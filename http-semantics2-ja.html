<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Semantics （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP Semantics
trans_update:2020-10-08
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
abbr_url:HTTPsem
spec_status:IETFID
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls

CONNECT:HTTP/Methods/CONNECT
DELETE:HTTP/Methods/DELETE
GET:HTTP/Methods/GET
HEAD:HTTP/Methods/HEAD
OPTIONS:HTTP/Methods/OPTIONS
POST:HTTP/Methods/POST
PUT:HTTP/Methods/PUT
TRACE:HTTP/Methods/TRACE

field.accept-charset:HTTP/Headers/Accept-Charset
field.accept-encoding:HTTP/Headers/Accept-Encoding
field.accept-language:HTTP/Headers/Accept-Language
field.accept-ranges:HTTP/Headers/Accept-Ranges
field.accept:HTTP/Headers/Accept
field.allow:HTTP/Headers/Allow
	field.authentication-info:HTTP/Headers/Authentication-Info
field.authorization:HTTP/Headers/Authorization
field.connection:HTTP/Headers/Connection
field.content-encoding:HTTP/Headers/Content-Encoding
field.content-language:HTTP/Headers/Content-Language
field.content-length:HTTP/Headers/Content-Length
field.content-location:HTTP/Headers/Content-Location
field.content-range:HTTP/Headers/Content-Range
field.content-type:HTTP/Headers/Content-Type
field.date:HTTP/Headers/Date
field.etag:HTTP/Headers/ETag
field.expect:HTTP/Headers/Expect
field.from:HTTP/Headers/From
field.host:HTTP/Headers/Host
field.if-match:HTTP/Headers/If-Match
field.if-modified-since:HTTP/Headers/If-Modified-Since
field.if-none-match:HTTP/Headers/If-None-Match
field.if-range:HTTP/Headers/If-Range
field.if-unmodified-since:HTTP/Headers/If-Unmodified-Since
field.last-modified:HTTP/Headers/Last-Modified
field.location:HTTP/Headers/Location
	field.max-forwards:HTTP/Headers/Max-Forwards
field.proxy-authenticate:HTTP/Headers/Proxy-Authenticate
	field.proxy-authentication-info:HTTP/Headers/Proxy-Authentication-Info
field.proxy-authorization:HTTP/Headers/Proxy-Authorization
field.range:HTTP/Headers/Range
field.referer:HTTP/Headers/Referer
field.retry-after:HTTP/Headers/Retry-After
field.server:HTTP/Headers/Server
field.te:HTTP/Headers/TE
field.trailer:HTTP/Headers/Trailer
field.upgrade:HTTP/Headers/Upgrade
field.user-agent:HTTP/Headers/User-Agent
field.vary:HTTP/Headers/Vary
field.via:HTTP/Headers/Via
field.www-authenticate:HTTP/Headers/WWW-Authenticate

status.codes:HTTP/Status
status.100:HTTP/Status/100
status.101:HTTP/Status/101
status.200:HTTP/Status/200
status.201:HTTP/Status/201
status.202:HTTP/Status/202
status.203:HTTP/Status/203
status.204:HTTP/Status/204
status.205:HTTP/Status/205
status.206:HTTP/Status/206
status.300:HTTP/Status/300
status.301:HTTP/Status/301
status.302:HTTP/Status/302
status.303:HTTP/Status/303
status.304:HTTP/Status/304
status.305:HTTP/Status/305
status.306:HTTP/Status/306
status.307:HTTP/Status/307
status.308:HTTP/Status/308
status.400:HTTP/Status/400
status.401:HTTP/Status/401
status.402:HTTP/Status/402
status.403:HTTP/Status/403
status.404:HTTP/Status/404
status.405:HTTP/Status/405
status.406:HTTP/Status/406
status.407:HTTP/Status/407
status.408:HTTP/Status/408
status.409:HTTP/Status/409
status.410:HTTP/Status/410
status.411:HTTP/Status/411
status.412:HTTP/Status/412
status.413:HTTP/Status/413
status.414:HTTP/Status/414
status.415:HTTP/Status/415
status.416:HTTP/Status/416
status.417:HTTP/Status/417
status.418:HTTP/Status/418
status.422:HTTP/Status/422
status.426:HTTP/Status/426
status.500:HTTP/Status/500
status.501:HTTP/Status/501
status.502:HTTP/Status/502
status.503:HTTP/Status/503
status.504:HTTP/Status/504
status.505:HTTP/Status/505


●●link_map
h.Received:~RFCx/rfc5322#section-3.6.7
h.Accept-Patch:~HTTPpatch#accept-patch
		RFC5789/3.1:~HTTPpatch#section-3.1
h.Keep-Alive:~HTTPmsg#compatibility.with.http.1.0.persistent.connections
h.Proxy-Connection:~HTTPmsg#compatibility.with.http.1.0.persistent.connections

h.If:~RFCx/rfc4918#section-10.4
h.Digest:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#digest
h.Origin:~FETCH#http-origin
	h.Origin:~RFCx/rfc6454#section-4

p.Accept-Charset:~HTTPsem#p.Accept-Charset
p.Accept-Encoding:~HTTPsem#p.Accept-Encoding
p.Accept-Language:~HTTPsem#p.Accept-Language
p.Accept-Ranges:~HTTPsem#p.Accept-Ranges
p.Accept:~HTTPsem#p.Accept
p.Allow:~HTTPsem#p.Allow
p.Authentication-Info:~HTTPsem#p.Authentication-Info
p.Authorization:~HTTPsem#p.Authorization
p.Connection:~HTTPsem#p.Connection
p.Content-Encoding:~HTTPsem#p.Content-Encoding
p.Content-Language:~HTTPsem#p.Content-Language
p.Content-Length:~HTTPsem#p.Content-Length
p.Content-Location:~HTTPsem#p.Content-Location
p.Content-Range:~HTTPsem#p.Content-Range
p.Content-Type:~HTTPsem#p.Content-Type
p.Date:~HTTPsem#p.Date
p.ETag:~HTTPsem#p.ETag
p.Expect:~HTTPsem#p.Expect
p.From:~HTTPsem#p.From
p.Host:~HTTPsem#p.Host
p.If-Match:~HTTPsem#p.If-Match
p.If-Modified-Since:~HTTPsem#p.If-Modified-Since
p.If-None-Match:~HTTPsem#p.If-None-Match
p.If-Range:~HTTPsem#p.If-Range
p.If-Unmodified-Since:~HTTPsem#p.If-Unmodified-Since
p.Last-Modified:~HTTPsem#p.Last-Modified
p.Location:~HTTPsem#p.Location
p.Max-Forwards:~HTTPsem#p.Max-Forwards
p.Proxy-Authenticate:~HTTPsem#p.Proxy-Authenticate
p.Proxy-Authentication-Info:~HTTPsem#p.Proxy-Authentication-Info
p.Proxy-Authorization:~HTTPsem#p.Proxy-Authorization
p.Range:~HTTPsem#p.Range
p.Referer:~HTTPsem#p.Referer
p.Retry-After:~HTTPsem#p.Retry-After
p.Server:~HTTPsem#p.Server
p.TE:~HTTPsem#p.TE
p.Trailer:~HTTPsem#p.Trailer
p.Upgrade:~HTTPsem#p.Upgrade
p.User-Agent:~HTTPsem#p.User-Agent
p.Vary:~HTTPsem#p.Vary
p.Via:~HTTPsem#p.Via
p.WWW-Authenticate:~HTTPsem#p.WWW-Authenticate

c.bytes:~HTTPsem#_bytes
c.q:~HTTPsem#c.q
c.trailers:~HTTPsem#_trailers-token
c.message/http:~HTTPmsg#media.type.message.http
c.none:~HTTPsem#range-none
c.application/octet-stream:~RFCx/rfc2046#section-4.5.1

sdir.immutable:~RFC8246#cache-response-directive.immutable
sdir.no-transform:~HTTPcache#cache-response-directive.no-transform

		:#rule.token.separators
		:#rule.quoted-pair
		:#rule.parameter
		:#rule.ranges-specifier
		:#rule.ranges-specifier.suffix

		p.range-unit:#range.units
		p.first-pos:#rule.int-range
		p.int-range:#rule.int-range
		p.last-pos:#rule.int-range
		p.other-range:#rule.other-range
		p.range-set:#rule.ranges-specifier
		p.range-spec:#rule.ranges-specifier
		p.ranges-specifier:#rule.ranges-specifier
		p.suffix-length:#rule.suffix-range
		p.suffix-range:#rule.suffix-range


役割:~HTTPinfra#role
	~secure化:~HTTPinfra#secured
絶対~形:~HTTPinfra#p.absolute-URI
~scheme:~HTTPinfra#p.scheme
~host:~HTTPinfra#p.host
~port:~HTTPinfra#p.port
生成元:~HTTPinfra#uri-origin

接続~option:#connection-option
既定の重み:#defult-weight
形式変換ng~proxy:#transforming-proxy
最終-受信者:#final-recipient
強い:#strong-validator
弱い:#weak-validator
不透明:#opaque
評価-:#evaluation

base64:~4648#section-4
base64url:~4648#section-5
base32:~4648#section-7
base16:~4648#section-8
~lock:~RFCx/rfc4918#section-6

新鮮:~HTTPcache#fresh
	再検証:~HTTPcache#revalidating
無効化-:~HTTPcache#invalidate
	無効化-:~HTTPcache#invalidation
~cache指令:~HTTPcache#cache-directive
~cache鮮度:~HTTPcache#expiration.model
空~行l:~HTTPmsg#empty-line

要請~密入~攻撃:~HTTPmsg#request.smuggling

cite.内容~符号法~registry:~IANA-a/http-parameters
cite.~HTTP範囲~単位~registry:~IANA-a/http-parameters
cite.~HTTP状態s~code~registry:~IANA-a/http-status-codes
cite.~HTTP認証~scheme~registry:~IANA-a/http-authschemes

r.BCP13:~HTTPinfra#BCP13
r.Caching:~HTTPinfra#Caching
r.Err1912:~HTTPinfra#Err1912
r.Err5433:~HTTPinfra#Err5433
r.Messaging:~HTTPinfra#Messaging
r.REST:~HTTPinfra#REST
r.RFC1950:~HTTPinfra#RFC1950
r.RFC1951:~HTTPinfra#RFC1951
r.RFC1952:~HTTPinfra#RFC1952
r.RFC2045:~HTTPinfra#RFC2045
r.RFC2046:~HTTPinfra#RFC2046
r.RFC2068:~HTTPinfra#RFC2068
r.RFC2295:~HTTPinfra#RFC2295
r.RFC2324:~HTTPinfra#RFC2324
r.RFC3986:~HTTPinfra#RFC3986
r.RFC4648:~HTTPinfra#RFC4648
r.RFC4918:~HTTPinfra#RFC4918
r.RFC5322:~HTTPinfra#RFC5322
r.RFC5646:~HTTPinfra#RFC5646
r.RFC5789:~HTTPinfra#RFC5789
r.RFC6265:~HTTPinfra#RFC6265
r.RFC6365:~HTTPinfra#RFC6365
r.RFC7231:~HTTPinfra#RFC7231
r.RFC7538:~HTTPinfra#RFC7538
r.RFC7578:~HTTPinfra#RFC7578
r.RFC7616:~HTTPinfra#RFC7616
r.RFC7617:~HTTPinfra#RFC7617
r.RFC7694:~HTTPinfra#RFC7694
r.RFC8246:~HTTPinfra#RFC8246
r.RFC8288:~HTTPinfra#RFC8288
r.RFC8446:~HTTPinfra#RFC8446
r.Sniffing:~HTTPinfra#Sniffing
r.Welch:~HTTPinfra#Welch

	●§
著作者の~address:~HTTPinfra#rfc.authors

3.7:~HTTPinfra#intermediaries
4:~HTTPinfra#uri
5.1:~HTTPinfra#protocol.version
5.6:~HTTPinfra#trailer.fields
5.7.1:~HTTPinfra#abnf.extension
7.2:~HTTPsem#representation.data
7.4.2:~HTTPsem#charset
7.9:~HTTPsem#response.validator
7.9.2.2:~HTTPsem#lastmod.comparison
10.3:~HTTPsem#challenge.and.response
11.1:~HTTPsem#proactive.negotiation
12.2:~HTTPsem#evaluation
12.3:~HTTPsem#precedence
15.1:~HTTPinfra#method.extensibility
15.2:~HTTPinfra#status.code.extensibility
15.3.1:~HTTPinfra#field-name.registry
15.5:~HTTPinfra#range.unit.extensibility
15.5.1:~HTTPinfra#range.unit.registry
15.6:~HTTPinfra#content.coding.extensibility
15.7:~HTTPinfra#upgrade.token.registry
16:~HTTPinfra#security.considerations
16.3:~HTTPinfra#attack.pathname
16.5:~HTTPinfra#attack.protocol.element.length
16.9:~HTTPinfra#sensitive.information.in.uris
16.12:~HTTPinfra#fingerprinting
16.14:~HTTPinfra#overlapping.ranges
16.15.1:~HTTPinfra#confidentiality.of.credentials

Caching/4.1:~HTTPcache#caching.negotiated.responses
Caching/4.2.2:~HTTPcache#heuristic.freshness
Caching/4.3.4:~HTTPcache#freshening.responses
Caching/3.3:~HTTPcache#caching.authenticated.responses
Caching/4.3.2:~HTTPcache#validation.received
Caching/4.3.5:~HTTPcache#head.effects
Caching/4:~HTTPcache#constructing.responses.from.caches
Messaging/3.3:~HTTPmsg#reconstructing.target.uri
Messaging/6.2:~HTTPmsg#body.content-length
Messaging/9.6:~HTTPmsg#persistent.tear-down
Messaging/B:~HTTPmsg#differences.between.http.and.mime

●●words_table1

●●words_table

	●network環境
UNIX:
IP:
HTTP-to-HTTP:
intercept:
interception:
	~frame法:framing
	~frame化:framing

	●構文
US-ASCII:
hyphen::::ハイフン
semicolon::::セミコロン
縮約-:collapse:~
小数点:decimal point:~
数字列:numerals:~
改行:line break:~
wildcard::::ワイルドカード
	片:fragment
構成-:compose:~
	構成し直-:recompose
	構文~的に:syntactically
固定的:fixed:~
	前後:-
alphabet::::アルファベット
filename::::ファイル名
切落す:truncateする:切り落とす

	●範囲
部分範囲:subrange::~
単位:unit:~
区分-:partition:~
	~~尾部:suffix
	先頭:beginning
	列:sequence
	~address可能:addressable

	●保安
malware::::マルウェア
密入:smuggling::~
非公開の:non-publicな:~
本物の:realな:~
迂回-:bypass:~
whitelist::::ホワイトリスト
spam::::スパム
防ぐ:prevent する:~
製品:product::~
下位製品:subproduct::~
検査情報:check:~
不用意:accidental:~
被保護:protected:~
受動的:passive:~
	晒し:expose
	~secure化:secured
	~secure化されてない:unsecured
	誤って~directされた:misdirected

	●仕様
critical:
scale::::スケール
	~scale能:scalability
主張-:claim:~
確立:establishment::~
無視r:disregard:無視することに
不整合:inconsistency:~
放棄-:abandon:~
拒否-:refuse:~
奇妙:bizarre:~
引換関係:trade-off:引き換え関係
想定-:suppose:~
想起-:envision:~
発見:discovery:~
指示書き:instruction:~
機能:function:~
仮の:hypotheticalな:~
招いて:inviteして:~
衝突:collision:~
衝突-:collide:~
誂えら:tailorさ:あつらえら
誂える:tailorする:あつらえる
無用:useless:~
心配:fear:~
負担:burden:~
特典:benefit:~
無差別:indiscriminate:~
請求-:demand:~
放置:inactivity:~
協力的:cooperative:~
短絡:short-circuit:~
特殊用途の:special-purpose:~
理解度:intelligibility:~
直交的:orthogonal:独立
一助:help:~
価値:value:~
浪費-:waste:~
アタリマエ:ubiquitous::あたりまえ
兆候:signal:~
改訂履歴:revision::~
不作為:inadvertent:~
木目細かな:fine-grainedな:~
最大化する:maximizeする:最大限に得る
正当化-:justify:~
楽観的:optimistic:~
不許可に:disallow:~
厳格:stringent:~
排する:eliminateする:~
周知の:well-knownな:~
理想的:ideal:~
自己決定的:self-determined:~
等価性:equivalency:~
裁量:discretion:~
通告-:advise:~
過度:excessive:~
管轄:administrative domain:~
変種:variant:~
満足可能:satisfiable:~
信頼性:reliability:~
介入-:intervene:~
綴り:spell:~
拡げる:expandする:~

	IESG
	実効:effective
	~~見かけ上:apparently
	~~精確に~~述べる:delineate
	~~適した:readily
	~~手間を要する:suffers from the
	~~勧める:advised to
	〜とも呼ばれる:a.k.a
	すなわち:a.k.a
	よって:hence
	~~基準に:with respect to
	基づくようにする:with respect to 〜 by phrasing

	問わず:regardless／
	~~可能性がある:potential
	かねない:potentially
	~~可能性:potentially
	〜としても:potential
	なり得る:potential
	おそれがある:potential as
	とても:very
	は別として／の他に／以外:aside from
	優先:take precedence over
	視る:view
	今や:now
	好ましい:preferable
	用意はない:unwilling
	用意があった:willing to
	また，:In turn
	~~責務者:person responsible for
	それぞれの:respective
	~~見做され:presumed
	~~前提:presume
	再利用-能:reusability

	相互運用するため:for the sake of interoperating
	跡をなぞる:trace
	整合性:consistent with
	~~働く:act
	~~非常:unusual
	~~価する:worthwhile
	~~馴染んで:familiar with
	挙げられ:mention
	~~無為に:circumvents
	必要とされてはいないが:, but not necessarily
	~~関知:held accountable for
	くだけて言えば:Informally／:Verbally
	-:pertaining
	適宜:as appropriate
	~~長年にわたり:for a long time
	予約-済みでない:unreserved
	反して:against
	害を及ぼす:causing harm
	~~考えられがち:tempting to think of
	~~受容し易い:amenable
	~~強いるものではない:not prevent
	~~望ましくない:unfortunate
	~~落と:markdown
	反し:contrary
	大きく:highly
	It knows that:わかっている
	~~特徴がある:distinguished
	他にもある:(among others)
	解さなければならない:must-understand
	に関して指令する:has some direction regarding
	はるかに:far more
	誰かが〜たいていは:people
	力点が置かれる所:focus
	無分別:foolish
	込み入った:elaborate
	話す:speak する
	〜から:by virtue of
	多少を問わず:more or less than
	言って:say
	滅多にない:seldom
	指定されていない:unspecified
	ほぼ:nearly
	よく似る:very similar
	前項に代えて:Alternatively
	きちんと:well-
	不必要に:Overly
	〜に関わる:What matters to〜
	~~悪影響:adverse impact
	~~委ね:left to
	陥った:descended into
	もちろん:obvious
	あろうとし続ける:tries to remain
	たとえ:albeit
	~~誤った:erroneous
	~~間違い:wrong
	~~困難でない:feasible
	~~困難でない:unless not feasible
	~~困難:unfeasible
	~~記述するもの:descriptive
	~~正しくない:malformed
	どっちつかず:noncommittal
	ついて~~合意が得られなかった:disagreement over
	~~誤認を誘うもの:deceptive
	~~注意して行う:done with care
	鶏と卵:chicken-and-egg
	事実がなかった:were not for the fact
	~~理由:because
	~~同類の:sibling
	~~観点:considerations
	~~支持:support
	~~効率が落ちる:less efficiently
	用心:guard
	から見て:perspective
	もの:flavor
	対象に:over
	課す:impose
	~~最大の:best
	あまり〜でない:far less
	~~支配的:prevailing
	視野を絞る:identify the scope
	代わるもの:replacement
	依存-:dependent
	運用~上の:operational
	拘束されない:unconstrained
	してもらう:encourage
	向こう側で 独立に動作する者:independent actor on the other side
	特に関心を引くもの:of particular interest
	類する:analogous な
	“同じさの質”: “sameness” ~quality
	同じさ度合い:sameness
	ならない見込みが高い:unlikely
	まずない:unlikely
	やり方:fashion
	いずれにせよ、:Regardless,
	手引き:help guide
	~~併用:with
	全面的:entirely
	大多数:overwhelming majority
	環境設定し直す:reconfigure
	安全か否か:between safe and unsafe
	に宛てて:target
	~~大体~同じ:around the same
	組で:together
	分かれる:split
	査定:assessment of

	●事例
家電:home appliance:~
分析:analysis:~
解析:analytics:~
医療:medical:~
科学的:scientific:~
画像処理:imaging:~
投函-:post:~
目録:catalog::~::カタログ
ニュースグループ:newsgroup:::~
メーリングリスト:mailing list:::~
ブログ:blog:::~
課金:charge:~
記事:article:~
広告料:advertising account:~
	広告-用:advertising
掲示板:bulletin board:~
英国:British:~
言語上の:linguistic:~
	inline:in-line
仮装-:masquerade:~
誤入力:mistype:~
SMTP:
Canada::カナダ
Danish::デンマーク語
Maori::マオリ語
入門書:primer:~
初学者:beginner:~
紙:paper:~
購入:purchase:~
領収書:receipt document:~
加工-:craft:~
	臨時の販促:limited-time, promotional
満杯:full:~
編集-:edit:~
編集:editing:~
	~link編集:link-editing
traversal:
探索:search::検索
notepad::::ノートパッド
一括的:batch-oriented:~
会話-:communicate:~
	英語の一方言:variety of English
	ワイタンギ条約:Treaty of Waitangi
	富士山:Laguna Beach
	天気:weather
	天気~予報:weather report

	●未分類
透過的:transparent::~
逐語的:verbatim:~
routine::::ルーチン
pipe::::パイプ
digital::::デジタル
完全修飾:fully qualified::~
参照先の:referenced:~
変名:variation:~
後続-:follow:~
仮想:virtual::~
総計:total:~
増分的:incremental:~
増分:increment:~
	増やす:increase
peer::::ピア
保つ:keepする:~
sniff:
	~sniff法:sniffing
分散-:distribute:~
排他的:mutually exclusive:~
窓:window:~
符号化形:coded form::~::コード化形
自動解凍-:automatic に decompress:~
視聴者:audience:~
話者:-literate audience:~
配達:deployment:~
遅い:slowな:~
選好順:descending preference の order:選好度の高い順
処理命令:processing instructions:~
時間的:temporal:~
再検証:revalidation::~
新鮮:fresh::~
差控える:forgoする:差し控える
不変:unchanged:~
後側の:later:~
backup::::バックアップ
deactivate:::非 active 化:非アクティブ化
loop-back::::ループバック
読専:read-only:読み取り専用
閉な:closed:閉じた
上書-:overwrite::上書き
可分:non-atomic:~

semaphore::::セマフォ
拡がり:expansion:~
透過性:transparency::~
	:refer
間隙:gap:~
和集合:union:~
連続的:continuous:~
完結:finalization:~
分解能:resolution:~
整形式:well-formed:~
枯渇-:exhaust:~
	枯渇-:exhaustion of
循環的:cyclical:~
耐衝突:collision-resistant:~
無限loop:black hole::無限ループ
	最後に改変された:last-modified
real-time:::リアルタイム
辿る:traverseする:~
構文上は:syntacticには::~
変動-:vary::~
変動:variance::~
発行i:issue:発行

	~~獲得-:gain
	^en:deep linking
	~~実行済みで:enact されて
	~~最新な:up-to-date な
	その場を占める:take the place of
	入って来る:incoming
	始める:begin
	その場で:on the fly
	~~遡る:follow 〜 back to
	型~付け:typing
	失われ:lost
	失われ:lose
	0 〜 1 個の／ 0 個以上の~potential
	32-bit
	CRC
	LZ77
	Huffman
	zlib
	渡-:pass
	最下~層のものから昇順に:layer-ascending order
	？:conclude
	不在:absence
	秒:seconds
	秒単位:every second／single second／one-second
	秒単位より細かい:sub-second
	定まる秒~数の間:during the second covered by

	●言い換え
	〜な時間内に:within 〜 period of time
	期間:period of time
	範囲に含まれ:inclusive／inclusive numbered parts
	結合し直:recombine
	~~完全に:quite
	利用者に知覚される:user-perceived
	~~増やす:degrade
	現れる:appear
	再掲-:restate
	~~連続する一連の:ordered subsequence
	最短:minimum
	等しく:equally
	直近:immediate
	ごく小さな割合:small percentage
	埋め~~始め:starts filling
	~~埋め込まれ:within
	~~時区間:window
	~~過去に戻る:back in time
	~~過去の:earlier
	~~過去:before
	~~巨大:huge:巨大
	築く:building
	群:group of
	様々な~~断片:dimension
	要請-中にある:being requested
	-:speaking
	から来た:came from
	-:highlighted by
	~~元に戻す:undo
	戻れる~link:back-links
	返送:back
	同期-に乏しい:poorly synchronized
	先頭部分:prefix
	単独の部位t:single-part
	継続-中:continuing
	~linkし直す:re-link
	提出し直-:resubmit
	計算し直-:recalculate
	~~遠い:distant
	~~相対的:against
	検証-用:validating

	●他の語
	一種／:variation
	次に挙げるものなど:including (but not limited to)
	1 個の:exactly one
	初回:first time
	次回:second
	次回:next
	多種多様:wide variety of
	~~位置:offset
	位置:position
	位置／番:offset
	~~事前:before actually doing so
	~~直に~code化:hard-coded
	~~領域:space
	もたらす／:cause
	一連の:sequence
	圧縮-済み:compressed
	~~一過性の:transitory
	~~正常に~~処理されました。:It worked!
	~~単独の:bare
	~~伝える:tell
	際限なく続く:unbounded
	何であろうが:anything
	~~直前:-
	~~直前:just prior to
	保存…:…Save as ...
	短い:short
	ほぼ:mostly
	最終的:ultimately
	各自の:own
	各部:parts
	次に:next
	指す:point to
	短か過ぎる:too short
	~escapeを外そ:unescaping
	~~現在時:current instance
	-:located
	通過-:passed through
	~~部署:office and regional
	~~風刺-:lampoon
	~hypertext:hypertext note
	~~細切れにされた:small disjoint
	~~細切れ:small
	~~若い:younger
	徐々に:gradually
	〜分間:minutes
	日に一度だけ:once per day
	適量:appropriate amount
	代えて:supplant
	~~確定していない:might or might not
	するとき／しないとき:might or might not
	~~消失した:gone

	他方の:one of the two
	離れて他へ:away from
	いつまでも:any length of time
	いつまでか:how long
	ときには:occasional
	その時々:on occasion
	~~直前:just before
	直後:immediately after
	個々人:individual


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP Semantics</a>
の
§ 8 〜 § 14
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1 title="HTTP Semantics">HTTP 意味論（ Semantics ）</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

<p class="trans-note">【
この~pageでは、~HTTP意味論を成す内容のうち，
§ 6 〜 § 14 を述べる。
仕様の~metadata情報は、
<a href="~HTTPinfra">~HTTP意味論（共通基盤）</a>
を参照されたし。
】</p>

<main id="MAIN0">
	<section id="routing">
<h2 title="Routing">6. ~route法</h2>

<p>
~HTTPは、一般用~computerから家電までに渡る，多種多様な応用で利用される。
一部の事例では、通信~optionは，~clientの環境設定~内に~~直に~code化されている。
しかしながら，ほとんどの~HTTP~clientは、一般用~Web~browserと同じ［
`資源$を識別するための仕組みと, 環境設定~技法
］に依拠する。
◎
HTTP is used in a wide variety of applications, ranging from general-purpose computers to home appliances. In some cases, communication options are hard-coded in a client's configuration. However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers.
</p>

<p>
~HTTP要請~messageの~route法は、各`~client$により，次に基づいて決定される
⇒＃
`~target資源$,
~clientの~proxy環境設定,
`内方$への接続の確立／再利用
◎
HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection.＼
</p>

<p>
対応する応答の~route法は、同じ接続`連鎖$を，~clientまで~~遡る。
◎
The corresponding response routing follows the same connection chain back to the client.
</p>

		<section id="target.resource">
<h3 title="Target Resource">6.1. ~target資源</h3>

			<section id="request.target">
<h4 title="Request Target">6.1.1. 要請~target</h4>

<p>
`要請~target@
は、
`~target資源@
を識別する~protocol要素である。
◎
The "request target" is the protocol element that identifies the "target resource".
</p>

<p>
`要請~target$は、概して，`~URI参照$である
— `~UA$は、この~URIを`絶対~形$に解決して，
`~target~URI@
を得することになる。
参照~内の素片（ `fragment$p ）成分は、在っても，~target~URIからは除外される
— 素片~識別子は、`~client$側の処理（ `RFC3986/3.5$sec ）に予約されているので。
◎
Typically, the request target is a URI reference (Section 4) which a user agent would resolve to its absolute form in order to obtain the "target URI". The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([RFC3986], Section 3.5).
</p>

<p>
しかしながら、次に挙げる，~methodに特有な特別な形があり、特定の状況下で`要請~target$用に許容される：
◎
However, there are two special, method-specific forms allowed for the request target in specific circumstances:
</p>
<ul>
	<li>
`CONNECT$m 用には
⇒
`要請~target$は、`~tunnel$の行先を与える，~colonで分離された［
~host名と~port番号
］になる。
◎
For CONNECT (Section 8.3.6), the request target is the host name and port number of the tunnel destination, separated by a colon.
</li>
	<li>
`OPTIONS$m 用には
⇒
`要請~target$は、 1 個の~asterisk（ "`*^c" ）にもなり得る。
◎
For OPTIONS (Section 8.3.7), the request target can be a single asterisk ("*").
</li>
</ul>

<p>
詳細は、それぞれの~method定義を見よ。
これらの形は、他の~methodとともに利用されてはナラナイ。
◎
See the respective method definitions for details. These forms MUST NOT be used with other methods.
</p>
			</section>
			<section id="field.host">
<h4>6.1.2. `Host^h</h4>

<p>
要請~内の `Host^h ~headerは、`~target~URI$からの［
`host$p ＆ `port$p
］情報を供して、`生成元~server$が［
単独の~IP~address上にて複数の~host名に対する要請
］を~serviceしている間でも，`資源$を互いに判別できるようにする：
◎
The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.
</p>

<pre class="bnf">
`Host@p
    = `uri-host$p [ ":" `port$p ] ; `4$sec
</pre>

<p>
`Host$h の`~field値$は，要請を取扱うときに~criticalな情報なので、`~UA$は，
`Host$h を`~header節$の中の最初の~fieldとして`生成する$ベキである。
◎
Since the Host field value is critical information for handling a request, a user agent SHOULD generate Host as the first field in the header section.
</p>

<div class="example">
<p>
例えば、
`http://www.example.org/pub/WWW/^c
用の`生成元~server$へ向けた `GET$m 要請 は、次で始まることになろう：
◎
For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</p>

<pre class="lang-http">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</pre>
</div>

<p>
`Host$h ~headerは，応用~levelの~route法の仕組みとして動作するので、~malwareにとっては，`共用~cache$を汚染したり,
要請を意図されていない`~server$へ~redirectさせる，格好の標的になる。
~interception`~proxy$は、［
要請を内部~serverへ~redirectする／`共用~cache$内の~cache~keyとして利用する
］ときに `Host$h `~field値$に依拠していて，［
~interceptされた接続が，当の~host用の妥当な~IP~addressを~targetにしているかどうか
］を最初に検証yしていない場合には、特に脆弱になる。
◎
Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the Host field value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.
</p>

			</section>
			<section id="reconstructing.target.uri">
<h4 title="Reconstructing the Target URI">6.1.3. ~target~URIの再構築-法</h4>

<p>
`内方$への接続を得したなら、`~client$は，~HTTP要請~messageを送信する。
◎
Once an inbound connection is obtained, the client sends an HTTP request message.
</p>

<p>
~clientの~target~URIは、当の要請の資質に依存して，要請~messageを成す様々な各部の中へ 何~成分かに分割されて，伝送される（または含意される）こともある。
各~受信者は、［
各自の局所的な環境設定, 入って来る接続の文脈
］に則って，`~target~URI$を決定する。
~serverが~HTTP11要請~用に~target~URIを決定する方法は、
`Messaging/3.3$sec
が定義する。
◎
Depending on the nature of the request, the client's target URI might be split into components and transmitted (or implied) within various parts of a request message. These parts are recombined by each recipient, in accordance with their local configuration and incoming connection context, to determine the target URI. Section 3.3 of [Messaging] defines how a server determines the target URI for an HTTP/1.1 request.
</p>

<div class="p">
<p>
`~target~URI$が再構築されたなら、`生成元~server$は，［
その~URIに対する~serviceを，［
要請が受信された接続
］を介して供するかどうか
］を裁定する必要がある。
例えば，受信した要請の `Host$h ~headerの中の情報は、故意に, あるいは不用意に誤って［
接続が為された［
`~host$＆`~port$
］とは相違する何か
］を~directしているかもしれない。
信用された`~gateway$からの接続であれば，その不整合は予期されたものかもしれないが、他の場合，次の試みを指示しているかもしれない
⇒＃
~security~filterを迂回する ／
非公開の内容を送達させるよう，~serverを騙す ／
~cacheを汚染する
◎
Once the target URI has been reconstructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received. For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received Host header field differs from the host or port upon which the connection has been made. If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.＼
</p>

<p>
~messageの~route法に関する~securityの考慮点は、
`16$sec を見よ。
◎
See Section 16 for security considerations regarding message routing.
</p>
</div>

<p class="note">注記：
以前の仕様は、構成し直した~target~URIを，別個な概念として
<dfn id="effective.request.uri">実効~要請~URI</dfn>
（ `effective request URI^en ）と定義していた。
◎
Note: previous specifications defined the recomposed target URI as a distinct concept, the effective request URI.
</p>

			</section>
		</section>
		<section id="routing.inbound">
<h3 title="Routing Inbound">6.2. 内方への~route法</h3>

<p>
`~target~URI$と その`生成元$が決定されたなら、`~client$は，次を裁定する
⇒＃
欲された意味論を成遂げるためには，~network要請が必要とされるかどうか／
必要とされるなら，その要請をどこへ~directするか
◎
Once the target URI and its origin are determined, a client decides whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.
</p>

			<section id="routing.cache">
<h4 title="To a Cache">6.2.1. ~cacheへの~route法</h4>

<p>
`~client$が`~cache$ `Caching$r を備えていて, かつ
それにより要請を満足できる場合、要請は，通例的に，最初にそこへ~directされる。
◎
If the client has a cache [Caching] and the request can be satisfied by it, then the request is usually directed there first.
</p>

			</section>
			<section id="routing.proxy">
<h4 title="To a Proxy">6.2.2. ~proxyへの~route法</h4>

<p>
代表的な`~client$は、［
要請が`~cache$により満足できない
］場合に［
要請を満足するために利用される`~proxy$があるかどうか
］を決定するため，自身の環境設定を検査することになる。
~proxy環境設定は、実装に依存するが，［
~URI接頭辞の照合,
選択的な権限の照合,
または この両者
］に基づくことが多く、~proxy自身は，通例的に［
"`http$c" ／ "`https$c"
］~URIにより識別される。
適用-可能な`~proxy$がある場合、~clientは，［
その~proxyへの接続を確立する（または再利用する）
］ことにより，`内方$へ接続する。
◎
If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI. If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy.
</p>

			</section>
			<section id="routing.origin">
<h4 title="To the Origin">6.2.3. 生成元への~route法</h4>

<p>
適用-可能な`~proxy$は無い場合、代表的な`~client$は，［
`~target資源$用の生成元へ直に接続する
］ために［
通例的に`~target~URI$の`~scheme$ごとに特有な，~handler~routine
］を呼出すことになる。
これが どう成遂げられるかは、~target~URIの`~scheme$に依存し，それを~~規定する仕様により定義される。
◎
If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an origin for the target resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification.
</p>

			</section>
		</section>
		<section id="response.correlation">
<h3 title="Response Correlation">6.3. 応答の相関</h3>

<p>
同じ接続が，複数の［
要請, 対する応答
］の交換に利用されることもある。
要請~messageと応答~messageとを相関するために利用される仕組みは、~versionに依存する
— ~HTTPのある~versionは~messageの暗黙的な順序付けを利用する一方で，他の~versionは明示的な識別子を利用する。
◎
A connection might be used for multiple request/response exchanges. The mechanism used to correlate between request and response messages is version dependent; some versions of HTTP use implicit ordering of messages, while others use an explicit identifier.
</p>

<p>
応答は（`最終-応答$, `暫定-応答$どちらも）、要請を受信した後のいつでも
— 要請がまだ完了していなくとも —
送信できる。
しかしながら，`~client$（`中継者$も含む）は、応答が適度な時間内に来なければ，要請を放棄することもある。
◎
Responses (both final and interim) can be sent at any time after a request is received, even if it is not yet complete. However, clients (including intermediaries) might abandon a request if the response is not forthcoming within a reasonable period of time.
</p>

		</section>
		<section id="message.forwarding">
<h3 title="Message Forwarding">6.4. ~messageの回送-法</h3>

<p>
`中継者$は
— `3.7$sec にて述べたように —
~HTTP［
要請, 応答
］の処理において，様々な`役割$を~serveし得る。
中継者には、［
処理能や可用性を改善する
］ために利用されるものもあれば，［
~accessを制御する／内容を~filterする
］ために利用されるものもある。
~HTTP~streamには，［
~pipe＆~filter
~architecture
］に類似な特性があるので、`中継者$が増強-（または干渉-）し得る限度には
— ~streamの方向を問わず —
内来的な制限は無い。
◎
As described in Section 3.7, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.
</p>

<p>
`~tunnel$として動作しない`中継者$は、
`Connection$h ~headerを，その節に指定されるとおりに実装しなければナラナイ
— 加えて，［
自身宛の接続のみに意図されている~field
］は、回送する際に除外しなければナラナイ。
◎
An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.4.1, and exclude fields from being forwarded that are only intended for the incoming connection.
</p>

<p>
`中継者$は、自身宛の~messageを回送してはナラナイ
— それが，無限~要請~loopから保護されていない限り【？】
。
一般に，`中継者$は、自前の~server名
— ［
別名,
局所的な変名,
~literal~IP~address
］も含む —
を認識して，そのような要請に対し直に応答する~OUGHT。
◎
An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.
</p>

<p>
~HTTP~messageは、［
増分的に処理する／`下流$へ回送する
］ときには，~streamとして構文解析できる。
しかしながら，`受信者$は、増分的~送達による部分的~messageには，依拠できない
— 一部の実装は、［
~network効率性,
~security検査,
`~payload$の`形式変換$
］の~~目的で，~message回送を~bufferしたり遅延するので。
◎
An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations.
</p>

			<section id="field.connection">
<h4>6.4.1. `Connection^h</h4>

<p>
`Connection^h ~headerは、［
現在の接続に欲される制御~option
］を~listすることを，`送信者$に許容する。
◎
The "Connection" header field allows the sender to list desired control options for the current connection.
</p>

<p>
`送信者$は、［
`Connection^h 以外の`~field$
］を［
現在の接続［
用／について
］の制御~情報を給する
］ために利用するときは，対応する`~field名$を `Connection^h ~headerの中に~listしなければナラナイ。
~HTTPの一部の~versionは、そのような情報~用に各~fieldを利用するのを禁制する
— したがって， `Connection^h ~fieldを許容しない —
ことに注意。
◎
When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field. Note that some versions of HTTP prohibit the use of fields for such information, and therefore do not allow the Connection field.
</p>

<div class="p">
<p>
`中継者$は、受信した~message `M^V を回送する前に，次を行わなければナラナイ：
◎
Intermediaries MUST＼
</p>
<ol>
	<li>
`M^V 内の `Connection^h ~header`~field値$を構文解析する。
◎
parse a received Connection header field before a message is forwarded and,＼
</li>
	<li>
前~段の結果を成す各 `connection-option$p に対し
⇒
`M^V から［
`connection-option$p と同じ名前を`~field名$に伴う［
`~header$／`~trailer$
］］をすべて除去する
◎
for each connection-option in this field, remove any header or trailer field(s) from the message with the same name as the connection-option, and then＼
</li>
	<li>
次のいずれかを行う
⇒＃
`M^V から `Connection^h ~headerを除去する／
`M^V 内の `Connection^h の値を 自前の`接続~option$で置換する
◎
remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).
</li>
</ol>
</div>

<p>
すなわち， `Connection^h ~headerは、［
直近の`受信者$のみに意図された（`隣点間$）`~field$
］と［
`連鎖$上にある すべての`受信者$に意図された（`端点間$）`~field$
］とを判別できるようにする，宣言的な仕方を供する
— それは、~messageを自己-記述的にすることで，［
古い`中継者$により盲目的に回送されるおそれ
］なく，［
接続ごとに特有な，将来の拡張
］を配備できるようにする。
◎
Hence, the Connection header field provides a declarative way of distinguishing fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.
</p>

<p>
さらに，`中継者$は、次に該当する各~fieldを
— ~fieldの意味論を適用した後に —
除去するか置換するベキである
⇒
その意味論は回送する前の除去を要求することが既知であるもの
— ~field名が `Connection^h の`接続~option$として出現するかどうかは問わない。
次に挙げる~fieldは，これに含まれるが、この限りでない
⇒＃
`Proxy-Connection$h `Messaging$r,
`Keep-Alive$h `RFC2068/19.7.1$sec,
`TE$h,
`Trailer$h,
`Transfer-Encoding$h `Messaging$r,
`Upgrade$h
◎
Furthermore, intermediaries SHOULD remove or replace field(s) whose semantics are known to require removal before forwarding, whether or not they appear as a Connection option, after applying those fields' semantics. This includes but is not limited to:
• Proxy-Connection (Appendix C.1.2 of [Messaging])
• Keep-Alive (Section 19.7.1 of [RFC2068])
• TE (Section 9.1.4)
• Trailer (Section 9.1.5)
• Transfer-Encoding (Section 6.1 of [Messaging])
• Upgrade (Section 6.6)
</p>

<p>
`Connection$h ~header`~field値$の文法は：
◎
The Connection header field's value has the following grammar:
</p>

<pre class="bnf">
`Connection@p
    = #`connection-option$p
`connection-option@p
    = `token$p
</pre>

<p>
`connection-option$p が各
`接続~option@
を与える。
それらは、文字大小無視である。
◎
Connection options are case-insensitive.
</p>

<p>
`送信者$は、`接続~option$として［
`~payload$を受け取るすべての`受信者$向けに意図された`~field$
］に対応するものは，送信してはナラナイ。
例えば， `Cache-Control$h は、接続~optionとしては，決して適切にならない。
◎
A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the payload. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [Caching]).
</p>

<p>
`接続~option$は，常に［
~message内に在る`~field$
］に対応するとは限らない
— 結付けられる~parameterがない接続~optionに対しては、［
接続ごとに特有な`~field$
］は不要になり得るので。
対照的に，［
対応する接続~optionを伴わずに受信された，接続ごとに特有な~field
］は、通例的に［
当の~fieldは`中継者$により不適正に回送された
］ことを指示するので，`受信者$は無視する~OUGHT。
◎
The connection options do not always correspond to a field present in the message, since a connection-specific field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.
</p>

<p>
仕様~策定者は，新たな`接続~option$を定義するときは、予約-済み`~field名$として文書~化した上で，その定義を
— 衝突を避けるよう —
`~HTTP~field名~registry^cite（ `15.3.1$sec ）に登録する~OUGHT。
◎
When defining new connection options, specification authors ought to document it as reserved field name and register that definition in the Hypertext Transfer Protocol (HTTP) Field Name Registry (Section 15.3.1), to avoid collisions.
</p>

			</section>
			<section id="field.max-forwards">
<h4>6.4.2. `Max-Forwards^h</h4>

<p>
`Max-Forwards^h ~headerは、`要請~method$［
`TRACE$m ／ `OPTIONS$m
］と伴に，［
要請が`~proxy$により回送される回数
］を制限する仕組みを供する。
これは、`~client$が［`連鎖$の途上で［
失敗する／~loopする
］ように出現する要請
］の跡をなぞろうと試みるとき，有用になり得る。
◎
The "Max-Forwards" header field provides a mechanism with the TRACE (Section 8.3.8) and OPTIONS (Section 8.3.7) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
</p>

<pre class="bnf">
`Max-Forwards@p
    = 1*DIGIT
</pre>

<p>
`Max-Forwards^h は、［
当の要請~messageを回送できる残りの回数
］を指示する~decimal整数を値にとる。
◎
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message can be forwarded.
</p>

<div class="p">
<p>
各 `中継者$は、
`Max-Forwards^h ~headerを包含している［
`TRACE$m ／ `OPTIONS$m 
］要請を受信したときは、要請を回送するに先立って，その値 `N^V を検査して更新しなければナラナイ。
`中継者$は、 `N^V に応じて：
◎
Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request.＼
</p>
<ul class="switch">
	<li>
`N^V ~EQ 0 の場合
⇒
要請を回送してはナラナイ
— 代わりに、`最終-受信者$として応答しなければナラナイ。
◎
If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient.＼
</li>
	<li>
他の場合（ `N^V ≥ 1 ）
⇒
回送する~message内に
`Max-Forwards^h ~header【！~field】を
— その`~field値$を次のうち最小に更新した上で —
`生成し$なければナラナイ
⇒＃
`N^V − 1,
当の受信者が `Max-Forwards^h 用に~supportする最大~値
◎
If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.
</li>
</ul>
</div>

<p>
`受信者$は、［
他の`要請~method$に伴って受信した `Max-Forwards^h ~header
］については，無視してもヨイ。
◎
A recipient MAY ignore a Max-Forwards header field received with any other request methods.
</p>

			</section>
			<section id="field.via">
<h4>6.4.3. `Via^h</h4>

<div class="p">
<p>
`Via$h ~headerは、中継~protocolが在ること, および［
要請においては `~UA$ ↔ ︎`~server$ 間にある`受信者$たち ／
応答においては `生成元~server$ ↔ `~client$ 間にある`受信者$たち
］を指示する。
それは、~emailにおける `Received$h ~header `RFC5322$r に類似する。
◎
The "Via" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the "Received" header field in email (Section 3.6.7 of [RFC5322]).＼
</p>

<p>
`Via$h は、次の用途に利用できる
⇒＃
各~message回送-の追跡 ／
要請~loopを避ける ／
［要請／応答］の`連鎖$沿いにある各~送信者の~protocol能力を識別する
◎
Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.
</p>
</div>

<pre class="bnf">
`Via@p
    = #( `received-protocol$p `RWS$p `received-by$p [ `RWS$p `comment$p ] )
`received-protocol@p
    = [ `protocol-name$p "/" ] `protocol-version$p【！; see `6.6$sec】
`received-by@p
    = `pseudonym$p [ ":" `port$p ]
`pseudonym@p
    = `token$p
</pre>

<p class="trans-note">【
“`pseudonym^p” ＝ “`pseudo^en” + “`anonymous^en” （ “~~疑似匿名（~~仮名）” ）
】</p>

<p>
`Via$h `~field値$を成す各~memberは、当の~messageを回送した［
`~proxy$／`~gateway$
］を表現する。
各`中継者$は、［
~messageがどう受信されたかについての，自前の情報
］を［
回送した`受信者$たちの順序が保たれる
］ように付加する。
◎
Each member of the Via field value represents a proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.
</p>

<div class="p">
<p>
`~proxy$は、以下に述べるように，回送する各~message内に適切な `Via$h ~headerを送信しなければナラナイ。
◎
A proxy MUST send an appropriate Via header field, as described below, in each message that it forwards.＼
</p>

<p>
~HTTP-to-HTTP`~gateway$は、回送する~messageが：
◎
An HTTP-to-HTTP gateway＼
</p>
<ul>
	<li>
`内方$への要請ならば、適切な `Via$h ~headerを送信しなければナラナイ。
◎
MUST send an appropriate Via header field in each inbound request message and＼
</li>
	<li>
【`外方$への】応答ならば、 `Via$h ~headerを送信してもヨイ。
◎
MAY send a Via header field in forwarded response messages.
</li>
</ul>
</div>

<p>
`received-protocol$p は、~messageの`下流$の`中継者$たちに対し，［
`上流$の`送信者$により利用された~protocol, その~version
］を指示する。
すなわち， `Via$h `~field値$は、［
要請／応答
］`連鎖$にて広告された~protocol能力を，`下流$の`受信者$から可視であり続けるように記録する
— これは、 `5.1$sec にて述べたように，［
後方-互換でない特能のうち，どれが［
応答／今後の要請
］の中で利用するときに安全になり得るか
］を決定するときに有用になり得る。
~~簡潔にするため、受信される~protocolが~HTTPであるときは，
`received-protocol$p 内の `protocol-name^p は省略される【されてもヨイ？】
。
◎
For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 5.1. For brevity, the protocol-name is omitted when the received protocol is HTTP.
</p>

<p>
`received-by$p を成す部位は、通常は［
受信者`~server$, または［
~messageを~~後続へ回送した`~client$
］］の［
`host$p, および省略可能な `port$p 番号
］になる。
しかしながら，［
本物の~hostは敏感な情報である
］と見なされる場合、`送信者$は，それを `pseudonym$p に置換してもヨイ。
`port$p が供されていない場合、`受信者$は，それを［
`received-protocol$p の既定の~TCP~port上で受信されたことを意味している
］と解釈してもヨイ
— 当の~protocolに既定の~TCP~portが定義されている限り。
◎
The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol.
</p>

<p>
`送信者$は、各`受信者$の~softwareを識別するために【識別する側とされる側が逆？】，
`comment$p を`生成し$てもヨイ
— ［
`User-Agent$h ／ `Server$h
］~headerに相似的な。
しかしながら，
`Via$h ~header内の~commentは任意選択であり、受信者は
— ~messageを回送するに先立って —
それらを除去してもヨイ。
◎
A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.
</p>

<div class="example">
<div class="p">
<p>
例えば，要請~messageが：
◎
For example, a request message could＼
</p>
<ol>
	<li>
~HTTP10`~UA$から［
~code名 "`fred^c" の内部~proxy
］に向けて送信され，
◎
be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred",＼
</li>
	<li>
その内部~proxyは，それを［
`p.example.net^c にある公共~proxy
］に向けて回送するときに~HTTP11を利用し，
◎
which uses HTTP/1.1 to forward the request to a public proxy at p.example.net,＼
</li>
	<li>
その公共~proxyは，それを［
`www.example.com^c にある`生成元~server$
］に向けて回送して，完了した
◎
which completes the request by forwarding it to the origin server at www.example.com.＼
</li>
</ol>

<p>
とするとき、
`www.example.com^c にて受信される要請には，次の `Via$h ~headerが在ることになろう：
◎
The request received by www.example.com would then have the following Via header field:
</p>
</div>

<pre class="lang-http">
Via: 1.0 fred, 1.1 p.example.net
</pre>
</div>

<p>
［
~network~firewallを通る~portal
］として利用される`中継者$は、明示的に可能化されていない限り，［
~firewall領域の中の各~host
］の［
名前＆~port
］を回送するベキでない。
可能化されていない場合、そのような`中継者$は，［
~firewallの背後の~hostを表すような，各 `received-by$p ~host
］を［
その~hostに適切な `pseudonym$p
］に置換するベキである。
◎
An intermediary used as a portal through a network firewall SHOULD NOT forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary SHOULD replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.
</p>

<p>
`中継者$は、
`Via$h ~headerの［
`received-protocol$p 値が互いに一致する，~~連続する一連の~list~member
］を，単独の~memberに結合してもヨイ。
◎
An intermediary MAY combine an ordered subsequence of Via header field list members into a single member if the entries have identical received-protocol values.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre>

<p>
は、次の様に縮約することもできる：
◎
could be collapsed to
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre>
</div>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
複数の~list~memberを 1 つに結合するベキでない
— ただし、［
それらすべてが同じ組織の制御~下にある
］かつ［
それらの~hostは すでに `pseudonym$p に置換されている
］場合は除く。
◎
A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.＼
</li>
	<li>
［
`received-protocol$p 値が互いに異なる，複数の~member
］を 1 つに結合してはナラナイ。
◎
A sender MUST NOT combine members that have different received-protocol values.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="message.transformations">
<h3 title="Transformations">6.5. 形式変換</h3>

<p>
一部の`中継者$は、［
~messageとその`~payload$
］を
`形式変換-@
するための特能を有している。
例えば，`~proxy$には、［
~cache~~領域を節約したり, 遅い~link上の流通~量を抑制する
］ために，画像~形式を変換するものもある。
しかしながら、これらの形式変換が［［
医療~画像処理や科学的~data分析などの~criticalな応用
］に意図されている~payload
］に適用されるとき，運用~上の問題が生じるかもしれない
— 特に、受信される~payloadが元と一致することを確保するために，完全性~検査や~digital署名が利用されている下では。
◎
Some intermediaries include features for transforming messages and their payloads. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original.
</p>

<p>
［
~messageを，意味論的に有意義な仕方で改変する
］ように［
設計され／環境設定され
］ている~HTTP-to-HTTP`~proxy$は、
`形式変換ng~proxy@
と呼ばれる（改変するとは、通常の~HTTP処理に要求されるものを超えて，［
元の`送信者$にとって有意になる, あるいは
`下流$の`受信者$にとって有意になり得る
］ような仕方で~messageを変更することを意味する）。
例えば，形式変換ng~proxyには、［
共用~注釈~server（応答を，局所的な注釈~databaseへの参照を内包するように 改変する）,
~malware~filter,
形式~符号変換器,
~privacy~filter
］などとして，動作しているものもあるかもしれない。
そのような`形式変換$は、~client（または~client組織）が何であれ，［
`~client$が欲して`~proxy$を選んだ
］ことが~~前提にあるとされる。
◎
An HTTP-to-HTTP proxy is called a "transforming proxy" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) chose the proxy.
</p>

<p>
`~proxy$は：
◎
↓</p>
<ul>
	<li>
<p>
受信した`~target~URI$に［
完全修飾~domain名でない `host$p 名
］が伴われる場合には、要請を回送するときに，自前の~domainを受信した `host$p 名に追加してもヨイ。
◎
If a proxy receives a target URI with a host name that is not a fully qualified domain name, it MAY add its own domain to the host name it received when forwarding the request.＼
</p>

<p>
`~target~URI$が完全修飾~domain名を包含する場合には。 `host$p 名を変更してはナラナイ。
◎
A proxy MUST NOT change the host name if the target URI contains a fully qualified domain name.
</p>

	</li>
	<li>
受信した`~target~URI$を，`内方$にある次の`~server$へ回送するときには、その［
`absolute-path$p, `query$p
］を成す部分を改変してはナラナイ
— ただし，上に注記された［
空な~pathを "`/^c" または "`*^c" に置換する
］場合を除く。
◎
A proxy MUST NOT modify the "absolute-path" and "query" parts of the received target URI when forwarding it to the next inbound server, except as noted above to replace an empty path with "/" or "*".
</li>
	<li>
<p>
当の~messageが［
`no-transform$sdir `Cache-Control$h 応答~指令
］を：
◎
↓</p>
		<ul>
			<li>
包含する場合、その`~payload$を`形式変換-$してはナラナイ。
`転送~符号法$などの［
~payloadには影響しない，`~message本体$に対する変更
］は、これには該当しないことに注意。
◎
A proxy MUST NOT transform the payload (Section 5.5) of a message that contains a no-transform cache-control response directive (Section 5.2 of [Caching]).＼
Note that this does not include changes to the message body that do not affect the payload, such as transfer codings (Section 7 of [Messaging]).
</li>
			<li>
包含しない場合、その`~payload$を`形式変換-$してもヨイ。
加えて，［
`200$st 応答の`~payload$
］を`形式変換-$するときは、［
`応答~状態s~code$を `203$st に変更する
］ことにより，［
`下流$の`受信者$たちに`形式変換$が適用されていることを伝える
］こともできる。
◎
A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive. A proxy that transforms the payload of a 200 (OK) response can inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 14.3.4).
</li>
		</ul>
	</li>
	<li>
<p>
次についての情報を供する~headerは、改変するベキでない
⇒＃
通信`連鎖$の両`端点$,
`資源$の状態,
`選定された表現$（`~payload$について以外の）
◎
A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the payload)＼
</p>

<p>
— ただし，次に該当するときは除く
⇒＃
~headerの定義が，そのような改変を特定的に許容している ／
~privacyや~securityのために，改変が必要と判断される
◎
unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security.
</p>
	</li>
</ul>

		</section>
		<section id="field.upgrade">
<h3>6.6. `Upgrade^h</h3>

<p>
`Upgrade^h ~headerは、［［
ある接続~上で，`~HTTP11$から 何らかの他の~protocolへ移行する
］ための単純な仕組み
］を意図して供されている。
◎
The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.
</p>

<p>
`~client$は、要請の `Upgrade^h ~header内に［
選好順による，~protocol名の~list
］を送信して，［
`~server$が`最終-応答$を送信する前に，
1 個~以上の それらの名前の~protocolに切替えてもらう
］よう，~serverを招いてもヨイ。
`~server$は、その接続~上で現在の~protocolを利用し続けたいと望むならば，受信した `Upgrade^h ~headerを無視してもヨイ。
`Upgrade^h を利用して，~protocol変更を強要することはできない。
◎
A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.
</p>

<pre class="bnf">
`Upgrade@p
    = #`protocol$p
`protocol@p
    = `protocol-name$p ["/" `protocol-version$p]
`protocol-name@p
    = `token$p
`protocol-version@p
    = `token$p
</pre>

<p>
~protocol名は，選好される文字大小で登録されるが、受信者は，［
各 `protocol-name$p を~supportされる~protocolと照合するとき
］には文字大小無視で比較するベキである。
◎
Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.
</p>

<p>
`~server$は：
◎
↓</p>
<ul>
	<li>
<p>
`101$st 応答を送信するときは：
◎
A server that sends a 101 (Switching Protocols) response＼
</p>
		<ul>
			<li>
`Upgrade^h ~headerを送信して、切替えようとしている接続に対し，
1 個~以上の新たな~protocolを指示しなければナラナイ。
◎
MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched;＼
</li>
			<li>
切替えようとしている~protocol層が複数ある場合，それらを，最下~層のものから昇順に~listしなければナラナイ。
◎
if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.＼
</li>
			<li>
~protocolを［［［
`~client$による，対応する要請
］の `Upgrade^h ~header
］内に指示されていないもの
］に切替えてはナラナイ。
◎
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.＼
</li>
			<li>
`~client$により指示された［
選好の順序
］を無視することにして，［
要請の資質や, ~server上の現在の負荷などの，他の要因
］に基づく新たな†~protocol（たち）を選定してもヨイ。
【† “新たな” — 前項に反しない中で】
◎
A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.
</li>
		</ul>
	</li>
	<li>
`426$st 応答を送信するときは
⇒
［
選好順による， `Upgrade^h ~header
］を送信して，受容-可能な~protocolを指示しなければナラナイ。
◎
A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.
</li>
	<li>
他の応答においても、未来の要請~用に適切になるときは
⇒
［
選好順による， `Upgrade^h ~header
］を送信して，［
~listされた~protocolに昇格するための~supportを，自身が実装している
］ことを広告してもヨイ。
◎
A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.
</li>
</ul>

<div class="example">
<p>
`~client$により送信される仮の例を次に示す：
◎
The following is a hypothetical example sent by a client:
</p>

<pre class="lang-http">
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
</pre>
</div>

<p>
~protocol変更~後の［
応用~level通信の能力や資質
］は、［
選ばれた新たな~protocol（たち）
］に全面的に依存する。
しかしながら，`~server$は、
`101$st 応答を送信した直後に［
新たな~protocolの中で，元の要請に等価なものを受信した
］かのように応答を継続するものと期待されている（すなわち，~protocolが変更された後であっても、依然として，満足するべき応答待ち要請【まだ`最終-応答$は受信されていない要請】は在って，~serverには［
要請の繰返しを要求することなく，それを満足する
］ものと期待されている）。
◎
The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).
</p>

<p>
例えば，~serverが、［
`GET$m 要請にて `Upgrade^h ~headerが受信された
］下で，~protocolを切替えると裁定した場合には、まず［
HTTP/1.1 `101$st ~message
］で応答した直ぐ後に，［
新たな~protocolにおける［
`~target資源$上の `GET$m に対する応答
］に等価なもの
］が後続する。
これにより、追加的な往来による待時間~costなしに，［
~HTTPと同じ意味論を有する~protocol
］へ接続を昇格できるようになる。
`~server$は、新たな~protocolが［
受信した~messageの意味論
］を尊守し得ない場合は，~protocolを切替えてはナラナイ
— `OPTIONS$m 要請は，どの~protocolからも尊守し得る。
◎
For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.
</p>

<div class="example">
<p>
上に示した仮の要請に対する応答~例を，次に示す：
◎
The following is an example response to the above hypothetical request:
</p>

<pre class="lang-http">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

<span class="comment">
[…… "`GET /hello^c" 要請に対し，適切な応答により~data~streamを
websocket に切替える（その新たな~protocolによる定義に従って）…… ]
◎
[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</span>
</pre>
</div>

<p>
`Upgrade^h を送信する`送信者$は、［
`Upgrade^h が［
~listされた~protocolを実装していない`中継者$
］により偶発的に回送される
］ことを防ぐために，［
"`upgrade^c" `接続~option$を包含する `Connection$h ~header
］も送信しなければナラナイ。
`~server$は、［
~HTTP10要請にて受信した `Upgrade^h ~header
］を無視しなければナラナイ。
◎
When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.4.1) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols. A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.
</p>

<p>
`~client$は、［
要請~messageを完全に送信し終える
］まで，接続~上にて昇格された~protocolの利用を~~開始できない（すなわち，~clientは、~messageの中途で，送信している~protocolを変更できない）。
`~server$は、［
`Upgrade^h,
`100-continue$c `期待$を伴う `Expect$h
］の両~headerとも受信したときは，
`101$st 応答を送信する前に `100$st 応答を送信しなければナラナイ。
◎
A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 9.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.
</p>

<p>
`Upgrade^h ~headerは、［
既存の接続の上層にある~protocolの切替
］に限り，適用される。
それは、［
下層~接続の（~transport）~protocolの切替
］, あるいは［
既存の通信を異なる接続に切替えること
］には利用し得ない。
その種の目的には、 `3xx$st 応答を利用する方が適切である。
◎
The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 14.4).
</p>

<p>
この仕様は、［
Hypertext Transfer Protocol 族
］に利用するための~protocol名として
—［
~HTTP~version規則
`5.1$sec, および この仕様に対する将来の更新
］に定義されるように —
"`HTTP^c" のみを定義する。
追加的な~protocol名は、
`15.7$sec に定義される登録~手続きを利用して登録される~OUGHT。
◎
This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 5.1 and future updates to this specification. Additional protocol names ought to be registered using the registration procedure defined in Section 15.7.
</p>

		</section>
	</section>
	<section id="representations">
<h2 title="Representations">7. 表現</h2>

<p>
`表現@
とは、［
所与の`資源$の［
過去の／現在の／欲される
］状態を反映する
］ように意図された，［
~protocolを介して通信するに~~適した形式による情報
］である。
表現は、［
`表現~metadata$からなる集合, および
`表現~data$の~stream（際限なく続くものにもなり得る）
］からなる。
◎
A "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol. A representation consists of a set of representation metadata and a potentially unbounded stream of representation data.
</p>

<p>
~HTTPは、統一的な~interfaceの背後に “情報を隠す” ことを許容する
— 資源~自体を転送するのではなく，通信を当の資源の状態の転送-可能な表現に基づくようにすることにより。
これは、何であろうが，~URIにより識別される資源になり得ることを許容する
— “富士山における現在の天気” の様な，［
~messageが生成された時点に，その資源を表現する情報
］を供する時間的な関数も含めて。
`REST$r
◎
HTTP allows "information hiding" behind its uniform interface by phrasing communication with respect to a transferable representation of the resource state, rather than transferring the resource itself. This allows the resource identified by a URI to be anything, including temporal functions like "the current weather in Laguna Beach", while potentially providing information that represents that resource at the time a message is generated [REST].
</p>

<p>
統一的な~interfaceは、窓のようなものである
— ［
その窓の向こう側で独立に動作する者と，~messageを通信すること
］を通してのみ、何かモノを観測して, 動作できるような。
通信において［
現在の状態【すなわち，応答】,
欲される状態【すなわち，要請】
］を表現する（ “その場を占める” ）ためには、共有される抽象-化が必要になる。
表現が~hypertextであるならば、それは，［
資源~状態の表現,
未来における受信者とのヤリトリを手引きするような処理命令
］どちらも供し得る。
◎
The uniform interface is similar to a window through which one can observe and act upon a thing only through the communication of messages to an independent actor on the other side. A shared abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. When a representation is hypertext, it can provide both a representation of the resource state and processing instructions that help guide the recipient's future interactions.
</p>

		<section id="selected.representation">
<h3 title="Selected Representation">7.1. 選定された表現</h3>

<p>
`生成元~server$は、同じ`~target資源$に対し，［
それぞれが`資源$の現在の状態を反映するものと意図された，複数の表現
］を［
供する／生成する
］能力を備えていることもある。
そのような事例では、生成元~serverにより，［
それらの表現のうち，所与の要請に最も適用-可能なもの
］を
— 通例的に，`内容~折衝$に基づいて —
選定するような、何らかの~algoが利用される。
このようにして一つに
`選定された表現@
が、［
`条件付き要請$を評価する
］ため, および ［
`GET$m に対する
`200$st ／ `206$st ／ `304$st
応答の~payloadを構築する
］ための，［
~dataと~metadata
］を供するために利用される。
◎
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests (Section 12.1) and constructing the payload for 200 (OK), 206 (Partial Content), and 304 (Not Modified) responses to GET (Section 8.3.1).
</p>

		</section>
		<section id="representation.data">
<h3 title="Data">7.2. ~data</h3>

<p>
~HTTP~messageに結付けられる
`表現~data@
— 資源の`表現$を成す~data —
は、~messageの`~payload本体$として供されるか, または［
~message意味論と`~target~URI$
］により指される。
表現~dataの［
形式と符号化法
］は、`表現~metadata$~headerにより定義される。
◎
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the target URI. The representation data is in a format and encoding defined by the representation metadata header fields.
</p>

<p>
表現~dataの~data型は、［
`Content-Type$h, および `Content-Encoding$h 
］~headerを介して決定される。
これらは［
2 層からなる, 順序付けられた符号化~model
］を定義する：
◎
The data type of the representation data is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:
</p>

<blockquote>
表現~data := `Content-Encoding^V ( `Content-Type^V ( ビット列 ) )
◎
representation-data := Content-Encoding( Content-Type( bits ) )
</blockquote>

		</section>
		<section id="representation.metadata">
<h3 title="Metadata">7.3. ~metadata</h3>

<p>
`表現~header@
は、
`表現~metadata@
— `表現$についての~metadata —
を供する。
~messageが`~payload本体$を内包するとき、一連の表現~headerは，［
~payload本体~内に同封される`表現~data$
］を解釈する方法を述べる。
`HEAD$m 要請に対する応答においては、一連の表現~headerは，［
その要請が `GET$m であったとするとき，~payload本体~内に同封されることになる表現~data
］について述べる。
◎
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
</p>

<p>
次の~headerは、`表現~metadata$を伝達する
⇒＃
`Content-Type$h,
`Content-Encoding$h,
`Content-Language$h,
`Content-Location$h
◎
The following header fields convey representation metadata:
◎
Table 3
Field Name 	Ref.

Content-Type 	7.4
Content-Encoding 	7.5
Content-Language 	7.6
Content-Length 	7.7
Content-Location 	7.8
</p>

		</section>
		<section id="field.content-type">
<h3>7.4. `Content-Type^h</h3>

<p>
`Content-Type^h ~headerは、結付けられている`表現$
— ~message意味論に従って決定された，［
`~message~payload$内に同封された表現, または`選定された表現$
］ —
の`~MIME型$を指示する。
指示された~MIME型は、［
`Content-Encoding$h により指示される`内容~符号法$（たち）を復号した結果の~data
］の［
形式, および［
受信者は，それをどう処理するものと意図されているか
］］を，受信された~message意味論の視野の中で定義する。
◎
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by Content-Encoding are decoded.
</p>

<pre class="bnf">
`Content-Type@p
    = `media-type$p
</pre>

<div class="example">
<p>
【！ ~MIME型は 6.1.1 にて定義される。】
~headerの例：
◎
Media types are defined in Section 7.4.1. An example of the field is
</p>

<pre class="lang-http">
Content-Type: text/html; charset=ISO-8859-4
</pre>
</div>

<p>
［
`~payload本体$を包含している~message
］を`生成する$`送信者$は、［
自身が，同封された`表現$に意図された`~MIME型$について未知でない
］限り、その~message内に `Content-Type^h ~headerを`生成する$ベキである。
`受信者$は、~message内に `Content-Type^h ~headerが無い場合には，その~MIME型を［
"`application/octet-stream$c" `RFC2046$r であるものと見做す
］か, または
その~dataを精査して決定してもヨイ。
◎
A sender that generates a message containing a payload body SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient MAY either assume a media type of "application/octet-stream" ([RFC2046], Section 4.5.1) or examine the data to determine its type.
</p>

<p>
実施においては、`資源$の所有者は，［
`生成元~server$が［
所与の`表現$用に正しい `Content-Type^h を供する
］ように，常に適正に環境設定されている
］とは限らない。
一部の~UAは、`~payload$の内容を精査して，ある種の事例で，指定された型を上書きする（例えば `Sniffing$r を見よ）。
この “~MIME~sniff法” には、~dataについて不正な結論に至る~riskがあり，追加的な~security~riskに利用者を晒し得る（例： “特権拡大” ）。
更には、~data形式を精査して 送信者が意図する処理~modelを決定するのは，不可能である
— 多くの~data形式は、処理の意味論においてのみ相違するような，複数の`~MIME型$に合致する。
実装者には、そのような~sniff法を不能化する手段を供することが奨励される。
◎
In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine a payload's content and, in certain cases, override the received type (for example, see [Sniffing]). This "MIME sniffing" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intended processing model by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means to disable such sniffing.
</p>

<p>
更には，
`Content-Type^h は`単数~field$として定義されるが、不正に複数回 `生成され$，その結果 `結合-$された`~field値$が~listのように出現することもある。
受信者は，この~errorを［
~listを成す構文~的に妥当な~memberのうち，最後のものを利用して取扱う
］よう試みることが多いが、一部の実装は異なる挙動で この~errorを取扱うかもしれず，［
相互運用能／~security
］の課題へ導くことに注意。
◎
Furthermore, although Content-Type is defined as a singleton field, it is sometimes incorrectly generated multiple times, resulting in a combined field value that appears to be a list. Recipients often attempt to handle this error by using the last syntactically valid member of the list, but note that some implementations might have different error handling behaviors, leading to interoperability and/or security issues.
</p>

			<section id="media.type">
<h4 title="Media Type">7.4.1. ~MIME型</h4>

<p class="trans-note">【
この訳では、原文の［
`Internet media type^en, その略称 `media type^en
］を，一律に “~MIME型” と表記する（ RFC 以外の他の~web標準と一貫させるため）。
】</p>

<p>
~HTTPは、［
~openかつ拡張できる，~dataの型~付けと型~折衝
］を供するため，［
`Content-Type$h, `Accept$h
］~header内で~MIME型 `RFC2046$r を利用する。
`~MIME型@
（ `media-type$p ）は、~data形式, および
様々な処理~model
— ~dataが受信される各~文脈に則って，~dataを処理する方法 —
を定義する。
◎
HTTP uses media types [RFC2046] in the Content-Type (Section 7.4) and Accept (Section 11.1.2) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
</p>

<pre class="bnf">
`media-type@p
    = `type$p "/" `subtype$p `parameters$p
`type@p
    = `token$p
`subtype@p
    = `token$p
</pre>

【！ Errata 4031 Rejected】

<p>
［
`type$p, `subtype$p
］とも、文字大小無視である。
◎
The type and subtype tokens are case-insensitive.
</p>

<p>
`type/subtype^p には、~semicolonで区切られた何個かの
`~MIME型~parameter@
— `名前^V=`値^V ~pairの形をとる`~parameter$ —
が後続してもヨイ。
~parameterの有無は、［
~MIME型~registryにおける その定義
］に依存して，~MIME型の処理に有意になり得る。
各~parameterの値が文字大小区別になるかどうかは、当の~parameterの名前の意味論に依存する。
◎
The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.7.6) in the form of name=value pairs. The presence or absence of a parameter might be significant to the processing of a media type, depending on its definition within the media type registry. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.
</p>

<div class="example">
<p>
例えば次のものは、~UTF-8文字~符号化~schemeに符号化された~HTML~text~dataを述べるときには，どれも等価になる（ "`charset^c" ~parameterの値は、
`RFC2046/4.1.2$sec
にて文字大小無視として定義されている）
— 一貫性を得るため、最初のものが選好されるが：
◎
For example, the following media types are equivalent in describing HTML text data encoded in the UTF-8 character encoding scheme, but the first is preferred for consistency (the "charset" parameter value is defined as being case-insensitive in [RFC2046], Section 4.1.2):
</p>

<pre class="lang-http">
text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
text/html;charset=UTF-8
</pre>
</div>

<p>
~MIME型は、`BCP13$r にて定義される手続きに則って，~IANAにより登録される~OUGHT。
◎
Media types ought to be registered with IANA according to the procedures defined in [BCP13].
</p>

			</section>
			<section id="charset">
<h4 title="Charset">7.4.2. ~charset</h4>

<p>
~HTTPでは、［
~textな表現の，文字~符号化~scheme `RFC6365$r
］を指示したり折衝するときに，~charset名（ `charset$p ）を利用する。
`charset$p は、文字大小無視~tokenにより識別される。
◎
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [RFC6365]. A charset is identified by a case-insensitive token.
</p>

<pre class="bnf">
`charset@p
    = `token$p
</pre>

<p>
~charset名は、`RFC2978/2$sec にて定義される手続きに則って，~IANA
<a href="~IANA-a/character-sets">Character Sets</a>
~registryに登録される~OUGHT。
◎
Charset names ought to be registered in the IANA "Character Sets" registry (&lt;https://www.iana.org/assignments/character-sets&gt;) according to the procedures defined in Section 2 of [RFC2978].
</p>

<p class="note">注記：
理論~上は、~charset名は， `mime-charset^p ~ABNF規則  `RFC2978/2.3$sec に定義される（ `Err1912$r により正された上で）。
その規則は， `token$p に含まれない 2 つの文字（ "`{^c", "`}^c" ）を許容するが、これを書いている時点では，それらの文字を含む~charset名は登録されていない（ `Err5433$r を見よ）。
◎
Note: In theory, charset names are defined by the "mime-charset" ABNF rule defined in Section 2.3 of [RFC2978] (as corrected in [Err1912]). That rule allows two characters that are not included in "token" ("{" and "}"), but no charset name registered at the time of this writing includes braces (see [Err5433]).
</p>

			</section>
			<section id="canonicalization.and.text.defaults">
<h4 title="Canonicalization and Text Defaults">7.4.3. 正準-化, ~textにおける既定</h4>

<p>
~MIME型は、［
~native符号化~形式が様々な~system
］間でも相互運用-可能にするため，正準-形で登録される。
［
MIME（ `Multipurpose Internet Mail Extensions^en ）`RFC2045$r
］にて述べられている多くの理由と同じ理由から、［
~HTTPを介して 選定される／転送される`表現$
］は正準-形にされる~OUGHT。
しかしながら，［
~email配達（すなわち，~messageを格納して~peerへ回送する）の処理能 特性
］は、［
~HTTPや~Web（~serverに基づく情報~service）において共通的なそれ
］からは有意に異なる。
更には、~MIMEによる拘束は，古い~mail転送~protocolとの互換性を~~目的にしており、~HTTPには適用されない（ `Messaging/B$sec を見よ）。
◎
Media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [RFC2045]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see Appendix B of [Messaging]).
</p>

<p>
~MIMEの正準-形では、［
"`text^c" `~MIME型$を成すすべての下位型
］において，~text改行に `CRLF$P を利用することが要求される。
一方で，~HTTPでは、［
改行が~~単独の `CR$P ／ `LF$P で表現された，~text~media
］の転送も，［
そのような改行が`表現$ 全体で~~一貫している
］ときには 許容される。
~HTTP［
`送信者$／`受信者$
］は、~text~media内に［
`CRLF$P 並びや, ~~単独の `CR$P ／ `LF$P による改行
］を`生成し$てもヨイ
— また，構文解析できなければナラナイ。
加えて，~HTTPにおける~text~mediaは、［
`CR$P, `LF$P に，~octet `0D^X, `0A^X 【！ 13, 10】（同順）を利用する`~charset$
］に制限されない。
この，改行に関する柔軟性は、［
`表現$の中に， "`text^c" ~MIME型としてアテガわれた~text
］のみに適用され，［
"`multipart$c" 型や, `~payload本体$の外側の~HTTP要素（例：`~header$）
］には適用されない。
◎
MIME's canonical form requires that media subtypes of the "text" type use CRLF as the text line break. HTTP allows the transfer of text media with plain CR or LF alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender MAY generate, and a recipient MUST be able to parse, line breaks in text media that consist of CRLF, bare CR, or bare LF. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for CR and LF, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
</p>

<p>
`表現$が`内容~符号法$により符号化される場合、下層の~dataは，符号化されるに先立って，上で定義した形にされる~OUGHT。
◎
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
</p>

			</section>
			<section id="multipart.types">
<h4 title="Multipart Types">7.4.4. `multipart^c 型</h4>

<p>
~MIMEは、［
単独の`~message本体$の中に， 1 個以上の`表現$が~encapsulateされる
］ような，いくつもの
"`multipart^c" 型
を供する。
すべての "`multipart^c" 型は、`RFC2046/5.1.1$secにて定義される 共通な構文を共有し，`~MIME型$ 値の一部として 境界~parameterを内包する。
`~message本体$自身は、~protocol要素である
— `送信者$は、本体の各 部分~間の改行を表現するときは， `CRLF$P のみを`生成し$なければナラナイ。
◎
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in Section 5.1.1 of [RFC2046], and include a boundary parameter as part of the media type value. The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.
</p>

<p>
~HTTP~message~frame法においては、
"`multipart^c" 境界が `~message本体$の長さの指示子として利用されることはない
— ~payloadを生成する／処理する実装により，利用されることはあっても。
例えば， "`multipart/form-data^c" 型は、
`RFC7578$r に述べられるように，要請~内に~form~dataを運ばせるために よく利用される。
また， "`multipart/byteranges$c" 型は、一部の `206$st 応答に利用するためとして，この仕様に定義される。
◎
HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [RFC7578], and the "multipart/byteranges" type is defined by this specification for use in some 206 (Partial Content) responses (see Section 14.3.7).
</p>

			</section>
		</section>
		<section id="field.content-encoding">
<h3>7.5. `Content-Encoding^h</h3>

<p>
`Content-Encoding^h ~headerは、［
当該の`~MIME型$に内来的なものを超えて，`表現$に適用された`内容~符号法$
］を指示し、従って，［［［
`Content-Type$h ~headerにより参照されている~MIME型
］による~data
］を得するために 適用する必要がある，復号の仕組み
］を指示する。
`Content-Encoding^h は、首に，［
その下層の~MIME型の同一性を損なうことなく，表現の~dataを圧縮できる
］ようにするために利用される。
◎
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
</p>

<pre class="bnf">
`Content-Encoding@p
    = #`content-coding$p
</pre>

<div class="example">
<p>
その利用~例：
◎
An example of its use is
</p>

<pre class="lang-http">
Content-Encoding: gzip
</pre>
</div>

<p>
`送信者$は、［
`表現$に一つ以上の符号化法を適用する
］ときには，［
各 `内容~符号法$を適用した順序で~listする，
`Content-Encoding^h ~header
］を`生成し$なければナラナイ。
"`identity$c" と命名される符号法は、
`Accept-Encoding$h における特別な役割に予約されており，内包するベキではない。
◎
If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named "identity" is reserved for its special role in Accept-Encoding, and thus SHOULD NOT be included.
</p>

<p>
［
符号化法の各種~parameterについての追加的な情報
］も［
この仕様では定義されない他の~header
］により供され得る。
◎
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h と違って，［
`Content-Encoding^h 内に~listされた符号法
］は、`表現$の特性である
— 表現は、符号化形の用語を通して定義される。
また，表現に関する他のすべての~metadataは、その~metadata定義にて注記されない限り，符号化形に関するものである。
表現が復号されるのは、概して，それを具現化する, またはそれに類する用法の~~直前に限られる。
◎
Unlike Transfer-Encoding (Section 6.1 of [Messaging]), the codings listed in Content-Encoding are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
</p>

<p>
［
常に圧縮されるような~data形式などの，`~MIME型$が含む内来的な符号化法
］は、それが［
いずれかの`内容~符号法$と たまたま同じ~algoである
］としても、
`Content-Encoding^h 内には再掲されない。
そのような内容~符号法が~listされるのは、`表現$を形成するときに，何らかの奇妙な理由から 二重に適用された場合に限られることになる。
同様に，`生成元~server$は、同じ~dataを［［
符号法が［
`Content-Type$h や `Content-Encoding^h
］の一部として定義されるかどうか
］においてのみ相違するような，複数の表現
］として発行することを選ぶかもしれない
— 一部の~UAは、応答ごとに取扱いを違えるように挙動するので（例： 内容を自動解凍して具現化する代わりに， “保存…” ~dialogを開く）。
◎
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of Content-Type or Content-Encoding, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
</p>

<p>
`生成元~server$は、［
要請~message内の`表現$が，受容-可能でない`内容~符号法$を持つ
］ときには， `415$st で応答してもヨイ。
◎
An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.
</p>

			<section id="content.codings">
<h4 title="Content Codings">7.5.1. 内容~符号法</h4>

<p>
内容~符号法の値（ `content-coding$p ）は、［
`表現$に［
適用された／適用できる
］符号化法による形式変換
］を指示する。
内容~符号法は，首に、表現の下層の［
`~MIME型$の同一性, 情報
］を損なうことなく，表現を［
圧縮する／有用に形式変換する
］ことを許容するために利用される。
表現が，［
符号化形で格納され, 直に伝送され，最終-受信者によってのみ復号される
］ことは、~~頻繁にある。
◎
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
</p>

<pre class="bnf">
`content-coding@p
    = `token$p
</pre>

<p>
内容~符号法は，すべて文字大小無視であり、
`15.6$sec にて述べるように
`内容~符号法~registry$cite
の中に登録される~OUGHT。
◎
All content codings are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as described in Section 15.6
</p>

<p>
各種 内容~符号法~値は、［
`Accept-Encoding$h,
`Content-Encoding$h
］~header内で利用される。
◎
Content-coding values are used in the Accept-Encoding (Section 11.1.4) and Content-Encoding (Section 7.5) header fields.
</p>

<p>
この仕様では、次に挙げる内容~符号法~用の値が定義される：
◎
The following content-coding values are defined by this specification:
</p>

<div>
<table><thead><tr><td>名前
<td>説明d
</thead><tbody>

<tr><td>"`compress$c"
<td>~UNIX "compress" ~data形式 `Welch$r

<tr><td>"`deflate$c"
<td>"zlib" ~data形式 `RFC1950$r の内側の "deflate" 圧縮-済み~data `RFC1951$r

<tr><td>"`gzip$c"
<td>GZIP ~file形式 `RFC1952$r

<tr><td>"`identity$c"
<td>予約-済み

<tr><td>"`x-compress^c"
<td>非推奨d（ "`compress$c" の別名）

<tr><td>"`x-gzip^c"
<td>非推奨d（ "`gzip$c" の別名）

</tbody></table>

◎
Table 4
Name 	Description 	Ref.

compress 	UNIX "compress" data format [Welch] 	7.5.1.1
deflate 	"deflate" compressed data ([RFC1951]) inside the "zlib" data format ([RFC1950]) 	7.5.1.2
gzip 	GZIP file format [RFC1952] 	7.5.1.3
identity 	Reserved 	11.1.4
x-compress 	Deprecated (alias for compress) 	7.5.1.1
x-gzip 	Deprecated (alias for gzip) 	7.5.1.3
</div>

				<section id="compress.coding">
<h5 title="Compress Coding">7.5.1.1. "`compress^c" 符号法</h5>

<p>
"`compress^c" 符号法は、共通的に［
~UNIX~file圧縮~program “compress”
］により生産される，［
適応的 LZW（ `Lempel-Ziv-Welch^en ）符号法 `Welch$r
］である。
`受信者$は、 "`x-compress^c" を "`compress^c" と等価と見なすベキである。
◎
The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program "compress". A recipient SHOULD consider "x-compress" to be equivalent to "compress".
</p>

				</section>
				<section id="deflate.coding">
<h5 title="Deflate Coding">7.5.1.2. "`deflate^c" 符号法</h5>

<p>
"`deflate^c" 符号法は、
“zlib” ~data形式 `RFC1950$r であり，［
LZ77 （ `Lempel-Ziv^en ）圧縮~algoと, Huffman 符号法が組合された， “deflate” 圧縮-済み~data~stream `RFC1951$r
］を包含する。
◎
The "deflate" coding is a "zlib" data format [RFC1950] containing a "deflate" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.
</p>

<p class="note">注記：
一部の適合しない実装は、
"`deflate^c" 圧縮-済み~dataを，zlib で包装せずに送信する。
◎
Note: Some non-conformant implementations send the "deflate" compressed data without the zlib wrapper.
</p>

				</section>
				<section id="gzip.coding">
<h5 title="Gzip Coding">7.5.1.3. "`gzip^c" 符号法</h5>

<p>
"`gzip^c" 符号法は、［
32-bit CRC（ `Cyclic Redundancy Check^en ）が伴われた LZ77 符号法
］であり，［
“gzip” ~file圧縮~program `RFC1952$r
］により共通的に生産される。
`受信者$は、 "`x-gzip^c" を "`gzip^c" と等価と見なすベキである。
◎
The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider "x-gzip" to be equivalent to "gzip".
</p>

				</section>
			</section>
		</section>
		<section id="field.content-language">
<h3>7.6. `Content-Language^h</h3>

<p>
`Content-Language^h ~headerは、`表現$用に意図される視聴者の自然~言語（たち）を述べる。
これは、［
表現の中で利用される どの言語にも等価にならない
］場合もあることに注意。
◎
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
</p>

<pre class="bnf">
`Content-Language@p
    = #`language-tag$p
</pre>

<p>
【！ 言語~tagは、6.1.3にて定義される。】
`Content-Language^h の首な目的は、利用者が，自身が選好する言語に則って，表現を識別したり相違化できるようにすることである。
◎
Language tags are defined in Section 7.6.1. The primary purpose of Content-Language is to allow a user to identify and differentiate representations according to the users' own preferred language.＼
</p>

<div class="example">
<p>
したがって、~Danish話者~向けのみを意図した内容に適切になる~fieldは：
◎
Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
</p>

<pre class="lang-http">
Content-Language: da
</pre>
</div>

<p>
`Content-Language^h が指定されていない場合、［
内容は，すべての言語の視聴者~向けを意図する
］ことが，既定になる。
これは、送信者が［
内容は どの自然~言語にも特有でないと見なしているか，内容に意図された言語を知らない
］ことを意味するであろう。
◎
If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
</p>

<p>
［
複数の言語の視聴者~向けに意図される内容
］に対しては、複数の言語が~listされてもヨイ。
◎
Multiple languages MAY be listed for content that is intended for multiple audiences.＼
</p>

<div class="example">
<p>
例えば，
“ワイタンギ条約”
を，元の~Maoriと英語~versionで同時に呈示させたければ、次を用いることになろう：
◎
For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
</p>

<pre class="lang-http">
Content-Language: mi, en
</pre>
</div>

<p>
しかしながら、単に表現の中に 複数の言語が在るだけで，複数種の言語~話者~向けが意図されたことにはならない。
例えば、 “`A First Lesson in Latin^en” のような，英語~話者~向けが明瞭な 初学者~向けの言語~入門書であれば、 `Content-Language^h は "`en^c" のみを内包する方が適正になるであろう。
◎
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".
</p>

<p>
`Content-Language^h は、どの`~MIME型$に適用されてもヨイ
— ~textな文書のみに制限されない。
◎
Content-Language MAY be applied to any media type — it is not limited to textual documents.
</p>

			<section id="language.tags">
<h4 title="Language Tags">7.6.1. 言語~tag</h4>

<p>
`言語~tag@
は、
`RFC5646$r にて定義されるように，［
他者と情報をやりとりするために，ヒトにより［
話され, 書かれ, あるいは伝達される
］自然~言語
］を識別する。
~computer言語は、明示的に除外される。
◎
A language tag, as defined in [RFC5646], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
</p>

<p>
~HTTPでは、言語~tagを［
`Accept-Language$h ／ `Content-Language$h
］~headerの中で利用する。
`Accept-Language$h は，より~~広い `language-range$p 生成規則を利用するように定義される一方、
`Content-Language$h は，次に定義する `language-tag$p 生成規則を利用する：
◎
HTTP uses language tags within the Accept-Language and Content-Language header fields. Accept-Language uses the broader language-range production defined in Section 11.1.5, whereas Content-Language uses the language-tag production defined below.
</p>

<pre class="bnf">
`language-tag@p
    = &lt;Language-Tag, `RFC5646/2.1$sec&gt;
</pre>

<div class="p">
<p>
言語~tagは、文字~hyphen（ "`-^c", `2D^X ）で互いに分離された， 1 個~以上の~subtag（文字大小無視）からなる並びである。
ほとんどの事例では、言語~tagは 次の並びからなる：
◎
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of＼
</p>
<ol>
	<li>
関係する言語の~~広い族を識別する，首な言語~subtag（例： "`en^c" ＝ 英語）
◎
a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is＼
</li>
	<li>
その言語の範囲を［
精緻化する／~~狭める
］省略可能な一連の~subtag
（例： "`en-CA^c" は、~Canadaで会話される英語の一方言）
◎
optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada).＼
</li>
</ol>

<p>
言語~tagの中では、`空白$は許容されない。
◎
Whitespace is not allowed within a language tag.＼
</p>
</div>

<div class="example">
<p>
~tagの例：
◎
Example tags include:
</p>

<pre class="lang-http">
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</pre>
</div>

<p>
更なる情報は、 `RFC5646$r を見よ。
◎
See [RFC5646] for further information.
</p>

			</section>
		</section>
		<section id="field.content-length">
<h3>7.7. `Content-Length^h</h3>

<div class="p">
<p>
`Content-Length^h ~headerは、~messageに結付けられた`表現$を成す~dataの長さを，負でない~decimal整数による~octet数として指示する。
`Content-Length^h は：
◎
The "Content-Length" header field indicates the associated representation's data length as a decimal non-negative integer number of octets.＼
</p>
<ul>
	<li>
表現が当の~message内に転送されるときは、
`~message本体$の~frame法を区切るために利用できるよう（例： `Messaging/6.2$sec ），
同封された~dataの量を特定的に指す。
◎
When transferring a representation in a message, Content-Length refers specifically to the amount of data enclosed so that it can be used to delimit framing of the message body (e.g., Section 6.2 of [Messaging]).＼
</li>
	<li>
他の事例では、`選定された表現$の現在の長さを指示する
— `受信者$は、［
転送~時間を見積もる／以前に格納した表現と比較する
］ときに，それを利用できる。
◎
In other cases, Content-Length indicates the selected representation's current length, which can be used by recipients to estimate transfer time or compare to previously stored representations.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Length@p
    = 1*`DIGIT$P
</pre>

<div class="example">
<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Content-Length: 3495
</pre>
</div>

<p class="trans-note">【
構文としては、先頭の 0 も許容されている
— 例えば "`011^c" を数として解釈するときは、
11 と見なすと見受けられる（先頭の 0 の有無に応じて異なる数に解釈するような要件は、この仕様には無い）。
】</p>

<p>
`送信者$は
⇒
`Transfer-Encoding$h ~headerを包含する どの~messageにも，
`Content-Length^h ~headerを送信してはナラナイ。
◎
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
</p>

<div class="p">
<p>
`~UA$は：
◎
↓</p>
<ul>
	<li>
［
`Transfer-Encoding$h を送信しない
］かつ［
同封される`~payload本体$用の意味が，`要請~method$に定義されている
］ときは、要請~message内に `Content-Length^h を送信するベキである。
例えば， `POST$m 要請においては、
`Content-Length^h ~headerは，その値が 0 であっても，通常は送信される（値 0 は`~payload本体$が空であることを指示する）。
◎
A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body. For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body).＼
</li>
	<li>
［
要請~messageが`~payload本体$を包含しない
］かつ［
~method意味論からも そのような本体は見越されない
］ときは、
`Content-Length^h ~headerを送信するベキでない。
◎
A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.
</li>
</ul>
</div>

<p>
`~server$は：
◎
↓</p>
<ul>
	<li>
［
`HEAD$m 要請に対する応答
］内に `Content-Length^h ~headerを送信してもヨイ
— ただし，その際の`~field値$は、［
同じ要請に `GET$m ~methodが利用されたとするときに，応答の`~payload本体$~内に送信することになる~octet数
］に等しい，~decimal~~表現
］にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a response to a HEAD request (Section 8.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.
</li>
	<li>
［
条件付き `GET$m 要請に対する `304$st 応答
］内に `Content-Length^h ~headerを送信してもヨイ
— ただし，その際の`~field値$は、［
同じ要請に対し `200$st 応答を送信したとするときに，応答の`~payload本体$~内に送信することになる~octet数
］に等しい，~decimal~~表現にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 14.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.
</li>
	<li>
次のいずれかに該当する応答~内には，
`Content-Length^h ~headerを送信してはナラナイ
⇒＃
`1xx$st 応答／
`204$st 応答／
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 8.3.6).
</li>
</ul>

<p>
上に定義された各 事例を除き、
`Transfer-Encoding$h が無い下では，
`生成元~server$は［
`~header節$の送信を完了するに先立って，`~payload本体$~sizeが既知である
］ときには，
`Content-Length^h ~headerを送信するベキである。
これにより、`下流$の各`受信者$は，［
転送の進捗を計測する ／
受信される~messageがいつ完了するかを知る ／
追加的な要請~用に接続を後で再利用する
］ことが可能になる。
◎
Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.
</p>

<p>
`Content-Length^h に対する 0 以上のどの`~field値$も，妥当である。
［
`~payload$の長さに対する定義済み制限
］は無いので、`受信者$は，それを構文解析する際に［
~decimal数字列が巨大になり得ることや, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防がなければナラナイ（ `16.5$sec ）。
◎
Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 16.5).
</p>

<div class="p">
<p>
受信した~message内に `Content-Length^h ~headerが在って，［
その`~field値$は、~comma区切りの~list（ `5.7.1$sec ）として，複数個の同じ~decimal値からなる場合（例： `Content-Length: 42, 42^c ）
］†、`上流$の~message処理器が［
`Content-Length^h ~headerを重複して`生成し$たか, または`結合-$した
］ことを指示している。
そのような場合，`受信者$は、［
`~message本体$の長さを決定する ／ ~messageを回送する
］に先立って，次のいずれかを行わなければナラナイ：
◎
If a message is received that has a Content-Length header field value consisting of the same decimal value as a comma-separated list (Section 5.7.1) — for example, "Content-Length: 42, 42" — indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either＼
</p>
<ul>
	<li id="invalid-Content-Length">
~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
重複された値たち【！~field値】を［
その~decimal値を包含している， 1 個の妥当な `Content-Length^h ~header
］に置換する。
◎
replace the duplicated field values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.
</li>
</ul>

<p class="trans-note">【†
`Content-Length^h は`~listに基づく~field$ではないが、ここでは受容することも許容されている。
異なる数や妥当でない値が混じっている場合、~HTTP11においては，
<a href="~HTTPmsg#invalid-Content-Length">~message~frame法は妥当でない</a>
とされ，回復-不能な~errorになる。
】【†
同じ数を表現する異なる値（ "`042^c" と "`42^c" など）でも，同様になると思われる。
】</p>
</div>

		</section>
		<section id="field.content-location">
<h3>7.8. `Content-Location^h</h3>

<p>
`Content-Location^h ~headerは、［
この~messageの`~payload$内の`表現$に対応する，特定の`資源$
］用の識別子として利用できる`~URI$を参照する。
言い換えれば、この~messageの生成-時に，［
どこかから この~URIに向けて `GET$m 要請が遂行された
］ならば、それに対する `200$st 応答は，［
この~message内の~payloadに同封されるものと同じ表現
］を包含することになるであろう。
◎
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
</p>

<pre class="bnf">
`Content-Location@p
    = `absolute-URI$p / `partial-URI$p
</pre>

<p>
`~field値$は、`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、参照先の~URIは，`~target~URI$に相対的になる（ `RFC3986/5$sec ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 4), the referenced URI is relative to the target URI ([RFC3986], Section 5).
</p>

<p>
`Content-Location^h 値は、`~target~URI$に代わるものではない。
それは、`表現~metadata$である。
その構文と意味論は、［
~MIME本体 部分~用に定義される同じ名前の~header `RFC2557/4$sec
］と同じである。
しかしながら，~HTTP~messageにおける
`Content-Location^h の出現は、~HTTP受信者にとっては，ある特別な含意がある
—
◎
The Content-Location value is not a replacement for the target URI (Section 6.1). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in Section 4 of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
</p>

<p>
それが， `2xx$st 応答~message内に内包されているならば、その`~field値$（を`絶対~形$へ変換した後の値）が：
◎
If Content-Location is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form)＼
</p>

<dl class="switch">
	<dt>
`~target~URI$と同じ~URIを指す場合：
◎
to a URI that is the same as the target URI, then＼
</dt>
	<dd>
<p>
`受信者$は、その`~payload$を［
`~messageの出生日時$で指示される時点における，その`資源$の現在の`表現$
］と見なしてもヨイ：
◎
the recipient MAY consider the payload to be a current representation of that resource at the time indicated by the message origination date.＼
</p>
		<ul>
			<li>
［
`GET$m ／ `HEAD$m
］要請に対しては、これは，［
`~server$により `Content-Location^h が供されなかったとき
］の既定の意味論と同じである。
◎
For a GET (Section 8.3.1) or HEAD (Section 8.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server.＼
</li>
			<li>
`PUT$m や `POST$m などの状態変更 要請に対しては、これは，［
`~server$の応答が，その`資源$の新たな`表現$を包含する
］ことを含意する
— それにより，［
動作についてのみを報告し得るような`表現$（例： “~~正常に~~処理されました。” ）
］との違いを判別できる。
これにより、著作~用の応用は、後続の `GET$m 要請を要することなく，その局所的な複製を更新できるようになる。
◎
For a state-changing request like PUT (Section 8.3.4) or POST (Section 8.3.3), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
</li>
		</ul>
	</dd>

	<dt>
`~target~URI$と相違する`~URI$を指す場合：
◎
If Content-Location is included in a 2xx (Successful) response message and its field value refers to a URI that differs from the target URI, then＼
</dt>
	<dd>
<p>
`生成元~server$は、［
その~URIが，同封された`表現$に対応する異なる`資源$用の識別子である
］ことを主張している。
そのような主張-を信用できるのは、［
両~識別子が同じ資源~所有者を共有する
］ときに限られる
— それは、~HTTPを介しては~program的には決定できない：
◎
the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
</p>

<p>
（以下、 `Content-Location^h `~field値$を単に `~field値^V と記す。）
</p>
		<ul>
			<li>
<p>
［
`GET$m ／ `HEAD$m
］要請に対する応答に対しては、これは，次の 2 つを指示する：
</p>
				<ul>
					<li>
`~target~URI$は、`内容~折衝$の~subjectである`資源$を指している。
</li>
					<li>
`~field値^V は、`選定された表現$用の，より特定な識別子である。
</li>
				</ul>

◎
• For a response to a GET or HEAD request, this is an indication that the target URI refers to a resource that is subject to content negotiation and the Content-Location field value is a more specific identifier for the selected representation.
</li>
			<li>
状態変更~methodに対する `201$st 応答に対しては、［
`Location$h `~field値$と一致する `~field値^V
］は，［
この【応答の】`~payload$は，新たに作成された`資源$の現在の`表現$である
］ことを指示する。
◎
• For a 201 (Created) response to a state-changing method, a Content-Location field value that is identical to the Location field value indicates that this payload is a current representation of the newly created resource.
</li>
			<li>
<p>
他の場合【他の応答に対しては？】、そのような `Content-Location^h は，次の 2 つを指示する：
◎
• Otherwise, such a Content-Location indicates that＼
</p>

				<ul>
					<li>
この【応答の】`~payload$は、要請された動作の状態sを報告している`表現$である。
◎
this payload is a representation reporting on the requested action's status and that＼
</li>
					<li>
同じ報告が、 `~field値^V に与えられた`~URI$においても（ `GET$m による未来の~access用に）可用である。
◎
the same report is available (for future access with GET) at the given URI.＼
</li>
				</ul>
<p>
例えば，［
`POST$m 要請を介して~~行われた購入~transaction
］は、［
`200$st 応答の`~payload$
］として，領収書を内包することもある
— このときの `~field値^V は、未来に 同じ領収書の複製を検索取得するための識別子を供する。
◎
For example, a purchase transaction made via a POST request might include a receipt document as the payload of the 200 (OK) response; the Content-Location field value provides an identifier for retrieving a copy of that same receipt in the future.
</p>
			</li>
		</ul>
	</dd>
</dl>

<p>
`Content-Location^h を要請~message内に送信する`~UA$は、その値が［
~UAが（その~UAにより~~行われた改変に先立って，）同封された`表現$の内容を~~元々得した所
］を指していることを言明している。
言い換えれば、~UAは，［
元の表現の~sourceへ戻る~link
］を供している。
◎
A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
</p>

<div class="p">
<p>
要請~message内に `Content-Location^h ~fieldを受信した`生成元~server$は：
◎
An origin server that receives a Content-Location field in a request message＼
</p>
<ul>
	<li>
その情報を，~~一過性の要請~文脈として扱わなければナラナイ
— `表現$の一部として逐語的に保存されることになる~metadataとしてではなく。
◎
MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation.＼
</li>
	<li>
その文脈を，要請の処理を手引きするために利用したり, 他の利用のために保存してもヨイ
— ~source~linkや~version法~metadataの中など。
◎
An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata.＼
</li>
	<li>
しかしながら、そのような文脈~情報を，その要請の意味論を改めるために利用してはナラナイ。
◎
However, an origin server MUST NOT use such context information to alter the request semantics.
</li>
</ul>
</div>

<p>
例えば、~clientが，折衝された`資源$に対し `PUT$m 要請を為して、生成元~serverが，その `PUT$m を（~redirectionなしに）受容した場合、その資源の新たな状態は，その `PUT$m に給された一つの`表現$と整合するものと期待される。
`Content-Location^h は、［
折衝された表現のうち一つだけを更新する
］ための
“逆-内容~選定~識別子”
の形としては，利用できない
— ~UAがそのような意味論を求めていたなら、
`Content-Location^h の~URIに，直に `PUT$m を適用したであろう。
◎
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.
</p>

		</section>
		<section id="response.validator">
<h3 title="Validators">7.9. 検証子</h3>
<p>
下に挙げる
`検証子~header@
は、`選定された表現$についての~metadataを伝達する。
◎
Validator header fields convey metadata about the selected representation (Section 7).＼
</p>

<p>
［
`安全$な要請に対する応答
］内の検証子~fieldは、［
応答の取扱い中に，`生成元~server$により選ばれ, `選定された表現$
］について述べる。
`状態s~code$の意味論に依存して、必ずしも［
所与の応答において`選定された表現$が，その応答の~payloadに同封されている表現と同じになる
］とは限らないことに注意。
◎
In responses to safe requests, validator fields describe the selected representation chosen by the origin server while handling the response. Note that, depending on the status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response payload.
</p>

<p>
［
状態変更 要請に対する成功裡な応答
］内の検証子~fieldは、［
その要請を処理した結果
］として，［［
それに先立って`選定された表現$
］を置換する，新たな`表現$
］について述べる。
◎
In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior selected representation as a result of processing the request.
</p>

<p>
例えば，［
`201$st 応答~内の `ETag$h ~field
］は、 “`更新喪失$” 問題を防止するため，［
新たに作成された資源の表現~用の `entity-tag$p
］を通信して、それを今後の`条件付き要請$内に利用できるようにする。
◎
For example, an ETag field in a 201 (Created) response communicates the entity-tag of the newly created resource's representation, so that it can be used in later conditional requests to prevent the "lost update" problem Section 12.1.
</p>

<div>
<ul><li>`ETag$h
</li><li>`Last-Modified$h
</li></ul>
◎
Table 5
Field Name 	Ref.

ETag 	7.9.3
Last-Modified 	7.9.2
</div>

<p>
この仕様は、［
`資源$の状態を観測する, および
`事前条件$を~testする
］ために共通的に利用される， 2 種の形の~metadata［
`改変~日時$,
`不透明$な `entity-tag$p
］を定義する。
`資源$の状態を反映する追加的な~metadataも，~HTTPの様々な拡張により定義されている
— この仕様の視野を超える
WebDAV（ `Web Distributed Authoring and Versioning^en, `RFC4918$r ）など。
`事前条件$の中で利用される資源~metadata値は、
`検証子@
と呼ばれる。
◎
This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (Section 7.9.2) and opaque entity tags (Section 7.9.3). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, [RFC4918]), that are beyond the scope of this specification. A resource metadata value is referred to as a "validator" when it is used within a precondition.
</p>

			<section id="weak.and.strong.validators">
<h4 title="Weak versus Strong">7.9.1. 弱い vs. 強い</h4>

<p>
検証子には、強いものと, 弱いものがある。
`弱い検証子$は，容易に生成できるが、比較~~用途には，あまり有用でない。
`強い検証子$は，比較~~用途に理想的であるが、効率的に生成するのは，とても困難にも（ときには不可能にも）なり得る。
~HTTPは、［
すべての形の`資源$に，同じ強さの検証子を固守する
］ことを課すのではなく，［
利用~中にある検証子の型を公開する
］こと, および［
`弱い検証子$を いつどこで`事前条件$に利用できるか
］についての制約を課す。
◎
Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.
</p>

<p>
`強い検証子@
とは、［
`表現~data$が変化する度に値が変化する，`表現~metadata$
］であって，［
`GET$m  に対する `200$st 応答
］の`~payload本体$にて観測-可能になるものである。
◎
A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a 200 (OK) response to GET.
</p>

<p>
`強い検証子$は、`表現~data$の変化-以外の理由
— `表現~metadata$の意味論的に有意な部分（例： `Content-Type$h ）が変更された，など —
から変化することもあるが、`生成元~server$にとって~~最大の関心~事は，［［
遠隔~cacheや著作~toolにより保持されている，格納-済み応答
］を無効化させる必要がある
］ときにのみ，値を変更することである。
◎
A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.
</p>

<p>
~cache~entryは、その失効~時機に関わらず，~~任意の期間 持続し続け得る。
したがって~cacheは、［
~~遠い過去に得された検証子を利用している~entry
］を検証しようと試みることもある。
`強い検証子$は、［
ある特定の`資源$に結付けられた，すべての`表現$のすべての~version
］間で，時経過にわたり一意になる。
しかしながら、［
互いに異なる資源
］の表現~間にわたる一意性については，含意されない（すなわち、同じ`強い検証子$が，同~時に複数の資源の表現から利用~中になり得るが、それらの表現が等価であることは含意されない）。
◎
Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).
</p>

<p>
実施においては、種々の`強い検証子$が利用されている。
厳密な改訂~制御に基づくものが最良である
— 表現に対する各~変更に際して，［
表現が `GET$m から~access可能にされる前
］に，常に，一意な~node名と改訂~識別子がアテガわれるような。
［
`応答~header$が送信されるに先立って，~dataが可用である
］下では，耐衝突~hash関数を`表現~data$に適用して得られる~digestでも足り、検証~要請が受信される度に計算し直す必要はない。
<span id="_errata-5236-1">
ただし、`資源$が［
~metadataにおいてのみ相違するような，別個な`表現$を持つ
］場合（`内容~折衝$の対象になる`~MIME型$のうち ~~複数のものが，同じ~data形式を共有するときに生じ得る）には、`生成元~server$は，それらの表現どうしを判別するための追加的な情報を，検証子に組入れる必要がある。</span>
◎
There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.
</p>

<div class="p">
<p>
対照的に，
`弱い検証子@
は、`表現~data$が変化しても変化しない場合もあるような，`表現~metadata$である。
この弱さは、次のいずれかに因り得る：
◎
In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to＼
</p>
<ul>
	<li>
`時計$の分解能などの，値が計算される方法における制限。
◎
limitations in how the value is calculated, such as clock resolution,＼
</li>
	<li>
`資源$にアリなすべての`表現$ 間での一意性を，確保できないとき。
◎
an inability to ensure uniqueness for all possible representations of the resource, or＼
</li>
	<li>
資源~所有者は、`表現$ 間で一意な~data列ではなく，何らかの自己決定的な等価性に基づいて、`表現$たちを いくつかの集合に~group化することを欲しているとき。
◎
a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.＼
</li>
</ul>

<p>
`生成元~server$は、［
先立つ`表現$たちが現在の`表現$の代用として受容-可能でない
］と見なす度に，`弱い$ `entity-tag$p を変更するベキである。
言い換えれば、~cacheの中の古い応答を無効化させたく求める度に，変更する~OUGHT。
◎
An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.
</p>
</div>

<p>
例えば、［
動的な測定法に基づいて 内容が秒単位で変化するような，天気~予報の表現
］は、同じ`弱い検証子$により，（`生成元~server$から見て）等価な表現の集合に~group化されるかもしれない
— ~cache済み表現が、（たぶん，~server負荷や天気の質に基づいて動的に調整されるような）適度な期間，有効であり続けられるようにするために。
同様に、表現の改変~時刻が秒単位の分解能で定義されていて，その表現が 1 秒~間に 2 回~改変され，それらの改変の合間に検索取得され得る場合には、`弱い検証子$になることがある。
◎
For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.
</p>

<p>
同様に、検証子は、所与の`資源$の~~複数の`表現$間で同~時に共有されているならば，`弱い$ものになる
— それらの`表現~data$が一致しない限り。
例えば、`生成元~server$が，［
`gzip$c `内容~符号法$が適用された表現
］に対し［
内容~符号法を伴わない表現のときと同じ`検証子$
］を送信する場合、それは`弱い検証子$になる。
しかしながら，複数の`表現$が，同じ`強い検証子$を同時に共有することもある
— 同じ`表現~data$に対し，複数の異なる`~MIME型$が可用であるときなど、それらが`表現~metadata$においてのみ相違する場合には。
【！ https://www.rfc-editor.org/errata/eid5162】
◎
Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.
</p>

<p>
`強い検証子$は、どの`条件付き要請$にも利用できる
— ［
`~cache検証$,
`部分的$な内容~範囲,
“`更新喪失$” 回避法
］も含め。
`弱い検証子$を利用できるのは、［
~clientが以前に得した`表現~data$との正確な同等性を要求しないとき
］に限られる
— ~cache~entryを検証するときや，近過去の変更に対しては~web~traversalを制限するときなど。
◎
Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.
</p>

			</section>
			<section id="field.last-modified">
<h4>7.9.2. `Last-Modified^h</h4>

<p>
応答~内の `Last-Modified$h ~headerは、`生成元~server$が要請の取扱いから結論に至った，
`改変~日時@
— `選定された表現$が最後に改変された日付時刻 —
を指示する時刻印を供する。
◎
The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.
</p>

<pre class="bnf">
`Last-Modified@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of its use is
</p>

<pre class="lang-http">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre>
</div>

				<section id="lastmod.generation">
<h5 title="Generation">7.9.2.1. 生成</h5>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
その最後の`改変~日時$を，適度かつ一貫するように決定できる
］ならば、
`Last-Modified$h を送信するベキである
— `条件付き要請$における その利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する有意な要因になり得るので。
◎
An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([Caching]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability.
</p>

<p>
表現は概して、資源~interfaceの背後にある多くの部分の総和である。
最後に改変された時刻は、通例的に［
それらの部分のどれかが変更された，最も近過去の時刻
］になる。
所与の任意の`資源$に対し，その値が決定される方法は、実装の詳細であり，この仕様の視野を超える。
~HTTPに関わるのは、
`Last-Modified$h ~headerの受信者たちが［
`条件付き要請$を為す ／
局所的に~cacheされた応答の有効性を~testする
］ために，その値をどう利用できるかである。
◎
A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification. What matters to HTTP is how recipients of the Last-Modified header field can use its value to make conditional requests and test the validity of locally cached responses.
</p>

<p>
`生成元~server$は、［［
自身が応答に対し `Date$h `~field値$を生成する時刻
］にアリな限り近い，`表現$の `Last-Modified$h 値
］を得するベキである。
これにより、受信者は，表現の改変 時刻を正確aに査定できるようになる
— とりわけ，表現の変化が［
応答が`生成され$た時刻
］に近い場合に。
◎
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.
</p>

<p>
`時計$を備える`生成元~server$は、［
~serverによる~message出生時の時刻（ `Date$h ）より後の， `Last-Modified$h 日時
］を送信してはナラナイ。
最後の改変~時刻が，［［
生成元~serverの`時計$に則って，ある未来の時刻に評価される
］ような実装に特有な~metadata
］から導出される場合、`生成元~server$は，その値を~message出生時の日時に置換しなければナラナイ。
未来の`改変~日時$は、`~cache検証$に~~悪影響があるので。
◎
An origin server with a clock MUST NOT send a Last-Modified date that is later than the server's time of message origination (Date). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.
</p>

<p>
`時計$を備えていない`生成元~server$は、応答に `Last-Modified$h 値をアテガってはナラナイ
— その値が、依拠-可能な`時計$を備える他の~systemや利用者により，`資源$に結付けられていない限り。
◎
An origin server without a clock MUST NOT assign Last-Modified values to a response unless these values were associated with the resource by some other system or user with a reliable clock.
</p>

				</section>
				<section id="lastmod.comparison">
<h5 title="Comparison">7.9.2.2. 比較</h5>

<p>
要請~内の検証子として利用される，応答~内の `Last-Modified$h 時刻（以下 `V^V ）は、次のいずれかの規則を利用して`強い検証子$であることが演繹できない限り，暗黙的に`弱い検証子$になる（以下における `表現^V は、その検証子に結付けられている`表現$を指す）：
◎
A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
</p>
<ul>
	<li>
<p>
`生成元~server$が、検証子 `V^V を， `表現^V に対する実際の現在の検証子と比較しているとき：
◎
The validator is being compared by an origin server to the actual current validator for the representation and,
</p>
		<ul>
			<li>
［
`V^V から定まる秒~数の間、 `表現^V が，2 回~以上†変化しない
］ことを、その生成元~serverが依拠-可能に知り得る。
【† twice — “もう 1 回” の意味？】
◎
That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator.
</li>
		</ul>
	</li>
	<li>
<p>
~clientが、 `表現^V に対する~cache~entryを持っているので，検証子 `V^V を［
`If-Modified-Since$h ／
`If-Unmodified-Since$h ／
`If-Range$h
］~header内に利用しつつあるとき：
◎
or
◎
The validator is about to be used by a client in an If-Modified-Since, If-Unmodified-Since, or If-Range header field, because the client has a cache entry for the associated representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値を内包する
］，かつ
◎
That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^V は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
	<li>
<p>
中継~cacheが、検証子 `V^V を，［
自身の~cache~entry内に格納-済みな， `表現^V 用の検証子
］と比較しているとき：
◎
or
◎
The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値
］を内包する，かつ
◎
That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^V は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
</ul>

<!-- 
上述から、同じ応答~内の検証子に対する
強い／弱い
の定義は、~server／~client／中継~cacheの間で異なり得ることになる。
-->

<p>
この演繹-法は、［
異なる 2 個の応答が，同じ秒の間に`生成元~server$から送信されたが、両者とも同じ `Last-Modified$h 時刻を持っていた場合には、少なくとも一方の応答は，その
`Last-Modified$h 時刻に等しい `Date$h 値を持つことになる
］という事実に依拠する。
恣意的な 60 秒の上限は、
`Date$h ＆ `Last-Modified$h 値が［
異なる`時計$, あるいは
応答を準備する間にずれた時刻
］から`生成され$る可能性に対する用心である。
実装は、 60 秒では短か過ぎると予見される場合は，より大きい値を利用してもヨイ。
◎
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
</p>

				</section>
			</section>
			<section id="field.etag">
<h4>7.9.3. `Etag^h</h4>

<p>
応答~内の `ETag$h ~fieldは、要請の取扱いから結論に至った，［
`選定された表現$用の現在の `entity-tag$p
］を供する。
`entity-tag$p は、同じ`資源$による複数の`表現$を相違化するための，`不透明$な検証子である。
それら複数の表現が何に因るのか
—［
`資源$の状態が時間とともに変化したことによるのか，
`内容~折衝$により同~時に複数の表現が妥当になったことによるのか
］, あるいはこの両者によるのか —
に関わらず。
`entity-tag$p の主部は，引用符で括られた`不透明$な文字列（ `opaque-tag$p ）であり、`弱い検証子$であるときは，それを指示する `weak$p 接頭辞も付与される：
◎
The "ETag" field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request. An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
</p>

<pre class="bnf">
`ETag@p
    = `entity-tag$p

`entity-tag@p
    = [ `weak$p ] `opaque-tag$p
`weak@p
    = ~Ps"W/"
`opaque-tag@p
    = `DQUOTE$P *`etagc$p `DQUOTE$P
`etagc@p
    = `21^X
    / `23-7E^X
    / `obs-text$p
    ; <span class="comment">
`DQUOTE^P を除く `VCHAR^P, および `obs-text^p
◎
VCHAR except double quotes, plus obs-text
</span>
</pre>

<p class="note">注記：
`opaque-tag$p は、以前には
`quoted-string$p （ `RFC2616/3.11$sec ）として定義されていた。
そのため、受信者の中には，~backslash~escapeを外そうとするものもある。
したがって，~serverは、
`entity-tag$p 内では~backslash文字を避ける~OUGHT。
◎
Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], Section 3.11); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.
</p>

<div class="p">
<p>
次のいずれかの状況では、
`entity-tag$p は，検証において`改変~日時$よりも依拠-可能になり得る：
◎
An entity-tag can be more reliable for validation than a modification date in situations＼
</p>
<ul>
	<li>
`改変~日時$を格納しにくい不都合がある。
◎
where it is inconvenient to store modification dates,＼
</li>
	<li>
~HTTP日時~値の秒単位の分解能では足らない。
◎
where the one-second resolution of HTTP date values is not sufficient, or＼
</li>
	<li>
`改変~日時$が一貫して保守されていない。
◎
where modification dates are not consistently maintained.
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre>
</div>

<p>
`entity-tag$p は、`弱い検証子$にも, `強い検証子$（これが既定）にも，なり得る。
`表現$に `entity-tag$p を供する`生成元~server$は、［
その代の `entity-tag$p が，`強い検証子$の特性すべてを満足する
］のではない場合には、
`entity-tag$p に `weak$p 接頭辞（ "`W/^c", 文字大小区別）を与えて，`弱い検証子$として~markしなければナラナイ。
◎
An entity-tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (Section 7.9.1), then the origin server MUST mark the entity-tag as weak by prefixing its opaque value with "W/" (case-sensitive).
</p>

<p>
送信者は、 `Etag^h ~fieldを`~trailer節$内に送信してもヨイ（ `5.6$sec を見よ）。
しかしながら，`~trailer$は無視されることが多いので、
`Etag^h は
— `entity-tag$p が~message本体の送信-中に生成されていない限り —
`~header$として送信する方が好ましい。
◎
A sender MAY send the Etag field in a trailer section (see Section 5.6). However, since trailers are often ignored, it is preferable to send Etag as a header field unless the entity-tag is generated while sending the message body.
</p>

				<section id="entity.tag.generation">
<h5 title="Generation">7.9.3.1. 生成</h5>

<div class="p">
<p>
`entity-tag$p の背後にある原理は、次の 2 点にある：
◎
The principle behind entity-tags is that＼
</p>
<ul>
	<li>
`資源$に対し最も正確aかつ効率的な検証の仕組みを選定するような，資源の実装を十分良く知るのは、~service作者のみである。
◎
only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that＼
</li>
	<li>
そのようなどの仕組みも、比較を容易にするために，単純な~octet列に対応付けれる。
◎
any such mechanism can be mapped to a simple sequence of octets for easy comparison.＼
</li>
</ul>

<p>
値は
`不透明@
なので、~clientは，各 `entity-tag$p がどう構築されたかを自覚する必要はない。
◎
Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed.
</p>
</div>

<p>
例えば、［
どの変化にも適用される，実装に特有な~version法
］を備える`資源$は、内部~改訂~番号を利用するかもしれない
— たぶん，互いの`表現$を正確aに相違化するため，`内容~折衝$用の変動~識別子と組合されるような。
［
表現~内容の耐衝突~hash ／
様々な~file属性の組合n ／
分解能が秒単位より細かい改変~時刻印
］を利用する実装もあり得る。
◎
For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.
</p>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
変化の検出を，適度かつ一貫するように決定できる
］ならば、
`ETag$h を送信するベキである
— `条件付き要請$における `entity-tag$p の利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する有意な要因になり得るので。
◎
An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([Caching]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability.
</p>

				</section>
				<section id="entity.tag.comparison">
<h5 title="Comparison">7.9.3.2. 比較</h5>

<p>
`entity-tag$p を比較するとき、その文脈において`弱い検証子$の利用が許容されるかどうかに依存して、次のいずれかの関数が用いられる：
◎
There are two entity-tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:
</p>

<ul>
	<li>
`強い比較~関数@
⇒
2 つの `entity-tag$p は、［
ともに`弱い検証子$でない, かつ
互いの `opaque-tag$p は各~文字ごとに合致する
］ならば，等価とされる。
◎
Strong comparison: two entity-tags are equivalent if both are not weak and their opaque-tags match character-by-character.
</li>
	<li>
`弱い比較~関数@
⇒
2 つの `entity-tag$p は、`弱い$かどうかに関わらず，［
互いの `opaque-tag$p は各~文字ごとに合致する
］ならば，等価とされる。
◎
Weak comparison: two entity-tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as "weak".
</li>
</ul>

<p>
各種［
2 つの `entity-tag$p
］例に対する，両~比較~関数の結果を下に示す:
◎
The example below shows the results for a set of entity-tag pairs and both the weak and strong comparison function results:
</p>

<div >
<table><thead><tr><td>`ETag$p （ 1 個目）
<td>`ETag^p （ 2 個目）
<td>`強い比較~関数$
<td>`弱い比較~関数$
</thead>

<tbody><tr><td>`W/"1"^c
<td>`W/"1"^c
<td>合致しない
<td>合致する

<tr><td>`W/"1"^c
<td>`W/"2"^c
<td>合致しない
<td>合致しない

<tr><td>`W/"1"^c
<td>`"1"^c
<td>合致しない
<td>合致する

<tr><td>`"1"^c
<td>`"1"^c
<td>合致する
<td>合致する

</tbody></table>
◎
Table 6
ETag 1 	ETag 2 	Strong Comparison 	Weak Comparison

W/"1" 	W/"1" 	no match 	match
W/"1" 	W/"2" 	no match 	no match
W/"1" 	"1" 	no match 	match
"1" 	"1" 	match 	match
</div>

				</section>
				<section id="example.entity.tag.vs.conneg">
<h5 title="Example: Entity-Tags Varying on Content-Negotiated Resources">7.9.3.3. 内容~折衝された資源により `entity-tag^p が様々になる例</h5>

<p>
`資源$が`内容~折衝$の~subjectであって，
`GET$m 要請に対する応答~内に送信される`表現$が
`Accept-Encoding$h 要請~headerに基づいて様々になるときを考える。
◎
Consider a resource that is subject to content negotiation (Section 11), and where the representations sent in response to a GET request vary based on the Accept-Encoding request header field (Section 11.1.4):
</p>

<div class="example">
<p>
&gt;&gt; 要請：
◎
&gt;&gt; Request:
</p>

<pre class="lang-http">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
</pre>

<p>
この事例では、応答は
`gzip$c `内容~符号法$を利用するとき／しないときがあるとする。
利用しない場合の応答は、次の様な~~形になる：
◎
In this case, the response might or might not use the gzip content coding. If it does not, the response might look like:
</p>

<p>
&gt;&gt; 応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</pre>

<p>
代替~表現が `gzip^c `内容~符号法$を利用するときは：
◎
An alternative representation that does use gzip content coding would be:
</p>

<p>
&gt;&gt;
応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

`…~binary~data…^com
</pre>
</div>

<p class="note">注記：
`内容~符号法$は`表現~data$の~propertyであり、~cache更新や`範囲~要請$の間に競合が起きないようにするため、［
内容が符号化された`表現$,
されていない`表現$
］に対する`強い$ `entity-tag$p は，互いに別個なものになる。
対照的に，`転送~符号法$は、~message転送の間に限り適用されるので，別個な `entity-tag$p にはならない。
◎
Note: Content codings are a property of the representation data, so a strong entity-tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (Section 7 of [Messaging]) apply only during message transfer and do not result in distinct entity-tags.
</p>

				</section>
			</section>
			<section id="when.to.use.entity.tags.and.last-modified.dates">
<h4 title="When to Use Entity-Tags and Last-Modified Dates">7.9.4. `entity-tag^p と `Last-Modified^h  日時 をいつ利用するか</h4>

<p>
`GET$m ／ `HEAD$m に対し， `200$st で応答する`生成元~server$は：
◎
In 200 (OK) responses to GET or HEAD, an origin server:
</p>
<ul>
	<li>
`entity-tag$p 検証子を送信するベキである
— その生成-が~~困難でない限り。
◎
SHOULD send an entity-tag validator unless it is not feasible to generate one.
</li>
	<li>
`強い$ `entity-tag$p の代わりに `弱い$ `entity-tag$p を送信してもヨイ
— 処理能の~~観点から弱い `entity-tag$p の利用が~~支持される, あるいは
強い `entity-tag$p の送信が~~困難ならば。
◎
MAY send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag.
</li>
	<li>
`Last-Modified$h 値を送信するベキである
— その送信が~~困難でなければ。
◎
SHOULD send a Last-Modified value if it is feasible to send one.
</li>
</ul>

<p>
言い換えれば，`生成元~server$に選好される挙動は、検索取得~要請に対する成功裡な応答において，［
`強い$ `entity-tag$p, `Last-Modified$h 値
］の両者を送信することである。
◎
In other words, the preferred behavior for an origin server is to send both a strong entity-tag and a Last-Modified value in successful responses to a retrieval request.
</p>

<p>
`~client$は：
◎
A client:
</p>
<ul class="switch">
	<li>
`生成元~server$から `entity-tag$p が供されていた場合
⇒
（ `If-Match$h ／ `If-None-Match$h を利用する）どの`~cache検証~要請$ 内にも，その `entity-tag$p を送信しなければナラナイ。
◎
MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server.
</li>
	<li>
`生成元~server$から `Last-Modified$h 値のみが供されていた場合
⇒
（ `If-Modified-Since$h を利用する）非~部分範囲 `~cache検証~要請$ 内に，`Last-Modified$h 値を送信するベキである。
◎
SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
</li>
	<li>
~HTTP10`生成元~server$から `Last-Modified$h 値のみが供されていた場合
⇒
（ `If-Unmodified-Since$h を利用する）部分範囲 `~cache検証~要請$ 内に
`Last-Modified$h 値を送信してもヨイ。
困難な事例【？】では、~UAは，これを不能化する仕方を供するベキである。
◎
MAY send the Last-Modified value in subrange cache validation requests (using If-Unmodified-Since) if only a Last-Modified value has been provided by an HTTP/1.0 origin server. The user agent SHOULD provide a way to disable this, in case of difficulty.
</li>
	<li>
`生成元~server$から［
`entity-tag$p, `Last-Modified$h 値
］の両者が供されていた場合
⇒
`~cache検証~要請$ 内に，両~検証子とも送信するベキである。
これにより、［
~HTTP10, ~HTTP11
］~cacheのいずれも，適切に応答できるようになる。
◎
SHOULD send both validators in cache validation requests if both an entity-tag and a Last-Modified value have been provided by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="methods">
<h2 title="Methods">8. ~method</h2>

		<section id="method.overview">
<h3 title="Overview">8.1. 概観</h3>

<p>
要請 `method$p ~tokenが、要請の意味論の首な源になる：
それは、`~client$が［
当の要請を為した目的, および成功裡な結果として期待するもの
］を指示する。
◎
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
</p>

<p>
`要請~method$の意味論は、要請~内に［
その~methodと競合しないような意味論を追加する，何らかの~header
］が在るときには、更に特化され得る。
例えば，~clientは、`条件付き要請~header$を送信して，［
`~target資源$の現在の状態に要請される動作
］を条件付きにすることができる。
◎
The request method's semantics might be further specialized by the semantics of some header fields when present in a request if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields (Section 12.1) to make the requested action conditional on the current state of the target resource.
</p>

<pre class="bnf">
`method$p
    = `token$p
</pre>
【！ Errata 4224 Rejected】

<p>
~HTTPは、~~元々は，分散型の~obj~system用の~interfaceとして利用できるように設計された。
`要請~method$は、［
識別された~obj上に定義された~methodの呼出ngが，意味論を適用することになる
］のと ほぼ同じように，［
`~target資源$に意味論を適用するもの
］として想起された。
◎
HTTP was originally designed to be usable as an interface to distributed object systems. The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.
</p>

<p>
そのため、 `method$p ~tokenは，文字大小区別である
— ［
~method名が文字大小区別であるような，~objに基づく~system
］への~gatewayとしても，利用され得るので。
標準~化された~method名は、慣行により，大文字のみからなる~US-ASCII英字で定義される。
◎
The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
</p>

<p>
分散型の~objと違って、~HTTPにおける標準~化された`要請~method$は，`資源$に特有ではない
— ~networkに基づく~systemにおいては、統一的な~interfaceの方が［
可視性, 再利用
］を良く供するので `REST$r 。
標準~化された~methodは、いったん定義されたなら，どの資源に適用されるときにも 同じ意味論を備える~OUGHT
— それらの意味論を，自身に［
実装する／許容する
］かどうかは、それぞれの資源が決定するが。
◎
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
</p>

<p>
この仕様は、~HTTPにおいて共通的に利用される，いくつかの標準~化された~methodを定義する。
それらは、次の一覧に要旨される：
◎
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table.
◎
Table 7
Method 	Description 	Ref.
</p>

<table>
<thead><tr>
<th>~method
<th>記述
</thead><tbody>

<tr><td>`GET$m
<td>
`~target資源$の現在の`表現$を転送する。
◎
Transfer a current representation of the target resource. 	8.3.1

<tr><td>`HEAD$m
<td>
`GET$m と同じだが，要請~本体は転送しない。
◎
Same as GET, but do not transfer the response body. 	8.3.2

<tr><td>`POST$m
<td>
要請~payloadに対し，資源に特有な処理を遂行する。
◎
Perform resource-specific processing on the request payload. 	8.3.3

<tr><td>`PUT$m
<td>
~target資源の現在の表現~すべてを，要請~payloadに置換する。
◎
Replace all current representations of the target resource with the request payload. 	8.3.4

<tr><td>`DELETE$m
<td>
~target資源の現在の表現~すべてを，除去する。
◎
Remove all current representations of the target resource. 	8.3.5

<tr><td>`CONNECT$m
<td>
~target資源で識別される`~server$へ，`~tunnel$を確立する。
◎
Establish a tunnel to the server identified by the target resource. 	8.3.6

<tr><td>`OPTIONS$m
<td>
~target資源~用の通信~optionを述べる。
◎
Describe the communication options for the target resource. 	8.3.7

<tr><td>`TRACE$m
<td>
~target資源への経路に沿って~message~loop-back~testを遂行する。
◎
Perform a message loop-back test along the path to the target resource. 	8.3.8
</tbody></table>

<p>
すべての一般用`~server$は、
`GET$m および `HEAD$m を~supportしなければナラナイ。
他の~methodの~supportは、すべて`任意選択^2119である。
◎
All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.
</p>

<div class="p">
<p>
`~target資源$に許容される~methodの集合は，
`Allow$h ~header内に~listできる／され得る。
加えて，その集合は、
【応答ごとに】
動的に変更できる／変化し得る。
◎
The set of methods allowed by a target resource can be listed in an Allow header field (Section 9.2.1). However, the set of allowed methods can change dynamically.＼
</p>

<p>
`生成元~server$は：
◎
＼
</p>
<ul>
	<li>
自身が認識できない／実装していない `要請~method$を受信したときは、
`501$st で応答するベキである。
◎
When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.＼
</li>
	<li>
自身に既知であるが，~target資源には許容されない `要請~method$を受信したときは、
`405$st で応答するベキである。
◎
When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.
</li>
</ul>
</div>

<p>
この仕様の視野から外れる，追加的な~methodも、~HTTPにおける利用~用に指定されている。
そのような~methodは，すべて、
`15.1$sec にて述べるとおりに，
`~HTTP~method~registry^citeの中に登録される~OUGHT。
◎
Additional methods, outside the scope of this specification, have been specified for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry", as described in Section 15.1.
</p>

		</section>
		<section id="method.properties">
<h3 title="Common Method Properties">8.2. 共通な~method~property</h3>

			<section id="safe.methods">
<h4 title="Safe Methods">8.2.1. 安全な~method</h4>

<p>
`要請~method$は、［
それに定義される意味論が本質的に読専
］であるとき，
`安全@
（ `safe^en ）であると見なされる
— すなわち，`~client$は、［
安全な~methodを`~target資源$に適用した結果
］として，`生成元~server$上の いかなる状態~変化も，要請しない／期待しない。
同様に，［
安全な~methodの適度な利用
］は、生成元~server上に，いかなる［
害／~propertyの損失／~~非常な負担
］も及ぼさないものと期待されている。
◎
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
</p>

<p>
この［
安全な~methodの定義
］は、その呼出ngが［
有害にもなり得る ／
読専でない~~部分がある ／
副作用を及ぼす
］ような挙動を含まないことを 実装に~~強いるものではない。
しかしながら，重要な点は、`~client$は［
追加的な挙動を要請しないし, それについて~~関知できない
］ことにある。
例えば、ほとんどの~serverは，［
~methodに関わらず，応答が完了するごとに 要請~情報を~access~log~fileに付加する
］が、［
その~log~storageが満杯になり，~serverが~crashする可能性がある
］としても，安全と見なされる。
同様に，~Web広告を選定することにより起動される 安全な要請には、広告料を課金するような副作用があることが多い。
◎
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
</p>

<p>
この仕様が定義する`要請~method$のうち［
`GET$m ,
`HEAD$m ,
`OPTIONS$m ,
`TRACE$m
］は、安全であるものと定義される。
◎
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
</p>

<p>
~methodが安全か否かを判別する目的は、［
自動化された検索取得~処理n（~spider）／
~cache処理能の最適化（事前fetch）
］が，害を及ぼす心配なしに働けるようにすることにある。
加えて，~UAが［
信用できない~~可能性もある内容
］を処理する際に、安全でない~methodが自動的に利用されないよう，適切な拘束を適用することも可能になる。
◎
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
</p>

<p>
`~UA$は、~methodが安全か否かを判別して、安全でない動作は要請される前に利用者が自覚できるよう，~~行われ得る動作を利用者に呈示するベキである。
◎
A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
</p>

<p>
`資源$が［
`~target~URI$に~~埋め込まれた~parametersが，動作を選定する効果を持つ
］ように構築されているとき、［
その動作が，`要請~method$の意味論に整合する
］ことを確保することは，資源~所有者の責務である。
例えば，［
~Webに基づく内容~編集~softwareが，
`query$p ~parameterに~~埋め込まれた動作を利用する
］ことは、共通的にある
— "`page?do=delete^c" など。
そのような資源の目的が，安全でない動作の遂行-である場合、資源~所有者は，［
それが安全な要請~methodを利用して~accessされる
］ときには，その動作を不能化するか, 不許可にしなければナラナイ。
さもなければ、［
~link保守, 事前fetch, 探索~indexを築く, 等々
］の~~目的で，［
どの`~URI参照$に対しても，自動化~処理により `GET$m が遂行される
］ときに、~~望ましくない副作用が~~生じることになる。
◎
When a resource is constructed such that parameters within the target URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
</p>

			</section>
			<section id="idempotent.methods">
<h4 title="Idempotent Methods">8.2.2. 冪等~method</h4>

<p>
`要請~method$は、［
複数回の［
互いに一致する，その~methodを伴う要請
］により意図される，`~server$に対する効果
］が［
単独の そのような要請による効果
］と同じになるとき，
`冪等@
（ `idempotent^en ）であると見なされる。
この仕様が定義する要請~methodのうち［
`PUT$m,
`DELETE$m,
`安全$であるもの
］は、冪等である。
【`安全$な要請~methodは、定義により，この仕様が定義しないものでも冪等になるであろう。】
◎
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
</p>

<p>
`安全$の定義と同様に、冪等性の定義が適用されるのは，［
利用者から何が要請されたか
］に限られる
— `~server$が、各 冪等な要請に対し［
その~logを別にとるのも,
改訂~制御~用の履歴を維持するのも,
他の非~冪等な副作用を実装するのも
］自由である。
◎
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
</p>

<p>
冪等な~methodには、［
`~client$が`~server$の応答を読取れるようになる前に，通信が失敗した場合には、要請を自動的に繰返せる
］という~~特徴がある。
例えば、~clientが `PUT$m 要請を送信したとき，応答が受信される前に 下層の接続が~closeされた場合、~clientは，新たな接続を確立して冪等な要請を再試行できる。
元の要請が成功していたとしても、その要請を繰返した結果が
— 応答は相違するかもしれないが —
意図された効果と同じになることは，わかっているので。
◎
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
</p>

<div class="p">
<p>
`~client$は、［
`冪等$でない~methodを伴う要請
］を自動的に再試行するベキではない
— ただし，何らかの手段により次のいずれかを行い得るときは除く：
◎
A client SHOULD NOT automatically retry a request with a non-idempotent method unless it has＼
</p>
<ul>
	<li>
~methodに関わらず，実際に要請の意味論が`冪等$であることを知る。
◎
some means to know that the request semantics are actually idempotent, regardless of the method, or＼
</li>
	<li>
元の要請は決して【~target資源に】適用されていないことを検出する。
◎
some means to detect that the original request was never applied.
</li>
</ul>

<p>
例えば，［
所与の`資源$に対する `POST$m 要請が安全である
］ことを（設計または環境設定を通して）知る`~UA$は、その要請を自動的に繰返せる。
同様に，［
~version制御~repository上で運用するように特定的に設計された~UA
］は、部分的~失敗~条態から，概ね次の流れで回復するであろう：
◎
For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by＼
</p>
<ol>
	<li>
接続が失敗した後に，`~target資源$の改訂履歴を検査する。
◎
checking the target resource revision(s) after a failed connection,＼
</li>
	<li>
部分的に適用された変更を復帰するか, 修正する。
◎
reverting or fixing any changes that were partially applied,＼
</li>
	<li>
しかる後，その失敗した要請を自動的に再試行する。
◎
and then automatically retrying the requests that failed.
</li>
</ol>
</div>

<p>
一部の~clientは、自動的な再試行を起動するために，より弱い兆候を利用する。
例えば、 `POST$m 要請を送信したが，応答を一部でも受信する前に下層の~transport接続が~closeされたとき。
これは共通して実装されているが、推奨されない。
◎
Some clients use weaker signals to initiate automatic retries. For example, when a POST request is sent, but the underlying transport connection is closed before any part of the response is received. Although this is commonly implemented, it is not recommended.
</p>

<p>
`~proxy$は、冪等でない要請を自動的に再試行してはナラナイ。
`~client$は、［
失敗した自動的な再試行
］を自動的に再試行するベキでない。
◎
A proxy MUST NOT automatically retry non-idempotent requests. A client SHOULD NOT automatically retry a failed automatic retry.
</p>

			</section>
			<section id="cacheable.methods">
<h4 title="Methods and Caching">8.2.3. ~methodと~caching</h4>

<p>
~cacheが応答を格納して利用するためには、結付けられている~methodが~cachingを明示的に許容していて，応答を後続の要請を満足するために利用できる条件について詳細を与える必要がある
— ~method定義がそうしていない場合、~cacheできない。
追加的な要件については、 `Caching$r を見よ。
◎
For a cache to store and use a response, the associated method needs to explicitly allow caching, and detail under what conditions a response can be used to satisfy subsequent requests; a method definition which does not do so cannot be cached. For additional requirements see [Caching].
</p>

<p>
この仕様は、［
`GET$m, `HEAD$m, `POST$m 
］~method用の~caching意味論を定義する
— 大多数の~cache実装は、 `GET$m, `HEAD$m のみを~supportしているが。
◎
This specification defines caching semantics for GET, HEAD, and POST, although the overwhelming majority of cache implementations only support GET and HEAD.
</p>

			</section>
		</section>
		<section id="method.definitions">
<h3 title="Method Definitions">8.3. ~method定義</h3>

			<section id="GET">
<h4>8.3.1. `GET^m</h4>

<p>
`GET^m ~methodは、現在の［
`~target資源$用に`選定される表現$
］を転送するよう要請する。
◎
The GET method requests transfer of a current selected representation for the target resource.
</p>

<p>
`GET^m は、情報を検索取得する首な仕組みであり，ほぼすべての処理能 最適化の力点が置かれる所である。
よって、誰かが［
~HTTPを介して識別できる何らかの情報を検索取得する
］ことについて話すとき，たいていは `GET^m 要請を為すことを指している。
成功裡な応答は、`~target~URI$により識別される “同じさの質” を反映する。
また，応用を［
重要な各~資源に対し，~URIを生産する
］よう構築すれば、他の応用にとって可用になる資源は~~増え，~Webの更なる拡がりを促進する~network効果を生産することになる。
◎
GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request. A successful response reflects the quality of "sameness" identified by the target URI. In turn, constructing applications such that they produce a URI for each important resource results in more resources being available for other applications, producing a network effect that promotes further expansion of the Web.
</p>

<p>
資源~識別子は 遠隔~file~systemの~pathnameで，`表現$は そのような~file内容の複製であると、~~考えられがちである。
事実、多くの資源が実装されている方法でもある（関係する~securityの考慮点については `16.3$sec を見よ）。
しかしながら、実施において そのような制限は無い。
◎
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see Section 16.3 for related security considerations). However, there are no such limitations in practice.
</p>

<p>
資源~用の~HTTP~interfaceは、単に［
内容~objの~tree ／
様々な~database~record上の~program的な~view ／
他の情報~systemへの~gateway
］などとして実装される見込みも高い。
`~URI$対応付けの仕組みが，~file~systemに縛られているときでも、`生成元~server$は，［
~fileを直に転送するのではなく，［
要請を入力に~fileを実行して、その出力として，表現を送信する
］ように環境設定される
］こともある。
いずれにせよ、 `GET^m に対する応答において，［
その各~資源~識別子を，どの実装に対応させるか
］や, ［
各~実装が［
`~target資源$の現在の表現を選定して送信すること
］を，どう管理するか
］を知る必要があるのは、生成元~serverのみである。
◎
The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.
</p>

<p>
`~client$は、要請~内に `Range$h ~headerを送信することにより，
`GET^m の意味論を`範囲~要請$
— `選定された表現$を成すいくつかの部分に限り，転送を要請する要請 —
に改めることもできる。
◎
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a Range header field in the request (Section 13.2).
</p>

<p>
~clientは、 `GET^m 要請~内に本体を`生成する$ベキでない。
`GET^m 要請~内に受信される~payloadには、意味論は定義されず，要請の意味や~targetを改めることはない
— 加えて，`要請~密入~攻撃$ `Messaging$r のおそれがあるので、一部の実装を［
要請を却下して接続を~closeする
］よう導くかもしれない。
◎
A client SHOULD NOT generate a body in a GET request. A payload received in a GET request has no defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [Messaging]).
</p>

<p>
`GET^m 要請に対する応答は，`~cache可能$である
— `Cache-Control$h ~headerから指示されない限り、［
後続の `GET^m ／ `HEAD$m 要請を満足する
］ために，その応答を~cacheに利用してもヨイ。
~cacheは、 `GET^m 要請~内に受信した~payloadを
— その内容を問わず —
無視して~cacheする見込みが高い。
◎
The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [Caching]). A cache that receives a payload in a GET request is likely to ignore that payload and cache regardless of the payload contents.
</p>

<p>
情報の検索取得が，利用者が供した情報から`~target~URI$を構築する仕組み
— 例： `GET^m を利用している~formの~query~fieldなど —
で遂行されるとき、~URIの中に開示するには適切にならない，敏感になり得る~dataが供されるかもしれない（ `16.9$sec を見よ）。
一部の事例では、そのような情報を露呈しないよう，当の~dataを［
~filter／形式変換
］できる。
他の事例では
— 特に，応答を~cacheしても便益は無いときは —
`GET^m に代えて `POST$m ~methodを利用すれば、そのような情報は，通例的に
— 新たな~URIを構築することなく —
要請の本体~内に伝送されることになる。
◎
When information retrieval is performed with a mechanism that constructs a target URI from user-provided information, such as the query fields of a form using GET, potentially sensitive data might be provided that would not be appropriate for disclosure within a URI (see Section 16.9). In some cases, the data can be filtered or transformed such that it would not reveal such information. In others, particularly when there is no benefit from caching a response, using the POST method (Section 8.3.3) instead of GET will usually transmit such information in the request body rather than construct a new URI.
</p>

			</section>
			<section id="HEAD">
<h4>8.3.2. `HEAD^m</h4>

<p>
`HEAD^m ~methodは、［
~serverが，応答~内に`~message本体$を送信してはナラナイ（すなわち，応答は、`~header節$の終端で終了する）
］ことを除いて、 `GET$m と一致する。
`~server$は、 `HEAD^m 要請に対する応答~内に，［
要請が `GET$m であったときに送信することになる~headerたち
］と同じ~headerたちを送信するベキである
— ただし、それらのうち`~payload~header$は省略されてもヨイ。
この~methodは、［
`表現~data$を転送することなく，`選定された表現$についての~metadataを得する
］ために利用でき、また，［［
妥当性 ／ ~accessibility ／ 近過去の改変
］のために~hypertext~linkを~testする
］ときに，利用されることが多い。
◎
The HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section). The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields (Section 5.5) MAY be omitted. This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.
</p>

<p>
`HEAD^m 要請~messageの~payloadには、意味論は定義されない
— 既存の実装には、`~payload本体$を伴って送信されてきた `HEAD^m 要請を，却下するものもある。
◎
A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.
</p>

<p>
`HEAD^m 要請に対する応答は，`~cache可能$である
— `Cache-Control$h ~headerから指示されない限り、［
後続の `HEAD^m 要請を満足する
］ために~cacheが利用されてもヨイ。
`HEAD^m 応答も，［
以前に~cacheされた `GET$m に対する応答
］に効果を及ぼすことがある
— `Caching/4.3.5$sec を見よ。
◎
The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [Caching]). A HEAD response might also have an effect on previously cached responses to GET; see Section 4.3.5 of [Caching].
</p>

			</section>
			<section id="POST">
<h4>8.3.3. `POST^m</h4>

<p>
`POST^m ~methodは、［
`~target資源$が，自前の特有な意味論に則って，要請~内に同封された`表現$を処理する
］ことを要請する。
例えば `POST^m は、次の機能~用に利用される（他にもある）:
◎
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):
</p>
<ul>
	<li>
［
HTML ~formに手入力された一連の~field
］などの~data~blockを，~data取扱い処理nに供する。
◎
Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
</li>
	<li>
［
掲示板,
ニュースグループ,
メーリングリスト,
ブログ,
その他~同類の記事~群
］などへ，~messageを投函する。
◎
Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
</li>
	<li>
`生成元~server$により まだ識別されていない，新たな資源を作成する。
◎
Creating a new resource that has yet to be identified by the origin server; and
</li>
	<li>
既存の資源の，いくつかの`表現$に、~dataを付加する。
◎
Appending data to a resource's existing representation(s).
</li>
</ul>

<p>
`生成元~server$は、［
`POST^m 要請の処理~結果に依存して，適切な状態s~codeを選ぶ
］ことにより，応答の意味論を指示する
— `POST^m に対する応答~内には、この仕様が定義する ほぼすべての状態s~codeを，受信させることもできる（例外は： `206$st, `304$st, `416$st ）。
◎
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification could be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)).
</p>

<div class="p">
<p>
`POST^m 要請が成功裡に処理された結果，`生成元~server$上にて 1 個以上の資源が作成された場合、生成元~serverは，次を包含する `201$st 応答を送信するベキである：
◎
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing＼
</p>
<ul>
	<li>
［
作成された`首な資源$用の識別子
］を供する `Location$h ~header,
◎
a Location header field that provides an identifier for the primary resource created (Section 9.2.3) and＼
</li>
	<li>
新たな資源（たち）を指しつつ, 要請の状態sも述べるような，`表現$。
◎
a representation that describes the status of the request while referring to the new resource(s).
</li>
</ul>
</div>

<p>
`POST^m 要請に対する応答は、`~cache可能$になるのは［
それが，明示的な`鮮度~情報$を内包する, かつ `Content-Location$h ~headerは `POST^m の`~target~URI$と同じ値をとる
］ときに限られる。
~cache済み `POST^m 応答は、後の［
`GET$m ／ `HEAD$m
］要請を満足するために再利用できるが、
`POST^m 要請には再利用できない
— `POST^m は`生成元~server$を通して書き出されることが要求され, そうするのは安全でないので。
`Caching/4$sec を見よ。
◎
Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [Caching]) and a Content-Location header field that has the same value as the POST's target URI (Section 7.8). A cached POST response can be reused to satisfy a later GET or HEAD request, but not a POST request, since POST is required to be written through to the origin server, because it is unsafe; see Section 4 of [Caching].
</p>

<p>
`POST^m の処理~結果が，既存の資源の`表現$と等価になる場合、`生成元~server$は、［
その既存の資源の識別子を `Location$h ~header【！~field】内に伴う， `303$st 応答
］を送信して，`~UA$を~redirectしてもヨイ。
これには、特典がある
— 資源~識別子を~UAに供して，表現を［
`共用~cache$が，より~~受容し易い~method
］を介して転送させるような
— ~UAが~cache済み表現をまだ持っていない場合には，余分な要請~costがかかるが。
◎
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
</p>

			</section>
			<section id="PUT">
<h4>8.3.4. `PUT^m</h4>

<p>
`PUT^m ~methodは、［
`~target資源$の状態を，［
要請~message~payload内に同封された`表現$により定義される状態
］として作成する, あるいはその状態に置換する
］ことを要請する。
［
所与の表現に対する成功裡な `PUT^m
］は、［
同じ~target資源に対する後続の `GET$m の結果が，
`200$st 応答~内に送信されている表現と等価になる
］ことを示唆する。
しかしながら，［
そのような状態~変化が観測-可能になる
］ことは保証されない
— ~target資源は、［
後続の `GET$m が受信される前に，並列的な 他の~UAにより動作されたり
］, ［
`生成元~server$による動的~処理の~subjectである
］こともあるので。
成功裡な応答は、その処理~時点で［
~UAの意図が，生成元~serverにより達成された
］ことのみを含意する。
◎
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
</p>

<p>
`生成元~server$には、以下の要件が課される
— 以下、 `PUT^m された`表現$を `P^V と記す：
◎
↓</p>
<ul>
	<li>
<p>
`~target資源$が現在の`表現$を：
◎
↓</p>
		<ul>
			<li>
持たない場合
⇒
`PUT^m が何か一つを成功裡に作成したときは、
`201$st 応答を`~UA$に送信してその旨を伝えなければナラナイ。
◎
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.＼
</li>
			<li>
持つ場合
⇒
その表現が， `P^V の状態に則って 成功裡に改変されたときは、
`200$st または `204$st 応答を送信して，要請の成功裡な完了を指示しなければナラナイ。
◎
If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.
</li>
		</ul>
	</li>
	<li>
`PUT^m 要請~内に受信した［
`~header$／`~trailer$
］のうち，認識できないものは、無視する（すなわち，資源~状態の一部として保存しない）ベキである。
◎
An origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., do not save them as part of the resource state).
</li>
	<li>

<div class="p">
<p>
［
`~target資源$に備わる［
`PUT^m により変更できない／されることにはならない
］ようにする，どの拘束
］にも， `P^V が整合することを検証yするベキである。
これは特に、`生成元~server$が［
`~URI$に関係する内部 環境設定~情報を利用して，
`GET$m 応答~上の`表現~metadata$用の値を設定している
］ときに，重要になる。
◎
An origin server SHOULD verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT. This is particularly important when the origin server uses internal configuration information related to the URI in order to set the values for representation metadata on GET responses.＼
</p>

<p>
`P^V が~target資源と整合でないときには、次のいずれかをするベキである：
◎
When a PUT representation is inconsistent with the target resource, the origin server SHOULD either＼
</p>
		<ul>
			<li>
［
`P^V を形式変換するか, 資源についての環境設定を変更する
］ことにより，それらを整合させる。
◎
make them consistent, by transforming the representation or changing the resource configuration, or＼
</li>
			<li>
［
何故 `P^V が相応しくないかを説明するに足る情報
］を包含する，適切な~error~messageで応答する。
それが `Content-Type$h 値に対する拘束に特有であるときは、［
`409$st ／ `415$st
］が示唆される。
◎
respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.
</li>
		</ul>
</div>

<p>
例えば，［
`~target資源$が常に `Content-Type$h に "`text/html^c" を持つ
］ように環境設定されていて, ［
`P^V は `Content-Type$h に "`image/jpeg^c" を持つ
］場合、次のいずれかをする~OUGHT：
◎
For example, if the target resource is configured to always have a Content-Type of "text/html" and the representation being PUT has a Content-Type of "image/jpeg", the origin server ought to do one of:
</p>

		<ul>
			<li>
~target資源が新たな`~MIME型$を反映するように，環境設定し直す。
◎
reconfigure the target resource to reflect the new media type;
</li>
			<li>
`P^V を新たな資源~状態として保存する前に、
`P^V の形式が資源の形式と整合するように，
`P^V を形式変換する。
◎
transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,
</li>
			<li>
要請に対し、［
~target資源が "`text/html^c" に制限されていることを指示する， `415$st 応答
］で却下する
— たぶん［
新たな`表現$に相応しい~targetになる，異なる資源への~link
］を内包するような。
◎
reject the request with a 415 (Unsupported Media Type) response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.
</li>
		</ul>
	</li>
</ul>

<div class="p">
<p>
~HTTPは、次のものは定義しない：
◎
HTTP does not define＼
</p>
<ul>
	<li>
`PUT^m ~methodが `生成元~server$の状態に正確にどう影響するかについて
— ［
~UA要請の意図や, 生成元~serverによる応答の意味論により表出できるもの
］を超えるような。
◎
exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and＼
</li>
	<li>
資源が何になり得るかについて
— ［
~HTTPを介して供される~interface
］を超えるような，その言葉が表すいかなるイミにおいても。
◎
the semantics of the origin server response.＼
It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP.＼
</li>
	<li>
資源~状態がどう “格納される” か。
◎
It does not define how resource state is "stored", nor＼
</li>
	<li>
資源~状態が変化した結果，そのような~storageがどう変化し得るか。
◎
how such storage might change as a result of a change in resource state, nor＼
</li>
	<li>
生成元~serverが，資源~状態をどう`表現$に翻訳するか。
◎
how the origin server translates resource state into representations.＼
</li>
</ul>

<p>
一般に，［
資源~interfaceの背後にある，実装の詳細すべて
］は、~serverにより意図的に隠される。
◎
Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
</p>
</div>

<div class="p">
<p>
`生成元~server$は、次の両者が~~満たされない限り，［
`PUT^m に対する成功裡な応答
］内に
— `ETag$h や `Last-Modified$h などの —
`検証子~header$を送信してはナラナイ：
◎
An origin server MUST NOT send a validator header field (Section 7.9), such as an ETag or Last-Modified field, in a successful response to PUT unless＼
</p>
<ul>
	<li>
要請の`表現~data$は、本体にいかなる形式変換も適用されずに，保存された（すなわち，資源の新たな表現~dataは、 `PUT^m 要請~内に受信された表現~dataと一致する）。
◎
the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and＼
</li>
	<li>
`検証子$を成す`~field値$は、新たな`表現$を反映している。
◎
the validator field value reflects the new representation.＼
</li>
</ul>

<p>
この要件により，`~UA$は、［
~memory内に持つ表現の本体が，現在の `PUT^m の結果そのままであるとき
］を知れるようになる
— したがって，生成元~serverから再び検索取得する必要はなくなり、また，［
応答~内に受信した，新たな`検証子$（たち）
］を未来の`条件付き要請$に利用して，偶発的な上書-を防止できるようになる。
◎
This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 12.1).
</p>
</div>

<div class="p">
<p>
`POST$m と `PUT^m の間の根本的な相違は、同封された`表現$の意図が異なることにある：
◎
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation.＼
</p>
<ul>
	<li>
`POST$m 要請には、`~target資源$が［
同封された表現を，資源による自前の意味論に則って取扱う
］ことが意図される。
◎
The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas＼
</li>
	<li>
`PUT^m 要請は、［
同封された表現が，~target資源の状態を置換する
］ものとして定義される。
◎
the enclosed representation in a PUT request is defined as replacing the state of the target resource.＼
</li>
</ul>

<p>
よって，`PUT^m の意図は、その正確な効果が 生成元~serverのみに既知であっても，`冪等$であり、`中継者$からは可視になる。
◎
Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
</p>
</div>

<p>
`PUT^m 要請を適正に解釈するためには、［
~UAが，どの`~target資源$が【利用者から】欲されているか知っている
］ことが前提になる。
［
~clientに利するために、状態変更 要請を受信した後，適正な`~URI$を選定する~service
］は、
`PUT^m ではなく， `POST$m ~methodを利用して実装するベキである。
`生成元~server$は、要請された `PUT^m を
— それにより`~target資源$の状態を変更することなく —
異なる資源に適用したいと望む場合
— 当の資源が異なる~URIへ移動されたときなど —
には，適切な `3xx$st 応答を送信しなければナラナイ。
また，`~UA$は、要請を~redirectするかどうかに関して，自前の裁定を下してもヨイ。
◎
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.
</p>

<p>
`~target資源$に適用される `PUT^m 要請は、他の`資源$に副作用を及ぼし得る。
例えば，ある記事は、 “各種~version” （ある時点で他のいずれかの~versionと同じ状態を共有する，互いに異なる資源）を識別するために，別々の`~URI$を持ち得る。
したがって， “現在の~version” の~URIに対する成功裡な `PUT^m 要請は、~target資源の状態を変化させた上で，新たな~versionの資源を作成する
— 更には、関係する資源~間の~linkを追加することもある。
◎
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
</p>

<div class="p">
<p>
所与の`~target資源$に対し `PUT^m を許容する`生成元~server$は、［
`Content-Range$h ~headerを包含する `PUT^m 要請
］に対しては， `400$st 応答を送信しなければナラナイ
— その~payloadは、［
誤って全部的な`表現$として `PUT^m された，部分的~内容【！ ＊？】
］である見込みが高いので。
部分的な内容の更新は、次のいずれかによりアリである：
◎
An origin server that allows PUT on a given target resource MUST send a 400 (Bad Request) response to a PUT request that contains a Content-Range header field (Section 13.4), since the payload is likely to be partial content that has been mistakenly PUT as a full representation. Partial content updates are possible＼
</p>
<ul>
	<li>
より大きい資源のある部位に重なるような状態にある，別々に識別される資源を~targetする。
◎
by targeting a separately identified resource with state that overlaps a portion of the larger resource, or＼
</li>
	<li>
部分的な更新~用に特定的に定義された，異なる~methodを利用する（例えば，`RFC5789$r にて定義される `PATCH$m ~method）。
◎
by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [RFC5789]).
</li>
</ul>
</div>

<p>
`PUT^m ~methodに対する応答は、`~cache可能$でない。
成功裡な `PUT^m 要請が，［
`~target~URI$用に格納-済みな応答を 1 個以上~持つ~cache
］を通して渡された場合、それらの格納-済み応答は，`無効化-$されることになる。
◎
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [Caching]).
</p>

			</section>
			<section id="DELETE">
<h4>8.3.5. `DELETE^m</h4>

<p>
`DELETE^m ~methodは、［
`生成元~server$に，`~target資源$と，その現在の機能性との間の結付けを除去してもらう
］ことを要請する。
この~methodの効果は、 UNIX の rm ~commandに類似する：
それは、［
以前に結付けられた情報が削除される
］という期待ではなく，［
生成元~serverによる~URI対応付けにおける削除~演算
］を表出する。
◎
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
</p>

<p>
`~target資源$が 現在の`表現$を 1 個以上~持つ場合に，それらが［
`生成元~server$により破壊されたり, 結付けられた~storageが取戻される
］かどうかは、［
その資源の資質と, 生成元~serverによる その実装（この仕様の視野を超える）
］に全面的に依存する。
同様に、 `DELETE^m の結果として，［
~databaseや~gateway接続など，資源の他の実装~側面
］が~deactivateされる／~archiveされる必要が~~生じることもある。
一般に，生成元~serverが `DELETE^m を許容するのは、削除を成遂げる仕組みが制定されている資源に限られるものと見做されている。
◎
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
</p>

<p>
`DELETE^m ~methodを許容する資源は、相対的に少数である
— それは首に、［
利用者が，その効果に関して指令する
］ような，遠隔~著作~用の環境に利用される。
例えば，［
`PUT$m 要請を利用して，以前に作成された資源
］や［
`POST$m 要請に対する`201$st 応答の `Location$h ~headerを介して識別される資源
］は、それらの動作を~~元に戻すような，対応する `DELETE^m 要請を許容することもある。
同様に，［
~HTTP利用して改訂を制御する~clientなど，遠隔~運用~用の著作~機能を実装する~custom~UA実装
］では、［
~version~repositoryに対応するように加工されている，~serverの~URI空間
］についての前提に基づいて， `DELETE^m を利用できることもある。
◎
Relatively few resources allow the DELETE method — its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the Location header field after a 201 (Created) response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
</p>

<div class="p">
<p>
`DELETE^m ~methodが成功裡に適用された場合、`生成元~server$は、動作~~状況に応じて，次のいずれかの状態s~codeを送信するベキである：
◎
If a DELETE method is successfully applied, the origin server SHOULD send
</p>
<ul>
	<li>
動作は成功する見込みが高いが、まだ~~実行済みでない場合
⇒
`202$st
◎
a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted,
</li>
	<li>
動作は実行済みで、更なる情報は給されない場合
⇒
`204$st
◎
a 204 (No Content) status code if the action has been enacted and no further information is to be supplied, or
</li>
	<li>
動作は実行済みで、応答~messageが［
その状態sを述べる`表現$
］を内包する場合
⇒
`200$st
◎
a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status.
</li>
</ul>

【！ Errata ID: 4436 "," → ";" 訳には影響なし】
</div>

<p>
`~client$は、 `DELETE^m 要請~内に本体を生成するベキでない。
`DELETE^m 要請~内に受信された~payloadは、意味論は定義されない
— 要請の意味や~targetを改めることはないことに加え，一部の実装に要請を却下するよう導くかもしれない。
◎
A client SHOULD NOT generate a body in a DELETE request. A payload received in a DELETE request has no defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request.
</p>

<p>
`DELETE^m ~methodに対する応答は、`~cache可能$でない。
成功裡な `DELETE^m 要請が［
`~target~URI$用に格納-済みな応答を， 1 個以上~持つ~cache
］を通して渡された場合、それらの格納-済み応答は，`無効化-$されることになる。
◎
Responses to the DELETE method are not cacheable. If a successful DELETE request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [Caching]).
</p>

			</section>
			<section id="CONNECT">
<h4>8.3.6. `CONNECT^m</h4>

<p>
`CONNECT^m ~methodは、［［
`要請~target$により識別される，行先の生成元~server
］への`~tunnel$を確立する
］こと, および［
それに成功したならば、~tunnelが~closeされるまで，受信者の挙動を
— 両~方向とも —
~dataの盲目的な回送に制約する
］ことを，`受信者$に要請する。
~tunnelは、［
1 個以上の`~proxy$を通して，端点間の仮想~接続を作成する
］ときに共通的に利用される
— しかる後、 ~TLS（ `Transport Layer Security^en, `RFC8446$r ）を利用して~secure化できるようになる。
◎
The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request target and, if successful, thereafter restrict its behavior to blind forwarding of data, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [RFC8446]).
</p>

<p>
`CONNECT^h は，~HTTP接続の［
要請／応答
］に関する資質を変更するので、その意味論を~protocolの伝送路~形式へ対応付ける仕方は，特定の~HTTP~versionごとに異なるかもれない。
◎
Because CONNECT changes the request/response nature of an HTTP connection, specific HTTP versions might have different ways of mapping its semantics into the protocol's wire format.
</p>

<p>
`CONNECT^m は、`~proxy$への要請に利用するためのみに意図されている。
`生成元~server$は，［
自身に向けられた `CONNECT^m 要請を受信した
］ときは、接続が確立されたことを指示するために，
`2xx$st で応答してもヨイ。
しかしながら，ほとんどの生成元~serverは、 `CONNECT^m を実装しない。
◎
CONNECT is intended only for use in requests to a proxy. An origin server that receives a CONNECT request for itself MAY respond with a 2xx (Successful) status code to indicate that a connection is established. However, most origin servers do not implement CONNECT.
</p>

<p>
`~client$が `CONNECT^m 要請を送信するときは、`要請~target$として，
`authority$p 成分を送信しなければナラナイ
— すなわち，`要請~target$は、~colonで分離された，`~tunnel$の行先の［
~host名, ~port番号
］のみからなる。
◎
A client sending a CONNECT request MUST send the authority component (described in Section 3.2 of [RFC3986]) as the request target; i.e., the request target consists of only the host name and port number of the tunnel destination, separated by a colon.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
</pre>
</div>

<div class="p">
<p>
`受信者$`~proxy$は、［
`要請~target$へ直に接続する
］か, あるいは［
別の~proxyを利用するよう環境設定されている場合は，
`CONNECT^m 要請を`内方$にある次の~proxyへ回送する
］ことにより，`~tunnel$を確立できる：
◎
The recipient proxy can establish a tunnel either by directly connecting to the request target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy.＼
</p>
<ul>
	<li>
どの `2xx$st 応答も、［
成功裡な応答の`~header節$を締めくくる空行
］の直後に，［
`送信者$（および すべての内方`~proxy$）が~tunnel~modeへ切替えることになる
］ことを指示する
— その空行より後に受信される~dataは、［
`要請~target$により識別される~server
］からのものになる。
◎
Any 2xx (Successful) response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request target.＼
</li>
	<li>
成功裡な応答 以外のどの応答も、［
~tunnelは まだ形成されておらず，接続は ~HTTPにより統治され続ける
］ことを指示する。
◎
Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
</li>
</ul>
</div>

<div class="p">
<p>
`~tunnel$は、［
~tunnel中継者が，いずれかの側がその接続を~closeしたことを検出した
］とき，~closeされる
— その際には、`中継者$は，順に次をしなければナラナイ：
◎
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST＼
</p>
<ol>
	<li>
~closeされた側から来た，応答待ち~dataすべてを、他の側へ送信することを試みる。
◎
attempt to send any outstanding data that came from the closed side to the other side,＼
</li>
	<li>
接続を両~側とも~closeする。
◎
close both connections, and＼
</li>
	<li>
送達されてない残りの~dataは、すべて破棄する。
◎
then discard any remaining data left undelivered.
</li>
</ol>
</div>

<p>
~proxy認証が，`~tunnel$を作成するための権限を確立するために利用されることもある。
◎
Proxy authentication might be used to establish the authority to create a tunnel.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
</pre>
</div>

<p>
任意な~serverへ`~tunnel$を確立することには、有意な~riskがある
— 特に、その行先が，~Web流通~用には意図されていない［
周知の／予約-済みな
］~TCP~portであるときは。
例えば，［
"`example.com:25^c" への `CONNECT^m
］は、~proxyに［
~SMTP流通~用に予約-済みな~port
］へ接続するよう示唆することになるであろう
— 許容された場合、~proxyを，~spam~emailを中継させるように騙せてしまう。
`CONNECT^m を~supportする`~proxy$は、その利用を［
既知な~portの制限された集合
］または［
環境設定できる，安全な`要請~target$たちからなる~whitelist
］に制約するベキである。
◎
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
</p>

<p>
`~server$は、［
`CONNECT^m に対する `2xx$st 応答
］内に［
`Transfer-Encoding$h ／ `Content-Length$h
］~headerを送信してはナラナイ。
`~client$は、［
`CONNECT^m に対する成功裡な応答
］内に受信された［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerを，無視しなければナラナイ。
◎
A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.
</p>

<p>
`CONNECT^m 要請~messageの~payloadには、意味論は定義されない
— 既存の実装には、`~payload本体$を伴って送信されてきた `CONNECT^m 要請を却下するものもある。
◎
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
</p>

【！ Errata 4351 Rejected ~ERRATA/eid4351】

<p>
`CONNECT^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the CONNECT method are not cacheable.
</p>

			</section>
			<section id="OPTIONS">
<h4>8.3.7. `OPTIONS^m</h4>

<p>
`OPTIONS^m ~methodは、［
`生成元~server$／介在している`中継者$
］に対し，［
`~target資源$に可用な通信~optionについての情報
］を要請する。
この~methodにより，`~client$は、資源に対する動作を含意することなく［［
資源に結付けられた，~optionや要件
］／
~serverの能力
］を決定できるようになる。
◎
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
</p>

<p>
`OPTIONS^m 要請のうち，`要請~target$として~asterisk （ "`*^c" ）を伴うものは、特定の資源に対してではなく，
`~server-wide@
に適用される。
`~server$の通信~optionは，概して資源に依存するので、この種の要請が有用になるのは
— “`ping^en” や “`no-op^en” の類いの~methodのような —
~clientが~serverの能力を~testする以上のことは何もしないものに限られる。
例えば これを、［
`~HTTP11$への適合性（または その欠如）について，`~proxy$を~testする
］ときに利用できる。
◎
An OPTIONS request with an asterisk ("*") as the request target (Section 6.1) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
</p>

<p>
`要請~target$が~asterisk "`*^c" でない場合、当の `OPTIONS^m 要請は，`~target資源$と通信するときに可用な~optionに適用される。
◎
If the request target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
</p>

<div class="p">
<p>
`~server$は、そのような `OPTIONS^m に対し成功裡な応答を`生成する$ときは：
◎
A server generating a successful response to OPTIONS＼
</p>
<ul>
	<li>
自身が実装している~headerのうち，［
`~target資源$に適用-可能な，任意選択な特能を指示するかもしれないもの
］（例： `Allow$h ）すべてを
— この仕様で定義されていない拡張があれば，それも含めて —
送信するベキである。
◎
SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.＼
</li>
	<li>
応答~payloadも（もしあれば）、~machineやヒトから読取可能な`表現$により，通信~optionを述べるかもしれない。
そのような表現~用の標準~形式は、この仕様では定義されないが，将来の~HTTP拡張により定義されるかもしれない。
◎
The response payload, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.
</li>
</ul>
</div>

<p>
`~client$は、 `OPTIONS^m 要請~内に，［
要請の`連鎖$にある，特定の`受信者$
］に宛てて `Max-Forwards$h ~headerを送信してもヨイ。
`~proxy$は、受信した要請を回送するときには，それが
`Max-Forwards$h ~headerを伴っていない限り，
`Max-Forwards$h ~headerを`生成し$てはナラナイ。
◎
A client MAY send a Max-Forwards header field in an OPTIONS request to target a specific recipient in the request chain (see Section 6.4.2). A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.
</p>

<p>
`~client$は、［
`~payload本体$を包含する `OPTIONS^m 要請
］を`生成する$ときは，［
`表現$の`~MIME型$を述べる妥当な `Content-Type$h ~header
］を送信しなければナラナイ。
この仕様は，そのような~payloadのいかなる利用も定義しないことに注意。
◎
A client that generates an OPTIONS request containing a payload body MUST send a valid Content-Type header field describing the representation media type. Note that this specification does not define any use for such a payload.
</p>

<p>
`OPTIONS^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the OPTIONS method are not cacheable.
</p>

			</section>
			<section id="TRACE">
<h4>8.3.8. `TRACE^m</h4>

<div class="p">
<p>
`TRACE^m ~methodは、当の要請~messageに対し，［
遠隔からの，応用~levelの~loop-back
］を要請する。
要請の`最終-受信者$は、受信した~messageを反映するべく，次のような `200$st 応答を~clientへ返送するベキである：
</p>
<ul>
	<li>
応答には， `Content-Type$h 値に "`message/http$c" を伴わせる。
</li>
	<li>
受信した~messageを，応答の`~message本体$に含ませる。
</li>
	<li>
ただし、下に述べるいくつかの`~field$は，~messageから除外する。
</li>
</ul>
◎
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a Content-Type of "message/http" (Section 10.1 of [Messaging]).＼
</div>

<p>
`最終-受信者@
とは、`生成元~server$, または最初に［
要請~内の `Max-Forwards$h 値に 0 を受信した`~server$
］である。
◎
The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 6.4.2).
</p>

<p>
`~client$は、 `TRACE^m 要請~内に［
応答により開示され得るような，敏感な~dataを包含する`~field$
］を`生成し$てはナラナイ。
例えば，［
格納されている利用者の`資格証$や~cookie `RFC6265$r
］を `TRACE^m 要請~内に送信するような~UAは、無分別であろう。
要請の`最終-受信者$が，応答~本体を`生成する$ときには、［
敏感な~dataを包含しそうな どの要請`~field$
］も除外するベキである。
◎
A client MUST NOT generate fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials Section 10 or cookies [RFC6265] in a TRACE request. The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response body.
</p>

<p>
`TRACE^m により、`~client$は，［
要請の`連鎖$における，他方の終端で受信されているもの
］を見て，その~dataを［
~test用や診断~情報
］に利用できるようになる。
特に関心を呼ぶものは、要請~連鎖の跡をなぞる，
`Via$h ~headerの値である。
`Max-Forwards$h ~headerにより、~clientは，要請~連鎖の長さを制限できるようになる
— それは、［
~messageを回送している`~proxy$の`連鎖$が，無限~loopになっている
］かどうか，~testするときに有用になる。
◎
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (Section 6.4.3) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
</p>

<p>
`~client$は、 `TRACE^m 要請~内に`~message本体$を送信してはナラナイ。
◎
A client MUST NOT send a message body in a TRACE request.
</p>

<p>
`TRACE^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the TRACE method are not cacheable.
</p>

			</section>
		</section>
	</section>
	<section id="context">
<h2 title="Context">9. 文脈</h2>

		<section id="request.context">
<h3 title="Request Context">9.1. 要請~文脈</h3>

<div class="p">
<p>
`~client$は、次のいずれかのために
`要請~header@
を送信する：
◎
A client sends request header fields to＼
</p>
<ul>
	<li>
要請~文脈についての更なる情報を供する。
◎
provide more information about the request context,＼
</li>
	<li>
`~target資源$の状態に基づいて，要請を条件付きにする。
◎
make the request conditional based on the target resource state,＼
</li>
	<li>
応答に選好される形式を示唆する。
◎
suggest preferred formats for the response,＼
</li>
	<li>
認証用の`資格証$を給する。
◎
supply authentication credentials, or＼
</li>
	<li>
期待される要請~処理を改変する。
◎
modify the expected request processing.＼
</li>
</ul>

<p>
これらの`~field$は、~programming言語の~methodに渡す~parameterに類似な，要請の改変子として動作する。
◎
These fields act as request modifiers, similar to the parameters on a programming language method invocation.
</p>
</div>

<p>
次に挙げる要請~headerは、［
利用者, ~UA, 要請の背後にある資源
］についての情報も含め，要請の文脈について 追加的な情報を供する
⇒＃
`Expect$h,
`From$h,
`Referer$h,
`TE$h,
`Trailer$h,
`User-Agent$h
◎
The following request header fields provide additional information about the request context, including information about the user, user agent, and resource behind the request.
◎
Table 8
Field Name 	Ref.

Expect 	9.1.1
From 	9.1.2
Referer 	9.1.3
TE 	9.1.4
Trailer 	9.1.5
User-Agent 	9.1.6
</p>


			<section id="field.expect">
<h4>9.1.1. `Expect^h</h4>

<p>
要請~内の `Expect^h ~headerは、
`期待@
（ `expectation$p ）を指示する
— それは、［
当の要請を適正に取扱うためには、~serverが~supportする必要がある
］ような，一定の挙動の集合である。
◎
The "Expect" header field in a request indicates a certain set of behaviors (expectations) that need to be supported by the server in order to properly handle this request.
</p>

<pre class="bnf">
`Expect@p
    = #`expectation$p
`expectation@p
    = `token$p [ "=" ( `token$p / `quoted-string$p ) `parameters$p ]
</pre>

<p>
`Expect^h `~field値$は文字大小無視である。
◎
The Expect field value is case-insensitive.
</p>

<p>
この仕様が定義する唯一の期待は、
"`100-continue$c" である（定義される~parameterは無い）。
◎
The only expectation defined by this specification is "100-continue" (with no defined parameters).
</p>

<p>
`Expect^h にて［
`100-continue$c 以外の~memberを包含している`~field値$
］を受信した`~server$は、
`417$st で応答して，予期されない期待には応えられないことを指示してもヨイ。
◎
A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.
</p>

<p>
`期待$
`100-continue@c
は、［
`~client$は，当の要請~内に（大概は巨大な）`~message本体$を送信しつつあり、［
~method, `~target~URI$, および各種~header
］が［
即時に成功をもたらすには足らない／~redirectになる／~error応答になる
］かどうかについて，`暫定-応答$ `100$st の受信-を望んでいる
］ことを`受信者$に伝える。
これにより、~clientは，~~事前に［
~message本体を送信するに~~価するかどうかの指示
］があるまで待機できるようになり、~message本体が~~巨大なときや,
~errorになる見込みが高いと~clientが見越すとき（例：以前に検証yされた認証用の`資格証$を伴わずに，初回に状態変更~methodを送信するとき）に，効率性を改善できる。
◎
A 100-continue expectation informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a 100 (Continue) interim response if the method, target URI, and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the message body before actually doing so, which can improve efficiency when the message body is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).
</p>

<div class="example">
<p>
例えば，次で始まる要請により：
◎
For example, a request that begins with
</p>

<pre class="lang-http">
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue
</pre>
</div>

<p>
`生成元~server$は、［
`~client$が，不必要な~data転送で~pipeを埋め~~始める
］前に，［
`401$st や `405$st などの~error~message
］で即時に応答できるようになる。
◎
allows the origin server to immediately respond with an error message, such as 401 (Unauthorized) or 405 (Method Not Allowed), before the client starts filling the pipes with an unnecessary data transfer.
</p>

<p>
`~client$に課される要件は：
◎
Requirements for clients:
</p>
<ul>
	<li>
`~message本体$を内包しない要請~内に
`100-continue$c 期待を`生成し$てはナラナイ。
◎
A client MUST NOT generate a 100-continue expectation in a request that does not include a message body.
</li>
	<li>
要請の`~message本体$を送信する前に， `100$st 応答を待機するつもりがあるときは、
`100-continue$c 期待を包含する `Expect^h ~headerを送信しなければナラナイ。
◎
A client that will wait for a 100 (Continue) response before sending the request message body MUST send an Expect header field containing a 100-continue expectation.
</li>
	<li>
`100-continue$c 期待を送信してから，特定の長さの時間 待機することは、要求されない
— 応答がまだ受信されないうちに，`~message本体$の送信を続行してもヨイ。
更には，
`100$st 応答は ~HTTP10中継者を通しては送信され得ないので、~message本体を送信する前に不定~期間 待機するベキでない。
◎
A client that sends a 100-continue expectation is not required to wait for any specific length of time; such a client MAY proceed to send the message body even if it has not yet received a response. Furthermore, since 100 (Continue) responses cannot be sent through an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite period before sending the message body.
</li>
	<li>
`100-continue$c 期待を包含する要請に対する応答~内に， `417$st を受信したときは、その要請を，
`100-continue$c 期待を除いた上で，繰返すベキである
— この `417^st0 応答は、単に，［
応答の`連鎖$は、期待を~supportしていない
］ことを指示するので（例：~HTTP10~serverを通して渡されるとき）。
◎
A client that receives a 417 (Expectation Failed) status code in response to a request containing a 100-continue expectation SHOULD repeat that request without a 100-continue expectation, since the 417 response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server).
</li>
</ul>

<p>
`~server$に課される要件は：
◎
Requirements for servers:
</p>
<ul>
	<li>
~HTTP10要請~内に受信された
`100-continue$c 期待は、無視しなければナラナイ。
◎
A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.
</li>
	<li>
次のいずれかに該当する場合、
`100$st 応答の送信を省略してもヨイ
⇒＃
対応する要請の`~message本体$の一部をすでに受信している／
~frame法が，~message本体が無いことを指示している
◎
A server MAY omit sending a 100 (Continue) response if it has already received some or all of the message body for the corresponding request, or if the framing indicates that there is no message body.
</li>
	<li>
`100$st 応答を送信した後，`~message本体$を受信して処理したなら、接続が尚早に~closeされない限り，最終的には `最終-応答$【！最終-状態s~code】を送信しなければナラナイ。
◎
A server that sends a 100 (Continue) response MUST ultimately send a final status code, once the message body is received and processed, unless the connection is closed prematurely.
</li>
	<li>
要請の`~payload本体$ 全体を読取る前に，`最終-応答$【！最終-状態s~code】で応答するときは、次のどちらを意図するか指示するベキである
⇒＃
接続を~closeする（例： `Messaging/9.6$sec を見よ）／
~payload本体の読取りを継続する
◎
A server that responds with a final status code before reading the entire request payload body SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [Messaging]) or continue reading the payload body.
</li>
</ul>

<p>
［
`生成元~server$／`~proxy$
］は、`~HTTP11$（以上の~versionの）［
~method, `~target~URI$, 完全な`~header節$
］を受信したとき，それが［
`100-continue$c 期待を包含していて，要請の`~message本体$が後続することを指示している
］ならば：
◎
↓</p>
<ul>
	<li>
<p>
`生成元~server$は、次のいずれかをしなければナラナイ：
◎
An origin server MUST, upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request message body will follow, either＼
</p>
		<ul>
			<li>
［
~method, `~target~URI$, 各~header
］を精査するだけで，状態sを決定できるならば、即時に その`状態s~code$を伴う`最終-応答$【！最終-状態s~codeを伴う応答】を送信する。
◎
send an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or＼
</li>
			<li>
`100$st 応答を送信して，~clientに要請の`~message本体$を送信してもらうよう奨励する
— この場合、この応答を送信する前に，~message本体を待機してはナラナイ。
◎
send an immediate 100 (Continue) response to encourage the client to send the request's message body. The origin server MUST NOT wait for the message body before sending the 100 (Continue) response.
</li>
		</ul>
	</li>
	<li>
<p>
`~proxy$は、次のいずれかをしなければナラナイ：
◎
A proxy MUST, upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request message body will follow, either＼
</p>
		<ul>
			<li>
［
~method, `~target~URI$, 各~header
］を精査するだけで，状態sを決定できるならば、即時に その`状態s~code$を伴う`最終-応答$【！最終-状態s~codeを伴う応答】を送信する。
◎
send an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or＼
</li>
			<li>
<p>
`内方$にある次の`~server$へ対応する［
~method, `~target~URI$【！＊`request-line$p】, `~header節$
］を送信することにより、`生成元~server$へ向けて当の要請を回送し始める。
◎
begin forwarding the request toward the origin server by sending a corresponding request-line and header section to the next inbound server.＼
</p>

<p>
ただし，［
内方にある次の~serverが~HTTP10のみを~supportする
］ことを（環境設定または過去のやりとりから）予見できるならば、`~client$に`~message本体$を送信し始めてもらうよう，即時に `100$st 応答を`生成し$てもヨイ。
◎
If the proxy believes (from configuration or past interaction) that the next inbound server only supports HTTP/1.0, the proxy MAY generate an immediate 100 (Continue) response to encourage the client to begin sending the message body.
</p>
			</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`Expect^h ~headerは、
~~元々の~HTTP11 `RFC2068$r が発行された後に，［
`暫定-応答$ `100$st を要請する手段
］と［
解さなければならない拡張を指示するための一般的な仕組み
］の両者として追加された。
しかしながら，この拡張の仕組みは、~clientからは未だ利用されていないことに加え，多くの~serverは その要件を実装していないため、拡張の仕組みの具現化は，無用と化している。
`100-continue$c の定義とその処理を単純~化するため、この仕様は，その拡張の仕組みを除去した。
◎
Note: The Expect header field was added after the original publication of HTTP/1.1 [RFC2068] as both the means to request an interim 100 (Continue) response and the general mechanism for indicating must-understand extensions. However, the extension mechanism has not been used by clients and the must-understand requirements have not been implemented by many servers, rendering the extension mechanism useless. This specification has removed the extension mechanism in order to simplify the definition and processing of 100-continue.
</p>

			</section>
			<section id="field.from">
<h4>9.1.2. `From^h</h4>

<p>
`From^h ~headerは、［
要請を~~発行する~UAを制御するヒト利用者
］の~Internet~email~addressを包含する。
~addressは、~machineから利用-可能な，
`RFC5322/3.4$sec にて定義される `mailbox^p になる~OUGHT：
◎
The "From" header field contains an Internet email address for a human user who controls the requesting user agent. The address ought to be machine-usable, as defined by "mailbox" in Section 3.4 of [RFC5322]:
</p>

<pre class="bnf">
`From@p
    = `mailbox$p

`mailbox@p
    = &lt;mailbox, `RFC5322/3.4$sec&gt;
</pre>

<div class="example">
<p>
例：
◎
An example is:
</p>

<pre class="lang-http">
From: webmaster@example.org
</pre>
</div>

<p>
`From^h ~headerが非~robotic~UAにより送信されることは稀である。
`~UA$は、利用者により明示的に環境設定されない限り，
`From^h ~headerを送信するベキでない
— ［
利用者の~privacyへの関心や, それらの~siteの~security施策
］と競合するであろうから。
◎
The From header field is rarely sent by non-robotic user agents. A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.
</p>

<p>
~robotic~UAは、自身が［
過度な／求まれていない／妥当でない
］要請を送信しているときなど，［
~server上に問題が生じた場合に，~robotを稼働させている~~責務者と連絡をとれる
］ような，［
妥当な `From^h ~header
］を送信するベキである。
◎
A robotic user agent SHOULD send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.
</p>

<p>
`~server$は、 `From^h ~headerを［
~access制御や認証
］用に利用するベキでない
— ほとんどの受信者は、この~headerの値を公な情報であると見做すことになるので。
◎
A server SHOULD NOT use the From header field for access control or authentication, since most recipients will assume that the field value is public information.
</p>

			</section>
			<section id="field.referer">
<h4>9.1.3. `Referer^h</h4>

<p>
`Referer^h ~headerにより、`~UA$は［
`~target~URI$を得した所の資源
］用に，`~URI参照$を指定できるようになる（すなわち， “referrer（~~参照元）”
— `~field名$の綴りは誤っているが）。
`~UA$は、 `Referer^h `~field値$を`生成する$際に，~URI参照に［
`fragment$p ／ `userinfo$p
］成分 `RFC3986$r を内包してはナラナイ。
◎
The "Referer" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the "referrer", though the field name is misspelled). A user agent MUST NOT include the fragment and userinfo components of the URI reference [RFC3986], if any, when generating the Referer field value.
</p>

<pre class="bnf">
`Referer@p
    = `absolute-URI$p / `partial-URI$p
</pre>

<p>
`~field値$は、`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、参照先の~URIは，`~target~URI$に相対的になる（ `RFC3986/5$sec ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 4), the referenced URI is relative to the target URI ([RFC3986], Section 5).
</p>

<p>
`Referer^h ~headerにより、`~server$は，［
単純な解析,
~log取り,
最適化された~caching,
等々
］のために，他の資源へ戻れる~linkを生成できるようになる。
それはまた、保守~用に［
廃用にされた／誤入力された
］~linkを見出すことも可能にする。
一部の~serverは、 `Referer^h ~headerを，［
他~siteからの~link（いわゆる “`deep linking^en” ）を否認したり,
CSRF （ cross-site request forgery ）を制約する
］ための手段として利用するが、すべての要請がそれを包含するわけではない。
◎
The Referer header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc. It also allows obsolete or mistyped links to be found for maintenance. Some servers use the Referer header field as a means of denying links from other sites (so-called "deep linking") or restricting cross-site request forgery (CSRF), but not all requests contain it.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Referer: http://www.example.org/hypertext/Overview.html
</pre>
</div>

<p>
`~target~URI$が［
~URIを持たない源から得されたもの
］である場合（例：利用者~keyboardからの入力, 利用者の~bookmark）、
`Referer^h ~fieldを除外するか, または その値に "`about:blank^c" を送信しなければナラナイ。
◎
If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent MUST either exclude the Referer field or send it with a value of "about:blank".
</p>

<p>
`Referer^h ~fieldが［
要請の文脈や, 利用者の閲覧~履歴についての情報
］を露呈し得る場合、それは，［
参照元~資源の識別子が（~account名などの）個人-情報を露呈したり
］, あるいは［
資源が機密的と想定される（~firewallの背後や, ~secure化された~serviceの内部など）
］場合に，~privacy上の懸念になる。
ほとんどの一般用~UAは、参照元~資源が局所的な［
"`file^c" ／ "`data^c"
］~URI【`~scheme$】であるときには，
`Referer^h ~headerを送信しない。
`~UA$は、［
参照元~pageが~secure~protocolで受信されていた
］場合には，~secure化されてない~HTTP要請~内に
`Referer^h ~headerを送信してはナラナイ。
追加的な~securityの考慮点については、 `16.9$sec を見よ。
◎
The Referer field has the potential to reveal information about the request context or browsing history of the user, which is a privacy concern if the referring resource's identifier reveals personal information (such as an account name) or a resource that is supposed to be confidential (such as behind a firewall or internal to a secured service). Most general-purpose user agents do not send the Referer header field when the referring resource is a local "file" or "data" URI. A user agent MUST NOT send a Referer header field in an unsecured HTTP request if the referring page was received with a secure protocol. See Section 16.9 for additional security considerations.
</p>

<p>
一部の`中継者$は，［
外向けの要請から `Referer^h ~headerを無差別に除去する
］ことが、既知である。
これは、 CSRF 攻撃に対する保護に干渉するような，~~望ましくない副作用を及ぼす
— それは、利用者にとり，はるかに有害になる。
`Referer^h 内への情報~開示を制限したいと望む［
`中継者$／`~UA$拡張
］は、それらの変更を［
内部~domain名を `pseudonym$p に置換したり，
`query$p や`path$p 成分を切落す
］などの，特定の編集-に制約する~OUGHT。
`中継者$は、［
~field値が，`~target~URI$と同じ `scheme$p ＆ `host$p を共有する
］ときは， `Referer^h ~headerを改変したり削除するベキでない。
◎
Some intermediaries have been known to indiscriminately remove Referer header fields from outgoing requests. This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users. Intermediaries and user agent extensions that wish to limit information disclosure in Referer ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the query and/or path components. An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the target URI.
</p>

			</section>
			<section id="field.te">
<h4>9.1.4. `TE^h</h4>

<p>
要請~内に［
"`trailers@c"
~memberを包含する `TE^h ~header
］を利用すれば、`送信者$は`~trailer$を破棄しないことを指示できる。
【！ `5.6$sec → 5.6.2 `trailers$c】
◎
The "TE" header field in a request can be used to indicate that the sender will not discard trailer fields when it contains a "trailers" member, as described in Section 5.6.
</p>

<p>
加えて，特定の~HTTP~versionでは、
`TE^h は，［
`~client$が応答にて受容する用意がある`転送~符号法$
］を指示するためにも利用できる。
◎
Additionally, specific HTTP versions can use it to indicate the transfer codings the client is willing to accept in the response.
</p>

<p>
`TE$h の`~field値$は，~tokenの~listであり、それを成す各~tokenは，省略可能な`~parameter$【 `transfer-parameter$p 】たちを許容する。
◎
The TE field-value consists of a list of tokens, each allowing for optional parameters (as described in Section 5.7.6).
</p>

<pre class="bnf">
`TE@p
    = #`t-codings$p
`t-codings@p
    = "`trailers$c"
    / ( `transfer-coding$p [ `t-ranking$p ] )
`t-ranking@p
    = `OWS$p ";" `OWS$p "q=" `rank$p
`rank@p
    = ( "0" [ "." 0*3`DIGIT$P ] )
    / ( "1" [ "." 0*3("0") ] )
</pre>

			</section>
			<section id="field.trailer">
<h4>9.1.5. `Trailer^h</h4>

<p>
`Trailer^h ~headerは、送信者が［
同じ~messageの中に`~trailer$として送信するもの
］と見越している，`~field名$の~listを供する。
これは、［
本体の処理を開始する前に，指示された~metadataの受領に対し準備する
］ことを，受信者に許容する。
◎
The "Trailer" header field provides a list of field names that the sender anticipates sending as trailer fields within that message. This allows a recipient to prepare for receipt of the indicated metadata before it starts processing the body.
</p>

<pre class="bnf">
`Trailer@p
    = #`field-name$p
</pre>

<p>
例えば，送信者は、［
`~payload$が~stream化されるに伴い，~message完全性の検査情報が算出され、最終-署名を`~trailer$として供することになる
］ことを指示するかもしれない。
受信者は、~payload~dataを受信するに伴い，その場で同じ検査を遂行できるようになる。
◎
For example, a sender might indicate that a message integrity check will be computed as the payload is being streamed and provide the final signature as a trailer field. This allows a recipient to perform the same check on the fly as the payload data is received.
</p>

<p>
~message内に`~trailer$を`生成し$ようと意図する送信者は、その~messageの`~header節$内に `Trailer$h ~headerを`生成し$て，そのような`~field$が`~trailer節$内に在るかもしれないことを指示するベキである。
◎
A sender that intends to generate one or more trailer fields in a message SHOULD generate a Trailer header field in the header section of that message to indicate which fields might be present in the trailers.
</p>

			</section>
			<section id="field.user-agent">
<h4>9.1.6. `User-Agent^h</h4>

<div class="p">
<p>
`User-Agent^h ~headerは、［
要請を出生した`~UA$
］についての情報を包含する
— `~server$は、次のために，これを利用することが多い：
◎
The "User-Agent" header field contains information about the user agent originating the request, which is often used by servers＼
</p>
<ul>
	<li>
報告された相互運用能の問題を絞り込むための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~UA制限を避けるために，［
対処する／応答を誂える
］。
◎
to work around or tailor responses to avoid particular user agent limitations, and＼
</li>
	<li>
利用されている~browserや OS に関する解析。
◎
for analytics regarding browser or operating system use.＼
</li>
</ul>

<p>
`~UA$は、特定的に環境設定されていない限り，各~要請~内に `User-Agent^h ~fieldを送信するベキである。
◎
A user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so.
</p>
</div>

<pre class="bnf">
`User-Agent@p
    = `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`User-Agent^h `~field値$は、
1 個~以上の
`製品~識別子@
（ `product$p ）からなり，各~製品~識別子には 0 個以上の~comment（
`comment$p
）が後続する。
それらは組で，［
~UA~software, および その有意な下位製品
］を識別する。
慣行により，製品~識別子は、~UA~softwareを識別するために［
それらの有意度の降順
］で~listされる。
各 `製品~識別子$は、［
名前, 省略可能な~version（ `product-version$p ）
］からなる。
◎
The User-Agent field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.7.5), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.
</p>

<pre class="bnf">
`product@p
    = `token$p ["/" `product-version$p]
`product-version@p
    = `token$p
</pre>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
`生成する$`製品~識別子$を［
製品を識別するために必要とされるもの
］に制限するベキである。
◎
A sender SHOULD limit generated product identifiers to what is necessary to identify the product;＼
</li>
	<li>
`製品~識別子$の中に［
広告-用その他の本質的でない情報
］を`生成し$てはナラナイ。
◎
a sender MUST NOT generate advertising or other nonessential information within the product identifier.＼
</li>
	<li>
`product-version$p 内に，~version識別子でない情報を`生成する$ベキでない（すなわち，［
同じ製品~名の 一連の~version
］は、［
製品~識別子の `product-version$p 部位
］においてのみ相違する~OUGHT）。
◎
A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</pre>
</div>

<div class="p">
<p>
`~UA$は：
◎
A user agent＼
</p>
<ul>
	<li>
不必要に木目細かな詳細を包含する `User-Agent^h ~fieldを，`生成する$ベキでない。
◎
SHOULD NOT generate a User-Agent field containing needlessly fine-grained detail and＼
</li>
	<li>
第三者主体による下位製品の追加を，制限するベキである。
◎
SHOULD limit the addition of subproducts by third parties.＼
</li>
</ul>

<p>
不必要に長く詳細な `User-Agent^h `~field値$は、要請の待時間を増やし，利用者の望みに反して, 識別される~risk（ “`指紋収集$” ）を高める。
◎
Overly long and detailed User-Agent field values increase request latency and the risk of a user being identified against their wishes ("fingerprinting").
</p>
</div>

<p>
同様に，実装には、［
他の実装の製品~tokenを，互換性を宣言するために利用する
］ことは奨励されない
— そうすると，この~fieldの目的を~~無為にするので。
別の~UAとして仮装する~UAに対しては、`受信者$は，［
利用者が意図的に，その別の~UA用に誂えられた応答を見たいと欲している
］ものと見做せる
— その応答が、実際に利用されている~UAで働くかどうかに関わらず。
◎
Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field. If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used.
</p>

			</section>
		</section>
		<section id="response.context">
<h3 title="Response Context">9.2. 応答~文脈</h3>


<p>
`応答~header@
は、［
状態s~codeを補足する ／
~cachingを指令する ／
~clientに次へ行く所を指図する
］ような制御~dataを給せる。
◎
Response header fields can supply control data that supplements the status code, directs caching, or instructs the client where to go next.
</p>

<p>
応答~headerにより、~serverは［
`状態s~code$を超える，応答についての追加的な情報
］を渡せるようになる。
これらの~headerは、［
~server／`~target資源$への更なる~access／関係する資源
］についての情報を与える。
◎
The response header fields allow the server to pass additional information about the response beyond the status code. These header fields give information about the server, about further access to the target resource, or about related resources.
</p>

<p>
各種 応答~headerは，それ自身に定義される意味を持つが、一般に，精確な意味論は［
`要請~method$や`応答~状態s~code$の意味論
］により更に精緻化され得る。
◎
Although each response header field has a defined meaning, in general, the precise semantics might be further refined by the semantics of the request method and/or response status code.
</p>

<p>
残りの応答~headerは、今後の要請にあり得る利用のために，［
`~target資源$についての更なる情報
］を供する
⇒＃
`Allow$h,
`Date$h,
`Location$h,
`Retry-After$h,
`Server$h
◎
The remaining response header fields provide more information about the target resource for potential use in later requests.
◎
Table 9
Field Name 	Ref.

Allow 	9.2.1
Date 	9.2.2
Location 	9.2.3
Retry-After 	9.2.4
Server 	9.2.5
</p>


			<section id="field.allow">
<h4>9.2.1. `Allow^h</h4>

<p>
`Allow^h ~headerは、［
`~target資源$が~supportするものとして広告される，~methodの集合
］を~listする。
この~fieldの目的は、［
資源に結付けられている妥当な`要請~method$
］を，`受信者$に厳密に伝えることである。
◎
The "Allow" header field lists the set of methods advertised as supported by the target resource. The purpose of this field is strictly to inform the recipient of valid request methods associated with the resource.
</p>

<pre class="bnf">
`Allow@p
    = #`method$p
</pre>

<div class="example">
<p>
利用~例：
◎
Example of use:
</p>

<pre class="lang-http">
Allow: GET, HEAD, PUT
</pre>
</div>

<p>
許容される~methodの実際の集合は、各~要請の時点で，`生成元~server$により定義される。
`生成元~server$は、 `405$st 応答~内には， `Allow^h ~fieldを`生成し$なければナラナイ。
また、他のどの応答~内にも`生成し$てもヨイ。
値が空な `Allow^h ~fieldは、［
資源がどの~methodも許容しない
］ことを指示する
— それは、［
資源が環境設定により一時的に不能化されている
］場合に `405$st0 応答~内に生じ得る。
◎
The actual set of allowed methods is defined by the origin server at the time of each request. An origin server MUST generate an Allow field in a 405 (Method Not Allowed) response and MAY do so in any other response. An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration.
</p>

<p>
`~proxy$は、 `Allow^h ~fieldを改変してはナラナイ
— 汎用~message取扱い規則に則って取扱うときは、値の中に指示された すべての~methodを解する必要はない。
◎
A proxy MUST NOT modify the Allow header field — it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.
</p>

			</section>
			<section id="field.date">
<h4>9.2.2. `Date^h</h4>

<p>
`Date^h ~headerは、~messageが
<dfn id="origination-date">出生した日付時刻</dfn>
を表現する
— その意味論は、 `RFC5322/3.6.1$sec に定義される `Origination Date Field^en （ `orig-date^p ）と同じである。
その`~field値$は：
◎
The "Date" header field represents the date and time at which the message was originated, having the same semantics as the Origination Date Field (orig-date) defined in Section 3.6.1 of [RFC5322]. The field value is an HTTP-date, as defined in Section 5.7.7.
</p>

<pre class="bnf">
`Date@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Date: Tue, 15 Nov 1994 08:12:31 GMT
</pre>
</div>

<p>
`送信者$は、 `Date^h ~headerを`生成する$ときは，その~header値として［
~message生成の日付時刻に可用な，最良な近似
］を`生成する$ベキである。
理論~上は、日時は，~payloadが`生成され$る~~直前の瞬間を表現する~OUGHT。
実施~上は、日時は，~message出生時の間の任意の時点に`生成され$得る。
◎
When a Date header field is generated, the sender SHOULD generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before the payload is generated. In practice, the date can be generated at any time during message origination.
</p>

<p>
`時計@
— ~UTCによる~~現在時の適度な近似を供する時計 —
を備えていない`生成元~server$は、
`Date^h ~headerを送信してはナラナイ。
生成元~serverは、`応答~状態s~code$の`応答class$が［
`1xx$st ／ `5xx$st
］である場合， `Date^h ~headerを送信してもヨイ
— 他のすべての事例では， `Date^h ~headerを送信しなければナラナイ。
◎
An origin server MUST NOT send a Date header field if it does not have a clock capable of providing a reasonable approximation of the current instance in Coordinated Universal Time. An origin server MAY send a Date header field if the response is in the 1xx (Informational) or 5xx (Server Error) class of status codes. An origin server MUST send a Date header field in all other cases.
</p>

<p>
`時計$を備えている`受信者$が，［
`Date^h ~headerを伴わない応答~messageを受信した
］ときは、それを［
~cacheする／下流へ回送する
］ときには，受信した時刻を記録して，~messageの`~header節$に［
対応する `Date^h ~header
］付加しなければナラナイ。
◎
A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.
</p>

<p>
`~UA$は、要請~内に `Date^h ~headerを送信してもヨイ
— 一般には，~serverにとって有用な情報を伝達するものと予見される場合に限られるが。
例えば，~HTTPの~customな応用は、［
~serverが、利用者からの要請の解釈を，~UAと~serverにおける時計の相違に基づいて調整する
］ことが予期される場合には， `Date^h を伝達することもあろう。
◎
A user agent MAY send a Date header field in a request, though generally will not do so unless it is believed to convey useful information to the server. For example, custom applications of HTTP might convey a Date if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks.
</p>

			</section>
			<section id="field.location">
<h4>9.2.3. `Location^h</h4>

<p>
`Location^h ~headerは、［
応答に関係する特定の資源を指す
］ために，一部の応答~内にて利用される。
関係性の型は、［
`要請~method$, `状態s~code$
］の意味論の組合nで定義される。
◎
The "Location" header field is used in some responses to refer to a specific resource in relation to the response. The type of relationship is defined by the combination of request method and status code semantics.
</p>

<pre class="bnf">
`Location@p
    = `URI-reference$p
</pre>

<p>
`~field値$は、単独の `URI-reference$p からなる。
値が相対~参照（ `RFC3986/4.2$sec ）の形をとる場合、最終-値は，`~target~URI$に~~相対的に解決することで算出される（ `RFC3986/5$sec ）。
◎
The field value consists of a single URI-reference. When it has the form of a relative reference ([RFC3986], Section 4.2), the final value is computed by resolving it against the target URI ([RFC3986], Section 5).
</p>

<p>
`Location^h 値は、
`201$st 応答に対しては［
要請により作成された
`首な資源@
］を指す ／
`3xx$st 応答に対しては，［
要請を自動的に~redirectするときに選好される`~target資源$
］を指す。
◎
For 201 (Created) responses, the Location value refers to the primary resource created by the request. For 3xx (Redirection) responses, the Location value refers to the preferred target resource for automatically redirecting the request.
</p>

<p>
`3xx$st 応答~内に供される `Location^h 値に 素片~成分（ `fragment$p ）がない場合、`~UA$は，~redirectionを［
その値は、［
`~target~URI$を`生成する$ときに利用した`~URI参照$
］の素片~成分を継承している
］かのように処理しなければナラナイ（すなわち，~redirectionは、元の参照に素片があるならば，それを継承する）。
◎
If the Location value provided in a 3xx (Redirection) response does not have a fragment component, a user agent MUST process the redirection as if the value inherits the fragment component of the URI reference used to generate the target URI (i.e., the redirection inherits the original reference's fragment, if any).
</p>

<div class="example">
<p>
例えば、［
~URI参照 "`http://www.example.org/~tim^c" に対し`生成され$た `GET$m 要請
］の結果が，次の~headerを包含する `303$st 応答になるならば：
◎
For example, a GET request generated for the URI reference "http://www.example.org/~tim" might result in a 303 (See Other) response containing the header field:
</p>

<pre class="lang-http">
Location: /People.html#tim
</pre>

<p>
これは、~UAが
"`http://www.example.org/People.html#tim^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.org/People.html#tim"
</p>

<p>
同様に、［
~URI参照 "`http://www.example.org/index.html#larry^c" に対し`生成され$た `GET$m 要請
］の結果が，次の~headerを包含する `301$st 応答になるならば：
◎
Likewise, a GET request generated for the URI reference "http://www.example.org/index.html#larry" might result in a 301 (Moved Permanently) response containing the header field:
</p>

<pre class="lang-http">
Location: http://www.example.net/index.html
</pre>

<p>
これは、~UAが，元の素片~識別子を保全して
"`http://www.example.net/index.html#larry^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.net/index.html#larry", preserving the original fragment identifier.
</p>
</div>

<p>
`Location^h 値~内の素片~識別子が，適切でなくなる状況もある：
例えば，［
`201$st 応答~内の `Location^h ~header
］は、［
作成された資源に特有な~URI
］を供するものと仮定されることになる。
◎
There are circumstances in which a fragment identifier in a Location value would not be appropriate. For example, the Location header field in a 201 (Created) response is supposed to provide a URI that is specific to the created resource.
</p>

<p class="note">注記：
一部の`受信者$は、［
`Location^h ~fieldの`~URI参照$が妥当でない
］ときに，その回復を試みる。
この仕様は，そのような処理を義務化したり定義しないが、堅牢性の~~目的で，それを許容する。
`Location^h の`~field値$は、~memberの~listを許容し得ない
— ~list分離子である~commaは、 `URI-reference$p の中でも妥当な~data文字なので。
複数個の `Location$h ~fieldを伴う妥当でない~messageが送信された場合、当の経路~上の ある`受信者$は，それらの`~field行l$を 1 個に`結合-$するかもしれない。
その状況から妥当な `Location^h ~field値を回復するのは、困難であり，各 実装~間で相互運用可能にならない。
◎
Note: Some recipients attempt to recover from Location fields that are not valid URI references. This specification does not mandate or define such processing, but does allow it for the sake of robustness. A Location field value cannot allow a list of members because the comma list separator is a valid data character within a URI-reference. If an invalid message is sent with multiple Location field instances, a recipient along the path might combine the field instances into one value. Recovery of a valid Location field value from that situation is difficult and not interoperable across implementations.
</p>

<p class="note">注記：
`Content-Location$h ~headerは、それが［
同封された`表現$に対応する最も特定な資源
］を指す点で， `Location^h から相違する。
したがって、応答が［
`Location^h, `Content-Location$h
］両~headerを包含することもアリである。
◎
Note: The Content-Location header field (Section 7.8) differs from Location in that the Content-Location refers to the most specific resource corresponding to the enclosed representation. It is therefore possible for a response to contain both the Location and Content-Location header fields.
</p>

			</section>
			<section id="field.retry-after">
<h4>9.2.4. `Retry-After^h</h4>

<p>
~serverは、［
~UAが後継の要請を為す前に，どのくらい長く待機する~OUGHT
］かを指示するために， `Retry-After^h ~headerを送信する。
［
`503$st 応答に伴って送信されてきた `Retry-After^h
］は、［
当の~serviceが~clientに可用でないと予期されるのは、いつまでか
］を指示する。
［
`3xx$st 応答に伴って送信されてきた `Retry-After^h
］は、［
~redirect要請を発行iする前に，~UAに待機するよう依頼する最短な時間
］を指示する。
◎
Servers send the "Retry-After" header field to indicate how long the user agent ought to wait before making a follow-up request. When sent with a 503 (Service Unavailable) response, Retry-After indicates how long the service is expected to be unavailable to the client. When sent with any 3xx (Redirection) response, Retry-After indicates the minimum time that the user agent is asked to wait before issuing the redirected request.
</p>

<p>
この~fieldの値は、
【可用になるであろう日時を与える】 `HTTP-date$p, または
応答を受信してからの遅延~秒数【を与える `delay-seconds$p 】をとる。
◎
The value of this field can be either an HTTP-date or a number of seconds to delay after the response is received.
</p>

<pre class="bnf">
`Retry-After@p
    = `HTTP-date$p
    / `delay-seconds$p
</pre>

<p>
`delay-seconds$p 値は、秒数を表現する負でない~decimal整数である。
◎
A delay-seconds value is a non-negative decimal integer, representing time in seconds.
</p>

<pre class="bnf">
`delay-seconds@p
    = 1*`DIGIT$P
</pre>

<div class="example">
<p>
その利用~例：
◎
Two examples of its use are
</p>

<pre class="lang-http">
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
</pre>

<p>
後者の遅延は 2 分間になる。
◎
In the latter example, the delay is 2 minutes.
</p>
</div>

			</section>
			<section id="field.server">
<h4>9.2.5. `Server^h</h4>

<div class="p">
<p>
`Server^h ~headerは、［
`生成元~server$が，要請を取扱うために利用している~software
］についての情報を包含する
— それは、次のために，~clientに利用されることが多い：
◎
The "Server" header field contains information about the software used by the origin server to handle the request, which is often used by clients＼
</p>
<ul>
	<li>
報告された相互運用能の問題の視野を絞るための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~server制限を避けるために，対処する／要請を仕立上げる
◎
to work around or tailor requests to avoid particular server limitations, and＼
</li>
	<li>
［
~server／~OS
］の利用に関する分析。
◎
for analytics regarding server or operating system use.＼
</li>
</ul>

<p>
`生成元~server$は、自身の応答~内に `Server^h ~fieldを`生成し$てもヨイ。
◎
An origin server MAY generate a Server field in its responses.
</p>
</div>

<pre class="bnf">
`Server@p
    = `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`Server^h `~field値$は、
1 個~以上の［
`製品~識別子$, 後続する 0 個以上の `comment$p
］からなる。
それらは組で，［
生成元~serverの~software, および その有意な下位製品
］を識別する。
慣行により，製品~識別子は、生成元~serverの~softwareを識別するために［
それらの有意度の降順
］で~listされる。
各 `製品~識別子$は、それに定義されるように，名前, および~version（省略可）からなる。
◎
The Server field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.7.5), which together identify the origin server software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the origin server software. Each product identifier consists of a name and optional version, as defined in Section 9.1.6.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Server: CERN/3.0 libwww/2.17
</pre>
</div>

<p>
`生成元~server$は、［
不必要に木目細かな詳細を包含する `Server^h ~field
］を`生成する$ベキでない。
また、［
第三者主体による下位製品の追加
］を制限するベキである。
~~過度に長く詳細な `Server^h `~field値$は、応答の待時間を増やす。
また，内部~実装の詳細を露呈する~~可能性もあるので、攻撃者にとっては，（少しばかり）既知な~securityの穴を見出して悪用し易くなる。
◎
An origin server SHOULD NOT generate a Server field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties. Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.
</p>

			</section>
		</section>
	</section>
	<section id="authentication">
<h2 title="Authentication">10. 認証</h2>

		<section id="auth.scheme">
<h3 title="Authentication Scheme">10.1. 認証~scheme</h3>

<p>
~HTTPは、~access制御と認証~用の一般的な~frameworkを，拡張-可能な［
［~challenge→応答］
`認証~scheme$の集合
］を介して，供する
— それは、`~server$により~client要請を~challengeするために, および
`~client$により認証~情報を供するために利用できる。
それは、認証~schemeを識別するため，文字大小区別な~tokenを利用する：
◎
HTTP provides a general framework for access control and authentication, via an extensible set of challenge-response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information. It uses a case-insensitive token to identify the authentication scheme
</p>

<pre class="bnf">
`auth-scheme@p
    = `token$p
</pre>

<p>
一般的な~frameworkは別として、この文書は，どの認証~schemeも指定しない。
［
新たな／既存の
］認証~schemeは、独立に指定された上で，
`~HTTP認証~scheme~registry$cite
の中に登録される~OUGHT。
例えば，認証~scheme［
"`basic^c" ／ "`digest^c"
］は、［
`RFC7617$r ／ `RFC7616$r
］にて定義される。
◎
Aside from the general framework, this document does not specify any authentication schemes. New and existing authentication schemes are specified independently and ought to be registered within the "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry". For example, the "basic" and "digest" authentication schemes are defined by RFC 7617 and RFC 7616, respectively.
</p>

		</section>
		<section id="auth.params">
<h3 title="Authentication Parameters">10.2. 認証~parameter</h3>

<p>
認証~schemeには、その~schemeを介して認証を達成するために必要とされる追加的な情報として，次のいずれかが後続する
⇒＃
いくつかの`認証~parameter$からなる，~comma区切りの~list／
base64 符号化された情報を保持できる，単独の文字~並び（ `token68$p ）。
◎
The authentication scheme is followed by additional information necessary for achieving authentication via that scheme as either a comma-separated list of parameters or a single sequence of characters capable of holding base64-encoded information.
</p>

<pre class="bnf">
`token68@p
    = 1*( `ALPHA$P / `DIGIT$P / "-" / "." / "_" / "~" / "+" / "/" ) *"="
</pre>

<p>
`token68$p 構文は、予約-済みでない 66 個の~URI文字（ `RFC3986/2.3$sec ）に加えて，空白~以外の少数の文字も許容する
— 次に挙げる符号化法 `RFC4648$r を，~paddingの有無も込みで保持できるようにするための
⇒＃
`base64$,
`base64url$ （~URLや~filenameに用いても安全な~alphabet）,
`base32$,
`base16$ （ 16 進）
◎
The token68 syntax allows the 66 unreserved URI characters ([RFC3986]), plus a few others, so that it can hold a base64, base64url (URL and filename safe alphabet), base32, or base16 (hex) encoding, with or without padding, but excluding whitespace ([RFC4648]).
</p>

<div class="p">
<p>
各
`認証~parameter@
（ `auth-param$p ）は、
"`=^c" で~~区切られた［
名前, 値
］が成す~pairである：
◎
Authentication parameters are name=value pairs, where＼
</p>
<ul>
	<li>
名前は、文字大小無視で照合される `token$p である。
◎
the name token is matched case-insensitively and＼
</li>
	<li>
同じ名前が生じるのは、 `challenge$p ごとに 1 個まででなければナラナイ。
◎
each parameter name MUST only occur once per challenge.
</li>
</ul>
</div>

<pre class="bnf">
`auth-param@p
    = `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )
</pre>

<p>
~parameterの値は、 "`token$p" としても "`quoted-string$p" としても表出できる。
`認証~scheme$に関わらず，汎用な構文解析~componentの利用を許容するため、認証~scheme定義は，`送信者$用にも, `受信者$用にも両~表記法を受容する必要がある。
◎
Parameter values can be expressed either as "token" or as "quoted-string" (Section 5.7). Authentication scheme definitions need to accept both notations, both for senders and recipients, to allow recipients to use generic parsing components regardless of the authentication scheme.
</p>

<p>
後方-互換性を得るため、認証~scheme定義は，送信者~用の形式を この 2 つの変種の片方に制約できる。
これは、［
配備された実装が、他方の形式に遭遇したときは失敗する
］ことが既知であるとき，重要になり得る。
◎
For backwards compatibility, authentication scheme definitions can restrict the format for senders to one of the two variants. This can be important when it is known that deployed implementations will fail when encountering one of the two formats.
</p>

		</section>
		<section id="challenge.and.response">
<h3 title="Challenge and Response">10.3. ~challengeと応答</h3>

<p>
`401$st 応答~messageは、`~UA$への権限付与を~challengeするために，`生成元~server$により利用され、［
要請された資源に適用-可能な， 1 個~以上の `challenge$p
］を包含する， `WWW-Authenticate$h ~headerを含む。
◎
A 401 (Unauthorized) response message is used by an origin server to challenge the authorization of a user agent, including a WWW-Authenticate header field containing at least one challenge applicable to the requested resource.
</p>

<p>
`407$st 応答~messageは、`~client$への権限付与を~challengeするために，`~proxy$により利用され、［
要請された資源~用に~proxyに適用-可能な， 1 個~以上の `challenge$p
］を包含する， `Proxy-Authenticate$h ~headerを含む。
◎
A 407 (Proxy Authentication Required) response message is used by a proxy to challenge the authorization of a client, including a Proxy-Authenticate header field containing at least one challenge applicable to the proxy for the requested resource.
</p>

<pre class="bnf">
`challenge@p
    = `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<p class="note">注記：
多くの`~client$は、［
未知な~schemeを包含するような `challenge$p
］の構文解析-に失敗する。
この問題~用の対処法は、きちんと~supportされている~schemeたち（ "`basic^c" など）を，~~最初の方に挙げることである。
◎
Note: Many clients fail to parse a challenge that contains an unknown scheme. A workaround for this problem is to list well-supported schemes (such as "basic") first.
</p>

<p>
`~UA$は
— 必要とされてはいないが通例的には， `401$st を受信した後に —
［
要請に `Authorization$h ~headerを内包する
］ことにより，［
自身を`生成元~server$から認証してもらう
］ことができる。
◎
A user agent that wishes to authenticate itself with an origin server — usually, but not necessarily, after receiving a 401 (Unauthorized) — can do so by including an Authorization header field with the request.
</p>

<p>
`~client$は
— 必要とされてはいないが通例的には， `407$st を受信した後に —
［
要請に `Proxy-Authorization$h ~headerを内包する
］ことにより，［
自身を`~proxy$から認証してもらう
］ことができる。
◎
A client that wishes to authenticate itself with a proxy — usually, but not necessarily, after receiving a 407 (Proxy Authentication Required) — can do so by including a Proxy-Authorization header field with the request.
</p>

		</section>
		<section id="credentials">
<h3 title="Credentials">10.4. 資格証</h3>

<div class="p">
<p>
`Authorization$h, `Proxy-Authorization$h
両`~field値$とも，要請-中にある`資源$が属する `realm$c 用の［
`~client$の
`資格証@
（ `credentials$p ）
］を包含する
— 応答~内に（場合によっては過去のある時点で）受信された `challenge$p に基づくような。
`~UA$は、それらの値を，次を行うことにより作成する~OUGHT：
◎
Both the Authorization field value and the Proxy-Authorization field value contain the client's credentials for the realm of the resource being requested, based upon a challenge received in a response (possibly at some point in the past). When creating their values, the user agent ought to do so by＼
</p>
<ul>
	<li>
受信した `challenge$p たちのうち，［
自身が解する かつ最も~secureと見なすような， `auth-scheme$p
］を伴うものを選定する。
◎
selecting the challenge with what it considers to be the most secure auth-scheme that it understands,＼
</li>
	<li>
利用者から適宜 `資格証$を得する。
◎
obtaining credentials from the user as appropriate.＼
</li>
</ul>

<p>
`資格証$を~header`~field値$の中に伝送することは、下層~接続の機密性に関する，有意な~securityの考慮点も含意する
— `16.15.1$sec を見よ。
◎
Transmission of credentials within header field values implies significant security considerations regarding the confidentiality of the underlying connection, as described in Section 16.15.1.
</p>
</div>

<pre class="bnf">
`credentials@p
    = `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<div class="p">
<p>
`生成元~server$は、被保護~資源~用の`資格証$が［
省略されている ／
無効である（例： 不良~password） ／
部分的である（例：`認証~scheme$が複数~回の往来を要求する）
］ような要請の受領~時には，次のような `401$st 応答を送信するベキである：
◎
Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that＼
</p>
<ul>
	<li>
`WWW-Authenticate$h ~headerを包含する。
◎
contains a WWW-Authenticate header field＼
</li>
	<li>
この~headerには、 1 個~以上の［
要請された資源に適用-可能な `challenge$p
］を伴わせる（場合によっては 新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the requested resource.
</li>
</ul>
</div>

<div class="p">
<p>
同様に，認証を要求する`~proxy$は、~proxy`資格証$が［
省略されている／無効である／部分的である
］ような要請の受領~時には，次のような `407$st 応答を`生成する$ベキである：
◎
Likewise, upon receipt of a request that omits proxy credentials or contains invalid or partial proxy credentials, a proxy that requires authentication SHOULD generate a 407 (Proxy Authentication Required) response that＼
</p>
<ul>
	<li>
`Proxy-Authenticate$h ~headerを包含する。
◎
contains a Proxy-Authenticate header field＼
</li>
	<li>
この~headerには、 1 個~以上の［
その`~proxy$に適用-可能な `challenge$p
］を伴わせる（場合によっては 新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the proxy.
</li>
</ul>
</div>

<p>
`~server$は、妥当であるが ~accessを~~獲得するには必要十分でない`資格証$を受信したときは，状態s~code `403$st で応答する~OUGHT。
◎
A server that receives valid credentials that are not adequate to gain access ought to respond with the 403 (Forbidden) status code (Section 14.5.4).
</p>

<p>
~HTTPは、この単純な［~challenge→応答］~frameworkによる応用を，~access認証のみに制約しない。
追加的な仕組みも利用できる
— ［
~transport~levelの認証として, あるいは
~messageによる~encapsulationを介して
］, および［
認証~情報を指定する追加的な~headerを伴わせる
］ような。
しかしながら、そのような追加的な仕組みは，この仕様では定義されない。
◎
HTTP does not restrict applications to this simple challenge-response framework for access authentication. Additional mechanisms can be used, such as authentication at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, such additional mechanisms are not defined by this specification.
</p>

<p>
利用者~認証~用の様々な~customな仕組みが、
`RFC6265$r に定義される［
`Set-Cookie$h, `Cookie$h
］~headerを利用して認証に関係する~tokenを渡すことに注意。
◎
Note that various custom mechanisms for user authentication use the Set-Cookie and Cookie header fields, defined in [RFC6265], for passing tokens related to authentication.
</p>

		</section>
		<section id="protection.space">
<h3 title="Protection Space (Realm)">10.5. 保護~空間（ `realm^c ）</h3>

<p>
名前
`realm@c
の`認証~parameter$は、`認証~scheme$における保護の視野
— `保護~空間$ —
を指示する利用が望まれるときのために，予約されている。
◎
The "realm" authentication parameter is reserved for use by authentication schemes that wish to indicate a scope of protection.
</p>

<p>
`保護~空間@
は、~accessされている`~server$の
`正準的~root~URI@
— `~target~URI$の［
`scheme$p, `authority$p
］成分の組 —
と, この `realm$c 値（もし在るなら）との組合nにより定義される。
`realm$c により、`~server$上の被保護~資源たちを，いくつかの`保護~空間$に区分できるようになる
— それぞれが自前の［
`認証~scheme$や, 権限付与~database
］を伴うような。
`realm$c 値は、一般に，`生成元~server$により アテガわれる文字列であり、`認証~scheme$に特有な追加的な意味論を持ち得る。
応答は、［
同じ `auth-scheme$p を伴いつつ, 異なる `realm$c 値を伴う
］ような，複数の `challenge$p を持ち得ることに注意。
◎
A protection space is defined by the canonical root URI (the scheme and authority components of the target URI; see Section 6.1) of the server being accessed, in combination with the realm value if present. These realms allow the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme and/or authorization database. The realm value is a string, generally assigned by the origin server, that can have additional semantics specific to the authentication scheme. Note that a response can have multiple challenges with the same auth-scheme but with different realms.
</p>

<p>
`保護~空間$は、`資格証$を自動的に適用できるような~domainを決定する。
先立つ要請に権限付与されていた場合、`~UA$は、その`保護~空間$に属する他のすべての要請に対し，同じ`資格証$を ある期間までは再利用してもヨイ
— その期間は、［
`認証~scheme$, `認証~parameter$たち, 利用者の選好（環境設定できるような放置 時間制限など）
］のうち いくつかから決定される。
`認証~scheme$により特定的に許容されない限り、単独の`保護~空間$は，その`~server$の視野から外へは拡張できない。
◎
The protection space determines the domain over which credentials can be automatically applied. If a prior request has been authorized, the user agent MAY reuse the same credentials for all other requests within that protection space for a period of time determined by the authentication scheme, parameters, and/or user preferences (such as a configurable inactivity timeout). Unless specifically allowed by the authentication scheme, a single protection space cannot extend outside the scope of its server.
</p>

<p>
歴史的な理由から、`送信者$は， `quoted-string$p 構文のみを`生成し$なければナラナイ。
~~長年にわたり両 表記法を受容してきた既存の`~client$との相互運用能を最大にするため、
`受信者$は， `token$p, `quoted-string$p 両~構文の~supportを要し得る。
◎
For historical reasons, a sender MUST only generate the quoted-string syntax. Recipients might have to support both token and quoted-string syntax for maximum interoperability with existing clients that have been accepting both notations for a long time.
</p>

		</section>
		<section id="auth.user.origin.server">
<h3 title="Authenticating User to Origin Server">10.6. 生成元~serverへの利用者の認証-法</h3>

			<section id="field.www-authenticate">
<h4>10.6.1. `WWW-Authenticate^h</h4>

<p>
`WWW-Authenticate^h ~headerは、`~target資源$に適用-可能な［
`認証~scheme$たち, および
`認証~parameter$たち
］を指示する。
◎
The "WWW-Authenticate" header field indicates the authentication scheme(s) and parameters applicable to the target resource.
</p>

<pre class="bnf">
`WWW-Authenticate@p
    = #`challenge$p
</pre>

<p>
`401$st 応答を`生成する$`~server$は、［
 1 個~以上の `challenge$p を包含する，
`WWW-Authenticate$h ~header
］を送信しなければナラナイ。
~serverは、他の応答~message内にも，
`WWW-Authenticate$h ~headerを`生成し$てもヨイ
— 【後の要請に】 `資格証$（または異なる`資格証$）を給することが，対する応答に影響し得ることを指示するために。
◎
A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge. A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.
</p>

<p>
応答を回送している`~proxy$は、その応答~内のどの
`WWW-Authenticate$h ~fieldも，改変してはナラナイ。
◎
A proxy forwarding a response MUST NOT modify any WWW-Authenticate fields in that response.
</p>

<p>
`~UA$には、`~field値$を構文解析するときに，特別に~careすることを~~勧める
— それは，複数個の `challenge$p を包含するかもしれず、各 `challenge$p も，何個かの`認証~parameter$からなる~comma区切りの~listを包含し得るので。
更には、~header自体も複数~回 生じ得る。
◎
User agents are advised to take special care in parsing the field value, as it might contain more than one challenge, and each challenge can contain a comma-separated list of authentication parameters. Furthermore, the header field itself can occur multiple times.
</p>

<div class="example">
<p>
一例として：
◎
For instance:
</p>

<pre class="lang-http">
WWW-Authenticate: Newauth realm="apps", type=1, title="Login to \"apps\"", Basic realm="simple"
</pre>

<div class="p">
<p>
この~headerは、 2 個の `challenge$p を包含する：
◎
This header field contains two challenges;＼
</p>
<ul>
	<li>
`Newauth^c ~scheme用の `realm$c 値 "`apps^c" を伴い，追加的な~parameter `type^c, `title^c も伴うもの。
◎
one for the "Newauth" scheme with a realm value of "apps", and two additional parameters "type" and "title", and＼
</li>
	<li>
`Basic^c ~scheme用の `realm$c 値 "`simple^c" を伴うもの。
◎
another one for the "Basic" scheme with a realm value of "simple".
</li>
</ul>
</div>
</div>

<p>
しかしながら、一部の~UAは，この形を認識しない。
結果として，
`WWW-Authenticate^h の`~field値$を同じ`~field行l$に複数個の~memberを伴わせて送信するのは、相互運用可能にならないかもしれない。
◎
Some user agents do not recognise this form, however. As a result, sending a WWW-Authenticate field value with more than one member on the same field line might not be interoperable.
</p>

<p class="note">注記：
`challenge$p 文法~生成規則も~list構文を利用する。
したがって、［
~comma, 空白, ~comma
］の並びは、［
先行している `challenge$p に適用するもの
］としても, あるいは［
`challenge$p の~listにおける，空~entry
］にも，見なし得る。
この多義性は、実施においては 当の~headerの`~field値$の意味論には影響しないので，無害である。
◎
Note: The challenge grammar production uses the list syntax as well. Therefore, a sequence of comma, whitespace, and comma can be considered either as applying to the preceding challenge, or to be an empty entry in the list of challenges. In practice, this ambiguity does not affect the semantics of the header field value and thus is harmless.
</p>

			</section>
			<section id="field.authorization">
<h4>10.6.2. `Authorization^h</h4>

<p>
`Authorization^h ~headerにより、`~UA$は，自身を`生成元~server$から認証してもらうことが可能になる
— 必要とされてはいないが通例的には， `401$st 応答を受信した後に。
その値は、［
要請-中にある資源の `realm$c 用の，`~UA$の認証~情報
］を包含する`資格証$からなる。
◎
The "Authorization" header field allows a user agent to authenticate itself with an origin server — usually, but not necessarily, after receiving a 401 (Unauthorized) response. Its value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
</p>

<pre class="bnf">
`Authorization@p
    = `credentials$p
</pre>

<p>
要請が認証され, かつ `realm$c も指定されている場合、同じ`資格証$は，［
この `realm$c に属する 他のすべての要請に対しても，妥当である
］と~~見做されるようになる（`認証~scheme$自体が，他のもの
— ［
`challenge$p 値に則って, あるいは同期された`時計$を利用して
］様々になるような`資格証$など —
を要求しない限りにおいて）。
◎
If a request is authenticated and a realm specified, the same credentials are presumed to be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).
</p>

<p>
要請を回送している`~proxy$は、その要請~内のどの `Authorization^h ~headerも，改変してはナラナイ。
~HTTP~cacheによる `Authorization^h ~headerの取扱い［
の詳細／に課される要件
］については、
`Caching/3.3$sec
を見よ。
◎
A proxy forwarding a request MUST NOT modify any Authorization fields in that request. See Section 3.3 of [Caching] for details of and requirements pertaining to handling of the Authorization field by HTTP caches.
</p>

			</section>
			<section id="field.authentication-info">
<h4>10.6.3. `Authentication-Info^h</h4>

<p>
~HTTP`認証~scheme$では、`~client$の認証用の`資格証$を受容した後に，
`Authentication-Info^h 応答~headerを利用して情報を通信できる。
この情報は~serverからの【認証の】完結~messageを内包し得る（例：~server認証を包含し得る）。
◎
HTTP authentication schemes can use the Authentication-Info response header field to communicate information after the client's authentication credentials have been accepted. This information can include a finalization message from the server (e.g., it can contain the server authentication).
</p>

<p>
その`~field値$は、 `auth-param$p 構文を利用する，一連の［
~parameter（名前, 値が成す~pair）
］からなる~listである。
この仕様は、汎用な形式のみを述べる
— 個々の~parameterは、 `Authentication-Info^h を利用している`認証~scheme$が定義することになる。
一例として、 `Digest^c 認証~schemeは， `RFC7616/3.5$sec にて複数の~parameterを定義する。
◎
The field value is a list of parameters (name/value pairs), using the "auth-param" syntax defined in Section 10.3. This specification only describes the generic format; authentication schemes using Authentication-Info will define the individual parameters. The "Digest" Authentication Scheme, for instance, defines multiple parameters in Section 3.5 of [RFC7616].
</p>

<pre class="bnf">
`Authentication-Info@p
    = #`auth-param$p
</pre>

<p>
`Authentication-Info^h ~headerは、`要請~method$や`状態s~code$から独立に，どの~HTTP応答にも利用できる。
その意味論は、［
対応する要請の `Authorization$h ~headerにより指示される，`認証~scheme$
］により定義される。
◎
The Authentication-Info header field can be used in any HTTP response, independently of request method and status code. Its semantics are defined by the authentication scheme indicated by the Authorization header field (Section 10.6.2) of the corresponding request.
</p>

<p>
応答を回送している`~proxy$には、どの仕方であろうと，`~field値$を改変することは許容されない。
◎
A proxy forwarding a response is not allowed to modify the field value in any way.
</p>

<p>
`Authentication-Info^h は、`認証~scheme$が明示的に許容するときには，`~trailer$として送信され得る（ `5.6$sec ）。
◎
Authentication-Info can be sent as a trailer field (Section 5.6) when the authentication scheme explicitly allows this.
</p>

			</section>
		</section>
		<section id="auth.client.proxy">
<h3 title="Authenticating Client to Proxy">10.7. ~proxyへの~clientの認証-法</h3>

			<section id="field.proxy-authenticate">
<h4>10.7.1. `Proxy-Authenticate^h</h4>

<p>
`Proxy-Authenticate^h ~headerは、
1 個~以上の `challenge$p からなる
— 各 `challenge^p は、この【~~今後の？】要請~用に`~proxy$に適用-可能な［
`認証~scheme$, `認証~parameter$たち
］を指示する。
`~proxy$は、自身が`生成する$各 `407$st 応答~内に，
1 個~以上の `Proxy-Authenticate^h ~headerを送信しなければナラナイ。
◎
The "Proxy-Authenticate" header field consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this request. A proxy MUST send at least one Proxy-Authenticate header field in each 407 (Proxy Authentication Required) response that it generates.
</p>

<pre class="bnf">
`Proxy-Authenticate@p
    = #`challenge$p
</pre>

<p>
`WWW-Authenticate$h とは違って，
`Proxy-Authenticate^h ~headerが適用されるのは、［
応答`連鎖$の`外方$にある次の`~client$
］に限られる
— 当の`~proxy$を選んだ`~client$のみが，認証に必要とされる`資格証$を有するものと見込まれるので。
しかしながら，同じ管轄の中で複数の~proxyが利用されるときは
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
`~UA$により`生成され$た`資格証$が，消費されるまで階層を通過することは、共通的にある。
よって，そのような環境設定の下では、各~proxyは同じ `challenge$p 集合を送信することになり，
`Proxy-Authenticate^h は回送されているかのように出現することになる。
◎
Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authenticate is being forwarded because each proxy will send the same challenge set.
</p>

<p>
`WWW-Authenticate$h ~headerの構文解析に対する考慮点は、この~fieldにも適用されることに注意。
◎
Note that the parsing considerations for WWW-Authenticate apply to this header field as well; see Section 10.6.1 for details.
</p>

			</section>
			<section id="field.proxy-authorization">
<h4>10.7.2. `Proxy-Authorization^h</h4>

<div class="p">
<p>
`Proxy-Authorization^h ~headerは：
</p>
<ul>
	<li>
次を`~client$に許容する
⇒
認証を要求している`~proxy$に対し，自身を（または その利用者を）識別してもらう
</li>
	<li>
その値は、次を包含する`資格証$からなる
⇒
［
当の~proxy／要請-中にある資源の `realm$c
］用の，`~client$の認証~情報
</li>
</ul>
◎
The "Proxy-Authorization" header field allows the client to identify itself (or its user) to a proxy that requires authentication.＼
Its value consists of credentials containing the authentication information of the client for the proxy and/or realm of the resource being requested.
</div>

<pre class="bnf">
`Proxy-Authorization@p
    = `credentials$p
</pre>

<p>
`Authorization$h と違って，
`Proxy-Authorization^h ~headerが適用されるのは、［
`Proxy-Authenticate$h ~headerを利用して認証を請求した，`内方$にある次の`~proxy$
］に限られる。
`連鎖$にて複数の~proxyが利用されているときは、
`Proxy-Authorization^h ~headerは，［
`資格証$の受信を期待していた~proxyのうち，`内方$にある最初のもの
］により消費される。
複数の~proxyが，所与の要請を協力的に認証する仕組みを成している場合、それらに属する~proxyは，~client要請からの`資格証$を 次の~proxyへ中継してもヨイ。
◎
Unlike Authorization, the Proxy-Authorization header field applies only to the next inbound proxy that demanded authentication using the Proxy-Authenticate field. When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first inbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.
</p>

			</section>
			<section id="field.proxy-authentication-info">
<h4>10.7.3. `Proxy-Authentication-Info^h</h4>

<p>
`Proxy-Authentication-Info^h 応答~headerは、次を除き， `Authentication-Info$h に等価である
⇒
この~headerは，~proxy認証（ `10.3$sec ）に適用され、その意味論は，［
対応する要請の `Proxy-Authorization$h ~headerに指示される`認証~scheme$
］により定義される。
◎
The Proxy-Authentication-Info response header field is equivalent to Authentication-Info, except that it applies to proxy authentication (Section 10.3) and its semantics are defined by the authentication scheme indicated by the Proxy-Authorization header field (Section 10.7.2) of the corresponding request:
</p>

<pre class="bnf">
`Proxy-Authentication-Info@p
    = #`auth-param$p
</pre>

<p>
しかしながら， `Authentication-Info$h と違って、
`Proxy-Authentication-Info^h ~headerが適用されるのは，応答`連鎖$において`外方$にある次の`~client$に限られる
— 当の`~proxy$を選んだ`~client$のみが，認証に必要とされる`資格証$を有するものと見込まれるので。
しかしながら，同じ管轄の中で複数の~proxyが利用されるときは
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
`~UA$により`生成され$た`資格証$が，消費されるまで階層を通過することは、共通的にある。
よって，そのような環境設定の下では、各~proxyが同じ`~field値$を送信することになり，
`Proxy-Authentication-Info^h は回送されているかのように出現することになる。
◎
However, unlike Authentication-Info, the Proxy-Authentication-Info header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authentication-Info is being forwarded because each proxy will send the same field value.
</p>

			</section>
		</section>
	</section>
	<section id="content.negotiation">
<h2 title="Content Negotiation">11. 内容~折衝</h2>

<p>
`生成元~server$は、応答にて伝達する~payload情報を表現するときに
— その情報が成功, ~errorどちらを指示するにしても —
いくつか異なる仕方を備えていることが多い
— 例えば，異なる［
形式／言語／符号化法
］で。
また，［
能力／特性／選好
］は［
利用者や~UA
］ごとに異なり得るので、［
可用な`表現$のうち，どれを送達するのが最良になるか
］も変わり得る。
この理由から、~HTTPは，`内容~折衝$用の仕組みをいくつか供する。
◎
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
</p>

<div class="p">
<p>
この仕様は、~protocolの中で可視にされ得る
`内容~折衝@
として，次の 3 種の~patternを定義する：
◎
This specification defines three patterns of content negotiation that can be made visible within the protocol:＼
</p>
<ul>
	<li>
`~proactive折衝$
⇒
`~server$が、`~UA$が言明した選好に基づいて，`表現$を選定する。
◎
"proactive" negotiation, where the server selects the representation based upon the user agent's stated preferences,＼
</li>
	<li>
`~reactive折衝$
⇒
`~server$が、`~UA$向けに選んでもらう`表現$の~listを供する。
◎
"reactive" negotiation, where the server provides a list of representations for the user agent to choose from, and＼
</li>
	<li>
`要請~payload折衝$
⇒
`~UA$が、`~server$が過去の応答~内で言明した選好に基づいて，未来の要請~用の表現を選定する。
◎
"request payload" negotiation, where the user agent selects the representation for a future request based upon the server's stated preferences in past responses.＼
</li>
</ul>

<p>
他の~patternによる`内容~折衝$には、次のものが含まれる：
◎
Other patterns of content negotiation include＼
</p>
<ul>
	<li>
条件付き内容
⇒
`表現$は複数個の部分からなっていて、各部分は、~UAの各種~parameterに基づいて，選択的に具現化される。
◎
"conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters,＼
</li>
	<li>
作動中の内容
⇒
`表現$は~scriptを包含していて、それが、~UAの特性に基づいて，追加的な（より特定な）要請を為す。
◎
"active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and＼
</li>
	<li>
透過的な内容~折衝（ `Transparent Content Negotiation^en `RFC2295$r ）
⇒
`中継者$が、内容の選定を遂行する。
◎
"Transparent Content Negotiation" ([RFC2295]), where content selection is performed by an intermediary.＼
</li>
</ul>

<p>
これらの~patternは、排他的ではない
— それぞれ、適用能と実用性の引換関係にある。
◎
These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
</p>
</div>

<p>
すべての事例において、~HTTPは，`資源$の意味論を自覚しないことに注意。
［
要請に対し応答する生成元~serverの［
時経過, および`内容~折衝$の様々な次元
］にわたる一貫性、したがって［
時経過にわたり資源に観測される，`表現$の “同じさ度合い”
］は、全面的に，［
それらの応答を選定したり, 生成する，実体／~algo
］により決定される。
◎
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses.
</p>

		<section id="proactive.negotiation">
<h3 title="Proactive Negotiation">11.1. ~proactive折衝</h3>

<div class="p">
<p>
`~UA$により，要請~内に［
`~server$に所在する~algoに，選好される`表現$を選定するよう促す選好
］が送信されるような`内容~折衝$は、
`~proactive折衝@
と呼ばれる（ “~server駆動な折衝” とも呼ばれる）。
この選定は、次の 2 つの比較対照に基づく：
◎
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on＼
</p>
<ul>
	<li>
応答に可用な`表現$（選好の次元は、言語, `内容~符号法$, 等々，多様になり得る）。
◎
the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to＼
</li>
	<li>
要請~内に給される様々な情報。
これには、以下に与える明示的な折衝~fieldや，暗黙的な特性
— ~clientの~network~address, `User-Agent$h ~fieldの各部など —
も含まれる。
◎
various information supplied in the request, including both the explicit negotiation fields below and implicit characteristics, such as the client's network address or parts of the User-Agent field.
</li>
</ul>
</div>

<div class="p">
<p>
~proactive折衝は、次のときに有利になる：
◎
Proactive negotiation is advantageous when＼
</p>
<ul>
	<li>
［
可用な`表現$の中から一つを選定するための~algo
］を，~UAに向けて述べるのが困難であるとき。
◎
the algorithm for selecting from among the available representations is difficult to describe to a user agent, or＼
</li>
	<li>
`~server$が，最初の応答に［
~UAにとって “最良と推測される” もの
］を送信することを欲するとき（利用者にとり，その推測で十分良いときに、後続の要請の往来による遅延を避けることを期待して）。
◎
when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user).＼
</li>
</ul>

<p>
`~UA$は、`~server$による推測を改善させるために，［
自身の選好を述べる`要請~header$
］を送信してもヨイ。
◎
In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.
</p>
</div>

<p>
~proactive折衝には、深刻な不利がある：
◎
Proactive negotiation has serious disadvantages:
</p>
<ul>
	<li>
`~server$にとっては、［
任意の利用者にとって，何が “最良” になるか
］を正確aに決定することは，不可能である
— そのためには、［
~UAに備わる能力,
応答に対し意図される利用（例： 利用者が求めているのは、~screen上で視る, 紙に印刷する のどっちか？）
］の両者について，完全な知識を要求することになるので。
◎
It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
</li>
	<li>
~UAが 毎~要請ごとに，自身に備わる能力を述べるとするなら、とても非効率になり得る（ごく小さな割合の応答のみが複数個の`表現$を持つ下では）。
更に、利用者の~privacyに対する~riskも高める。
◎
Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
</li>
	<li>
［
`生成元~server$,
要請に対する応答を生成する~algo
］の実装が複雑化する。
◎
It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
</li>
	<li>
共用~cachingにおける応答の再利用-能が，制限される。
◎
It limits the reusability of responses for shared caching.
</li>
</ul>

<p>
`~UA$は、［
~proactive折衝による選好が一貫して尊守される
］ことに依拠できない
— `生成元~server$は、要請された`資源$用には ~proactive折衝を実装していなかったり，［
~UAの選好に適合しない応答を送信する方が， `406$st 応答を送信するより良い
］と裁定することもあるので。
◎
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a 406 (Not Acceptable) response.
</p>

<p>
`Vary$h ~headerは、［
要請のどの部分の情報が，選定~algoに利用されるか
］を指示するために，［
~proactive折衝を~subjectとする応答
］内に送信されることが多い。
◎
A Vary header field (Section 11.2.1) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
</p>
<div class="p">
<p>
次に挙げる`要請~header$は、［
応答~内容の`~proactive折衝$
］に携わるために，`~UA$により送信され得る
⇒＃
`Accept$h,
`Accept-Charset$h,
`Accept-Encoding$h,
`Accept-Language$h
</p>

<p>
これらの~field内に送信される選好は、次に挙げるものを含め，応答~内のどの内容にも適用される
⇒＃
`~target資源$の`表現$,
~errorや処理~状態sの`表現$,
~protocolの中に出現し得る 他の~text文字列
</p>

◎
The following request header fields can be sent by a user agent to engage in proactive negotiation of the response content, as defined in Section 11.1. The preferences sent in these fields apply to any content in the response, including representations of the target resource, representations of error or processing status, and potentially even the miscellaneous text strings that might appear within the protocol.
◎
Table 10
Field Name 	Ref.

Accept 	11.1.2
Accept-Charset 	11.1.3
Accept-Encoding 	11.1.4
Accept-Language 	11.1.5
</div>

			<section id="conneg.shared">
<h4 title="Shared Negotiation Features">11.1.1. 共用の折衝~特能</h4>

				<section id="conneg.absent">
<h5 title="Absence">11.1.1.1. 不在</h5>

<p>
これらの~headerそれぞれに対し、それを包含しない要請は，［
当の~headerが表す折衝の軸に関しては、~UAの選好は無い
］ことを含意する。
要請~内に当の~headerは在って，［
応答~用に可用な表現のうち，その~headerに則って受容-可能と見なせるものは無い
］場合、`生成元~server$は，［
`406$st 応答を送信して，その~headerを尊守する
］ことも［
応答を`内容~折衝$の~subjectではないかのように扱って，その~headerは無視rする
］こともできる。
しかしながら，これ【包含しないこと】は、［
~clientは、その表現を利用-可能になる
］ことを含意するものではない。
◎
For each of these header fields, a request that does not contain the field implies that the user agent has no preference on that axis of negotiation. If the header field is present in a request and none of the available representations for the response can be considered acceptable according to it, the origin server can either honor the header field by sending a 406 (Not Acceptable) response or disregard the header field by treating the response as if it is not subject to content negotiation for that request header field. This does not imply, however, that the client will be able to use the representation.
</p>

<p class="note">注記：
これらの~headerの送信は、~serverにとっては，［
~UAからの要請の特性から個々人を識別する
］ことをより容易にする（ `16.12$sec ）。
◎
Note: Sending these header fields makes it easier for a server to identify an individual by virtue of the user agent's request characteristics (Section 16.12).
</p>

				</section>
				<section id="quality.values">
<h5 title="Quality Values">11.1.1.2. 品質~値</h5>

<p>
この仕様が定義する内容~折衝~用の`~field$は、［
相対的な選好の “重み” を，結付けられる内容の種類にアテガう
］ために，［
`q$c と命名される（文字大小無視な）共通な~parameter
］を利用する。
この重みは、同じ~parameter名が，~server環境設定の中で［
資源~用に選定され得る様々な`表現$の，相対的な品質の重み
］をアテガうために 利用されることが多いため、
`品質~値@
（ あるいは “`qvalue^en” ）と呼ばれる。
◎
The content negotiation fields defined by this specification use a common parameter, named "q" (case-insensitive), to assign a relative "weight" to the preference for that associated kind of content. This weight is referred to as a "quality value" (or "qvalue") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource.
</p>

<p>
重みは、範囲 0 〜 1 の実数に正規化される
— ここで，［
値 0.001 は最も選好されず，
値 1 は最も選好され，
値 0 は “受容-可能でない”
］ことを意味する。
`q$c ~parameterが無い場合の
`既定の重み@
は 1 とする。
◎
The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means "not acceptable". If no "q" parameter is present, the default weight is 1.
</p>

<pre class="bnf">
`weight@p
    = `OWS$p ";" `OWS$p "`q@c=" `qvalue$p
`qvalue@p
    = ( "0" [ "." 0*3DIGIT ] )
    / ( "1" [ "." 0*3("0") ] )
</pre>

<p>
`送信者$が，小数点の後に`生成する$品質値の桁~数は、 3 以下でなければナラナイ。
これらの値による利用者~環境設定も，同じやり方で制限される~OUGHT。
◎
A sender of qvalue MUST NOT generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.
</p>

				</section>
				<section id="wildcard.values">
<h5 title="Wildcard Values">11.1.1.3. ~wildcard値</h5>

<p>
ほとんどの~headerは、指示される所では，［
指定されていない値を選定するための，~wildcard値（ "`*^c" ）
］を定義する。
~wildcardは無い場合、その~field内に明示的に挙げられなかった どの値も，~clientには “受容-可能でない” ものと見なされる。
◎
Most of these header fields, where indicated, define a wildcard value ("*") to select unspecified values. If no wildcard is present, all values not explicitly mentioned in the field are considered "not acceptable" to the client.
</p>

<p class="note">注記：
実施においては、内容~折衝に利用される~wildcardの実用的な価値は，制限される
— 例えば、
“多少を問わず，何か（何らかの特定の値）より `image/*^c を選好します”
と言っても，有用になることは滅多にないので。
~clientは、
`Accept: */*;q=0^c
を送信することにより，［
より選好される形式は可用でない場合には、 `406$st0 応答を送信する
］よう明示的に要請できるが、他の応答も依然として取扱える必要がある
— ~serverには、~clientの選好を無視することも許容されるので。
◎
Note: In practice, using wildcards in content negotiation has limited practical value, because it is seldom useful to say, for example, "I prefer image/* more or less than (some other specific value)". Clients can explicitly request a 406 (Not Acceptable) response if a more preferred format is not available by sending Accept: */*;q=0, but they still need to be able to handle a different response, since the server is allowed to ignore their preference.
</p>

				</section>
			</section>
			<section id="field.accept">
<h4>11.1.2. `Accept^h</h4>

<p>
`~UA$は、 `Accept^h ~headerを利用して，応答の`~MIME型$に関する自身の選好を指定できる。
例えば、要請が［
自身が欲する型からなる小さな集合に，特定的に制限される
］ことを指示するときに利用できる
— ~inline画像に対する要請など。
◎
The "Accept" header field can be used by user agents to specify their preferences regarding response media types. For example, Accept header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
</p>

<p>
~serverにより送信された応答~内の `Accept^h は、［
同じ`資源$に対する後続の要請
］の~payloadには［
どの内容~型が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept provides information about what content types are preferred in the payload of a subsequent request to the same resource.
</p>

<pre class="bnf">
`Accept@p
    = #( `media-range$p [ `accept-params$p ] )

`media-range@p
    = ( "*/*"
        / ( `type$p "/" "*" )
        / ( `type$p "/" `subtype$p )
      ) `parameters$p
`accept-params@p
    = `weight$p *( `accept-ext$p )
`accept-ext@p
    = `OWS$p ";" `OWS$p `token$p [ "=" ( `token$p / `quoted-string$p ) ]
</pre>

<p>
`media-range$p における文字~asterisk "`*^c" は、`~MIME型$をある範囲に~group化するために利用される
⇒＃
"`*/*^c" は，すべての~MIME型を指示する／
"`type^V`/*^c" は， `type^V ~MIME型を成すすべての下位型を指示する。
◎
The asterisk "*" character is used to group media types into ranges, with "*/*" indicating all media types and "type/*" indicating all subtypes of that type.＼
</p>

<p>
`media-range$p には、その範囲の~MIME型に適用-可能な`~MIME型~parameter$も内包できる。
◎
The media-range can include media type parameters that are applicable to that range.
</p>

<div class="p">
<p>
各 `media-range$p には、順に，次のものが後続し得る：
◎
Each media-range might be followed by＼
</p>
<ol>
	<li>
0 個以上の，
適用-可能な`~MIME型~parameter$（ `parameter$p ）（例： "`charset^c" ）
◎
zero or more applicable media type parameters (e.g., charset),＼
</li>
	<li>
0 〜 1 個の，（ `weight$p を成す） `q$c ~parameter
— 相対的な重み（`品質~値$）を指示する
◎
an optional "q" parameter for indicating a relative weight (Section 11.1.1.2), and then＼
</li>
	<li>
0 個以上の，拡張~parameter（ `accept-ext$p ）
◎
zero or more extension parameters.＼
</li>
</ol>

<p>
`q$c ~parameterは，その前後の~parameter集合の分離子として~~働くので、拡張（ `accept-ext$p ）が在るならば，必要とされる。
◎
The "q" parameter is necessary if any extensions (accept-ext) are present, since it acts as a separator between the two parameter sets.
</p>
</div>

<p class="note">注記：
［
`Accept^h の拡張~parameter（ `accept-params$p ）から`~MIME型~parameter$を分離する，~parameter名 "`q^c"
］の利用は、歴史的な実施に因る。
これにより， `media-range$p においては［
"`q^c" と命名される`~MIME型~parameter$
］は利用できなくなるが、［
~IANA~MIME型~registryには， `q$c ~parameterはまだ無いこと
］および［
`Accept^h における`~MIME型~parameter$の利用eは稀である
］下では、そのような出来事は，まずないと予見されている。
将来の~MIME型においては、"`q^c" と命名されるどのような~parameterも登録しないことが奨励される。
◎
Note: Use of the "q" parameter name to separate media type parameters from Accept extension parameters is due to historical practice. Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters in Accept. Future media types are discouraged from registering any parameter named "q".
</p>

<div class="example">
<p>
例：
◎
The example
</p>

<pre class="lang-http">
Accept: audio/*; q=0.2, audio/basic
</pre>

<p>
これは、次の様に解釈される
⇒
“ `audio/basic^c を選好しますが、無いなら［
品質を `80%^ ~~落とした上で，最良に可用な `audio^c 型
］があれば，それを送信してください。”
◎
is interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% markdown in quality".
</p>
</div>

<div class="example">
<p>
より込み入った例：
◎
A more elaborate example is
</p>

<pre class="lang-http">
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
</pre>

<p>
これは、くだけて言えば，次の様に解釈されるであろう
⇒
“`~MIME型$ `text/html^c と `text/x-c^c を等しく選好しますが、無ければ `text/x-dvi^c による表現を, それも無ければ `text/plain^c による表現を送信してください”
◎
Verbally, this would be interpreted as "text/html and text/x-c are the equally preferred media types, but if they do not exist, then send the text/x-dvi representation, and if that does not exist, send the text/plain representation".
</p>
</div>

<p>
`media-range$p は、より特定な［
`media-range$p ／ `~MIME型$
］で上書きできる。
所与の型に，複数の `media-range$p が適用されている場合、最も特定な参照が優先される。
◎
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*, text/plain, text/plain;format=flowed, */*
</pre>

<p>
の優先順は、次になる：
◎
have the following precedence:
</p>
<ol ><li>`text/plain;format=flowed^c
</li><li>`text/plain^c
</li><li>`text/*^c
</li><li>`*/*^c
</li></ol>
</div>

<p>
所与の型に結付けられる`~MIME型$の 品質~係数は、［
型に合致する，最も優先される `media-range$p
］を見出すことにより決定される。
◎
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence that matches the type.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
        text/plain;format=fixed;q=0.4, */*;q=0.5
</pre>

<p>
に対しては、次に挙げる値が結付けられる：
◎
would cause the following values to be associated:
</p>

<div>
<table><thead><tr><td>~MIME型
<td>`品質~値$
</thead>

<tbody><tr><td>`text/plain;format=flowed^c
<td>`1^c

<tr><td>`text/plain^c
<td>`0.7^c

<tr><td>`text/html^c
<td>`0.3^c

<tr><td>`image/jpeg^c
<td>`0.5^c

<tr><td>`text/plain;format=fixed^c
<td>`0.4^c

<tr><td>`text/html;level=3^c
<td>`0.7^c

</tbody></table>
◎
Table 11
Media Type 	Quality Value

text/plain;format=flowed 	1
text/plain 	0.7
text/html 	0.3
image/jpeg 	0.5
text/plain;format=fixed 	0.4
text/html;level=3 	0.7
</div>
</div>

<p class="note">注記：
~UAは、一定 範囲の~media用に，`品質~値$の既定の集合を供し得る。
しかしながら，~UAが［
他の具現化~agentとヤリトリし得ない閉な~system
］でない限り、この既定の集合は，利用者により環境設定できる~OUGHT。
◎
Note: A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user.
</p>
			</section>
			<section id="field.accept-charset">
<h4>11.1.3. `Accept-Charset^h</h4>

<p>
`~UA$は、 `Accept-Charset^h ~headerを送信して，［
~textな応答~内容~内の`~charset$に対する自身の選好
］を指示できる。
例えば~UAは、より［
包括的な／特殊用途の
］~charsetを解する能力を備えるならば、この~headerにより，その能力を［
それらの~charsetで情報を表現する能力を備えている生成元~server
］へ通達できるようになる。
◎
The "Accept-Charset" header field can be sent by a user agent to indicate its preferences for charsets in textual response content. For example, this field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
</p>

<pre class="bnf">
`Accept-Charset@p
    = #( ( `charset$p / "*" ) [ `weight$p ] )
</pre>
<p>
各~charset名は、`7.4.2$sec にて定義される。
`~UA$は、各~charsetに［
利用者の相対的~選好を指示する`品質~値$
］を結付けてもヨイ。
◎
Charset names are defined in Section 7.4.2. A user agent MAY associate a quality value with each charset to indicate the user's relative preference for that charset, as defined in Section 11.1.1.2.＼
</p>

<div class="example">
<p>
例えば：
◎
An example is
</p>

<pre class="lang-http">
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre>
</div>

<p>
`Accept-Charset^h ~fieldにおける特別な値 "`*^c" は、在るならば，その~field内に挙げられていない どの`~charset$にも合致する。
◎
The special value "*", if present in the Accept-Charset field, matches every charset that is not mentioned elsewhere in the Accept-Charset field.
</p>

<p class="note">注記：
`Accept-Charset^h は、非推奨にされた。
~UTF-8がほぼアタリマエになったのと、利用者が選好する~charsetの詳細な~listの送信は，［
帯域幅を浪費し,
待時間を増やし,
受動的な指紋収集をずっと容易にする（ `16.12$sec ）
］ので。
ほとんどの一般用~UAは、 `Accept-Charset^h を送信しない
— そうするよう特定的に環境設定されない限り。
◎
Note: Accept-Charset is deprecated because UTF-8 has become nearly ubiquitous and sending a detailed list of user-preferred charsets wastes bandwidth, increases latency, and makes passive fingerprinting far too easy (Section 16.12). Most general-purpose user agents do not send Accept-Charset, unless specifically configured to do so.
</p>

			</section>
			<section id="field.accept-encoding">
<h4>11.1.4. `Accept-Encoding^h</h4>

<p>
`Accept-Encoding^h ~headerは、`内容~符号法$に関する選好を指示するために利用できる。
◎
The "Accept-Encoding" header field can be used to indicate preferences regarding the use of content codings (Section 7.5.1).
</p>

<p>
~UAにより送信された要請~内の `Accept-Encoding^h は、対する応答~内に`内容~符号法$を受容-可能であることを指示する。
◎
When sent by a user agent in a request, Accept-Encoding indicates the content codings acceptable in a response.
</p>

<p>
~serverにより送信された応答~内の `Accept-Encoding^h は、［
同じ`資源$に対する後続の要請
］の~payloadには［
どの`内容~符号法$が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept-Encoding provides information about what content codings are preferred in the payload of a subsequent request to the same resource.
</p>

<p>
"`identity@c"
~tokenは、選好する符号化は無いことを通信するための，
“符号化しない” の同義語として利用される。
◎
An "identity" token is used as a synonym for "no encoding" in order to communicate when no encoding is preferred.
</p>

<pre class="bnf">
`Accept-Encoding@p
    = #( `codings$p [ `weight$p ] )
`codings@p
    = `content-coding$p / "`identity$c" / "*"
</pre>

<p>
各 符号法~値（ `codings$p ）には、［
その符号化法に結付けられる選好~度を表現する，`品質~値$
］も与えられてもヨイ。
`Accept-Encoding^h ~header内の記号~asterisk "`*^c"
は、可用な`内容~符号法$のうち［
その~header内に明示的に~listされていないもの
］すべてに合致する。†a
◎
Each codings value MAY be given an associated quality value representing the preference for that encoding, as defined in Section 11.1.1.2. The asterisk "*" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</pre>
</div>


				<section id="_request.accept-encoding">
<h5>11.1.4.1. 要請~内の `Accept-Encoding^h</h5>

<p>
`~server$は、次の規則を利用して，［
所与の`表現$用の`内容~符号法$は，`~UA$にとって受容-可能になるかどうか
］を~testする：
◎
A server tests whether a content-coding for a given representation is acceptable using these rules:
</p>
<ol>
	<li>
要請~内に `Accept-Encoding^h ~fieldが無い場合、どの`内容~符号法$も受容-可能であると見なされる。†b
◎
If no Accept-Encoding field is in the request, any content-coding is considered acceptable by the user agent.
</li>
	<li>
<p>
`表現$が`内容~符号法$を持たない場合、
`Accept-Encoding^h の`~field値$が次のいずれかを満足する場合を除き，既定で受容-可能である†c：
◎
If the representation has no content-coding, then it is acceptable by default unless specifically excluded by the Accept-Encoding field stating either＼
</p>
		<ul>
			<li>
"`identity;q=0^c" を伴う。
◎
"identity;q=0" or＼
</li>
			<li>
"`*;q=0^c" を伴う, かつ［
明示的な品質値を伴う `identity^c
］は伴わない。
◎
"*;q=0" without a more specific entry for "identity".
</li>
		</ul>

<p class="trans-note">【
"`identity$c" も内容~符号法の一種（恒等変換）と見なして、表現が内容~符号法を持たないことを，
“表現は内容~符号法 "`identity^c" を持つ”
と解釈すれば、この規則は，次項による規則の特別な場合と見なせる。
】</p>

	</li>
	<li>
`表現$の`内容~符号法$が［
`Accept-Encoding^h の`~field値$内に~listされているもの
］である場合、それに`品質値$ 0 が付随していない限り，受容-可能である。
（`品質値$の定義により，値 0 は “受容-可能でない”ことを意味する）。†d
◎
If the representation's content-coding is one of the content-codings listed in the Accept-Encoding field value, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in Section 11.1.1.2, a qvalue of 0 means "not acceptable".)
</li>
	<li>
複数の `内容~符号法$が受容-可能である場合、受容-可能な`内容~符号法$のうち［
最も高い`品質値$（ ~NEQ 0 ）を伴うもの
］が選好される。†e
◎
If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.
</li>
</ol>

<div class="p">
<p>
`Accept-Encoding^h ~headerの`~field値$が空である場合、［
`~UA$は、応答~内に どの`内容~符号法$も~~望まない
］ことを含意する。†f
◎
An Accept-Encoding header field with a field value that is empty implies that the user agent does not want any content-coding in response.＼
</p>

<p>
`生成元~server$は、［
要請~内に `Accept-Encoding^h ~headerが在る
］かつ［
応答に可用な どの`表現$も
受容-可能として~listされた`内容~符号法$を持たない
］場合には，`内容~符号法$を伴わない応答を送信するベキである。†g
◎
If an Accept-Encoding header field is present in a request and none of the available representations for the response have a content-coding that is listed as acceptable, the origin server SHOULD send a response without any content-coding.
</p>
</div>

<div class="trans-note">

<p>【
~serverが，選好される内容~符号法を選定する手続きは、以下のように定式化できるであろう：
】</p>

<p>
尚，ここでは、 "`identity^c" も内容~符号法の一種と見なす。
また、以下に現れる “（†…）” は，上のどの規則が反映されているかを表す。
</p>

<p>
まず、（表現に可用かどうかに関わらず，）~UAにとって受容-可能と見なされる内容~符号法の集合 `S^V, および それらの各 品質値を得る：
</p>
<ol>
	<li>
<p>
`V^V ~LET 要請~内に `Accept-Encoding^h ~headerは［
在るならば その`~field値$ ／
無いならば "`*^c" （†b）
］
</p>

<p>
上の規則では、
`V^V の中に同じ内容~符号法（ あるいは "`*^c" ）が複数 現れる場合の挙動が指定されていない
— 以降では、この種の競合は，次に挙げるような何らかの挙動により解消されていると見なす
⇒＃
何らかの基準に従って，それらのうちの一つに絞り、残りは `V^V から除去する／
それらをすべて `V^V から除去する／
構文~errorとして，~headerは無かったかのように扱う
</p>

	</li>
	<li>
`V^V の中の，品質値を伴わない［
内容~符号法, および "`*^c"
］の品質値は、`既定の重み$ 1 と見なす。
</li>
	<li>
`Q^V ~LET ［
`V^V の中に "`*^c" が現れるならば，その品質値 ／
他の場合は 0
］（†c, †d, †f）。
</li>
	<li>
`V^V に~listされていない，どの内容~符号法の品質値も、 `Q^V と見なす（†a）。
</li>
	<li>
`S^V は、既知な すべての内容~符号法（ "`identity$c" も含む）のうち，品質値が 0 でないものからなる集合である（†a, †c, †d）。
</li>
</ol>

<p>
応答に最も選好される内容~符号法は、
</p>
<ul>
	<li>
`T^V ~LET 応答に可用なすべての表現の，内容~符号法の集合††
</li>
	<li>
`R^V ~LET `S^V, `T^V の交差集合
</li>
</ul>

<p>
とするとき：
</p>
<ul>
	<li>
`R^V が空~集合ならば（どれも選好されないが） `identity^c と見なすべきである（†c, †g）（†f）††
</li>
	<li>
他の場合、 `R^V の中で，品質値が最~大なものたち（†e）。
</li>
</ul>

<p>††
通常は， `identity$c は常に `T^V に含まれると考えられるが、明言されていない
— ~serverが強制的に他の内容~符号法のみに限定することも，あるかもしれない。
</p>
</div>

				</section>
				<section id="_response.accept-encoding">
<h5>11.1.4.2. 応答~内の `Accept-Encoding^h</h5>

<p>
`Accept-Encoding^h ~headerが応答~内に在るときは、［
当の応答に結付けられている要請にて，当の資源が受容する用意があった`内容~符号法$たち
］を指示する。
その`~field値$は、要請におけるそれと同じ仕方で評価される。
◎
When the Accept-Encoding header field is present in a response, it indicates what content codings the resource was willing to accept in the associated request. The field value is evaluated the same way as in a request.
</p>

<p>
この情報は、結付けられている要請に特有であることに注意。
~supportされる符号化法の集合は、同じ~server上の他の資源~用のそれとは異なるかもしれない。
また、時間とともに変化したり，要請の他の側面（`要請~method$など）に依存することもある。
◎
Note that this information is specific to the associated request; the set of supported encodings might be different for other resources on the same server and could change over time or depend on other aspects of the request (such as the request method).
</p>

<p>
所与の`内容~符号法$を~supportしないことに因り，要請に対し失敗した~serverは、
`415$st で応答する~OUGHT
— 加えて，その応答~内に `Accept-Encoding^h ~headerを内包して、当の課題は［
内容~符号法, ~MIME型
］のどちらに関係するか判別するのを，~clientに許容する~OUGHT。
~MIME型に関係する課題との混同を避けるため、
`415^st0 を伴う要請に対し内容~符号法に無関係な事由で失敗した~serverは，
`Accept-Encoding^h ~headerを内包してはナラナイ。
◎
Servers that fail a request due to an unsupported content coding ought to respond with a 415 (Unsupported Media Type) status and include an Accept-Encoding header field in that response, allowing clients to distinguish between issues related to content codings and media types. In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.
</p>

<p>
`Accept-Encoding^h は、［
`~client$による`内容~符号法$の楽観的な利用に対する，
`415$st 状態s~codeを伴う応答
］内で，最も共通的に利用される。
しかしながら，この~headerは、［
`内容~符号法$が~supportされることを~clientに指示して，未来のヤリトリを最適化する
］ためにも利用できる。
例えば，［
要請~payloadは 圧縮~符号法の利用を正当化するほど十分に大きかったが，~clientがそうするのに失敗した
］とき、`資源$は `2xx$st 応答~内に この~headerを内包するかもしれない。
◎
The most common use of Accept-Encoding is in responses with a 415 (Unsupported Media Type) status code, in response to optimistic use of a content coding by clients. However, the header field can also be used to indicate to clients that content codings are supported, to optimize future interactions. For example, a resource might include it in a 2xx (Successful) response when the request payload was big enough to justify use of a compression coding but the client failed do so.
</p>

<p class="note">注記：
ほとんどの~HTTP10応用は、`内容~符号法$に結付けられた`品質値$を［
認識しない／順守しない
］。
これは、`品質値$が働かないかもしれず，［
`x-gzip^c や `x-compress^c
］との~~併用も許可されないことを意味する。
◎
Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues might not work and are not permitted with x-gzip or x-compress.
</p>

				</section>
			</section>
			<section id="field.accept-language">
<h4>11.1.5. `Accept-Language^h</h4>

<p>
`~UA$は、 `Accept-Language^h ~headerを利用して，次を指示できる
⇒
応答にて選好される自然~言語（`言語~tag$）の集合
◎
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Language tags are defined in Section 7.6.1.
</p>

<pre class="bnf">
`Accept-Language@p
    = #( `language-range$p [ `weight$p ] )
`language-range@p
    = &lt;language-range, `RFC4647/2.1$sec&gt;
</pre>

【！ Errata ID: 4734 Rejected】

<p>
各 `language-range$p には、次を与えれる
⇒
それが指定する言語~範囲に結付けられる，［
利用者の選好の見積もり
］を表現する`品質~値$
◎
Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in Section 11.1.1.2.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept-Language: da, en-gb;q=0.8, en;q=0.7
</pre>

<p>
は、次を意味することになる
⇒
“~Danishを選好しますが，英国~英語 や他~種の英語も受容します”。
◎
would mean: "I prefer Danish, but will accept British English and other types of English".
</p>
</div>

<p>
一部の受信者は
— 特に，等しい`品質~値$がアテガわれた`言語~tag$たちに対し —
`言語~tag$が~listされた順序を，優先度~順の指示として扱うことに注意（どの~tagの品質値も 1 でなくなる）。
しかしながら、この挙動には依拠できない。
多くの~UAは、一貫性を得るため, および 相互運用能を最大化するため、各`言語~tag$に一意な`品質~値$をアテガった上で，それらを品質の降順で~listする。
言語~優先度~listについての追加的な論点は、`RFC4647/2.3$sec に見出せる。
◎
Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1). However, this behavior cannot be relied upon. For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality. Additional discussion of language priority lists can be found in Section 2.3 of [RFC4647].
</p>

<p>
`RFC4647/3$sec は、数種の照合~schemeを，照合~用に定義している。
実装は、自身の要件に最も適切な照合~schemeを提供できる。
"Basic Filtering" ~scheme（ `RFC4647/3.3.1$sec ）は、以前に［
`RFC2616/14.4$sec にて，~HTTP用として定義された照合~scheme
］と一致する。
◎
For matching, Section 3 of [RFC4647] defines several matching schemes. Implementations can offer the most appropriate matching scheme for their requirements. The "Basic Filtering" scheme ([RFC4647], Section 3.3.1) is identical to the matching scheme that was previously defined for HTTP in Section 14.4 of [RFC2616].
</p>

<p>
毎~要請ごとに［
完全な，利用者の言語上の選好
］を伴う `Accept-Language^h ~headerを送信するのは、利用者が期待する~privacyに反し得る（ `16.12$sec ）。
◎
It might be contrary to the privacy expectations of the user to send an Accept-Language header field with the complete linguistic preferences of the user in every request (Section 16.12).
</p>

<p>
言語の理解度は，個々の利用者に大きく依存するので、`~UA$は，言語上の選好を制御することを利用者に許容する必要がある（~UAの環境設定を通して, あるいは 利用者が制御できる~system設定による既定により）。
そのような制御を利用者に供さない`~UA$は、
`Accept-Language^h ~headerを送信してはナラナイ。
◎
Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting). A user agent that does not provide such control to the user MUST NOT send an Accept-Language header field.
</p>

<p class="note">注記：
`~UA$は、選好の設定~時に，利用者~向けの指導を供する~OUGHT
— 利用者が、上に述べた言語~照合の詳細について，~~馴染んでいることは稀なので。
例えば，利用者は、［
"`en-gb^c" を選定すれば、英国~英語が可用でなくても，どの種類の英語~文書であれ~serveされるようになる
］ものと見做すかもしれない。
~UAは，そのような事例では、照合の挙動を もっと良くするためとして，~listに "`en^c" を追加することを示唆できる。
◎
Note: User agents ought to provide guidance to users when setting a preference, since users are rarely familiar with the details of language matching as described above. For example, users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. A user agent might suggest, in such a case, to add "en" to the list for better matching behavior.
</p>

			</section>
		</section>
		<section id="reactive.negotiation">
<h3 title="Reactive Negotiation">11.2. ~reactive折衝</h3>

<div class="p">
<p>
`~reactive折衝@
においては、~UAが，`表現$の選定を遂行する（ “~agent駆動な折衝” とも呼ばれる）。
すなわち，`~UA$は：
◎
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent＼
</p>
<ol>
	<li>
`生成元~server$から［
代替~表現~用の`資源$の~listを包含する，初期~応答
］を受信した後に，（その`状態s~code$に関わらず）最良な応答~表現を選定する。
◎
after receiving an initial response from the origin server that contains a list of resources for alternative representations.＼
</li>
	<li>
初期~応答の表現で満足されない場合には、［
その応答~用の，異なる形による表現
］を得するために，［
~list内に内包された~metadataに基づいて選定される，一つ以上の代替~資源
］へ向けて， `GET$m 要請を遂行できる。
◎
If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response.＼
</li>
</ol>

<p>
代替の選定は、~UAにより自動的に遂行されることもあれば、利用者が，生成された（場合によっては~hypertextによる）~menuから手動で選定することもある。
◎
Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
</p>
</div>

<div class="p">
<p>
上における表現は、一般には，応答の表現を指すことに注意
— `資源$の`表現$ではなく。
代替~表現は、［
それを供した応答が，次のいずれかの意味論を持つ場合
］に限り，`~target資源$の表現であると見なされる：
◎
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided＼
</p>
<ul>
	<li>
~target資源の`表現$である（例： `GET$m 要請に対する `200$st 応答）
◎
has the semantics of being a representation of the target resource (e.g., a 200 (OK) response to a GET request) or＼
</li>
	<li>
~target資源~用の代替~表現への~linkを供する（例： `GET$m 要請に対する `300$st 応答）
◎
has the semantics of providing links to alternative representations for the target resource (e.g., a 300 (Multiple Choices) response to a GET request).
</li>
</ul>
</div>

<p>
`~server$は、［
代替~list以外の初期~表現を送信しないことを選ぶことにより，`~UA$による~reactive折衝を選好することを指示する
］こともある。
例えば，［
`300$st ／ `406$st を伴う応答
］内に~listされる代替は、［
利用者または~UAが~reactiveに選定を行い得るような，可用な`表現$
］についての情報を内包する。
◎
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the 300 (Multiple Choices) and 406 (Not Acceptable) status codes include information about the available representations so that the user or user agent can react by making a selection.
</p>

<div class="p">
<p>
~reactive折衝は、次のときに有利になる：
◎
Reactive negotiation is advantageous＼
</p>
<ul>
	<li>
応答が、共通的に利用される次元（型【`~MIME型$】, 言語, 符号化法 など）にわたって，様々になり得るとき。
◎
when the response would vary over commonly used dimensions (such as type, language, or encoding),＼
</li>
	<li>
生成元~serverが、要請を精査しても，~UAに備わる能力を決定できないとき。
◎
when the origin server is unable to determine a user agent's capabilities from examining the request, and＼
</li>
	<li>
一般に、~server負荷を分散したり~network利用eを抑制するために，公共~cacheが利用されるとき。
◎
generally when public caches are used to distribute server load and reduce network usage.
</li>
</ul>
</div>

<p>
~reactive折衝には、代替~listを~UAへ伝送する~~手間を要する不利がある
— それは、［
~listを`~header節$~内に伝送し，代替-表現を得するために 2 度目の要請を要する
］場合に，利用者に知覚される待時間を~~増やす。
更には、この仕様は，自動~選定を~supportする仕組みは定義しない
— そのような仕組みを拡張として開発することも~~止めないが。
◎
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
</p>

			<section id="field.vary">
<h4>11.2.1. `Vary^h</h4>

<p>
応答~内の `Vary^h ~headerは、［
~method／`~target~URI$
］の他に，要請~messageのどの部分が［
`生成元~server$による，この応答を選定して表現する処理n
］に波及し得た（し得る）かを述べる。
◎
The "Vary" header field in a response describes what parts of a request message, aside from the method and target URI, might influence the origin server's process for selecting and representing this response.
</p>

<pre class="bnf">
`Vary@p
    = #( "*" / `field-name$p )
</pre>

<p>
`Vary^h は，`~listに基づく~field$であり、その`~field値$は，この応答~用の`表現$を選定する役割を担い得た要請~field名からなる
— これらは
`選定用~header@
と呼ばれる。
選定用~headerになり得るものは、この仕様が定義するものに制限されない。
◎
A Vary field value is a list of request field names, known as the selecting header fields, that might have a role in selecting the representation for this response. Potential selecting header fields are not limited to those defined by this specification.
</p>

<p>
この~listが "`*^c" を包含する場合、要請の他の側面
— 場合によっては、~message構文の外側の要素も含む（例：~clientの~network~address） —
が，応答の`表現$を選定する役割を担い得ることを通達する。
`受信者$は、この応答が今後の【以前の要請と一致する】要請にも適切になるかどうかを
— 要請を`生成元~server$に回送しない限り —
決定できないことになる。
`~proxy$は、 `Vary^h の`~field値$内に "`*^c" を`生成し$てはナラナイ。
◎
If the list contains "*", it signals that other aspects of the request might play a role in selecting the response representation, possibly including elements outside the message syntax (e.g., the client's network address). A recipient will not be able to determine whether this response is appropriate for a later request without forwarding the request to the origin server. A proxy MUST NOT generate "*" in a Vary field value.
</p>

<div class="example">
<p>
例えば，次を包含する応答は：
◎
For example, a response that contains
</p>

<pre class="lang-http">
Vary: accept-encoding, accept-language
</pre>

<p>
次を指示する
⇒
`生成元~server$は、この応答~用の内容を選ぶ決定要因として，要請の［
`Accept-Encoding$h, `Accept-Language$h
］~field（または それらの欠如）を利用したかもしれない
◎
indicates that the origin server might have used the request's Accept-Encoding and Accept-Language fields (or lack thereof) as determining factors while choosing the content for this response.
</p>
</div>

<p>
`生成元~server$が［
`~field名$の~listを伴う `Vary^h
］を送信する目的には、次の 2 つがあり得る：
◎
An origin server might send Vary with a list of fields for two purposes:
</p>
<ul>
	<li>
<p>
`~cache$受信者たちに，次のことを伝える
⇒
この応答は、次を満たされない限り，今後の要請を満足するために利用してはナラナイ
⇒
要請は、~listされた~fieldについて，元の要請と同じ値をとる（ `Caching/4.1$sec ）
</p>
<p>
言い換えれば `Vary^h は、［
新たな要請が，格納-済みな~cache~entryに合致する
］ために要求される~cache~keyを拡げる。
</p>
◎
To inform cache recipients that they MUST NOT use this response to satisfy a later request unless the later request has the same values for the listed fields as the original request (Section 4.1 of [Caching]). In other words, Vary expands the cache key required to match a new request to the stored cache entry.
</li>
	<li>
`~UA$受信者に，次のことを伝える
⇒
この応答は，`内容~折衝$の~subjectであり、~listされたいずれかの~header内に 追加的な~parameterが供される場合には，後続の要請に対し異なる`表現$が送信され得る（`~proactive折衝$）。
◎
To inform user agent recipients that this response is subject to content negotiation (Section 11) and that a different representation might be sent in a subsequent request if additional parameters are provided in the listed header fields (proactive negotiation).
</li>
</ul>

<div class="p">

<p>
`生成元~server$は、［
自身による，`表現$を選定する~algo
］が［
要請~messageの［
~method, `~target~URI$
］以外の側面
］に基づいて変動するときには， `Vary^h ~headerを送信するベキである
— ただし，次のいずれかに該当する場合は除く：
</p>
<ul>
	<li>
そのような変動は生じ得ないとき【！cannot be crossed】
— 例えば
⇒
`~field名$ `Authorization$h は、［
その定義により，複数~利用者にまたがる再利用が拘束される
］ので， `Vary^h 内に送信する必要はない。
</li>
	<li>
当の生成元~serverは、~cache透過性を防止するように，故意に環境設定されているとき
— 例えば
⇒
生成元~serverは、［
変動よりも， `Vary^h による~cachingの処理能~costへの影響iの方が有意である
］と見なす場合には，
`Vary^h に代えて `Cache-Control$h 応答~指令を利用するかもしれない。
</li>
</ul>

◎
An origin server SHOULD send a Vary header field when its algorithm for selecting a representation varies based on aspects of the request message other than the method and target URI, unless＼
the variance cannot be crossed or＼
the origin server has been deliberately configured to prevent cache transparency.＼
For example,＼
there is no need to send the Authorization field name in Vary because reuse across users is constrained by the field definition (Section 10.6.2).＼
Likewise, an origin server might use Cache-Control response directives (Section 5.2 of [Caching]) to supplant Vary if it considers the variance less significant than the performance cost of Vary's impact on caching.
</div>

			</section>
		</section>
		<section id="request.payload.negotiation">
<h3 title="Request Payload Negotiation">11.3. 要請~payload折衝</h3>

<p>
`~server$が応答~内に`内容~折衝$の選好を送信するとき、~listされた選好たちは，
`要請~payload折衝@
と呼ばれる
— それらは、［
当の資源に対する後続の要請~用の~payloadとして適切なもの
］の選定に波及することが意図されるので。
例えば，
`Accept-Encoding$h ~fieldは、当の資源に対する後続の要請~用に選好される`内容~符号法$を指示するため，応答~内に送信され得る
`RFC7694$r
。
◎
When content negotiation preferences are sent in a server's response, the listed preferences are called request payload negotiation because they intend to influence selection of an appropriate payload for subsequent requests to that resource. For example, the Accept-Encoding field (Section 11.1.4) can be sent in a response to indicate preferred content codings for subsequent requests to that resource [RFC7694].
</p>

<aside>
<p class="note">
同様に， `RFC5789$r は、
`Accept-Patch$h 応答~headerを定義する
— それは、［
`PATCH$m 要請~内で受容される内容~型
］の発見を許容する。
◎
Similarly, Section 3.1 of [RFC5789] defines the "Accept-Patch" response header field which allows discovery of which content types are accepted in PATCH requests.
</p>
</aside>

		</section>
	</section>
	<section id="conditional.requests">
<h2 title="Conditional Requests">12. 条件付き要請</h2>

<p>
`条件付き要請@
（ `conditional request^en ）とは、
1 個~以上の`条件付き要請~header$を伴う~HTTP要請である。
`条件付き要請~header@†
とは、
`事前条件@
（ `precondition^en ）
— 要請~methodを`~target資源$に適用する前に~testされることになる条件 —
を指示する`要請~header$である。
`12.2$sec は、事前条件がいつ適用されるかを定義する。
`12.3$sec は、事前条件が複数個~在るときの評価~順序を定義する。
◎
A conditional request is an HTTP request with one or more request header fields that indicate a precondition to be tested before applying the request method to the target resource. Section 12.2 defines when preconditions are applied. Section 12.3 defines the order of evaluation when more than one precondition is present.
</p>

<p class="trans-note">【†
“事前条件~header” とも称される。
これら 2 つの用語は、同義と見受けられる（その差異は、この仕様からは読み取れない）。
】【
［
条件付き要請／条件付き~header
］は、単に
“条件付き”
とも総称される（文脈に応じて，どちらか適切な方を指すであろう）。
】</p>

<p>
条件付き `GET$m 要請は、~HTTP~cache更新 `Caching$r 用の効率的な仕組みの大部分を~~占める。
条件付きは、
“`更新喪失@”
問題
— 並列的に動作している ある~clientが，別の~clientによる成果を偶発的に上書きすること —
を防止するために，［
`PUT$m や `DELETE$m などの状態変更~method
］にも適用され得る／できる。
◎
Conditional GET requests are the most efficient mechanism for HTTP cache updates [Caching]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the "lost update" problem: one client accidentally overwriting the work of another client that has been acting in parallel.
</p>

<p>
`条件付き要請$の`事前条件$は、［
一体としての，`~target資源$の状態（その現在の値の集合）
］, あるいは［
以前に得された`表現$（その集合~内の 1 つの値）
］にて観測される状態に基づく。
`資源$は、現在の表現として，［
それぞれが自前の観測-可能な状態を伴うような，複数の表現
］を持つかもしれない。
条件付き要請の仕組みは、~serverが その利点を得ようと意図するならば，［
要請から`選定された表現$への対応関係は、時経過にわたり一貫する
］ものと見做す。
いずれにせよ、対応関係が一貫しなくなり，~serverが適切な`表現$を選定-不能になっても、事前条件が偽に評価される結果，害になることはない。
◎
Conditional request preconditions are based on the state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). A resource might have multiple current representations, each with its own observable state. The conditional request mechanisms assume that the mapping of requests to a selected representation (Section 7) will be consistent over time if the server intends to take advantage of conditionals. Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false.
</p>

		<section id="preconditions">
<h3 title="Preconditions">12.1. 事前条件</h3>

<p>
次に挙げる`要請~header$は、`~target資源$の状態に対する`事前条件$を設置することを，`~client$に許容する
— それは、偽に評価されたときには［
~method意味論に対応する動作
］を適用しない†ようにする条件を与える
⇒＃
`If-Match$h
`If-None-Match$h
`If-Modified-Since$h
`If-Unmodified-Since$h
`If-Range$h†
◎
The following request header fields allow a client to place a precondition on the state of the target resource, so that the action corresponding to the method semantics will not be applied if the precondition evaluates to false.＼
</p>

<p class="trans-note">【†
`If-Range^h については、適用~対象が（~method意味論に直に対応する動作ではなく） `Range$h ~headerになる点で，他の事前条件~headerと異なる。
】</p>

<p>
この仕様が定義する各種 `事前条件$は、［
先立つ［
~target資源の`表現$
］から得された`検証子$の集合
］と［
`選定された表現$用の，それらの検証子の現在の状態
］との比較からなる（ `7.9$sec ）。
よって，これらの事前条件は、~target資源の状態が［
~clientに既知である，所与の状態
］から変化したかどうかを評価する。
そのような評価の効果は、
`12.2$sec に定義されるように［
~method意味論, 条件付きの選択
］に依存する。
◎
Each precondition defined by this specification consists of a comparison between a set of validators obtained from prior representations of the target resource to the current state of validators for the selected representation (Section 7.9). Hence, these preconditions evaluate whether the state of the target resource has changed since a given state known by the client. The effect of such an evaluation depends on the method semantics and choice of conditional, as defined in Section 12.2.
◎
Table 12
Field Name 	Ref.

If-Match 	12.1.1
If-None-Match 	12.1.2
If-Modified-Since 	12.1.3
If-Unmodified-Since 	12.1.4
If-Range 	12.1.5
</p>


			<section id="field.if-match">
<h4>12.1.1. `If-Match^h</h4>

<p>
`If-Match^h ~headerは、受信者である`生成元~server$に対し，`要請~method$を次による条件付きにする：
◎
The "If-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を `S^V とするとき、`~field値$に応じて：
◎
the recipient origin server either＼
</p>
		<ul class="switch" id="condition-If-Match">
			<li>
"`*^c" の場合
⇒
`S^V は空でない。
◎
having at least one current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^V 内に［
~list内の ある~memberに合致する `entity-tag$p
］を持つものがある。
◎
having a current representation of the target resource that has an entity-tag matching a member of the list of entity-tags provided in the field value.
</li>
		</ul>
	</li>
	<li>
`生成元~server$は、
`If-Match^h に対し `entity-tag$p を比較するときには，`強い比較~関数$を利用しなければナラナイ
— ~clientが，この`事前条件$に意図しているのは、［
`表現~data$に何か変化があった場合には，~methodを適用しない
］ことなので。
◎
An origin server MUST use the strong comparison function when comparing entity-tags for If-Match (Section 7.9.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.
</li>
</ul>

<pre class="bnf">
`If-Match@p
    = "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</pre>
</div>

<p>
`If-Match^h は、［［
同じ`資源$に対し，複数の~UAが並列的に動作し得る
］ときの，偶発的な上書-（すなわち， “`更新喪失$”問題）
］を防止するために，状態変更~method（例：
`POST$m, `PUT$m, `DELETE$m
）と伴に，最もよく利用される。
また、どの~methodにも利用できる／され得る
— `選定された表現$が［
当の`~client$が、以前の要請に対し，すでに（あるいは`部分的$に）格納した応答
］に合致しない場合には、要請を中止するために。
◎
If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the "lost update" problem). It can also be used with any method to abort a request if the selected representation does not match one that the client has already stored (or partially stored) from a prior request.
</p>

<p>
`If-Match^h ~headerを受信した`生成元~server$は、~methodの遂行に先立って
— `12.2$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Match">前述の条件</a>を評価しなければナラナイ
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Match header field MUST evaluate the condition as per Section 12.2 prior to performing the method.
◎
To evaluate a received If-Match header field:
• If the field value is "*", the condition is true if the origin server has a current representation for the target resource.
• If the field value is a list of entity-tags, the condition is true if any of the listed tags match the entity-tag of the selected representation.
• Otherwise, the condition is false.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server MUST NOT perform the requested method if a received If-Match condition evaluates to false.＼
</li>
	<li>
代わりに，`状態s~code$ `412$st で応答して、当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、`選定される表現$には，すでに適用されたように出現している場合
］には、前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ（すなわち，~UAから要請された変更はすでに成功したが、たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気づかなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、複数の~UAが，共通な資源に対し~semaphoreとして書込んでいると（例：可分な増分）、衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、厳格に［
~methodが`安全$でない場合は、失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
他の事例【`安全$な場合】では、当の資源の現在の状態についての混同を排するよう，成功~応答から `ETag$h ~fieldを除外すれば、次回の要請として `GET$m を遂行するよう~UAに奨励するかもしれない。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a non-atomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.
</p>
	</li>
</ul>

<p>
`If-Match^h ~headerは、格納-済み応答には適用-可能でないので，~cacheや`中継者$からは無視され得る。
◎
The If-Match header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

<p>
`If-Match^h ~headerに［
"`*^c" と他の値（ "`*^c" も含む）
］を包含している~list値が伴われる場合、相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-Match header field with a list value containing "*" and other values (including other instances of "*") is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-none-match">
<h4>12.1.2. `If-None-Match^h</h4>

<div class="p">
<p>
`If-None-Match^h ~headerは、受信者である［
`~cache$／`生成元~server$
］に対し，`要請~method$を次による条件付きにする：
◎
The "If-None-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を `S^V とするとき、`~field値$に応じて：
◎
a recipient cache or origin server either＼
</p>
		<ul class="switch" id="condition-If-None-Match">
			<li>
"`*^c" の場合
⇒
`S^V は空である。
◎
not having any current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^V 内で`選定される表現$として［
~list内の ある~memberに合致する `entity-tag$p
］を持つものはない。
◎
having a selected representation with an entity-tag that does not match any of those listed in the field value.
</li>
		</ul>
	</li>
	<li>
受信者は、 `If-None-Match^h 用に `entity-tag$p を比較するときには，`弱い比較~関数$を利用しなければナラナイ
— `弱い検証子$である `entity-tag$p は、`表現~data$が変化したとしても，`~cache検証$に利用できるので。
◎
A recipient MUST use the weak comparison function when comparing entity-tags for If-None-Match (Section 7.9.3.2), since weak entity-tags can be used for cache validation even if there have been changes to the representation data.
</li>
</ul>
</div>

<pre class="bnf">
`If-None-Match@p
    = "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</pre>
</div>

<p>
`If-None-Match^h は、［
~transactionの~overheadを最小に~~抑えて，~cache済み情報の効率的な更新を可能化する
］ために、首に，条件付き `GET$m 要請にて利用される。
~clientが `entity-tag$p を持つ 1 個以上の格納-済み応答の更新を欲するときは、
`GET$m 要請を為すときに［
それらの `entity-tag$p からなる~listを包含する， `If-None-Match^h ~header
］を`生成する$ベキである
— これにより、受信者~serverは、［
それら格納-済み応答のいずれかが，`選定された表現$に合致した
］ときに，それを指示する `304$st 応答を送信できるようになる。
◎
If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity-tags, the client SHOULD generate an If-None-Match header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation.
</p>

<p>
`If-None-Match^h は、`安全$でない`要請~method$（例： `PUT$m ）にも，値 "`*^c" を伴わせて利用できる
— これにより，~clientは、`資源$が現在の`表現$を持たないものと予見できるときに，`~target資源$の既存の表現を不作為に改変することを防止できる。
これは、［
~~複数の~clientが，`~target資源$に対する初期~表現を作成しようと試みた
］ときに発生し得る， “`更新喪失$” 問題の一種である。
◎
If-None-Match can also be used with a value of "*" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 8.2.1). This is a variation on the "lost update" problem that might arise if more than one client attempts to create an initial representation for the target resource.
</p>

<p>
`If-None-Match^h ~headerを受信した`生成元~server$は、~methodの遂行に先立って
— `12.2$sec に従う下で —
その~field値に与えられた<a href="#condition-If-None-Match">前述の条件</a>を
評価しなければナラナイ
— 条件が偽に評価された場合
◎
An origin server that receives an If-None-Match header field MUST evaluate the condition as per Section 12.2 prior to performing the method.
◎
To evaluate a received If-None-Match header field:
• If the field value is "*", the condition is false if the origin server has a current representation for the target resource.
• If the field value is a list of entity-tags, the condition is false if one of the listed tags matches the entity-tag of the selected representation.
• Otherwise, the condition is true.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server MUST NOT perform the requested method if the condition evaluates to false;＼
</li>
	<li>
代わりに，［
`要請~method$が `GET$m または `HEAD$m ならば `304$st ／
他の要請~methodに対しては `412$st
］で応答しなければナラナイ。
◎
instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.
</li>
</ul>

<p>
`~cache$が受信した `If-None-Match^h ~headerの取扱い課される要件は、
`Caching/4.3.2$sec
にて定義される。
◎
Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [Caching].
</p>

<p>
`If-None-Match^h ~headerに［
"`*^c" と他の値（ "`*^c" も含む）を包含している~list値
］が伴われる場合、相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-None-Match header field with a list value containing "*" and other values (including other instances of "*") is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-modified-since">
<h4>12.1.3. `If-Modified-Since^h</h4>

<div class="p">
<p>
`If-Modified-Since^h ~headerは、［
`GET$m ／ `HEAD$m
］要請~methodを，次による条件付きにする：
◎
The "If-Modified-Since" header field makes a GET or HEAD request method conditional on＼
</p>
<ul id="condition-If-Modified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は、`~field値$が供する日時より近過去である。
◎
the selected representation's modification date being more recent than the date provided in the field value.＼
</li>
</ul>

<p>
`選定された表現$の~dataが変更されていない場合、その転送を避けれるようになる。
◎
Transfer of the selected representation's data is avoided if that data has not changed.
</p>
</div>

<pre class="bnf">
`If-Modified-Since@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
~fieldの例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
受信者は、要請が `If-None-Match$h ~headerも包含する場合には，
`If-Modified-Since^h を無視しなければナラナイ
— `If-None-Match$h 内の条件は，
`If-Modified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-None-Match$h を実装していない~~可能性もある古い`中継者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.
</p>

<div class="p">
<p>
受信者は、次のいずれかの場合には，
`If-Modified-Since^h ~headerを無視しなければナラナイ：
◎
A recipient MUST ignore the If-Modified-Since header field＼
</p>
<ul>
	<li>
受信した`~field値$は、
`HTTP-date$p として妥当でないか，
1 個以上の~memberからなる。
◎
if the received field value is not a valid HTTP-date, the field value has more than one member, or＼
</li>
	<li>
`要請~method$は `GET$m, `HEAD$m のいずれでもない。
◎
if the request method is neither GET nor HEAD.
</li>
</ul>
</div>

<p>
受信者は、
`If-Modified-Since^h ~field値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.
</p>

<div class="p">
<p>
`If-Modified-Since^h は、概して，次に挙げる別個な目的に利用される：
◎
If-Modified-Since is typically used for two distinct purposes:＼
</p>
<ul>
	<li>
(A)
`entity-tag$p を持たないような~cache済み`表現$を，効率的に更新する。
◎
1) to allow efficient updates of a cached representation that does not have an entity-tag and＼
</li>
	<li>
(B)
［
~web~traversalによる，`資源$への検索取得
］の対象範囲を，近過去に変更されたもののみに制限する。
◎
2) to limit the scope of a web traversal to resources that have recently changed.
</li>
</ul>
</div>

<div class="p">
<p>
上の (A) に利用される場合、`~cache$は，概して，
`If-Modified-Since^h の~field値を`生成する$ときに［
~cache済み~messageの `Last-Modified$h ~field値
］を利用することになる。
この挙動は、次の事例において，最も相互運用-可能になる：
◎
When used for cache updates, a cache will typically use the value of the cached message's Last-Modified field to generate the field value of If-Modified-Since. This behavior is most interoperable for cases＼
</p>
<ul>
	<li>
`時計$の同期-に乏しいとき, または
◎
where clocks are poorly synchronized or＼
</li>
	<li>
~serverが，［
時刻印の正確な合致のみを尊守する
］ことを選んだとき（［
`生成元~server$の`時計$が正された
］または［
`表現$が~backupの~archiveから格納し直された
］ことにより，
`Last-Modified$h 日時が “~~過去に戻る” ように出現する問題に因り）。
◎
when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go "back in time" when the origin server's clock is corrected or a representation is restored from an archived backup).＼
</li>
</ul>

<p>
しかしながら，`~cache$は、ときには，［
~cache済み~messageの `Date$h ~headerや,
~messageを受信したときの局所的な時計による時刻
］などの他の~dataに基づいて，~field値を`生成する$こともある
— 特に，~cache済み~messageが `Last-Modified$h ~fieldを包含しないときに。
◎
However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a Last-Modified field.
</p>
</div>

<p>
上の (B) に利用される場合、~UAは，［
自前の局所的な時計, または
先立つ応答にて~serverから受信した `Date$h ~header
］に基づいて， `If-Modified-Since^h ~field値を`生成する$ことになる。
`生成元~server$が，［
`選定された表現$の `Last-Modified$h ~fieldに基づく，時刻印の正確な合致
］を選んだ場合、［
~UAが，~data転送を［
指定された~~時区間~内に変更されたもの
］のみに制限する
］一助にはならなくなることになる。
◎
When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own local clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
</p>

<div class="p">
<p>
`If-Modified-Since^h ~headerを受信した`生成元~server$は、`~method$の遂行に先立って
— `12.2$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Modified-Since">前述の条件</a>を評価するベキである
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Modified-Since header field SHOULD evaluate the condition as per Section 12.2 prior to performing the method.＼
</p>
<ul>
	<li>
要請された~methodを遂行するベキでない
◎
The origin server SHOULD NOT perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field value;＼
</li>
	<li>
代わりに，次のみを内包する， `304$st 応答を`生成する$ベキである
⇒
【応答の受信者が】以前に~cacheした応答を［
識別する／更新する
］ために有用になる~metadata
◎
instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.
</li>
</ul>
</div>

<p>
`~cache$が受信した `If-Modified-Since^h ~headerの取扱いに課される要件は、
`Caching/4.3.2$sec
にて定義される。
◎
Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [Caching].
</p>

			</section>
			<section id="field.if-unmodified-since">
<h4>12.1.4. `If-Unmodified-Since^h</h4>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerは、`要請~method$を
<span id="condition-If-Unmodified-Since">次の`否定^em</span>
による条件付きにする：
◎
The "If-Unmodified-Since" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`選定された表現$には［
`改変~日時$がある†
］かつ［
その最後の改変~日時は、`~field値$が供する日時より近過去である
］。
◎
the selected representation's last modification date being earlier than or equal to the date provided in the field value.＼
</p>

<p class="trans-note">【†
この条件（この改訂による追加）は、原文では後に現れているが，評価-可能になるために必要になるので ここに移動している。
（ `If-Modified-Since$h には，改変~日時の有無について述べられていないが、同様に必要になろう。）
】</p>
	</li>
</ul>

<p>
この~fieldは、~UAが`表現$用の `entity-tag$p を持たない所で， `If-Match$h と同じ目的を成遂げる。
◎
This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation.
</p>
</div>

<pre class="bnf">
`If-Unmodified-Since@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
`If-Unmodified-Since^h ~headerの受信者は：
◎
↓</p>
<ul>
	<li>
要請が `If-Match$h ~headerも包含する場合は、
`If-Unmodified-Since^h を無視しなければナラナイ
— `If-Match$h 内の条件は，
`If-Unmodified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-Match$h を実装していないかもしれない古い`中継者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.
</li>
	<li>
受信した`~field値$は妥当な `HTTP-date$p でない場合（~field値は日時の~listとして出現している場合も含む）、
`If-Unmodified-Since^h ~headerを無視しなければナラナイ。
◎
A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).
</li>
	<li>
`If-Unmodified-Since^h ~field値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.
</li>
</ul>

<p>
`If-Unmodified-Since^h は、状態変更~method（例： `POST$m, `PUT$m, `DELETE$m ）と伴に最もよく利用される
— ［
その`表現$に `entity-tag$p を給さない`資源$
］上で，複数の~UAが並列的に動作し得るときの、偶発的な上書-（すなわち， “`更新喪失$” 問題）を防止するために。
また、どの~methodにも利用できる／され得る
— `選定された表現$が［
当の`~client$が、以前の要請に対し，すでに（あるいは`部分的$に）格納した応答
］に合致しないときは、要請を中止するために。
◎
If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the "lost update" problem). It can also be used with any method to abort a request if the selected representation does not match one that the client already stored (or partially stored) from a prior request.
</p>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerを受信した`生成元~server$は、`~method$の遂行に先立って
— `12.2$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Unmodified-Since">前述の条件</a>を評価しなければナラナイ
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Unmodified-Since header field MUST evaluate the condition as per Section 12.2 prior to performing the method.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
If the selected representation has a last modification date, the origin server MUST NOT perform the requested method if that date is more recent than the date provided in the field value.＼
</li>
	<li>
代わりに，`状態s~code$ `412$st で応答して、当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、`選定される表現$には，すでに適用されたように出現している場合
］には、前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ（すなわち，~UAから要請された変更はすでに成功したが、たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気づかなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、複数の~UAが，共通な資源に対し~semaphoreとして書込んでいると（例：可分な増分）、衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、厳格に［
~methodが`安全$でない場合は、失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.
</p>
	</li>
</ul>
</div>

<p>
`If-Unmodified-Since^h ~headerは、格納-済み応答には適用-可能でないので，`~cache$や`中継者$からは無視され得る。
◎
The If-Unmodified-Since header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

			</section>
			<section id="field.if-range">
<h4>12.1.5. `If-Range^h</h4>

<p>
`If-Range^h ~headerは、
`If-Match$h や `If-Unmodified-Since$h に~~似るが，［
検証子が合致しない場合には， `Range$h ~headerを無視する
］よう受信者に指図するための、特別な`条件付き要請$の仕組みを供する。
合致しない場合、 `412$st 応答の代わりに，新たな，`選定された表現$が転送されることになる。
◎
The "If-Range" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response.
</p>

<p>
`~client$が，［
`表現$の`部分的$な複製を持っていて, 表現~~全体の~~最新な複製を望む
］ならば、
`Range$h ~headerを，（
`If-Unmodified-Since$h, `If-Match$h
のいずれか, または両者を利用する）条件付き `GET$m と伴に利用できる。
しかしながら、表現が改変されたために`事前条件$が失敗した場合、~clientは，現在の表現~~全体を得するために，もう一度~要請を為さなければならなくなる。
◎
If a client has a partial copy of a representation and wishes to have an up-to-date copy of the entire representation, it could use the Range header field with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the precondition fails because the representation has been modified, the client would then have to make a second request to obtain the entire current representation.
</p>

<p>
`If-Range^h ~headerにより、~clientは，次回の要請を “短絡” できるようになる。
くだけて言えば、次のような意味になる
⇒
“表現がまだ不変なら， `Range$h にて要請している部位t（たち）を送信してください。
そうでなければ，表現~~全体を送信してください。”
◎
The "If-Range" header field allows a client to "short-circuit" the second request. Informally, its meaning is as follows: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.
</p>

<pre class="bnf">
`If-Range@p
    = `entity-tag$p / `HTTP-date$p
</pre>

<p>
`~client$は、
`Range$h ~headerを包含しない要請~内に，
`If-Range^h ~headerを`生成し$てはナラナイ。
`~server$は、
`Range$h ~headerを包含しない要請~内に受信した `If-Range^h ~headerを，無視しなければナラナイ。
`生成元~server$は、
`Range$h 要請を~supportしない`~target資源$に対する要請~内に受信した `If-Range^h ~headerを，無視しなければナラナイ。
◎
A client MUST NOT generate an If-Range header field in a request that does not contain a Range header field. A server MUST ignore an If-Range header field received in a request that does not contain a Range header field. An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.
</p>

<div class="p">
<p>
`~client$は、次のいずれかを包含する `If-Range^h ~headerを`生成し$てはナラナイ：
◎
↓</p>
<ul>
	<li>
弱い（ `weak$p を伴う） `entity-tag$p 。
◎
A client MUST NOT generate an If-Range header field containing an entity-tag that is marked as weak.＼
</li>
	<li>
`HTTP-date$p
— ただし、~clientが対応する`表現$用の `entity-tag$p を持たない, かつ
その日時が `7.9.2.2$sec にて定義されるイミで`強い検証子$になる場合は除く。
◎
A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity-tag for the corresponding representation and the date is a strong validator in the sense defined by Section 7.9.2.2.
</li>
</ul>
</div>

<div class="p">
<p>
`If-Range^h による`事前条件$を評価する`~server$は、
`If-Range$p に供されている`検証子$に応じて：
◎
A server that evaluates an If-Range precondition＼
</p>
<ul class="switch">
	<li>
`entity-tag$p の場合
⇒
`entity-tag^p を比較する際には，`強い比較~関数$を利用しなければナラナイ。
◎
MUST use the strong comparison function when comparing entity-tags (Section 7.9.3.2) and＼
</li>
	<li>
`HTTP-date$p の場合
⇒
それが（ `7.9.2.2$sec に定義されるイミで）`強い検証子$でない場合には、その事前条件を偽に評価しなければナラナイ。
◎
MUST evaluate the condition as false if an HTTP-date validator is provided that is not a strong validator in the sense defined by Section 7.9.2.2.＼
</li>
</ul>

<p>
妥当な `entity-tag^p と妥当な `HTTP-date^p は、判別できる
— 最初の 2 文字について `DQUOTE$P の有無を精査することにより。
◎
A valid entity-tag can be distinguished from a valid HTTP-date by examining the first two characters for a DQUOTE.
</p>
</div>

<p>
`~server$は、
`If-Range^h ~header内に与えられた`検証子$が［
`~target資源$の`選定された表現$に対する現在の`検証子$
］に合致する場合には，
`Range$h ~headerを要請されたとおり処理するベキであり、合致しない場合には，
`Range$h ~headerを無視しなければナラナイ。
この［
正確な合致による比較
］は
— `検証子$が `HTTP-date$p のときも含め —
［
`If-Unmodified-Since$h 条件付きを評価するときの “より早期かどうか” の比較
］から相違することに注意。
◎
If the validator given in the If-Range header field matches the current validator for the selected representation of the target resource, then the server SHOULD process the Range header field as requested. If the validator does not match, the server MUST ignore the Range header field. Note that this comparison by exact match, including when the validator is an HTTP-date, differs from the "earlier than or equal to" comparison used when evaluating an If-Unmodified-Since conditional.
</p>

			</section>
		</section>
		<section id="evaluation">
<h3 title="Evaluation">12.2. 評価</h3>

<div class="p">
<p>
`受信者$である［
`~cache$／`生成元~server$
］は
— 以下により除外されるときを除いて —
［
自身による通常の要請~検査を成功裡に遂行した後
］かつ［
要請~本体（もし在れば）を処理するか，`要請~method$に結付けられた動作を遂行する
］~~直前【いずれか早い方】に，受信した要請の`事前条件$を評価しなければナラナイ。
◎
Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request body (if any) or perform the action associated with the request method.＼
</p>

<p>
~serverは：
◎
＼</p>
<ul>
	<li>
<p>
次に該当する場合、受信したすべての`事前条件$を無視しなければナラナイ
⇒
当の要請が それらの条件を伴っていなかったとするとき、対する応答の`状態s~code$は
— 要請~本体の処理に先立って —
［
`2xx$st, `412$st
］以外になる
◎
A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request body, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).＼
</p>

<p>
言い換えれば，有意な処理が生じる前に検出された~redirectや失敗は、`事前条件$の評価よりも優先される。
◎
In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.
</p>
	</li>
	<li>
［
`~target資源$に対する`生成元~server$でない
］かつ［
`~target資源$に対する要請~用の`~cache$としても動作し得ない
］ならば、この仕様が定義する`条件付き要請~header$を評価してはナラナイ
— 要請を回送するときは、それらの~headerも回送しなければナラナイ。
そのような~headerを生成した~clientは、それを評価するのは，現在の`表現$を供せる~serverであることを意図しているので。
◎
A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation.＼
</li>
	<li>
`選定される表現$の［
選定, 改変
］を孕まない`要請~method$
— `CONNECT$m, `OPTIONS$m, `TRACE$m など —
に伴って受信した`条件付き要請~header$のうち，この仕様が定義するものは、無視しなければナラナイ。
◎
Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.
</li>
</ul>
</div>

<p>
~protocol拡張は、再検証を誘発し得る条件を改変し得ることに注意。
例えば， `immutable$sdir `~cache指令$ `RFC8246$r は、`新鮮$な応答の再検証を，~clientから要請されようが差控えるよう ~cacheに指図する。
◎
Note that protocol extensions can modify the conditions under which revalidation is triggered. For example, the "immutable" cache directive (defined by [RFC8246]) instructs caches to forgo revalidation of fresh responses even when requested by the client.
</p>

<p>
~HTTPに対する拡張により定義される`条件付き要請~header$は、［
すべての受信者 ／
一般的な`~target資源$の状態 ／
`資源$の~group
］に対し，条件を設置することもある。
一例として， WebDAV における `If$h ~headerは、［
`~lock$など，複数の資源の様々な側面
］に対し，要請を条件付きにし得る
— 受信者が その~fieldを解する, かつ実装するならば。
◎
Conditional request header fields that are defined by extensions to HTTP might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the "If" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([RFC4918], Section 10.4).
</p>

<p>
`条件付き要請~header$は，（ `HEAD$m, `GET$m の間で意味論の整合性を保つため）
`HEAD$m ~methodと伴用できるものと定義されるが、条件付き `HEAD$m を送信することに~~利点はない
— 何故なら，成功裡な応答は、
`304$st 応答と~~大体~同じ~sizeになり，
`412$st 応答よりも有用なので。
◎
Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response.
</p>

		</section>
		<section id="precedence">
<h3 title="Precedence">12.3. 優先順</h3>

<div class="p">
<p>
要請~内に`条件付き要請~header$が~~複数~在る場合、それらの~fieldが評価される順序が重要になる。
実施においては、この文書にて定義される各種~fieldは、次の~~理由から，一貫して［
ある単独の，論理的な順序
］で実装されている：
◎
When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since＼
</p>
<ul>
	<li>
“`更新喪失$” のための`事前条件$は、`~cache検証$よりも厳密な要件を備える。
◎
"lost update" preconditions have more strict requirements than cache validation,＼
</li>
	<li>
検証された~cacheは、`部分的な応答$よりも効率的である。
◎
a validated cache is more efficient than a partial response, and＼
</li>
	<li>
`entity-tag$p は、日時~検証子よりも正確aと~~見做されている。
◎
entity tags are presumed to be more accurate than date validators.
</li>
</ul>
</div>

<p>
受信者である［
`~cache$／`生成元~server$
］は、要請における［
この仕様にて定義される各種`事前条件$
］を，次の順序で評価しなければナラナイ：
◎
A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order:
</p>

<p class="trans-note">【
以下における “応答する” は、そこで評価~~手続きを終えることも意味する。
】</p>
<ol>
	<li>
<p>
次がすべて満たされるならば…
</p>
		<ul>
			<li>
受信者は`生成元~server$である
</li>
			<li>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li>
要請に `If-Match$h が在って，その事前条件は偽に評価される

</li>
					<li>
要請に `If-Match$h は無い, かつ［
要請に `If-Unmodified-Since$h が在って，その事前条件は偽に評価される
］
</li>
				</ul>
			<li>
次に該当しない
⇒
要請は状態変更~methodであって，すでに成功したものと決定できた（詳細は前項の各~fieldの記述を見よ）
</li>
		</ul>
<p>
…ならば
⇒
`412$st で応答する
</p>

◎
When recipient is the origin server and If-Match is present, evaluate the If-Match precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 12.1.1)
◎
When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 12.1.4)
</li>
	<li>
<p>
要請の~methodに応じて：
</p>
		<dl class="switch">
			<dt>`GET$m</dt>
			<dt>`HEAD$m</dt>
			<dd>
<p>
次のいずれかが満たされるならば…：
</p>
				<ul>
					<li>
要請に `If-None-Match$h が在って，その事前条件は偽に評価される
</li>
					<li>
要請に `If-None-Match$h は無い, かつ［
要請に `If-Modified-Since$h が在って，その事前条件は偽に評価される
］
</li>
				</ul>
<p>
…ならば
⇒
`304$st で応答する
</p>

			</dd>
			<dt>その他</dt>
			<dd>
要請に `If-None-Match$h が在って，その事前条件は偽に評価されるならば
⇒
`412$st で応答する
</dd>
		</dl>

◎
When If-None-Match is present, evaluate the If-None-Match precondition:
• if true, continue to step 5
• if false for GET/HEAD, respond 304 (Not Modified)
• if false for other methods, respond 412 (Precondition Failed)
◎
When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition:
• if true, continue to step 5
• if false, respond 304 (Not Modified)
</li>
	<li>
<p>
次がすべて満たされるならば…：
</p>
				<ul>
					<li>
~methodは `GET$m である
</li>
					<li>
`Range$h, `If-Range$h ともに在る
</li>
					<li>
`If-Range$h 事前条件を評価したとき，検証子が合致する
</li>
					<li>
`Range$h 指定は`選定された表現$に適用-可能である
</li>
				</ul>
<p>
…ならば
⇒
`206$st で応答する
</p>

◎
When the method is GET and both Range and If-Range are present, evaluate the If-Range precondition:
• if the validator matches and the Range specification is applicable to the selected representation, respond 206 (Partial Content)
</li>
	<li>
すべての条件は満たされたので、要請された動作を遂行した上で，その成功／失敗に則って応答する。
◎
Otherwise,
• all conditions are met, so perform the requested action and respond according to its success or failure.
</li>
</ol>

<p>
~HTTPに対する拡張は、追加的な`条件付き要請~header$を定義するならば，
そのような~fieldと他の`条件付き要請~header$
— この文書にて定義されるものに加え、実施において見出され得る他のそれも含む —
を評価する順序に関する自前の期待を定義する~OUGHT。
◎
Any extension to HTTP that defines additional conditional request header fields ought to define its own expectations regarding the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.
</p>

		</section>
	</section>
	<section id="range.requests">
<h2 title="Range Requests">13. 範囲~要請</h2>

<p>
`~client$は、［
要請が取消された／接続が落とされた
］結果，~data転送の中断に遭遇することはよくある。
~clientが`部分的$な`表現$を格納したときは、後続の要請にて，
表現~~全体を転送するのでなく，その表現の残り~~部分を要請することが望ましい。
同様に，局所的な~storageが制限されている機器は、より大きい`表現$の下位集合のみを要請できることで便益を得ることもある
— 巨大な文書の単独の~pageや, 様々な~~断片による埋込d画像としてなど。
◎
Clients often encounter interrupted data transfers as a result of canceled requests or dropped connections. When a client has stored a partial representation, it is desirable to request the remainder of that representation in a subsequent request rather than transfer the entire representation. Likewise, devices with limited local storage might benefit from being able to request only a subset of a larger representation, such as a single page of a very large document, or the dimensions of an embedded image.
</p>

<p>
`範囲~要請$は，~HTTPの`任意選択^2119な特能であり、この特能を実装していない（または，`~target資源$に対しては~supportしていない）`受信者$が，相互運用能に影響iすることなく，それが通常の `GET$m 要請であったかのように応答できるように設計されている。
対する`部分的な応答$は、この特能を実装しないかもしれない`~cache$から
全部的な応答に誤解されないように，別個な`状態s~code$で指示される。
◎
Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability. Partial responses are indicated by a distinct status code to not be mistaken for full responses by caches that might not implement the feature.
</p>

		<section id="range.units">
<h3 title="Range Units">13.1. 範囲~単位</h3>

<p>
`表現~data$は、
`範囲~単位@
（ `range-unit$p ）
— その~dataの［
`内容~符号法$／`~MIME型$
］に内来的な，~address可能な構造上の単位 —
があるときには、部分範囲に区分できる。
例えば，~octet（すなわち，~byte）境界は、すべての`表現~data$に共通な構造上の単位であり，~dataを成す一~区分-が［
~dataの始端／終端からの~offsetによる範囲を成す~byte列
］として識別されることを許容する。
◎
Representation data can be partitioned into subranges when there are addressable structural units inherent to that data's content coding or media type. For example, octet (a.k.a., byte) boundaries are a structural unit common to all representation data, allowing partitions of the data to be identified as a range of bytes at some offset from the start or end of that data.
</p>

<p>
この一般的な`範囲~単位$の観念は、次のために利用される：
◎
This general notion of a "range unit" is used in＼
</p>
<ul>
	<li>
`Accept-Ranges$h 応答~header内にて，`範囲~要請$の~supportを広告する。
◎
the Accept-Ranges (Section 13.3) response header field to advertise support for range requests,＼
</li>
	<li>
`Range$h 要請~header内にて，要請される`表現$の各~部位tが占める範囲を~~精確に~~述べる。
◎
the Range (Section 13.2) request header field to delineate the parts of a representation that are requested, and＼
</li>
	<li>
`Content-Range$h `~payload~header$内にて，`表現$のどの部位tが転送されているかを述べる。
◎
the Content-Range (Section 13.4) payload header field to describe which part of a representation is being transferred.
</li>
</ul>

<pre class="bnf">
`range-unit@p
    = `token$p
</pre>

<p>
すべての`範囲~単位$は文字大小無視であり、
`15.5.1$sec に定義される
`~HTTP範囲~単位~registry$cite
の中に登録される~OUGHT。
◎
All range unit names are case-insensitive and ought to be registered within the "HTTP Range Unit Registry", as defined in Section 15.5.1
</p>

<p>
`範囲~単位$は、
`15.5$sec に述べるように，拡張-可能になるものと意図されている。
この文書では、次の範囲~単位~名が定義される：
◎
Range units are intended to be extensible, as described in Section 15.5. The following range unit names are defined by this document:
</p>

<div>
<dl>
	<dt>`bytes@c</dt>
	<dd>
~octet列の範囲
— `~byte範囲$ —
を与える
</dd>

	<dt>`none@c</dt>
	<dd>
範囲~要請は~supportされないことを指示する~keywordとして予約される（ `Accept-Ranges$h を見よ）。
</dd>
</dl>
◎
Table 13
Range Unit Name 	Description 	Ref.

bytes 	a range of octets 	13.1.2
none 	reserved as keyword to indicate range requests are not supported 	13.3
</div>

			<section id="range.specifiers">
<h4 title="Range Specifiers">13.1.1. 範囲~指定子</h4>


<p>
範囲は、範囲~指定子（ `range-spec$p ）の集合（ `range-set$p ）, それと~pairにされた`範囲~単位$の用語で表出される。
範囲~単位を成す名前は、［
自前の指定子において，どの種類の `range-spec$p が適用-可能になるか
］を決定する。
よって，次に与える文法は汎用である
— 各~範囲~単位は、［
`int-range$p,
`suffix-range$p,
`other-range$p
］がいつ許容されるかに関する要件を指定するものと期待される。
◎
Ranges are expressed in terms of a range unit paired with a set of range specifiers. The range unit name determines what kinds of range-spec are applicable to its own specifiers. Hence, the following gramar is generic: each range unit is expected to specify requirements on when int-range, suffix-range, and other-range are allowed.
</p>

<p id="rule.ranges-specifier">
`範囲~要請$は、［
単独の表現の中の， 1 個以上の範囲が成す集合
］を指定できる。
◎
A range request can specify a single range or a set of ranges within a single representation.
</p>

<pre class="bnf">
`ranges-specifier@p
    = `range-unit$p "=" `range-set$p
`range-set@p
    = 1#`range-spec$p
`range-spec@p
    = `int-range$p
    / `suffix-range$p
    / `other-range$p
</pre>

<p id="rule.int-range">
`int-range$p は、範囲を［
2 個の負でない整数
］または［
1 個の負でない整数から`表現~data$の終端まで
］として表出する。
`範囲~単位$は、これらの整数が何を意味するかを指定する（例：
先頭からの単位~offset,
その~offsetも範囲に含まれるかどうか,
等々を指示することもあろう）。
◎
An int-range is a range expressed as two non-negative integers or as one non-negative integer through to the end of the representation data. The range unit specifies what the integers mean (e.g., they might indicate unit offsets from the beginning, inclusive numbered parts, etc.).
</p>

<pre class="bnf">
`int-range@p
    = `first-pos$p "-" [ `last-pos$p ]
`first-pos@p
    = 1*`DIGIT$P
`last-pos@p
    = 1*`DIGIT$P
</pre>

<p>
`int-range$p は、［
`last-pos$p 値が在って, その値は `first-pos$p 未満である
］ならば，妥当でない。
◎
An int-range is invalid if the last-pos value is present and less than the first-pos.
</p>

<p id="rule.suffix-range">
`suffix-range$p は、`表現~data$の~~尾部を［
供された負でない（`範囲~単位$による）整数による最大~長さ
］で表出する範囲である。
言い換えれば、表現~dataを成す最後から `N^V 個の単位を表す。
◎
A suffix-range is a range expressed as a suffix of the representation data with the provided non-negative integer maximum length (in range units). In other words, the last N units of the representation data.
</p>

<pre class="bnf">
`suffix-range@p
    = "-" `suffix-length$p
`suffix-length@p
    = 1*`DIGIT$P
</pre>

<p id="rule.other-range">
`other-range$p 規則の文法は、ほぼ拘束されない
— 次を許容する拡張能を供するためにあるので
⇒＃
応用に特有な`範囲~単位$／
追加的な範囲~指定子を定義する将来の`範囲~単位$
◎
To provide for extensibility, the other-range rule is a mostly unconstrained grammar that allows application-specific or future range units to define additional range specifiers.
</p>

<pre class="bnf">
`other-range@p
    = 1*( `21-2B^X / `2D-7E^X )
    ; 1*(<span class="comment" title="VCHAR excluding comma">~comma以外の `VCHAR$P</span>)
</pre>

			</section>
			<section id="byte.ranges">
<h4 title="Byte Ranges">13.1.2. ~byte範囲</h4>

<p>
`範囲~単位$ "`bytes$c" は、
`~byte範囲@
— `表現~data$の~octet列を成す部分範囲 —
を表出するために利用される。
各~byte範囲は、`表現~data$の［
先頭から ( `int-range$p ）または終端から ( `suffix-range$p ）
］の，ある~offsetを指す整数~範囲として表出される。
~byte範囲は `other-range$p 指定子を利用しない。
◎
The "bytes" range unit is used to express subranges of a representation data's octet sequence. Each byte range is expressed as an integer range at some offset, relative to either the beginning (int-range) or end (suffix-range) of the representation data. Byte ranges do not use the other-range specifier.
</p>

<p>
`bytes$c における `int-range$p を成す［
`first-pos$p 値, `last-pos$p 値
］は、順に，範囲の［
最初の~offset, 最後の~offset
］を 0 から数えた~byte数で与える。
すなわち、指定された~byte~~位置は範囲に含まれ， "`0^c" は先頭~byteを~~指す。
◎
The first-pos value in a bytes int-range gives the offset of the first byte in a range. The last-pos value gives the offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.
</p>

<p>
`表現~data$に`内容~符号法$が適用されている場合、各~byte範囲は，符号化された~byte列を~~基準に計算される
— 復号して得される下層の~byte列ではなく。
◎
If the representation data has a content coding applied, each byte range is calculated with respect to the encoded sequence of bytes, not the sequence of underlying bytes that would be obtained after decoding.
</p>

<div class="example">
<p>
~byte範囲~指定子の例：
◎
Examples of bytes range specifiers:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte（ 0 〜 499 番の~byte （ 0 番が先頭~byte — 以下同様））：
◎
The first 500 bytes (byte offsets 0-499, inclusive):
</p>

<pre>
bytes=0-499
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte（ 500 〜 999 番の~byte）：
◎
The second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-999
</pre>
	</li>
</ul>
</div>

<p>
`~client$は、`選定される表現$の~sizeを知ることなく，要請される~byte数を制限できる。
［
`last-pos$p 値が無い, または，その値が`表現~data$の現在の長さ以上
］の場合の`~byte範囲$は、`表現$の `first-pos$p 以降の~~部分として解釈される（すなわち，`~server$は、 `last-pos$p の値を
( `選定された表現$の現在の長さ − 1 )
に置換する）。
◎
A client can limit the number of bytes requested without knowing the size of the selected representation. If the last-pos value is absent, or if the value is greater than or equal to the current length of the representation data, the byte range is interpreted as the remainder of the representation (i.e., the server replaces the value of last-pos with a value that is one less than the current length of the selected representation).
</p>

<p id="rule.ranges-specifier.suffix">
`suffix-range$p を利用すれば、`~client$は，`選定される表現$の最後の `N^V ~byte（ `N^V ~GT 0 ）を要請できる：
`選定された表現$が，指定された `suffix-length$p より短い場合、`表現$~~全体が利用される。
◎
A client can request the last N bytes (N > 0) of the selected representation using a suffix-range. If the selected representation is shorter than the specified suffix-length, the entire representation is used.
</p>

<div class="example">
<p>
例 — ここでは，表現の長さは 10000 であるものと見做す：
◎
Additional examples, assuming a representation of length 10000:
</p>
<ul>
	<li>
<p>
最後の 500 ~byte（ 9500 〜 9999 番の~byte）：
◎
The final 500 bytes (byte offsets 9500-9999, inclusive):
</p>

<pre>
bytes=-500
</pre>

<p>
または
◎
Or:
</p>

<pre>
bytes=9500-
</pre>

</li>
	<li>
<p>
［
最初, 最後
］の~byteのみ（ 0 番, 9999 番の~byte）：
◎
The first and last bytes only (bytes 0 and 9999):
</p>

<pre>
bytes=0-0,-1
</pre>
【！ Errata ID: 4472 Rejected】

	</li>
	<li>
<p>
［
最初, 真中, 最後
］の 1000 ~byte
◎
The first, middle, and last 1000 bytes:
</p>

<pre>
bytes= 0-999, 4500-5499, -1000
</pre>

	</li>
	<li>
<p>
妥当である（が，正準的でない）， 2 番目の 500 ~byte（ 500 〜 999 番の~byte）の指定：
◎
Other valid (but not canonical) specifications of the second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-600,601-999
bytes=500-700,601-999
</pre>
	</li>
</ul>
</div>

<div class="p">
<p>
`bytes$c における `range-set$p は、妥当かつ［
それを成す ある `range-spec$p は次のいずれかを満たす
］ときに限り，`満足可能$とされる：
</p>
<ul>
	<li>
`int-range$p であって，それを成す `first-pos$p は`表現$の現在の長さ未満である
</li>
	<li>
`suffix-range$p であって，それを成す `suffix-length$p は 0 でない
</li>
</ul>
◎
If a valid bytes range-set includes at least one range-spec with a first-pos that is less than the current length of the representation, or at least one suffix-range with a non-zero suffix-length, then the bytes range-set is satisfiable. Otherwise, the bytes range-set is unsatisfiable.
</div>

<p>
`選定された表現$の長さが 0 の場合、`満足可能$な形をとる `range-spec$p は，上の後者に限られる。
◎
If the selected representation has zero length, the only satisfiable form of range-spec is a suffix-range with a non-zero suffix-length.
</p>

<p>
~byte範囲 構文における［
`first-pos$p,
`last-pos$p,
`suffix-length$p
］は、~octet数を 10 進~数で表出する。
`~payload$の長さには定義済み上限は無いので、`受信者$は，［
~decimal数字列が巨大になり得ること, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防がなければナラナイ。
◎
In the byte-range syntax, first-pos, last-pos, and suffix-length are expressed as decimal number of octets. Since there is no predefined limit to the length of a payload, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.
</p>

			</section>
		</section>
		<section id="field.range">
<h3>13.2. `Range^h</h3>

<p>
`GET$m 要請~上の `Range^h ~headerは、当の要請を
`範囲~要請@
にするよう
— `選定された表現$全体ではなく，その`表現~data$を成す 1 個~以上の部分範囲に限り転送を要請するよう —
~method意味論を改変する。
◎
The "Range" header field on a GET request modifies the method semantics to request transfer of only one or more subranges of the selected representation data (Section 7.2), rather than the entire selected representation.
</p>

<pre class="bnf">
`Range@p
    = `ranges-specifier$p
</pre>

<p>
`~server$は、 `Range^h ~headerを無視してもヨイ。
しかしながら，［
`生成元~server$／中継~cache
］は、アリなときは`~byte範囲$を~supportする~OUGHT
— `Range^h は［
部分的に失敗した転送の効率的な回復や,
巨大な`表現$の部分的な検索取得
］を~supportするので。
`~server$は、［
`GET$m 以外の`要請~method$に伴って受信された `Range^h ~header
］は無視しなければナラナイ。
◎
A server MAY ignore the Range header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since they support efficient recovery from partially failed transfers and partial retrieval of large representations. A server MUST ignore a Range header field received with a request method other than GET.
</p>

<p>
`生成元~server$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を無視しなければナラナイ。
`~proxy$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を破棄してもヨイ。
◎
An origin server MUST ignore a Range header field that contains a range unit it does not understand. A proxy MAY discard a Range header field that contains a range unit it does not understand.
</p>

<p>
範囲~要請を~supportする`~server$は、［
他と†重合する範囲が 3 個~以上ある, あるいは
昇順による順序で~listされていない 多数の小~範囲の集合
］からなる
`Range^h ~headerを無視-または却下してもヨイ
— いずれも，壊れた~client, あるいは故意による~DoS攻撃（ `16.14$sec ）を指示するので。
`~client$は、処理nや転送が，同じ~dataを包摂する単独の範囲より内来的に非~効率的な，複数の範囲を要請するベキでない。
【†おそらく。 3 箇所~以上で重合する／同じ箇所に重合する範囲が 3 個~以上、などの解釈も考えられなくはないが。】
◎
A server that supports range requests MAY ignore or reject a Range header field that consists of more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since both are indications of either a broken client or a deliberate denial-of-service attack (Section 16.14). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.
</p>

<p>
範囲~要請を~supportする~serverは、`選定された表現$に本体が無いときには（すなわち，その表現~dataの長さは 0 ），
`Range^h ~headerを無視してもヨイ。
◎
A server that supports range requests MAY ignore a Range header field when the selected representation has no body (i.e., the selected representation data is of zero length).
</p>

<p>
複数の範囲を要請する`~client$は、それらの範囲を昇順による順序で~listするベキである（概して，完全な`表現$~内にそれらが受信されることになる順序で）
— 後側の部位tをより早期に要請する必要が特にない限り。
例えば，［
一連の部位tについての内部~目録を伴う，巨大な`表現$
］を処理している~UAは、後側の部位tを最初に要請することも必要になり得る
— 特に，`表現$が逆~順序で格納されている~pageからなっていて，~UAが一度に 1 ~pageの転送を望む場合には。
◎
A client that is requesting multiple ranges SHOULD list those ranges in ascending order (the order in which they would typically be received in a complete representation) unless there is a specific need to request a later part earlier. For example, a user agent processing a large representation with an internal catalog of parts might need to request later parts first, particularly if the representation consists of pages stored in reverse order and the user agent wishes to transfer one page at a time.
</p>

<p>
`Range^h ~headerが評価されるのは、`事前条件~header$を評価した後であり，［
`Range^h ~headerが無いときの結果が `200$st 応答になる
］場合に限られる。
言い換えれば、条件付き `GET$m の結果が `304$st 応答になる場合には，範囲は無視される。
◎
The Range header field is evaluated after evaluating the precondition header fields defined in Section 12.1, and only if the result in absence of the Range header field would be a 200 (OK) response. In other words, Range is ignored when a conditional GET would result in a 304 (Not Modified) response.
</p>

<p>
`If-Range$h ~headerを， `Range^h ~headerを適用する際の`事前条件$として利用できる。
◎
The If-Range header field (Section 12.1.5) can be used as a precondition to applying the Range header field.
</p>

<p>
`~server$は、すべての`事前条件$は真に評価され, かつ
`~target資源$に対する `Range^h ~headerを~supportする場合には：
◎
↓</p>
<ul>
	<li>
指定された範囲（たち）が妥当かつ`満足可能$な場合、次を包含する~payloadを伴う `206$st 応答を送信するベキである
⇒
［
要請された範囲のうち，`満足可能$なもの
］に対応する， 1 個~以上の部分的な表現
◎
If all of the preconditions are true, the server supports the Range header field for the target resource, and the specified range(s) are valid and satisfiable (as defined in Section 13.1.2), the server SHOULD send a 206 (Partial Content) response with a payload containing one or more partial representations that correspond to the satisfiable ranges requested.
</li>
	<li>
他の場合、 `416$st 応答を送信するベキである。
◎
If all of the preconditions are true, the server supports the Range header field for the target resource, and the specified range(s) are invalid or unsatisfiable, the server SHOULD send a 416 (Range Not Satisfiable) response.
</li>
</ul>

【！ Errata ID: 4665 Rejected: 2017-02-23】

		</section>
		<section id="field.accept-ranges">
<h3>13.3. `Accept-Ranges^h</h3>

<p>
`Accept-Ranges$h ~headerにより、`~server$は，［
`~target資源$に対する`範囲~要請$を~supportする
］ことを指示できるようになる。
◎
The "Accept-Ranges" header field allows a server to indicate that it supports range requests for the target resource.
</p>

<pre class="bnf">
`Accept-Ranges@p
    = `acceptable-ranges$p
`acceptable-ranges@p
    = 1#`range-unit$p
    / "`none$c"
</pre>

<p>
`生成元~server$は、所与の`~target資源$に対する`~byte範囲$の要請を~supportするならば、~supportする`範囲~単位$を指示するために，次を送信してもヨイ：
◎
An origin server that supports byte-range requests for a given target resource MAY send
</p>

<pre class="lang-http">
Accept-Ranges: bytes
</pre>

<p>
`~client$は、この~headerを受信していなくても，当の資源に対し `範囲~要請$を`生成し$てもヨイ。
◎
to indicate what range units are supported. A client MAY generate range requests without having received this header field for the resource involved. Range units are defined in Section 13.1.
</p>

<p>
`~target資源$に対し，いかなる`範囲~要請$も~supportしない`~server$は、
"`none@c"
を送信してもヨイ：
◎
A server that does not support any kind of range request for the target resource MAY send
</p>

<pre class="lang-http">
Accept-Ranges: none
</pre>

<p>
これは、範囲~要請を試みないよう，~clientに通告する。
◎
to advise the client not to attempt a range request.
</p>

		</section>
		<section id="field.content-range">
<h3>13.4. `Content-Range^h</h3>

<div class="p">
<p>
`Content-Range^h ~headerは、次を
指示する／供する
ために送信される：
◎
The "Content-Range" header field is＼
</p>
<ul>
	<li>
単独の部位tによる `206$st 応答において
⇒
その`~message~payload$として同封された［
`選定された表現$の部分的な範囲
］を指示する。
◎
sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message payload,＼
</li>
	<li>
`複部位$ `206$st 応答の各~部位tにおいて
⇒
各~本体~部位t内に同封された範囲を指示する。
◎
sent in each part of a multipart 206 response to indicate the range enclosed within each body part, and＼
</li>
	<li>
`416$st 応答において
⇒
`選定された表現$についての情報を供する。
◎
sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Range@p
    = `range-unit$p `SP$P ( `range-resp$p / `unsatisfied-range$p )

`range-resp@p
    = `incl-range$p "/" ( `complete-length$p / "*" )
`incl-range@p
    = `first-pos$p "-" `last-pos$p
`unsatisfied-range@p
    = "*/" `complete-length$p

`complete-length@p
    = 1*`DIGIT$P
</pre>

<p>
`受信者$は、［
自身が解さない`範囲~単位$を伴う `Content-Range^h ~header
］を包含する`206$st 応答に対しては，それを格納-済み表現と結合し直そうと試みてはナラナイ。
その種の~messageを受信した`~proxy$は、それを`下流$へ回送するベキである。
◎
If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 13.1) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation. A proxy that receives such a message SHOULD forward it downstream.
</p>

<p>
`~byte範囲$に対しては、`送信者$は，［
抽出された範囲の表現
］の完全な長さを指示するベキである
— その長さが未知, または それを決定するのが困難である場合は除き。
`range-resp$p における，
`complete-length$p に代わる ~asterisk （ "`*^c" ）は、［
この~headerが生成されたとき，表現の長さが未知であった
］ことを指示する。
◎
For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character ("*") in place of the complete-length indicates that the representation length was unknown when the header field was generated.
</p>

<div class="example">
<p>
`選定される表現$の完全な長さが 1234 ~byteであることが，`送信者$に既知であるときの例：
◎
The following example illustrates when the complete length of the selected representation is known by the sender to be 1234 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/1234
</pre>

<p>
完全な長さが未知であるときの例：
◎
and this second example illustrates when the complete length is unknown:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/*
</pre>
</div>

<p>
`Content-Range^h の`~field値$は、それが包含する `range-resp$p が次を満たす場合には，妥当でない
⇒
［
`last-pos$p 値 ~LT `first-pos$p 値
］または［
`complete-length$p 値 ~LTE `last-pos$p 値
］
◎
A Content-Range field value is invalid if it contains a range-resp that has a last-pos value less than its first-pos value, or a complete-length value less than or equal to its last-pos value.＼
</p>

<p>
妥当でない `Content-Range^h の`受信者$は、受信した内容と格納-済みな表現を結合し直そうと試みてはナラナイ。
◎
The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.
</p>

<p>
`~server$は、`~byte範囲$の要請に対し `416$st 応答を`生成する$ときには，［
`unsatisfied-range$p 値を伴う `Content-Range^h ~header
］を送信するベキである
— 次の例のように：
◎
A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:
</p>

<div class="example">
<pre class="lang-http">
Content-Range: bytes */1234
</pre>
</div>

<p>
`416$st 応答~内の `complete-length$p は、`選定された表現$の現在の長さを指示する。
◎
The complete-length in a 416 response indicates the current length of the selected representation.
</p>

<p>
`Content-Range^h ~headerは、その意味論を明示的に述べない`状態s~code$に対しては，意味を持たない。
この仕様においては、次に挙げる`状態s~code$に限り，
`Content-Range^h 用の意味を述べる
⇒＃
`206$st,
`416$st
◎
The Content-Range header field has no meaning for status codes that do not explicitly describe its semantic. For this specification, only the 206 (Partial Content) and 416 (Range Not Satisfiable) status codes describe a meaning for Content-Range.
</p>

<div class="example">
<p>
`選定された表現$が総計 1234 ~byteを包含するときの， `Content-Range^h 値の例：
◎
The following are examples of Content-Range values in which the selected representation contains a total of 1234 bytes:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte:
◎
The first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 0-499/1234
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte：
◎
The second 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-999/1234
</pre>
	</li>
	<li>
<p>
最初の 500 ~byteを除くすべて：
◎
All except for the first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-1233/1234
</pre>
	</li>
	<li>
<p>
最後の 500 ~byte：
◎
The last 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 734-1233/1234
</pre>
	</li>
</ul>
</div>

		</section>
		<section id="multipart.byteranges">
<h3 title="Media Type multipart/byteranges">13.5. ~MIME型 "`multipart/byteranges^c"</h3>

<p>
`206$st 応答~messageが，複数の範囲からなる内容を内包するとき、それらの内容は，~MIME型
"`multipart/byteranges^c"
による
`複部位@
`~message本体$の中に，いくつかの本体~部位tとして伝送される（ `RFC2046/5.1$sec ）。
◎
When a 206 (Partial Content) response message includes the content of multiple ranges, they are transmitted as body parts in a multipart message body ([RFC2046], Section 5.1) with the media type of "multipart/byteranges".
</p>

<p>
~MIME型 "`multipart/byteranges^c" は、それぞれが自前の［
`Content-Type$h, `Content-Range$h
］~fieldを伴う， 1 個~以上の本体~部位tを内包する。
要求される境界~parameter（ `boundary parameter^en ）は、各~本体~部位tを分離するために利用される境界~文字列（ `boundary string^en ）を指定する。
◎
The multipart/byteranges media type includes one or more body parts, each with its own Content-Type and Content-Range fields. The required boundary parameter specifies the boundary string used to separate each body part.
</p>

<p>
実装~上の注記：
◎
Implementation Notes:
</p>
<ul>
	<li>
余分な `CRLF$P が本体~内の最初の境界~文字列に先行するかもしれない。
◎
Additional CRLFs might precede the first boundary string in the body.
</li>
	<li>
<p>
`RFC2046$r は，境界~文字列（ `boundary string^en †）を引用符で括ることも許可しているが、一部の既存の実装は，そのようにされた境界~文字列を不正に取扱う。
◎
Although [RFC2046] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
</p>

<p class="trans-note">【†
`RFC2046$r では “`boundary delimiter^en” と称されている。
下の例では `THIS_STRING_SEPARATES^c がそれに該当する。
】</p>
	</li>
	<li>
いくつもの［
~client／~server
］が， byteranges 仕様の早期の草案に合わせて~codeされており，
その~MIME型に `multipart/x-byteranges^c を利用していた
— それは、この型にほぼ互換である（が，~~完全にではない）。
◎
A number of clients and servers were coded to an early draft of the byteranges specification that used a media type of multipart/x-byteranges, which is almost (but not quite) compatible with this type.
</li>
</ul>

<p>
その名前にかかわらず、
"`multipart/byteranges$c" ~MIME型は，`~byte範囲$に制限されない。
◎
Despite the name, the "multipart/byteranges" media type is not limited to byte ranges.＼
</p>

<div class="example">
<p>
次の例は、 "`exampleunit^c" `範囲~単位$を利用する：
◎
The following example uses an "exampleunit" range unit:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
次の情報が、
`multipart/byteranges$c ~MIME型~用の登録~形として~serveする。
◎
The following information serves as the registration form for the multipart/byteranges media type.
</p>

<div>

<dl>
<dt>型~名
<dd>`multipart^c

<dt>下位型~名
<dd>`byteranges^c

<dt>要求される~parameter
<dd>`boundary^c

<dt>省略可能な~parameter
<dd>N/A

<dt>符号化法に対する考慮点
<dd>"`7bit^c", "`8bit^c", "`binary^c" のみ許可される

<dt>~securityの考慮点
<dd>`16$sec を見よ

<dt>相互運用能の考慮点
<dd>N/A

<dt>発行した仕様
<dd>この仕様（ `multipart/byteranges$c を見よ）

<dt>この~MIME型を利用する応用
<dd>単独の要請~内に複数の範囲を~supportする， HTTP ~component

<dt>素片~識別子に対する考慮点
<dd>N/A

<dt>追加的な情報
<dd>
	<dl>
	<dt>Deprecated alias names for this type:
	<dt>Magic number(s):
	<dt>File extension(s):
	<dt>Macintosh file type code(s):
	<dd>N/A
	</dl>

<dt>Person and email address to contact for further information:
<dd>`著作者の~address$に。

<dt>意図される用法
<dd>COMMON

<dt>用法~上の制約
<dd>N/A

<dt>著作者
<dd>`著作者の~address$に。

<dt>変更管理者
<dd>IESG
</dl>

◎
Type name:
• multipart
Subtype name:
• byteranges
Required parameters:
• boundary
Optional parameters:
• N/A
Encoding considerations:
• only "7bit", "8bit", or "binary" are permitted
Security considerations:
• see Section 16
Interoperability considerations:
• N/A
Published specification:
• This specification (see Section 13.5). 
Applications that use this media type:
• HTTP components supporting multiple ranges in a single request.
Fragment identifier considerations:
• N/A
Additional information:
• Deprecated alias names for this type:
•• N/A
• Magic number(s):
•• N/A
• File extension(s):
•• N/A
• Macintosh file type code(s):
•• N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

		</section>
	</section>
	<section id="status.codes">
<h2 title="Status Codes">14. 状態s~code</h2>

<p>
（応答の）
`状態s~code@
（ `status-code$p ）は、 3 桁の整数~codeであり，［
要請を解して それを満足しようと試みた結果
］を与える。
◎
The (response) status code is a three-digit integer code giving the result of the attempt to understand and satisfy the request.
</p>

<p>
~HTTP状態s~codeは、拡張できる。
~HTTP`~client$には、［
登録-済みな状態s~codeすべての意味を解する
］ことは要求されない
— もちろん、解する方が望ましいが。
しかしながら，`~client$は、［
最初の桁により指示される，どの［
状態s~codeの`応答class$
］］に対しても，それを解した上で，認識できない状態s~codeを［
その`応答class$の状態s~code `x00^st0 に等価である
］ものとして，扱わなければナラナイ。
◎
HTTP status codes are extensible. HTTP clients are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, a client MUST understand the class of any status code, as indicated by the first digit, and treat an unrecognized status code as being equivalent to the x00 status code of that class.
</p>

<p>
例えば，`~client$が［
認識できない状態s~code `471^st0
］を受信したときは、［
その要請に何か~~間違いがある
］ものと見做した上で，［
応答を `400$st を受信したかのように扱う
］ことができる。
応答~messageは、通例的に，その状態sを説明する`表現$を包含することになる。
◎
For example, if an unrecognized status code of 471 is received by a client, the client can assume that there was something wrong with its request and treat the response as if it had received a 400 (Bad Request) status code. The response message will usually contain a representation that explains the status.
</p>

<p>
`状態s~code$の最初の桁は、応答の
`応答class@
を定義する。
下位 2 桁には、分類上の役割はない。
`応答class$には、次に挙げる 5 種がある：
◎
The first digit of the status code defines the class of response. The last two digits do not have any categorization role. There are five values for the first digit:
</p>

<dl>
	<dt>`1xx$st</dt>
	<dd>
要請は受信され、その処理nは継続-中にある。
◎
The request was received, continuing process
</dd>

	<dt>`2xx$st</dt>
	<dd>
要請は、成功裡に［
受信され,
解され,
受容された
］。
◎
The request was successfully received, understood, and accepted
</dd>

	<dt>`3xx$st</dt>
	<dd>
要請を完了するためには、更なる動作がとられる必要がある。
◎
Further action needs to be taken in order to complete the request
</dd>

	<dt>`4xx$st</dt>
	<dd>
要請は、不良な構文を包含しているか, または履行できない。
◎
The request contains bad syntax or cannot be fulfilled
</dd>

	<dt>`5xx$st</dt>
	<dd>
要請は ~~見かけ上は妥当であるが、`~server$はその履行-に失敗した。
◎
The server failed to fulfill an apparently valid request
</dd>
</dl>

<p id="final-interim">
同じ要請に対しては、複数個の応答
— 0 個以上の`暫定-応答$, それらに後続する 1 個の`最終-応答$ —
が結付けられ得る。
`応答class$ `1xx$st に属する応答は，
`暫定-応答@
（ `interim response^en ）とされ、他の`応答class$に属する応答は，
`最終-応答@
（ `final response^en ）とされる。
◎
A single request can have multiple associated responses: zero or more interim (non-final) responses with status codes in the "informational" (1xx) range, followed by exactly one final response with a status code in one of the other ranges.
</p>

		<section id="overview.of.status.codes">
<h3 title="Overview of Status Codes">14.1. 状態s~codeの概観</h3>

<p>
下に挙げる`状態s~code$は、この仕様にて定義される。
括弧内に挙げる各種
`事由~句@
（ `reason-phrase$p ）は、推奨に過ぎない
— それらは、~protocolに影響することなく，局所的な等価~物に置換できる。
◎
The status codes listed below are defined in this specification. The reason phrases listed here are only recommendations — they can be replaced by local equivalents without affecting the protocol.
</p>

<p>
`経験的に~cache可能$であるものと定義されている状態s~code（例： この仕様では
`200$st0,
`203$st0,
`204$st0,
`206$st0,
`300$st0,
`301$st0,
`308$st0,
`404$st0,
`405$st0,
`410$st0,
`414$st0,
`501$st0
）を伴う応答は、［
~method定義／明示的な~cache制御
］から他が指示されない限り，［
経験的な失効を伴う~cache
］により再利用できる（ `Caching/4.2.2$sec ）。
他のすべての状態s~codeは、`経験的に~cache可能$でない。
◎
Responses with status codes that are defined as heuristically cacheable (e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [Caching]; all other status codes are not heuristically cacheable.
</p>

<p>
この仕様の視野から外れる追加的な`状態s~code$も，~HTTPにおける利用~用に指定されている。
そのような状態s~codeは，すべて、
`15.2$sec に述べるとおりに，
`~HTTP状態s~code~registry$cite
の中に登録される~OUGHT。
◎
Additional status codes, outside the scope of this specification, have been specified for use in HTTP. All such status codes ought to be registered within the "Hypertext Transfer Protocol (HTTP) Status Code Registry", as described in Section 15.2.
</p>

		</section>
		<section id="status.1xx">
<h3 title="Informational 1xx">14.2. `1xx^st</h3>

<p>
`応答class$ `1xx^st に属する`状態s~code$は、`暫定-応答$を指示する
— すなわち、［
要請された動作, および
その`最終-応答$の送信
］を完了するに先立って，［
通信-中の接続~状態sや, 要請の進捗状況
］を~~伝えるためにある。
`1xx^st0 応答は、`~header節$が終端するに伴い終了する【したがって、`~payload本体$を包含し得ない】。
~HTTP10は，この応答classの状態s~codeを定義しないので、`~server$は，~HTTP10~clientに対しては `1xx^st0 応答を送信してはナラナイ。
◎
The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. 1xx responses are terminated by the end of the header section. Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.
</p>

<p>
`~client$は、`最終-応答$に先立って受信した［
1 個以上の `1xx^st0 応答
］を
— 自身が予期していないとしても —
構文解析できなければナラナイ。
`~UA$は、予期していない `1xx^st0 応答を無視してもヨイ。
◎
A client MUST be able to parse one or more 1xx responses received prior to a final response, even if the client does not expect one. A user agent MAY ignore unexpected 1xx responses.
</p>

<p>
`~proxy$は、自身が `1xx^st0 応答の生成を要請した場合を除き，
`1xx^st0 応答を回送しなければナラナイ。
例えば，~proxyが要請を回送するときに［
`100-continue$c `期待$を内包する `Expect$h 【！`Expect: 100-continue^c】
］を追加した場合には、対応する `100^st 応答（たち）を回送する必要はない。
◎
A proxy MUST forward 1xx responses unless the proxy itself requested the generation of the 1xx response. For example, if a proxy adds an "Expect: 100-continue" field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s).
</p>
			<section id="status.100">
<h4>14.2.1. `100^st</h4>

<p>
`状態s~code$ `100^st は、次を指示する
⇒
要請の初期~部分が受信され、まだ，`~server$により却下されていない。
◎
The 100 (Continue) status code indicates that the initial part of a request has been received and has not yet been rejected by the server.＼
</p>

<p>
すなわち、~serverは次を意図している
⇒
要請を全部的に受信して, それに対し動作した後に、`最終-応答$を送信する
◎
The server intends to send a final response after the request has been fully received and acted upon.
</p>

<p>
`100^st0 応答に結付けられている要請が：
◎
When the request＼
</p>
<ul>
	<li>
`100-continue$c `期待$を内包する `Expect$h ~headerを包含していた場合
⇒
`~server$は、要請`~payload本体$の受信を望んでいることを指示する。
`~client$は、この `100^st0 応答は破棄して，要請の送信を継続する~OUGHT。
◎
contains an Expect header field that includes a 100-continue expectation, the 100 response indicates that the server wishes to receive the request payload body, as described in Section 9.1.1.＼
The client ought to continue sending the request and discard the 100 response.
</li>
	<li>
他の場合
⇒
`~client$は、この`暫定-応答$を単純に破棄できる。
◎
If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response.
</li>
</ul>

			</section>
			<section id="status.101">
<h4>14.2.2. `101^st</h4>

<p>
`状態s~code$ `101^st は、次を指示する
⇒
`~server$は、`~client$の要請を解したことに加え，［
この接続に利用されている応用~protocolを変更する
］ために `Upgrade$h ~header を介して要請に準拠する用意がある。
◎
The 101 (Switching Protocols) status code indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field (Section 6.6), for a change in the application protocol being used on this connection.＼
</p>

<p>
`~server$は、 `101^st0 応答~内に，次を指示する `Upgrade$h ~headerを`生成し$なければナラナイ
⇒
その応答を終了させる`空~行l$の直後から切替わることになる，~protocol（たち）
【！ `101^st0 は HTTP/2 では~supportされないので、この節の一部の記述は `Messaging$r の用語に基づいている。】
◎
The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be switched to immediately after the empty line that terminates the 101 response.
</p>

<p>
~serverが~protocolの切替に同意するのは、その方が有利なときに限られるものと見做されている。
例えば
⇒＃
より新しい~versionの~HTTPへの切替は、より古い~versionより有利になるかもしれない／
~real-timeかつ同期的な~protocolへの切替は、そのような特能を利用する資源を送達するときに有利になるかもしれない
◎
It is assumed that the server will only agree to switch protocols when it is advantageous to do so. For example, switching to a newer version of HTTP might be advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.
</p>

			</section>
		</section>
		<section id="status.2xx">
<h3 title="Successful 2xx">14.3. `2xx^st</h3>

<p>
`応答class$ `2xx^st に属する`状態s~code$は、次を指示する
⇒
`~client$の要請は、成功裡に，受信され, 解され, 受容された。
◎
The 2xx (Successful) class of status code indicates that the client's request was successfully received, understood, and accepted.
</p>
			<section id="status.200">
<h4>14.3.1. `200^st</h4>

<p>
`状態s~code$ `200^st は、次を指示する
⇒
要請は成功した。
◎
The 200 (OK) status code indicates that the request has succeeded.＼
</p>

<p>
`200^st0 応答~内に送信される~payloadは、`要請~method$に依存する。
この仕様が定義する~methodに対しては、~payloadに意図される意味は，次の様に要約できる：
◎
The payload sent in a 200 response depends on the request method. For the methods defined by this specification, the intended meaning of the payload can be summarized as:
</p>

<table>
<tbody><tr><th>`GET$m
<td>
`~target資源$の`表現$。
◎
a representation of the target resource;

<tr><th>`HEAD$m
<td>
`表現~data$は伴わないことを除いて、 `GET$m のときと同じ表現。
◎
the same representation as GET, but without the representation data;
<tr><th>`POST$m
<td>
［
動作の状態s,
または動作により得された結果
］の`表現$。
◎
a representation of the status of, or results obtained from, the action;
<tr><th>`PUT$m, `DELETE$m
<td>
［
動作の状態s
］の`表現$。
◎
a representation of the status of the action;
<tr><th>`OPTIONS$m
<td>
各種~通信~optionの`表現$。
◎
a representation of the communications options;

<tr><th>`TRACE$m
<td>
［
終端~serverにより受信された時点での，要請~message
］の`表現$。
◎
a representation of the request message as received by the end server.
</tbody>
</table>

<p>
`CONNECT$m に対する応答は別として、
`200^st0 応答には，常に`~payload本体$【！~payload】が在る
— `生成元~server$は、長さ 0 の~payload本体を`生成し$てもヨイが。
~payloadが欲されていない場合、生成元~serverは代わりに
`204$st を送信する~OUGHT。
`CONNECT$m に対しては，~payloadは許容されない
— その成功裡な結果は、`~tunnel$であり，
`200^st0 応答の`~header節$の直後から始まるので。
◎
Aside from responses to CONNECT, a 200 response always has a payload, though an origin server MAY generate a payload body of zero length. If no payload is desired, an origin server ought to send 204 (No Content) instead. For CONNECT, no payload is allowed because the successful result is a tunnel, which begins immediately after the 200 response header section.
</p>

<p>
`200^st0 応答は、`経験的に~cache可能$である。
◎
A 200 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.201">
<h4>14.3.2. `201^st</h4>

<p>
`状態s~code$ `201^st は、次を指示する
⇒
要請は履行され、その結果， 1 個以上の新たな`資源$が作成された。
◎
The 201 (Created) status code indicates that the request has been fulfilled and has resulted in one or more new resources being created.＼
</p>

<p>
要請により作成された`首な資源$は、［
応答~内に `Location$h ~headerが受信されたならば その値 ／
他の場合は`~target~URI$
］により識別される。
◎
The primary resource created by the request is identified by either a Location header field in the response or, if no Location field is received, by the target URI.
</p>

<p>
`201^st0 応答の~payloadは、概して，作成された`資源$（たち）を述べ, それらへ~linkする。
`201^st0 応答~内の［
`ETag$h や `Last-Modified$h などの`検証子~header$
］の意味と目的についての論点は、`7.9$sec を見よ。
◎
The 201 response payload typically describes and links to the resource(s) created. See Section 7.9 for a discussion of the meaning and purpose of validator header fields, such as ETag and Last-Modified, in a 201 response.
</p>

			</section>
			<section id="status.202">
<h4>14.3.3. `202^st</h4>

<p>
`状態s~code$ `202^st は、次を指示する
⇒
要請は処理~用に受容されたが、処理はまだ完了していない。
◎
The 202 (Accepted) status code indicates that the request has been accepted for processing, but the processing has not been completed.＼
</p>

<p>
最終的に要請が動作するかどうかは、実際の処理に入るときに許容されなくなることもあるので，~~確定していない。
~HTTPには、［
非同期的な演算から【その進捗や完了を指示する】状態s~codeを送信し直す
］ような便宜性はない。
◎
The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility in HTTP for re-sending a status code from an asynchronous operation.
</p>

<p>
`202^st0 応答は、意図的にどっちつかず（ `noncommittal^en ）にされている。
その目的は、`~server$が，何らかの処理n（たぶん，日に一度だけ稼働する一括的な処理n）用の要請を
— その処理の完了まで~serverへの接続を持続するよう，`~UA$に要求することなく —
受容できるようにすることにある。
この応答に伴って送信される`表現$は、要請の現在の状態sを述べることに加え，［
利用者に 要請がいつ履行されるかの見積もりを供せるような，状態s監視器
］を指す（または埋込む）~OUGHT。
◎
The 202 response is intentionally noncommittal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The representation sent with this response ought to describe the request's current status and point to (or embed) a status monitor that can provide the user with an estimate of when the request will be fulfilled.
</p>

			</section>
			<section id="status.203">
<h4>14.3.4. `203^st</h4>

<p>
`状態s~code$ `203^st は、次を指示する
⇒
要請は成功したが、同封された~payloadは，【！5.7.2$sec】`形式変換ng~proxy$により［
`生成元~server$の `200^st 応答のそれ
］から改変された。
◎
The 203 (Non-Authoritative Information) status code indicates that the request was successful but the enclosed payload has been modified from that of the origin server's 200 (OK) response by a transforming proxy (Section 6.5).＼
</p>

<p>
この状態s~codeにより、`形式変換$を適用した~proxyは，その旨を受信者たちに通知できるようになる
— その知識は、内容に関する今後の裁定に影響iするかもしれない。
例えば，［
内容に対する，未来の`~cache検証~要請$
］が適用-可能になるのは、同じ要請~経路に沿うもの（同じ~proxyたちを通して）に限られるようになり得る。
◎
This status code allows the proxy to notify recipients when a transformation has been applied, since that knowledge might impact later decisions regarding the content. For example, future cache validation requests for the content might only be applicable along the same request path (through the same proxies).
</p>

<p>
`203^st0 応答は、［［
どの状態s~codeを伴う応答にも適用-可能である利点
］がある， `Warning$h ~code `214^c
］に類似する。
◎
The 203 response is similar to the Warning code of 214 Transformation Applied (Section 5.5 of [Caching]), which has the advantage of being applicable to responses with any status code.
</p>

<p>
`203^st0 応答は、`経験的に~cache可能$である。
◎
A 203 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.204">
<h4>14.3.5. `204^st</h4>

<p>
`状態s~code$ `204^st は、次を指示する
⇒
`~server$は、要請を成功裡に履行した。
加えて、その応答の`~payload本体$内に送信する追加的な内容は無い。
◎
The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.＼
</p>

<p>
`応答~header$内の~metadataは、`~target資源$, および［
要請された動作が適用された後に`選定された表現$
］を指す。
◎
Metadata in the response header fields refer to the target resource and its selected representation after the requested action was applied.
</p>

<p>
例えば、
`PUT$m 要請に対する応答~内に `204^st0 が受信され，応答が `ETag$h ~fieldを包含する場合、
`PUT$m は成功していて，
`ETag$h `~field値$が［
その`~target資源$の新たな`表現$用の `entity-tag$p
］を包含する。
◎
For example, if a 204 status code is received in response to a PUT request and the response contains an ETag field, then the PUT was successful and the ETag field value contains the entity-tag for the new representation of that target resource.
</p>

<p>
`204^st0 応答により、`~server$は，`~UA$に向けて［［
~UAは，自身の現在の “文書~view” （もしあれば）から離れて他へ辿る必要はない
］ことを含意しつつ，動作が`~target資源$に成功裡に適用された
］ことを指示できるようになる。
`~server$は、［
~UAが、自身の~interfaceに則って，利用者に何らかの成功の指示を供した上で、［
応答~内の新たな／更新された~metadata
］を，~UAにて作動中の表現に適用することになる
］ものと見做している。
◎
The 204 response allows a server to indicate that the action has been successfully applied to the target resource, while implying that the user agent does not need to traverse away from its current "document view" (if any). The server assumes that the user agent will provide some indication of the success to its user, in accord with its own interface, and apply any new or updated metadata in the response to its active representation.
</p>

<p>
`204^st0 は、例えば，［
“保存” 動作に対応する文書~編集~interface
］と伴に共通的に利用され，［
保存-中の文書が，利用者による編集~用に可用であり続ける
］ようにする。
それはまた、分散型の~version制御~systemの中など，［
自動化~data転送が主流になると期待される~interface
］と伴に利用されることも多い。
◎
For example, a 204 status code is commonly used with document editing interfaces corresponding to a "save" action, such that the document being saved remains available to the user for editing. It is also frequently used with interfaces that expect automated data transfers to be prevalent, such as within distributed version control systems.
</p>

<p>
`204^st0 応答は、`~message本体$を包含できないので，`~header節$が終端するに伴い【！＊の後の最初の`空~行l$で】終了する。
◎
A 204 response is terminated by the first empty line after the header fields because it cannot contain a message body.
</p>

<p>
`204^st0 応答は、`経験的に~cache可能$である。
◎
A 204 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.205">
<h4>14.3.6. `205^st</h4>

<p>
`状態s~code$ `205^st は、次を指示する
⇒
`~server$は、要請を履行した。
加えて，~serverは、`~UA$が次を行うよう欲している
⇒
要請を送信させた “文書~view” を［
`生成元~server$から受信した，その元の状態
］に設定し直す
◎
The 205 (Reset Content) status code indicates that the server has fulfilled the request and desires that the user agent reset the "document view", which caused the request to be sent, to its original state as received from the origin server.
</p>

<p>
この応答は、［
次のような共通的な~data手入力の利用事例
］を~supportすることが意図されている
⇒
［［
~data手入力（~form, ~notepad, ~canvas, 等々）を~supportする内容
］を受信した利用者が，その場で手入力したり操作した~data
］が，要請にて提出されたとき、利用者が別の入力~動作に容易に取り掛かれるよう，次回の手入力~用に，~data手入力の仕組みを設定し直す。
◎
This response is intended to support a common data entry use case where the user receives content that supports data entry (a form, notepad, canvas, etc.), enters or manipulates data in that space, causes the entered data to be submitted in a request, and then the data entry mechanism is reset for the next entry so that the user can easily initiate another input action.
</p>

<p>
状態s~code `205^st0 は，［
追加的な内容は供されない
］ことを含意するので、`~server$は，
`205^st0 応答~内に~payloadを`生成し$てはナラナイ。
◎
Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate a payload in a 205 response.
</p>

			</section>
			<section id="status.206">
<h4>14.3.7. `206^st</h4>

<p>
`状態s~code$ `206^st
— `部分的な応答^dfn —
は、次を指示する
⇒
`~server$は、［
`選定された表現$を成す， 1 個~以上の部位t
］を転送することにより，`~target資源$に対する`範囲~要請$を成功裡に履行した
◎
The 206 (Partial Content) status code indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation.
</p>

<p>
`206^st0 応答を`生成し$ている`~server$は、以下の下位節にて要求されるものに加えて，次に挙げる~headerのうち［
同じ要請に対する `200$st 応答~内に送信されることになるもの
］を`生成し$なければナラナイ
⇒＃
`Date$h,
`Cache-Control$h ,
`ETag$h,
`Expires$h,
`Content-Location$h,
`Vary$h
◎
When a 206 response is generated, the server MUST generate the following header fields, in addition to those required in the subsections below, if the field would have been sent in a 200 (OK) response to the same request: Date, Cache-Control, ETag, Expires, Content-Location, and Vary.
</p>

<p>
`206^st0 応答~内に在る `Content-Length$h ~fieldは、当の応答の`~message本体$を成す~octetの個数を指示する
— それは、通例的には，`選定された表現$の完全な長さにはならない。
各 `Content-Range$h ~fieldが，選定された表現の完全な長さについての情報を内包する。
◎
A Content-Length field present in a 206 response indicates the number of octets in the body of this message, which is usually not the complete length of the selected representation. Each Content-Range field includes information about the selected representation's complete length.
</p>

<div class="p">
<p>
`送信者$は、
`If-Range$h ~headerを伴う要請に対する応答に
◎
↓</p>
<ul>
	<li>
`206^st0 を`生成する$ときは
⇒
［
要求されるものを超える，他の`表現~header$
］は、`生成する$ベキでない
— `~client$は，それらの~headerたちを包含するような先立つ応答をすでに持っているものと解されるので。
◎
If a 206 is generated in response to a request with an If-Range header field, the sender SHOULD NOT generate other representation header fields beyond those required, because the client is understood to already have a prior response containing those header fields.＼
</li>
	<li>
他の場合
⇒
［
同じ要請に対する `200$st 応答~内に送信されることになる
］ような，すべての`表現~header$を`生成し$なければナラナイ。
◎
Otherwise, the sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.
</li>
</ul>
</div>

<p>
`206^st0 応答は、`経験的に~cache可能$である
— 明示的な~cache制御により指示されない限り（ `Caching/4.2.2$sec を見よ）。
◎
A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

				<section id="partial.single">
<h5 title="Single Part">14.3.7.1. 単独の部位t</h5>

<p>
`206^st0 応答を`生成し$ている`~server$は、単独の部位tを転送している場合、［
`選定された表現$のどの範囲が同封されたか, および
範囲を成す~payload
］を述べる `Content-Range$h ~headerを`生成し$なければナラナイ。
◎
If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a payload consisting of the range.＼
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
</pre>
</div>

				</section>
				<section id="partial.multipart">
<h5 title="Multiple Parts">14.3.7.2. 複数の部位t</h5>
<p>
`206^st0 応答を`生成し$ている`~server$は、複数の部位tを転送している場合は，
"`multipart/byteranges$c" ~payload, および［
"`multipart/byteranges$c" ~MIME型とそれに要求される `boundary^c ~parameter
］を包含する `Content-Type$h ~headerを`生成し$なければナラナイ。
単独の部位tによる応答との混同を避けるため、この応答の~HTTP`~header節$内には， `Content-Range$h ~headerを`生成し$てはナラナイ（この~headerは、以下に述べるように，各~部位tごとに送信することになる）。
◎
If multiple parts are being transferred, the server generating the 206 response MUST generate a "multipart/byteranges" payload, as defined in Section 13.5, and a Content-Type header field containing the multipart/byteranges media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).
</p>

<p>
`複部位$による~payload内の各~本体~部位tの~header区画の中では、その本体~部位t内に同封されている範囲に対応する， `Content-Range$h ~headerを`生成し$なければナラナイ。
`選定される表現$が，［
`200$st 応答においては `Content-Type$h ~headerを持つことになる
］ならば、その同じ `Content-Type$h ~headerを，各~本体~部位t内の~header区画~内に`生成する$ベキである。
◎
Within the header area of each body part in the multipart payload, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type field in the header area of each body part.＼
</p>

<div class="example">
<p>
例えば：
【この例では、 `THIS_STRING_SEPARATES^c が各 部位tを分離する境界を成す】
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
`~server$は、複数の範囲が要請されたときは、それらの範囲のうち［
重合するもの, あるいは
複数~部位tの送信による~overheadより小さな間隙で分離されるもの
］を合体してもヨイ
— 対応する `range-spec$p が，受信された `Range$h ~header内に出現する順序に関わらず。
"`multipart/byteranges$c" ~payloadの各~部位t間の 代表的な~overheadは， 80 ~byte程度なので、~~細切れにされた多数の部位tを転送するのは，［
`選定された表現$の~MIME型, および
選ばれた `boundary^c ~parameterの長さ
］に依存して、`選定された表現$ ~~全体を転送するより非~効率的になり得る。
◎
When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between parts of a multipart/byteranges payload is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.
</p>

<p>
`~server$は、単独の範囲に対する要請に対し，`複部位$応答を`生成し$てはナラナイ
— 複数の部位tを要請しなかった~clientは，`複部位$応答を~supportしないかもしれないので。
しかしながら，`~server$は、複数の範囲が要請されていて, かつ［
唯一の範囲が`満足可能$として見出された, または
合体した後に 1 個の範囲のみ残った
］ならば、単独の本体~部位tのみを伴う
"`multipart/byteranges$c" ~payloadを`生成し$てもヨイ。
"`multipart/byteranges$c" 応答を処理できない`~client$は、複数の範囲を依頼する要請を`生成し$てはナラナイ。
◎
A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a multipart/byteranges payload with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a multipart/byteranges response MUST NOT generate a request that asks for multiple ranges.
</p>

<p>
`~server$は、`複部位$応答の~payloadを生成するときには，受信された `Range$h ~header内に出現する対応する `range-spec$p と同じ順序で，各~部位tを送信するベキである
— 範囲たちのうち［
`満足可能$でないと判断される／他の範囲に合体される
］ものは除外した上で。
`複部位$応答を受信した`~client$は、各~本体~部位t内に在る `Content-Range$h ~headerを検分して，その本体~部位t内にどの範囲が包含されているかを決定しなければナラナイ
— ~clientは、自身が要請したものと同じ［
範囲たち／順序
］の受信に依拠できない。
◎
When a multipart response payload is generated, the server SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.
</p>

				</section>
				<section id="combining.byte.ranges">
<h5 title="Combining Parts">14.3.7.3. 範囲の結合-法</h5>

<p>
応答は、［
接続が尚早に~closeされた, または
要請が 1 個~以上の `Range$h 指定を利用した
］場合に，表現の部分範囲のみを転送し得る。
その種の転送が何度か行われたなら、`~client$は，同じ表現のいくつかの範囲を受信することになるであろう。
これらの各~範囲を安全に結合できるのは、それらが揃って同じ`強い検証子$を持つ場合に限られる。
◎
A response might transfer only a subrange of a representation if the connection closed prematurely or if the request used one or more Range specifications. After several such transfers, a client might have received several ranges of the same representation. These ranges can only be safely combined if they all have in common the same strong validator (Section 7.9.1).
</p>

<p>
`~target資源$に対する何度かの `GET$m 要請に対し，複数の`部分的$（または`不完全$）な［
`200$st ／ `206$st
］応答を受信した`~client$は、以下に従って，［
それらのうち同じ`強い検証子$を共有するものたち
］を より大きな連続的な範囲に結合してもヨイ。
◎
A client that has received multiple partial responses to GET requests on a target resource MAY combine those responses into a larger continuous range if they share the same strong validator.
</p>

<p class="trans-note">【
該当する応答~すべてかどうかは、明言されていない。
また、結果の範囲が連続的にならない場合でも，以下は適用し得るように見受けられる。
】</p>

<div>
<p>
以下においては：
</p>
<ul>
	<li>
`S^V は、これらの（~cacheに格納-済みな【, または現在の】）応答が成す集合を表すとする。
</li>
	<li>
`C^V は、結合した結果の応答を表すとする。
</li>
	<li>
所与の `応答^V, `名前^V に対し，
“`応答^V の`~header^i( `名前^V )”
という表記は、
`応答^V 内の［
`~field名$が `名前^V に合致する~header
］を指すとする。
</li>
</ul>
◎
↓</div>

<ul class="switch">
	<li>
<p>
`S^V 内に `200^st0 応答が在る場合
— `R^V は、それらのうち最も近過去の応答を表すとする：
</p>

<p>
`R^V 内の~headerの`~field名$からなる集合を成す
~EACH( `名前^V )
に対し：
</p>
		<ul>
			<li>
`R^V の`~header^i( `名前^V )
を `C^V の~headerとして利用する。
</li>
			<li>
`R^V は `S^V 内で最も近過去の応答でもあるならば
⇒
`S^V 内の `R^V 以外の
~EACH( `応答^V )
に対し
⇒
`応答^V の`~header^i( `名前^V ) を
`R^V の`~header^i( `名前^V ) で置換する
</li>
		</ul>
◎
If the most recent response is an incomplete 200 (OK) response, then the header fields of that response are used for any combined response and replace those of the matching stored responses.
◎
If the most recent response is a 206 (Partial Content) response and at least one of the matching stored responses is a 200 (OK), then the combined response header fields consist of the most recent 200 response's header fields.＼
</li>
	<li>
<p>
他の場合（ `S^V 内の応答は、どれも `206^st0 応答である）：
</p>
<p>
［
`S^V 内のある応答~内に在る~headerの`~field名$
］に合致するような `Content-Range$h 以外の
~EACH( `名前^V )
に対し：
</p>
		<ul>
			<li>
以下における `R^V は、
`S^V 内の応答のうち［
その`~header^i( `名前^V ) は空でない
］もののうち最も近過去に受信したものを表すとする。
</li>
			<li>
`R^V の`~header^i( `名前^V )
を `C^V の~headerの~sourceとして利用する。
</li>
			<li>
`R^V は `S^V 内で最も近過去の応答でもあるならば
⇒
`S^V 内の `R^V 以外の
~EACH( `応答^V )
に対し
⇒
`応答^V の`~header^i( `名前^V )
を
`R^V の`~header^i( `名前^V )
で置換しなければナラナイ。
</li>
		</ul>

<p class="trans-note">【
`C^V の `Content-Range$h は、結果の範囲を表現するように決定されることになろう。
】</p>

◎
If all of the matching stored responses are 206 responses, then the stored response with the most recent header fields is used as the source of header fields for the combined response, except that the client MUST use other header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.
</li>
</ul>

<div class="p">
<p>
`C^V の`~message本体$は、［
`S^V を成す各 応答による部分的~範囲
］の内容からなる和集合になる。
`~client$は、その和集合が：
◎
The combined response message body consists of the union of partial content ranges in the new response and each of the selected responses. If the union consists of＼
</p>
<ul class="switch">
	<li>
表現~~全体を成す場合
⇒
`C^V を，それが`完全$な `200$st 応答であるかのように処理しなければナラナイ
— 完全な長さを反映する， `Content-Length$h ~headerも含め。
◎
the entire range of the representation, then the client MUST process the combined response as if it were a complete 200 (OK) response, including a Content-Length header field that reflects the complete length.＼
</li>
	<li>
<p>
他の場合、和集合を成している各［
連続的な範囲たち
］を，次のいずれかとして処理しなければナラナイ：
◎
Otherwise, the client MUST process the set of continuous ranges as one of the following:＼
</p>

		<ul>
			<li>
`C^V が表現の先頭部分を成す場合に限り、`不完全$な `200$st 応答
◎
an incomplete 200 (OK) response if the combined response is a prefix of the representation,＼
</li>
			<li>
"`multipart/byteranges$c" 本体を包含している単独の `206$st 応答
◎
a single 206 (Partial Content) response containing a multipart/byteranges body, or＼
</li>
			<li>
それぞれが，［
`Content-Range$h ~headerにより指示される 1 個の連続的な範囲
］を伴うような、複数の `206$st 応答。
◎
multiple 206 (Partial Content) responses, each with one continuous range that is indicated by a Content-Range header field.
</li>
		</ul>
	</li>
</ul>
</div>

				</section>
			</section>
		</section>
		<section id="status.3xx">
<h3 title="Redirection 3xx">14.4. `3xx^st</h3>

<p>
`応答class$ `3xx^st に属する`状態s~code$は、次を指示する
⇒
要請が履行されるためには、~UAは，更なる動作をとる必要がある。
◎
The 3xx (Redirection) class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.＼
</p>

<p>
~redirectは、次に挙げる種別に分けられる：
◎
There are several types of redirects:
</p>
<ul>
	<li>
［
当の`資源$は、 `Location$h ~fieldが供する，異なる~URIにて可用かもしれない
］ことを指示するもの
⇒＃
`301$st,
`302$st,
`307$st,
`308$st
◎
Redirects that indicate this resource might be available at a different URI, as provided by the Location field, as in the status codes 301 (Moved Permanently), 302 (Found), 307 (Temporary Redirect), and 308 (Permanent Redirect).
</li>
	<li>
何個かの合致した`資源$からなる選択肢を提供するもの
— それぞれが当の`資源$を表現する能力を有するような
⇒
`300$st
◎
Redirection that offers a choice among matching resources capable of representing this resource, as in the 300 (Multiple Choices) status code.
</li>
	<li>
［
`Location$h ~fieldにより識別され，要請に対する間接的な応答を表現し得る
］ような，異なる`資源$への~redirection
⇒
`303$st
◎
Redirection to a different resource, identified by the Location field, that can represent an indirect response to the request, as in the 303 (See Other) status code.
</li>
	<li>
以前に格納-済みな結果への~redirection
⇒
`304$st
◎
Redirection to a previously stored result, as in the 304 (Not Modified) status code.
</li>
</ul>

<p>
応答に `Location$h ~headerが供されている場合、`~UA$は
— その特定の状態s~codeを解せないときでも —
その`~field値$により参照される`~URI$へ向けて，要請を自動的に~redirectして
【 “~directし直して” 】
もヨイ。
自動~redirectionは、［
`安全$であると既知でない~methodに対しては、利用者は，その~redirectを望まないこともある
］ので，~~注意して行う必要がある。
◎
If a Location header field (Section 9.2.3) is provided, the user agent MAY automatically redirect its request to the URI referenced by the Location field value, even if the specific status code is not understood. Automatic redirection needs to be done with care for methods not known to be safe, as defined in Section 8.2.1, since the user might not wish to redirect an unsafe request.
</p>

<p>
`~UA$は，~redirectされた要請に対し自動的に追従するときは、［
元の要請~messageに，次に挙げる改変を加えた結果の要請
］を送信し直すベキである：
◎
When automatically following a redirected request, the user agent SHOULD resend the original request message with the following modifications:
</p>
<ol>
	<li>
`~target~URI$を次に置換する
⇒
［
~redirection応答の `Location$h ~header`~field値$が参照している~URI
］を［
元の要請の`~target~URI$
］に相対的に解決した結果
◎
Replace the target URI with the URI referenced by the redirection response's Location header field value after resolving it relative to the original request's target URI.
</li>
	<li>
<p>
当の実装により自動的に生成された~headerを除去して、それらを新たな要請に適切な，更新された値で置換する
— 次に挙げるものが含まれる：
◎
Remove header fields that were automatically generated by the implementation, replacing them with updated values as appropriate to the new request. This includes:
</p>
		<ul>
			<li>
接続に特有な~header（ § `Connection$h ）
◎
Connection-specific header fields (see Section 6.4.1),
</li>
			<li>
~clientの~proxy環境設定に特有な~header
— 次に挙げるものなど
⇒＃
`Proxy-Authorization$h
◎
Header fields specific to the client's proxy configuration, including (but not limited to) Proxy-Authorization,
</li>
			<li>
生成元に特有な~header
— 次に挙げるものなど
⇒＃
`Host$h
◎
Origin-specific header fields (if any), including (but not limited to) Host,
</li>
			<li>
実装の`~cache$により追加された検証-用~header（例：
`If-None-Match$h,
`If-Modified-Since$h
）
◎
Validating header fields that were added by the implementation's cache (e.g., If-None-Match, If-Modified-Since),
</li>
			<li>
資源に特有な~header
— 次に挙げるものなど
⇒＃
`Referer$h,
`Origin$h,
`Authorization$h,
`Cookie$h
◎
Resource-specific header fields, including (but not limited to) Referer, Origin, Authorization, and Cookie.
</li>
		</ul>
	</li>
	<li>
~securityの含意が在る所では、実装により自動的に生成されたものでない~header（すなわち、~callしている文脈により要請~内に追加されたもの）を除去することも，考慮する
— 次に挙げるものなど
⇒＃
`Authorization$h,
`Cookie$h
◎
Consider removing header fields that were not automatically generated by the implementation (i.e., those present in the request because they were added by the calling context) where there are security implications; this includes but is not limited to Authorization and Cookie.
</li>
	<li>
適用-可能なら、~redirectしている`状態s~code$の意味論に則って，当の`要請~method$を変更する
◎
Change the request method according to the redirecting status code's semantics, if applicable.
</li>
	<li>
当の`要請~method$を［
`GET$m ／ `HEAD$m
］に変更したならば、内容に特有な~headerを除去する
— 次に挙げるものなど
⇒＃
`Content-Encoding$h,
`Content-Language$h,
`Content-Location$h,
`Content-Type$h,
`Content-Length$h,
`Digest$h,
`ETag$h,
`Last-Modified$h
◎
If the request method has been changed to GET or HEAD, remove content-specific header fields, including (but not limited to) Content-Encoding, Content-Language, Content-Location, Content-Type, Content-Length, Digest, ETag, Last-Modified.
</li>
</ol>

<p class="note">注記：
~HTTP10においては、［
`301$st, `302$st
］のみが，この節の冒頭にて最初に挙げた種別の~redirect用として定義された（ `RFC1945/9.3$sec ）。
早期の~UAは、~redirect~targetに~methodを適用するときに，~methodを［
元の要請と同じにするもの, `GET$m に書換えるもの
］に分かれる。
~HTTPは，~~元々は［
`301$st0, `302$st に対しては前者の意味論
］に, ［
`303$st に対しては後者の意味論
］に合致するように定義されていたが、~~支配的な実施から［
`301$st0, `302$st0 に対しても後者の意味論
］になるように徐々に収束してきた。
`~HTTP11$の最初の改訂には、そのような実施の分岐に影響iされないものとして，
`302$st0 の前者の意味論を指示する `307$st が追加された。
10 年が経過した今でも、ほとんどの~UAは， `301$st0 ／ `302$st0 に対しては，依然として~methodを書換えている。
同じ理由で、後に `308$st が `301^st0 に合致するよう `RFC7538$r に追加された。
したがって，その挙動は、元の要請が `POST$m であるときには， `RFC7231$r により適合tとされた。
◎
Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and 302 (Found) were defined for the first type of redirect ([RFC1945], Section 9.3). Early user agents split on whether the method applied to the redirect target would be the same as the original request or would be rewritten as GET. Although HTTP originally defined the former semantics for 301 and 302 (to match its original implementation at CERN), and defined 303 (See Other) to match the latter semantics, prevailing practice gradually converged on the latter semantics for 301 and 302 as well. The first revision of HTTP/1.1 added 307 (Temporary Redirect) to indicate the former semantics of 302 without being impacted by divergent practice. For the same reason, 308 (Permanent Redirect) was later on added in [RFC7538] to match 301. Over 10 years later, most user agents still do method rewriting for 301 and 302; therefore, [RFC7231] made that behavior conformant when the original request is POST.
</p>

<p>
`~client$は、循環的な~redirection（すなわち， “無限” ~redirection~loop）を検出して，介入するベキである。
◎
A client SHOULD detect and intervene in cyclical redirections (i.e., "infinite" redirection loops).
</p>

<p class="note">注記：
この仕様の~~過去の~versionでは、~redirection回数として最大 5 回までが推奨されていた（ `RFC2068/10.3$sec ）。
内容~開発者は、そのような固定的な制限を実装する~clientもあり得ることを，自覚しておく必要がある。
◎
Note: An earlier version of this specification recommended a maximum of five redirections ([RFC2068], Section 10.3). Content developers need to be aware that some clients might implement such a fixed limitation.
</p>

			<section id="status.300">
<h4>14.4.1. `300^st</h4>

<p>
`状態s~code$ `300^st は、次を指示する
⇒
`~target資源$には複数の`表現$が有り，そのそれぞれが［
自前の，より特定な識別子
］を伴うこと，および［
それらの代替についての情報が供されていて、利用者（または~UA）は，［
それらの識別子のうち 1 個以上のものへ，要請を~redirectする
］ことにより，選好する表現を選定できる。
◎
The 300 (Multiple Choices) status code indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers.＼
</p>

<p>
言い換えれば、`~server$は，［
`~UA$が、`~reactive折衝$に携わって，自身の必要性に最も適切な表現（たち）を選定する
］よう欲している。
◎
In other words, the server desires that the user agent engage in reactive negotiation to select the most appropriate representation(s) for its needs (Section 11).
</p>

<p>
`~server$は、それらの選択肢のうち 選好するものがあるならば，［
その選択肢の`~URI参照$を包含する `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
◎
If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference. The user agent MAY use the Location field value for automatic redirection.
</p>

<div class="p">
<p>
`要請~method$は `HEAD$m でない場合、`~server$は， `300^st0 応答~内に［［
利用者／~UA
］が最も選好するものを選べるような，`表現~metadata$と`~URI参照$（たち）からなる~list
］を包含する~payloadを`生成する$ベキである。
`~UA$は、供された`~MIME型$を解するならば，その~listから自動的に選定してもヨイ。
［
自動~選定~用の特定の形式
］は、この仕様では，定義されない
— ~HTTPは、~payloadの定義に直交的であろうとし続けるので。
実施においては、`表現$は，次のいずれかとして供される：
◎
For request methods other than HEAD, the server SHOULD generate a payload in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred. The user agent MAY make a selection from that list automatically if it understands the provided media type. A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its payloads. In practice, the representation is provided＼
</p>
<ul>
	<li>
何らかの容易に構文解析できる形式
— 共有されている［
設計や`内容~折衝$
］により決定され, ~UAに受容-可能と予見されるような。
◎
in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation,＼
</li>
	<li>
何らかの共通して受容される~hypertext形式。
◎
or in some commonly accepted hypertext format.
</li>
</ul>
</div>

<p>
`300^st0 応答は、`経験的に~cache可能$である。
◎
A 300 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

<p class="note">注記：
`300^st0 用の元の提案では、 `URI^h ~headerを［［
`200$st0 ／ `300^st0 ／ `406$st0
］応答に利用でき，［
`HEAD$m ~methodに対する応答~内に転送される，代替~表現の~list
］を供するもの
］として，定義していた。
しかしながら，［
配備の欠如と，構文について~~合意が得られなかった
］ため、［
`URI^h,
後続して提案された `Alternates^h
］は，この仕様から落とされることになった。
配備については鶏と卵の問題であるが、
`Link$h ~header `RFC8288$r の`~field値$として
— その~memberたちに関係性 "`alternate^c" 【 “代替する” 】を伴わせて —
~listを通信することはアリである。
◎
Note: The original proposal for the 300 status code defined the URI header field as providing a list of alternative representations, such that it would be usable for 200, 300, and 406 responses and be transferred in responses to the HEAD method. However, lack of deployment and disagreement over syntax led to both URI and Alternates (a subsequent proposal) being dropped from this specification. It is possible to communicate the list as a Link header field value [RFC8288] whose members have a relationship of "alternate", though deployment is a chicken-and-egg problem.
</p>

			</section>
			<section id="status.301">
<h4>14.4.2. `301^st</h4>

<p>
`状態s~code$ `301^st は、次を指示する
⇒
`~target資源$に，新たな恒久的~URIがアテガわれていて、この資源への未来の参照は，同封された いずれかの~URIを利用する~OUGHT。
◎
The 301 (Moved Permanently) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.＼
</p>

<p>
~link編集~能力を備えている`~client$は、アリな所では，`~target~URI$への参照を［
~serverから送信されてきた，1 個以上の新たな参照
］へ自動的に~linkし直す~OUGHT。
◎
Clients with link-editing capabilities ought to automatically re-link references to the target URI to one or more of the new references sent by the server, where possible.
</p>

<p>
`~server$は、応答~内に，［［
新たな恒久的~URIとして選好される，`~URI参照$
］を包含する， `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
新たな~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>

<p class="note">注記：
歴史的な理由から、~UAは，後続の要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、代わりに `308$st を利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 308 (Permanent Redirect) status code can be used instead.
</p>

<p>
`301^st0 応答は、`経験的に~cache可能$である。
◎
A 301 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.302">
<h4>14.4.3. `302^st</h4>

<p>
`状態s~code$ `302^st は、次を指示する
⇒
`~target資源$は、一時的に，異なる~URIの下に居る。
◎
The 302 (Found) status code indicates that the target resource resides temporarily under a different URI.＼
</p>

<p>
~redirectionは，その時々で改められ得るので、`~client$は，未来の要請には`~target~URI$を利用し続ける~OUGHT。
◎
Since the redirection might be altered on occasion, the client ought to continue to use the target URI for future requests.
</p>

<p>
`~server$は、応答~内に，［［
その異なる~URI用の`~URI参照$
］を包含する `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

<p class="note">注記：
歴史的な理由から、`~UA$は，後続の要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、代わりに `307$st を利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 307 (Temporary Redirect) status code can be used instead.
</p>

			</section>
			<section id="status.303">
<h4>14.4.4. `303^st</h4>

<p>
`状態s~code$ `303^st は、次を指示する
⇒
`~server$は、［
`Location$h ~header内の~URIにより指示される，異なる`資源$
］へ，~UAを~redirectしている。
◎
The 303 (See Other) status code indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field,＼
</p>

<p>
その意図は、［
元の要請に対する間接的な応答を供する
］ことである。
`~UA$は、［
その~URIを~targetする検索取得~要請（ ~HTTPを利用しているなら `GET$m または `HEAD$m 要請）
］を遂行できる
— それは、［
元の要請に対する回答として最終的な結果を呈示する
］ために，また~redirectされ得る。
`Location$h ~header内の新たな~URIは、`~target~URI$に等価なものとは見なされないことに注意。
◎
which is intended to provide an indirect response to the original request.＼
A user agent can perform a retrieval request targeting that URI (a GET or HEAD request if using HTTP), which might also be redirected, and present the eventual result as an answer to the original request. Note that the new URI in the Location header field is not considered equivalent to the target URI.
</p>

<p>
この状態s~codeは、どの~HTTP~methodにも適用-可能である。
これは首に、［
`POST$m 動作の出力により，`~UA$を選定された`資源$へ~redirectできるようにする
］ために利用される
— そうすることにより、［
~formにおける `POST$m 応答に対応する情報
］は、元の要請からは独立に, ［
別々に［
識別する／~bookmarkする／~cacheする
］ことができる形
］で，供されるようになる。
◎
This status code is applicable to any HTTP method. It is primarily used to allow the output of a POST action to redirect the user agent to a selected resource, since doing so provides the information corresponding to the POST response in a form that can be separately identified, bookmarked, and cached, independent of the original request.
</p>

<p>
`GET$m 要請に対する `303^st0 応答は、［
`生成元~server$は［
~serverにより~HTTP越しに転送できるような［
`~target資源$の`表現$
］を持たないが、
`Location$h `~field値$は［
元の~target資源 `A^V を~~記述するものである，資源 `B^V
］を指している
］ことを指示する
— その資源 `B^V への検索取得~要請を為した結果が、資源 `A^V を表現することを含意することなく，受信者に有用な表現になり得るような。
［
何を表現し得るか？ ／
どのような表現であれば必要十分になるか？ ／
何が有用な~~記述になり得るか？
］に対する回答は、~HTTPの視野から外れることに注意。
◎
A 303 response to a GET request indicates that the origin server does not have a representation of the target resource that can be transferred by the server over HTTP. However, the Location field value refers to a resource that is descriptive of the target resource, such that making a retrieval request on that other resource might result in a representation that is useful to recipients without implying that it represents the original target resource. Note that answers to the questions of what can be represented, what representations are adequate, and what might be a useful description are outside the scope of HTTP.
</p>

<p>
`HEAD$m 要請に対する応答を除いて、［
`303^st0 応答の`表現$
］は、［［
`Location$h ~header内に供されたものと同じ`~URI参照$
］への~hyperlinkを伴う，短い~hypertext
］を包含する~OUGHT。
◎
Except for responses to a HEAD request, the representation of a 303 response ought to contain a short hypertext note with a hyperlink to the same URI reference provided in the Location header field.
</p>

			</section>
			<section id="status.304">
<h4>14.4.5. `304^st</h4>

<p>
`状態s~code$ `304^st は、次を指示する
⇒
条件付き［
`GET$m ／ `HEAD$m
］要請が受信されたこと，および、仮に［
その条件が偽に`評価-$される事実がなかった
］とするならば， `200$st で応答することになる。
◎
The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false.＼
</p>

<p>
言い換えれば、`~server$にとっては，`~target資源$の`表現$を転送する必要はない
— 何故なら，そのような要請は、［
その要請を条件付きにした`~client$が，妥当な表現をすでに持っている
］ことを指示するので。
すなわち，~serverは、［
~clientに格納-済みな その表現を，
`200$st 応答の`~payload$であったかのように用立ててもらう
］べく，~clientを~redirectしている。
◎
In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response.
</p>

<p>
`304^st 応答を`生成し$ている~serverは、次に挙げる~headerのうち［
同じ要請に対し `200$st 応答にて送信されることになるもの
］すべてを`生成し$なければナラナイ
⇒＃
`Cache-Control$h,
`Content-Location$h,
`Date$h,
`ETag$h,
`Expires$h,
`Vary$h
◎
The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.
</p>

<p>
`304^st0 応答の目標は，［
受信者がすでに 1 個以上の~cache済み`表現$を有するときに，転送する情報を最小限にする
］ことなので、送信者は，上に挙げた~field以外の`表現~metadata$を`生成する$ベキでない
— その種の~metadataが~cache更新を手引きする目的で存在するのでない限り（例：
`Last-Modified$h は、応答が `ETag$h ~fieldを持たない場合には，有用になり得る）。
◎
Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).
</p>

<p>
`304^st0 応答を受信した`~cache$に課される要件は、
`Caching/4.3.4$sec
にて定義される。
`条件付き要請$が`外方$にある`~client$
— 自前の~cacheを備え，共用~proxyに向けて条件付き `GET$m を送信する~UAなど —
により出生された場合、`~proxy$は，
`304^st0 応答を その~clientに向けて回送するベキである。
◎
Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [Caching]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.
</p>

<p>
`304^st0 応答は、`~message本体$【！`message-body$p 】を包含できない
— それは常に、`~header節$が終端するに伴い【！それを終わらせる最初の`空~行l$で】終了する。
◎
A 304 response cannot contain a message-body; it is always terminated by the first empty line after the header fields.
</p>

			</section>
			<section id="status.305">
<h4>14.4.6. `305^st</h4>

<p>
`状態s~code$ `305^st は、この仕様の以前の~versionにて定義されていたが，今や非推奨にされた（ `RFC7231/B$sec ）。
◎
The 305 (Use Proxy) status code was defined in a previous version of this specification and is now deprecated (Appendix B of [RFC7231]).
</p>

			</section>
			<section id="status.306">
<h4>14.4.7. `306^st0 （利用されない）</h4>

<p>
`状態s~code$ `306^st0 は、この仕様の以前の~versionにて定義されていたが，もはや利用されない
— この~codeは予約-済みにされた。
◎
The 306 status code was defined in a previous version of this specification, is no longer used, and the code is reserved.
</p>

			</section>
			<section id="status.307">
<h4>14.4.8. `307^st</h4>

<p>
`状態s~code$ `307^st は、次を指示する
⇒
［
`~target資源$は，一時的に異なる~URIの下に居る
］こと, および［
`~UA$は、その~URIへの自動~redirectionを遂行するときに，`要請~method$を変更してはナラナイ
］。
◎
The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.＼
</p>

<p>
~redirectionは，時間とともに変化し得るので、`~client$は，未来の要請にも 元の`~target~URI$を利用し続ける~OUGHT。
◎
Since the redirection can change over time, the client ought to continue using the original target URI for future requests.
</p>

<p>
`~server$は、応答~内に，［
その異なる~URI用の`~URI参照$を包含する， `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
その異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

			</section>
			<section id="status.308">
<h4>14.4.9. `308^st</h4>

<p>
`状態s~code$ `308^st は、次を指示する
⇒
`~target資源$には，新たな恒久的~URIがアテガわれていて、この資源への未来の参照は，同封された いずれかの~URIを利用する~OUGHT。
◎
The 308 (Permanent Redirect) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.＼
</p>

<p>
~link編集~能力を備えている`~client$は、アリな所では，［
`~target~URI$への参照
］を［
`~server$から送信されてきた，1 個以上の新たな参照
］へ自動的に~linkし直す~OUGHT。
◎
Clients with link editing capabilities ought to automatically re-link references to the target URI to one or more of the new references sent by the server, where possible.
</p>

<p>
`~server$は、応答~内に［
新たな恒久的~URI用に選好される`~URI参照$を包含している `Location$h ~header
］を生成するベキである。
`~UA$は、 `Location^h `~field値$を自動的~redirection用に利用してもヨイ。
~serverの応答`~payload$は、通例的に［
新たな~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>

<p>
`308^st0 応答は、`経験的に~cache可能$である。
◎
A 308 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

<p class="note">注記：
この状態s~codeは~~同類の~codeよりもずっと~~若い（ 2014 年 6 月）ので、どこでも認識されるとは限らない。
配備~上の考慮点については、 `RFC7538/4$sec を見よ。
◎
Note: This status code is much younger (June 2014) than its sibling codes, and thus might not be recognized everywhere. See Section 4 of [RFC7538] for deployment considerations.
</p>

			</section>
		</section>
		<section id="status.4xx">
<h3 title="Client Error 4xx">14.5. `4xx^st</h3>

<p>
`応答class$ `4xx^st に属する`状態s~code$は、［
`~client$による~errorに見える
］ことを指示する。
`HEAD$m 要請に対し応答するときを除いて、`~server$は，［［
その~error状況の説明，および
その条態は［
一時的, 恒久的
］のどちらなのか
］を包含している`表現$
］を送信するベキである。
これらの状態s~codeは、どの`要請~method$にも適用-可能である。
`~UA$は、内包された どの表現も，利用者に表示するベキである。
◎
The 4xx (Client Error) class of status code indicates that the client seems to have erred. Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents SHOULD display any included representation to the user.
</p>

			<section id="status.400">
<h4>14.5.1. `400^st</h4>

<p>
`状態s~code$ `400^st は、次を指示する
⇒
`~server$は、~client~errorに知覚される何かに因り，要請を処理できないか, するつもりがない（例：
要請の構文が~~正しくない ／
要請~message~frame法が妥当でない ／
要請の~route法が~~誤認を誘うものである，など）。
◎
The 400 (Bad Request) status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
</p>

			</section>
			<section id="status.401">
<h4>14.5.2. `401^st</h4>

<p>
`状態s~code$ `401^st は、次を指示する
⇒
要請は、`~target資源$用の妥当な認証用の`資格証$を欠如するため，まだ適用されていない。
◎
The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.＼
</p>

<p>
`401^st0 応答を`生成し$ている`~server$は、次を包含する `WWW-Authenticate$h ~headerを送信しなければナラナイ
⇒
`~target資源$に適用-可能な，
1 個~以上の `challenge$p
◎
The server generating a 401 response MUST send a WWW-Authenticate header field (Section 10.6.1) containing at least one challenge applicable to the target resource.
</p>

<div class="p">
<p>
要請が認証用の`資格証$を内包していた場合、 `401^st0 応答は，［
その`資格証$に対する権限付与は，拒否された
］ことを指示する。
`~UA$は，その応答に対し：
◎
If the request included authentication credentials, then the 401 response indicates that authorization has been refused for those credentials.＼
</p>
<ul>
	<li>
次を伴わせた上で，同じ要請を繰返してもヨイ
⇒
新たな, または他の値に置換された `Authorization$h ~header
◎
The user agent MAY repeat the request with a new or replaced Authorization header field (Section 10.6.2).＼
</li>
	<li>
［
その `401^st0 応答が，それに先立つ応答と同じ `challenge$p を包含する
］, かつ［
~UAは，認証をすでに 1 回は試みていた
］場合、同封された表現を利用者に呈示するベキである
— それは、通例的に，関連な診断~情報を包含するので。
◎
If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information.
</li>
</ul>
</div>

			</section>
			<section id="status.402">
<h4>14.5.3. `402^st</h4>

<p>
`状態s~code$ `402^st は、将来~利用のために予約-済みにされる。
◎
The 402 (Payment Required) status code is reserved for future use.
</p>

			</section>
			<section id="status.403">
<h4>14.5.4. `403^st</h4>

<p>
`状態s~code$ `403^st は、次を指示する
⇒
`~server$は、要請を解したが，その履行-を拒否している。
◎
The 403 (Forbidden) status code indicates that the server understood the request but refuses to fulfill it.＼
</p>

<p>
`~server$は、要請が何故 禁止されたか 公にしたいと望むならば，［
その事由を，応答の~payload（もしあれば）内に述べる
］ことができる。
◎
A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).
</p>

<p>
［
要請~内に認証用の`資格証$が供されていた
］場合、~serverは，［
それは，~accessを是認するには足らない
］と見なしている。
`~client$は、［
同じ資格証を伴わせた要請
］を，自動的に繰返すベキでない。
~clientは、［
新たな／異なる
］資格証を伴わせるのであれば，要請を繰返してもヨイ。
しかしながら、資格証に無関係な理由により，要請が禁止されることもある。
◎
If authentication credentials were provided in the request, the server considers them insufficient to grant access. The client SHOULD NOT automatically repeat the request with the same credentials. The client MAY repeat the request with new or different credentials. However, a request might be forbidden for reasons unrelated to the credentials.
</p>

<p>
`生成元~server$は、禁止された`~target資源$の現在の存在を “隠したい” と望むときは，代わりに［
`404$st
］で応答してもヨイ。
◎
An origin server that wishes to "hide" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).
</p>

			</section>
			<section id="status.404">
<h4>14.5.5. `404^st</h4>

<p>
`状態s~code$ `404^st は、次を指示する
⇒
`生成元~server$は、［
`~target資源$用に現在の`表現$を見出せなかった
］か［
~target資源が存在することを開示する用意はない
］。
◎
The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.＼
</p>

<p>
`404^st0 は、この［
表現の欠如
］は［
一時的, 恒久的
］のどちらなのかは，指示しない。
`生成元~server$が，その条態は恒久的になる見込みが高いことを
— 大概は何らかの環境設定し得る手段を通して —
知る場合、
`404^st0 よりも `410$st が選好される。
◎
A 404 status code does not indicate whether this lack of representation is temporary or permanent; the 410 (Gone) status code is preferred over 404 if the origin server knows, presumably through some configurable means, that the condition is likely to be permanent.
</p>

<p>
`404^st0 応答は、`経験的に~cache可能$である。
◎
A 404 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.405">
<h4>14.5.6. `405^st</h4>

<p>
`状態s~code$ `405^st は、次を指示する
⇒
【！`request-line$p 内に】
受信した~methodは、`生成元~server$に既知ではあるが，`~target資源$においては~supportされない。
◎
The 405 (Method Not Allowed) status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource.＼
</p>

<p>
`生成元~server$は、 `405^st0 応答~内に，次を包含する `Allow$h ~headerを`生成し$なければナラナイ
⇒
~target資源が現在~supportしている~methodたちが成す~list
◎
The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.
</p>

<p>
`405^st0 応答は、`経験的に~cache可能$である。
◎
A 405 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.406">
<h4>14.5.7. `406^st</h4>

<p>
`状態s~code$ `406^st は、次を指示する
⇒
`~target資源$の現在の`表現$には，［
要請~内に受信された`~proactive折衝~header$に則って，`~UA$に受容-可能になるもの
］は無いことに加え、`~server$は，既定の表現を給する用意はない。
◎
The 406 (Not Acceptable) status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request (Section 11.1), and the server is unwilling to supply a default representation.
</p>

<p>
`~server$は、次を包含する~payloadを`生成する$ベキである
⇒
［
利用者／`~UA$
］が最も適切なものを選べるような［
可用な表現~特性の~list
］と，そのそれぞれに対応する資源~識別子
◎
The server SHOULD generate a payload containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate.＼
</p>

<p>
`~UA$は、この~listから，最も適切な選択肢を自動的に選定してもヨイ。
しかしながら，状態s~code `300$st にて述べたように、この仕様は，そのような自動~選定~用の どのような標準も定義しない。
◎
A user agent MAY automatically select the most appropriate choice from that list. However, this specification does not define any standard for such automatic selection, as described in Section 14.4.1.
</p>

			</section>
			<section id="status.407">
<h4>14.5.8. `407^st</h4>

<p>
`状態s~code$ `407^st は、 `401$st に類似するが，次を指示する
⇒
`~client$は、【！＊】この要請~用に`~proxy$を利用するためには，自身を認証してもらう必要がある。
◎
The 407 (Proxy Authentication Required) status code is similar to 401 (Unauthorized), but it indicates that the client needs to authenticate itself in order to use a proxy for this request.＼
</p>
<ul>
	<li>
`~proxy$は、当の要請~用に
`Proxy-Authenticate$h ~headerを
— 自身に適用-可能な `challenge$p を包含して —
送信しなければナラナイ。
◎
The proxy MUST send a Proxy-Authenticate header field (Section 10.7.1) containing a challenge applicable to that proxy for the request.＼
</li>
	<li>
`~client$は、次を伴わせた上で，同じ要請を繰返してもヨイ
⇒
新たな, または他の値に置換された，
`Proxy-Authorization$h ~header
◎
The client MAY repeat the request with a new or replaced Proxy-Authorization header field (Section 10.7.2).
</li>
</ul>

			</section>
			<section id="status.408">
<h4>14.5.9. `408^st</h4>

<p>
`状態s~code$ `408^st は、次を指示する
⇒
`~server$は、待機するよう準備された時間~内に，要請~messageを`完全$に受信しなかった。
◎
The 408 (Request Timeout) status code indicates that the server did not receive a complete request message within the time that it was prepared to wait.＼
</p>

<p>
`~client$は、応答待ち要請があれば，同じ要請を新たな接続~上にて繰返してもヨイ。
◎
If the client has an outstanding request in transit, the client MAY repeat that request on a new connection.
</p>

			</section>
			<section id="status.409">
<h4>14.5.10. `409^st</h4>

<p>
`状態s~code$ `409^st は、次を指示する
⇒
`~target資源$の現在の状態との競合に因り，要請を完了できなかった。
◎
The 409 (Conflict) status code indicates that the request could not be completed due to a conflict with the current state of the target resource.＼
</p>

<p>
この~codeは、［
利用者は、競合を解決して，要請を提出し直せる
］ような状況で利用される。
`~server$は、［
利用者が競合の源を認識するに十分な情報
］を内包する~payloadを`生成する$ベキである。
◎
This code is used in situations where the user might be able to resolve the conflict and resubmit the request. The server SHOULD generate a payload that includes enough information for a user to recognize the source of the conflict.
</p>

<p>
競合は、
`PUT$m 要請に対する応答にて生じる見込みが最も高い。
例えば，`生成元~server$は、~version法が利用されている下で［
`PUT$m している`表現$が，［
~~以前に（第三者主体からの）要請により~~行われたもの
］と競合するような，資源への変更を含む
］場合に，［
要請を完了できないことを指示する `409^st0 応答
］を利用できる。
この事例では，応答の`表現$は、［
改訂~履歴に基づいて，相違点を併合する
］ために有用になる情報を包含することになる見込みが高い。
◎
Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the representation being PUT included changes to a resource that conflict with those made by an earlier (third-party) request, the origin server might use a 409 response to indicate that it can't complete the request. In this case, the response representation would likely contain information useful for merging the differences based on the revision history.
</p>

			</section>
			<section id="status.410">
<h4>14.5.11. `410^st</h4>

<p>
`状態s~code$ `410^st は、次を指示する
⇒
`生成元~server$における`~target資源$への~accessは，もはや可用でなく、その条態は恒久的になる見込みが高い。
◎
The 410 (Gone) status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.＼
</p>

<p>
`生成元~server$は、条態が恒久的になるかどうかについて判らない場合は，代わりに `404$st を利用する~OUGHT。
◎
If the origin server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) ought to be used instead.
</p>

<p>
`410^st0 応答は、首に，~web保守の~taskを支援するために意図されており、`受信者$に向けて，［
資源は意図的に可用でなくされ，~server所有者が［
その資源への遠隔~linkは除去される
］ことを欲している
］ことを通知する。
そのような~eventは、臨時の販促~serviceや, ［
個々人に所属する資源が，もはや `生成元~server$の~siteに結付けられなくなったとき
］に，共通的にある。
恒久的に可用でない資源すべてを，［
“~~消失した” ものと~markしたり，その~markをいつまでも保つ
］ことは、必要とされない
— それは、~server所有者の裁量に~~委ねられる。
◎
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer associated with the origin server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time — that is left to the discretion of the server owner.
</p>

<p>
`410^st0 応答は、`経験的に~cache可能$である。
◎
A 410 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.411">
<h4>14.5.12. `411^st</h4>

<p>
`状態s~code$ `411^st は、次を指示する
⇒
`~server$は、
`Content-Length$h が定義されてない要請の受容-を拒否した。
◎
The 411 (Length Required) status code indicates that the server refuses to accept the request without a defined Content-Length (Section 7.7).＼
</p>

<p>
`~client$は、同じ要請を，次を追加した上で繰返してもヨイ
⇒
`~message本体$の長さを包含する，妥当な `Content-Length$h ~header
◎
The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message body in the request message.
</p>

			</section>
			<section id="status.412">
<h4>14.5.13. `412^st</h4>

<p>
`状態s~code$ `412^st は、次を指示する
⇒
ある`条件付き要請~header$にて与えられた条件が，`~server$上で~testされたときに偽に`評価-$された。
◎
The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server.＼
</p>

<p>
この応答~状態s~codeは、`~client$に次を許容する
⇒
現在の`資源$の状態（資源の現在の`表現$と~metadata）に対し，`事前条件$を設置して、`~target資源$が期待されない状態にある場合には，`要請~method$は適用されないようにする。
◎
This response status code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.
</p>

			</section>
			<section id="status.413">
<h4>14.5.14. `413^st</h4>

<p>
`状態s~code$ `413^st は、次を指示する
⇒
要請の~payloadは，`~server$が［
処理できる／処理する用意がある
］ものより巨大なため、~serverは，要請を処理するのを拒否している。
◎
The 413 (Payload Too Large) status code indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process.＼
</p>

<p>
`~server$は
⇒＃
利用-中の~protocol~versionが許容するならば，要請を終了してもヨイ／
他の場合、接続を~closeしてもヨイ
◎
The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.
</p>

<p>
条態が一時的である場合，`~server$は、
`Retry-After$h ~headerを`生成し$て，次を指示するベキである
⇒
条態は一時的であること, および`~client$は いつ再び試行してよいか
◎
If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.
</p>

			</section>
			<section id="status.414">
<h4>14.5.15. `414^st</h4>

<p>
`状態s~code$ `414^st は、次を指示する
⇒
`~target~URI$は，`~server$が解釈する用意がある~~長さより長いため、~serverは，要請に対する~serviceを拒否している。
◎
The 414 (URI Too Long) status code indicates that the server is refusing to service the request because the target URI is longer than the server is willing to interpret.＼
</p>

<p>
この稀な条態が生じるのは、ほぼ，次のときに限られる：
◎
This rare condition is only likely to occur＼
</p>
<ul>
	<li>
~clientが `POST$m 要請を，不適正に，長い `query$p 情報を伴う `GET$m 要請に変換した。
◎
when a client has improperly converted a POST request to a GET request with long query information,＼
</li>
	<li>
~clientが~redirectionの “無限loop” に陥った（例：
~URI接頭辞の~redirect先が，接頭辞~自身に接尾辞を付加したものになっている）。
◎
when the client has descended into a "black hole" of redirection (e.g., a redirected URI prefix that points to a suffix of itself) or＼
</li>
	<li>
~clientが~~可能性のある~securityの穴を悪用しようと，~serverを攻撃している。
◎
when the server is under attack by a client attempting to exploit potential security holes.
</li>
</ul>

<p>
`414^st0 応答は、`経験的に~cache可能$である。
◎
A 414 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.415">
<h4>14.5.16. `415^st</h4>

<p>
`状態s~code$ `415^st は、次を指示する
⇒
`~target資源$に対しては，［
要請の~payloadは，要請の~methodが~supportする形式ではない
］ため、`生成元~server$は，要請に対する~serviceを拒否している。
◎
The 415 (Unsupported Media Type) status code indicates that the origin server is refusing to service the request because the payload is in a format not supported by this method on the target resource.
</p>

<p>
形式の問題は、［
要請が指示した
`Content-Type$h ／ `Content-Encoding$h
］に因ることも, ［
要請の~dataを直に検分した結果
］に因ることもある
— 当の問題が：
◎
The format problem might be due to the request's indicated Content-Type or Content-Encoding, or as a result of inspecting the data directly.
</p>
<ul>
	<li>
~supportされない`内容~符号法$によるものである場合
⇒
`Accept-Encoding$h 応答~headerを利用して，どの`内容~符号法$が（もし在れば）要請~内に受容されるかを指示する~OUGHT。
◎
If the problem was caused by an unsupported content coding, the Accept-Encoding response header field (Section 11.1.4) ought to be used to indicate what (if any) content codings would have been accepted in the request.
</li>
	<li>
~supportされない`~MIME型$によるものである場合
⇒
`Accept$h 応答~headerを利用して，どの~MIME型が要請~内に受容されるかを指示できる。
◎
On the other hand, if the cause was an unsupported media type, the Accept response header field (Section 11.1.2) can be used to indicate what media types would have been accepted in the request.
</li>
</ul>

			</section>
			<section id="status.416">
<h4>14.5.17. `416^st</h4>

<p>
`状態s~code$ `416^st は、次を指示する
⇒
要請の `Range$h ~header にて要請された範囲の集合は、次のいずれかに該当するので却下された
⇒＃
`満足可能$な範囲は無い／
過度に［~~細切れであるか重合している］（~DoS攻撃にもなり得る）
◎
The 416 (Range Not Satisfiable) status code indicates that the set of ranges in the request's Range header field (Section 13.2) has been rejected either because none of the requested ranges are satisfiable or because the client has requested an excessive number of small or overlapping ranges (a potential denial of service attack).
</p>

<p>
各 `範囲~単位$が、その単位に基づく範囲~集合が
`満足可能@
になるためには何が要求されるかを定義する。
例えば，`~byte範囲$secは、~byte範囲の集合は，何をもって満足可能とされるかを定義する。
◎
Each range unit defines what is required for its own range sets to be satisfiable. For example, Section 13.1.2 defines what makes a bytes range set satisfiable.
</p>

<p>
`送信者$は、この`状態s~code$を［
`~byte範囲$の要請に対する応答
］内に`生成する$ときは，［
`選定された表現$の現在の長さ
］を指定する `Content-Range$h ~headerを`生成する$ベキである。
◎
When this status code is generated in response to a byte-range request, the sender SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 13.4).
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
</pre>
</div>

<p class="note">注記：
~serverが `Range$h を無視するのは自由なので、多くの実装は
`200$st 応答において，`選定された表現$ ~~全体で応答する。
その~~理由の一部は、ほとんどの~clientが，（たとえ~~効率が落ちるとしても）
`200$st を受信して~taskを完了するように準備されているためであり、また，~clientには［
`完全$な表現を受信するまで，妥当でない部分的~要請【`範囲~要請$】を為すのを停止しない
］ものもあるためである。
したがって，~clientは、それが最も適切になるときでも，
`416$st 応答の受信には依存できない。
◎
Note: Because servers are free to ignore Range, many implementations will respond with the entire selected representation in a 200 (OK) response. That is partly because most clients are prepared to receive a 200 (OK) to complete the task (albeit less efficiently) and partly because clients might not stop making an invalid partial request until they have received a complete representation. Thus, clients cannot depend on receiving a 416 (Range Not Satisfiable) response even when it is most appropriate.
</p>

			</section>
			<section id="status.417">
<h4>14.5.18. `417^st</h4>

<p>
`状態s~code$ `417^st は、次を指示する
⇒
`内方$にある いずれかの`~server$にて，［
要請の `Expect$h ~header内に与えられた期待
］に応えられなかった。
◎
The 417 (Expectation Failed) status code indicates that the expectation given in the request's Expect header field (Section 9.1.1) could not be met by at least one of the inbound servers.
</p>

			</section>
			<section id="status.418">
<h4>14.5.19. `418^st0 （利用されない）</h4>

<p>
`RFC2324$r は、~HTTPを濫用する様々な仕方を~~風刺した `April 1^en RFC であった。
そのような濫用の一つは、応用に特有な `418^st0 状態s~codeの定義であった。
年月を経て、この状態s~codeは “`Easter Egg^en” として広範に実装されており，実質的にこの利用に消費されている。
◎
[RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code. In the intervening years, this status code has been widely implemented as an "Easter Egg", and therefore is effectively consumed by this use.
</p>

<p>
したがって，状態s~code `418^st0 は、~IANA
`~HTTP状態s~code~registry$cite
にて予約される。
すなわち，現時点では、この状態s~codeには，他の応用はアテガえないことを指示する。
将来の状況下で，その利用が要求された場合（例： `4xx^st0 状態s~codeが枯渇した）、別の利用が再びアテガわれ得る。
◎
Therefore, the 418 status code is reserved in the IANA HTTP Status Code Registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use.
</p>

			</section>
			<section id="status.422">
<h4>14.5.20. `422^st</h4>

<p>
`状態s~code$ `422^st は、次を指示する
⇒
［
`~server$は，要請~payloadの内容~型を解した（よって，状態s~code `415$st は適切でない）
］かつ［
要請~payloadの構文は正しい
］が、それが包含する指示書きは処理-不能である。
◎
The 422 (Unprocessable Payload) status code indicates that the server understands the content type of the request payload (hence a 415 (Unsupported Media Type) status code is inappropriate), and the syntax of the request payload is correct, but was unable to process the contained instructions.＼
</p>

<p>
この状態s~codeは、例えば，~XML要請~payloadの内容は整形式である（すなわち、構文上は正しい）が，意味論的には~~誤った~XML指示書きである場合に生じる。
◎
For example, this status code can be sent if an XML request payload contains well-formed (i.e., syntactically correct), but semantically erroneous XML instructions.
</p>

			</section>
			<section id="status.426">
<h4>14.5.21. `426^st</h4>

<p>
`状態s~code$ `426^st は、次を指示する
⇒
`~server$は、［
現在の~protocolの下では，要請の遂行-を拒否した
］が，［
`~client$が異なる~protocolに昇格した後には，そうする用意がある
］かもしれない。
◎
The 426 (Upgrade Required) status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.＼
</p>

<p>
`~server$は、 `426^st0 応答~内に［
要求される~protocol（たち）を指示する， `Upgrade$h ~header
］を送信しなければナラナイ。
◎
The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 6.6).
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
【この~serviceには HTTP/3.0 ~protocolの利用が要求されます。】
</pre>
</div>

			</section>
		</section>
		<section id="status.5xx">
<h3 title="Server Error 5xx">14.6. `5xx^st</h3>

<p>
`応答class$ `5xx^st に属する`状態s~code$は、次を指示する
⇒
`~server$は、自身の~errorを自覚したか，要請された~methodを遂行する能力を備えていない。
◎
The 5xx (Server Error) class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method.＼
</p>

<p>
`HEAD$m 要請に対し応答するときを除いて、`~server$は，次を包含している`表現$を送信するベキである
⇒
その~error状況の説明,
その条態は［
一時的, 恒久的
］のどちらなのか
◎
Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.＼
</p>

<p>
`~UA$は、内包された表現があれば，それを利用者に表示するベキである。
◎
A user agent SHOULD display any included representation to the user.＼
</p>

<p>
これらの状態s~codeは、どの`要請~method$にも適用-可能である。
◎
These response codes are applicable to any request method.
</p>

			<section id="status.500">
<h4>14.6.1. `500^st</h4>

<p>
`状態s~code$ `500^st は、次を指示する
⇒
`~server$は、予期しない条態に遭遇して，要請を履行できなくなった。
◎
The 500 (Internal Server Error) status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.
</p>

			</section>
			<section id="status.501">
<h4>14.6.2. `501^st</h4>

<p>
`状態s~code$ `501^st は、次を指示する
⇒
`~server$は、要請を履行するために要求される機能性を~supportしない。
◎
The 501 (Not Implemented) status code indicates that the server does not support the functionality required to fulfill the request.＼
</p>

<p>
これは、次のときに適切な応答になる
⇒
~serverは，当の`要請~method$を認識せず、どの資源にも それを~supportする能力はない
◎
This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
</p>

<p>
`501^st0 応答は、`経験的に~cache可能$である。
◎
A 501 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.502">
<h4>14.6.3. `502^st</h4>

<p>
`状態s~code$ `502^st は、次を指示する
⇒
［
`~gateway$／`~proxy$
］として動作している`~server$が、要請を履行しようと試みているときに，自身が~accessした`内方$にある~serverから妥当でない応答を受信した。
◎
The 502 (Bad Gateway) status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
</p>

			</section>
			<section id="status.503">
<h4>14.6.4. `503^st</h4>

<p>
`状態s~code$ `503^st は、次を指示する
⇒
`~server$は、いくばくかの遅延~後に軽減される見込みが高い［
一時的な過負荷／~scheduleされた保守
］に因り，現在 要請を取扱えない。
◎
The 503 (Service Unavailable) status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.＼
</p>

<p>
`~server$は、 `Retry-After$h ~headerを送信して，次を示唆してもヨイ
⇒
`~client$が要請を再試行する前に待機する，適量な時間
◎
The server MAY send a Retry-After header field (Section 9.2.4) to suggest an appropriate amount of time for the client to wait before retrying the request.
</p>

<p class="note">注記：
状態s~code `503^st0 の存在は、［
過負荷~時には，その利用が~serverに要求される
］ことを含意するわけではない。
単純に接続を拒否する~serverもあり得る。
◎
Note: The existence of the 503 status code does not imply that a server has to use it when becoming overloaded. Some servers might simply refuse the connection.
</p>

			</section>
			<section id="status.504">
<h4>14.6.5. `504^st</h4>

<p>
`状態s~code$ `504^st は、次を指示する
⇒
［
`~gateway$／`~proxy$
］として動作している~serverが，［
要請を完了するために~accessする必要がある，`上流$にある~server
］から適時に応答を受信できなかった。
◎
The 504 (Gateway Timeout) status code indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.
</p>

			</section>
			<section id="status.505">
<h4>14.6.6. `505^st</h4>

<p>
`状態s~code$ `505^st は、次を指示する
⇒
`~server$は、［
要請~message内に利用された~HTTP`~major~version$
］を［
~supportしない／~supportを拒否した
］。
◎
The 505 (HTTP Version Not Supported) status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message.＼
</p>

<p>
`~server$は、［
`~client$と同じ`~major~version$を利用するどの要請も，この~error~message以外では 完了できない／する用意はない
］ことを指示している（ `5.1$sec を見よ）。
~serverは、
`505^st0 応答に対しては，［
その~versionが何故~supportされないか, および
自身が~supportする他の~protocol
］について述べる`表現$を`生成する$ベキである。
◎
The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 5.1, other than with this error message. The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.
</p>

			</section>
		</section>
	</section>
</main></div>
