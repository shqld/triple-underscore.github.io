<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style>
.html-code.bad {
	color: gray;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		persisted_parts: Util.collectHtmlCodeList(),
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a':
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'h':
	text = `<code class="header">${text}</code>`;
	break;
case 'xCode':
	return `<a id="_ex-${key}">＊</a>`;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2019-07-02
trans_update:2019-07-03
source_checked:180514
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/interaction.html
	abbr_url:HTMLinteraction
site_nav:uievents,html
nav_prev:HTMLselectors
nav_next:HTMLdnd
trans_1st_pub:2016-11-06


●●class_map
e:element
a:attr
et:event-type
p:property
st:attr-state
aH:attr-state
css:css
v:value
E:error
h:header

●●tag_map
I:code
m:code
E:code
c:code
e:code
a:code
et:code
st:span
aH:span
h:code
p:code
css:code
samp:samp
v:code
i:i
kbd:kbd

●●original_id_map


dom-document-designmode:designMode


●●link_map


E.SyntaxError:~WEBIDL#syntaxerror

I.Document:~HTMLdom#document
I.ElementContentEditable:#elementcontenteditable
I.Element:~DOM4#interface-element
I.FocusEvent:~UIEVENTS#focusevent
I.Node:~DOM4#interface-node
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window
I.Selection:~SELECTIONAPI#selection
I.FocusOptions:#focusoptions

CEReactions:~HEcustom#cereactions


	■DOM
m.isTrusted:~DOM4#dom-event-istrusted
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type
m.accessKey:#dom-accesskey
m.accessKeyLabel:#dom-accesskeylabel
m.activeElement:#dom-document-activeelement
m.autocapitalize:#dom-autocapitalize
m.~blur0:#dom-blur
m.blur:#dom-window-blur
m.~focus0:#dom-focus
m.enterKeyHint:#dom-enterkeyhint
m.focus:#dom-window-focus
m.click:#dom-click
m.contentEditable:#dom-contenteditable
m.hasFocus:#dom-document-hasfocus
m.hidden:#dom-hidden
m.isContentEditable:#dom-iscontenteditable
m.inputMode:#dom-inputmode
m.preventScroll:#dom-focusoptions-preventscroll

	m.execCommand:#execCommand
m.execCommand:~EXEC-COMMAND#execcommand%28%29
m.queryCommandEnabled:~EXEC-COMMAND#dom-document-querycommandenabled%28%29
m.queryCommandIndeterm:~EXEC-COMMAND#dom-document-querycommandindeterm%28%29
m.queryCommandState:~EXEC-COMMAND#dom-document-querycommandstate%28%29
m.queryCommandSupported:~EXEC-COMMAND#dom-document-querycommandsupported%28%29
m.queryCommandValue:~EXEC-COMMAND#dom-document-querycommandvalue%28%29

m.spellcheck:#dom-spellcheck
m.tabIndex:#dom-tabindex

m.relatedTarget:~UIEVENTS#dom-focusevent-relatedtarget
m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view
m.showModal:~HEinteractive#dom-dialog-showmodal
m.designMode:#dom-document-designmode
~designMode:#designMode

	■css
p.outline:~CSSUI#outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.white-space:~CSSTEXT#white-space-property

	■e
e.a:~HEtextlevel#the-a-element

e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element

e.body:~HEsections#the-body-element

e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.form:~HEforms#the-form-element
e.label:~HEforms#the-label-element
e.output:~HEforms#the-output-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.div:~HEgrouping#the-div-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.video:~HEmedia#the-video-element

	■#attr-
a.autocapitalize:#attr-autocapitalize
a.contenteditable:#attr-contenteditable
a.enterkeyhint:#attr-enterkeyhint
a.inputmode:#attr-inputmode
a.form:~HTMLforms#attr-fae-form
a.href:~HTMLlinks#attr-hyperlink-href
a.~href0:~HEmetadata#attr-link-href
a.pattern:~HEinput#attr-input-pattern
a.readonly:~HEinput#attr-input-readonly
a.~readonly0:~HEforms#attr-textarea-readonly
a.spellcheck:#attr-spellcheck
a.src:~HEimages#attr-img-src
a.tabindex:#attr-tabindex
a.title:~HTMLdom#attr-title
a.type:~HEinput#attr-input-type

a.accesskey:#the-accesskey-attribute
a.hidden:#the-hidden-attribute
a.aria-describedby:~ARIA1#aria-describedby

a.draggable:~HTMLdnd#the-draggable-attribute

v.none:#attr-inputmode-keyword-none
v.text:#attr-inputmode-keyword-text
v.tel:#attr-inputmode-keyword-tel
v.url:#attr-inputmode-keyword-url
v.email:#attr-inputmode-keyword-email
v.numeric:#attr-inputmode-keyword-numeric
v.decimal:#attr-inputmode-keyword-decimal
v.search:#attr-inputmode-keyword-search

v.off:#attr-autocapitalize-off
v.~noneC:#attr-autocapitalize-none
v.on:#attr-autocapitalize-on
v.sentences:#attr-autocapitalize-sentences
v.words:#attr-autocapitalize-words
v.characters:#attr-autocapitalize-characters

v.enter:#attr-enterkeyhint-keyword-enter
v.done:#attr-enterkeyhint-keyword-done
v.go:#attr-enterkeyhint-keyword-go
v.next:#attr-enterkeyhint-keyword-next
v.previous:#attr-enterkeyhint-keyword-previous
v.~search0:#attr-enterkeyhint-keyword-search
v.send:#attr-enterkeyhint-keyword-send

	■event
et.blur:~HTMLindex#event-blur
et.change:~HTMLindex#event-change
et.focus:~HTMLindex#event-focus
et.reset:~HTMLindex#event-reset
et.submit:~HTMLindex#event-submit
et.contextmenu:~HTMLindex#event-contextmenu
et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseup:~UIEVENTS#event-type-mouseup
et.mousemove:~UIEVENTS#event-type-mousemove
et.mouseover:~UIEVENTS#event-type-mouseover
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.touchend:~TOUCHEVENTS#event-touchend

st.Email:~HEinput#e-mail-state-(type=email)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Url:~HEinput#url-state-(type=url)

aH.既定:#autocap-hint-default
aH.なし:#autocap-hint-none
aH.一文ごと:#autocap-hint-sentences
aH.単語ごと:#autocap-hint-words
aH.文字ごと:#autocap-hint-characters


cF.動作:~HEinteractive#command-facet-action
cF.不能化~状態:~HEinteractive#command-facet-disabledstate
cF.隠d状態:~HEinteractive#command-facet-hiddenstate

	■
文書:~HTMLdom#the-document-object
要素:#_element
~tabindex値:#_focusable-area-tabindex-value


利用者の作動化により誘発され:#triggered-by-user-activation
アテガわれている~access~Key:#assigned-access-key
~modal~dialogにより阻まれ:#blocked-by-a-modal-dialog


編集-可能:~EXEC-COMMAND#editable
編集中の~host:~EXEC-COMMAND#editing-host
属する編集中の~host:~EXEC-COMMAND#editing-host-of
作動範囲:~EXEC-COMMAND#active-range
選択を削除-:~EXEC-COMMAND#delete-the-selection

	＊作動範囲:#active-range


明に不活:#expressly-inert
	dlg.明に不活:#expressly-inert-dialog

~task:~WAPI#concept-task
~queueされ:~WAPI#queue-a-task
~click~eventを発火-:~WAPI#fire-a-click-event
~click~eventを発火する:~WAPI#fire-a-click-event
~focus~eventを発火する:#fire-a-focus-event
合成~mouse~eventを発火する:~WAPI#fire-a-synthetic-mouse-event
関連な大域~obj:~WAPI#concept-relevant-global

~click進捗中~flag:#click-in-progress-flag

~DOM~anchor:#dom-anchor
~focus鎖:#focus-chain
~focusを獲得した:#gains-focus
~focusを得ている:#has-focus-steps
~focusされて:#focused

~focus可能な区画:#focusable-area
~focus可能な区画の順序:#_focusable-area-order
~focus可能な図形:#_focusable-shape

~top-level閲覧文脈の現在の被focus区画:#currently-focused-area-of-a-top-level-browsing-context
現在の被focus区画:#currently-focused-area-of-a-top-level-browsing-context
指名する被focus区画:#focused-area-of-the-document

~focusを更新する:#focus-update-steps
~objを~unfocusする:#unfocusing-steps
~objを~focusする:#focusing-steps

	:#bc-focus-ergo-bcc-focus

~home逐次的~focus~navi順序:#home-sequential-focus-navigation-order
~home文書:#home-document
相応しい逐次的に~focus可能な区画:#suitable-sequentially-focusable-area

~focus~lock~flag:#locked-for-focus
逐次的~focus~navi順序:#sequential-focus-navigation-order
逐次的~focus~naviの始点:#sequential-focus-navigation-starting-point
始点:#sequential-focus-navigation-starting-point
逐次的~focus~navi:#sequential-focus-navigation
~tabindex~focus~flag:#specially-focusable
~focus修復~規則:#focus-fixup-rule
	適切になるなら:#concept-platform-dropeffect-override
	concept-platform-dropeffect-override-

不活:#inert
不活ness:#inert-
既定の挙動:#concept-spellcheck-default
既定で継承する:#concept-spellcheck-default-inherit
既定で行う:#concept-spellcheck-default-true
既定で行わない:#concept-spellcheck-default-false

逐次的~navi探索~algo:#sequential-navigation-search-algorithm
~source~node:#source-node


自動頭字化~hint:#autocapitalization-hint
自前の自動頭字化~hint:#own-autocapitalization-hint
使用~自動頭字化~hint:#used-autocapitalization-hint
自動頭字化-を継承-:~HEforms#category-autocapitalize


	●DOM/CSS
表示域:~CSS2VISUREN#viewport
~box~tree:~CSSDISP#box-tree
~CSS~box:~CSSDISP#box
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view

~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
文書~内にある:~DOM4#in-a-document
文書~要素:~DOM4#document-element
配送-:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior
接続されて:~DOM4#connected
~shadowも含む子孫:~DOM4#concept-shadow-including-descendant
~composed~flag:~DOM4#composed-flag

	●HTML
閲覧文脈~容器:~BROWSERS#browsing-context-container
入子にしている閲覧文脈~容器:~BROWSERS#browsing-context-nested-through
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
子~閲覧文脈:~BROWSERS#child-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
入子にして:~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
作動中の文書:~BROWSERS#active-document
対応する閲覧文脈:~WINDOW#window-bc

~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace

~HTML要素:~HTMLINFRA#html-elements
大小区別:~HTMLINFRA#case-sensitive
即時に:~HTMLINFRA#immediately
~live:~HTMLINFRA#live
反映する:~HTMLcdom#reflect
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

列挙d属性:~HTMLcms#enumerated-attribute
真偽~属性:~HTMLcms#boolean-attribute
妥当でない値~用の既定:~HTMLcms#invalid-value-default
値なし用の既定:~HTMLcms#missing-value-default
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
一意な~tokenからなる空白区切りの有順序~集合:~HTMLcms#ordered-set-of-unique-space-separated-tokens
妥当な整数:~HTMLcms#valid-integer

不能化され:~HTMLforms#concept-fe-disabled
変異-可能:~HTMLforms#concept-fe-mutable
fe.値:~HTMLforms#concept-fe-value
~form所有者:~HTMLforms#form-owner

選択-中の~fileの~list:~HEinput#concept-input-type-file-selected
	~HEtextlevel#the-a-element
	~HEinput#number-state-(type=number)
	~HEinput#range-state-(type=range)
	~HEinput#text-(type=text)-state-and-search-state-(type=search)
	適用される:~HEinput#concept-input-apply

~commandを定義する:~HEinteractive#concept-command
~modal~dialogが示され:~HEinteractive#dom-dialog-showmodal
	公開することもある:~HEinteractive#expose-commands-in-ui

	関連な~canvas~fallback内容として利用中にある:~HEcanvas#being-used-as-relevant-canvas-fallback-content

不能化-:~HTMLselectors#concept-element-disabled

~UIにより利用者に公開されている~control:~HEmedia#expose-a-user-interface-to-the-user

~body要素:~HTMLdom#the-body-element-2
対話的~内容:~HTMLdom#interactive-content-2

具現化され:~HTMLrendering#being-rendered
具現化されて:~HTMLrendering#being-rendered
	具現化~節にて示唆されている規則:~HTMLrendering#hiddenCSS
~hyperlink:~HTMLlinks#hyperlink
画像~map:~HEimages#image-map

上端層:~FULLSCREEN#top-layer
~URL:~URL1#concept-url

●●words_table1


EXEC-COMMAND:https://w3c.github.io/editing/execCommand.html
POINTEREVENTS:pointerevents-ja.html
TOUCHEVENTS:touch-events-ja.html


href0:href
readonly0:readonly
blur0:blur
focus0:focus
noneC:none
search0:search

●●words_table


	●仕様
	なり得る:possible
素早く:quickに:~
	-:non-normative
美観:aesthetics:~
正当:legitimate:~
略式的:skeletal:~
文脈的な:contextual::~


	きれいに:neatly
	きわどい:corner
	それに代わる:in its stead
	ないがしろに:detriment
	に過ぎない:merely
	も:opt to
	何らかの方法:somehow
	何らかの類の:some sort of
	普及している:prevalent:
	〜の違いを除いて:Modulo
	申し分ない:fine
	全面的に:entirely
	具体的には:for instance
	可能性が高い:likely
	多様な:wide variety of

	様々な:variety
	-:in fact
	それに伴い:thereby

	●仕様（動詞
濫用-:abuse:~
関心:interest:~
想定-:suppose:~
失った:loseした:~
選択的:selective:~
支援-:assist:~
介入-:intervene:~

	custom化:customizable
	-:abstract concept
	指定されていない:unspecified
	ある:particular
	できるようにする:allow
	易くする:help
	概ね、:roughly speaking
	正当化される:well justify
	要因:a factor that contributes towards
	周知の:commonly known
	呼応:in response to
	~~説明:Description
	できる:capable of

	注意:note
	満たす:meet

	●focus／dialog
	逐次的~focus~navi順序
	~focus~navi序列
blur:
	~focus可能:focusable
被focus:focused::被 focus:被フォーカス
unfocus::::未フォーカスに
	~unfocus時の:unfocusing
	~focus時の:focusing

指名-:designate::~
標的:target::~::ターゲット
届けら:routeさ::~
届ける:routeする::~
	経由-:channeled:

獲得した:gainした::得た
獲得しよ:gainしよ::得よ

tabindex:
図形:shape::~
dialog::::ダイアログ
修復:fixup::~
	~focus修復:focus-fixup
	到達-可能でない:unreachable

前方:forward::~
後方:backward::~
不活:inert::~
	inertness::::
明に:expressly::~
環:ring::~

anchor::::アンカー

逐次的:sequential::~
鎖:chain::~
進捗中:in progress::~
隠す:hideする::~
隠d:hidden::隠され
隠-:hide::~
領域:region:~

操作o:operation:操作
代役:placeholder:~
作動範囲:active range:~
候補:candidate:~
選定法:selection mechanism:~
始点:starting point:~


home:
首:primary:主
	首に:primarily
	＊首位／第一


	●編集
綴り:spelling:~
	綴りが誤っている:misspelt
検査ng:checking:検査
編集:editing::~
編集-:edit::~
編集中の:editing::~
折返す:wrapする::折り返す
折返され:wrapされ::折り返され
折返し:wrapping::折り返し
境界点:boundary point::~
選択-:select:~

選択:selection:~
字下げ:indentation:~
単語:word:~
一文:sentence:文
自然言語:language:~
終端:end:~
始端:start:~
誤り:error::~::エラー
訂正:correction:~
	不向き: not well suited

	●UI／呈示
	~scroll可能な:scrollable
方向:direction:~

tab::::タブ
	tab化された:tabbed
	tabbing:

window::::ウィンドウ
designMode:
kiosk:
所在bar:location bar:::URL 欄
panel::::パネル
popup::::
bullet::::ビュレット
command::::コマンド
drag::::ドラッグ
drop::::ドロップ
modal::::モーダル
modality::::モーダル性
widget::::ウィジェット
下位widget:subwidget::下位 widget:下位ウィジェット
menu::::メニュー
full::::フル
pointing::::ポインタ指示
十key:numeric keypad:::テンキーの類
修飾:modifier:~


声:voice:~
押下げた:pressした:~
背景:background:~
読取器:reader::~::リーダ
click:
外形線:outline:~

欄:field::~::フィールド
探索:search:検索

上端層:top layer::~

	使い勝手:usability
	使い勝手がすこぶる悪く:significantly less usable
	使い勝手は悪くなる:become unusable

	押すこと:pressing
	閉じられ:closed
	最も手前に示される:topmost

alphabetic-mnemonic:alphabetic mnemonic::alphabetic 符号:アルファベット符号
電話番号:telephone number:~
e-mail-address::::メールアドレス
手早く:quickに:~
書式区切子:format separator::~
locale::::ロケール
virtual-keyboard:virtual keyboard:::ソフトウェアキーボード
	小数を含む:fractional
数的:numeric:~
	数:numeric
	PIN


自動頭字化-:autocapitalize::~
自動頭字化:autocapitalization::~
字l:letter::字°
頭字化:capitalize::~
頭字:capital letter::~
	頭字に:to a capital letter
voice:::声::ボイス
打込まれ:typeされ:打ち込まれ:::タイプされ
打込む:typeする:打ち込む:::タイプする
打込んだ:typeした:打ち込んだ:::タイプした
組成-:compose::~
閉じら:closeさ:~
	助けに:helpful
改行:new line:~
	`Enter^kbd ~Key:enter key
cue::::キュー
icon::::アイコン
IME:
	導く:take 〜 to

	●構文

	-:literal
縮約-:collapse:~
数字:digit:~
普通字:letter:~
頭部の:leading:~
分割-:split:~
空白区切りの:space-separated:~
小文字:lowercase:~
大文字:uppercase:~


	●event
trust:
	~trustされない:not trusted
composed:

	●内容／DOM
body:
shadow:

	後続-:
	子たち:children

一節:section:~

	●未分類（動詞
アテガイ:assign 法::あてがい方
持続-:persist:~
代用:substitute:~
合成:synthetic:~
告知-:advertise:~
保つ:keepする:~
	なくなった:stop
切替える:switchする:切り替える
対応関係:mappings:~

	投稿-:publish
	未設定:unset
	外された:omitted
	戻せるように:allow 〜 toggle it back
	したい:want
	在-:present
	不在:absent
	始-:begin
	伝える:tell／:inform
	~~由来する:comes from
	~~検索
	~~生成
	~~要請
	~~連続する:adjacent
	〜されない:opposed
	選び取る:pick
	選んだ:choosing
	選ぶ:choose
	-:exception
	-:setting
	-:map

	●未分類
rich:
commit:
game::::ゲーム
engine::::エンジン
hyperlink::::ハイパーリンク
log-in:log in:::ログイン
main::::メイン
shortcut::::ショートカット
space:
層:layer:~
逆順:reverse order:~
off-screen::::オフスクリーン
時間枠:timeframe:~
連鎖:chain:~
	開閉:opened or closed
携帯:mobile::~::モバイル

	designated focused
	-:header
	~text片:piece of text
	-:time
	-:argument
	-:required
	-:relative
	~~記事:article
	数:number
	正の:positive
	負の:negative
	小さい:small

	●指示語
現在:currently:~
一様:uniform:~

	直の:immediate
	先ず:first place
	などなど:and so forth
	-:second／third
	以前の:previous
	次の:next
	前の:previous
	-:originally
	先ず:first
	次:next
	一つに:together
	一例
	一方
	一種
	一連
	一部
	一部分／一部を成す:part of
	上述
	以上
	以下
	以前
	以外
	以降
	任意
	個
	個数
	全体
	各種
	場合
	前後の:next or previous
	前述
	〜単独:alone
	〜しか:just
	右列:cells in the right column
	左列:The cells in the left column
	左右列にまたがるセル:cells that span both columns
	直前
	直前に:just
	直後
	自身
	新
	旧
	その検査／:spellchecking
	とする／:suppose
	またがる:span
	利用-中に:being used
	つつある:about to be
	いかなる類の:any sort of

	●他の語
	-:facet
	-:in place for
	-:in the middle
	-:lack thereof
	ARIA
	Alt
	C:
	CSS
	Control
	Emacs
	Escape
	Mac
	Shift
	WYSIWYG
	Windows
	aforementioned
	amongst
	aware
	became
	become
	care
	caused
	cell
	column
	committing
	consist
	e-mail
	earlier:#1
	equipped
	express
	finally
	follow
	home
	instruction
	lack
	later
	lead
	left
	mac
	made
	marked
	matching
	moving
	off-screen
	opted
	in-
	middle
	point
	pre-order
	put
	redo
	reduce
	referenced
	rerouting
	right
	row
	said
	sometime
	spin-control
	sure
	thereof
	top
	toward
	unable
	unadorned
	unmark
	unset
	vision

	し易く:easily
	その場で:on-demand
	セル
	一枚の大きな:one big
	人々:people
	分断不可:non-breaking
	前順, 深さ優先:pre-order, depth-first
	だけで:simply
	参照
	参照元:
	同時:
	同等に:equally
	名称:
	増減:button:up and down buttons in a spin-control version


	対応
	必ず:make sure
	指-:refer
	指す~refer
	新着:New
	方法
	昇順に整列
	時点
	時経過に伴って:over time
	時間~後:

	普通の:regular
	最も深い:deepest

	条件:conditions
	正数
	注意:
	注記
	用途
	留意
	省略時
	秒~後
	組み合わせ:mix
	自動的:
	表:table
	複数:
	複雑:complicated
	規定:
	該当:
	詳細:
	黄色:yellow

	無条件
	無用に煩雑
	現時点

●●html_code_list
■data-model-1
<map id=wallmap><area alt="入り口ドア" coords="10,10,100,200" href="door.html"></map>
...
<img src="images/innerwall.jpeg" alt="ドア付きの白い壁がここにある" usemap="#wallmap">
...
<img src="images/outerwall.jpeg" alt="ドア付きの赤い壁がここにある" usemap="#wallmap">

alt="Enter Door"
...
alt="There is a white wall here, with a door."
...
alt="There is a red wall here, with a door."

■intro9-1
<input type=button value=Collect onclick="collect()"
       ＜accesskey="C 1"＞ id=c>

■accesskey-1
<nav>
 <p>
  <a
    title="Consortium Activities"
    ＜accesskey="A"＞
    href="/Consortium/activities"
  >Activities</a> |
  <a
    title="Technical Reports and Recommendations"
    ＜accesskey="T"＞
    href="/TR/"
  >Technical Reports</a> |
  <a
    title="Alphabetical Site Index"
    ＜accesskey="S"＞
    href="/Consortium/siteindex"
  >Site Index</a> |
  <a
    title="About This Site"
    ＜accesskey="B"＞
    href="/Consortium/"
  >About Consortium</a> |
  <a
    title="Contact Consortium"
    ＜accesskey="C"＞
    href="/Consortium/contact"
  >Contact</a>
 </p>
</nav>

<nav>
 <p>
  <a title="Consortium Activities" accesskey="A" href="/Consortium/activities">Activities</a> |
  <a title="Technical Reports and Recommendations" accesskey="T" href="/TR/">Technical Reports</a> |
  <a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex">Site Index</a> |
  <a title="About This Site" accesskey="B" href="/Consortium/">About Consortium</a> |
  <a title="Contact Consortium" accesskey="C" href="/Consortium/contact">Contact</a>
 </p>
</nav>

■accesskey-2
<form action="/search">
 <label>Search: <input type="search" name="q" ＜accesskey="s 0"＞></label>
 <input type="submit">
</form>

■contenteditable-1
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
 </fieldset>
 <p><button>投稿</button></p>
</form>

<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
 </fieldset>
 <p><button>Publish</button></p>
</form>

■contenteditable-2
<form method=POST>
 <fieldset>
  <legend>新着記事</legend>
  <textarea id=textarea name=article>&lt;p>こんにちは&lt;/p></textarea>
＜  <div id=div style="white-space: pre-wrap" hidden><p>こんにちは</p></div>
  <％script>
   let textarea = document.getElementById("textarea");
   let div = document.getElementById("div");
   textarea.hidden = true;
   div.hidden = false;
   div.contentEditable = "true";
   div.oninput = (e) => {
     textarea.value = div.innerHTML;
   };
  </％script>＞
 </fieldset>
 <p><button>投稿</button></p>
</form>

■contenteditable-3
<!doctype html>
<html lang=en>
<title>Live CSS editing!</title>
<style style=white-space:pre contenteditable>
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
</style>

■spelling-1
<div contenteditable="true">
 <span spellcheck="false" id="a">Hell</span><em>o!</em>
</div>

■spelling-2 bad
<p spellcheck="true">
 <label>Name: <input spellcheck=" false" id="b"></label>
</p>


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">User interaction</a>
章を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header id="head">
	<hgroup>
<h1>HTML — 利用者対話 — User interaction</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="editing">
<h2 title="User interaction">6. 利用者~対話</h2>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
用語
`要素@
は、 `Element$I ~objの略記として用いられる。
</p>

		</section>
		<section id="the-hidden-attribute">
<h3 title="The hidden attribute">6.1. `hidden^a 属性</h3>

<p>
`hidden$a 内容~属性は、すべての`~HTML要素$に設定できる。
`hidden$a 属性は`真偽~属性$である。
指定された場合、その要素は，利用者からは直に~accessできないことを指示する
— すなわち，［
まだ, あるいはそれ以降、~pageの現在の状態に直には関連しない
］ことを, あるいは［
~pageの他の部分に再利用される内容を宣言するために利用されている
］ことを指示する。
~UAは、 `hidden$a 属性が指定されている要素を具現化するべきでない。
この要件は、~style層を通して間接的に実装されてもヨイ。
例えば ~HTML＋~CSS ~UAは、これらの要件を
<a href="~HTMLrendering#hiddenCSS">具現化~節にて示唆されている規則</a>
を利用して実装することもできる。
◎
All HTML elements may have the hidden content attribute set. The hidden attribute is a boolean attribute. When specified on an element, it indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user. User agents should not render elements that have the hidden attribute specified. This requirement may be implemented indirectly through the style layer. For example, an HTML+CSS user agent could implement these requirements using the rules suggested in the Rendering section.
</p>

<p class="note">注記：
この属性は、概して~CSSを利用して実装されるので、~CSSを利用して上書きすることもまたアリである。
具体的には、すべての要素に
`display: block^css
を適用する規則は、 `hidden$a 属性の効果を取消すことになる。
したがって，~stylesheetを書く作者には、この属性を有する要素に依然として期待される~styleがアテガわれるよう，注意する必要がある。
◎
Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the hidden attribute. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected.
</p>

<div class="example">

<p>
次の略式的な例では、利用者が~log-inするまで~Web~gameの~main~screenを隠すために，この属性が利用されている：
◎
In the following skeletal example, the attribute is used to hide the Web game's main screen until the user logs in:
</p>

<pre class="html-code">
&lt;h1&gt;The Example Game&lt;/h1&gt;
&lt;section id="login"&gt;
 &lt;h2&gt;Login&lt;/h2&gt;
 &lt;form&gt;
  ...
  &lt;!-- 利用者~資格を検査したなら， login() を~callする --&gt;
 &lt;/form&gt;
 &lt;script&gt;
  function login() {
    // ~screenを切り替える
    document.getElementById('login').hidden = true;
    document.getElementById('game').hidden = false;
  }
 &lt;/script&gt;
&lt;/section&gt;
&lt;section id="game" hidden&gt;
 ...
&lt;/section&gt;
</pre>

</div>

<!-- 
The Example Game
Login

calls login() once the user's credentials have been checked

// switch screens
-->
<p>
`hidden$a 属性は、他の呈示では正当に示され得るような内容に対し，それを隠す用途には，利用されてはナラナイ。
例えば、~tab化された~dialog内の~panelを隠す用途に `hidden$a を利用することは，不正である
— ~tab化された~interfaceは，~overflow呈示の一種に過ぎず、単に~scrollbarを伴う大きな~pageにすべての~form~controlを示すことに同等なので。
同様に、この属性を ある呈示に限って内容を隠す用途に利用することは，不正である
— `hidden$a 属性を有するものは、~screen読取器も含め，すべての呈示から隠される。
◎
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.
</p>

<p>
`hidden$a 属性を有さない要素から， `hidden$a 属性を有する要素へ`~hyperlink$してはナラナイ。
同様に、 `hidden$a 属性を有さない［
`label$e ／ `output$e
］要素の `for^a 属性が、 `hidden$a 属性を有する要素を指してはナラナイ。
いずれの参照-も，利用者を惑わすことになるので。
◎
Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.
</p>

<p>
しかしながら，他の文脈においては、要素や~scriptが `hidden$a 属性を有する要素を指すこともある。
◎
Elements and scripts may, however, refer to elements that are hidden in other contexts.
</p>

<div class="example">

<p>
例えば， `href$a 属性の~link先に `hidden$a 属性を有する一節をアテガうのは、不正になる。
当の内容が［
適用-可能でない／関連しない
］ならば、そこへ~linkする理由はない。
◎
For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.
</p>

<p>
しかしながら， ARIA `aria-describedby$a 属性を利用して `hidden$a 属性を有する記述を指すことは，申し分ない。
記述を隠すことは，それ~~単独では有用でないことを含意するが、ある画像についての記述を その画像から参照させるなど，特定の文脈~下で有用になるように書くことはできる。
◎
It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the images that they describe.
</p>

<p>
同様に、 `hidden$a 属性を有する `canvas$e 要素は，~scriptによる~graphic~engineから~off-screen~bufferとして利用されることもあり、~form~controlの `form$a 属性は， `hidden$a 属性を有する `form$e 要素を指すこともある。
◎
Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.
</p>

</div>

<p>
`hidden$a 属性を有する一節~内の要素であっても、依然として作動中であり続ける
— 例えば，そのような一節~内の［
~script／~form~control
］は、依然として［
実行される／提出される
］。
変化するのは、利用者~向けの呈示に限られる。
◎
Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.
</p>

<dl class="idl-def">
	<dt>`hidden@m</dt>
	<dd>
`hidden$a 内容~属性を`反映する$モノトスル。
◎
The hidden IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>

		</section>
		<section id="inert-subtrees">
<h3 title="Inert subtrees">6.2. 不活~下位tree</h3>

<p>
~node（特に，要素／~text~node）は、
`不活@
にされ得る。
~UAは、`不活$にされている~nodeに対しては：
◎
This section does not define or create any content attribute named "inert". This section merely defines an abstract concept of inertness.
◎
A node (in particular elements and text nodes) can be marked as inert. When a node is inert, then the user agent＼
</p>

<ul>
	<li>
利用者~対話~eventの標的にしないモノトスル
— その目的においては，~nodeは不在であったかのように動作して。
◎
must act as if the node was absent for the purposes of targeting user interaction events,＼
</li>
	<li>
~text探索~UI（ “~page内を~~検索” として周知の）の目的においては，~nodeを無視してもヨイ。
◎
may ignore the node for the purposes of text search user interfaces (commonly known as "find in page"), and＼
</li>
	<li>
その~node内の~textについては，利用者が選択できなくしてもヨイ。
◎
may prevent the user from selecting text in that node.＼
</li>
</ul>

<p>
しかしながら，~UAは、~textの探索と選択については，利用者が上の制約を上書きできるようにするべきである。
◎
User agents should allow the user to override the restrictions on search and text selection, however.
</p>

<p class="example">
例えば、ある~pageに`不活$にされた段落が 1 個だけあって `body$e の~~中程に位置しているとする。
利用者が，~pointing装置をその段落の外から内に移動させ，そこで~clickした場合、
`mouseover$et ~eventは発火されず，
`mousemove$et ／ `click$et
~eventは，段落ではなく `body$e 要素に向けて発火されることになる。
◎
For example, consider a page that consists of just a single inert paragraph positioned in the middle of a body. If a user moves their pointing device from the body over to the inert paragraph and clicks on the paragraph, no mouseover event would be fired, and the mousemove and click events would be fired on the body element rather than the paragraph.
</p>

<p class="note">注記：
一般に、不活である~nodeには，~focusできない
— そのような~nodeが`~commandを定義する$ものであれば，不能化されることになる。
◎
When a node is inert, it generally cannot be focused. Inert nodes that are commands will also get disabled.
</p>

<p>
ある閲覧文脈 %B を`入子にしている閲覧文脈~容器$に対しては、それが`不活$にされている間は，［
%B にて`作動中の文書$, および
その`文書$内のすべての~node
］も`不活$にされるモノトスル。
◎
While a browsing context container is marked as inert, its nested browsing context's active document, and all nodes in that Document, must be marked as inert.
</p>

<p>
`不活$にされている要素のうち，［
その`~node文書$は`不活$でない
］ものは、
`明に不活@
とされる：
◎
An element is expressly inert if it is inert and its node document is not inert.
</p>

<p>
`文書$ %文書 が ある
`~modal~dialogにより阻まれ@
ているとは、 %文書 の`上端層$の最後の（最も手前に示される）要素が その~modal~dialog（ `dialog$e 要素）であることをいう。
%文書 がそのように阻まれている間は、
%文書 に`接続されて$いるどの~nodeも
— %dialog と その`~shadowも含む子孫$を除き —
`不活$にされるモノトスル。
（この段落にて除かれた要素であっても、他の手段を通して，`不活$にされ得る
— 当の~modal~dialogの一部を成す~nodeであっても，`不活$にされないよう “保護される” わけではない）
◎
A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer. While document is so blocked, every node that is connected to document, with the exception of the subject element and its shadow-including descendants, must be marked inert. (The elements excepted by this paragraph can additionally be marked inert through other means; being part of a modal dialog does not "protect" a node from being marked inert.)
</p>

<p class="note">注記：
`dialog$e 要素の `showModal()$m ~methodは、要素の`~node文書$の`上端層$に要素を追加することにより，この仕組みを誘発する。
◎
The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node document's top layer.
</p>

		</section>
		<section id="activation">
<h3 title="Activation">6.3. 作動化</h3>

<p>
ある種の~HTML要素は、`作動化の挙動$を有する
— すなわち、利用者はそれを作動化できる。
これは、常に `click$et ~eventにより生じる。
◎
Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.
</p>

<p>
~UAは、利用者が，`作動化の挙動$を有する要素を手動で
— 具体的には、~keyboardや声~入力を利用したり，~mouse~clickを通して —
誘発できるようにするべきである。
利用者が，`作動化の挙動$が定義されている要素を~click以外の方式で誘発したときは、対話~eventの既定の動作においては，要素に向けて`~click~eventを発火-$するモノトスル。
◎
The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.
</p>

<p id="allowed-to-show-a-popup">
［
次のいずれかの条件を満たす`~task$
］が走らせている~algoは、
`利用者の作動化により誘発され@
たとされる：
◎
An algorithm is triggered by user activation if any of the following conditions is true:
</p>

<ul>
	<li>
［［
`isTrusted$m ~EQ ~T
］なる `click$et ~eventによる`作動化の挙動$
］を現在~処理している
◎
The task in which the algorithm is running is currently processing an activation behavior whose click event's isTrusted attribute is true.
</li>
	<li>
<p>
［
次をいずれも満たす~event
］用の~event~listenerを現在~走らせている：
◎
The task in which the algorithm is running is currently running the event listener for an event＼
</p>

		<ul>
			<li>
`isTrusted$m ~EQ ~T
◎
whose isTrusted attribute is true and＼
</li>
			<li>
`type$m ~IN { `change$et, `click$et, `contextmenu$et, `dblclick$et, `mouseup$et, `pointerup$et, `reset$et, `submit$et, `touchend$et }
◎
whose type is one of:
• change
• click
• contextmenu
• dblclick
• mouseup
• pointerup
• reset
• submit
• touchend
</li>
		</ul>
	</li>
	<li>
<p>
`利用者の作動化により誘発され$た~algoにより`~queueされ$たものであって，そのような~algoの連鎖は~UA定義の時間枠の中で開始された。
◎
The task in which the algorithm is running was queued by an algorithm that was triggered by user activation, and the chain of such algorithms started within a user-agent defined timeframe.
</p>

<p class="example">
例えば~popupは、利用者が~buttonを~clickしてから 4 秒~後であれば 受容-可能かもしれないが， 4 時間~後ならおよそ受容-可能とされないであろう。
◎
For example, if a user clicked a button, it might be acceptable for a popup to result from that after 4 seconds, but it would likely not be acceptable for a popup to result from that after 4 hours.
</p>
	</li>
</ul>

<dl class="domintro">
	<dt>%element . `click()$m</dt>
	<dd>
要素が~clickされたかのように動作させる。
◎
Acts as if the element was clicked.
</dd>
</dl>

<p>
各~要素には、
`~click進捗中~flag@
— 初期~時は ~F —
が結付けられる。
◎
Each element has an associated click in progress flag, which is initially unset.
</p>

<dl class="idl-def">
	<dt>`click()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らすモノトスル：
◎
The click() method must run the following steps:
</p>
		<ol>
			<li>
此れは`不能化され$ている~form~controlである
⇒
~RET
◎
If this element is a form control that is disabled, then return.
</li>
			<li>
~IF［
此れの`~click進捗中~flag$ ~EQ ~T
］
⇒
~RET
◎
If this element's click in progress flag is set, then return.
</li>
			<li>
此れの`~click進捗中~flag$ ~SET ~T
◎
Set this element's click in progress flag.
</li>
			<li>
`合成~mouse~eventを発火する$( 此れ, `click^et, `~trustされない^i )
◎
Fire a synthetic mouse event named click at this element, with the not trusted flag set.
</li>
			<li>
此れの`~click進捗中~flag$ ~SET ~F
◎
Unset this element's click in progress flag.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="focus">
<h3 title="Focus">6.4. ~focus</h3>

			<section id="introduction-8">
<h4 title="Introduction">6.4.1. 序論</h4>

~INFORMATIVE

<p>
~HTML~UIは、概して複数の対話的~widgetからなる
—
~form~control,
~scroll可能な領域,
~link,
~dialog~box,
~browser~tab,
などなど。
これらの~widgetは、あるもの（例： ~browser~tab, ~dialog~box）が他のもの（例： ~link, ~form~control）を包含しているような，階層を形成する。
◎
An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).
</p>

<p>
~keyboard~UIによるヤリトリ-時の~Key入力は、~systemから対話的~widgetの階層を経由して，`~focusされて$いる作動中の~widgetにたどり着く。
◎
When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.
</p>

<div class="example">

<p>
~graphicな環境~内で走っている~browser~tab内で走っている~HTML~appを考える。
この~appの~pageには，いくつかの~text~controlや~linkがあり、~modal~dialogを現在~示していて，その中にも~text~controlや~buttonがあるとする。
この局面における~focus可能な~widgetの階層は：
◎
Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.
</p>

<p>
先ず~browser~windowを含み、
⇒
~windowは，~HTML~appを包含している~browser~tabを子として持ち、
⇒
~tabは，前述の~dialogの他に種々の~linkや~text~controlを子として持ち、
⇒
~dialogは，~text~controlや~buttonを子として持つことになる。
◎
The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as well as the dialog. The dialog itself would have as its children the text control and the button.
</p>

<figure>
<img src="HTML-resources/focus-tree.png" alt="" width="800" height="450">
<figcaption>

</figcaption></figure>

<p>
この例において `~focusされて$いる~widgetが，~dialog~box内の~text~controlであった場合、~Key入力は、［
~graphicな~system →
① ~Web~browser →
② ~tab →
③ ~dialog →
④ ~text~control
］の順に経由することになる。
◎
If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the graphical system to ① the Web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.
</p>

</div>

<p>
~keyboard~eventは、常に，この`~focusされて$いる要素を標的にする。
◎
Keyboard events are always targeted at this focused element.
</p>

			</section>
			<section id="data-model">
<h4 title="Data model">6.4.2. ~data~model</h4>

<p>
用語
`~focus可能な区画@
は、~keyboard入力の標的になれるような，~UIの領域を指す。
［
要素, 要素の一部分, その他の~UAにより管理される領域
］は、~focus可能な区画になり得る。
◎
The term focusable area is used to refer to regions of the interface that can become the target of keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.
</p>

<p>
各 `~focus可能な区画$は、
`~DOM~anchor@
を持つ
— それは、`~focus可能な区画$の~DOMにおける位置を表現する `Node$I ~objである（`~focus可能な区画$自身が `Node$I であれば，それがそのまま`~DOM~anchor$になる）。
`~DOM~anchor$は、`~focus可能な区画$を表現する~DOM~objが他にないときに，一部の~APIにより`~focus可能な区画$の代用として利用される。
◎
Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.
</p>

<p>
次の表の左列に、どの~objが`~focus可能な区画$になり得るかを述べる。
対応する`~DOM~anchor$を表の右列に述べる。
◎
The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)
</p>

<table id="table-fa"><thead><tr><th>`~focus可能な区画$
<th id="th-fa-dom-rep">`~DOM~anchor$
<tr><th colspan="2">
<div class="example"><i>左右列にまたがるセルには、例を示す。</i></div>
</thead>

<tbody><tr><th id="td-fa-1">
<p >
次をいずれも満たす要素：
</p>

<ul ><li>`~tabindex~focus~flag$ ~EQ ~T
</li><li>`不能化-$されていない
</li><li>`明に不活$でない
</li><li>［
`具現化されて$いる
］~OR［
<a href="~HEcanvas#being-used-as-relevant-canvas-fallback-content">関連な~canvas~fallback内容として利用-中にある</a>
］
</li></ul>

◎
Elements that have their tabindex focus flag set, that are not actually disabled, that are not expressly inert, and that are either being rendered or being used as relevant canvas fallback content.
<td>
要素~自身。
◎
The element itself.
<tr><td colspan="2">

<div class="example">

<ul><li>`iframe$e
</li><li><a href="~HEinput#text-(type=text)-state-and-search-state-(type=search)">`&lt;input type=text&gt;^e</a>,
</li><li>場合によっては（~platform規約に依存する）
<a href="~HEtextlevel#the-a-element">`&lt;a href="…"&gt;^e</a>
</li></ul>

◎
iframe, &lt;input type=text&gt;, sometimes &lt;a href=""&gt; (depending on platform conventions).
</div>
</tbody>

<tbody><tr><th id="td-fa-2">
<p>
`画像~map$内の
`~focus可能な図形@
— そのような図形は、次を満たす各~組
( `area$e 要素 %A , `img$e 要素 %I )
ごとに作成される：
</p>

<ul ><li>%I は、その `usemap^a 属性を通して %A の親である `map^e 要素を指している
</li><li>%I は、`具現化されて$いる, かつ `明に不活$でない
</li></ul>

<p class="trans-note">【
以下では、
%A を指して 図形を`定義している^i `area$e 要素，
%I を指して 図形が`属する^i `img$e 要素
と称することにする。
】</p>

◎
The shapes of area elements in an image map associated with an img element that is being rendered and is not expressly inert.
<td>
その図形が属する `img$e 要素。
◎
The img element.
<tr><td colspan="2">

<div class="example">
<p>
次の例の `area$e 要素は、［
その親である `map^e 要素への参照を通して それを利用している各 `img$e 要素
］ごとに 1 個ずつ，計 2 個の図形を作成する。
各~図形の`~DOM~anchor$は、参照元の `img^e 要素になる。
◎
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.
</p>

`data-model-1^xCode

</div>

</tbody>

<tbody><tr><th id="td-fa-3">
<p >
~UAにより供される下位widget要素であって，次をいずれも満たすもの：
</p>

<ul ><li>`具現化されて$いる
</li><li>`不能化-$されてない
</li><li>`明に不活$でない
</li></ul>

◎
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or expressly inert.
<td>
`~focus可能な区画$がその下位widgetである要素。
◎
The element for which the focusable area is a subwidget.
<tr><td colspan="2" headers="td-fa-3">

<div class="example">
<ul>
	<li>
`video$e 要素~用に，`~UIにより利用者に公開されている~control$
◎
The controls in the user interface that is exposed to the user for a video element,＼
</li>
	<li>
<a href="~HEinput#number-state-(type=number)">`&lt;input type=number&gt;^e</a>
用の増減~button
◎
the up and down buttons in a spin-control version of &lt;input type=number&gt; ,＼
</li>
	<li>
<a href="~HEinput#range-state-(type=range)">`&lt;input type=range multiple&gt;^e</a>
用の範囲~control~widget
◎
the two range control widgets in a &lt;input type=range multiple&gt;,＼
</li>
	<li>
`details$e 要素の具現化の一部を成していて，当の要素の開閉を~keyboard入力を利用して可能化させているもの。
◎
the part of a details element's rendering that enabled the element to be opened or closed using keyboard input.
</li>
</ul>
</div>
</tbody>

<tbody><tr><th id="td-fa-4">
次を満たす要素の，~scroll可能な領域
⇒
［
`具現化されて$いる
］~AND［
`明に不活$でない
］
◎
The scrollable regions of elements that are being rendered and are not expressly inert.
<td>
その~scroll可能な領域~boxを~~生成させた要素。
◎
The element for which the box that the scrollable region scrolls was created.
<tr><td colspan="2">

<div class="example">
<p>
~CSS `overflow$p ~propに対する `scroll^v 値は、概して，~scroll可能な領域を作成させる。
◎
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.
</p>
</div>

</tbody>

<tbody><tr><th id="td-fa-5">
次を満たす`文書$の，`表示域$
⇒
［
`属する閲覧文脈$ ~NEQ ~NULL
］~AND［
`不活$でない
］
◎
The viewport of a Document that has a non-null browsing context and is not inert.
<td>
`表示域$を作成させている`文書$。
◎
The Document for which the viewport was created.
<tr><td colspan="2">
<div class="example">
<p>
`iframe$e の内容。
◎
The contents of an iframe.
</p>
</div>
</tbody>

<tbody><tr><th id="td-fa-6">
他の任意の
— とりわけ，~accessibilityを援助する, あるいは~platform規約により良く合致するような —
要素またはその一部分。
◎
Any other element or part of an element, especially to aid with accessibility or to better match platform conventions.
<td>
要素。
◎
The element.
<tr><td colspan="2">

<div class="example">
<p>
~UAは、利用者が~listを~navigateし易くなるよう，すべての~list~item~bulletを~focus可能にすることもできる。
◎
A user agent could make all list item bullets focusable, so that a user can more easily navigate lists.
</p>

<p>
同様に，~UAは、
`title$a 属性を有するすべての要素に対し，その助言的~情報に~accessできるよう，~focus可能にすることもできる。
◎
Similarly, a user agent could make all elements with title attributes focusable, so that their advisory information can be accessed.
</p>
</div>

</tbody></table>

<p id="bc-focus-ergo-bcc-focus" class="note">注記：
`閲覧文脈~容器$ %容器 （例： `iframe$e ）は `~focus可能な区画$であるが，ある`閲覧文脈$ %B を`入子にして$いる場合、 %容器 へ届けられる~Key~eventは，%B にて`作動中の文書$ %文書 へ，即時に届けられるようになる。
同様に，`逐次的~focus~navi$においては、
%容器 は，本質的には %文書 の代役として動作するに過ぎない。
◎
A browsing context container (e.g. an iframe) is a focusable area, but key events routed to a browsing context container get immediately routed to the nested browsing context's active document. Similarly, in sequential focus navigation a browsing context container essentially acts merely as a placeholder for its nested browsing context's active document.
</p>

<hr>

<p>
各 `文書$が
`指名する被focus区画@
は、文書に属する`~focus可能な区画$のうち 1 つを指す【常に在る（初期~時は表示域）】。
どの~focus可能な区画がそう指名されるかは、この仕様の各種~algoに基づいて，時経過に伴って変化する。
◎
One focusable area in each Document is designated the focused area of the document. Which control is so designated changes over time, based on algorithms in this specification.
</p>

<p>
同じ`文書$に属する`~focus可能な区画$たちの順序は、次に与える
`~focus可能な区画の順序@
に従うとする：
◎
Focusable areas in a Document are ordered relative to＼
</p>

<ul>
	<li>
それぞれの`~DOM~anchor$の`~tree順序$。
◎
the tree order of their DOM anchors.＼
</li>
	<li>
`~DOM~anchor$が同じになる`~focus可能な区画$たちの順序は、それらが~~生成する`~CSS~box$の`~box~tree$ `CSS$r における前順, 深さ優先の順序。
【すなわち，`~tree順序$と同様に定義される順序】
◎
Focusable areas with the same DOM anchor in a Document are ordered relative to their CSS boxes' relative positions in a pre-order, depth-first traversal of the box tree. [CSS]
</li>
</ul>

<hr>

<div class="algorithm">
<p>
`~top-level閲覧文脈$ %T の，所与の時点における
`現在の被focus区画@
は、次を走らせた結果の`~focus可能な区画$である：
◎
The currently focused area of a top-level browsing context at any particular time is the focusable area returned by this algorithm:
</p>

<ol>
	<li>
%候補 ~LET %T にて`作動中の文書$
◎
Let candidate be the Document of the top-level browsing context.
</li>
	<li>
%F ~LET %候補 が`指名する被focus区画$
◎
If the designated focused area of the document＼
</li>
	<li>
~IF［
%F は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒＃
%T ~SET %B；
~GOTO 最初の段
◎
is a browsing context container with a non-null nested browsing context, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.
</li>
	<li>
~RET［
%F ~NEQ ε ならば %F ／
~ELSE_ %候補
］
◎
If candidate has a focused area, set candidate to candidate's focused area.
◎
Return candidate.
</li>
</ol>
</div>

<p>
`現在の被focus区画$の`~DOM~anchor$である要素は、
`~focusされて@
いるという。
そうでない要素がそうなることを、要素は
`~focusを獲得した@
という。
◎
An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level browsing context. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level browsing context, it is focused.
</p>

<div class="algorithm">
<p>
`~focus可能な区画$ %~subject の
`~focus鎖@
は、次に従って構築される有順序~listである：
◎
The focus chain of a focusable area subject is the ordered list constructed as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~list
◎
Let current object be subject.
◎
Let output be an empty list.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%出力 に %~subject を付加する
◎
Loop: Append current object to output.
</li>
			<li>
~IF［
%~subject は`~focus可能な図形$である
］
⇒
%出力 に %~subject を定義している `area$e 要素を付加する
◎
If current object is an area element's shape, append that area element to output.
</li>
			<li>
~ELIF［
%~subject は`~focus可能な区画$である
］~AND［
%~subject の`~DOM~anchor$ %A ~NEQ %~subject
］
⇒
%出力 に %A を付加する
◎
Otherwise, if current object is a focusable area whose DOM anchor is an element that is not current object itself, append that DOM anchor element to output.
</li>
			<li>
~ELIF［
%~subject は`文書$である
］~AND［
%~subject が`属する閲覧文脈$ %B を`入子にしている閲覧文脈~容器$ %C がある
］
⇒
%~subject ~SET %C
◎
If current object is a Document in a nested browsing context, let current object be its browsing context container, and return to the step labeled loop.
</li>
			<li>
~ELSE
⇒
~RET %出力
◎
Return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
~focus鎖は、 %O から開始して，（ %O が`現在の被focus区画$である／なり得るならば）
`~top-level閲覧文脈$に属する`文書$まで，~focus階層を辿り続ける。
◎
The chain starts with subject and (if subject is or can be the currently focused area of a top-level browsing context) continues up the focus hierarchy up to the Document of the top-level browsing context.
</p>
</div>

			</section>
			<section id="the-tabindex-attribute">
<h4 title="The tabindex attribute">6.4.3. `tabindex^a 属性</h4>

<p>
`tabindex@a
内容~属性により、作者は，次について想定することを指示できるようになる：
◎
The tabindex content attribute allows authors to indicate that＼
</p>

<ul>
	<li>
要素は`~focus可能な区画$になること。
◎
an element is supposed to be focusable, and＼
</li>
	<li>
`逐次的~focus~navi$を利用して到達-可能かどうか。
◎
whether it is supposed to be reachable using sequential focus navigation and,＼
</li>
	<li>
到達できる場合、要素は，逐次的~focus~navi順序においてどこに~~位置するか。
◎
if so, what is to be the relative order of the element for the purposes of sequential focus navigation.＼
</li>
</ul>

<p>
“tab index” という名称は、一連の~focus可能な要素を~navigateするときに， “tab” ~Keyが共通的に利用されることに~~由来する。
語 “tabbing” とは、逐次的~focus~naviを利用して到達し得る~focus可能な要素を，前方へ辿ることを指す。
◎
The name "tab index" comes from the common use of the "tab" key to navigate through the focusable elements. The term "tabbing" refers to moving forward through the focusable elements that can be reached using sequential focus navigation.
</p>

<p>
この属性が省略されている場合、~UAは，下に述べる既定のふるまいを適用する。
（`具現化されて$いる要素を~focus可能でなくする仕方は、それを`不能化-$するか`不活$にする他にない。）
◎
When the attribute is omitted, the user agent applies defaults. (There is no way to make an element that is being rendered be not focusable at all without disabling it or making it inert.)
</p>

<p>
`tabindex$a 属性に指定される値は、`妥当な整数$でなければナラナイ。
正~数は、要素の`~focus可能な区画$の，`逐次的~focus~navi順序$における位置を指定する。
負~数は、当の~controlは，`逐次的~focus~navi$においては到達-可能でないことを指示する。
◎
The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is to be unreachable by sequential focus navigation.
</p>

<p>
開発者は、 `tabindex$a 属性に対する 0, −1 以外の値は注意して利用するべきである
— 正しく利用するのは複雑なので。
◎
Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.
</p>

<p>
各~要素には
`~tabindex~focus~flag@
が結付けられ、下に定義されるように ~T にされ得る【初期~時は ~F 】。
以前の節で述べたように、この~flagは，要素が`~focus可能な区画$になるかどうか決定する要因になる。
◎
Each element can have a tabindex focus flag set, as defined below. This flag is a factor that contributes towards determining whether an element is a focusable area, as described in the previous section.
</p>

<p>
所与の要素の
`~tabindex値@
は、［
要素は `tabindex$a 属性 %A を有する
］~AND［
`整数として構文解析する$( %A の値 ) ~NEQ `失敗^i
］ならば その結果 ／
~ELSE_ ε
］とする。
所与の`~focus可能な区画$の`~tabindex値$は、その`~DOM~anchor$の`~tabindex値$とする。
【`~tabindex値$は、以下を簡潔に述べるために，この訳に導入した定義である。】
◎
↓</p>

<p>
~UAは、要素~上の`~tabindex値$を，次に従って解釈するモノトスル：
◎
If the tabindex attribute is specified on an element, it must be parsed using the rules for parsing integers. The attribute's values, or lack thereof, must be interpreted as follows:
</p>

<ul>
	<li>
<p>
`~tabindex値$ ~EQ ε の場合、~UAは，~platform規約に従って
次を決定するべきである
⇒
要素の`~tabindex~focus~flag$は ~T にされるか？
— そうであれば
⇒
［
要素, または要素を`~DOM~anchor$とする`~focus可能な区画$
］へは、`逐次的~focus~navi$を利用して到達できるか？
— そうであれば
⇒
要素／~focus可能な区画は、`逐次的~focus~navi順序$において どこに位置するか？
◎
If the attribute is omitted or parsing the value returns an error
◎
The user agent should follow platform conventions to determine if the element's tabindex focus flag is set and, if so, whether the element and any focusable areas that have the element as their DOM anchor can be reached using sequential focus navigation, and if so, what their relative position in the sequential focus navigation order is to be.
</p>

<p>
~platform規約の違いを除き、次のいずれかに該当する要素~用には，`~tabindex~focus~flag$を ~T にすることが示唆される：
◎
Modulo platform conventions, it is suggested that for the following elements, the tabindex focus flag be set:
</p>

		<ul>
			<li>
`a$e 要素のうち， `href$a 属性を有するもの
◎
a elements that have an href attribute
</li>
			<li>
`link$e 要素のうち， `~href0$a 属性を有するもの
◎
link elements that have an href attribute
</li>
			<li>
`button$e 要素
◎
button elements
</li>
			<li>
`input$e 要素のうち，その `type$a 属性の状態 ~NEQ `Hidden$st なるもの
◎
input elements whose type attribute are not in the Hidden state
</li>
			<li>
`select$e 要素
◎
select elements
</li>
			<li>
`textarea$e 要素
◎
textarea elements
</li>
			<li>
`details$e 要素の子である `summary$e 要素のうち，最初のもの
◎
summary elements that are the first summary element child of a details element
</li>
			<li>
`draggable$a 属性を有する要素のうち、~UAが［
利用者が~pointing装置を利用することなく，その要素~用の~drag操作oを始める
］ことを可能化するもの。
◎
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin a drag operations for those elements without the use of a pointing device
</li>
			<li>
`編集中の~host$
◎
Editing hosts
</li>
			<li>
`閲覧文脈~容器$
◎
Browsing context containers
</li>
		</ul>
	</li>
	<li>
<p>
`~tabindex値$ ~NEQ ε の場合、要素の`~tabindex~focus~flag$は ~T にするモノトスル。
加えて：
◎
↓</p>
		<ul>
			<li>
<p>
`~tabindex値$ ~LT 0 の場合、`逐次的~focus~navi順序$からは，要素を外すべきである。
◎
If the value is a negative integer
◎
The user agent must set the element's tabindex focus flag, but should omit the element from the sequential focus navigation order.
</p>

<p class="note">注記：
要素を逐次的~focus~naviから外すとする，作者から~~要請された要件を無視する妥当な理由としては、利用者が~focusを移動する仕組みが，逐次的~focus~naviの他にない場合が挙げられる。
具体的には、~keyboardのみの利用者は，負の `tabindex$a を伴う~text~controlを~clickできないので、~UAが，~~要請にかかわらず［
利用者が~tabで当の~controlへ移れる
］ようにすることは正当化される。
◎
One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.
</p>
			</li>
			<li>
`~tabindex値$ ~GTE 0 の場合、［
要素, および要素を`~DOM~anchor$とする`~focus可能な区画$
］へは，`逐次的~focus~navi$を利用して到達できるようにするべきである。
◎
If the value is a zero
◎
↓↓
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, following platform conventions to determine the element's relative position in the sequential focus navigation order.
◎
If the value is greater than zero
◎
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation,＼
</li>
		</ul>
	</li>
	<li >
<p>
`逐次的~focus~navi$を利用して到達できる`~focus可能な区画$たちの~navi順序は、以下に従うべきである：
</p>

<ul>
	<li>
［
`~tabindex値$ ~EQ 0
］なるものどうしの順序は、~platform規約に従う。
</li>
	<li>
［
`~tabindex値$ ~GT 0
］なるものは、他のものより先にする。
</li>
	<li>
<p>
［
`~tabindex値$ ~GT 0
］なるものどうしの順序は：
</p>

<ul><li>`~tabindex値$の昇順に整列する（値が小さいものが先）。
</li><li>`~tabindex値$が同じものどうしの順序は、`~DOM~anchor$の`~tree順序$に従う。
</li></ul>

	</li>
</ul>

<p class="trans-note">【
`~tabindex値$が負数のものどうしの順序は、ここには規定されていない（元々、逐次的~focus~naviからは外される “べき” とされている）。
同じ`~DOM~anchor$を共有するものどうしの順序も、規定されていない（`~focus可能な区画の順序$に準じそうにも思われるが、ここには言及されていない）。
】</p>

◎
and should place the element — referenced as candidate below — and the aforementioned focusable areas in the sequential focus navigation order so that, relative to other focusable areas in the sequential focus navigation order, they are:
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or less than zero,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is earlier in the document in tree order than candidate,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is later in the document in tree order than candidate, and
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
</li>
</ul>

<p>
`tabindex$a 属性が指定されている要素は、`対話的~内容$になる。
◎
An element with the tabindex attribute specified is interactive content.
</p>

<dl class="idl-def">
	<dt>`tabIndex@m</dt>
	<dd>
`tabindex$a 内容~属性の値を`反映する$モノトスル。
◎
The tabIndex IDL attribute must reflect the value of the tabindex content attribute.＼
</dd>
	<dd>
その既定~値は、要素が［
~focus可能ならば 0 ／
~focus可能でないならば −1 
］とする。
◎
Its default value is 0 for elements that are focusable and −1 for elements that are not focusable.
</dd>
</dl>

			</section>
			<section id="focus-processing-model">
<h4 title="Processing model">6.4.4. 処理~model</h4>

<div class="algorithm">
<p>
`~objを~focusする@
ときは、所与の
( %標的, %~fallback標的 （省略時は ε ） )
に対し，次の手続きを走らす：
◎
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a browsing context, are as follows. They can optionally be run with a fallback target.
</p>

<ol>
	<li>
~Assert：
%標的 は［
`~focus可能な区画$ ／ `~focus可能な区画$でない要素 ／ `閲覧文脈$
］である
◎
↑</li>
	<li>
<p>
%標的 ~SET 次の下位手続きを走らせた結果：
◎
If new focus target is not a focusable area, then run the first matching set of steps from the following list:
</p>
		<ol>
			<li>
~IF［
%標的 は`~focus可能な区画$である
］
⇒
~RET %標的
◎
↑</li>
			<li>
~IF［
%標的 は `area$e 要素である
］~AND［
%標的 は`~focus可能な図形$を定義している
］
⇒
~RET 
それらの図形の`~DOM~anchor$のうち，`~tree順序$で最初のもの
◎
If new focus target is an area element with one or more shapes that are focusable areas
• Let new focus target be the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.
</li>
			<li>
~IF［
%標的 は要素である
］~AND［
%標的 は`~focus可能な区画$である 1 個以上の~scroll可能な領域 `CSS$r を伴う
］
⇒
~RET それらのうち，`~focus可能な区画の順序$において最初の~scroll可能な領域
◎
If new focus target is an element with one or more scrollable regions that are focusable areas
• Let new focus target be the element's first scrollable region, according to a pre-order, depth-first traversal of the box tree. [CSS]
</li>
			<li>
~IF［
%標的 は`文書~要素$である
］
⇒
~RET %標的 の`文書$の`表示域$
◎
If new focus target is the document element of its Document
• Let new focus target be the Document's viewport.
</li>
			<li>
~IF［
%標的 は`閲覧文脈$である
］
⇒
~RET %標的 にて`作動中の文書$
◎
If new focus target is a browsing context
• Let new focus target be the browsing context's active document.
</li>
			<li>
~IF［
%標的 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒
~RET %B にて`作動中の文書$
◎
If new focus target is a browsing context container with a non-null nested browsing context
• Let new focus target be the browsing context container's nested browsing context's active document.
</li>
			<li>
~RET %~fallback標的
◎
Otherwise
• If no fallback target was specified, abort the focusing steps.
• Otherwise, let new focus target be the fallback target.
</li>
		</ol>
	</li>
	<li>
~IF［
%標的 ~EQ ε
］
⇒
~RET
◎
↑</li>
	<li>
~IF［
%標的 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒＃
%標的 ~SET %B にて`作動中の文書$；
`and redo this step^en 【意図不明な記述】
◎
If new focus target is a browsing context container with non-null nested browsing context, then let new focus target be the nested browsing context's active document, and redo this step.
</li>
	<li>
~IF［
%標的 は`~focus可能な区画$である
］~AND［
%標的 の`~DOM~anchor$は`不活$である
］
⇒
~RET
◎
If new focus target is a focusable area and its DOM anchor is inert, then return.
</li>
	<li>
~IF［
%標的 ~EQ `現在の被focus区画$
］
⇒
~RET
◎
If new focus target is the currently focused area of a top-level browsing context, then return.
</li>
	<li>
%旧~鎖 ~LET ［［
%標的 が見出される`~top-level閲覧文脈$
］の`現在の被focus区画$
］の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of the top-level browsing context in which new focus target finds itself.
</li>
	<li>
%新~鎖 ~LET %標的 の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
`~focusを更新する$( %旧~鎖, %新~鎖, %標的 )
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>
</ol>
</div>

<div class="algorithm">
<p>
~UAは、利用者が［
`~focus可能な区画$ ／ `閲覧文脈$
］ %候補 に~focusを移動しようと試みたときには、`即時に$次を走らすモノトスル
⇒
`~objを~focusする$( %候補 )
◎
User agents must immediately run the focusing steps for a focusable area or browsing context candidate whenever the user attempts to move the focus to candidate.
</p>
</div>

<div class="algorithm">
<p>
`~objを~unfocusする@
ときは、所与の
( ［ `~focus可能な区画$ ／ `~focus可能な区画$でない要素 ］ %旧~標的 )
に対し，次の手続きを走らす：
◎
The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:
</p>

<ol>
	<li>
~IF［
%旧~標的 は`不活$である
］
⇒
~RET
◎
If old focus target is inert, then return.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
［
`現在の被focus区画$は`~focus可能な図形$である
］~AND［
 %旧~標的 は その図形を定義している `area$e 要素である
</li>
			<li>
［
`現在の被focus区画$は~scroll可能な領域である
］~AND［
%旧~標的 は その~scroll可能な領域を有する要素である
］
</li>
		</ul>
<p>
…ならば
⇒
%旧~標的 ~LET `現在の被focus区画$
</p>
◎
If old focus target is an area element and one of its shapes is the currently focused area of a top-level browsing context, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level browsing context, then let old focus target be that currently focused area of a top-level browsing context.
</li>
	<li>
~ELIF［
%旧~標的 ~NIN `現在の被focus区画$の`~focus鎖$
］
⇒
~RET
◎
Let old chain be the focus chain of the currently focused area of a top-level browsing context.
◎
If old focus target is not one of the entries in old chain, then return.
</li>
	<li>
~IF［
%旧~標的 は`~focus可能な区画$である
］
⇒
`~objを~focusする$( %旧~標的 が属する`文書$の`表示域$ )
◎
If old focus target is a focusable area, then let new focus target be its Document's viewport.
◎
Otherwise, let new focus target be null.
◎
If new focus target is not null, then run the focusing steps for new focus target.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`現在の被focus区画$ %F が，それに代わる別の要素が明示的に~focusされずに，何らかの方法で~unfocusされた場合、~UAは，`即時に$次を走らすモノトスル
⇒
`~objを~unfocusする$( %F )
◎
When the currently focused area of a top-level browsing context is somehow unfocused without another element being explicitly focused in its stead, the user agent must immediately run the unfocusing steps for that object.
</p>
</div>

<p class="note">注記：
`~objを~unfocusする$ことにより，常に~focusが変更されるとは限らない
— `現在の被focus区画$に適用されるときであっても。
例えば，`現在の被focus区画$は`表示域$である場合、通例的には，［
`~objを~focusする$ことにより，別の`~focus可能な区画$が明示的に~focusされる
］までは，その~focusを保つことになる。
◎
The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level browsing context. For example, if the currently focused area of a top-level browsing context is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.
</p>

<hr>

<p>
`~focus修復~規則@
⇒
`文書$ %文書 が`指名する被focus区画$が %文書 に属さなくなったときは（例：
`~focus可能な区画$でなくなった ／
~DOMから除去された ／
`明に不活$になった,
等々）
⇒
%文書 が`指名する被focus区画$を %文書 の`表示域$にする
◎
Focus fixup rule: When the designated focused area of the document is removed from that Document in some way (e.g. it stops being a focusable area, it is removed from the DOM, it becomes expressly inert, etc.), designate the Document's viewport to be the new focused area of the document.
</p>

<p class="example">
これは、例えば次のときに起こり得る
⇒＃
要素が`文書$から除去されたとき／
`hidden$a 属性が追加されたとき／
`input$e 要素が`不能化され$たとき
◎
For example, this might happen because an element is removed from its Document, or has a hidden attribute added. It might also happen to an input element when the element gets disabled.
</p>

<p class="example">
`文書$が`指名する被focus区画$は `button$e 要素である下で，その~buttonが［
除去され ／不能化され ／ 隠され
］た場合、~pageが新たに`指名する被focus区画$は，`文書$の`表示域$になる。
その結果、 `activeElement$m は`~body要素$を返すようになる。
◎
In a Document whose focused area is a button element, removing, disabling, or hiding that button would cause the page's new focused area to be the viewport of the Document. This would, in turn, be reflected through the activeElement API as the body element.
</p>

<hr>

<div class="algorithm">
<p>
`~focusを更新する@
ときは、所与の
( %旧~鎖, %新~鎖, %新~標的 )
に対し，次の手続きを走らす：
◎
The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:
</p>

<ol>
	<li>
~WHILE［
%旧~鎖 内の最後の~entry ~EQ %新~鎖 内の最後の~entry
］
⇒＃
%旧~鎖 内から最後の~entryを~popする；
%新~鎖 内から最後の~entryを~popする
◎
If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.
</li>
	<li>
<p>
%旧~鎖 内の
~EACH( ~entry %~entry )
に対し：
◎
For each entry entry in old chain, in order, run these substeps:
</p>
		<ol>
			<li id="unfocus-causes-change-event">
<p>
~IF［
次のいずれも満たされる
］…
</p>

<ul ><li>%~entry は `input$e 要素 %要素 である
</li><li>%要素 には `change$et ~eventが
<a href="~HEinput#concept-input-apply">適用される</a>
</li><li>%要素 には`作動化の挙動$は定義されていない
</li><li>%要素 が~focusされている間に，利用者は %要素 の［
`値$fe ／ `選択-中の~fileの~list$
］を変更していて、その（~controlが最初に~focusされたときと異なるような）変更はまだ~commitされていない
</li></ul>

<p>
…ならば
⇒
%要素 に向けて，名前 `change$et の`~eventを発火する$
—　次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
</p>
◎
If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behavior, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then fire an event named change at the element, with the bubbles attribute initialized to true.
</li>
			<li>
%~blur~event標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry は要素である
］
⇒
%~blur~event標的 ~LET %~entry
◎
If entry is an element, let blur event target be entry.
</li>
			<li>
~ELIF［
%~entry は`文書$である
］
⇒
%~blur~event標的 ~LET %~entry に`関連な大域~obj$
◎
If entry is a Document object, let blur event target be that Document object's relevant global object.
◎
Otherwise, let blur event target be null.
</li>
			<li>
%関係する標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %旧~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%新~鎖 内の最後の~entryは`要素$である
］
⇒
%関係する標的 ~LET %新~鎖 内の最後の~entry
◎
If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.
</li>
			<li>
<p>
~IF［
%~blur~event標的 ~NEQ ~NULL
］
⇒
%~blur~event標的 に向けて `~focus~eventを発火する$( `blur$et, %関係する標的 )
◎
If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.
</p>

<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
	<li>
~IF［
%新~標的 の~focus時に，~platformに特有な関連な規約がある
］
⇒
その規約を適用する（例えば，一部の~platformは、~text~controlに~focusされたときに，その内容を選択する）
◎
Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text control when that control is focused.)
</li>
	<li>
<p>
%新~鎖 内の
~EACH( ~entry %~entry )
に対し，逆順に：
◎
For each entry entry in new chain, in reverse order, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~entry は`~focus可能な区画$である
］
⇒
%~entry が属する`文書$が`指名する被focus区画$ ~SET %~entry
◎
If entry is a focusable area: designate entry as the focused area of the document.
</li>
			<li>
%~focus~event標的 ~LET %~entry に応じて
⇒＃
要素であるならば %~entry ／
`文書$であるならば %~entry に`関連な大域~obj$ ／
~ELSE_ ~NULL
◎
If entry is an element, let focus event target be entry.
◎
If entry is a Document object, let focus event target be that Document object's relevant global object.
◎
Otherwise, let focus event target be null.
</li>
			<li>
%関係する標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %新~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%旧~鎖 内の最後の~entryは`要素$である
］
⇒
%関係する標的 ~SET %旧~鎖 内の最後の~entry
◎
If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.
</li>
			<li>
<p>
~IF［
%~focus~event標的 ~NEQ ~NULL
］
⇒
%~focus~event標的 に向けて `~focus~eventを発火する$( `focus$et, %関係する標的 )
◎
If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.
</p>

<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`~focus可能な図形$ ／ ~scroll可能な領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
%要素 に向けて
`~focus~eventを発火する@
ときは、所与の
( 名前 %e, 関係する標的 %r )
に対し，
%要素 に向けて，名前 %e の`~eventを発火する$
— `FocusEvent$I を利用し，次のように初期化して
⇒＃
`relatedTarget$m 属性 ~SET %r,
`view$m 属性 ~SET %要素 の`~node文書$に`関連な大域~obj$,
`~composed~flag$ ~SET ~T
◎
To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the relatedTarget attribute initialized to r, the view attribute initialized to t's node document's relevant global object, and the composed flag set.
</p>
</div>

<hr>

<div class="algorithm">
<p>
~UAは、`~top-level閲覧文脈$内で~Key~event %~event を届けるときは、次の手続きを走らすモノトスル：
◎
When a key event is to be routed in a top-level browsing context, the user agent must run the following steps:
</p>

<ol>
	<li>
%標的~区画 ~LET `現在の被focus区画$
◎
Let target area be the currently focused area of the top-level browsing context.
</li>
	<li>
%標的~node ~LET ［
%標的~区画 は`~focus可能な区画$ならば %標的~区画 の`~DOM~anchor$ ／
~ELSE_ %標的~区画
］
◎
If target area is a focusable area, let target node be target area's DOM anchor. Otherwise, target area is a dialog; let target node be target area.
</li>
	<li>
~IF［
%標的~node は`文書$である
］
⇒
%標的~node ~SET ［
%標的~node の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %標的~node の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %標的~node
］
◎
If target node is a Document that has a body element, then let target node be the body element of that Document.
◎
Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.
</li>
	<li>
<p>
~IF［
%標的~node は`不活$である
］
⇒
~RET
◎
If target node is not inert, then:
</p>

<p class="note">注記：
`現在の被focus区画$は`不活$にもなり得る
— 例えば`~modal~dialogが示され$ていて，その `dialog$e 要素が`不活$にされているとき。
それは，~appにおける~logicの誤りによる可能性が高いが。
◎
It is possible for the currently focused area of a top-level browsing context to be inert, for example if a modal dialog is shown, and then that dialog element is made inert. It is likely to be the result of a logic error in the application, though.
</p>
	<li>
%canHandle ~LET %標的~node に向けて %~event を`配送-$した結果
◎
Let canHandle be the result of dispatching the key event at target node.
</li>
	<li>
~IF［
%canHandle ~EQ ~T
］
⇒
%標的~区画 に %~event を取扱わせる
— これは、 %標的~node に向けて`~click~eventを発火する$ことも含み得る。
◎
If canHandle is true, then let target area handle the key event. This might include firing a click event at target node.
</li>
</ol>
</div>

<hr>

<div class="algorithm">
<p>
所与の`文書$ %標的 は、所与の時点で，次の手続きが ~T を返すならば
`~focusを得ている@
とされる：
◎
The has focus steps, given a Document object target, are as follows:
</p>

<ol>
	<li>
%B ~LET %標的 が`属する閲覧文脈$の`~top-level閲覧文脈$
<!-- ＊原文抜け “作動中の” -->
◎
Let candidate be the Document of the top-level browsing context.
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%候補 ~LET %B にて`作動中の文書$
◎
↑↓</li>
			<li>
~IF［
%候補 ~EQ %標的
］
⇒
~RET ~T
◎
If candidate is target, then return true.
</li>
			<li>
~IF［
%候補 が`指名する被focus区画$は、ある`閲覧文脈$を`入子にしている閲覧文脈~容器$である
］
⇒
%B ~SET その閲覧文脈
◎
If the focused area of candidate is a browsing context container with a non-null nested browsing context, then set candidate to the active document of that browsing context container's nested browsing context.
</li>
			<li>
~ELSE
⇒
~RET ~F
◎
Otherwise, return false.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="sequential-focus-navigation">
<h4 title="Sequential focus navigation">6.4.5. 逐次的~focus~navi</h4>

<p>
所与の`文書$に属する`~focus可能な区画$のうち いくつかは，
`逐次的~focus~navi順序@
により順序付けられ、`逐次的~focus~navi$を介して到達できるとされる。
この順序は、`~focus可能な区画の順序$に従う必要はない。
この順序から外された`~focus可能な区画$は、`逐次的~focus~navi$を介しては到達-可能でないことになる。
◎
Each Document has a sequential focus navigation order, which orders some or all of the focusable areas in the Document relative to each other. The order in the sequential focus navigation order does not have to be related to the tree order in the Document itself. If a focusable area is omitted from the sequential focus navigation order of its Document, then it is unreachable via sequential focus navigation.
</p>

<p>
逐次的~focus~naviには
`逐次的~focus~naviの始点@
もある。
それは、初期~時には ε （未設定）とする。
~UAは、利用者がそれを移動すべく指示したときに，この始点を設定してもヨイ。
◎
There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>

<p class="example">
例えば~UAは、利用者が文書の内容を~clickしたときに，その~click位置に設定することもできる。
◎
For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.
</p>

<div class="algorithm">
<div class="p">
<p>
~UAは、利用者から~focusを移動するよう要請されたとき
— 具体的には：
</p>

<ul><li>ある`~top-level閲覧文脈$ %top 内で，
</li><li>
	<ul ><li>(A) %top の`現在の被focus区画$から, または
	</li><li>(B) %top の外側（例えば，~browserの所在bar）から 先ず %top へ~focusを移動した上で，
	</li></ul>
</li><li>ある %方向 ［
`前方^i または `後方^i
］へ，
</li><li>~focusを移動するよう要請された
</li></ul>

<p>
ときには（例えば，~tab~Keyを押すことによる既定の動作として）、以下の~algoを利用するモノトスル：
</p>

<p class="note">注記：
概して、［
<kbd>`tab^kbd</kbd> ／
<kbd>`shift^kbd+`tab^kbd</kbd>
］を押すことは［
前方／後方
］にある~controlへ移動することを要請する。
</p>

◎
When the user requests that focus move from the currently focused area of a top-level browsing context to the next or previous focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level browsing context in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:
</div>

<ol>
	<li>
%始点 ~LET 上述の［
(A) ならば %top の`現在の被focus区画$ ／ (B) ならば %top
］
◎
Let starting point be the currently focused area of a top-level browsing context, if the user requested to move focus sequentially from there, or else the top-level browsing context itself, if the user instead requested to move focus from outside the top-level browsing context.
</li>
	<li>
%~focus始点 ~LET `逐次的~focus~naviの始点$
◎
↓</li>
	<li>
~IF［
%~focus始点 ~NEQ ε
］~AND［
%~focus始点 は %始点 の内側にある
］
⇒
%始点 ~LET %~focus始点
◎
If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.
◎
Let direction be forward if the user requested the next control, and backward if the user requested the previous control.
◎
Typically, pressing tab requests the next control, and pressing shift+tab requests the previous control.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Loop:＼
</p>
		<ol>
			<li>
<p>
%選定法 ~LET ［
次のいずれかが満たされるならば `逐次的^i ／
~ELSE_ `~DOM順^i
］：
</p>

<ul ><li>%始点 は`閲覧文脈$である
</li><li>%始点 ~IN %始点 が属する`文書$の`逐次的~focus~navi順序$
</li></ul>

◎
Let selection mechanism be sequential if the starting point is a browsing context or if starting point is in its Document's sequential focus navigation order.
◎
Otherwise, starting point is not in its Document's sequential focus navigation order; let selection mechanism be DOM.
</li>
			<li>
%候補 ~LET
`逐次的~navi探索~algo$( %始点, %方向, %選定法 )
◎
Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism as the arguments.
</li>
			<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒＃
`~objを~focusする$( %候補 )；
~RET
◎
If candidate is not null, then run the focusing steps for candidate and return.
</li>
			<li>
`逐次的~focus~naviの始点$ ~SET ε
◎
Otherwise, unset the sequential focus navigation starting point.
</li>
			<li>
<p>
~IF［
%始点 ~EQ %top
］~OR［
%始点 は %top 内の`~focus可能な区画$である
］：
◎
If starting point is the top-level browsing context, or a focusable area in the top-level browsing context,＼
</p>
				<ol>
					<li>
<p>
~IF［
~UAには、自前の~focus可能な~controlがある
］
⇒
~UAは、次を行うべきである
⇒
%方向 を尊守しつつ，~focusを自前の~focus可能な~controlのいずれかに適切に転送する
◎
the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.
</p>

<p class="example">
例えば， %方向 ~EQ `後方^i の場合、［
~browserの具現化~区画の直前にある~focus可能な~control
］に，~focusすることになる。
◎
For example, if direction is backward, then the last focusable control before the browser's rendering area would be the control to focus.
</p>
					</li>
					<li>
<p>
~ELSE
⇒
~UAは、次を行ってもヨイ
⇒＃
%始点 ~SET %top；
~CONTINUE
</p>

<p class="example">
~kiosk~mode~browserなど、自前の~focus可能な~controlがない~UAもあり得る。
</p>

◎
If the user agent has no focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level browsing context itself.
</li>
					<li>
~RET
◎
↑</li>
				</ol>
			</li>
			<li>
~ELSE（ %始点 は`入子の閲覧文脈$ %B 内の`~focus可能な区画$である）
⇒
%始点 ~LET %B を`入子にしている閲覧文脈~容器$
◎
Otherwise, starting point is a focusable area in a nested browsing context. Let starting point be that nested browsing context's browsing context container, and return to the step labeled loop.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`逐次的~navi探索~algo@
は、所与の
( %始点, %方向, %選定法 )
に対し，次を走らす：
◎
The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.
</p>

<div >

<ol>
	<li>
%文書 ~LET %始点 に応じて
⇒＃
`閲覧文脈$であるならば %始点 にて`作動中の文書$ ／
`~focus可能な区画$であるならば %始点 が属する`文書$†1
</li>
	<li>
%候補~集合 ~LET %文書 の`逐次的~focus~navi順序$
</li>
	<li>
~Assert：
［
%始点 は`~focus可能な区画$である
］~AND［
%選定法 ~EQ `逐次的^i
］ならば［
%始点 ~IN %候補~集合 †2
］である
<!-- ↓ class="note" -->
</li>
	<li>
%候補~集合 ~SET %候補~集合 内の`~focus可能な区画$のうち，次を満たすものからなる集合†3
⇒
その`~DOM~anchor$は`不活$でない
</li>
	<li>
<p>
~IF［
%始点 は`~focus可能な区画$である
］
⇒
%候補~集合 ~SET %候補~集合 内の~focus可能な区画のうち， %方向 に応じて 次に該当するものからなる集合
⇒＃
`前方^i ならば %始点 に後続しているもの／
`後方^i ならば %始点 に先行しているもの
</p>

<p class="trans-note">【
明示的に言及されていないが、順序は， %選定法 に応じて［
`逐次的^i ならば `逐次的~focus~navi順序$ ／
`~DOM順^i ならば `~focus可能な区画の順序$
］に基づくと見受けられる。
一方で，次の次の段では、 %選定法 を問わず，`逐次的~focus~navi順序$に基づくと見受けられる。
】</p>

	</li>
	<li>
~IF［
%候補~集合 は空である
］
⇒
~RET ~NULL
</li>
	<li>
%候補 ~SET %候補~集合 内の~focus可能な区画のうち， %方向 に応じて
⇒＃
`前方^i ならば 最初のもの ／
`後方^i ならば 最後のもの
</li>
	<li>
<p>
~IF［
%候補 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］：
</p>
		<ol>
			<li>
%新~候補 ~LET
`逐次的~navi探索~algo$( %B, %方向, `逐次的^i )
</li>
			<li>
~IF［
%新~候補 ~NEQ ~NULL
］
⇒
~RET %新~候補
</li>
			<li>
~RET `逐次的~navi探索~algo$( %候補, %方向, %選定法 )
</li>
		</ol>
	</li>
	<li>
~RET %候補
</li>
</ol>

<div class="trans-note">
<p>【
簡明にするため、この手続きの構成は，原文から大きく違えている。
原文では、この手続きにて次の用語が定義されている：
</p>

<ul ><li>†1 を指して， %始点 の
`~home文書@
という。
</li><li>†2 を指して（そこに記された条件が満たされる場合に限り）， %始点 の
`~home逐次的~focus~navi順序@
という。
</li><li>†3 を指して，
`相応しい逐次的に~focus可能な区画@
という。
</li></ul>

<p>
が、無用に煩雑になるだけで，（現時点では）他からも参照されていないので、この訳では利用しない。
】</p>
</div>

<ol lang="en">
	<li>
<p>
Pick the appropriate cell from the following table, and follow the instructions in that cell.
<p>
The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.

<table><thead><tr><th>
<th>direction is forward
<th>direction is backward
</thead>
<tbody><tr><th>
starting point is a browsing context
<td>
Let candidate be the first suitable sequentially focusable area in starting point's active document, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in starting point's active document, if any; or else null
<tr><th>
selection mechanism is DOM
<td>
Let candidate be the first suitable sequentially focusable area in the home document following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home document preceding starting point, if any; or else null
<tr><th>
selection mechanism is sequential
<td>
Let candidate be the first suitable sequentially focusable area in the home sequential focus navigation order following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home sequential focus navigation order preceding starting point, if any; or else null
</tbody></table>

<p>
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and that is in its Document's sequential focus navigation order.
<p>
The home document is the Document to which starting point belongs.
<p>
The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.
<p class="note">
The home sequential focus navigation order is the home document's sequential focus navigation order, but is only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).
</p>
	<li>
<p>
If candidate is a browsing context container with a non-null nested browsing context, then let new candidate be the result of running the sequential navigation search algorithm with candidate's nested browsing context as the first argument, direction as the second, and sequential as the third.
<p>
If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.
	<li>
Return candidate.
</ol>
</div>
</div>

			</section>
			<section id="focus-management-apis">
<h4 title="Focus management APIs">6.4.6. ~focus管理~API</h4>

<pre class="idl">
dictionary `FocusOptions@I {
  boolean `preventScroll$m = false;
};
</pre>

<dl class="domintro">
	<dt>%document . `activeElement$m</dt>
	<dd>
文書~内の要素のうち，
~Key~eventが
それを経て／それに向けて
届けられることになるような，最も深い要素を返す。
これは概ね、文書~内の被focus要素になる。
◎
Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
</dd>
	<dd>
この~APIの目的においては、`子~閲覧文脈$が~focusされるときには，それを`入子にしている閲覧文脈~容器$が`親~閲覧文脈$内で
<a href="#bc-focus-ergo-bcc-focus">~focusされる</a>。
例えば、利用者が，~focusを `iframe$e 内のある~text~controlに移動させたとき、その `iframe$e が，その`~node文書$上の `activeElement$m から返される要素になる。
◎
For the purposes of this API, when a child browsing context is focused, its browsing context container is focused in the parent browsing context. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
</dd>

	<dt>%document . `hasFocus()$m</dt>
	<dd>
~Key~eventは，［
%document へ, または %document を経て届けられている
］ならば ~T を返す。
~ELSE_ ~F を返す。
これは概ね、~focusされている［
当の文書, または
その内側に入子にされている文書
］に対応する。
◎
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.
</dd>

	<dt>%window . `focus()$m</dt>
	<dd>
~focusを %window に`対応する閲覧文脈$（もしあれば）に移動させる。
◎
Moves the focus to the window's browsing context, if any.
</dd>

	<dt>%element . `~focus0$m([ { `preventScroll$m: true } ])</dt>
	<dd>
~focusを %element に移動させる。
◎
Moves the focus to the element.
</dd>
	<dd>
要素が ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である場合、~focusは，代わりに %B へ移動される。
◎
If the element is a browsing context container, moves the focus to the nested browsing context instead.
</dd>
	<dd>
既定では、この~methodはまた，要素を~viewの中へ~scrollする。
`preventScroll$m ~optionを供して ~T に設定すれば、この挙動は防止される。
◎
By default, this method also scrolls the element into view. Providing the preventScroll option and setting it to true prevents this behavior.
</dd>

	<dt>%element . `~blur0()$m</dt>
	<dd>
~focusを`表示域$に移動させる。
この~methodは、利用しないことが奨励される。
`表示域$を~focusしたければ、`文書$の`文書~要素$上で，
`~focus0()$m ~methodを~callすること。
◎
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.
</dd>
	<dd>
~focus環が目障りであっても、~focus環を隠すためにこの~methodを利用しないこと。
代わりに、~CSS規則で `outline$p ~prop（外形線）を上書きした上で，~focusされる要素を示すような他の仕方を供すること。
そのような代替の~focus時の~styleを可用にできなかった場合、~keyboardを首に利用して~pageを~navigateしている人や，~navigateし易くするため~focus外形線を利用している弱視者にとっては、~pageの使い勝手がすこぶる悪くなることに留意すること。
◎
Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use a CSS rule to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.
</dd>
	<dd class="example">
<p>
例えば、~linkから外形線を隠す代わりに，黄色の背景を利用して~focusを指示したければ、次も利用できる：
◎
For example, to hide the outline from links and instead use a yellow background to indicate focus, you could use:
</p>

<pre class="css">
:link:focus, :visited:focus { outline: none; background: yellow; color: black; }
</pre>

	</dd>
</dl>

<dl class="idl-def">
	<dt>`activeElement@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
The activeElement attribute's getter must run these steps:
</p>
		<ol>
			<li>
%候補 ~LET 此れが`指名する被focus区画$の`~DOM~anchor$
◎
Let candidate be the DOM anchor of the focused area of this Document object.
</li>
			<li>
~IF［
%候補 は`文書$でない
］
⇒
~RET %候補
◎
If candidate is not a Document object, then return candidate.
</li>
			<li>
~RET ［
%候補 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %候補 の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL
］
◎
If candidate has a body element, then return that body element.
◎
If candidate's document element is non-null, then return that document element.
◎
Return null.
</li>
		</ol>
	</dd>

	<dt>`hasFocus()@m</dt>
	<dd>
被呼出時には、［
此れが`~focusを得ている$ならば ~T ／
~ELSE_ ~F
］を返すモノトスル。
◎
The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the Document object as the argument.
</dd>

	<dt>`Window$I ~obj上の `focus()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The focus() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%B ~LET 此れに`対応する閲覧文脈$
◎
Let current be this Window object's browsing context.
</li>
			<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET
◎
If current is null, then return.
</li>
			<li>
`~objを~focusする$( %B )
◎
Run the focusing steps with current.
</li>
			<li>
~IF［
%B は`~top-level閲覧文脈$である
］
⇒
~UAには，次を誘発することが奨励される
⇒
［
~pageが~focusを獲得しようと試みていることを，利用者に向けて指示する
］ような，何らかの類の通知
◎
If current is a top-level browsing context, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.
</li>
		</ol>
	</dd>

	<dt>`Window$I ~obj上の `blur()@m</dt>
	<dd>
被呼出時には、［
此れに`対応する閲覧文脈$ %B ~NEQ ~NULL
］ならば，次についての~hintを~UAに供する
⇒
~scriptは、利用者が，おそらく %B の内容に対する関心を失ったものと予見している
— が、当の内容に再び関心が向けられるかもしれない。
◎
The blur() method, when invoked, provides a hint to the user agent that the script believes the user probably is not currently interested in the contents of this Window object's browsing context, if non-null, but that the contents might become interesting again in the future.
</dd>
	<dd>
~UAには、この~methodの~callを全面的に無視することが奨励される。
◎
User agents are encouraged to ignore calls to this blur() method entirely.
</dd>
	<dd class="note">注記：
歴史的に、
`focus()$m ／ `blur()$m
~methodは、実際には，~system~levelの~focus
— `閲覧文脈$を包含している~system~widget（例：~tabや~window）の~focus —
にも影響していたが、この挙動は，利用者をないがしろに敵対的~siteから広範に濫用されている。
◎
Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g., tab or window) that contained the browsing context, but hostile sites widely abuse this behavior to the user's detriment.
</dd>

	<dt>要素~上の `~focus0(options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The focus(options) method on elements, when invoked, must run the following steps:
</p>
		<ol>
			<li>
~IF［
此れの`~focus~lock~flag$ ~EQ ~T
］
⇒
~RET
◎
If the element is marked as locked for focus, then return.
</li>
			<li>
此れの
`~focus~lock~flag@
【初期~時は ~F 】
~SET ~T
◎
Mark the element as locked for focus.
</li>
			<li>
`~objを~focusする$( 此れ )
◎
Run the focusing steps for the element.
</li>
			<li>
~IF［
%options の
`preventScroll@m
~memberの値 ~EQ ~F
］
⇒
次を与える下で，
此れを`~viewの中へ~scrollする$
⇒＃
~scrollの挙動 ~SET `auto^l, 
塊~flow方向~位置 ~SET ~UAにより定義される値,
行内~基底~方向~位置 ~SET ~UAにより定義される値
◎
If the value of the preventScroll dictionary member of options is false, then scroll the element into view with scroll behavior "auto", block flow direction position set to a UA-defined value, and inline base direction position set to a UA-defined value.
</li>
			<li>
此れの`~focus~lock~flag$ ~SET ~F
◎
Unmark the element as locked for focus.
</li>
		</ol>
	</dd>

	<dt>要素~上の `~blur0()@m</dt>
	<dd>
被呼出時には、次を走らすべきである
⇒
`~objを~unfocusする$( 此れ )
◎
The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called.＼
</dd>
	<dd>
~UAは、使い勝手の理由から，選択的に または一様に，この~methodの~callを無視してもヨイ。
◎
User agents may selectively or uniformly ignore calls to this method for usability reasons.
</dd>
	<dd class="example">
例えば、ただ美観の理由で， `~blur0()$m ~methodを利用して無思慮に~focus環が除去された場合、~keyboard利用者からは，~pageの使い勝手は悪くなるであろう。
この~methodの~callを無視すれば、~keyboard利用者でも~pageとヤリトリできるようになる。
◎
For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.
</dd>
</dl>

			</section>
		</section>
		<section id="assigning-keyboard-shortcuts">
<h3 title="Assigning keyboard shortcuts">6.5. ~keyboard~shortcutのアテガイ</h3>

			<section id="introduction-9">
<h4 title="Introduction">6.5.1. 序論</h4>

~INFORMATIVE

<p>
作動化-／~focusされ得るような各~要素には、
`accesskey$a 属性を利用して，それを作動化させる単独の~Key組合nをアテガえる。
◎
Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.
</p>

<p>
正確な~shortcutは、
`accesskey$a 属性から供される情報を基に，利用者の~keyboardについての情報
— ［
~platform上にすでに存在する ／
~page上で他に指定されている
］~shortcutなど —
に基づいて、~UAにより決定される
◎
The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.
</p>

<p>
`accesskey$a 属性~内にいくつもの代替を供すれば、作者は，多様な入力~装置にわたり関連な~keyboard~shortcutが可用になることを確保できる。
◎
In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.
</p>

<p>
各~代替は、普通字や数字などの単独の文字からなる。
◎
Each alternative consists of a single character, such as a letter or digit.
</p>

<p>
~UAは，利用者に~keyboard~shortcutの~listを供せるが、作者にもそうすることが奨励される。
`accessKeyLabel$m ~IDL属性は、~UAによりアテガわれた実際の~Key組合nを表現している文字列を返す。
◎
User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.
</p>

<div class="example">

<p>
次の例には、~shortcut~Keyを利用して呼出せる~buttonが供されている。
作者は、アリな~Keyとして，~full~keyboard用の "C" に加え，十keyしかないときに備えて別の~Key "1" も供している。
◎
In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possibly key.
</p>

`intro9-1^xCode

</div>

<div class="example">

<p>
どの~shortcut~Keyがあるか，利用者に伝えるため、次の~scriptでは，~buttonの~labelに ~Key組合nを明示的に追加する：
<!-- opted to＊ -->
◎
To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's label:
</p>

<pre class="js-code">
function addShortcutKeyLabel(%button) {
<strong>  if (%button.accessKeyLabel != '')
    %button.value += ' (' + %button.accessKeyLabel + ')';</strong>
}
addShortcutKeyLabel(document.getElementById('c'));
</pre>

<p>
同じ~Key組合nであっても、~browserが示す~labelは，各~platformに普及している規約に応じて異なり得る。
例えば、~Key組合nが［
Control ＋ Shift ＋ C
］ならば、［
Windows ~browserでは `Ctrl+Shift+C^samp ／
Mac ~browserでは `^⇧C^samp ／
Emacs ~browserでは `C-C^samp
］のように表示されるであろう。
同様に、~Key組合nが［
Alt ~Key ＋ Escape ~Key
］であれば、［
Windows では `Alt+Esc^samp ／
Mac では `⌥⎋^samp ／
Emacs ~browserでは `M-ESC^samp または `ESC ESC^samp
］が利用されるであろう。
◎
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".
</p>

<p>
したがって一般に、 `accessKeyLabel$m ~IDL属性から返される値を構文解析しようと試みるのは，賢明とは言えない。
◎
In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.
</p>

</div>

			</section>
			<section id="the-accesskey-attribute">
<h4 title="The accesskey attribute">6.5.2. `accesskey^a 属性</h4>

<p>
`accesskey$a 内容~属性は、すべての`~HTML要素$に設定できる。
この属性の値は、要素を［
作動化する／~focusする
］ための~keyboard~shortcutを作成する基になる情報として，~UAにより利用される。
◎
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.
</p>

<p>
この属性に指定する値は、`大小区別$される`一意な~tokenからなる空白区切りの有順序~集合$であって、各~tokenは，正確に 1 個の符号位置でなければナラナイ。
◎
If specified, the value must be an ordered set of unique space-separated tokens that are case-sensitive, each of which must be exactly one code point in length.
</p>

<div class="example">

<p>
次の例では、各~linkに~access~Keyがアテガわれている
— ~siteに馴染んでいる~keyboard利用者は，関連な~pageに素早く~navigateできるようになる：
◎
In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:
</p>

`accesskey-1^xCode

</div>

<div class="example">

<p>
次の例では、探索~欄に，アリな~access~Keyとして
`s^l, `0^l
の 2 つがこの順で与えられている。
~full~keyboard装置を備えている~UAは、~shortcut~Keyとして
<kbd>`Ctrl^kbd+`Alt^kbd+`S^kbd</kbd>
選び取るであろう。
一方で，十keyしか備えていない装置~上の~UAは、~Key
<kbd>`0^kbd</kbd>
を選び取るであろう：
◎
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:
</p>

`accesskey-2^xCode

</div>

<div class="example">
<p>
次の例では、アリな~access~Keyが~buttonに記述されている。
加えて，~UAが選択した~Key組合nを告知するため、~scriptは，~buttonの~labelを更新しようと試行する。
◎
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.
</p>

<pre class="html-code">
&lt;input type=submit accesskey="N @ 1" value="Compose"&gt;
...
&lt;script&gt;
 function labelButton(%button) {
   if (%button.accessKeyLabel)
     %button.value += ' (' + %button.accessKeyLabel + ')';
 }
 var %inputs = document.getElementsByTagName('input');
 for (var %i = 0; %i &lt; %inputs.length; %i += 1) {
   if (%inputs[%i].type == "submit")
     labelButton(%inputs[%i]);
 }
&lt;/script&gt;
</pre>

<p>
~buttonの~labelは、~UAに応じて，
`Compose (⌘N)^l にも `Compose (Alt+⇧+1)^l にもなり得る。
~UAが~Keyをアテガわなければ、 `Compose^l のみになる。
正確な文字列は、`アテガわれている~access~Key$, および
~UAがその~Key組合nをどう表現するかに依存する。
◎
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.
</p>

</div>

			</section>
			<section id="keyboard-shortcuts-processing-model">
<h4 title="Processing model">6.5.3. 処理~model</h4>

<p>
要素に
`アテガわれている~access~Key@
とは、要素の `accesskey$a 内容~属性から導出される~Key組合nである
— 初期~時には、どのような~access~Keyもアテガわれないモノトスル。
◎
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.
</p>

<div class="algorithm">
<p>
~UAは、要素の `accesskey$a 属性が［
設定- ／ 変更- ／除去-
］される度に、次の手続きを走らせて得られる~access~Keyで，要素に`アテガわれている~access~Key$を更新するモノトスル：
◎
Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:
</p>

<ol>
	<li>
<p>
~IF［
要素は `accesskey$a 属性を有する
］
⇒
`~ASCII空白で分割する$( 属性の値 )
— その結果を成す
~EACH( %値 )
に対し：
◎
If the element has no accesskey attribute, then skip to the fallback step below.
◎
Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.
◎
For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:
</p>
		<ol>
			<li>
~IF［
%値 を成す符号位置の個数 ~NEQ 1
］
⇒
~CONTINUE
◎
If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 は~systemの~keyboard上のどの~Keyにも対応しない
］
⇒
~CONTINUE
◎
If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.
</li>
			<li>
任意選択で
⇒
~IF［
%値 に対応する~Keyと, 0 個以上の修飾~Keyとの組み合わせに，~access~Keyとして利用できるものがある
］
⇒
~RET その~Key組合n
~FINGERPRINTING
◎
If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and return. (This is a fingerprinting vector.)
</li>
		</ol>
	</li>
	<li>
任意選択で
⇒
~RET ~UAが選んだ~Key組合n
◎
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then return.
</li>
	<li>
~RET ~access~Keyなし
◎
If this step is reached, the element has no assigned access key.
</li>
</ol>
</div>

<p>
要素~用に~access~Keyを選択してアテガった~UAは、要素の `accesskey$a 内容~属性が変更されるか，要素が別の`文書$へ移動されるまでは、要素に`アテガわれている~access~Key$を変更するべきでない。
◎
Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.
</p>

<div class="p">
<p>
`~commandを定義する$ような要素に対し，［
利用者が，それに`アテガわれている~access~Key$に対応する~Key組合nを押下げた
］ときは、~UAは，次のいずれも満たされるならば，その~commandの`動作$cFを誘発するモノトスル：
</p>

<ul><li>~commandの`隠d状態$cF ~EQ ~F （可視である）
</li><li>~commandの`不能化~状態$cF ~EQ  ~F （可能化されている）
</li><li>要素は、次を満たす`文書~内にある$
⇒
`属する閲覧文脈$ ~NEQ ~NULL
</li><li>要素, および そのどの先祖も， `hidden$a 属性を有さない
</li></ul>
◎
When the user presses the key combination corresponding to the assigned access key for an element, if the element defines a command, the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a document that has a non-null browsing context, and neither the element nor any of its ancestors has a hidden attribute specified, then the user agent must trigger the Action of the command.
</div>

<p class="note">注記：
~UAは、 `accesskey$a 属性を有する要素を，他の仕方で
— 例えば，特定の~Key組合nに呼応して表示される~menu内に —
<a href="~HEinteractive#expose-commands-in-ui">公開することもある</a>。
◎
User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.
</p> 

<hr>

<dl class="idl-def">
	<dt>`accessKey@m</dt>
	<dd>
`accesskey$a 内容~属性を`反映する$モノトスル。
◎
The accessKey IDL attribute must reflect the accesskey content attribute.
</dd>

	<dt>`accessKeyLabel@m</dt>
	<dd>
要素に`アテガわれている~access~Key$が［
あれば それを表現する文字列 ／
なければ空~文字列
］を返すモノトスル。
◎
The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.
</dd>
</dl>

			</section>
		</section>
		<section id="editing-2">
<h3 title="Editing">6.6. 編集</h3>

			<section id="contenteditable">
<h4 title="Making document regions editable: The contenteditable content attribute">6.6.1. 文書の領域を編集-可能にする： `contenteditable^a 属性</h4>

<pre class="idl">
interface mixin `ElementContentEditable@I {
  [`CEReactions$] attribute DOMString `contentEditable$m;
  readonly attribute boolean `isContentEditable$m;
  [`CEReactions$] attribute DOMString `inputMode$m;
};
</pre>

<div class="p">
<p>
`contenteditable@a
内容~属性は`列挙d属性$である。
とり得る~keywordの集合は
{ 空~文字列, `true^v, `false^v }
であり，次の状態に対応付けられる：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dt>`true^v</dt>
	<dd>
`~T^st 状態に対応付けられ、当の要素は編集-可能であることを指示する。
</dd>

	<dt>`false^v</dt>
	<dd>
`~F^st 状態に対応付けられ、当の要素は編集-可能でないことを指示する。
</dd>

	<dt>`値なし用の既定$</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`継承-^st 状態に対応付けられ、当の要素は，親が編集-可能ならそうなることを指示する。
</dd>
</dl>
◎
The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true, and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid value default.
◎
The true state indicates that the element is editable. The inherit state indicates that the element is editable if its parent is. The false state indicates that the element is not editable.
</div>

<div class="example">
<p>
例えば、~page内に 新たな~~記事の~~投稿用に `form$e と `textarea$e があり、利用者は~HTMLで~~記事を書くよう期待されているとする：
◎
For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:
</p>

`contenteditable-1^xCode

<p>
~scriptが可能化されている下では、
`contenteditable$a 属性を利用して，
`textarea$e 要素を~rich~text~controlに置換することもできる：
◎
When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the contenteditable attribute:
</p>

`contenteditable-2^xCode

<p>
例えば，~linkを挿入-可能にする特能は、
`execCommand()$m ~APIを利用して, あるいは
`Selection$I ~APIと他の~DOM~APIを利用して実装できる。
`EXECCOMMAND$r `SELECTION$r `DOM$r
◎
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]
</p>

</div>

<div class="example">
<p>
`contenteditable$a
属性は、効果を great にする【？】ためにも利用できる：
◎
The contenteditable attribute can also be used to great effect:
</p>

`contenteditable-3^xCode

</div>

<dl class="domintro">
	<dt>%element . `contentEditable$m [ = %value ]</dt>
	<dd>
`contenteditable$a 属性の状態に基づいて［
`true^l, `false^l,  `inherit^l
］いずれかを返す。
◎
Returns "true", "false", or "inherit", based on the state of the contenteditable attribute.
</dd>
	<dd>
設定してその状態を変更できる
— 新たな値がこれらの文字列のいずれでもない場合、
`SyntaxError$E 例外が投出される。
◎
Can be set, to change that state.
◎
Throws a "SyntaxError" DOMException if the new value isn't one of those strings.
</dd>

	<dt>%element . `isContentEditable$m</dt>
	<dd>
要素が編集-可能ならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is editable; otherwise, returns false.
</dd>
</dl>

<dl class="idl-def">
	<dt>`contentEditable@m</dt>
	<dd>
取得子は、要素~上の
`contenteditable$a 内容~属性の状態に応じて，次を返すモノトスル
⇒＃
`~T^st ならば `true^l ／
`~F^st ならば `false^l ／
~ELSE_ `inherit^l
◎
The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "false" if the content attribute is set to the false state, and "inherit" otherwise.＼
</dd>
	<dd>
<p>
設定子は、`~ASCII小文字~化する$( 所与の値 ) の結果に応じて，次を走らすモノトスル：
</p>

<dl class="switch"
	><dt>`inherit^l
</dt><dd>内容~属性を除去する

</dd><dt>`true^l
</dt><dd>内容~属性 ~SET `true^l

</dd><dt>`false^l
</dt><dd>内容~属性 ~SET `false^l

</dd><dt>その他
</dt><dd>~THROW `SyntaxError$E
</dd></dl>

◎
On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" DOMException.
</dd>

	<dt>`isContentEditable@m</dt>
	<dd>
取得子は、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返すモノトスル
⇒
要素は`編集中の~host$または `編集-可能$である
◎
The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.
</dd>
</dl>

			</section>
			<section id="making-entire-documents-editable:-the-designmode-idl-attribute">
<h4 title="Making entire documents editable: the designMode IDL attribute">6.6.2. 文書~全体を編集-可能にする： `designMode^m ~IDL属性</h4>

<p>
文書は
`~designMode@
を持ち、可能化したり不能化できる。
◎
Documents have a designMode, which can be either enabled or disabled.
</p>

<dl class="domintro">
	<dt>%document . `designMode$m [ = %value ]</dt>
	<dd>
文書は［
編集-可能ならば `on^l ／
~ELSE_ `off^l
］返す。
◎
Returns "on" if the document is editable, and "off" if it isn't.
</dd>
	<dd>
設定して文書の現在の状態を変更できる。
これは、文書を~focusした上で，文書~内の選択を再設定する。
◎
Can be set, to change the document's current state. This focuses the document and resets the selection in that document.
</dd>
</dl>

<dl class="idl-def">
	<dt>`designMode@m</dt>
	<dd>
この属性がとり得る値は［
`on^l, `off^l
］のいずれかである。
◎
The designMode IDL attribute on the Document object takes two values, "on" and "off".＼
</dd>
	<dd>
<p>
設定子は、`~ASCII小文字~化する$( 所与の値 ) の結果に応じて，次を走らすモノトスル：
</p>

		<dl class="switch">
			<dt>`on^l</dt>
			<dd>
此れの`~designMode$を可能化する
</dd>

			<dt>`off^l</dt>
			<dd>
此れの`~designMode$を不能化する
</dd>

			<dt>その他</dt>
			<dd>
無視する
</dd>
		</dl>
◎
On setting, the new value must be compared in an ASCII case-insensitive manner to these two values; if it matches the "on" value, then designMode must be enabled, and if it matches the "off" value, then designMode must be disabled. Other values must be ignored.
</dd>
	<dd>
取得子は、［
次が満たされるならば `on^l ／
~ELSE_ `off^l
］を返すモノトスル
⇒
此れの`~designMode$は可能化されている
◎
On getting, if designMode is enabled, the IDL attribute must return the value "on"; otherwise it is disabled, and the attribute must return the value "off".
</dd>
</dl>

<p>
文書の`~designMode$は、初期~時には，不能化されるモノトスル。
また、文書が破壊されるか, 状態が変化するまで，最後に設定された状態を持続するモノトスル。
◎
The last state set must persist until the document is destroyed or the state is changed. Initially, documents must have their designMode disabled.
</p>

<p>
不能化されている`~designMode$が可能化されたときは、~UAは，`即時に$文書の`作動範囲$の［
始端／終端
］境界点を`文書$の始端に再設定した上で、［
`文書$の`文書~要素$ %E ~NEQ ~NULL
］ならば、次を走らすモノトスル
⇒
`~objを~focusする$( %E )
◎
When the designMode changes from being disabled to being enabled, the user agent must immediately reset the document's active range's start and end boundary points to be at the start of the Document and then run the focusing steps for the document element of the Document, if non-null.
</p>

			</section>
			<section id="best-practices-for-in-page-editors">
<h4 title="Best practices for in-page editors">6.6.3. ~page編集者による最善な実施</h4>

<p>
作者には、［
`編集中の~host$, および
編集-用の仕組みを通して作成された~markup
］上の `white-space$p ~propを値 `pre-wrap^v に設定することが奨励される。
~HTMLにおける空白に対する既定の取扱いは， WYSIWYG 編集には不向きであり、
`white-space$p が既定~値のままだと，一部のきわどい事例では，行lの折返しが正しく働かなくなる。
◎
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.
</p>

<div class="example">

<p>
既定の `normal^v 値が利用された場合に生じる問題の一例として、利用者が［
"`yellow^kbd", `space^i, `space^i, `ball^kbd"
］を続けて打込んだときを考える。
`white-space$p の既定の値（ `normal^v ）の下では，~~連続する `space^i は一つに縮約する呈示が要求されるため、結果の~markupを［
`yellow^l, `nbsp^i, `space^i, `ball^l
］の並び, または［
`yellow^l, `space^i, `nbsp^i, `ball^l
］の並びとするような編集~規則が必要とされる
— ここで， `nbsp^i は分断不可 space（ non-breaking space ）,
`space^i は普通の space（ U+0020 ）を表すとする。
<!--  "␣"  -->
◎
As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&amp;nbsp; ball" or "yellow &amp;nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.
</p>

<p>
2 つの単語の合間で行lを折返す必要がある場合、前者の［
`nbsp^i, `space^i
］並びの事例では，行lの終端までに単語 `yellow^l のみが収まる場合でも，
`nbsp^i の直後で次の行lへ折返され、後者の［
`space^i, `nbsp^i
］並びの事例では， `nbsp^i の直前で次の行lへ折返される
— その結果、単語 `ball^l の前に字下げが露わになる。
◎
In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.
</p>

<p>
一方で、 `white-space$p が `pre-wrap^v に設定されている下での編集~規則は、単語の合間に 2 個の `space^i を挟むだけ済む。
その結果、 2 個の単語は行lの終端の所で分割され，~spaceは具現化からきれいに除去されることになる。
◎
When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.
</p>

</div>

			</section>
			<section id="editing-apis">
<h4 title="Editing APIs">6.6.4. 編集~API</h4>

<div>
<p>
次に挙げるものは、
`EXECCOMMAND$r 仕様にて定義される：
</p>

<ul ><li id="active-range">`作動範囲$
</li><li id="editing-host">`編集中の~host$
</li><li id="editing-host-of">~nodeが`属する編集中の~host$
</li><li id="editable">`編集-可能$
</li><li>［
`編集中の~host$ ／ `編集-可能$
］である要素に課される~UI要件
</li><li>~text選択
</li><li id="delete-the-selection">`選択を削除-$する~algo
</li><li>
<p>
次に挙げる各種~method
⇒＃
`execCommand()$m,
`queryCommandEnabled()$m,
`queryCommandIndeterm()$m,
`queryCommandState()$m,
`queryCommandSupported()$m,
`queryCommandValue()$m
</li></ul>

◎
The definition of the terms active range, editing host, editing host of, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand. [EXECCOMMAND]
</div>

			</section>
			<section id="spelling-and-grammar-checking">
<h4 title="Spelling and grammar checking">6.6.5. 綴りや文法の検査ng： `spellcheck^a 属性</h4>

<p>
~UAは、［
~form~control（ `textarea$e 要素の値など）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用して）
］内の編集-可能~textに対する綴りや文法の検査ngを~supportできる。
◎
User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).
</p>

<p>
~UAは、各~要素に対し，［
既定のもの, または利用者の選好
］を通して、
`既定の挙動@
を確立するモノトスル。
各~要素に対してアリな既定の挙動には、次の 3 種がある：
◎
For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:
</p>

<dl>
	<dt>
`既定で行う@
◎
true-by-default
</dt>
	<dd>
要素の内容の綴りや文法は、その内容が編集-可能であって，その検査ngは
`spellcheck$a 属性を通して明示的に不能化されていないならば、検査される。
◎
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
</dd>
	<dt>
`既定で行わない@
◎
false-by-default
</dt>
	<dd>
要素の綴りや文法は、 `spellcheck$a 属性を通して明示的に可能化されていない限り，決して検査されない。
◎
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
</dd>
	<dt>
`既定で継承する@
◎
inherit-by-default
</dt>
	<dd>
要素の既定の挙動は、その親~要素のそれと同じになる。
親~要素がない場合、既定の挙動はない。
◎
The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.
</dd>

</dl>

<hr>

<div class="p">
<p>
`spellcheck@a
属性は，`列挙d属性$であり、次に挙げる~keyword, および対応する状態をとり得る：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dt>`true^v</dt>
	<dd>
`~T^st 状態に対応付けられる。
</dd>

	<dt>`false^v</dt>
	<dd>
`~F^st 状態に対応付けられる。
</dd>

	<dt>`値なし用の既定$</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`既定の挙動^st 状態に対応付けられる。
</dd>
</dl>
◎
The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the default state, which is the missing value default and the invalid value default.
</div>

<p class="note">注記：
［
`~T^st ／ `~F^st ／ `既定の挙動^st
］状態は、当の要素の綴りや文法が，［
検査される ／ 検査されない ／ 検査されるかどうかは`既定の挙動$に則る
］ことを指示する。
`既定の挙動$に則る場合、場合によっては親~要素の `spellcheck$a 状態に基づくことになる。
◎
The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The false state indicates that the element is not to be checked.
</p>

<hr>

<dl class="domintro">
	<dt>%element . `spellcheck$m [ = %値 ]</dt>
	<dd>
要素の綴りや文法が検査されるならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.
</dd>
	<dd>
設定して、既定の挙動を上書きしつつ，
`spellcheck$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the spellcheck content attribute.
</dd>
</dl>

<dl class="idl-def">
	<dt>`spellcheck@m</dt>
	<dd>
<p>
取得子は、此れの `spellcheck$a 内容~属性の状態に応じて，次を走らすモノトスル：
</p>

		<dl class="switch">
			<dt>`~T^st</dt>
			<dd>
~RET ~T
</dd>
			<dt>`~F^st</dt>
			<dd>
~RET ~F
</dd>
			<dt>`既定の挙動^st</dt>
			<dd>
<p>
要素の`既定の挙動$に応じて：
</p>
				<dl class="switch">
				<dt>`既定で行う$</dt>
				<dd>
~RET ~T
</dd>
				<dt>`既定で行わない$</dt>
				<dd>
~RET ~F
</dd>
				<dt>`既定で継承する$</dt>
				<dd>
~RET 要素の親~要素の `spellcheck$m ~IDL属性を取得した結果
【親~要素がない場合は？】
</dd>
			</dl>
		</dd>
	</dl>
◎
The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behavior is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behavior is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.
</dd>
	<dd class="note">注記：
`spellcheck$m ~IDL属性は、［
利用者による， `spellcheck$a 内容~属性を上書きする選好
］からは影響されないため、実際の綴りや文法に対する検査ng状態を反映しないこともある。
◎
The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.
</dd>
	<dd>
設定子は、要素の `spellcheck$a 内容~属性を［
所与の値 ~EQ ~T ならば 文字列 `true^l ／
~ELSE_ `false^l
］に設定するモノトスル。
◎
On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".
</dd>
</dl>

<hr>

<p>
この特能の目的において検査-可能な~textは：
◎
User agents must only consider the following pieces of text as checkable for the purposes of this feature:
</p>

<ul>
	<li>
<p>
次に挙げる~text片に限られるモノトスル：
◎
↑</p>

		<ul>
			<li>
<p>
［
次のいずれも満たすような `input$e 要素
］の，`値$fe：
</p>

<ul><li>`type$a 属性の状態 ~IN { `Text$st, `Search$st, `Url$st, `Email$st }
</li><li>`変異-可能$ （すなわち、 `readonly$a 属性は有さない, かつ`不能化され$ていない）
</li></ul>
◎
The value of input elements whose type attributes are in the Text, Search, URL, or E-mail states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
</li>
			<li>
<p>
［
次のいずれも満たすような `textarea$e 要素
］の，`値$fe：
</p>

<ul><li>`~readonly0$a 属性は有さない
</li><li>`不能化され$ていない
</li></ul>

◎
The value of textarea elements that do not have a readonly attribute and that are not disabled.
</li>
			<li>
［
`編集中の~host$ ／ `編集-可能$な要素
］の子であるような `Text$I ~node内の~text。
◎
Text in Text nodes that are children of editing hosts or editable elements.
</li>
			<li>
`編集-可能$な要素の属性~内の~text。
◎
Text in attributes of editable elements.
</li>
		</ul>
	</li>
	<li>
<p>
所与の~textが属するとされる要素は、次で与えられる：
</p>

<ul><li>`Text$I ~nodeの一部を成す~textに対しては、［
単語, 一文, その他の~text片
］の最初の文字の直の親である要素。
</li><li>属性~内の~textに対しては、当の属性を有している要素。
</li><li>`input$e ／ `textarea$e 要素の値に対しては、要素~自身。
</li></ul>

◎
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.
</li>
</ul>

<div class="algorithm">
<p>
綴りや文法の検査ngが適用-可能な要素 %要素 に属する~textに対する検査ngは、次の~algoの結果が［
`可能化される^i ならば可能化される ／ `不能化される^i ならば不能化される
］モノトスル：
◎
To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:
</p>

<ol>
	<li>
~IF［
利用者は、この~textに対する検査ngを不能化している
］
⇒
~RET `不能化される^i
◎
If the user has disabled the checking for this text, then the checking is disabled.
</li>
	<li>
~IF［
利用者は、この~textの検査ngを常に可能化するように強制している
］
⇒
~RET `可能化される^i
◎
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
</li>
	<li>
%要素~list ~SET［
%要素 , および その先祖~要素
］からなる，%要素 に近い順の~list
◎
↓</li>
	<li>
<p>
%要素~list 内の
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%状態 ~LET %E の `spellcheck$a 内容~属性の状態
</li>
			<li>
~IF［
%状態 ~EQ `既定の挙動^st
］
⇒
~CONTINUE
</li>
			<li>
~RET %状態 に応じて
⇒＃
`~T^st ならば `可能化される^i ／
`~F^st ならば `不能化される^i
</li>
		</ol>
◎
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.
◎
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.
</li>
	<li>
<p>
%要素~list 内の
~EACH( %E )
に対し：
</p>
		<ol>
			<li>
%挙動 ~LET %E の`既定の挙動$
</li>
			<li>
~IF［
%挙動 ~EQ `既定で継承する$
］
⇒
~CONTINUE†
</li>
			<li>
~RET %挙動 に応じて
⇒＃
`既定で行う$ならば `可能化される^i ／
`既定で行わない$ならば `不能化される^i
</li>
		</ol>

<p class="trans-note">【†
原文では，この~algoを %E の親に対し再帰的に呼出しているが、前~段にて， %E のどの先祖の `spellcheck$a 内容~属性の状態も `既定の挙動^st であることはすでに判っているので、この段で反復することで十分になる。
】</p>

◎
Otherwise, if the element's default behavior is true-by-default, then checking is enabled.
◎
Otherwise, if the element's default behavior is false-by-default, then checking is disabled.
◎
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
</li>
	<li>
~RET `不能化される^i
◎
Otherwise, checking is disabled.
</li>
</ol>
</div>

<p>
単語や一文などの~textに対する検査ngが可能化されている場合、~UAは，その~text内に綴りや文法の誤りがあれば それを指示するべきである。
~UAは、綴りや文法の訂正を示唆するときには，文書~内に所与の他の意味論も織り込むべきである — これには、次が含まれる：
◎
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections.＼
</p>

<ul>
	<li>
綴りや文法に利用する規則を、要素に指定されている自然言語や, 利用者が選好している自然言語~設定群から決定してもヨイ。
◎
User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings.＼
</li>
	<li>
アリな所では、 `pattern$a などの `input$e 要素~属性を利用して，結果の値が妥当になることを確保するべきである。
◎
UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.
</li>
</ul>

<p>
検査ngが不能化されている場合、~UAは，その~textに対する綴りや文法の誤りを指示するべきでない。
◎
If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.
</p>

<div class="example">

<p>
次の例の単語 `Hello^l に対しては、その綴りを検査するかどうかを決定するときに，~ID `a^l の要素が利用され、その結果，検査されないになる。
◎
The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.
</p>

`spelling-1^xCode

<p>
次の例における~ID `b^l の要素に対しては、検査ngは可能化される（ `input$e 要素~上の属性~値~内の頭部の~ASCII空白は，属性を無視させるので、既定の挙動にかかわらず先祖の値が代わりに利用される）。
◎
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).
</p>

`spelling-2^xCode

</div>

<p class="note">注記：
この仕様は、綴りや文法~検査器~用の~UIは定義しない。
例えば~UAは、［
その場で検査ngを提供する ／
検査ngが可能化されている間，継続的に検査ngを遂行する ／
その他の~UI
］のいずれも利用できる。
◎
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.
</p>

			</section>
			<section id="autocapitalization">
<h4 title="Autocapitalization">6.6.6. 自動頭字化： `autocapitalize^a 属性</h4>

<p>
~textを手入力する~methodには、例えば，携帯~機器~上の~virtual-keyboardや ~voice入力などもあり、各~一文の最初の字lを自動的に頭字化（ capital 化 ）して，利用者を支援することが多い（当の自然言語にこの規約がある下で，~textを組成しているならば）。
【 字l（ letter ）とは、約物等を除く，“普通の” 文字を指す。】
自動頭字化を実装する~virtual-keyboardは、自動頭字化されるべき字lが打込まれつつあるとき，自動的に字lを大文字で示すよう切替えるかもしれない（利用者が小文字に戻せるようにしつつ）。
他の型の入力，例えば~voice入力では、最初に介入する~~余地を利用者に与えない仕方で，自動頭字化を遂行することもある。
`autocapitalize$a 属性は、作者がそのような挙動を制御できるようにする。
◎
Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.
</p>

<p>
`autocapitalize$a 属性は、概して，物理的~keyboardを打込むときの挙動には影響しないように実装される。
（この理由から, および［
一部の事例で自動頭字化の挙動を上書きできる／初期~入力の後に~textを編集する
］能を利用者に与えるため、いかなる類の入力~検証も，この属性には依拠しないモノトスル。）
◎
The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.)
</p>

<p>
`autocapitalize$a 属性は、次に該当するものに利用できる：
◎
The autocapitalize attribute can be used＼
</p>

<ul>
	<li>
`編集中の~host$
— ~hostされている編集-可能~領域~用に自動頭字化の挙動を制御するためとして。
◎
on an editing host to control autocapitalization behavior for the hosted editable region,＼
</li>
	<li>
［
`input$e ／ `textarea$e
］要素
— その要素の中に~textを入力するときの挙動を制御するためとして。
◎
on an input or textarea element to control the behavior for inputting text into that element, or＼
</li>
	<li>
`form$e 要素
— その~formが所有していて, `自動頭字化-を継承-$する要素すべての，既定の挙動を制御するためとして。
◎
on a form element to control the default behavior for all autocapitalize-inheriting elements associated with the form element. 
</li>
</ul>

<p>
`autocapitalize$a 属性は、次に該当するものに対しては，決して自動頭字化を可能化させない（この挙動は、下の`使用~自動頭字化~hint$~algoに含まれている）
⇒
`input$e 要素のうち，［
その`type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］なるもの
◎
The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL, E-mail, or Password states. (This behavior is included in the used autocapitalization hint algorithm below.)
</p>

<p>
自動頭字化の処理~modelは、次に定義される 5 個の
`自動頭字化~hint@
から選定することに基づく：
◎
The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:
</p>

<dl>
	<dt>`既定@aH</dt>
	<dd>
［
~UA／入力~method
］は、自前の決定を用立てて，自動頭字化を可能化するべきである。
<!-- ＊use make 誤順序？ -->
◎
The user agent and input method should use make their own determination of whether or not to enable autocapitalization.
</dd>

	<dt>`なし@aH</dt>
	<dd>
自動頭字化は適用されるべきでない（すべての字lは、既定で小文字にされるべきである）。
◎
No autocapitalization should be applied (all letters should default to lowercase).
</dd>

	<dt>`一文ごと@aH</dt>
	<dd>
各~一文の最初の字lは、既定で頭字にされるべきである。
他のすべての字lは、既定で小文字にされるべきである。
◎
The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.
</dd>

	<dt>`単語ごと@aH</dt>
	<dd>
各~単語の最初の字lは、既定で頭字にされるべきである。
他のすべての字lは、既定で小文字にされるべきである
◎
The first letter of each word should default to a capital letter; all other letters should default to lowercase.
</dd>
	<dt>`文字ごと@aH</dt>
	<dd>
すべての字lは、既定で大文字にされるべきである。
◎
All letters should default to uppercase.
</dd>
</dl>

<p>
`autocapitalize@a
属性は，`列挙d属性$であり、その状態は，アリな`自動頭字化~hint$を与える。
属性の状態により指定される`自動頭字化~hint$は、`使用~自動頭字化~hint$を~formするための他の考慮点と組合されて，~UAの挙動を伝える。
この属性~用の各種~keywordと, 状態への対応関係は、次で与えられる：
◎
The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization hint, which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:
</p>

<div>
<dl class="switch">
	<dt>`off$v</dt>
	<dt>`~noneC$v</dt>
	<dd>
`なし$aH
</dd>

	<dt>`on$v</dt>
	<dt>`sentences$v</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`一文ごと$aH
</dd>

	<dt>`words$v</dt>
	<dd>
`単語ごと$aH
</dd>

	<dt>`characters$v</dt>
	<dd>
`文字ごと$aH
</dd>

	<dt>`値なし用の既定$</dt>
	<dd>
`既定$aH
</dd>
</dl>
◎
Keyword 	State
off 	none
none
on 	sentences
sentences
words 	words
characters 	characters
◎
The invalid value default is the sentences state. The missing value default is the default state.
</div>

<dl class="domintro">
	<dt>%element . `autocapitalize$m [ = %value ]</dt>
	<dd>
この要素~用の［
現在の自動頭字化~状態, または
未~設定-の場合は空~文字列
］を返す。
［
`input$e ／ `textarea$e
］要素は、自身の状態を `form$e 要素から継承することに注意：
その場合， `form$e 要素の自動頭字化~状態を返すことになり、編集-可能~領域~内の要素であっても編集中の~hostの自動頭字化~状態は返さないことになる（要素~自身が，`編集中の~host$でない限り）。
◎
Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this element is, in fact, the editing host).
</dd>
	<dd>
設定して， `autocapitalize$a 内容~属性を設定できる（それに伴い，要素~用の自動頭字化の挙動も変更する）。
◎
Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).
</dd>
</dl>

<p>
所与の要素 %要素 の
`自前の自動頭字化~hint@
を算出するときは、次を走らす：
◎
To compute the own autocapitalization hint of an element element, run the following steps:
</p>

<ol>
	<li>
~IF［
%要素 は `autocapitalize$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］
⇒
~RET その属性の状態
◎
If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of the attribute.
</li>
	<li>
~IF［
%要素 は`自動頭字化-を継承-$する
］~AND［
%要素 の`~form所有者$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~form所有者$の`自前の自動頭字化~hint$
◎
If element is an autocapitalize-inheriting element and has a non-null form owner, return the own autocapitalization hint of element's form owner.
</li>
	<li>
~RET `既定$aH
◎
Return default.
</li>
</ol>

<dl class="idl-def">
	<dt>`autocapitalize@m</dt>
	<dd>
取得子は、此れの`自前の自動頭字化~hint$に応じて，次に与える文字列~値を返すモノトスル
⇒＃
`既定$aH ならば 空~文字列,
`なし$aH ならば `none^l†,
`一文ごと$aH ならば `sentences^l†,
`単語ごと$aH ならば `words^l,
`文字ごと$aH ならば `characters^l
◎
The autocapitalize IDL attribute, on getting, must return the string value corresponding to own autocapitalization hint of the element, with the exception that the default state maps to the empty string.＼
</dd>
	<dd class="trans-note">【†
実際の原文では，`自前の自動頭字化~hint$に “対応する文字列” としか記されておらず、例えば `一文ごと$aHに対し `sentences^l, `on^l のどちらを返すか，はっきりしない。
】</dd>
	<dd>
設定子は、此れの `autocapitalize$a 内容~属性を所与の値に設定するモノトスル。
◎
On setting, it must set the autocapitalize content attribute to the given new value.
</dd>
</dl>

<hr>

<p>
~UAは，［
~text入力~methodに対する自動頭字化の挙動を~custom化する機能性
］を~supportしていて［
~web開発者がそれを制御できる
］ようにしたいと望むならば、要素の中に~textを入力する間，要素~用の
`使用~自動頭字化~hint@
を算出するべきである。
これは、［
要素の中への~text入力~用に推奨される，自動頭字化の挙動
］を述べる，`自動頭字化~hint$になる。
◎
User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.
</p>

<p>
ある種の状況下においては、［
~UA／入力~method
］は，`使用~自動頭字化~hint$を［
無視する, または上書きする
］ことを選んでもヨイ。
◎
User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.
</p>

<p>
要素 %要素 用の`使用~自動頭字化~hint$は、次の~algoを用いて算出される：
◎
The used autocapitalization hint for an element element is computed using the following algorithm:
</p>

<ol>
	<li>
~IF［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］
⇒
~RET `既定$aH
◎
If element is an input element whose type attribute is in one of the URL, E-mail, or Password states, then return default.
</li>
	<li>
~IF［
%要素 は［
`input$e ／ `textarea$e
］要素である
］
⇒
~RET %要素 の`自前の自動頭字化~hint$
◎
If element is an input element or a textarea element, then return element's own autocapitalization hint.
</li>
	<li>
~IF［
%要素 は［
`編集中の~host$ ／ `編集-可能$な要素
］である
］
⇒
~RET
%要素 が`属する編集中の~host$の`自前の自動頭字化~hint$
◎
If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of element.
</li>
	<li>
~Assert：
この段に到達することは決してない
— ~text入力が生じるのは，上の判定基準のいずれかを満たす要素に限られるので。
◎
Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.
</li>
</ol>

			</section>
			<section id="input-modalities:-the-inputmode-attribute">
<h3 title="Input modalities: the inputmode attribute">6.6.7. 入力~modality： `inputmode^a 属性</h3>

<p>
~UAは、次に挙げるものに対し， `inputmode$a 属性を~supportできる
⇒＃
~form~control（`textarea$e 要素の値など） ／
`編集中の~host$内の要素（ `contenteditable$a を利用しているものなど）
◎
User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`inputmode@a
内容~属性は、［
内容を手入力している利用者にとって，どの種類の入力の仕組みが最も助けになるか
］を指定する，`列挙d属性$である。
~UAは、属性に与えられた~keywordに応じて，次に述べるような~virtual-keyboardを表示するべきである：
◎
The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.
◎
↓</p>

<table><thead><tr><th>~keyword
<th>~~説明
</thead><tbody>

<tr><td>`none@v
</td><td>
~virtual-keyboardは表示するべきでない。
この~keywordは、自前の~keyboard~controlを具現化するような内容に，有用になる。
◎
The user agent should not display a virtual keyboard. This keyword is useful for content that renders its own keyboard control.

<tr><td>`text@v
</td><td>
利用者の~localeにおける~textを入力できるもの。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale.

<tr><td>`tel@v
</td><td>
電話番号を入力できるもの。
これは、［
数字 0 〜 9, 文字 "#", "*"
］用の~Keyを含むべきである。
~localeによっては、これには~alphabetic-mnemonicも含まれる（例えば米国では、歴史的に，~label "2" の~Keyには ~label "A", "B", "C" も付与されている）。
◎
The user agent should display a virtual keyboard capable of telephone number input. This should including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g., in the US, the key labeled "2" is historically also labeled with the letters A, B, and C).

<tr><td>`url@v
</td><td>
利用者の~localeにおける~textを入力できる, かつ
`~URL$の入力を援助する~Keyも伴われたもの
— 次に挙げるような，~domain名に共通的に見出される文字列を手早く入力するための
⇒
`/^l, `.^l, `www.^l, `.com^l
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".com".

<tr><td>`email@v
</td><td>
利用者の~localeにおける~textを入力できる, かつ
~e-mail-addressの入力を援助する~Keyも伴われたもの
— 文字 `@^l, `.^l 用の~Keyなど。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of e-mail addresses, such as that for the "@" character and the "." character.

<tr><td>`numeric@v
</td><td>
数を入力できるもの。
この~keywordは、 PIN を手入力するときに有用になる。
◎
The user agent should display a virtual keyboard capable of numeric input. This keyword is useful for PIN entry.

<tr><td>`decimal@v
</td><td>
小数を含む数を入力できるもの。
利用者の~locale用の数的~Keyと書式区切子が示されるべきである。
◎
The user agent should display a virtual keyboard capable of fractional numeric input. Numeric keys and the format separator for the locale should be shown.

<tr><td>`search@v
</td><td>
探索~用に最適化されたもの。
◎
The user agent should display a virtual keyboard optimized for search.

</tbody></table>

<dl class="idl-def">
	<dt>`inputMode@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`inputmode$a 内容~属性を`反映する$モノトスル。
◎
The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.
</dd>
</dl>

<p>
`inputmode$a が指定されていない（または、~UAが~supportしない状態にある）ときは、~UAは，既定の~virtual-keyboardを決定して利用者に呈示するべきである
— 決定する際には、入力の［
`type$a や `pattern$a
］属性などの文脈的な情報を利用するべきである。
◎
When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.
</p>

			</section>
			<section id="input-modalities:-the-enterkeyhint-attribute">
<h3 title="Input modalities: the enterkeyhint attribute">6.6.8. 入力~modality： `enterkeyhint^a 属性</h3>

<p>
~UAは、~form~control（ `textarea$e 要素の値などの）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用しているもの）に対し，
`enterkeyhint$a 属性を~supportできる。
◎
User agents can support the enterkeyhint attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`enterkeyhint@a
内容~属性は、`列挙d属性$であり，［
~virtual-keyboard上の `Enter^kbd ~Key用に，どの動作~label（または~icon）を呈示するか
］を指定する。
これは、［
`Enter^kbd ~Keyの呈示を，利用者にもっと助けになるよう~custom化する
］ことを，作者に許容する。
◎
The enterkeyhint content attribute is an enumerated attribute that specifies what action label (or icon) to present for the enter key on virtual keyboards. This allows authors to customize the presentation of the enter key in order to make it more helpful for users.
</p>

<table><thead><tr><th>~keyword
<th>~UAは、［
代表的に、この列に述べるような操作o
］用の~cueを呈示するべきである。
<tbody>

<tr><td>`enter@v
<td>
改行を挿入する。
◎
The user agent should present a cue for the operation 'enter', typically inserting a new line.

<tr><td>`done@v
<td>
入力するものはそれ以上なく，~IMEは閉じられることになる。
◎
The user agent should present a cue for the operation 'done', typically meaning there is nothing more to input and the IME will be closed.

<tr><td>`go@v
<td>
打込んだ~textの標的へ利用者を導く。
◎
The user agent should present a cue for the operation 'go', typically meaning to take the user to the target of the text they typed.

<tr><td>`next@v
<td>
~textを受容する次の欄へ利用者を導く。
◎
The user agent should present a cue for the operation 'next', typically taking the user to the next field that will accept text.

<tr><td>`previous@v
<td>
~textを受容する前の欄へ利用者を導く。
◎
The user agent should present a cue for the operation 'previous', typically taking the user to the previous field that will accept text.

<tr><td>`~search0@v
<td>
打込んだ~textを探索した結果へ利用者を導く。
◎
The user agent should present a cue for the operation 'search', typically taking the user to the results of searching for the text they have typed.

<tr><td>`send@v
<td>
~textをその標的へ送達する。
◎
The user agent should present a cue for the operation 'send', typically delivering the text to its target.
</tbody></table>

<dl class="idl-def">
	<dt>`enterKeyHint@m</dt>
	<dd>
`既知な値のみに制限され$る下で，
`enterkeyhint$a 内容~属性を`反映する$モノトスル。
◎
The enterKeyHint IDL attribute must reflect the enterkeyhint content attribute, limited to only known values.
</dd>
</dl>

<p>
`enterkeyhint$a は指定されていない（または、~UAが~supportしない状態にある）場合、~UAは，~virtual-keyboard上に既定で呈示する動作~label（または~icon）を決定するべきである
— これを決定するときには、［
`inputmode$a ／ `type$a ／ `pattern$a
］属性などの文脈的な情報を利用するべきである。
◎
When enterkeyhint is unspecified (or is in a state not supported by the user agent), the user agent should determine the default action label (or icon) to present. Contextual information such as the inputmode, type, or pattern attributes should be used to determine which action label (or icon) to present on the virtual keyboard.
</p>

			</section>
		</section>
		<section id="dnd">
<h3 title="Drag and drop">6.7. ~drag＆~drop</h3>

<p class="trans-note">【
この節の内容は、
<a href="~HTMLdnd#dnd">別~pageにて</a>。
】</p>

		</section>
	</section>
</main>
