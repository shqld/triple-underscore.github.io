<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Pseudo-Elements Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style type="text/css">
.char-prop {
	font-family: serif0, serif;
	color: green;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	var link_map = this.link_map;
	var context_prop = '';
	const class_map = this.class_map;
	const tag_map = this.tag_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'p': // property
	if( indicator === '@') {
		context_prop = '#valdef-' + key + '-';
	}
	break;
case 'pe': 
	text = '::' + key;
	break;
case 'ps': 
	text = ':' + key;
	break;
case 'v': // css values
	href = context_prop + key;
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '"></a>';
case 'issue':
	text = 'Issue #' + key;
	href = '~CSSissue/' + key;
	break;
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Pseudo-Elements Module Level 4
spec_date:2019-01-24
trans_update:2019-01-25
source_checked:181231
page_state_key:CSS
original_url:https://drafts.csswg.org/css-pseudo-4/
	abbr_url:CSSPSEUDO
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2019,permissive
trans_1st_pub:2017-09-01


●●class_map
p:property
css:css
ps:pseudo
pe:pseudo
e:element
a:attr
v:value
uc:char-prop

●●tag_map
p:code
t:var
css:code
ps:code
pe:code
I:code
m:code
e:code
a:code
v:code
c:code
samp:samp
uc:b
em:em

●●original_id_map


●●link_map

Exposed:~WEBIDL#Exposed
unsigned long:~WEBIDL#idl-unsigned-long
I.CSSOMString:~CSSOM1#cssomstring
I.CSSPseudoElement:#csspseudoelement
I.CSSPseudoElementList:#csspseudoelementlist
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration
I.Element:~DOM4#element
I.EventTarget:~DOM4#eventtarget
	https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
I.Window:~WINDOW#window

m.type:#dom-csspseudoelement-type
m.element:#dom-csspseudoelement-element
m.style:#dom-csspseudoelement-style

m.length:#dom-csspseudoelementlist-length
m.item:#dom-csspseudoelementlist-item
m.getByType:#dom-csspseudoelementlist-getbytype

m.getPseudoElements:#dom-window-getpseudoelements

	引数
	#dom-window-getpseudoelements-elt-type-elt
	#dom-window-getpseudoelements-elt-type-type
	#dom-csspseudoelementlist-item-index-index
	#dom-csspseudoelementlist-getbytype-type-type


pe.after:#selectordef-after
pe.before:#selectordef-before
pe.first-letter:#selectordef-first-letter
pe.first-line:#selectordef-first-line
pe.grammar-error:#selectordef-grammar-error
pe.inactive-selection:#selectordef-inactive-selection
pe.marker:#selectordef-marker
pe.placeholder:#selectordef-placeholder
pe.selection:#selectordef-selection
pe.spelling-error:#selectordef-spelling-error

ps.placeholder-shown:~SELECTORS4#placeholder-shown-pseudo

p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.box-shadow:~CSSBG#propdef-box-shadow
p.caret-color:~CSSUI#propdef-caret-color
p.color:~CSSCOLOR#propdef-color
	p.color:https://drafts.csswg.org/css-color-3/#color0
p.content:~CSSCONTENT#propdef-content
p.cursor:~CSSUI#propdef-cursor
p.display:~CSSDISP#propdef-display
p.initial-letters:~CSSINLINE#propdef-initial-letters
	＊p.list-style-position: inside:https://drafts.csswg.org/css-lists-3/#propdef-list-style-position
p.opacity:~CSSCOLOR#propdef-opacity
p.outline:~CSSUI#propdef-outline
p.text-align:~CSSTEXT#propdef-text-align
p.text-combine-upright:~CSSWM#propdef-text-combine-upright
p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration
p.text-emphasis:~CSSTEXTDECOR#propdef-text-emphasis
p.text-shadow:~CSSTEXTDECOR#propdef-text-shadow
	＊p.display: list-item:~CSSDISP#propdef-display
p.text-transform:~CSSTEXT#propdef-text-transform
p.list-style-position:~CSSWG/css-lists-3/#propdef-list-style-position


v.none:~CSSCONTENT#valdef-content-none
v.inline:~CSSDISP#valdef-display-inline
v.transparent:~CSSCOLOR#valdef-color-transparent

v.inline-block:~CSSDISP#valdef-display-inline-block
v.table-cell:~CSSDISP#valdef-display-table-cell
v.list-item:~CSSDISP#valdef-display-list-item
v.currentcolor:~CSSCOLOR#valdef-color-currentcolor

v.spelling-error:~CSSWG/css-text-decor-4/#valdef-text-tecoration-line-spelling-error
	#valdef-text-decoration-line-spelling-error
v.grammar-error:~CSSWG/css-text-decor-4/#valdef-text-decoration-line-grammar-error


木に留まる疑似要素:#tree-abiding
仮想の~tag列:#fictional-tag-sequence
整形される最初の行l:#first-formatted-line
強調~overlay:#highlight-overlay
強調~疑似要素:#highlight-pseudo-element

出自の要素:~SELECTORS4#originating-element

継承-:~CASCADE#inheritance
継承d~prop:~CASCADE#inherited-property
初期~値:~CASCADE#initial-value

塊~容器:~CSSDISP#block-container
行内level:~CSSDISP#inline-level
行内~box:~CSSDISP#inline-box
塊level:~CSSDISP#block-level
包含塊:~CSSDISP#containing-block
~flow外:~CSSDISP#out-of-flow
~flow内:~CSSDISP#in-flow
主要~box:~CSSDISP#principal-box
置換され:~CSSDISP#replaced-element
表示-型:~CSSDISP#display-type
	塊:~CSSDISP#block
	行内:~CSSDISP#inline
	行内塊:~CSSDISP#valdef-display-inline-block

選択子:~SELECTORS4#selector

~typographic字l単位:~CSSTEXT#typographic-letter-unit
先頭字:~CSSINLINE#initial-letter
先頭字の~style付け:~CSSINLINE#initial-letter-styling
埋没~頭字:~CSSINLINE#dropped-initial
沈込み頭字:~CSSINLINE#sunken-initial
持上げ頭字:~CSSINLINE#raised-initial

有位置:~CSS2VISUREN#positioned-element

	using the normal cascade:http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html
	§3.1 Selecting Highlighted Content: the ::selection, ::inactive-selection, ::spelling-error, and ::grammar-error pseudo-elements:#highlight-selectors
	15 January 2015 Working Draft:https://www.w3.org/TR/2015/WD-css-pseudo-4-20150115/
	CSS2.1§E.2:https://www.w3.org/TR/CSS21/zindex.html
	CSS:http://www.w3.org/TR/CSS/
	Daniel’s thread:http://lists.w3.org/Archives/Public/www-style/2010May/0247.html
	F2F minutes:http://lists.w3.org/Archives/Public/www-style/2008Nov/0022.html
	Gecko notes:http://lists.w3.org/Archives/Public/www-style/2010May/0261.html
	Opera notes:http://lists.w3.org/Archives/Public/www-style/2010May/0366.html
疑似要素:~SELECTORS4#pseudo-element
~Unicode字種:~CSSTEXT#unicode-general-category
	Webkit notes:http://lists.w3.org/Archives/Public/www-style/2010May/0280.html
	comments here:http://css-tricks.com/almanac/selectors/p/placeholder/
	dbaron’s message:http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html


●●words_table1


●●words_table



	●CSS
CSS:
prop:property::プロパティ
下位porp:longhand::下位プロパティ
style:::スタイル
	style可能な／できる:styleable
	style付け:styling
stylesheet:style sheet::スタイルシート
cascade:::カスケード
	~cascade法:cascading

初期:initial:~
継承-:inherit::~
継承d:inherit::継承
継承:inheritance::~
指定d:specified:指定
算出d:computed:算出
媒体:media::~:メディア
規則:rule:~
選択-:select::~
選定-:select:~
選択:selection::~
選択子:selector::~:セレクタ
疑似:pseudo::~
疑似要素:pseudo-element::~
疑似類:pseudo-class::疑似クラス
出自の:originating:~

型:type:~
属性:attribute:~
名前:name:~
名:name:~
値:value:~

	●構造
文書:document::~
要素:element::~
親:parent::~
木:tree::~
	木に留まる:tree-abiding
先祖:ancestor::~
子:child::~
	children
子孫:descendant::~
入子に:nest::入れ子に
入子:nesting::入れ子
閉じて:close して:~
閉じた:close した:~
開く:open する:~
	また開く:re-open
封入-:enclose:~
包摂-:encompass:~
	留まる:abiding
	添え付け:attach
	~~直に括る:abut
	要素~~単位／~boxに対応する:fit
node:::ノード
tag:::タグ
開始tag:start tag::開始タグ
終了tag:end-tag::終了タグ
仮想の:fictional::~
構造:structure:~
直に:direct に:~
	最も内縁の:innermost
	文書~全体にわたる:document-wide

	●UI／呈示
対話的:interactive::~
作動中の:active な:~
作動中:active:~
	作動中でない:inactive
表示-:display:~
隠され:hide され:~
到達-:reach:~
	到達~可能:reachable
可視:visible:~
強調:highlight::~
呈示-:present::~
描画-:render::~
描画:rendering::~
手入力-:enter:~

	●塗り
overlay:
積層-:stack::~
層:layer::~
alpha:
channel:::チャネル
塗って:paint して::~
塗法:paint 法::塗り方
	painting
	手前:over
	最も手前:topmost
	背後:under
	直ぐ:immediately
描かれ:draw され:~
描く:draw する:~
	描くのを:drawing:
描直す:redraw する:描き直す
覆う:cover する:~
背景:background::~
前景:foreground::~
色:color::~
膜:wash:~
影:shadow::~
灰色:gray:~
濃淡:shade:~
不透明:opaque:~
半透明:semi-transparent:~
	~~覆う:create a 〜 to coat
	透けて見える:can show through
	highlighting
滲み:wash:~

	●layout
layout:::レイアウト
flow:::フロー
	flow外:out-of-flow
table:::テーブル
size:::サイズ
box:::ボックス
margin:::マージン
padding:::パディング
border:::ボーダー
	~border~box:border-box:
mark:::マーク
marker:::マーカ
生成-:generate:~
生成d:generated:生成
置換-:replace:~
	置換されない:non-replaced
	置換される:replaced
主要:principal::主
行内:inline::~:インライン
行内level:inline-level::行内レベル:インラインレベル
塊level:block-level::ブロックレベル
塊:block::ブロック
包含塊:containing block::包含ブロック
容器:container::コンテナ
包含-:contain:~
包含塊:containing block::包含ブロック
整形-:format::~
整形:formatting::~
位置決め:positioning::~
有位置:positioned::~
浮動-:float::~
浮動:floating::~
関与-:participate:~
内側:inside:~
外側:outside:~
外方:outward:~
区画:area:~
始端:start:~
終端:end:~
右端:right:~
横幅:width:~
縦幅:height:~
辺:edge:~
部位:portion:~
重合して:overlap して:重なり合って
区分:segment:~

	●text 組版
em:
text:::テキスト
font:::フォント
typographic:::タイポグラフィック
glyph:::グリフ
外形線:outline::~
字l:letter::字°
	最初の字l:first-letter
行l:line::行
	最初の行l:first-line
アキ:spacing::~
分断-:break::~
先頭字:initial cap::~
頭字:cap::~
埋没:dropped::~
	埋没~頭字:drop cap／drop-letter／Drop Caps
持上げ:raised::持ち上げ
	沈込み:sunken::沈み込み
上線:overline::~
下線:underline::~
	underlining:~
取消線:line-through::打消線
圏点:emphasis mark::~
	Punctuation
基底:base:~
段落:paragraph:~
符号位置:codepoint:~
大文字:uppercase:~
約物:punctuation:~
文字:character:~
文字列:string:~
引用符:quotes:~
数字:digit:~
装飾:decoration:~
植字用:typesetting:~
結合:combining::~
折返した:wrap した::折り返した
回込む:wrap around する::回り込む
span:
	すき間なく:tight
境界:boundary:~
双方向的:bidirectional::~

	●仕様
UA:user agent:UA
module:::モジュール
一般:general:~
一般的:general:~
不正:incorrect:~
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
共通の:common な:~
共通する:common な:~
効果:effect:~
実際の:actual な:~
将来:future:~
未来:future:~
情報:information:~
正しく:correct に:~
正しい:correct な:~
正確:exact:~
	-:exactly
歴史的:historical:~
特別:special:~
特有の:specific な:~
特定的には:specifical には:具体的には
自動的:automatic:~
草案:draft:~
言語:language:~
記法:notation:~
通例通り:as usual に:通例どおり
通常の:normal な:~
定例の:regular な:~
拙い:poor:~
小さなminor:~
急進的:radical:~
提案:proposal:~
代替:alternative:~
代替-:alternate:~
単純:simple:~
要因:factor:~
概して:typical に:~
地位:status:~
アリな:possible な:あり得る
	可能性:possibility
作業草案:Working Draft:~
重要:important:~
能:ability:~
明瞭:clear:~
	因り:due to
	特に:in particular:~
	同じ様にexactly like
	~~実際:In fact
	にもなり得る:may in fact
	必要:need
	:whereas
	:Issue
	おそらく:probably
	出発点:starting point
	不確か:not yet sure
	？:sure
	までは:at the moment
	の支持を受けて:in favor of
	具体例として:for instance
	個々の:their respective
	例:example
	例えば:for example
	歓迎する:welcome
	しかしながら／他方／が:however
	したがって:thus
	とは限らず／ない〜であっても:not necessarily
	べき:should
	seem
	note
	助け:help
	きめ細やかな:sensible:
	thank
	very:
	Issue:
	potentially
	Level
	次のことを~~念頭に:Recall that
	優先される:over have precedence
	任意に:arbitrarily
	価する:worth
	他に比べ:relatively

	●仕様（動詞
approach:::アプローチ
feedback:::フィードバック
fall-back:fall back::フォールバック
hint:::ヒント
model:::モデル
support:::サポート
version:::バージョン
comment:::コメント
予期-:expect:~
利用-:use:~
利用者:user:~
制約-:restrict:~
制約:restriction:~
動作-:act:~
取扱い:handling:~
受容-:accept:~
可用:available:~
問題:problem:~
存在-:exist:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
尊守-:honor:~
導入-:introduce:~
意味-:mean:~
意図-:intend:~
意図的:intentional:~
抽象的:abstract:~
拘束-:constrain:~
拡張-:extend:~
指定-:specify:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
供-:provide:~
明確化-:clarify:~
明確化:clarification:~
明示的:explicit:~
	暗黙に:implied:~
欲され:desire され:~
求める:want する:~
求めて:want して:~
考慮点:considerations:~
考査:review:~
要件:requirement:~
要請-:request:~
見なさ-:consider さ:~
設計-:design:~
許容-:allow:~
	できなくしている:not allow
誂える:tailor する:~
説明-:explain:~
論点:discussion:~
述べる:describe する:~
記述-:describe:~
過程:process:~
適合:conforming:~
適合性:conformance:~
適用-:apply:~
	適用-可能:applicable
開発:development:~
防止-:prevent:~
作者:author:~
依存-:depend:~
競合-:conflict:~
相互作用-:interact:~
相互作用:interaction:~
相互運用可能:interoperable:~
相互運用性:interoperability:~
解決策:solution:~
判明-:prove:~
構想:conception:~
併合-:merge:~
抑止-:suppress:~
追加的な:additional な:追加の
	加えて:additionally
影響-:affect:~
制限-:limit:~
指示-:indicate:~
決定-:determine:~
暗黙の:implied:~
模倣-:simulate:~
調整-:adjust:~
見出法:find 法:見出し方
	見出法:finding
上書き:override:~
	overriding
働く:work する:~

	協力-:contribution
	書き直す:rewritten
	書かれ:written
	に注意。:note that
	働き方:way things work
	序論:introduction
	扱う:treat
	築き上げる:build up
	見よ:see
	起こる:happen
	選ぶ:choose する
	織り込む:take into account
	〜とする:assume
	〜とするとき:assuming
	〜に基づく:based
	例示-:illustrate
	-:remember
	caused
	指せるように:refer

	●未分類（動詞
並替え:reordering:並び替え
有順序:ordered:~
識別-:identify:~
印刷:print:~
作成-:create:~
作成:creation:~
先行-:precede:~
共有-:share:~
反映-:reflect:~
合致-:match:~
変更-:change:~
変更点:changes:~
後続-:follow:~
挿入-:insert:~
検索取得-:retrieve:~
漏洩-:leak:~
無視-:ignore:~
現れる:appear する:~
組合わせ:combination:組み合わせ
組合した:combine した:組合わせた
結付けら:associate さ:結び付けら
表現-:represent:~
設定-:set:~
読取れ:read でき:読み取れ
追加-:add:~
追加:addition:~
除去-:remove:~
受取って:receive して:受け取って
受取る:receive:受け取る
近似-:approximate:~
勝つ:win する:優先される
所有-:own:~
形成-:form:~
	形:form
綴り:spelling:~
	綴りが誤っている:misspelled
開始-:start:~
	書いている:writing
収まる:fit する:~
演算:operation:~
複製-:copy:~

	返す:return する
	~~調和を乱す:disconcerting
	得られ:get
	埋め方:how to fill out
	保たれ:kept
	含-:include:~
	含めて:including
	次のように:as follow
	生じ:occur
	示す:show
	属する／所属:belong
	対応-:corresponding
	対応付けられ:map
	作成-:make
	とされた:flag
	欠く:missing
	またがり:cross

	●未分類
class:
OS:
IE:
Dutch:::オランダ語
HTML:
Unicode:
Web:
DOM:
browser:::ブラウザ

markup:::マークアップ
mark-up:mark up::マークアップ
collection:::コレクション
custom:::カスタム
error:::エラー
event:::イベント
form:::フォーム
	h2:level-2 header
index:
instance:::インスタンス
interface:::インタフェース
item:::アイテム
level:::レベル
link:::リンク
list:::リスト
method:::メソッド
obj:object::オブジェクト
parameter:::パラメタ
privacy:::プライバシー
script:::スクリプト
security:::セキュリティ
	-:source／-sourced

target:::ターゲット
window:::ウィンドウ
inline:::インライン
colon:::コロン
	~colon 1 個の:one-colon
copy:::コピー
paste:::ペースト
	与-:give:~
内容:content:~
入力:input:~
単語:word:~
片:fragment:~
同時的:simultaneous:~
	-:valid:~
文法:grammar:~
文脈:context:~
既定:default:~
既定の:default:~
構文:syntax:~
段:step:~
画像:image:~
空:empty:~
	節:section
編集-:edit:~
	編集-可能:editable
長さ:length:~
静的:static:~
頁:page::ページ
順序:order:~
	類似的／類似する:similar
	きれいに:clean:~
仮入力:placeholder:~
欄:field:~
慣行:traditions:~

	文:sentence
図形:shape:~
文法的:grammatical:~
辞書:dictionary:~
字種:general category:~
単位:unit:~
	blue／green／yellow／red／orange
	誤り:error:~
	列:sequence
	日付:date:~
	日付~入力:date-input:
	年, 月, 日:year-month-day
	住所録:address book
	~obj~model:OM
	型~選択子:tag selector
	we
	bare
	-:source／-sourced
	対象:target or object
	~DOM内の:real

	●指示語
普通の:ordinary:~
内縁:inner:~
自前の:own:~
新たな:new:~
既存の:existing:~
特定0の:particular:ある特定の
全部的:full:~
元の:original:~
	複数の:more than one
	直前 immediately before
	直後 immediately after
	のいずれか one of
	個数 number of
	この:this
	〜の代わりに:instead
	これらの:these
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらの:those
	それらを:them
	0:zero
	個の:one ／ two
	もの:thing
	一定の／ある種の:certain
	上:above
	下:below
	両者:both
	他の:other
	別の:another
	前:before
	単独の:single
	即時:immediate
	各:each
	合間:between
	同じ:same
	常に:always
	後:after
	所与の:given
	更なる:further
	最初の:first
	必要な最小限:bare minimum
	we
	様々な:various
	異なる:different
	直の／直〜:immediately
	等々:etc
	自身:itself
	複数の:multiple
	通:through
	向けに:against
	各〜ごと:every
	直前:just before
	以前の／前掲の:previous
	何らかの:some
	周り:around
	のみ／すぐ:just
	残り:rest
	多い:often
	残り:rest
	実の:real
	の始め:at the beginning
	始めの所:beginning
	間:during
	:non-
	:anything
	全体:throughout
	全体:entire
	少なくとも:at least
	一部:part of
	一部分:piece
	あらゆるもの:everything
	直後:right after
	同様に:like
	など:such as
	と同じく、:as with
	現時点:at this point
	超える:beyond
	対にされた:paired-
	だけ:alone
	しか〜ない:solely
	他の，〜部分:the rest
	を与える数:numeric
	いくつもの:number of
	次の:the following
	他所:elsewhere
	最終的には:finally


●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 July 2016. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-CONTENT-3]
    Elika Etemad; Dave Cramer. CSS Generated Content Module Level 3. 2 June 2016. WD. URL: https://www.w3.org/TR/css-content-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-LISTS-3]
    Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 20 March 2014. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-TEXT-DECOR-4]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 4. 13 March 2018. WD. URL: https://www.w3.org/TR/css-text-decor-4/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 22 December 2017. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 24 May 2018. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS3-TEXT-DECOR]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 3 July 2018. CR. URL: https://www.w3.org/TR/css-text-decor-3/ 
[CSS3BG]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS3COLOR]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS3TEXT]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 12 December 2018. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[DOM-LEVEL-2-EVENTS]
    Tom Pixley. Document Object Model (DOM) Level 2 Events Specification. 13 November 2000. REC. URL: https://www.w3.org/TR/DOM-Level-2-Events/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 
[UAX44]
    Mark Davis; Ken Whistler. Unicode Character Database. 25 September 2013. URL: http://www.unicode.org/reports/tr44/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. CSS Inline Layout Module Level 3. 8 August 2018. WD. URL: https://www.w3.org/TR/css-inline-3/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-FONTS]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS3-WRITING-MODES]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 24 May 2018. CR. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[HTML5]
    Ian Hickson; et al. HTML5. 27 March 2018. REC. URL: https://www.w3.org/TR/html5/ 
[SELECTORS-3]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 
[UAX29]
    Mark Davis; Laurențiu Iancu. Unicode Text Segmentation. 13 June 2017. Unicode Standard Annex #29. URL: https://www.unicode.org/reports/tr29/tr29-31.html 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Pseudo-Elements Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-pseudo-4/

編集者草案
	https://drafts.csswg.org/css-pseudo-4/

以前のバージョン
	https://www.w3.org/TR/2016/WD-css-pseudo-4-20160607/
	https://www.w3.org/TR/2015/WD-css-pseudo-4-20150115/

テスト一式
	http://test.csswg.org/suites/css-pseudo-4_dev/nightly-unstable/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-pseudo-4">GitHub Issues</a>

編集
	Daniel Glazman (Disruptive Innovations)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="mailto:stearns@adobe.com">Alan Stearns</a> (Adobe Systems Inc.)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-pseudo-4/Overview.bs">GitHub Editor</a>


</script>



<body>

<header>
	<hgroup>
<h1>疑似要素 — CSS Pseudo-Elements Module Level 4</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この~CSS~moduleは、疑似要素を定義する。
それは、選択して~styleできるような，~CSS描画-木のある部位を表現する抽象的な要素である。
◎
This CSS module defines pseudo-elements, abstract elements that represent portions of the CSS render tree that can be selected and styled.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公開の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`疑似要素$は、文書~言語により明示的に作成される要素を超えるような，文書の抽象的な要素を表現する。
疑似要素は，文書~木を成す要素~~単位に制約されないので、文書の木~構造に対応付けられない部位であっても，選択して~styleをあてがうために利用できる。
具体例として， `first-line$pe 疑似要素は、［
~layoutにおいて~textを`折返した後^emにおける，`出自の要素$の`整形される最初の行l$
］の内容を選択でき，その行lにだけ段落の残りと異なる~styleをあてがえるようになる。
◎
Pseudo-elements represent abstract elements of the document beyond those elements explicitly created by the document language. Since they are not restricted to fitting into the document tree, they can be used to select and style portions of the document that do not necessarily map to the document’s tree structure. For instance, the ::first-line pseudo-element can select content on the first formatted line of an element after text wrapping, allowing just that line to be styled differently from the rest of the paragraph.
</p>

<p>
各~疑似要素には、`出自の要素$が結付けられる。
疑似要素の構文は、 `<var>(疑似要素の名前)</var>^pe の形をとる。
この~moduleは、~CSSに存在している疑似要素, および
それらをどう~styleできるかを定義する。
疑似要素についての［
より一般的な情報, 構文, 他の`選択子$との相互作用
］については、
`SELECTORS4$r を見よ。
◎
Each pseudo-element is associated with an originating element and has syntax of the form ::name-of-pseudo. This module defines the pseudo-elements that exist in CSS and how they can be styled. For more information on pseudo-elements in general, and on their syntax and interaction with other selectors, see [SELECTORS4].
</p>

	</section>
	<section id="typographic-pseudos">
<h2 title="Typographic Pseudo-elements">2. ~typographic疑似要素</h2>


		<section id="first-line-pseudo">
<h3 title="The ::first-line pseudo-element">2.1. `first-line^pe 疑似要素</h3>

<p>
`first-line@pe
疑似要素は、その`出自の要素$の`整形される最初の行l$の内容を述べる。
◎
The ::first-line pseudo-element describes the contents of the first formatted line of its originating element.
</p>

<div class="example">

<p>
次の規則は、
“各 `p^e 要素ごとに その最初の行lを成す字lたちを大文字に変更する”
ことを意味する：
◎
The rule below means “change the letters of the first line of every p element to uppercase”:
</p>

<pre class="lang-css">
p::first-line { `text-transform$p: uppercase }
</pre>

<p>
選択子 `p::first-line^css に合致するような，実の文書~要素はない。
それが合致するのは、適合~UAが，各 `p^e 要素ごとに その始めの所に挿入することになる，疑似要素である。
◎
The selector p::first-line does not match any real document element. It does match a pseudo-element that conforming user agents will insert at the beginning of every p element.
</p>
</div>

<p class="note">注記：
最初の行lの長さは、頁の横幅, ~font~size, 等々，いくつもの要因に依存することに注意。
◎
Note: Note that the length of the first line depends on a number of factors, including the width of the page, the font size, etc.
</p>

<div class="example">

<p>
例えば，次のような普通の~HTML段落は：
◎
For example, given an ordinary HTML [HTML5] paragraph such as:
</p>

<pre class="lang-html">
&lt;p&gt;これは、いくぶん長い~HTML段落であり、何~行lかに分断される。最初の行lは、仮想の~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 


&lt;P&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->
<p>
次のように何~行lかに分断されるであろう：
◎
The lines might be broken as follows:
</p>

<pre class="lang-html">
<mark>これは、いくぶん長い~HTML段落であり、</mark>
何~行lかに分断される。最初の行lは、仮想の
~tag列により識別される。他の行lは、段落
内の普通の行lとして扱われることになる。
</pre>
<!-- 
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag
sequence. The other lines will be treated as
ordinary lines in the paragraph.

 -->
<p>
~UAは、この段落を `first-line$pe を表現する
`仮想の~tag列@
を含むよう “書き直す” こともある。
この`仮想の~tag列$は、~propがどう継承されるかを示す助けになる：
◎
This paragraph might be “rewritten” by user agents to include a fictional tag sequence to represent ::first-line. This fictional tag sequence helps to show how properties are inherited.
</p>

<pre class="lang-html">
&lt;p&gt;<mark>&lt;p::first-line&gt;</mark>これは、いくぶん長い~HTML段落であり、<mark>&lt;/p::first-line&gt;</mark>何~行lかに分断される。最初の行lは、仮想の~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;<mark>&lt;P::first-line&gt;</mark> This is a somewhat long HTML
paragraph that <mark>&lt;/P::first-line&gt;</mark> will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->
</div>

<p>
疑似要素が実の要素を分断する場合に欲される効果は、要素を閉じて, また開くような，`仮想の~tag列$で記述できることが多い。
◎
If a pseudo-element breaks up a real element, the desired effect can often be described by a fictional tag sequence that closes and then re-opens the element.
</p>

<div class="example">

<p>
前掲の段落の最初の文が， `span^e 要素で包摂されるように~mark-upされていたとする：
◎
Thus, if we mark up the previous paragraph with a span element encompassing the first sentence:
</p>

<pre class="lang-html">
&lt;p&gt;<mark>&lt;span class="test"&gt;</mark>これは、いくぶん長い~HTML段落であり、何~行lかに分断される。<mark>&lt;/span&gt;</mark>最初の行lは、仮想の~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;<mark>&lt;SPAN class="test"&gt;</mark> This is a somewhat long HTML
paragraph that will be broken into several
lines.<mark>&lt;/SPAN&gt;</mark> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->

<p>
`first-line$pe 用に`仮想の~tag列$を挿入するとき、~UAは， `span^e に対する［
開始tag, 終了tag
］を模倣して，正しい継承の挙動を得ることもできる。
◎
the user agent could simulate start and end tags for span when inserting the fictional tag sequence for ::first-line to get the correct inheritance behavior.
</p>

<pre class="lang-html">
&lt;p&gt;&lt;p::first-line&gt;<mark>&lt;span class="test"&gt;</mark>これは、いくぶん長い~HTML段落であり、<mark>&lt;/span&gt;</mark>&lt;/p::first-line&gt;<mark>&lt;span class="test"&gt;</mark>何~行lかに分断される。最初の行lは、仮想の<mark>&lt;/span&gt;</mark>~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;&lt;P::first-line&gt;<mark>&lt;SPAN class="test"&gt;</mark> This is a somewhat long HTML
paragraph that will <mark>&lt;/SPAN&gt;</mark>&lt;/P::first-line&gt;<mark>&lt;SPAN class="test"&gt;</mark> be broken into several
lines.<mark>&lt;/SPAN&gt;</mark> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
-->
</div>

			<section id="first-text-line">
<h4 title="Finding the First Formatted Line">2.1.1. 整形される最初の行lの見出法</h4>

<p>
~CSSにおいては、 `first-line$pe 疑似要素の効果があるのは，`塊~容器$に添え付けられた場合に限られる。
要素の
`整形される最初の行l@
が生じる所は、要素の子孫のうち［
同じ`~flow内$にある（すなわち，浮動や位置決めに因り`~flow外$にされていない）, かつ `塊level$である
］ものの内側になるモノトスル。
◎
In CSS, the ::first-line pseudo-element can only have an effect when attached to a block container. The first formatted line of an element must occur inside a block-level descendant in the same flow (i.e., a block-level descendant that is not out-of-flow due to floating or positioning).
</p>

<div class="example">

<p>
例えば
`&lt;div&gt;&lt;p&gt;最初の行l…&lt;/p&gt;&lt;/div&gt;^samp
における， `div^e の`整形される最初の行l$は、
`p^e 内の
`最初の行l…^samp
になる（この `p^e, `div^e は、ともに塊とする）。
◎
For example, the first line of the DIV in &lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt; is the first line of the P (assuming that both P and DIV are blocks).
</p>

</div>

<p>
［
`table-cell$v ／ `inline-block$v
］は塊levelではないので、その最初の行lは，先祖~要素の`整形される最初の行l$にはなり得ない。
したがって，
`&lt;div&gt;&lt;p style="display: inline-block"&gt;Hello&lt;br&gt;Goodbye&lt;/p&gt; etcetera&lt;/div&gt;^samp
における `div^e の`整形される最初の行l$は、行l "Hello" にはならない。
◎
The first line of a table-cell or inline-block cannot be the first formatted line of an ancestor element. Thus, in &lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt; the first formatted line of the DIV is not the line "Hello".
</p>

<p class="note">注記：
［
`&lt;p&gt;&lt;br&gt;First...^samp
における `p^e の最初の行l
］に包含される字lはないことに注意（ `br^e は既定の~styleとする）。
単語 "First" は、`整形される最初の行l$上にはない。
◎
Note: Note that the first line of the p in this fragment: &lt;p&gt;&lt;br&gt;First... doesn’t contain any letters (assuming the default style for br). The word "First" is not on the first formatted line.
</p>

<p>
~UAは、［
`first-line$pe 疑似要素の仮想の開始tagが、［
【最初の行lを】封入している`塊level$の要素のうち，最も内縁のもの
］の，すぐ内側に入子にされていた
］かのように動作するモノトスル。
◎
A user agent must act as if the fictional start tags of a ::first-line pseudo-element were nested just inside the innermost enclosing block-level element.
</p>

<div class="example">

<p>
例えば、次の~HTML：
◎
For example, the fictional tag sequence for
</p>

<pre class="lang-html">
&lt;div&gt;
  &lt;p&gt;最初の段落&lt;/p&gt;
  &lt;p&gt;二番目の段落&lt;/p&gt;
&lt;/div&gt;
</pre>
<!-- 
&lt;DIV&gt;
  &lt;P&gt;First paragraph&lt;/P&gt;
  &lt;P&gt;Second paragraph&lt;/P&gt;
&lt;/DIV&gt;
-->
<p>
に対する`仮想の~tag列$は：
◎
is
</p>

<pre class="lang-html">
&lt;div&gt;
  &lt;p&gt;&lt;div::first-line&gt;&lt;p::first-line&gt;最初の段落&lt;/p::first-line&gt;&lt;/div::first-line&gt;&lt;/p&gt;
  &lt;p&gt;&lt;p::first-line&gt;二番目の段落&lt;/p::first-line&gt;&lt;/p&gt;
&lt;/div&gt;
</pre>

<p class="trans-note">【
この例は、 `div^e, `p^e ともに `first-line$pe が適用されている。
`仮想の~tag列$を生成する順序は、先祖である `div^e から先になるようだ。
】</p>

<!-- 
&lt;DIV&gt;
  &lt;P&gt;&lt;DIV::first-line&gt;&lt;P::first-line&gt;First paragraph&lt;/P::first-line&gt;&lt;/DIV::first-line&gt;&lt;/P&gt;
  &lt;P&gt;&lt;P::first-line&gt;Second paragraph&lt;/P::first-line&gt;&lt;/P&gt;
&lt;/DIV&gt;
-->
</div>



			</section>
			<section id="first-line-styling">
<h4 title="Styling the First Line Pseudo-element">2.1.2. `first-line^pe 疑似要素の~style付け</h4>

<p>
`first-line$pe 疑似要素により生成される~boxは、`行内level$の要素によるそれと類似的に挙動するが、一定の制約がある。
`first-line$pe 疑似要素には、次の~propが適用される：
◎
The ::first-line pseudo-element’s generated box behaves similar to that of an inline-level element, but with certain restrictions. The following CSS properties apply to a ::first-line pseudo-element:
</p>

<ul>
	<li>
すべての~font~prop
`CSS3-FONTS$r
◎
all font properties (see [CSS3-FONTS])
</li>
	<li>
`color$p, `opacity$p ~prop
`CSS3COLOR$r
◎
the color and opacity properties (see [CSS3COLOR])
</li>
	<li>
すべての背景~prop
`CSS3BG$r
◎
all background properties (see [CSS3BG])
</li>
	<li>
植字用~propのうち，行内~要素に適用されるもの
`CSS3TEXT$r
◎
any typesetting properties that apply to inline elements (see [CSS3TEXT])
</li>
	<li>
すべての~text装飾~prop
`CSS3-TEXT-DECOR$r
◎
all text decoration properties (see [CSS3-TEXT-DECOR])
</li>
	<li>
行内~layout~propのうち，行内~要素に適用されるもの
`CSS-INLINE-3$r
◎
any inline layout properties that apply to inline elements (see [CSS-INLINE-3])
</li>
	<li>
その他、個々の仕様にて `first-line$pe に適用されるものと定義されている~prop。
◎
any other properties defined to apply to ::first-line by their respective specifications
</li>

</ul>

<p>
~UAは、他の~propを適用してもヨイ。
◎
User agents may apply other properties as well.
</p>

			</section>
			<section id="first-line-inheritance">
<h4 title="Inheritance and the ::first-line Pseudo-element">2.1.3.  継承と `first-line^pe 疑似要素</h4>

<p>
~CSS継承の間に，最初の行l上に生じる子~要素の部位が `first-line$pe 疑似要素から継承する~propは、 `first-line$pe 疑似要素に適用-可能なものに限られる。
すべての他の~propは、 `first-line$pe 疑似~要素の疑似要素でない親から継承される。
（最初の行l上に生じない子~要素の部位は、常に，その子の親から継承する。）
◎
During CSS inheritance, the portion of a child element that occurs on the first line only inherits properties applicable to the ::first-line pseudo-element from the ::first-line pseudo-element. For all other properties inheritance is from the non-pseudo-element parent of the first line pseudo element. (The portion of a child element that does not occur on the first line always inherits from the parent of that child.)
</p>

			</section>
		</section>
		<section id="first-letter-pseudo">
<h3 title="The ::first-letter pseudo-element">2.2. `first-letter^pe 疑似要素</h3>

<p>
`first-letter@pe
疑似要素は、その`出自の要素$の`整形される最初の行l$上の最初の`~typographic字l単位$ `CSS3TEXT$r を表現する
— 同じ行lに他の内容（画像や行内~tableなど）が先行していないならば。
`first-letter$pe 疑似要素は、
“持上げ頭字” や “埋没~頭字”
などの`先頭字$を作成するときに利用できる
— それらの~typographic効果は共通する。
◎
The ::first-letter pseudo-element represents the first typographic letter unit [CSS3TEXT] on the first formatted line of its originating element, if it is not preceded by any other content (such as images or inline tables) on its line. The ::first-letter pseudo-element can be used to create “initial caps” and “drop caps”, which are common typographic effects.
</p>

<div class="example">

<p>
例えば次の規則は、
`CSS-INLINE-3$r にて定義される `initial-letters$p ~propを利用して，各［
`h2^e に後続する段落
］ごとに 2 行lに~spanする埋没~頭字を作成する：
◎
For example, the following rule creates a 2-line drop-letter on every paragraph following a level-2 header, using the initial-letter property defined in [CSS-INLINE-3]:
</p>

<pre class="lang-css">
h2 + p::first-letter { initial-letters: 2; }
</pre>

</div>

<p>
最初の`~typographic字l単位$に［
先行する, または後続する
］ような約物（すなわち、`~Unicode字種$ `Punctuation^uc （ `P*^uc ） `UAX44$r ）に属する文字も， `first-letter$pe 疑似要素に含まれるモノトスル。
◎
Punctuation (i.e, characters that belong to the Punctuation (P*) Unicode general category [UAX44]) that precedes or follows the first typographic letter unit must also be included in the ::first-letter pseudo-element.
</p>

<figure>
<div style="width:8em; border:thin solid silver;" lang="en-x-a0">
<span style="display:inline-block; float: left; font-size: 300%; font-style:italic; line-height:1em">“A</span> bird in the hand is worth two in the bush,” says an old proverb.
</div>

<!-- css-pseudo/first-letter2.gif  -->
<figcaption>
最初の字lに先行する引用符も含められるベキである。
◎
Quotes that precede the first letter should be included.
</figcaption></figure>

<p>
`CSS3TEXT$r に説明されるように、`~typographic字l単位$は複数の ~Unicode符号位置を含み得る。
例えば，結合~文字たちは、それらの基底~文字とともに保たれるモノトスル。
また，一部の言語には、ある種の字lの組合わせを扱う方法について，追加的な規則もある。
例えば~Dutchでは、要素の始めに 字lの組合わせ "ij" が現れる場合、両~字lとも `first-letter$pe 疑似要素の中にあると見なさるベキである。
`UAX29$r
~UAは、［
`first-letter$pe 疑似要素の `包含塊^emの内容~言語
］による最初の字lに対する慣行を反映するように，自身による`~typographic字l単位$の定義を誂えるベキである。
◎
As explained in [CSS3TEXT], a typographic letter unit can include more than one Unicode codepoint. For example, combining characters must be kept with their base character. Also, languages may have additional rules about how to treat certain letter combinations. In Dutch, for example, if the letter combination "ij" appears at the beginning of an element, both letters should be considered within the ::first-letter pseudo-element. [UAX29] The UA should tailor its definition of typographic letter unit to reflect the first-letter traditions of the ::first-letter pseudo-element’s containing block’s content language.
</p>

<p class="note">注記：
最初の `~typographic字l単位$は、数字にもなり得ることに注意
— 例： "<samp>67 億もの大金…</samp>" の "6" など。
◎
Note: Note that the first typographic letter unit may in fact be a digit, e.g., the “6” in “67 million dollars is a lot of money.”
</p>

<p>
`first-letter$pe 疑似要素を形成する文字たちが複数の要素にまたがる場合
— `&lt;p&gt;‘&lt;em&gt;T...^samp 内の `‘T^c など —
~UAは、この疑似要素を，片方だけまたは両方の要素から作成してもヨイし，単純に作成しないことにしてもヨイ。
加えて，塊の最初の字l（たち）が行lの始端に来ない場合（例えば，双方向的な並替えに因り）、~UAは，疑似要素（たち）を作成する必要はない。
◎
If the characters that would form the ::first-letter are not in the same element, such as ‘T in &lt;p&gt;‘&lt;em&gt;T..., the user agent may create a ::first-letter pseudo-element from one of the elements, both elements, or simply not create a pseudo-element. Additionally, if the first letter(s) of the block are not at the start of the line (for example due to bidirectional reordering), then the user agent need not create the pseudo-element(s).
</p>

<p>
`first-letter$pe 疑似要素は、 `first-line$pe 疑似要素があれば その中に包含され、したがって `first-line$pe から継承する。
◎
The ::first-letter pseudo-element is contained within any ::first-line pseudo-elements, and thus inherits from ::first-line.
</p>

			<section id="application-in-css">
<h4 title="Finding the First Letter">2.2.1. 最初の字lの見出法</h4>

<p>
最初の字lは、`整形される最初の行l$に生じるモノトスル。
例えば，
`&lt;p&gt;&lt;br&gt;First...^samp
のような~HTML片の場合、最初の行lは字lを包含しないので， `first-letter$pe に合致するものはない。
特に、 "First" の "F" には合致しない。
◎
The first letter must occur on the first formatted line. For example, in this HTML fragment: &lt;p&gt;&lt;br&gt;First... the first line doesn’t contain any letters and ::first-letter doesn’t match anything. In particular, it does not match the “F” of “First”.
</p>

<p>
~CSSにおいては、 `first-letter$pe 疑似要素が適用されるのは，`塊~容器$に限られる。
<span class="note">
この仕様の将来~versionでは、この疑似要素を他の`表示-型$にも適用できるようにし得る。
</span>
`first-letter$pe 疑似要素は、［
~textを包含する ／
同じ~flow内にある~textを 包含している子孫がある
］ようなすべての要素に利用できる。
~UAは、［
`first-letter^pe 疑似要素の仮想の開始tagが要素の最初の~textの直前にある
］かのように動作するベキである
— その最初の~textが子孫~内にない場合でも。
◎
In CSS, the ::first-letter pseudo-element only applies to block containers. A future version of this specification may allow this pseudo-element to apply to more display types. The ::first-letter pseudo-element can be used with all such elements that contain text, or that have a descendant in the same flow that contains text. A user agent should act as if the fictional start tag of the ::first-letter pseudo-element is just before the first text of the element, even if that first text is in a descendant.
</p>

<div class="example">

<p>
例えば、次の~HTML片：
◎
Example: The fictional tag sequence for this HTML fragment:
</p>
<pre class="lang-html">
&lt;div&gt;
&lt;p&gt;~~最初の~text。
</pre>

<!-- 
<div>
<p>The first text.
-->

<p>
による`仮想の~tag列$は：
◎
is:
</p>

<pre class="lang-html">
&lt;div&gt;
&lt;p&gt;&lt;div::first-letter&gt;&lt;p::first-letter&gt;~~最&lt;/...&gt;&lt;/...&gt;~~初の~text。
</pre>

</div>

<p>
~CSSにおいては、
`table-cell$v ／ `inline-block$v
の最初の字lは、先祖~要素の最初の字lにはなれない。
したがって
`&lt;div&gt;&lt;p style="display: inline-block"&gt;Hello&lt;br&gt;Goodbye&lt;/p&gt; etcetera&lt;/div&gt;^samp
における `div^e の最初の字lは、字l "H" ではない。
~~実際、この `div^e に最初の字lはない。
要素が~list~itemである場合（
<span class="css">`display$p: `list-item$v</span>
）、 `first-letter$pe は，［
~markerの`後にある^em`主要~box$
］内の最初の字lに適用される。
~UAは、［
<span class="css">`list-style-position$p: `inside^v</span>
］にされている~list~item上の `first-letter$pe は無視してもヨイ。
要素に［
`before$pe ／ `after$pe
］内容もある場合、 `first-letter$pe は，その内容を`含んでいる^em要素の最初の字lに適用される。
◎
In CSS the first letter of a table-cell or inline-block cannot be the first letter of an ancestor element. Thus, in &lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt; the first letter of the DIV is not the letter "H". In fact, the DIV doesn’t have a first letter. If an element is a list item (display: list-item), the ::first-letter applies to the first letter in the principal box after the marker. User-Agents may ignore ::first-letter on list items with list-style-position: inside. If an element has ::before or ::after content, the ::first-letter applies to the first letter of the element including that content.
</p>

<div class="example">

<p>
例えば、規則
`p::before {content: "Note: "}^css
の後
,
選択子 `p::first-letter^css は、 "Note" の "N" に合致する。
◎
Example: After the rule p::before {content: "Note: "}, the selector p::first-letter matches the "N" of "Note".
</p>

</div>



			</section>
			<section id="first-letter-styling">
<h4 title="Styling the ::first-letter Pseudo-element">2.2.2.  `first-letter^pe 疑似要素の~style付け</h4>

<p>
~CSSにおいては、`first-letter^pe 疑似要素は、`行内level$の要素に類似する。
`first-letter$pe 疑似要素には、次の~propが適用される：
◎
In CSS a ::first-letter pseudo-element is similar to an inline-level element. The following properties that apply to ::first-letter pseudo-elements:
</p>

<ul>
	<li>
すべての~font~prop
`CSS3-FONTS$r
◎
all font properties (see [CSS3-FONTS])
</li>
	<li>
`color$p,
`opacity$p
~prop
`CSS3COLOR$r
◎
the color and opacity properties (see [CSS3COLOR])
</li>
	<li>
すべての背景~prop
`CSS3BG$r
◎
all background properties (see [CSS3BG])
</li>
	<li>
植字用~propのうち，行内~要素に適用されるもの
`CSS3TEXT$r
◎
any typesetting properties that apply to inline elements (see [CSS3TEXT])
</li>
	<li>
すべての~text装飾~prop
`CSS3-TEXT-DECOR$r
◎
all text decoration properties (see [CSS3-TEXT-DECOR])
</li>
	<li>
行内~layout~propのうち，行内~要素に適用されるもの
`CSS-INLINE-3$r
◎
any inline layout properties that apply to inline elements (see [CSS-INLINE-3])
</li>
	<li>
各種
~margin／~padding
~prop
`CSS21$r
◎
margin and padding properties (see [CSS21])
</li>
	<li>
各種~border~prop,
`box-shadow$p
`CSS3BG$r ）
◎
border properties and box-shadow (see [CSS3BG])
</li>
	<li>
その他、個々の仕様により、 `first-letter$pe に適用されるものと定義される~prop
◎
any other properties defined to apply to ::first-letter by their respective specifications
</li>
</ul>

<p>
~UAは、他の~propを適用してもヨイ。
◎
User agents may apply other properties as well.
</p>

<p class="note">注記：
~CSSの以前の~levelでは、~UAには、［
字lが成す図形に基づいて［
行l高, 縦幅＆横幅
］を選ぶこと ／
~font~sizeを近似すること ／
整形-時に ~glyph外形線を織り込むこと
］も許容されていた。
この可能性は、意図的に除去された
— 意図される利用-事例（埋没~頭字）には拙い解決策であることが判明している上、相互運用性の問題ももたらすので。
◎
Note: In previous levels of CSS, User Agents were allowed to choose a line height, width and height based on the shape of the letter, approximate font sizes, or to take the glyph outline into account when formatting. This possibility has been intentionally removed, as it proved to be a poor solution for the intended use case (Drop Caps), yet caused interoperability problems.
</p>

<div class="example">

<p>
先頭字にアリな描画を，次の~CSS, ~HTML例に示す。
最初の字lの仮想の開始tagは `span^e の内側にあるため、最初の字lの `font-weight^p は，
`span^e と同じ `bold^v ではなく `normal^v になることに注意：
◎
Example: This CSS and HTML example shows a possible rendering of an initial cap. Note that the fictional start tag of the first letter is inside the span, and thus the font weight of the first letter is normal, not bold as the span:
</p>

<pre class="lang-html">
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p&gt;&lt;span&gt;Het hemelsche&lt;/span&gt; gerecht heeft zich ten lange lesten&lt;br&gt;
Erbarremt over my en mijn benaeuwde vesten&lt;br&gt;
En arme burgery, en op mijn volcx gebed&lt;br&gt;
En dagelix geschrey de bange stad ontzet.
</pre>

<figure>
<div style="line-height: 1.1;padding-top: 1em;" lang="nl">
<span style="font-weight: bold;"><span style="font-size:300%; line-height: 0.37;">H</span>et hemelsche</span> gerecht heeft zich ten lange lesten<br>
Erbarremt over my en mijn benaeuwde vesten<br>
En arme burgery, en op mijn volcx gebed<br>
En dagelix geschrey de bange stad ontzet.
</div>
<!-- initial-cap.png -->
<figcaption>
`first-letter^pe 疑似要素の効果
◎
Image illustrating the ::first-letter pseudo-element
</figcaption></figure>

</div>

<div class="example">

<p>
次の~CSS, ~HTMLは、 2 行lに~spanする埋没~頭字を作成することになる：
◎
The following CSS will make a drop cap initial letter span about two lines:
</p>

<pre class="lang-css">
p               { font-size: 12pt; line-height: 1.2 }
p::first-letter { font-size: 200%; font-weight: bold; float: left }
span            { text-transform: uppercase }
</pre>

<pre class="lang-html">
&lt;p&gt;&lt;span&gt;The first&lt;/span&gt; few words of an article in The Economist.&lt;/p&gt;
</pre>

<!-- 
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
 -->

<p>
この例は、次のように整形されるであろう：
◎
This example might be formatted as follows:
</p>

<figure>
<div style="width:8em; line-height: 1.2; border:thin solid silver;" lang="en-x-a0">
<span><span style="display:inline-block; float: left; font-size: 200%; vertical-align: top; line-height:1em">T</span><span style="vertical-align: top;">HE FIRST</span></span> few words of an article in The Economist.
</div>
<!-- first-letter.gif -->

<figcaption>
`first-letter^pe, `first-line^pe 疑似要素を組合したときの効果
◎
Image illustrating the combined effect of the ::first-letter and ::first-line pseudo-elements
</figcaption></figure>

<p>
`仮想の~tag列$は：
◎
The fictional tag sequence is:
</p>

<pre class="lang-html">
&lt;p&gt;
  &lt;span&gt;
    &lt;p::first-letter&gt;
      T
    &lt;/p::first-letter&gt;he first
  &lt;/span&gt;
  few words of an article in the Economist.
&lt;/p&gt;
</pre>

<p>
`first-letter$pe 疑似要素~tagは，内容（すなわち，先頭字）を~~直に括る一方で、
`first-line^pe 疑似要素の開始tagは，塊~要素の開始tagの直後に挿入されることに注意。
◎
Note that the ::first-letter pseudo-element tags abut the content (i.e., the initial character), while the ::first-line pseudo-element start tag is inserted right after the start tag of the block element.
</p>

</div>

			</section>
		</section>
	</section>
	<section id="highlight-pseudos">
<h2 title="Highlight Pseudo-elements">3. 強調~用の疑似要素</h2>


		<section id="highlight-selectors">
<h3 title="Selecting Highlighted Content: the ::selection, ::inactive-selection, ::spelling-error, and ::grammar-error pseudo-elements">3.1. 強調された内容の選択-法： `selection^pe, `inactive-selection^pe, `spelling-error^pe, `grammar-error^pe 疑似要素</h3>

<p>
`強調~疑似要素@
は，文書~内で特定0の地位が与えられた部位を表現し、概して，その地位を利用者に指示するため異なる~styleがあてがわれる。
例えば，文書の選択された部位は、概して，それを表す地位を指示するよう強調される（代替する背景~色と前景~色, あるいは色~滲みが与えられる）。
`強調~疑似要素$として、以下に挙げるものが定義される：
◎
The highlight pseudo-elements represent portions of a document that have been given a particular status and are typically styled differently to indicate that status to the user. For example, selected portions of the document are typically highlighted (given alternate background and foreground colors, or a color wash) to indicate their selected status. The following highlight pseudo-elements are defined:
</p>

<dl>
	<dt>`selection@pe</dt>
	<dt>`inactive-selection@pe</dt>
	<dd>
これらの疑似要素は、未来にアリな~UAによる何らかの演算の対象として選定された，文書のある部位を表現する。
これらは例えば、［
~copy演算により複製されたり，~paste演算により置換されることになる
］ような，編集-可能な~text欄の中の選択された~textに適用される。
◎
The ::selection and ::inactive-selection pseudo-elements represent the portion of a document that has been selected as the target or object of some possible future user-agent operation(s). They apply, for example, to selected text within an editable text field, which would be copied by a copy operation or replaced by a paste operation.
</dd>
	<dd>
`selection$pe は，作動中の選択に適用される一方で、
`inactive-selection$pe は，作動中でない選択に適用される（例：
文書~windowは作動中でなく~eventを受取っていないとき）。
◎
::selection applies to active selections, whereas ::inactive-selection applies to inactive selections (e.g. when the document window is inactive and therefore not receiving events).
</dd>

	<dt>`spelling-error@pe</dt>
	<dd>
~UAにより綴りが誤っているとされた，~textの部位を表現する。
◎
The ::spelling-error pseudo-element represents a portion of text that has been flagged by the user agent as misspelled.
</dd>

	<dt>`grammar-error@pe</dt>
	<dd>
~UAにより文法的に不正とされた，~textの部位を表現する。
◎
The ::grammar-error pseudo-element represents a portion of text that has been flagged by the user agent as grammatically incorrect.
</dd>
</dl>

<p>
`強調~疑似要素$は、要素~木の中に収まるとは限らず，入子~構造を尊守せずに要素~境界を任意にまたがり得る。
◎
The highlight pseudo-elements do not necessarily fit into the element tree, and can arbitrarily cross element boundaries without honoring its nesting structure.
</p>

<p>
既定の~UA~stylesheetとして、次のものが追加される：
◎
The following addition is made to the default UA stylesheet:
</p>

<pre class="lang-css">
::spelling-error { text-decoration-line: spelling-error; }
::grammar-error { text-decoration-line: grammar-error; }
</pre>

<p class="note">注記：
~CSSの将来~levelでは、~custom強調~疑似要素を作成する仕方も導入され得る。
◎
Note: A future level of CSS may introduce ways to create custom highlight pseudo-elements.
</p>

		</section>
		<section id="highlight-styling">
<h3 title="Styling Highlights">3.2. 強調の~style付け</h3>

<p>
`強調~疑似要素$を~styleできる~propは、~layoutに影響しないものに制限される。
【<a href="#highlight-security">~security, ~privacy上の考慮点</a>を見よ。】
次に挙げる~propは、強調~疑似要素に適用される：
◎
The highlight pseudo-elements can only be styled by a limited set of properties that do not affect layout. The following properties apply to the highlight pseudo-elements:
</p>

<ul>
	<li>
`color$p
</li>
	<li>
`background-color$p
</li>
	<li>
`cursor$p
</li>
	<li>
`caret-color$p
</li>
	<li>
`outline$p とその下位porp
◎
outline and its longhands
</li>
	<li>
`text-decoration$p とそれに結付けられた各種~prop
◎
text-decoration and its associated properties
</li>
	<li>
`text-shadow$p
</li>
</ul>

<p class="issue">
ここに含められるべき~propは、他にもあるか？
◎
Are there any other properties that should be included here?
</p>

<p>
`color$p ~propは、次に挙げるものの色も指定する
⇒＃
~text,
~textに適用されているすべての行l装飾（下線, 上線, 取消線）,
［`出自の要素$, その先祖や子孫］により~textに適用される圏点（ `text-emphasis$p ）
◎
The color property specifies the color of both the text and all line decorations (underline, overline, line-through) and emphasis marks (text-emphasis) applied to the text by the originating element and its ancestors and descendants.
</p>

<p class="note">注記：
歴史的に，（これを書いている時点で）相互運用可能に~supportされているのは、
`color$p ／ `background-color$p
に限られている。
◎
Note: Historically (and at the time of writing) only color and background-color have been interoperably supported.
</p>

		</section>
		<section id="highlight-bounds">
<h3 title="Area of a Highlight">3.3. 強調を成す区画</h3>

<p>
<a href="#highlight-selectors">強調~用の疑似要素の各 型</a>
— `selection$pe, `inactive-selection$pe, `spelling-error$pe, `grammar-error$pe —
ごとに、文書~全体にわたる
`強調~overlay@
が存在し、その作動中の部位は，対応する`強調~疑似要素$により表現される。
◎
For each type of highlighting (see §3.1 Selecting Highlighted Content: the ::selection, ::inactive-selection, ::spelling-error, and ::grammar-error pseudo-elements) there exists a single highlight overlay for the entire document, the active portions of which are represented by the corresponding highlight pseudo-element.＼
</p>

<p>
各~boxは、自身が直に包含する［
~text／`置換され$る内容
］に対応する，~overlayの一部分を所有する：
◎
Each box owns the piece of the overlay corresponding to any text or replaced content directly contained by the box.
</p>

<ul>
	<li>
~textに対する~overlayは，少なくとも~em~box全体を覆うモノトスル。
また、~em~boxを行l~box辺まで更に上／下に拡張してもヨイ。
文字~間のアキもまた，~overlay区画の一部にしてもヨイ
— そのようなアキは、両側の文字とも包含するような要素のうち最も内縁のものに所属し，両~文字とも選択されたとき選択される。
◎
For text, the corresponding overlay must cover at least the entire em box and may extend further above/below the em box to the line box edges. Spacing between two characters may also be part of the overlay area, in which case it belongs to the innermost element that contains both characters and is selected when both characters are selected.
</li>
	<li>
`置換され$る内容に対する~overlayは、置換される~obj全体を覆うモノトスル。
また、要素の内容~box全体を含むように外方へ拡張してもヨイ。
◎
For replaced content, the associated overlay must cover at least the entire replaced object, and may extend outward to include the element’s entire content box.
</li>
	<li>
~overlayはまた、要素の~border~boxの中の，他の区画を含んでもヨイ
— そのような区画は、区画を包含する要素のうち，最も内縁のものに所属する。
◎
The overlay may also include other other areas within the border-box of an element; in this case, those areas belong to the innermost such element that contains the area.
</li>
</ul>

<p class="issue">
次を見よ：
<a href="http://lists.w3.org/Archives/Public/www-style/2008Nov/0022.html">F2F minutes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html">dbaron’s message</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0247.html">Daniel’s thread</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0261.html">Gecko notes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0366.html">Opera notes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0280.html">Webkit notes</a>
◎
See F2F minutes, dbaron’s message, Daniel’s thread, Gecko notes, Opera notes, Webkit notes
</p>

<p class="issue">
これは、働き方を正しく述べているのか？
◎
Not sure if this is the correct way of describing the way things work.
</p>

		</section>
		<section id="highlight-cascade">
<h3 title="Cascading and Per-Element Highlight Styles">3.4. ~cascade法と要素ごとの強調~style</h3>

<p>
各~要素は、作動中の自前の部位に`強調~overlay$を描く
— それは、［
要素を`出自の要素$とする`強調~疑似要素$たち
］に指定された~styleを受取る。
複数の~styleが競合する場合、~cascadeの結果により決定される~styleが勝つ。
~supportされる~propに~cascadeから値が与えられていない場合、その値は，`出自の要素$の親~要素の対応する`強調~疑似要素$からの継承により決定される（当の~propが`継承d~prop$かどうかに関わらず）。
◎
Each element draws its own active portions of the highlight overlays, which receives the styles specified by the corresponding highlight pseudo-element styles for which that element is the originating element. When multiple styles conflict, the winning style is determined by the cascade. When any supported property is not given a value by the cascade, it’s value is determined by inheritance from the corresponding highlight pseudo-element of its originating element’s parent element (regardless of whether that property is an inherited property).
</p>

<div class="example">

<p>
例えば次の規則が：
◎
For example, if the following rules were applied:
</p>
<pre class="lang-css">
p::selection      { color: yellow; background: green; }
p &gt; em::selection { color: orange; }
em::selection     { color:    red; }
</pre>

<p>
次の~markupに適用されていた場合：
◎
to the following markup:
</p>

<pre class="lang-html">
&lt;p&gt;これと&lt;em&gt;これを&lt;/em&gt;強調します。&lt;/p&gt;
</pre>
<!-- 
<p>Highlight this <em>and this</em>.</p>
 -->
<p>
`selection$pe による背景の強調~色は全体が `green^v になり、
`em^e 要素の外側, 内側の~text色は，順に `yellow^v, `orange^v になる。
◎
The selection highlight would be green throughout, with yellow text outside the &lt;em&gt; element and orange text inside it.
</p>

</div>

<p class="advisement">
複数の選択~styleを求める作者は、文書~全体にわたる選択~style用に
`:root::selection^css を利用するベキである
— そうすれば、子孫において きれいに上書きできるようになるので。
`selection$pe だけだと，木~内の各 要素に適用され、より特有の~styleが先祖にあっても，それを上書きすることになる。
◎
Authors wanting multiple selections styles should use :root::selection for their document-wide selection style, since this will allow clean overriding in descendants. ::selection alone applies to every element in the tree, overriding the more specific styles of any ancestors.
</p>

<div class="example">

<p>
例えば、作者が次を指定していて：
◎
For example, if an author specified
</p>
<pre class="lang-css">
::selection { background: blue; }
p.warning::selection { background: red; }
</pre>

<p>
文書が次を含んでいる場合：
◎
and the document included
</p>

<pre class="lang-html">
&lt;p class="warning"&gt;ある&lt;strong&gt;とても重要な情報&lt;/strong&gt;&lt;/p&gt;
</pre>
<!-- 
<p class="warning">Some <strong>very important information</strong></p>
 -->
<p>
"とても重要な情報" の強調は `blue^v になる
—  `strong^e 要素の `selection$pe は、 `::selection { background: blue; }^css 規則にも合致するので（型~選択子を欠くものは、暗黙の `*^css があることに注意）。
~style規則を次のように与えれば、意図される挙動（強調は `p.warning^css の中では `red^v, 他所では `blue^v ）になる：
◎
The highlight would be blue over “very important information” because the &lt;strong&gt; element´s ::selection also matches the ::selection { background: blue; } rule. (Remember that * is implied when a tag selector is missing.) The style rules that would give the intended behavior (red highlight within p.warning, blue elsewhere) are
</p>

<pre class="lang-css">
:root::selection { background: blue; }
p.warning::selection { background: red; }
</pre>

</div>

<p>
~UAは、作者が `color$p, `background-color$p とも指定していないときは，~OSに既定の強調~色を `selection$pe 用に利用するベキである。
◎
The UA should use the OS-default highlight colors for ::selection when neither color nor background-color has been specified by the author.
</p>

<p class="note">注記：
この，対にされて~cascadeする挙動は、~OSに既定の選択~色を，通常の~cascade（すなわち、~UA~stylesheetにおける `:root::selection^css 規則）を利用して表現できなくしている。
しかしながら，すでに~browser間で相互運用可能に実装されているので、おそらく~Web互換性の要件になる。
◎
Note: This paired-cascading behavior does not allow using the normal cascade (i.g. :root::selection rules in the UA style sheet) to represent the OS default selection colors. However it has been interoperably implemented in browsers and is thus probably a Web-compatibility requirement.
</p>

		</section>
		<section id="highlight-painting">
<h3 title="Painting the Highlight">3.5. 強調の塗法</h3>

<p>
各 `強調~疑似要素$は、対応する`強調~overlay$を成す部位の【利用者から見て】手前に, かつ
`有位置$な子孫（もしあれば）の直ぐ背後に，背景（ `background$p ）を描く（すなわち、
<a href="https://www.w3.org/TR/CSS21/zindex.html">CSS2.1§E.2</a>
段 8 の直前）。
その外形線（ `outline$p ）は、（もしあれば）背景の直ぐ手前に塗られる。
［
`selection$pe, `spelling-error$pe, `grammar-error$pe
］による~overlayは、先に挙げたものほど手前に描かれる。
◎
Each highlight pseudo-element draws its background over the corresponding portion of the highlight overlay, painting it immediately below any positioned descendants (i.e. just before step 8 in CSS2.1§E.2). Its outline, if any, is painted immediately over its background. The ::selection overlay is drawn over the ::spelling-error overlay which is drawn over the ::grammar-error overlay.
</p>

<p>
`強調~疑似要素$はまた、選択された~text（および，それに適用されている~text装飾）を描くのを抑止する。
代わりに，最も手前にある作動中の`強調~overlay$は、自前の `color$p を利用して，当の~text（および その装飾）を`強調~overlay$による背景（および外形線）の手前に描直す
— これらの `color^p に対する `currentcolor$v は、次の背後にある`強調~疑似要素$が成す層の `color$p を表現し，最終的には`出自の要素$に利用されることになる色に~fall-backする。
各`強調~疑似要素$により導入された~text装飾は、~textの元の装飾の手前に，それぞれの背景として同じ順序で積層され，それぞれの自前の色で描かれる。
◎
A highlight pseudo-element also suppresses the drawing of any selected text (and any text decorations applied to that text). Instead the topmost active highlight overlay redraws that text (and its decorations) over the highlight overlay backgrounds (and outlines, if any) using its own color, with currentColor representing the color of the next highlight pseudo-element layer below, falling back finally to that of the originating element (the colors that would otherwise be used). Any text decorations introduced by each highlight pseudo-element are stacked in the same order as their backgrounds over the text’s original decorations and are all drawn, in their own colors.
</p>

<p class="issue">
~text影には何が起こるべきか？
— それらを元の色で描くと、その色が灰色の濃淡でない場合，~~調和を乱す【なぜ灰色は除かれている？】。
~overlayに背景がある場合、その背後にある~text影は抑止するであろう？
◎
What should happen with text shadows? Drawing them in their original color is disconcerting if that color is not a shade of gray. Maybe if the overlay has a background, suppress any text shadows below it?
</p>

<p>
`置換され$ない内容に対しては、~UAは
`color$p, `background-color$p
の指定d値を（~alpha~channelも含め）尊守するモノトスル。
他方，`置換され$る内容に対しては、~UAは，内容が選択から透けて見えるような半透明な膜で~~覆うベキである。
この膜の色は、［
`background-color$p の指定d値が `transparent$v でなければそれ ／
他の場合は `color$p の指定d値
］になるベキである
— ~UAは、その~alpha~channelを調整してもヨイ。
◎
For non-replaced content, the UA must honor the color and background-color (including their alpha channels) as specified. However, for replaced content, the UA should create a semi-transparent wash to coat the content so that it can show through the selection. This wash should be of the specified background-color if that is not transparent, else of the specified color; however the UA may adjust the alpha channel.
</p>

		</section>
		<section id="highlight-security">
<h3 title="Security and Privacy Considerations">3.6. ~security, ~privacy上の考慮点</h3>

<p>
綴りや文法の誤りに対する~style付けは、利用者の辞書の内容についての情報（利用者の名前や,  住所録の内容まで含み得る）を漏洩し得るので、
`spelling-error$pe ／ `grammar-error$pe
を実装する~UAは，そのような強調された区分の~style付けを頁が読取れないよう防止するモノトスル。
【したがって、~layoutが変化するものなど，他の状態に影響して適用されたことが判別できる~styleは、適用されないことになる。】
◎
Because the styling of spelling and grammar errors can leak information about the contents of a user’s dictionary (which can include the user’s name and even includes the contents of his/her address book!) UAs that implement ::spelling-error and ::grammar-error must prevent pages from being able to read the styling of such highlighted segments.
</p>

		</section>
	</section>
	<section id="treelike">
<h2 title="Tree-Abiding Pseudo-elements">4. 木に留まる疑似要素</h2>

<p>
`木に留まる疑似要素@
は、常に~box木の中の ある~boxに対応する。
それは、`出自の要素$から`継承-$可能な~propすべてを継承する。
`継承-$可能でない~propは、通例通り，それぞれの`初期~値$をとる。
`CSS3CASCADE$r
◎
Tree-abiding pseudo-elements always fit within the box tree. They inherit any inheritable properties from their originating element; non-inheritable properties take their initial values as usual. [CSS3CASCADE]
</p>

		<section id="generated-content">
<h3 title="Generated Content Pseudo-elements: ::before and ::after">4.1.  生成d内容~疑似要素： `before^pe, `after^pe</h3>

<p>
`content$p の算出d値が `none$v でないときには、これらの疑似要素は，その`出自の要素$の直の子であったかのように†，~boxを生成し、文書~木~内にある通常の要素と同じ様に~styleできる。
◎
When their computed content value is not none, these pseudo-elements generate boxes as if they were immediate children of their originating element, and can be styled exactly like any normal document-sourced element in the document tree.
</p>

<p class="trans-note">【†
したがって、要素から~styleも継承することになる。
】</p>

<dl>
	<dt>`before@pe</dt>
	<dt>`after@pe</dt>
	<dd>
`出自の要素$の実際の内容の［
直前（ `before^pe ）／ 直後（ `after^pe ）
］にあって, ~box木において要素の子になるような，~style可能な疑似要素を表現する。
◎
Represents a styleable child pseudo-element immediately before the originating element’s actual content.
◎
Represents a styleable child pseudo-element immediately after the originating element’s actual content.
</dd>
</dl>

<div class="example">

<p>
例えば次の規則は、
`class^a 属性~値が `note^v を含んでいる
各 `p^e 要素ごとに，その内容の前に文字列 "注記：" を挿入する：
◎
For example, the following rule inserts the string “Note: ” before the content of every &lt;p&gt; element whose class attribute has the value note:
</p>

<pre class="lang-css">
p.note::before { content: "注記：" }
</pre>
<!-- "Note: " -->

<p>
`display$p の初期~値は `inline$v なので、これは`行内~box$を生成することになる。
`p^e の他の行内~boxである子と同様に，それは
`p^e の行内~整形~文脈に関与し，他の内容と行lを共有し得ることになる。
◎
Since the initial value of display is inline, this will generate an inline box. Like other inline children of &lt;p&gt;, it will participate in &lt;p&gt;’s inline formatting context, potentially sharing a line with other content.
</p>

</div>

<p>
定例の要素の内容と同じく、
`before$pe ／ `after^pe
疑似要素を成す生成d内容は、その`出自の要素$に適用されている
`first-line$pe や `first-letter$pe
疑似要素があれば，それらに含められ得る／含められてもヨイ。
◎
As with the content of regular elements, the generated content of ::before and :after pseudo-elements may be included in any ::first-line and ::first-letter pseudo-elements applied to its originating element.
</p>

		</section>
		<section id="marker-pseudo">
<h3 title="List Markers: the ::marker pseudo-element">4.2.  ~list~marker：`marker^pe 疑似要素</h3>

<p>
`marker@pe
疑似要素は、~list~itemにて自動的に生成される~marker~boxを表現する。 
<span class="css">`display$p: `list-item$v</span>
を見よ。
◎
The ::marker pseudo-element represents the automatically generated marker box of a list item. (See display: list-item.)
</p>

<p>
`marker$pe 疑似要素には、次の~propが適用される：
◎
The following CSS properties apply to a ::marker pseudo-element:
</p>

<ul>
	<li>
すべての~font~prop
`CSS3-FONTS$r
◎
all font properties (see [CSS3-FONTS])
</li>
	<li>
`color$p ~prop
`CSS3COLOR$r
◎
the color property (see [CSS3COLOR])
</li>
	<li>
`text-combine-upright$p ~prop
`CSS3-WRITING-MODES$r
◎
the text-combine-upright property (see [CSS3-WRITING-MODES])
</li>
</ul>

<p class="note" role="note">
将来の仕様は、ここに挙げた~propを拡張することが予期されている。
しかしながら，~marker~box~layoutが全部的に定義されるまでは、許容される~propは，これらに限られる。
◎
It is expected that future specifications will extend this list of properties; however at the moment marker box layout is not fully defined, so only these properties are allowed.
</p>

<p>
~UAは、自身の既定の~stylesheetに，次の規則を追加するモノトスル：
◎
UAs must add the following rule to their default style sheet:
</p>

<pre class="lang-css">
::marker { font-variant-numeric: tabular-nums; }
</pre>

		</section>
		<section id="placeholder-pseudo">
<h3 title="Placeholder Input: the ::placeholder pseudo-element">4.3. 仮入力： `placeholder^pe 疑似要素</h3>

<p>
`placeholder@pe
疑似要素は、~form入力~欄~内の仮入力（ `placeholder^en ）~textを表現する：
それは、当の欄の埋め方についての~hintを利用者に供するような，入力~textを表現する。
例えば日付~入力~欄の仮入力~textが
"<samp>YYYY/MM/DD</samp>"
であったなら、日付を与える数を［
年, 月, 日
］の順序で手入力することを明確化する。
◎
The ::placeholder pseudo-element represents placeholder text in an input field: text that represents the input and provides a hint to the user on how to fill out the form. For example, a date-input field might have the placeholder text “YYYY/MM/DD” to clarify that numeric dates are to be entered in year-month-day order.
</p>

<p class="note">注記：
`placeholder-shown$ps という`疑似類^emも存在する
— それは、仮入力~textを示している（~DOM内の）要素に適用され，そのような要素を特別に~styleするために利用できる。
`placeholder$pe は、特定的には，仮入力~text`自体^emを表現している疑似要素を選択する
— したがって，その能は他に比べ制限される。
◎
Note: There also exists a :placeholder-shown pseudo-class, which applies to (real) elements while they are showing placeholder text, and can be used to style such elements specially. ::placeholder specifically selects a pseudo-element representing the placeholder text, and is thus relatively limited in its abilities.
</p>

<p>
`first-line$pe 疑似要素に適用されるすべての~propは、
`placeholder$pe 疑似要素にも適用される。
◎
All properties that apply to the ::first-line pseudo-element also apply to the ::placeholder pseudo-element.
</p>

<p>
対話的~媒体においては、仮入力~textは，利用者が入力~欄に手入力し始めたときに隠されることが多い。
しかしながら，これは、要件ではなく，入力~値と仮入力の両~textとも同時的に可視にしてもヨイ。
正確な挙動は~UAにより定義されることに注意。
静的~媒体（印刷など）においては、仮入力~textは，利用者が入力を手入力した後でも呈示することになる。
◎
In interactive media, placeholder text is often hidden once the user has entered input; however this is not a requirement, and both the input value and the placeholder text may be visible simultaneously. The exact behavior is UA-defined. Note that in static media (such as print) placeholder text will be present even after the user has entered input.
</p>

<p class="issue">
~supportされる~propとして `text-align$p も含めるよう，求めている作者も見受けられる。
例えば
<a href="http://css-tricks.com/almanac/selectors/p/placeholder/">ここの~comment</a>
を見よ。
◎
Authors seem to want text-align on the list of supported properties. See e.g. comments here.
</p>

<p class="note">注記：
`placeholder$pe は、［
対応している要素が要素~木~内にある仮入力
］も指せるようにすることが，要請されている。
これがどう働くべきかは明瞭でないが、そうするに価するかもしれない。
`2517$issue
を見よ。
<!-- 2417誤記 -->
◎
Note: It’s been requested that ::placeholder also refer to a placeholder which has a corresponding element in the element tree. It’s not clear how this should work, but it may be worth doing. See Issue 2417.
</p>

		</section>
	</section>
	<section id="interactions">
<h2 title="Overlapping Pseudo-element Interactions">5. 重合している疑似要素~間の相互作用</h2>

<div class="example" id="overlapping-example">
<p>
次のことを~~念頭に：
◎
Recall that
</p>

<ul>
	<li>
`before$pe ／ `after$pe
を成す内容は、文書~木~内にある通常の要素であったかのように選択される。
◎
the contents of ::before and ::after are selected exactly as if they were normal elements in the document source tree
</li>
	<li>
`first-letter$pe は、`整形される最初の行l$上にしか存在できないよう拘束され、それを成す最初の字lに~~後続する~textは， `first-letter$pe の境界を すき間なく回込む。
◎
the ::first-letter boundaries are tightly wrapped around the first letter text, and ::first-letter is constrained to exist solely on the first formatted line.
</li>
	<li>
`first-line$pe の［
始端は 包含塊を与える要素の境界のすぐ内側／
終端は 行l上のすべての内容を閉じた後
］に挿入される。
◎
the ::first-line start is inserted just inside the containing block’s element boundary, and its end after the close of all content on the line
</li>
</ul>

<p>
重合している疑似要素がどう相互作用するかを、次の~CSS, ~HTMLに例示する。
◎
The following CSS and HTML example illustrates how overlapping pseudo-elements interact:
</p>

<pre class="lang-html">
&lt;style&gt;
p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }
&lt;/style&gt;

&lt;p&gt;この~textは、 1 行lに収まらない。&lt;/p&gt;
</pre>
<!-- 
&lt;p&gt;Some text that ends up on two lines&lt;/p&gt;
-->
<p>
各 `p^e 要素の最初の字lは、色は `green^v, ~font~sizeは `24pt^v になる。
残りのうち、`整形される最初の行l$を成す部分は `blue^v になり，その他の段落を成す部分は `red^v になる。
◎
The first letter of each P element will be green with a font size of ’24pt'. The rest of the first formatted line will be blue while the rest of the paragraph will be red.
</p>

<p>
単語 "収まらない" の直前で 行lが分断されるとするとき、この片に対する`仮想の~tag列$は、次のようになるであろう：
◎
Assuming that a line break will occur before the word "ends", the fictional tag sequence for this fragment might be:
</p>

<pre class="lang-html">
&lt;p&gt;
  &lt;p::first-line&gt;
    &lt;p::first-letter&gt;
      こ
    &lt;/p::first-letter&gt;
    の~textは、1 行lに
  &lt;/p::first-line&gt;
  収まらない。
&lt;/p&gt;
</pre>

</div>


	</section>
	<section id="cssom">
<h2 title="Additions to the CSS Object Model">6. ~CSS~obj~modelへの追加</h2>

<p>
疑似要素は、~scriptからも［
到達~可能になる／~styleできる／~event~targetとして可用になる
］ベキである。
◎
Pseudo-elements should be reachable by script, stylable from script, and available as event targets.
</p>

<p class="note" role="note">
この節は、将来には~scriptによる疑似要素の作成を許容するよう拡張され得る。
◎
Note We may extend this section in the future to allow creation of pseudo-elements from script.
</p>

<p class="issue">
この節~全体は、出発点に過ぎない。
~feedbackを歓迎する。
現時点における実装は〜でない【単に無い？】
— この~approachはまだ不確かなので。
◎
This entire section is a starting point for discussion. Feedback is welcome. Implementations, at this point, are not, as we are not yet sure of our approach.
</p>

<p class="issue">
これは、代替になる［
`PseudoElement^I, `pseudo()^m
］提案と併合される必要がある。
◎
This needs to be merged with the alternative PseudoElement and pseudo() proposal.
</p>

		<section id="CSSPseudoElement-interface">
<h3 title="Interface CSSPseudoElement">6.1. ~interface `CSSPseudoElement^I</h3>

<p>
`CSSPseudoElement^I ~interfaceにより、~scriptは，疑似要素を［
~styleする ／ ~event~targetにする
］ことが可能になる。
◎
The CSSPseudoElement interface allows pseudo-elements to be styleable from script and makes them event targets.
</p>

<p class="issue">
この草案における~approachは、 `CSSPseudoElement^I ~interfaceに必要な最小限から開始し、そこから築き上げる。
より急進的な、疑似要素と~nodeに共通する あらゆるものを取り出して
`Node^I, `CSSPseudoElement^I 用に新たな基底~classを作成する，別の~approachもある。
◎
The approach in this draft is to start with a bare minimum for the CSSPseudoElement interface and build up from there. Another more radical approach could take everything that’s common between a pseudo-element and a node and create a new base class for both Node and CSSPseudoElement.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPseudoElement@I {
    readonly attribute `CSSOMString$I `type$m;
    readonly attribute `Element$I `element$m;
    readonly attribute `CSSStyleDeclaration$I `style$m;
};

`CSSPseudoElement$I implements `EventTarget$I;
</pre>

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
<p>
疑似要素の型を表現する文字列を返す。
とり得る値は：
◎
The type attribute is a string representing the type of the pseudo-element. This can be one of the following values:
</p>
		<dl>
			<dt>`::before^l</dt>
			<dd>
疑似要素は、要素の内容の前に作成されている。
◎
The pseudo-element was created before the element’s contents.
</dd>

			<dt>`::after^l</dt>
			<dd>
疑似要素は、要素の内容の後に作成されている。
◎
The pseudo-element was created after the element’s contents.
</dd>

			<dt>`::first-letter^l</dt>
			<dd>
疑似要素は、要素の最初の字lを成す。
◎
The pseudo-element is the first letter of the element.
</dd>

			<dt>`::first-line^l</dt>
			<dd>
疑似要素は、要素の最初の行lを成す。
◎
The pseudo-element is the first line of the element.
</dd>

			<dt>`::selection^l</dt>
			<dd>
ある要素に対する選択~疑似要素。
◎
The selection pseudo-element for the element.
</dd>
		</dl>
	</dd>

	<dt>`element@m</dt>
	<dd>
この疑似要素の`出自の要素$を返す。
◎
The element attribute is the originating element of the pseudo-element.
</dd>

	<dt>`style@m</dt>
	<dd>
`CSSStyleDeclaration$I `CSSOM$r
を返す
— それは、この疑似要素の~style情報（~inline~style）を直に設定できるようにする。
この~inline~styleは、当の疑似要素に~styleをあてがう どの~style規則よりも優先される。
◎
The style attribute is a CSSStyleDeclaration [CSSOM] that allows directly setting style information (inline styles) onto the pseudo-element. Inline styles on a CSSPseudoElement have precedence over all style rules styling that pseudo-element.
</dd>
	<dd class="issue">
これは、実際の~inline~style
【通常の要素の<a href="~CSSSTYLEATTR#style-attribute0" >~style属性</a>による~style】
の様に
<a href="~CASCADE#cascade-order">~cascadeする</a>
ベキである
— 異なるものではなく。
◎
This should cascade like actual inline styles, not be a different thing.
</dd>
</dl>

<p>
`CSSPseudoElement^I ~objは、
`EventTarget$I ~interfaceを実装するモノトスル。
<!-- 
[DOM-LEVEL-2-EVENTS]
as a conformance requirement of this module.
 -->
◎
The EventTarget interface [DOM-LEVEL-2-EVENTS] must be implemented by all instances of CSSPseudoElement as a conformance requirement of this module.
</p>

		</section>
		<section id="CSSPseudoElementList-interface">
<h3 title="Interface CSSPseudoElementList">6.2. ~interface `CSSPseudoElementList^I</h3>

<p>
`CSSPseudoElementList^I は、
`CSSPseudoElement^I ~instanceたちが成す有順序~collectionを表現する。
◎
The CSSPseudoElementList represents an ordered collection of CSSPseudoElement instances.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPseudoElementList@I {
    readonly attribute `unsigned long$ `length$m;
    `CSSPseudoElement$I `item$m(`unsigned long$ %index);
    `CSSPseudoElement$I `getByType$m(`CSSOMString$I %type); /* <span class="comment">
%type に合致する疑似要素が無ければ ~NULL を返す。
◎
replies null if no pseudo-element exists for the requested type
</span> */
};
</pre>

<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
~collectionの~size（含まれる `CSSPseudoElement^I ~objの個数）を返す（~collectionが空ならば 0 になる）。
◎
The length attribute represents the number of CSSPseudoElement in the collection or zero if it is empty.＼
</dd>

	<dt>`item(index)@m</dt>
	<dd>
［
%index が ~collectionの~size未満ならば
~collection内の %index 番の `CSSPseudoElement^I ／
~ELSE_ ~NULL
］を返す。
◎
The method item() is used to retrieve a CSSPseudoElement by index. It takes one parameter being the requested index into the collection. Its return value is the CSSPseudoElement at the requested index in the collection or null if that is not a valid index.
</dd>

	<dt>`getByType(type)@m</dt>
	<dd>
~collection内に %type に合致する `CSSPseudoElement^I ~objが［
在ればそれ／
無ければ ~NULL
］を返す。
【この記述は、合致するものは，高々 1 つしかないことを前提にしている。】
◎
The method getByType() is used to retrieve a CSSPseudoElement by its type. Its return value is the CSSPseudoElement in the collection that matches the type or null if there is no CSSPseudoElement in the collection for that type.
</dd>
</dl>

		</section>
		<section id="window-interface">
<h3 title="Addition to the window interface">6.3. `Window^I ~interfaceへの追加</h3>

<p>
`Window^I ~interfaceには、所与の要素により作成された所与の型の疑似要素を検索取得するための，新たな~methodが追加される：
◎
A new method is added to the Window interface to retrieve pseudo-elements created by a given element for a given type:
</p>

<pre class="idl">
partial interface `Window$I {
  `CSSPseudoElementList$I `getPseudoElements$m(`Element$I %elt, `CSSOMString$I %type);
};
</pre>

<dl class="idl-def">
	<dt>`getPseudoElements(elt, type)@m</dt>
	<dd>
要素 %elt により作成された，型 %type の
`CSSPseudoElement^I ~instanceすべてからなる
`CSSPseudoElementList^I 値を返す。
【複数個あり得る？ 】
◎
The getPseudoElements() method is used to retrieve all CSSPseudoElement instances created by the element elt for the type type. Its return value is a CSSPseudoElementList, potentially empty if no pseudo-element exists for the given element and the given type.
</dd>
</dl>

		</section>
	</section>
	<section id="css2-compat">
<h2 title="Compatibilitiy Syntax">7. 互換性~構文</h2>

<p>
`CSS21$r 向けに書かれた既存の~stylesheetとの互換性を得るため、~UAは［
`before$pe ／ `after$pe ／ `first-letter$pe ／ `first-line$pe
］疑似要素~用には，以前の~colon 1 個の記法（
`before^ps ／ `after^ps ／ `first-letter^ps ／ `first-line^ps
）も受容するモノトスル。
◎
For compatibility with existing style sheets written against CSS Level 2 [CSS21], user agents must also accept the previous one-colon notation (:before, :after, :first-letter, :first-line) for the ::before, ::after, ::first-letter, and ::first-line pseudo-elements.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
<a href="https://www.w3.org/TR/2015/WD-css-pseudo-4-20150115/">2015年 1月 15日 作業草案</a>
からの変更点は：
◎
Changes since the 15 January 2015 Working Draft include:
</p>

<ul>
	<li>
`marker$pe 疑似要素を追加した。
◎
Addition of the ::marker pseudo-element.
</li>
	<li>
浮動された `first-letter$pe を与える特別な取扱いは除去した
— `先頭字の~style付け$の支持を受けて。
`CSS-INLINE-3$r
◎
Removed special handling of floated ::first-letter in favor of initial letter styling. [CSS-INLINE-3]
</li>
	<li>
`inactive-selection$pe を追加した。
◎
Added ::inactive-selection.
</li>
	<li>
~IEのより きめ細やかな挙動に合致させるため、 `selection$pe 上の~text装飾の取扱いを定義した。
◎
Defined handling of text decorations on ::selection to match IE’s more sensible behavior.
</li>
	<li>
疑似要素 ~obj~model設計-に関する論点への~link。
◎
Links to pseudo-element OM design discussions.
</li>
	<li>
様々な小さな明確化。
◎
Various minor clarifications.
</li>
	<li>
~UA~stylesheet内の［
`spelling-error$pe ／ `grammar-error$pe
］に［
`spelling-error$v ／ `grammar-error$v
］を利用。
◎
Use spelling-error and grammar-error with ::spelling-error and ::grammar-error in the UA stylesheet.
</li>
	<li>
`CSSPseudoElement$I ~interfaceに `element$m 属性を追加した。
◎
Added the element attribute to the CSSPseudoElement interface.
</li>
	<li>
`CSSPseudoElement$I ~interface上の `type$m 属性がとる値たちを，対応する疑似要素に合致するように変更した。
◎
Changed the values of the type attribute on the CSSPseudoElement interface to match the corresponding pseudo-elements.
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の構想, 開発, 考査の過程に協力された次の方々に：
</p>

<p lang="en-x-a0">
The editors would like to thank the following individuals for their contributions, either during the conception of the specification or during its development and specification review process: Tab Atkins, David Baron, Razvan Caliman, Chris Coyier, Anders Grimsrud, Vincent Hardy.
</p>

	</section>

</main></div>

