<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Pseudo-Elements Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	let context_prop = '';
	const class_map = this.class_map;
	const tag_map = this.tag_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'p':
	if( indicator === '@') {
		context_prop = `#valdef-${key}-`;
	}
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'v':
	href = context_prop + key;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}"></a>`;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Pseudo-Elements Module Level 4
spec_date:2020-07-08
trans_update:2020-07-14
source_checked:181231
page_state_key:CSS
original_url:https://drafts.csswg.org/css-pseudo-4/
	abbr_url:CSSPSEUDO
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2019,permissive
trans_1st_pub:2017-09-01


●●class_map
p:property
css:css
ps:pseudo
pe:pseudo
e:element
a:attr
v:value
uc:char-prop

●●tag_map
p:code
t:var
css:code
ps:code
pe:code
I:code
m:code
e:code
a:code
v:code
c:code
samp:samp
uc:b
em:em
i:i

●●original_id_map

●●mdn_urls
selectordef-after:CSS/::after
selectordef-before:CSS/::before
selectordef-first-letter:CSS/::first-letter
selectordef-first-line:CSS/::first-line
selectordef-grammar-error:CSS/::grammar-error
	selectordef-inactive-selection:CSS/::inactive-selection
selectordef-marker:CSS/::marker
selectordef-placeholder:CSS/::placeholder
selectordef-selection:CSS/::selection
selectordef-spelling-error:CSS/::spelling-error

csspseudoelement:API/CSSPseudoElement

●●link_map

Exposed:~WEBIDLjs#Exposed
CSSOMString:~CSSOM1#cssomstring
I.CSSPseudoElement:#csspseudoelement
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration
I.Element:~DOM4#element
I.EventTarget:~DOM4#eventtarget
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration

m.type:#dom-csspseudoelement-type
m.element:#dom-csspseudoelement-element

m.pseudo:#dom-element-pseudo


pe.after:#selectordef-after
pe.before:#selectordef-before
pe.first-letter:#selectordef-first-letter
pe.first-line:#selectordef-first-line
pe.grammar-error:#selectordef-grammar-error
pe.inactive-selection:#selectordef-inactive-selection
pe.marker:#selectordef-marker
pe.placeholder:#selectordef-placeholder
pe.selection:#selectordef-selection
pe.spelling-error:#selectordef-spelling-error

ps.placeholder-shown:~SELECTORS4#placeholder-shown-pseudo

p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.box-shadow:~CSSBG#propdef-box-shadow
p.caret-color:~CSSUI#propdef-caret-color
p.color:~CSSCOLOR#propdef-color
	p.color:https://drafts.csswg.org/css-color-3/#color0
p.content:~CSSCONTENT#propdef-content
p.cursor:~CSSUI#propdef-cursor
p.display:~CSSDISP#propdef-display
p.direction:~CSSWM#propdef-direction
p.initial-letter:~CSSINLINE#propdef-initial-letter
p.opacity:~CSSCOLOR#propdef-opacity
p.outline:~CSSUI#propdef-outline
p.ruby-position:~CSSRUBY#propdef-ruby-position
p.text-align:~CSSTEXT#propdef-text-align
p.text-emphasis-position:~CSSTEXTDECOR#propdef-text-emphasis-position
	/css-text-decor-4/#propdef-text-emphasis-position
p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration
	/css-text-decor-4/#propdef-text-decoration
p.text-emphasis:~CSSTEXTDECOR#propdef-text-emphasis
	/css-text-decor-4/#propdef-text-emphasis
p.text-shadow:~CSSTEXTDECOR#propdef-text-shadow
	＊p.display: list-item:~CSSDISP#propdef-display
p.text-transform:~CSSTEXT#propdef-text-transform
p.list-style-position:~CSSLIST#propdef-list-style-position
p.unicode-bidi:~CSSWM#propdef-unicode-bidi

p.stroke-color:https://drafts.fxtf.org/fill-stroke-3/#propdef-stroke-color
p.fill-color:https://drafts.fxtf.org/fill-stroke-3/#propdef-fill-color
p.stroke-width:https://drafts.fxtf.org/fill-stroke-3/#propdef-stroke-width
	~SVGpainting#StrokeWidthProperty


v.none:~CSSCONTENT#valdef-content-none
v.inline:~CSSDISP#valdef-display-inline
v.transparent:~CSSCOLOR#valdef-color-transparent

v.inline-block:~CSSDISP#valdef-display-inline-block
v.table-cell:~CSSDISP#valdef-display-table-cell
v.list-item:~CSSDISP#valdef-display-list-item
v.currentcolor:~CSSCOLOR#valdef-color-currentcolor

v.spelling-error:~CSSWG/css-text-decor-4/#valdef-text-decoration-line-spelling-error
	#valdef-text-decoration-line-spelling-error
v.grammar-error:~CSSWG/css-text-decor-4/#valdef-text-decoration-line-grammar-error

t.pseudo-element-selector:~SELECTORS4#typedef-pseudo-element-selector


~treeに留まる疑似要素:#tree-abiding
仮想の~tag列:#fictional-tag-sequence
整形される最初の行l:#first-formatted-line
強調~overlay:#highlight-overlay
強調~疑似要素:#highlight-pseudo-element

出自の要素:~SELECTORS4#originating-element

継承-:~CASCADE#inheritance
継承d~prop:~CASCADE#inherited-property
初期~値:~CASCADE#initial-value

塊~容器:~CSSDISP#block-container
行内~level:~CSSDISP#inline-level
行内~box:~CSSDISP#inline-box
塊~level:~CSSDISP#block-level
包含塊:~CSSDISP#containing-block
~flow外:~CSSDISP#out-of-flow
~flow内:~CSSDISP#in-flow
首要~box:~CSSDISP#principal-box
置換され:~CSSDISP#replaced-element
表示-型:~CSSDISP#display-type
	塊:~CSSDISP#block
	行内:~CSSDISP#inline
	行内塊:~CSSDISP#valdef-display-inline-block

選択子:~SELECTORS4#selector

~marker~box:~CSSLIST#marker
~list~item:~CSSLIST#list-item

~typographic字l単位:~CSSTEXT#typographic-letter-unit
先頭字:~CSSINLINE#initial-letter
埋没~頭字:~CSSINLINE#dropped-initial
沈込み頭字:~CSSINLINE#sunken-initial
持上げ頭字:~CSSINLINE#raised-initial

有位置:~CSSPOS#positioned-box
~style属性:~CSSSTYLEATTR#style-attribute0
疑似要素:~SELECTORS4#pseudo-element
~Unicode字種:~CSSTEXT#unicode-general-category

文法に則って構文解析-:~CSSSYN#css-parse-something-according-to-a-css-grammar

	●補完
~box:~CSSDISP#box
~box~tree:~CSSDISP#box-tree
内容~box:~CSSBOX#content-box
~border~box:~CSSBOX#border-box
	行l~box:~CSSINLINE#line-box
	~text連なり:~CSSDISP#text-run

	using the normal cascade:http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html
	§:#highlight-selectors
	:~TR/2015/WD-css-pseudo-4-20150115/
	:~TR/CSS21/zindex.html
	:http://lists.w3.org/Archives/Public/www-style/2010May/0247.html
	:http://lists.w3.org/Archives/Public/www-style/2008Nov/0022.html
	:http://lists.w3.org/Archives/Public/www-style/2010May/0261.html
	:http://lists.w3.org/Archives/Public/www-style/2010May/0366.html
	:http://lists.w3.org/Archives/Public/www-style/2010May/0280.html
	:http://css-tricks.com/almanac/selectors/p/placeholder/
	:http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html


●●words_table1


●●words_table



	●CSS
下位porp:longhand::下位プロパティ
	style可能な／できる:styleable
	style付け:styling
	~cascade法:cascading／:cascading rule

選択-:select::~
選択:selection::~
疑似:pseudo::~
出自の:originating:~

	●構造
	~treeに留まる:tree-abiding
	children
閉じて:closeして:~
閉じた:closeした:~
開く:openする:~
	また開く:re-open
封入-:enclose:~
	留まる:abiding
	添え付け:attach
	~~直に括る:abut
	要素~~単位／~boxに対応する:fit
	最も内縁の:innermost
	文書~全体にわたる:document-wide
後続-:follow:~

	●処理
	-:execute
読取れ:readでき:読み取れ
存続期間:lifetime:~
	手続き:steps

	●構文
開始tag:start tag::開始 tag:開始タグ
終了tag:end tag::終了 tag:終了タグ
仮想の:fictional::~

	●UI／呈示
copy::::コピー
paste::::ペースト
	作動中でない:inactive
隠され:hideされ:~
強調:highlight::~
仮入力:placeholder:~
contrast::::コントラスト
欄:field:~

	●塗り
overlay:
積層-:stack::~
alpha:
塗られ:paintされ::~
塗法:paint 法::塗り方
	painting
	手前:over
	最も手前:topmost
	背後:under
	直ぐ:immediately
描かれ:drawされ:~
描く:drawする:~
	描くのを:drawing:
描直す:redrawする:描き直す
覆う:coverする:~
背景:background::~
前景:foreground::~
色:color::~
膜:wash:~
影:shadow::~
灰色:gray:~
濃淡:shade:~
半透明:semi-transparent:~
	~~覆う:create a 〜 to coat
	透けて見える:can show through
	highlighting
滲み:wash:~
fill::::フィル

	●layout
	flow外:out-of-flow
table::::テーブル
	~border~box:border-box:
marker::::マーカ
	生成し直-:regenerate
	置換されない:non-replaced
	置換される:replaced
首要:principal::主要
浮動-:float::~
浮動:floating::~
外方:outward:~
部位:portion:~
重合して:overlapして:重なり合って
区分:segment:~

	●text 組版
em:
typographic::::タイポグラフィック
glyph::::グリフ
外形線:outline::~
字l:letter::字°
	最初の字l:first-letter
	最初の行l:first-line
アキ:spacing::~
分断-:break::~
先頭字:initial cap::~
頭字:cap::~
埋没:dropped::~
	埋没~頭字:drop cap／drop-letter／Drop Caps
持上げ:raised::持ち上げ
	沈込み:sunken::沈み込み
上線:overline::~
下線:underline::~

取消線:line-through::打消線
圏点:emphasis mark::~
	Punctuation
約物:punctuation::~
数字:digit:~
装飾:decoration::~
植字用:typesetting::~
結合:combining::~
折返した:wrapした::折り返した
回込む:wrap aroundする::回り込む
span:
	すき間なく:tight
双方向-:bidirectional::~

	●仕様
	-:exactly
拙い:poorな:~
地位:status:~
	可能性:possibility
都合:convenience:~
	小さな:minor

	同じ様にexactly like
	~~実際:In fact
	にもなり得る:may in fact
	:whereas
	:Issue
	？:sure
	までは:at the moment
	の支持を受けて:in favor of
	個々の:their respective
	他方／が:however
	とは限らず／ない〜であっても:not necessarily
	seem
	note
	助け:help
	thank
	very:
	Issue:
	potentially
	なり得る:potential
	Level
	次のことを~~念頭に:Recall that
	優先される:over have precedence
	価する:worth
	他に比べ:relatively
	〜限り:insofar

	●仕様（動詞
誂える:tailorする:あつらえる
過程:process:~
競合-:conflict:~
解決策:solution:~
判明して:proveされて:~
構想:conception:~
模倣-:simulate:~
見出法:find 法:見出し方
	overriding
修正点:fixes:~

	~supportされない:unsupported
	定義し直-:redefine
	実装されてない:unimplemented
	できなくしている:not allow
	論の最中にある under discussion
	書き直す:rewritten
	書かれ:written
	働き方:way things work
	選ぶ:choose する
	〜とする:assume
	〜とするとき:assuming
	例示-:illustrate
	-:remember
	caused
	指せるように:refer
	書いている:writing


	●未分類（動詞
先行-:precede:~
現れる:appearする:~
近似-:approximate:~
勝つ:winする:優先される
	形:form
綴り:spelling:~
	綴りが誤っている:misspelled
収まる:fitする:~
	~~調和を乱す:disconcerting
	得られ:get
	埋め方:how to fill out
	保たれ:kept
	次のように:as follow
	属する／所属:belong
	~~作成-:make
	とされた:flag
	欠く:missing
	またがり:cross

	●未分類

OS:
Dutch:::オランダ語
	h2:level-2 header
	-:source／-sourced
colon::::コロン
	~colon 1 個の:one-colon
片:fragment:~
	同時に:simultaneous

単語:word:~
文法的:grammatical:~
字種:general category:~
	文:sentence
編集-:edit:~
慣習:tradition:~
図形:shape:~
単位:unit:~
同一性:identity:~

	~NULL性:nullness
	blue／green／yellow／red／orange

	列:sequence
	日付~入力:date-input:
	年, 月, 日:year-month-day
	住所録:address book
	~obj~model:OM
	型~選択子:tag selector
	we
	bare
	-:source／-sourced
	対象:target or object
	~DOM内の:real

	●指示語
普通の:ordinary:~
	直の:immediately
	直前:just before
	直前 immediately before
	直後 immediately after
	即時:immediate
	we
	向けに:against
	各〜ごと:every
	以前の／前掲の:previous
	周り:around
	のみ／すぐ:just
	残り:rest
	実の:real
	の始め:at the beginning
	始めの所:beginning
	:non-
	:anything
	全体:throughout
	一部分:piece
	直後:right after
	同様に:like
	対にされた:paired-
	だけ:alone
	しか〜ない:solely
	他の，〜部分:the rest
	を与える数:numeric
	最終的には:finally
	-:anyone
	^en:congruent


●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 November 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-CONTENT-3]
    Elika Etemad; Dave Cramer. CSS Generated Content Module Level 3. 2 August 2019. WD. URL: https://www.w3.org/TR/css-content-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. CSS Lists Module Level 3. 17 August 2019. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-RUBY-1]
    Elika Etemad; et al. CSS Ruby Layout Module Level 1. 29 April 2020. WD. URL: https://www.w3.org/TR/css-ruby-1/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 29 April 2020. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-TEXT-DECOR-4]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 4. 6 May 2020. WD. URL: https://www.w3.org/TR/css-text-decor-4/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 24 January 2020. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 10 December 2019. REC. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FILL-STROKE-3]
    Elika Etemad; Tab Atkins Jr.. CSS Fill and Stroke Module Level 3. 13 April 2017. WD. URL: https://www.w3.org/TR/fill-stroke-3/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 
[UAX44]
    Ken Whistler; Laurențiu Iancu. Unicode Character Database. 4 March 2020. Unicode Standard Annex #44. URL: https://www.unicode.org/reports/tr44/tr44-26.html 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. CSS Inline Layout Module Level 3. 4 June 2020. WD. URL: https://www.w3.org/TR/css-inline-3/ 
[CSS-TEXT-DECOR-3]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 13 August 2019. CR. URL: https://www.w3.org/TR/css-text-decor-3/ 
[HTML5]
    Ian Hickson; et al. HTML5. 27 March 2018. REC. URL: https://www.w3.org/TR/html5/ 
[SELECTORS-3]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 
[UAX29]
    Mark Davis; Christopher Chapman. Unicode Text Segmentation. 19 February 2020. Unicode Standard Annex #29. URL: https://www.unicode.org/reports/tr29/tr29-37.html 
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. Web Animations. 11 October 2018. WD. URL: https://www.w3.org/TR/web-animations-1/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Pseudo-Elements Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-pseudo-4/

編集者草案
	https://drafts.csswg.org/css-pseudo-4/

以前のバージョン
	https://www.w3.org/TR/2016/WD-css-pseudo-4-20160607/
	https://www.w3.org/TR/2015/WD-css-pseudo-4-20150115/

テスト一式
	http://test.csswg.org/suites/css-pseudo-4_dev/nightly-unstable/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-pseudo-4">GitHub Issues</a>

編集
	Daniel Glazman (Disruptive Innovations)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="mailto:stearns@adobe.com">Alan Stearns</a> (Adobe Systems Inc.)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-pseudo-4/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/css-pseudo-4

</script>



<body>

<header>
	<hgroup>
<h1>疑似要素 — CSS Pseudo-Elements Module Level 4</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、疑似要素を定義する。
それは、選択して~styleできるような，~CSS描画-~treeのある部位を表現する抽象的な要素である。
◎
This CSS module defines pseudo-elements, abstract elements that represent portions of the CSS render tree that can be selected and styled.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`疑似要素$は、文書~言語により明示的に作成される要素を超えるような，文書の抽象的な要素を表現する。
疑似要素は，文書~treeを成す要素~~単位に制約されないので、文書の~tree構造に対応付けられない部位であっても，選択して~styleをあてがうために利用できる。
一例として， `first-line$pe 疑似要素は、［
~layoutにおいて~textを`折返した後^emにおける，`出自の要素$の`整形される最初の行l$
］の内容を選択でき，その行lにだけ段落の残りと異なる~styleをあてがえるようになる。
◎
Pseudo-elements represent abstract elements of the document beyond those elements explicitly created by the document language. Since they are not restricted to fitting into the document tree, they can be used to select and style portions of the document that do not necessarily map to the document’s tree structure. For instance, the ::first-line pseudo-element can select content on the first formatted line of an element after text wrapping, allowing just that line to be styled differently from the rest of the paragraph.
</p>

<p>
各~疑似要素には、`出自の要素$が結付けられる。
疑似要素の構文は、 `<var>(疑似要素の名前)</var>^pe の形をとる。
この~moduleは、~CSSに存在している疑似要素, および
それらをどう~styleできるかを定義する。
疑似要素についての［
より一般的な情報, 構文, 他の`選択子$との相互作用
］については、
`SELECTORS-4$r を見よ。
◎
Each pseudo-element is associated with an originating element and has syntax of the form ::name-of-pseudo. This module defines the pseudo-elements that exist in CSS and how they can be styled. For more information on pseudo-elements in general, and on their syntax and interaction with other selectors, see [SELECTORS-4].
</p>

	</section>
	<section id="typographic-pseudos">
<h2 title="Typographic Pseudo-elements">2. ~typographic疑似要素</h2>


		<section id="first-line-pseudo">
<h3 title="The ::first-line pseudo-element">2.1. `first-line^pe 疑似要素</h3>

<p>
`first-line@pe
疑似要素は、その`出自の要素$の`整形される最初の行l$の内容を述べる。
◎
The ::first-line pseudo-element describes the contents of the first formatted line of its originating element.
</p>

<div class="example">

<p>
次の規則は、
“各 `p^e 要素ごとに その最初の行lを成す字lたちを大文字に変更する”
ことを意味する：
◎
The rule below means “change the letters of the first line of every p element to uppercase”:
</p>

<pre class="lang-css">
p::first-line { `text-transform$p: uppercase }
</pre>

<p>
選択子 `p::first-line^css に合致するような，実の文書~要素はない。
それが合致するのは、適合~UAが，各 `p^e 要素ごとに その始めの所に挿入することになる，疑似要素である。
◎
The selector p::first-line does not match any real document element. It does match a pseudo-element that conforming user agents will insert at the beginning of every p element.
</p>
</div>

<p class="note">注記：
最初の行lの長さは、~pageの横幅, ~font~size, 等々，いくつもの要因に依存することに注意。
◎
Note: Note that the length of the first line depends on a number of factors, including the width of the page, the font size, etc.
</p>

<div class="example">

<p>
例えば，次のような普通の~HTML段落は：
◎
For example, given an ordinary HTML [HTML5] paragraph such as:
</p>

<pre class="lang-html">
&lt;p&gt;これは、いくぶん長い~HTML段落であり、何~行lかに分断される。最初の行lは、`仮想の~tag列$により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 


&lt;P&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->
<p>
次のように何~行lかに分断されるであろう：
◎
The lines might be broken as follows:
</p>

<pre class="lang-html">
<mark>これは、いくぶん長い~HTML段落であり、</mark>
何~行lかに分断される。最初の行lは、仮想の
~tag列により識別される。他の行lは、段落
内の普通の行lとして扱われることになる。
</pre>
<!-- 
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag
sequence. The other lines will be treated as
ordinary lines in the paragraph.

 -->
<p>
~UAは、この段落を `first-line$pe を表現する
`仮想の~tag列@
（ `fictional tag sequence^en ）を含むよう “書き直す” こともある。
この`仮想の~tag列$は、~propがどう継承されるかを示す助けになる：
◎
This paragraph might be “rewritten” by user agents to include a fictional tag sequence to represent ::first-line. This fictional tag sequence helps to show how properties are inherited.
</p>

<pre class="lang-html">
&lt;p&gt;<mark>&lt;p::first-line&gt;</mark>これは、いくぶん長い~HTML段落であり、<mark>&lt;/p::first-line&gt;</mark>何~行lかに分断される。最初の行lは、仮想の~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;<mark>&lt;P::first-line&gt;</mark> This is a somewhat long HTML
paragraph that <mark>&lt;/P::first-line&gt;</mark> will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->
</div>

<p>
疑似要素が実の要素を分断する場合に欲される効果は、要素を閉じて, また開くような，`仮想の~tag列$で記述できることが多い。
◎
If a pseudo-element breaks up a real element, the desired effect can often be described by a fictional tag sequence that closes and then re-opens the element.
</p>

<div class="example">

<p>
前掲の段落の最初の文が， `span^e 要素で包摂されるように~mark-upされていたとする：
◎
Thus, if we mark up the previous paragraph with a span element encompassing the first sentence:
</p>

<pre class="lang-html">
&lt;p&gt;<mark>&lt;span class="test"&gt;</mark>これは、いくぶん長い~HTML段落であり、何~行lかに分断される。<mark>&lt;/span&gt;</mark>最初の行lは、仮想の~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;<mark>&lt;SPAN class="test"&gt;</mark> This is a somewhat long HTML
paragraph that will be broken into several
lines.<mark>&lt;/SPAN&gt;</mark> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;

 -->

<p>
`first-line$pe 用に`仮想の~tag列$を挿入するとき、~UAは， `span^e に対する［
開始tag, 終了tag
］を模倣して，正しい継承の挙動を得ることもできる。
◎
the user agent could simulate start and end tags for span when inserting the fictional tag sequence for ::first-line to get the correct inheritance behavior.
</p>

<pre class="lang-html">
&lt;p&gt;&lt;p::first-line&gt;<mark>&lt;span class="test"&gt;</mark>これは、いくぶん長い~HTML段落であり、<mark>&lt;/span&gt;</mark>&lt;/p::first-line&gt;<mark>&lt;span class="test"&gt;</mark>何~行lかに分断される。最初の行lは、仮想の<mark>&lt;/span&gt;</mark>~tag列により識別される。他の行lは、段落~内の普通の行lとして扱われることになる。&lt;/p&gt;
</pre>
<!-- 
&lt;P&gt;&lt;P::first-line&gt;<mark>&lt;SPAN class="test"&gt;</mark> This is a somewhat long HTML
paragraph that will <mark>&lt;/SPAN&gt;</mark>&lt;/P::first-line&gt;<mark>&lt;SPAN class="test"&gt;</mark> be broken into several
lines.<mark>&lt;/SPAN&gt;</mark> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
-->
</div>

			<section id="first-text-line">
<h4 title="Finding the First Formatted Line">2.1.1. 整形される最初の行lの見出法</h4>

<p>
~CSSにおいては、 `first-line$pe 疑似要素の効果があるのは，`塊~容器$に添え付けられた場合に限られる。
要素の
`整形される最初の行l@
が生じる所は、要素の子孫のうち［
同じ`~flow内$にある（すなわち，浮動や位置決めに因り`~flow外$にされていない）, かつ `塊~level$である
］ものの内側になるモノトスル。
◎
In CSS, the ::first-line pseudo-element can only have an effect when attached to a block container. The first formatted line of an element must occur inside a block-level descendant in the same flow (i.e., a block-level descendant that is not out-of-flow due to floating or positioning).
</p>

<div class="example">

<p>
例えば
`&lt;div&gt;&lt;p&gt;最初の行l…&lt;/p&gt;&lt;/div&gt;^samp
における， `div^e の`整形される最初の行l$は、
`p^e 内の
`最初の行l…^samp
になる（この `p^e, `div^e は、ともに塊とする）。
◎
For example, the first line of the DIV in &lt;DIV&gt;&lt;P&gt;This line...&lt;/P&gt;&lt;/DIV&gt; is the first line of the P (assuming that both P and DIV are blocks).
</p>

</div>

<p>
［
`table-cell$v ／ `inline-block$v
］は塊~levelではないので、その最初の行lは，先祖~要素の`整形される最初の行l$にはなり得ない。
したがって，
`&lt;div&gt;&lt;p style="display: inline-block"&gt;Hello&lt;br&gt;Goodbye&lt;/p&gt; etcetera&lt;/div&gt;^samp
における `div^e の`整形される最初の行l$は、行l "Hello" にはならない。
◎
The first line of a table-cell or inline-block cannot be the first formatted line of an ancestor element. Thus, in &lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt; the first formatted line of the DIV is not the line "Hello".
</p>

<p class="note">注記：
［
`&lt;p&gt;&lt;br&gt;First...^samp
における `p^e の最初の行l
］に包含される字lはないことに注意（ `br^e は既定の~styleとする）。
単語 "First" は、`整形される最初の行l$上にはない。
◎
Note: Note that the first line of the p in this fragment: &lt;p&gt;&lt;br&gt;First... doesn’t contain any letters (assuming the default style for br). The word "First" is not on the first formatted line.
</p>

<p>
~UAは、［
`first-line$pe 疑似要素の仮想の開始tagが、［
【最初の行lを】封入している`塊~level$の要素のうち，最も内縁のもの
］の，すぐ内側に入子にされていた
］かのように動作するモノトスル。
◎
A user agent must act as if the fictional start tags of a ::first-line pseudo-element were nested just inside the innermost enclosing block-level element.
</p>

<div class="example">

<p>
例えば、次の~HTML：
◎
For example, the fictional tag sequence for
</p>

<pre class="lang-html">
&lt;div&gt;
  &lt;p&gt;最初の段落&lt;/p&gt;
  &lt;p&gt;二番目の段落&lt;/p&gt;
&lt;/div&gt;
</pre>
<!-- 
&lt;DIV&gt;
  &lt;P&gt;First paragraph&lt;/P&gt;
  &lt;P&gt;Second paragraph&lt;/P&gt;
&lt;/DIV&gt;
-->
<p>
に対する`仮想の~tag列$は：
◎
is
</p>

<pre class="lang-html">
&lt;div&gt;
  &lt;p&gt;&lt;div::first-line&gt;&lt;p::first-line&gt;最初の段落&lt;/p::first-line&gt;&lt;/div::first-line&gt;&lt;/p&gt;
  &lt;p&gt;&lt;p::first-line&gt;二番目の段落&lt;/p::first-line&gt;&lt;/p&gt;
&lt;/div&gt;
</pre>

<p class="trans-note">【
この例は、 `div^e, `p^e ともに `first-line$pe が適用されている。
`仮想の~tag列$を生成する順序は、先祖である `div^e から先になるようだ。
】</p>

<!-- 
&lt;DIV&gt;
  &lt;P&gt;&lt;DIV::first-line&gt;&lt;P::first-line&gt;First paragraph&lt;/P::first-line&gt;&lt;/DIV::first-line&gt;&lt;/P&gt;
  &lt;P&gt;&lt;P::first-line&gt;Second paragraph&lt;/P::first-line&gt;&lt;/P&gt;
&lt;/DIV&gt;
-->
</div>



			</section>
			<section id="first-line-styling">
<h4 title="Styling the First Line Pseudo-element">2.1.2. `first-line^pe 疑似要素の~style付け</h4>

<p>
`first-line$pe 疑似要素により生成される`~box$は、`行内~level$の要素によるそれと類似に挙動するが、一定の制約がある。
`first-line$pe 疑似要素には、次の~propが適用される：
◎
The ::first-line pseudo-element’s generated box behaves similar to that of an inline-level element, but with certain restrictions. The following CSS properties apply to a ::first-line pseudo-element:
</p>

<ul>
	<li>
すべての~font~prop
`CSS-FONTS-3$r
◎
all font properties (see [CSS-FONTS-3])
</li>
	<li>
`color$p, `opacity$p ~prop
`CSS-COLOR-3$r
◎
the color and opacity properties (see [CSS-COLOR-3])
</li>
	<li>
すべての背景~prop
`CSS-BACKGROUNDS-3$r
◎
all background properties (see [CSS-BACKGROUNDS-3])
</li>
	<li>
植字用~propのうち，行内~要素に適用されるもの
`CSS-TEXT-3$r
◎
any typesetting properties that apply to inline elements (see [CSS-TEXT-3])
</li>
	<li>
すべての~text装飾~prop
`CSS-TEXT-DECOR-3$r
◎
all text decoration properties (see [CSS-TEXT-DECOR-3])
</li>
	<li>
`ruby-position$p ~prop
`CSS-RUBY-1$r
◎
the ruby-position property (see [CSS-RUBY-1]) 
</li>
	<li>
行内~layout~propのうち，行内~要素に適用されるもの
`CSS-INLINE-3$r
◎
any inline layout properties that apply to inline elements (see [CSS-INLINE-3])
</li>
	<li>
その他、個々の仕様にて `first-line$pe に適用されるものと定義されている~prop。
◎
any other properties defined to apply to ::first-line by their respective specifications
</li>

</ul>

<p>
~UAは、他の~propを適用してもヨイ。
◎
User agents may apply other properties as well.
</p>

			</section>
			<section id="first-line-inheritance">
<h4 title="Inheritance and the ::first-line Pseudo-element">2.1.3.  継承と `first-line^pe 疑似要素</h4>

<p>
~CSS継承の間に，最初の行l上に生じる子~要素の部位が `first-line$pe 疑似要素から継承する~propは、 `first-line$pe 疑似要素に適用-可能なものに限られる。
すべての他の~propは、 `first-line$pe 疑似~要素の疑似要素でない親から継承される。
（最初の行l上に生じない子~要素の部位は、常に，その子の親から継承する。）
◎
During CSS inheritance, the portion of a child element that occurs on the first line only inherits properties applicable to the ::first-line pseudo-element from the ::first-line pseudo-element. For all other properties inheritance is from the non-pseudo-element parent of the first line pseudo element. (The portion of a child element that does not occur on the first line always inherits from the parent of that child.)
</p>

			</section>
		</section>
		<section id="first-letter-pseudo">
<h3 title="The ::first-letter pseudo-element">2.2. `first-letter^pe 疑似要素</h3>

<p>
`first-letter@pe
疑似要素は、その`出自の要素$の`整形される最初の行l$上の最初の`~typographic字l単位$ `CSS-TEXT-3$r を表現する
— 同じ行lに他の内容（画像や行内~tableなど）が先行していないならば。
`first-letter$pe 疑似要素は、
“持上げ頭字” や “埋没~頭字”
などの`先頭字$を作成するときに利用できる
— それらの~typographic効果は共通する。
◎
The ::first-letter pseudo-element represents the first typographic letter unit [CSS-TEXT-3] on the first formatted line of its originating element, if it is not preceded by any other content (such as images or inline tables) on its line. The ::first-letter pseudo-element can be used to create “initial caps” and “drop caps”, which are common typographic effects.
</p>

<div class="example">

<p>
例えば次の規則は、
`CSS-INLINE-3$r にて定義される `initial-letter$p ~propを利用して，各［
`h2^e に後続する段落
］ごとに 2 行lに~spanする埋没~頭字を作成する：
◎
For example, the following rule creates a 2-line drop-letter on every paragraph following a level-2 header, using the initial-letter property defined in [CSS-INLINE-3]:
</p>

<pre class="lang-css">
h2 + p::first-letter { initial-letter: 2; }
</pre>

</div>

<p>
最初の`~typographic字l単位$に［
先行する, または後続する
］ような約物（すなわち、`~Unicode字種$ `Punctuation^uc （ `P*^uc ） `UAX44$r ）に属する文字も， `first-letter$pe 疑似要素に含まれるモノトスル。
◎
Punctuation (i.e, characters that belong to the Punctuation (P*) Unicode general category [UAX44]) that precedes or follows the first typographic letter unit must also be included in the ::first-letter pseudo-element.
</p>

<figure>
<div style="width:8em; border:thin solid silver;" lang="en-x-a0">
<span style="display:inline-block; float: left; font-size: 300%; font-style:italic; line-height:1em">“A</span> bird in the hand is worth two in the bush,” says an old proverb.
</div>

<!-- css-pseudo/first-letter2.gif  -->
<figcaption>
最初の字lに先行する引用符も含められるベキである。
◎
Quotes that precede the first letter should be included.
</figcaption></figure>

<p>
`CSS-TEXT-3$r に説明されるように、`~typographic字l単位$は複数の ~Unicode符号位置を含み得る。
例えば，結合~文字たちは、それらの基底~文字とともに保たれるモノトスル。
また，一部の言語には、ある種の字lの組合nを扱う方法について，追加的な規則もある。
例えば~Dutchでは、要素の始めに 字lの組合n "ij" が現れる場合、両~字lとも `first-letter$pe 疑似要素の中にあると見なされるベキである。
`UAX29$r
~UAは、［
`first-letter$pe 疑似要素の `包含塊^emの内容~言語
］による最初の字lに対する慣習を反映するように，自身による`~typographic字l単位$の定義を誂えるベキである。
◎
As explained in [CSS-TEXT-3], a typographic letter unit can include more than one Unicode codepoint. For example, combining characters must be kept with their base character. Also, languages may have additional rules about how to treat certain letter combinations. In Dutch, for example, if the letter combination "ij" appears at the beginning of an element, both letters should be considered within the ::first-letter pseudo-element. [UAX29] The UA should tailor its definition of typographic letter unit to reflect the first-letter traditions of the ::first-letter pseudo-element’s containing block’s content language.
</p>

<p class="note">注記：
最初の `~typographic字l単位$は、数字にもなり得ることに注意
— 例： "<samp>67 億もの大金…</samp>" の "6" など。
◎
Note: Note that the first typographic letter unit may in fact be a digit, e.g., the “6” in “67 million dollars is a lot of money.”
</p>

<p>
`first-letter$pe 疑似要素を形成する文字たちが複数の要素にまたがる場合
— `&lt;p&gt;‘&lt;em&gt;T...^samp 内の `‘T^c など —
~UAは、この疑似要素を，片方だけまたは両方の要素から作成してもヨイし，単純に作成しないことにしてもヨイ。
加えて，塊の最初の字l（たち）が行lの始端に来ない場合（例えば，双方向-並替ngに因り）、~UAは，疑似要素（たち）を作成する必要はない。
◎
If the characters that would form the ::first-letter are not in the same element, such as ‘T in &lt;p&gt;‘&lt;em&gt;T..., the user agent may create a ::first-letter pseudo-element from one of the elements, both elements, or simply not create a pseudo-element. Additionally, if the first letter(s) of the block are not at the start of the line (for example due to bidirectional reordering), then the user agent need not create the pseudo-element(s).
</p>

<p>
`first-letter$pe 疑似要素は、 `first-line$pe 疑似要素があれば その中に包含され、したがって `first-line$pe から継承する。
◎
The ::first-letter pseudo-element is contained within any ::first-line pseudo-elements, and thus inherits from ::first-line.
</p>

			<section id="first-letter-application">
<h4 title="Finding the First Letter">2.2.1. 最初の字lの見出法</h4>

<p>
最初の字lは、`整形される最初の行l$に生じるモノトスル。
例えば，
`&lt;p&gt;&lt;br&gt;First...^samp
のような~HTML片の場合、最初の行lは字lを包含しないので， `first-letter$pe に合致するものはない。
特に、 "First" の "F" には合致しない。
◎
The first letter must occur on the first formatted line. For example, in this HTML fragment: &lt;p&gt;&lt;br&gt;First... the first line doesn’t contain any letters and ::first-letter doesn’t match anything. In particular, it does not match the “F” of “First”.
</p>

<p>
~CSSにおいては、 `first-letter$pe 疑似要素が適用されるのは，`塊~容器$に限られる。
<span class="note">
この仕様の将来~versionでは、この疑似要素を他の`表示-型$にも適用できるようにし得る。
</span>
`first-letter$pe 疑似要素は、［
~textを包含する ／
同じ~flow内にある~textを 包含している子孫がある
］ようなすべての要素に利用できる。
~UAは、［
`first-letter^pe 疑似要素の仮想の開始tagが要素の最初の~textの直前にある
］かのように動作するベキである
— その最初の~textが子孫~内にない場合でも。
◎
In CSS, the ::first-letter pseudo-element only applies to block containers. A future version of this specification may allow this pseudo-element to apply to more display types. The ::first-letter pseudo-element can be used with all such elements that contain text, or that have a descendant in the same flow that contains text. A user agent should act as if the fictional start tag of the ::first-letter pseudo-element is just before the first text of the element, even if that first text is in a descendant.
</p>

<div class="example">

<p>
例えば、次の~HTML片：
◎
Example: The fictional tag sequence for this HTML fragment:
</p>
<pre class="lang-html">
&lt;div&gt;
&lt;p&gt;~~最初の~text。
</pre>

<!-- 
<div>
<p>The first text.
-->

<p>
による`仮想の~tag列$は：
◎
is:
</p>

<pre class="lang-html">
&lt;div&gt;
&lt;p&gt;&lt;div::first-letter&gt;&lt;p::first-letter&gt;~~最&lt;/...&gt;&lt;/...&gt;~~初の~text。
</pre>

</div>

<p>
~CSSにおいては、
`table-cell$v ／ `inline-block$v
の最初の字lは、先祖~要素の最初の字lにはなれない。
したがって
`&lt;div&gt;&lt;p style="display: inline-block"&gt;Hello&lt;br&gt;Goodbye&lt;/p&gt; etcetera&lt;/div&gt;^samp
における `div^e の最初の字lは、字l "H" ではない。
~~実際、この `div^e に最初の字lはない。
要素が~list~itemである場合（
<span class="css">`display$p: `list-item$v</span>
）、 `first-letter$pe は，［
~markerの`後にある^em`首要~box$
］内の最初の字lに適用される。
~UAは、［
<span class="css">`list-style-position$p: `inside^v</span>
］にされている~list~item上の `first-letter$pe は無視してもヨイ。
要素に［
`before$pe ／ `after$pe
］内容もある場合、 `first-letter$pe は，その内容を`含んでいる^em要素の最初の字lに適用される。
◎
In CSS the first letter of a table-cell or inline-block cannot be the first letter of an ancestor element. Thus, in &lt;DIV&gt;&lt;P STYLE="display: inline-block"&gt;Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt; the first letter of the DIV is not the letter "H". In fact, the DIV doesn’t have a first letter. If an element is a list item (display: list-item), the ::first-letter applies to the first letter in the principal box after the marker. User-Agents may ignore ::first-letter on list items with list-style-position: inside. If an element has ::before or ::after content, the ::first-letter applies to the first letter of the element including that content.
</p>

<div class="example">

<p>
例えば、規則
`p::before {content: "Note: "}^css
の後
,
選択子 `p::first-letter^css は、 "Note" の "N" に合致する。
◎
Example: After the rule p::before {content: "Note: "}, the selector p::first-letter matches the "N" of "Note".
</p>

</div>



			</section>
			<section id="first-letter-styling">
<h4 title="Styling the ::first-letter Pseudo-element">2.2.2.  `first-letter^pe 疑似要素の~style付け</h4>

<p>
~CSSにおいては、`first-letter^pe 疑似要素は、`行内~level$の要素に類似する。
`first-letter$pe 疑似要素には、次の~propが適用される：
◎
In CSS a ::first-letter pseudo-element is similar to an inline-level element. The following properties that apply to ::first-letter pseudo-elements:
</p>

<ul>
	<li>
すべての~font~prop
`CSS-FONTS-3$r
◎
all font properties (see [CSS-FONTS-3])
</li>
	<li>
`color$p,
`opacity$p
~prop
`CSS-COLOR-3$r
◎
the color and opacity properties (see [CSS-COLOR-3])
</li>
	<li>
すべての背景~prop
`CSS-BACKGROUNDS-3$r
◎
all background properties (see [CSS-BACKGROUNDS-3])
</li>
	<li>
植字用~propのうち，行内~要素に適用されるもの
`CSS-TEXT-3$r
◎
any typesetting properties that apply to inline elements (see [CSS-TEXT-3])
</li>
	<li>
すべての~text装飾~prop
`CSS-TEXT-DECOR-3$r
◎
all text decoration properties (see [CSS-TEXT-DECOR-3])
</li>
	<li>
行内~layout~propのうち，行内~要素に適用されるもの
`CSS-INLINE-3$r
◎
any inline layout properties that apply to inline elements (see [CSS-INLINE-3])
</li>
	<li>
各種
~margin／~padding
~prop
`CSS2$r
◎
margin and padding properties (see [CSS2])
</li>
	<li>
各種~border~prop,
`box-shadow$p
`CSS-BACKGROUNDS-3$r ）
◎
border properties and box-shadow (see [CSS-BACKGROUNDS-3])
</li>
	<li>
その他、個々の仕様により、 `first-letter$pe に適用されるものと定義される~prop
◎
any other properties defined to apply to ::first-letter by their respective specifications
</li>
</ul>

<p>
~UAは、他の~propを適用してもヨイ。
◎
User agents may apply other properties as well.
</p>

<p class="note">注記：
~CSSの以前の~levelでは、~UAには、［
字lが成す図形に基づいて［
行l高, 縦幅＆横幅
］を選ぶこと ／
~font~sizeを近似すること ／
整形-時に ~glyph外形線を織り込むこと
］も許容されていた。
この可能性は、意図的に除去された
— 意図される利用事例（埋没~頭字）には拙い解決策であることが判明している上、相互運用能の問題ももたらすので。
◎
Note: In previous levels of CSS, User Agents were allowed to choose a line height, width and height based on the shape of the letter, approximate font sizes, or to take the glyph outline into account when formatting. This possibility has been intentionally removed, as it proved to be a poor solution for the intended use case (Drop Caps), yet caused interoperability problems.
</p>

<div class="example">

<p>
先頭字にアリな描画を，次の~CSS, ~HTML例に示す。
最初の字lの仮想の開始tagは `span^e の内側にあるため、最初の字lの `font-weight^p は，
`span^e と同じ `bold^v ではなく `normal^v になることに注意：
◎
Example: This CSS and HTML example shows a possible rendering of an initial cap. Note that the fictional start tag of the first letter is inside the span, and thus the font weight of the first letter is normal, not bold as the span:
</p>

<pre class="lang-html">
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p&gt;&lt;span&gt;Het hemelsche&lt;/span&gt; gerecht heeft zich ten lange lesten&lt;br&gt;
Erbarremt over my en mijn benaeuwde vesten&lt;br&gt;
En arme burgery, en op mijn volcx gebed&lt;br&gt;
En dagelix geschrey de bange stad ontzet.
</pre>

<figure>
<div style="line-height: 1.1;padding-top: 1em;" lang="nl">
<span style="font-weight: bold;"><span style="font-size:300%; line-height: 0.37;">H</span>et hemelsche</span> gerecht heeft zich ten lange lesten<br>
Erbarremt over my en mijn benaeuwde vesten<br>
En arme burgery, en op mijn volcx gebed<br>
En dagelix geschrey de bange stad ontzet.
</div>
<!-- initial-cap.png -->
<figcaption>
`first-letter^pe 疑似要素の効果
◎
Image illustrating the ::first-letter pseudo-element
</figcaption></figure>

</div>

<div class="example">

<p>
次の~CSS, ~HTMLは、 2 行lに~spanする埋没~頭字を~~作成することになる：
◎
The following CSS will make a drop cap initial letter span about two lines:
</p>

<pre class="lang-css">
p               { font-size: 12pt; line-height: 1.2 }
p::first-letter { font-size: 200%; font-weight: bold; float: left }
span            { text-transform: uppercase }
</pre>

<pre class="lang-html">
&lt;p&gt;&lt;span&gt;The first&lt;/span&gt; few words of an article in The Economist.&lt;/p&gt;
</pre>

<!-- 
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
 -->

<p>
この例は、次のように整形されるであろう：
◎
This example might be formatted as follows:
</p>

<figure>
<div style="width:8em; line-height: 1.2; border:thin solid silver;" lang="en-x-a0">
<span><span style="display:inline-block; float: left; font-size: 200%; vertical-align: top; line-height:1em">T</span><span style="vertical-align: top;">HE FIRST</span></span> few words of an article in The Economist.
</div>
<!-- first-letter.gif -->

<figcaption>
`first-letter^pe, `first-line^pe 疑似要素を組合せたときの効果
◎
Image illustrating the combined effect of the ::first-letter and ::first-line pseudo-elements
</figcaption></figure>

<p>
`仮想の~tag列$は：
◎
The fictional tag sequence is:
</p>

<pre class="lang-html">
&lt;p&gt;
  &lt;span&gt;
    &lt;p::first-letter&gt;
      T
    &lt;/p::first-letter&gt;he first
  &lt;/span&gt;
  few words of an article in the Economist.
&lt;/p&gt;
</pre>

<p>
`first-letter$pe 疑似要素~tagは，内容（すなわち，先頭字）を~~直に括る一方で、
`first-line^pe 疑似要素の開始tagは，塊~要素の開始tagの直後に挿入されることに注意。
◎
Note that the ::first-letter pseudo-element tags abut the content (i.e., the initial character), while the ::first-line pseudo-element start tag is inserted right after the start tag of the block element.
</p>

</div>

			</section>
		</section>
	</section>
	<section id="highlight-pseudos">
<h2 title="Highlight Pseudo-elements">3. 強調~用の疑似要素</h2>


		<section id="highlight-selectors">
<h3 title="Selecting Highlighted Content: the ::selection, ::inactive-selection, ::spelling-error, and ::grammar-error pseudo-elements">3.1. 強調された内容の選択-法： `selection^pe, `inactive-selection^pe, `spelling-error^pe, `grammar-error^pe 疑似要素</h3>

<p>
`強調~疑似要素@
は，文書~内で特定0の地位が与えられた部位を表現し、概して，その地位を利用者に指示するため異なる~styleがあてがわれる。
例えば，文書の選択された部位は、概して，それを表す地位を指示するよう強調される（代替する背景~色と前景~色, あるいは色~滲みが与えられる）。
`強調~疑似要素$として、以下に挙げるものが定義される：
◎
The highlight pseudo-elements represent portions of a document that have been given a particular status and are typically styled differently to indicate that status to the user. For example, selected portions of the document are typically highlighted (given alternate background and foreground colors, or a color wash) to indicate their selected status. The following highlight pseudo-elements are defined:
</p>

<dl>
	<dt>`selection@pe</dt>
	<dt>`inactive-selection@pe</dt>
	<dd>
これらの疑似要素は、未来にアリな~UAによる何らかの演算の対象として選定された，文書のある部位を表現する。
これらは例えば、［
~copy演算により複製されたり，~paste演算により置換されることになる
］ような，編集-可能な~text欄の中の選択された~textに適用される。
◎
The ::selection and ::inactive-selection pseudo-elements represent the portion of a document that has been selected as the target or object of some possible future user-agent operation(s). They apply, for example, to selected text within an editable text field, which would be copied by a copy operation or replaced by a paste operation.
</dd>
	<dd>
`selection$pe は，作動中の選択に適用される一方で、
`inactive-selection$pe は，作動中でない選択に適用される（例：
文書~windowは作動中でなく~eventを受取っていないとき）。
◎
::selection applies to active selections, whereas ::inactive-selection applies to inactive selections (e.g. when the document window is inactive and therefore not receiving events).
</dd>

	<dt>`spelling-error@pe</dt>
	<dd>
~UAにより綴りが誤っているとされた，~textの部位を表現する。
◎
The ::spelling-error pseudo-element represents a portion of text that has been flagged by the user agent as misspelled.
</dd>

	<dt>`grammar-error@pe</dt>
	<dd>
~UAにより文法的に不正とされた，~textの部位を表現する。
◎
The ::grammar-error pseudo-element represents a portion of text that has been flagged by the user agent as grammatically incorrect.
</dd>
</dl>

<p>
`強調~疑似要素$は、要素~treeの中に収まるとは限らず，入子ng構造を尊守せずに要素~境界を任意にまたがり得る。
◎
The highlight pseudo-elements do not necessarily fit into the element tree, and can arbitrarily cross element boundaries without honoring its nesting structure.
</p>

<p>
既定の~UA~stylesheetとして、次のものが追加される：
◎
The following addition is made to the default UA stylesheet:
</p>


<pre class="lang-css">
/* <span class="comment">
綴り, 文法の誤りに対する既定の~style付けを，調整-可能な仕方で表現する
◎
Represent default spelling/grammar error styling in an adjustable way
</span> */
:root::spelling-error { text-decoration-line: spelling-error; }
:root::grammar-error  { text-decoration-line: grammar-error; }
/* <span class="comment">
影を伴う~text上の~contrastを確保する
◎
Ensure contrast on text with shadows
</span> */
:root::selection      { text-shadow: none; }
</pre>

<p class="note">注記：
~CSSの将来~levelでは、~custom強調~疑似要素を作成する仕方も導入され得る。
◎
Note: A future level of CSS may introduce ways to create custom highlight pseudo-elements.
</p>

		</section>
		<section id="highlight-styling">
<h3 title="Styling Highlights">3.2. 強調の~style付け</h3>

<p>
`強調~疑似要素$を~styleできる~propは、~layoutに影響しないものに制限される。
【<a href="#highlight-security">~security, ~privacy上の考慮点</a>を見よ。】
次に挙げる~propは、強調~疑似要素に適用される：
◎
The highlight pseudo-elements can only be styled by a limited set of properties that do not affect layout. The following properties apply to the highlight pseudo-elements:
</p>

<ul>
	<li>
`color$p
</li>
	<li>
`background-color$p
</li>
	<li>
`cursor$p
</li>
	<li>
`caret-color$p
</li>
	<li>
`outline$p とその下位porp
◎
outline and its longhands
</li>
	<li>
`text-decoration$p とそれに結付けられた各種~prop
◎
text-decoration and its associated properties
</li>
	<li>
`text-shadow$p
</li>
	<li>
`stroke-color$p, `fill-color$p, `stroke-width$p
</li>
</ul>

<p class="issue">
ここに含められるべき~propは、他にもあるか？
◎
Are there any other properties that should be included here?
</p>

<p>
`color$p ~propは、次に挙げるものの色も指定する
⇒＃
~text,
~textに適用されているすべての行l装飾（下線, 上線, 取消線）,
［`出自の要素$, その先祖や子孫］により~textに適用される圏点（ `text-emphasis$p ）
◎
The color property specifies the color of both the text and all line decorations (underline, overline, line-through) and emphasis marks (text-emphasis) applied to the text by the originating element and its ancestors and descendants.
</p>

<p class="note">注記：
歴史的に，（これを書いている時点で）相互運用可能に~supportされているのは、
`color$p ／ `background-color$p
に限られている。
◎
Note: Historically (and at the time of writing) only color and background-color have been interoperably supported.
</p>

		</section>
		<section id="highlight-bounds">
<h3 title="Area of a Highlight">3.3. 強調を成す区画</h3>

<p>
<a href="#highlight-selectors">強調~用の疑似要素の各 型</a>
— `selection$pe, `inactive-selection$pe, `spelling-error$pe, `grammar-error$pe —
ごとに、文書~全体にわたる
`強調~overlay@
が存在し、その作動中の部位は，対応する`強調~疑似要素$により表現される。
◎
For each type of highlighting (see § 3.1 Selecting Highlighted Content: the ::selection, ::inactive-selection, ::spelling-error, and ::grammar-error pseudo-elements) there exists a single highlight overlay for the entire document, the active portions of which are represented by the corresponding highlight pseudo-element.＼
</p>

<p>
各`~box$は、自身が直に包含する［
~text／`置換され$る内容
］に対応する，~overlayの一部分を所有する：
◎
Each box owns the piece of the overlay corresponding to any text or replaced content directly contained by the box.
</p>

<ul>
	<li>
~textに対する~overlayは，少なくとも~em~box全体を覆うモノトスル。
また、~em~boxを行l~box辺まで更に上／下に拡張してもヨイ。
文字~間のアキもまた，~overlay区画の一部にしてもヨイ
— そのようなアキは、両側の文字とも包含するような要素のうち最も内縁のものに所属し，両~文字とも選択されたとき選択される。
◎
For text, the corresponding overlay must cover at least the entire em box and may extend further above/below the em box to the line box edges. Spacing between two characters may also be part of the overlay area, in which case it belongs to the innermost element that contains both characters and is selected when both characters are selected.
</li>
	<li>
`置換され$る内容に対する~overlayは、置換される~obj全体を覆うモノトスル。
また、要素の`内容~box$全体を含むように外方へ拡張してもヨイ。
◎
For replaced content, the associated overlay must cover at least the entire replaced object, and may extend outward to include the element’s entire content box.
</li>
	<li>
~overlayはまた、要素の`~border~box$の中の，他の区画を含んでもヨイ
— そのような区画は、区画を包含する要素のうち，最も内縁のものに所属する。
◎
The overlay may also include other other areas within the border-box of an element; in this case, those areas belong to the innermost such element that contains the area.
</li>
</ul>

<p class="issue">
次を見よ：
<a href="http://lists.w3.org/Archives/Public/www-style/2008Nov/0022.html">F2F minutes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2008Oct/0268.html">dbaron’s message</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0247.html">Daniel’s thread</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0261.html">Gecko notes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0366.html">Opera notes</a>,
<a href="http://lists.w3.org/Archives/Public/www-style/2010May/0280.html">Webkit notes</a>
◎
See F2F minutes, dbaron’s message, Daniel’s thread, Gecko notes, Opera notes, Webkit notes
</p>

<p class="issue">
これは、働き方を正しく述べているのか？
◎
Not sure if this is the correct way of describing the way things work.
</p>

		</section>
		<section id="highlight-cascade">
<h3 title="Cascading and Per-Element Highlight Styles">3.4. ~cascade法と要素ごとの強調~style</h3>

<p>
各~要素は、作動中の自前の部位に`強調~overlay$を描く
— それは、［
要素を`出自の要素$とする`強調~疑似要素$たち
］に指定された~styleを受取る。
複数の~styleが競合する場合、~cascadeの結果により決定される~styleが勝つ。
~supportされる~propに~cascadeから値が与えられていない場合、その値は，`出自の要素$の親~要素の対応する`強調~疑似要素$からの継承により決定される（当の~propが`継承d~prop$かどうかに関わらず）。
◎
Each element draws its own active portions of the highlight overlays, which receives the styles specified by the corresponding highlight pseudo-element styles for which that element is the originating element. When multiple styles conflict, the winning style is determined by the cascade. When any supported property is not given a value by the cascade, it’s value is determined by inheritance from the corresponding highlight pseudo-element of its originating element’s parent element (regardless of whether that property is an inherited property).
</p>

<div class="example">

<p>
例えば次の規則が：
◎
For example, if the following rules were applied:
</p>
<pre class="lang-css">
p::selection      { color: yellow; background: green; }
p &gt; em::selection { color: orange; }
em::selection     { color:    red; }
</pre>

<p>
次の~markupに適用されていた場合：
◎
to the following markup:
</p>

<pre class="lang-html">
&lt;p&gt;これと&lt;em&gt;これを&lt;/em&gt;強調します。&lt;/p&gt;
</pre>
<!-- 
<p>Highlight this <em>and this</em>.</p>
 -->
<p>
`selection$pe による背景の強調~色は全体が `green^v になり、
`em^e 要素の外側, 内側の~text色は，順に `yellow^v, `orange^v になる。
◎
The selection highlight would be green throughout, with yellow text outside the &lt;em&gt; element and orange text inside it.
</p>

</div>

<p class="advisement">
複数の選択~styleを求める作者は、文書~全体にわたる選択~style用に
`:root::selection^css を利用するベキである
— そうすれば、子孫において きれいに上書きできるようになるので。
`selection$pe だけだと，~tree内の各 要素に適用され、より特有な~styleが先祖にあっても，それを上書きすることになる。
◎
Authors wanting multiple selections styles should use :root::selection for their document-wide selection style, since this will allow clean overriding in descendants. ::selection alone applies to every element in the tree, overriding the more specific styles of any ancestors.
</p>

<div class="example">

<p>
例えば、作者が次を指定していて：
◎
For example, if an author specified
</p>
<pre class="lang-css">
::selection { background: blue; }
p.warning::selection { background: red; }
</pre>

<p>
文書が次を含んでいる場合：
◎
and the document included
</p>

<pre class="lang-html">
&lt;p class="warning"&gt;ある&lt;strong&gt;とても重要な情報&lt;/strong&gt;&lt;/p&gt;
</pre>
<!-- 
<p class="warning">Some <strong>very important information</strong></p>
 -->
<p>
"とても重要な情報" の強調は `blue^v になる
—  `strong^e 要素の `selection$pe は、 `::selection { background: blue; }^css 規則にも合致するので（型~選択子を欠くものは、暗黙の `*^css があることに注意）。
~style規則を次のように与えれば、意図される挙動（強調は `p.warning^css の中では `red^v, 他所では `blue^v ）になる：
◎
The highlight would be blue over “very important information” because the &lt;strong&gt; element´s ::selection also matches the ::selection { background: blue; } rule. (Remember that * is implied when a tag selector is missing.) The style rules that would give the intended behavior (red highlight within p.warning, blue elsewhere) are
</p>

<pre class="lang-css">
:root::selection { background: blue; }
p.warning::selection { background: red; }
</pre>

</div>

<p>
~UAは、作者が `color$p, `background-color$p とも指定していないときは，~OSに既定の強調~色を `selection$pe 用に利用するベキである。
◎
The UA should use the OS-default highlight colors for ::selection when neither color nor background-color has been specified by the author.
</p>

<p class="note">注記：
この，対にされて~cascadeする挙動は、~OSに既定の選択~色を，通常の~cascade（すなわち、~UA~stylesheetにおける `:root::selection^css 規則）を利用して表現できなくしている。
しかしながら，すでに~browser間で相互運用可能に実装されているので、おそらく~Web互換性の要件になる。
◎
Note: This paired-cascading behavior does not allow using the normal cascade (i.g. :root::selection rules in the UA style sheet) to represent the OS default selection colors. However it has been interoperably implemented in browsers and is thus probably a Web-compatibility requirement.
</p>

		</section>
		<section id="highlight-painting">
<h3 title="Painting the Highlight">3.5. 強調の塗法</h3>

<p>
各 `強調~疑似要素$は、対応する`強調~overlay$を成す部位の【利用者から見て】手前に, かつ
`有位置$な子孫（もしあれば）の直ぐ背後に，背景（ `background$p ）を描く（すなわち、
<a href="~TR/CSS21/zindex.html">CSS2.2 §E.2</a>
段 8 の直前）。
［
`selection$pe, `spelling-error$pe, `grammar-error$pe
］による~overlayは、先に挙げたものほど手前に描かれる。
◎
Each highlight pseudo-element draws its background over the corresponding portion of the highlight overlay, painting it immediately below any positioned descendants (i.e. just before step 8 in CSS2.2§E.2). The ::selection overlay is drawn over the ::spelling-error overlay which is drawn over the ::grammar-error overlay.
</p>

<p>
`強調~疑似要素$はまた、選択された~text（および，それに適用されている~text装飾）を描くのを抑止する。
代わりに，最も手前にある作動中の`強調~overlay$は、自前の `color$p を利用して，当の~text（および その装飾）を`強調~overlay$による背景の手前に描直す
— これらの `color^p に対する `currentcolor$v は、次の背後にある`強調~疑似要素$が成す層の `color$p を表現し，最終的には`出自の要素$に利用されることになる色に~fall-backする。
各`強調~疑似要素$により導入された~text装飾は、~textの元の装飾の手前に，それぞれの背景として同じ順序で積層され，それぞれの自前の色で描かれる。
◎
A highlight pseudo-element also suppresses the drawing of any selected text (and any text decorations applied to that text). Instead the topmost active highlight overlay redraws that text (and its decorations) over the highlight overlay backgrounds using its own color, with currentColor on its color property representing the color of the next highlight pseudo-element layer below, falling back finally to that of the originating element (the colors that would otherwise be used). Any text decorations introduced by each highlight pseudo-element are stacked in the same order as their backgrounds over the text’s original decorations and are all drawn, in their own colors.
</p>

<p class="note">注記：
したがって，要素の自前の~text装飾（
<a href="~CSSTEXTDECOR#line-decoration">行l装飾</a>,
<a href="~CSSTEXTDECOR#emphasis-marks">圏点</a>
の両者とも）は、当の疑似要素の自前の `color$p が `currentcolor$v でないならば，その色で描かれる
— 要素の元の［
色／~fill指定
］に関わらず。
◎
Note: The element’s own text decorations (both line decorations and emphasis marks) are thus drawn in the pseudo-element’s own color when that is not currentColor, regardless of their original color or fill specifications.
</p>

<p class="issue">
~text影には何が起こるべきか？
— それらを元の色で描くと、その色が灰色の濃淡でない場合，~~調和を乱す【なぜ灰色は除かれている？】。
~overlayに背景がある場合、その背後にある~text影は抑止するであろう？
◎
What should happen with text shadows? Drawing them in their original color is disconcerting if that color is not a shade of gray. Maybe if the overlay has a background, suppress any text shadows below it?
</p>

<p>
`置換され$ない内容に対しては、~UAは
`color$p, `background-color$p
の指定d値を（~alpha~channelも含め）尊守するモノトスル。
他方，`置換され$る内容に対しては、~UAは，内容が選択から透けて見えるような半透明な膜で~~覆うベキである。
この膜の色は、［
`background-color$p の指定d値が `transparent$v でなければそれ ／
他の場合は `color$p の指定d値
］になるベキである
— ~UAは、その~alpha~channelを調整してもヨイ。
◎
For non-replaced content, the UA must honor the color and background-color (including their alpha channels) as specified. However, for replaced content, the UA should create a semi-transparent wash to coat the content so that it can show through the selection. This wash should be of the specified background-color if that is not transparent, else of the specified color; however the UA may adjust the alpha channel.
</p>

		</section>
		<section id="highlight-security">
<h3 title="Security and Privacy Considerations">3.6. ~security, ~privacyの考慮点</h3>

<p>
綴りや文法の誤りに対する~style付けは、利用者の辞書の内容についての情報（利用者の名前や,  住所録の内容まで含み得る）を漏洩し得るので、
`spelling-error$pe ／ `grammar-error$pe
を実装する~UAは，そのような強調された区分の~style付けを~pageが読取れないよう防止するモノトスル。
【したがって、~layoutが変化するものなど，他の状態に影響して適用されたことが判別できる~styleは、適用されないことになる。】
◎
Because the styling of spelling and grammar errors can leak information about the contents of a user’s dictionary (which can include the user’s name and even includes the contents of his/her address book!) UAs that implement ::spelling-error and ::grammar-error must prevent pages from being able to read the styling of such highlighted segments.
</p>

		</section>
	</section>
	<section id="treelike">
<h2 title="Tree-Abiding Pseudo-elements">4. ~treeに留まる疑似要素</h2>

<p>
`~treeに留まる疑似要素@
は、常に`~box~tree$の中の ある~boxに対応する。
それは、`出自の要素$から`継承-$可能な~propすべてを継承する。
`継承-$可能でない~propは、通例通り，それぞれの`初期~値$をとる。
`CSS-CASCADE-4$r
◎
Tree-abiding pseudo-elements always fit within the box tree. They inherit any inheritable properties from their originating element; non-inheritable properties take their initial values as usual. [CSS-CASCADE-4]
</p>

		<section id="generated-content">
<h3 title="Generated Content Pseudo-elements: ::before and ::after">4.1.  生成d内容~疑似要素： `before^pe, `after^pe</h3>

<p>
`content$p の算出d値が `none$v でないときには、これらの疑似要素は，その`出自の要素$の直の子であったかのように†，~boxを生成し、文書~tree内にある通常の要素と同じ様に~styleできる。
◎
When their computed content value is not none, these pseudo-elements generate boxes as if they were immediate children of their originating element, and can be styled exactly like any normal document-sourced element in the document tree.
</p>

<p class="trans-note">【†
したがって、要素から~styleも継承することになる。
】</p>

<dl>
	<dt>`before@pe</dt>
	<dt>`after@pe</dt>
	<dd>
`出自の要素$の実際の内容の［
直前（ `before^pe ）／ 直後（ `after^pe ）
］にあって, `~box~tree$において要素の子になるような，~style可能な疑似要素を表現する。
◎
Represents a styleable child pseudo-element immediately before the originating element’s actual content.
◎
Represents a styleable child pseudo-element immediately after the originating element’s actual content.
</dd>
</dl>

<div class="example">

<p>
例えば次の規則は、
`class^a 属性~値が `note^v を含んでいる
各 `p^e 要素ごとに，その内容の前に文字列 "注記：" を挿入する：
◎
For example, the following rule inserts the string “Note: ” before the content of every &lt;p&gt; element whose class attribute has the value note:
</p>

<pre class="lang-css">
p.note::before { content: "注記：" }
</pre>
<!-- "Note: " -->

<p>
`display$p の初期~値は `inline$v なので、これは`行内~box$を生成することになる。
`p^e の他の行内~boxである子と同様に，それは
`p^e の行内~整形~文脈に関与し，他の内容と行lを共有し得ることになる。
◎
Since the initial value of display is inline, this will generate an inline box. Like other inline children of &lt;p&gt;, it will participate in &lt;p&gt;’s inline formatting context, potentially sharing a line with other content.
</p>

</div>

<p>
定例の要素の内容と同じく、［
`before$pe ／ `after$pe
］疑似要素を成す生成d内容は、その`出自の要素$に適用されている［
`first-line$pe や `first-letter$pe
］疑似要素があれば，それらの一部を形成し得る。
◎
As with the content of regular elements, the generated content of ::before and :after pseudo-elements can form part of any ::first-line and ::first-letter pseudo-elements applied to its originating element.
</p>

		</section>
		<section id="marker-pseudo">
<h3 title="List Markers: the ::marker pseudo-element">4.2.  ~list~marker：`marker^pe 疑似要素</h3>

<p>
`marker@pe
疑似要素は、`~list~item$用に自動的に生成される`~marker~box$を表現する。
`CSS-DISPLAY-3$r, `CSS-LISTS-3$r
を見よ。
◎
The ::marker pseudo-element represents the automatically generated marker box of a list item. (See [CSS-DISPLAY-3] and [CSS-LISTS-3].)
</p>

<p>
`marker$pe 疑似要素に利用できる~propは限られている。
その~listは、
`CSS-LISTS-3$r
<a href="~CSSLIST#marker-properties">§ `marker^pe に適用される~prop</a>
に定義される。
◎
Only a limited set of properties can be used on the ::marker pseudo-element. This list is defined in CSS Lists 3 §3.1.1 Properties Applying to ::marker.
</p>

		</section>
		<section id="placeholder-pseudo">
<h3 title="Placeholder Input: the ::placeholder pseudo-element">4.3. 仮入力： `placeholder^pe 疑似要素</h3>

<p>
`placeholder@pe
疑似要素は、~form入力~欄~内の仮入力（ `placeholder^en ）~textを表現する：
それは、当の欄の埋め方についての~hintを利用者に供するような，入力~textを表現する。
例えば日付~入力~欄の仮入力~textが
"<samp>YYYY/MM/DD</samp>"
であったなら、日付を与える数を［
年, 月, 日
］の順序で手入力することを明確化する。
◎
The ::placeholder pseudo-element represents placeholder text in an input field: text that represents the input and provides a hint to the user on how to fill out the form. For example, a date-input field might have the placeholder text “YYYY/MM/DD” to clarify that numeric dates are to be entered in year-month-day order.
</p>

<p class="note">注記：
`placeholder-shown$ps という`疑似類^emも存在する
— それは、仮入力~textを示している（~DOM内の）要素に適用され，そのような要素を特別に~styleするために利用できる。
`placeholder$pe は、特定的には，仮入力~text`自体^emを表現している疑似要素を選択する
— したがって，その能は他に比べ制限される。
◎
Note: There also exists a :placeholder-shown pseudo-class, which applies to (real) elements while they are showing placeholder text, and can be used to style such elements specially. ::placeholder specifically selects a pseudo-element representing the placeholder text, and is thus relatively limited in its abilities.
</p>

<p>
`first-line$pe 疑似要素に適用されるすべての~propは、
`placeholder$pe 疑似要素にも適用される。
◎
All properties that apply to the ::first-line pseudo-element also apply to the ::placeholder pseudo-element.
</p>

<p>
対話的~媒体においては、仮入力~textは，利用者が入力~欄に手入力し始めたときに隠されることが多い。
しかしながら，これは、要件ではなく，入力~値と仮入力の両~textとも同時に可視にしてもヨイ。
正確な挙動は~UAにより定義されることに注意。
静的~媒体（印刷など）においては、仮入力~textは，利用者が入力を手入力した後でも呈示することになる。
◎
In interactive media, placeholder text is often hidden once the user has entered input; however this is not a requirement, and both the input value and the placeholder text may be visible simultaneously. The exact behavior is UA-defined. Note that in static media (such as print) placeholder text will be present even after the user has entered input.
</p>

<p class="issue">
~supportされる~propとして `text-align$p も含めるよう，求めている作者も見受けられる。
例えば
<a href="http://css-tricks.com/almanac/selectors/p/placeholder/">ここの~comment</a>
を見よ。
◎
Authors seem to want text-align on the list of supported properties. See e.g. comments here.
</p>

<p class="note">注記：
`placeholder$pe は、［
対応している要素が要素~tree内にある仮入力
］も指せるようにすることが，要請されている。
これがどう働くべきかは明瞭でないが、そうするに価するかもしれない。
`2517$issue
を見よ。
<!-- 2417誤記 -->
◎
Note: It’s been requested that ::placeholder also refer to a placeholder which has a corresponding element in the element tree. It’s not clear how this should work, but it may be worth doing. See Issue 2417.
</p>

		</section>
	</section>
	<section id="interactions">
<h2 title="Overlapping Pseudo-element Interactions">5. 重合している疑似要素~間の相互作用</h2>

<div class="example" id="overlapping-example">
<p>
次のことを~~念頭に：
◎
Recall that
</p>

<ul>
	<li>
`before$pe ／ `after$pe
を成す内容は、文書~tree内にある通常の要素であったかのように選択される。
◎
the contents of ::before and ::after are selected exactly as if they were normal elements in the document source tree
</li>
	<li>
`first-letter$pe は、`整形される最初の行l$上にしか存在できないよう拘束され、それを成す最初の字lに~~後続する~textは， `first-letter$pe の境界を すき間なく回込む。
◎
the ::first-letter boundaries are tightly wrapped around the first letter text, and ::first-letter is constrained to exist solely on the first formatted line.
</li>
	<li>
`first-line$pe の［
始端は 包含塊を与える要素の境界のすぐ内側／
終端は 行l上のすべての内容を閉じた後
］に挿入される。
◎
the ::first-line start is inserted just inside the containing block’s element boundary, and its end after the close of all content on the line
</li>
</ul>

<p>
重合している疑似要素がどう相互作用するかを、次の~CSS, ~HTMLに例示する。
◎
The following CSS and HTML example illustrates how overlapping pseudo-elements interact:
</p>

<pre class="lang-html">
&lt;style&gt;
p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }
&lt;/style&gt;

&lt;p&gt;この~textは、 1 行lに収まらない。&lt;/p&gt;
</pre>
<!-- 
&lt;p&gt;Some text that ends up on two lines&lt;/p&gt;
-->
<p>
各 `p^e 要素の最初の字lは、色は `green^v, ~font~sizeは `24pt^v になる。
残りのうち、`整形される最初の行l$を成す部分は `blue^v になり，その他の段落を成す部分は `red^v になる。
◎
The first letter of each P element will be green with a font size of ’24pt'. The rest of the first formatted line will be blue while the rest of the paragraph will be red.
</p>

<p>
単語 "収まらない" の直前で 行lが分断されるとするとき、この片に対する`仮想の~tag列$は、次のようになるであろう：
◎
Assuming that a line break will occur before the word "ends", the fictional tag sequence for this fragment might be:
</p>

<pre class="lang-html">
&lt;p&gt;
  &lt;p::first-line&gt;
    &lt;p::first-letter&gt;
      こ
    &lt;/p::first-letter&gt;
    の~textは、1 行lに
  &lt;/p::first-line&gt;
  収まらない。
&lt;/p&gt;
</pre>

</div>


	</section>
	<section id="cssom">
<h2 title="Additions to the CSS Object Model">6. ~CSS~obj~modelへの追加</h2>

		<section id="CSSPseudoElement-interface">
<h3 title="Interface CSSPseudoElement">6.1. ~interface `CSSPseudoElement^I</h3>

<p>
`CSSPseudoElement^I ~interfaceは、疑似要素も~event~targetになれるようにする。
◎
The CSSPseudoElement interface allows pseudo-elements to be event targets.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPseudoElement@I : `EventTarget$I {
    readonly attribute `CSSOMString$ `type$m;
    readonly attribute `Element$I `element$m;
};
</pre>

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
<p>
疑似要素の型を表現する文字列を返す。
とり得る値は：
◎
The type attribute is a string representing the type of the pseudo-element. This can be one of the following values:
</p>
		<dl>
			<dt>`::before^l</dt>
			<dd>
`before$pe 疑似要素を表現する。
◎
Represents the ::before pseudo-element.
</dd>

			<dt>`::after^l</dt>
			<dd>
`after$pe 疑似要素を表現する。
◎
Represents the ::after pseudo-element.
</dd>

			<dt>`::marker^l</dt>
			<dd>
`marker$pe 疑似要素を表現する。
◎
Represents the ::marker pseudo-element.
</dd>
		</dl>
	</dd>

	<dt>`element@m</dt>
	<dd>
この疑似要素の`出自の要素$を返す。
◎
The element attribute is the originating element of the pseudo-element.
</dd>
</dl>

<p class="note">注記：
この~interfaceは、将来には拡張され得る
— 他の型の疑似要素にまで, および `CSSStyleDeclaration$I の `style^m 属性を通して~style情報を設定できるように。
現在の機能性は、 `web-animations-1$r ~supportするために必要なものに制限されている。
◎
Note: This interface may be extended in the future to other pseudo-element types and/or to allow setting style information through a CSSStyleDeclaration style attribute. The current functionality is limited to that which is needed to support [web-animations-1].
</p>

		</section>
		<section id="window-interface">
<h3 title="pseudo() method of the Element interface">6.2. `Element^I ~interface上の `pseudo()^m ~method</h3>

<p>
`Element$I ~interfaceには、所与の要素により作成された所与の型の疑似要素を検索取得するための，新たな~methodが追加される：
◎
A new method is added to the Element interface to retrieve pseudo-elements created by a given element for a given type:
</p>


<pre class="idl">
partial interface `Element$I {
  `CSSPseudoElement$I? `pseudo$m(`CSSOMString$ %type);
};
</pre>

<dl class="idl-def">
	<dt>`pseudo(type)@m</dt>
	<dd>
この要素を`出自の要素$とする `CSSPseudoElement$I ~instanceのうち［
`type$m が %type に合致しているもの
］を検索取得するために利用される。
◎
The pseudo(CSSOMString type) method is used to retrieve the CSSPseudoElement instance of the type matching type associated with the element.＼
</dd>
	<dd>
<p>
被呼出時には、次を走らす：
◎
When it is called, execute the following steps:
</p>
		<ol>
			<li>
%type ~SET %type 引数を `pseudo-element-selector$t の`文法に則って構文解析-$した結果
◎
Parse the type argument as a &lt;pseudo-element-selector&gt;, and let type be the result.
</li>
			<li>
~IF［
%type ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If type is failure, return null.
</li>
			<li>
~RET ［
此れを`出自の要素$とする疑似要素のうち，選択子 %type に合致するもの
］を表現している `CSSPseudoElement$I ~obj†
◎
Otherwise, return the CSSPseudoElement object representing the pseudo-element that would match the selector type with this as its originating element.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【†
そのような疑似要素が実際に生成されていなくとも，それを表現する~objは在ると見なされることになる。
しかしながら、例えば `::unknown^l が引数に渡されたときも `CSSPseudoElement^I ~objを返すことになるが，その `type$m 属性がとれる値は限られている（関係する詳細は下に挙げる課題に）。
】</dd>
	<dd>
同じ`出自の要素$上の同じ`疑似要素$を表現するものとして返す値は、観測-可能になる限り，常に同じ `CSSPseudoElement$I ~objにするモノトスル（観測-可能にならない場合、~UAは
— 自身の都合や処理能のためとして —
この~objを［
落として／生成し直して
］もヨイ）。
◎
Return values that represent the same pseudo-element on the same originating element must be, insofar as observable, always the same CSSPseudoElement object. (The UA may drop or regenerate the object for convenience or performance if this is not observable.)
</dd>
	<dd class="issue">
`pseudo()$m ~methodが返す値の［
同一性, 存続期間, ~NULL性
］（および，~errorなり得る事例）は、依然として論の最中にある。
`3607$issue,
`3603$issue
を見よ。
◎
The identity, lifetime, and nullness of the return value (and potential error cases) of the pseudo() method is still under discussion. See Issue 3607 and Issue 3603.
</dd>
</dl>

		</section>
	</section>
	<section id="css2-compat">
<h2 title="Compatibilitiy Syntax">7. 互換性~構文</h2>

<p>
`CSS2$r 向けに書かれた既存の~stylesheetとの互換性を得るため、~UAは［
`before$pe ／ `after$pe ／ `first-letter$pe ／ `first-line$pe
］疑似要素~用には，以前の~colon 1 個の記法（
`before^ps ／ `after^ps ／ `first-letter^ps ／ `first-line^ps
）も受容するモノトスル。
◎
For compatibility with existing style sheets written against CSS Level 2 [CSS2], user agents must also accept the previous one-colon notation (:before, :after, :first-letter, :first-line) for the ::before, ::after, ::first-letter, and ::first-line pseudo-elements.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt>
<a href="~TR/2019/WD-css-pseudo-4-20190225/">2019年 2月 25日 作業草案</a>
からの変更点
◎
Changes since the 25 February 2019 Working Draft include:
</dt>
	<dd>
`CSSPseudoElement$I ~interface用に許容される型として
`marker$pe を追加した。
◎
Added ::marker to types allowed for CSSPseudoElement interface.
</dd>
	<dd>
`pseudo()$m が返す値を明確化した。
◎
Clarified return value of pseudo().
</dd>
	<dd>
`marker$pe に許容される~propとして
`content$p,
`unicode-bidi$p,
`direction$p
を追加した。
◎
Added content, unicode-bidi, and direction to properties allowed on ::marker.
</dd>
	<dd>
`first-line$pe に許容される~propとして
— `text-emphasis-position$p と相似的になるよう —
`ruby-position$p を追加した。
（ `2998$issue ）
◎
Added ruby-position to properties allowed on ::first-line, analogous with text-emphasis-position. (Issue 2998)
</dd>

	<dt>
<a href="~TR/2016/WD-css-pseudo-4-20160607/">2016 年 6月 7日 作業草案</a>
からの変更点
◎
Changes since the 7 June 2016 Working Draft include:
</dt>
	<dd>
~UA~stylesheetにて，［
`spelling-error$pe ／ `grammar-error$pe
］に［
`spelling-error$v ／ `grammar-error$v
］を指定した。
◎
Specified spelling-error and grammar-error with ::spelling-error and ::grammar-error in the UA stylesheet.
</dd>
	<dd>
親, 子の強調~疑似要素の間の値の伝播を，~cascade法ではなく継承を利用するよう定義し直した。
`2474$issue, そこからの~linkにおける論点を見よ。
◎
Redefined value propagation between parent/child highlight pseudo-elements to use inheritance rather than cascading. See discussion in and linked from Issue 2474.
</dd>
	<dd>
強調~疑似要素 用に~supportされる~propの~listを精緻化した
— 例：
`stroke-color$p, `fill-color$p を追加して， `outline$p を除去した, 等々。
◎
Refined list of supported properties for highlight pseudo-elements, e.g. adding stroke-color/fill-color, removing outline, etc.
</dd>
	<dd>
強調~疑似要素 用の［
~text, ~text装飾
］の色がどう塗られるかを，明確化した。
◎
Clarified how text and text decoration colors are painted for highlight pseudo-elements.
</dd>
	<dd>
`CSSPseudoElement$I ~interfaceに `element$m 属性を追加した。
◎
Added the element attribute to the CSSPseudoElement interface.
</dd>
	<dd>
`CSSPseudoElement$I ~interface上の `type$m 属性がとる値たちを，対応する疑似要素に合致するように変更した。
◎
Changed the values of the type attribute on the CSSPseudoElement interface to match the corresponding pseudo-elements.
</dd>
	<dd>
~supportされる `CSSPseudoElement$I の型を抑制し、実装されてない `style^m 属性は除去した。
◎
Reduced supported types of CSSPseudoElement and removed unimplemented style attribute.
</dd>
	<dd>
`window.getPseudoElements(elem,type)^m を `Element.pseudo(type)^m に変更した。
◎
Changed window.getPseudoElements(elem,type) to Element.pseudo(type).
</dd>
	<dd>
諸々の小さな明確化と修正点。
◎
Miscellaneous minor clarifications and fixes.
</dd>
</dl>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の構想, 開発, 考査の過程に貢献された次の方々に：
</p>

<p lang="en-x-a0">
The editors would like to thank the following individuals for their contributions, either during the conception of the specification or during its development and specification review process: Tab Atkins, David Baron, Razvan Caliman, Chris Coyier, Anders Grimsrud, Vincent Hardy.
</p>

	</section>
</main></div>
