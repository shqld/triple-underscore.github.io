<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Spatial Navigation Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<style>
.key {
	padding:0 0.2em;
	color: black;
	border-radius: 3px;
	background-color: #B0E0E6;
}

/* event 定義表 */

tr {
	border-top: 1px solid silver;
}

table.eventdef {
	border-spacing: 0px;
	background-color: hsl(300, 50%, 95% );
	border-left: 0.5em solid;
}

table.eventdef {
	border-left-color: hsl(300, 70%, 80% )
}

table.eventdef tr,
table.eventdef td {
	border-top-color: hsl(300, 50%, 85% );
}

table.eventdef th {
	white-space: nowrap;
}

table.eventdef td {
	min-width: 12em;
	border-left: 1px solid hsl(300, 50%, 85% );
}


#_ex-TV-program table {
	border-collapse: collapse;
	border: solid black 1px;
}
#_ex-TV-program td,
#_ex-TV-program th {
	border: solid black 1px;
	width: 2em;
	text-align: center;
	white-space: nowrap;
}

#_ex-TV-program {
	display: flex;
}
#_ex-TV-program > button {
	align-self: center;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	const source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'vt':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'ft':
	text = `&lt;<code class="func">${key}()</code>&gt;`;
	klass='f';
	break;
case 'mC':
	text = 'Constructor'
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`
	break;
case 'kY': // key event .key value
	href = `~UIEVENTS-KEY#key-${key}`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `issue#${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}


</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Scrollbars Module Level 1
spec_date:2019-05-08
trans_update:2019-05-09
	source_checked:
page_state_key:CSS
original_url:https://drafts.csswg.org/css-nav-1/
	abbr_url:CSSNAV
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
conformance:css
copyright:2019,permissive
trans_1st_pub:2019-04-23

●●class_map
p:property
css:css
e:element
a:attr
et:event-type
v:value
t:type
vt:type
kY:key


●●tag_map
p:code
t:var
vt:var
css:code
e:code
a:code
et:code
v:code
I:code
m:code
mC:code
c:code
kY:code
nEI:code
mSO:code
i:i
em:em

●●original_id_map


●●link_map

	●idl
Exposed:~WEBIDL#Exposed
DOMString:~WEBIDL#idl-DOMString

I.FocusableAreaSearchMode:#enumdef-focusableareasearchmode
I.FocusableAreasOption:#dictdef-focusableareasoption
I.NavigationEvent:#navigationevent
I.NavigationEventInit:#dictdef-navigationeventinit
I.SpatialNavigationDirection:#enumdef-spatialnavigationdirection
I.SpatialNavigationSearchOptions:#dictdef-spatialnavigationsearchoptions

I.Document:~DOM4#concept-document
I.Element:~DOM4#element
I.EventTarget:~DOM4#eventtarget
	~node:~DOM4#boundary-point-node
I.Node:~DOM4#node
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.UIEvent:~UIEVENTS#uievent
I.UIEventInit:~UIEVENTS#dictdef-uieventinit
I.Window:~WINDOW#window

l.up:#dom-spatialnavigationdirection-up
l.down:#dom-spatialnavigationdirection-down
l.left:#dom-spatialnavigationdirection-left
l.right:#dom-spatialnavigationdirection-right

l.visible:#dom-focusableareasearchmode-visible
l.all:#dom-focusableareasearchmode-all

m.focus:~HTMLinteraction#dom-focus
m.key:~UIEVENTS#dom-keyboardevent-key
m.preventDefault:~DOM4#dom-event-preventdefault

m.navigate:#dom-window-navigate
m.getSpatialNavigationContainer:#dom-element-getspatialnavigationcontainer
m.focusableAreas:#dom-element-focusableareas
m.spatialNavigationSearch:#dom-element-spatialnavigationsearch

mC.NavigationEvent:#dom-navigationevent-navigationevent
m.relatedTarget:#dom-navigationevent-relatedtarget
m.dir:#dom-navigationevent-dir

m.mode:#dom-focusableareasoption-mode

mSO.dir:#dom-spatialnavigationsearchoptions-dir
mSO.candidates:#dom-spatialnavigationsearchoptions-candidates
mSO.container:#dom-spatialnavigationsearchoptions-container

nEI.relatedTarget:#dom-navigationeventinit-relatedtarget
nEI.dir:#dom-navigationeventinit-dir


	%:#dom-window-navigate-dir-dir
	%:#dom-element-focusableareas-option-option
	%:#dom-element-spatialnavigationsearch-options-options
	%:#dom-navigationevent-navigationevent-type-eventinitdict-type
	%:#dom-navigationevent-navigationevent-type-eventinitdict-eventinitdict

	●a

a.tabindex:~HTMLinteraction#attr-tabindex
a.inert:https://github.com/WICG/inert
	不活:#inert

	●p
p.spatial-navigation-contain:#propdef-spatial-navigation-contain
p.spatial-navigation-action:#propdef-spatial-navigation-action
p.overscroll-behavior:~CSSOVERSCROLL#propdef-overscroll-behavior

	p.all:~CASCADE#propdef-all
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y

	●v
	v.auto:#valdef-spatial-navigation-contain-auto
v.contain:#valdef-spatial-navigation-contain-contain

v.auto:#valdef-spatial-navigation-action-auto
v.focus:#valdef-spatial-navigation-action-focus
v.scroll:#valdef-spatial-navigation-action-scroll

v.hidden:~CSSOVERFLOW3#valdef-overflow-hidden
v.mandatory:~CSSSCROLLSNAP#valdef-scroll-snap-type-mandatory

	●et
et.navbeforefocus:#eventdef-navigationevent-navbeforefocus
et.navnotarget:#eventdef-navigationevent-navnotarget
et.keydown:~UIEVENTS#keydown
et.focusin:~UIEVENTS#focusin
et.focus:~UIEVENTS#focus

	●用語
空間的~navi:#spatial-navigation
~risk下:#at-risk
境界~box:#boundary-box
手動で~scrollできる:#can-be-manually-scrolled
要素をある方向へ~scrollする:#directionally-scroll-an-element
要素の中で~focus可能な区画を見出す:#find-focusable-areas
最短~距離を見出す:#find-the-shortest-distance
l.navigation-override:#navigation-override
~navi上書き:#navigation-override
最良の候補を選定する:#select-the-best-candidate
空間的~navi容器:#spatial-navigation-containers
空間的~navi始点:#spatial-navigation-starting-point
空間的~navi手続き:#spatial-navigation-steps


	●§
	§:#overview
	§:#js-api
	§:#events-navigationevent
	§:#events-nav-type
	§:#processing-model
	§:#grouping
§ ~navi:#nav
	§:#declarative
	§:#container

	●他
拡張-可能な~Web:https://github.com/extensibleweb/manifesto
	Extensible Web:https://github.com/extensibleweb/manifesto
	:https://wicg.github.io/spatial-navigation/tests/ux/list.html
	old WICD Spec:https://www.w3.org/TR/WICD/#focus-handling
	:https://github.com/WICG/overscroll-behavior

	●用語 css
留め位置:~CSSSCROLLSNAP#scroll-snap-position

	すべての要素:https://drafts.csswg.org/css-pseudo/#generated-content
~border~box:~CSSBOX#border-box
	~border~box:~CSS2BOX#x14
~box断片:~CSSBREAK#box-fragment
~box:~CSSDISP#css-box
最適な~view用~領域:~CSSSCROLLSNAP#optimal-viewing-region
~CSS塗ng順序:~CSS22/zindex.html#painting-order
首要~box:~CSSDISP#principal-box
相対~位置決め:~CSSPOS#relative-position
要素を~scrollする:~CSSOMVIEW#scroll-an-element
~scroll境界:~CSSOVERSCROLL#scroll-boundary
~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport

	●用語 HTML
a.tabindex:~HTMLinteraction#attr-tabindex

作動中の文書:~BROWSERS#active-document
属する閲覧文脈:~BROWSERS#concept-document-bc
入子にしている閲覧文脈~容器:~BROWSERS#nested-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈:~BROWSERS#browsing-context
	HTML~Standard~§attr-tabindex:~HTMLLS/#attr-tabindex
入子の閲覧文脈:~BROWSERS#nested-browsing-context
生成元:~ORIGIN#concept-origin
~body要素:~HTMLdom#the-body-element-2
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

~DOM~anchor:~HTMLinteraction#dom-anchor
~tabindex値:~HTMLinteraction#_focusable-area-tabindex-value

~top-level閲覧文脈の現在の被focus区画:~HTMLinteraction#currently-focused-area-of-a-top-level-browsing-context
~focus可能な区画:~HTMLinteraction#focusable-area
~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~navi順序:~HTMLinteraction#sequential-focus-navigation-order
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point

	●用語 infra
	~Assert:~INFRA#assert
~clone:~INFRA#list-clone
空:~INFRA#list-is-empty
~size:~INFRA#list-size
除去する:~INFRA#list-remove
set.置換する:~INFRA#set-replace
有順序~集合:~INFRA#ordered-set


	●用語 DOM
取消d~flag:~DOM4#canceled-flag
文書~要素:~DOM4#document-element
文書:~DOM4#concept-document
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
~node:~DOM4#boundary-point-node

	●用語 他
featu
既定の許容list:~FEATUREPOLICY#default-allowlist
文書~内の特能は生成元~用に可能化されるか？:~FEATUREPOLICY#is-feature-enabled
可能化されて:~FEATUREPOLICY#is-feature-enabled
施策により制御される特能:~FEATUREPOLICY#policy-controlled-feature

~event序列:~UIEVENTS#event-order


●●words_table1

CSSOVERSCROLL:css-overscroll-behavior-ja.html
	https://drafts.csswg.org/css-overscroll-behavior-1/
UIEVENTS-KEY:uievents-key-ja.html


●●words_table

	●幾何
空間:space::~
空間的:spatial::~
境界:boundary::~
限界:bounding::~
offset:::オフセット
中心:center:~
形状付け:shaping:~
幾何-:geometric:~
	幾何-:geometrical
幾何的:geometric:~
垂直:perpendicular:~
point::点
変形n:transformation:変形
面積:area:~
重合する:overlapする:重なり合う
重合しな:overlapしな:重なり合わな
長さ:length:~
隅:corner:~
距離:distance:~
横幅:width:~
縦幅:height:~
横方向:horizontal:~
縦方向:vertical:~
横:horizontal:~
縦:vertical:~
軸:axis:~
	各~辺が軸に平行な／限界~boxの各~辺は軸に平行:axis-aligned
辺:edge:~
上端:top:~
下端:bottom:~
右端:right:~
	右:right
左端:left:~
閉半平面:closed half plane:閉じた半平面
始点:starting point:~
起点:origin:~
領域:region:~
平方根:square root:~
射影:projection:~
度合い:degree:~
直交する:orthogonalな:~
直交-:orthogonal:~
重み:weight:~
転移:displacement:~
偏り:bias:~
euclidean:::ユークリッド
位置:position:~
位置決め:positioning:~
	x
	y

	●layout
layout:::レイアウト
border:::ボーダー
box:::ボックス
配列-:arrange::~
配置-:place:~
整列-:align::~
整列:alignment::~
格子:grid::~:グリッド
	格子~状の:grid-like
一次元的:linear::~
	およそ一次元的でない:predominantly non linear
	上層にある:higher

	●nav
方向:direction::~
	ある方向へ:directionally／:directional
	ある方向へ
	方向を表す:directional
区画:area::~
移動-:move::~
	移動-:moving
動き:movement:~
転送-:transfer::~
探索-:search::~
探索:search::~
候補:candidate:~
基準:reference:~
loop:::ループ
	~loopして戻る:loop-back
down:下
	外:out
	下に:under
留め:snap::~:スナップ
留めら:snap さ::~:スナップさ
スカスカ:quite sparse:~
見出す:findする:~
見出した:findした:~
見出せな:findできな:~
見出して:findして:~
見出され:findされ:~
側:side:~
内側:inside:~
外側:outside:~

	反対:opposite
	~~反対:the other
	最も近い:nearest
	最も近い:closest
	近く:closely
	より近い:closer
	探して:looking for
	一部でも入らない:at least partly within
	巡って:around
	上下左右:4-way
	に来てはいない:not at
	来る:come
	行く／通る:goes／:going
	遡る:climb
	遡る:going up
	遡って:up
	優先度を下げる:down-prioritize
	最優先:at first
	優先的に:prioritize
	優先度:priority:~
	し切った:maximum
	~~現れ:uncover
	遮られ:obscure され
	隠れて:hidden

	●UI

UI:
anchor:::アンカー
browser:::ブラウザ
button:::ボタン
remote-control:remote control::リモコン
scroller:::スクローラ
	~scroll容器:scroller
scrollport:::スクロール域
矢印:arrow:~
key:::キー
	十字キー:D-pad／:directional pad
修飾key:modifier key::修飾キー
control:コントロール
controller:::コントローラ
mouse:::マウス
navi:navigation::ナビ
navigate:::ナビゲート
desktop:::デスクトップ
game:::ゲーム
	~game用:gaming
host:::ホスト
scroll:::スクロール
	scroll可能:scrollable
scrolling:::スクロール処理
caret:::キャレット
keyboard:::キーボード
focus:::フォーカス
被focus:focused::被フォーカス
	focusされ:focused
	focus可能な:focusable
click:::クリック
	~click可能:clickable
pressする::押す
pressして::押して
pressした::押した
pressされ::押され
screen:::スクリーン
	~screen上の:on-screen
ヤリトリ:interaction::やりとり
最良の:best な:~
操作o:operate:操作
逐次的:sequential::~
頁:page::ページ
feature-phone:feature phone::スマホ
機器:device:~
写真展示:photo gallery:~

可視:visible::~
不可視:invisible::~
表示域:viewport::~:ビューポート
外見的:apparent:~
	前週:previous week
	次週:next week

	●構造
level:::レベル
list:::リスト
item:::アイテム
top-level:::トップレベル
node:::ノード
obj:object::オブジェクト
group:::グループ
	~group化:grouping
body:
内容:content::~
包含-:contain::~
容器:container::コンテナ
子孫:descendant::~
空:empty::~
順序:order::~
序列:order::~
有順序:ordered::~
連列:sequence::~
連鎖:chain::~
木:tree::~
根:root::~
組合わせ:combination:組み合せ
要素:element::~
下層の:underlying:~
先祖:ancestor::~
先祖上の:ancestry::~
入子の:nested::入れ子の
入子に:nest::入れ子に
集合:set::~
下位集合:subset::~
	下位集合~化:sub-setting
文書:document::~

	●処理／IDL
被呼出時:被 invoke 時:~
	被呼出時:called
構築子:constructor::~:コンストラクタ
例外:exception:~
可能化-:enable:~
不能化-:disable:~
event:::イベント
flag:::フラグ
algo:algorithm::アルゴリズム
call:
処理-:process:~
処理:processing:~
手続き:steps:~
段:step:~
呼出さな:invoke しな:呼び出さな
入力:input:~
実行-:execute:~
遂行-:perform:~
返す:returnする:~
走らす:run する:~
走らせ:run し:~
再開-:resume:~
中断-:interrupt:~
再帰的:recursive:~
	再帰的に:recursively
初期:initial:~
	初期~時には:initially
初期化:initialize:~
取得-:get::~
設定-:set::~
未設定:unset::~
	ε に設定する:unset
	同じ値に設定する:not be set differently
設定ng:setting::設定
置換-:replace::~
挿入:insertion::~
作成-:create::~
	作成-法:creating
失敗-:fail::~
型:type::~
引数:argument:~
非同期的:asynchronous::~
演算:operation:~
浮上:bubble::~
発火-:fire::~
発火:firing::~
取消-:cancel::取り消::キャンセル
取消:cancel::取り消し::キャンセル
取消す:cancelする::取り消す::キャンセルする
取消d:canceld::取消
	取消~可能:cancellable
受取っ:receiveし:受け取っ
受取る:receiveする:受け取る
送信-:send::~
評価-:evaluate:~
繰返す:repeatする:繰り返す
作動化-:activate::~:アクティブ化
作動中の:active::~:アクティブな
動作:action::~:アクション
反応:reaction::~:リアクション

	%可視のみ:visibleOnly
	%探索~起点:searchOrigin
	%~focus可能~集合:focusables
	%可視~集合:visibles
	%最良の候補:bestCandidate
	%候補たち:candidates
	%内側~区画:insideArea
	%区画たち:areas
	%方向:dir
	%~anchorたち:anchors
	%要素:e
	%方向:d
	%距離:d
	%基準:reference
	%~event標的:eventTarget
	%内側にあるもの:insiders
	%最も近いものたち:closest subset
	%転移:displacement
	%~euclidean距離:euclidean
	%直交-偏り:orthogonalBias
	%直交-重み:orthogonalWeight
	%整列-偏り:alignBias
	%整列-重み:alignWeight
	%射影が重合する長さ:projectedOverlap
	%重合する面積の平方根:sqrt(Overlap)

	-:Else, fallback to the next step.
	項:term
	渡して:pass して:~

	●CSS
塗ng:painting:塗り
graphic:::グラフィック
	~graphic的:graphical
適用対象:applies to:~
継承-:inherit::~
百分率:percentage::~
受容-:accept:~
正準的:canonical::~
文法:grammar::~
animation:::アニメーション
離散的:discrete::~
首要:principal::主要


	●保安
許容list:allowlist::許容リスト
privacy:::プライバシー
security:::セキュリティ
生成元:origin::~:オリジン
施策:policy::~:ポリシー
特能:feature::~
悪意的:malicious:~
攻撃:attack:~
敵対的:hostile:~
	~~無為にする:lost cause
	~~価値はある:worthwhile
乗取る:highjackする:乗っ取る
自己考査:self-review:~
干渉-:interfere:~
質問票:questionaires:~

	●仕様
API:
Event:
app:application::アプリ
approach:::アプローチ
option:::オプション
UA:user agent:UA
model:::モデル
module:::モジュール
platform:::プラットフォーム
program:::プログラム
	program的:programmatic／:programmatically
risk:::リスク
	risk下にある:at-risk
vendor:::ベンダ
version:::バージョン
web:
Web:
アリ:possible:可能
	あり得る:may choose 〜possible
必要十分:adequate:~
付録:appendix:~
前提:assumption:~
可用性:availability:~
直感:intuition:~
精神:spirit:~
面:surface:~
上流:upstream:~
用法:usage:~
	謝辞:acknowledgements
一般:general:~
一般的:general:~
中核:core:~
中核の:coreな:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
側面:aspect:~
典型的:typical:~
効果:effect:~
副作用:side effect:~
単純:simple:~
	単純~化:simplification
	単純~化され:simplified
原則:principle:~
可用:available:~
可能性:possibility:~
各種用語:terminology:~
	同様に:similarly
問題:problem:~
回答:answer:~
答え:answer:~
多義的:ambiguous:~
実際:actual:~
容易:easy:~
帰結:consequence:~
序論:introduction:~
強く:strongに:~
情報:information:~
意味論的:semantic:~
意図的:intentional:~
手動:manual:~
	手動で:manually
手段:means:~
文脈:context:~
	文脈~上の:contextual:~
既定の:default:~::デフォルト
既定:default:~::デフォルト
既知の:knownな:~
明示的:explicit:~
最適:optimal:~
有用:useful:~
	期間:period:~
概して:typicalに:~
概観:overview:~
機能性:functionality:~
歴史的:historical:~
特定的には:specificalには:具体的には
特有:specific:~
状況:situation:~
独立:independent:~
用語:term:~
目的:purpose:~
直に:directに:~
直感的:intuitive:~
相応しい:suitableな:~
精確:precise:~
	精確でない:imprecise
経験則:heuristics:~
能:ability:~
能力:capability:~
自動的:automatic:~
自然:natural:~
複雑:complicated:~
要件:requirement:~
	要約:abstract
規範的:normative:~
規約:convention:~
記述:description:~
詳細:details:~
論題:topic:~
適切:appropriate:~
適格:eligible:~
重要:important:~
第一の:primaryな:~
勧告候補:CR:~
案:idea:~
通常は:normal には:~
rightな::当を得た
捕える:trapする:~
試行-:try:~
良さげ:plausible:~
即座に:outrightに:~
一貫する:consistentな:~
最善の:best な:~
省略可:optional:~

	因り:due
	例:example
	例えば:for example
	するための:in order to
	-:sufficiently
	代わりに:instead
	しかしながら，:however
	したがって:therefore
	どう:how
	より良い:better
	いくぶん:somewhat
	〜に基づく:based
	おそらく:probably
	一例として:for-instance
	同様に:similarly
	依然として:still
	きちんと:well
	と同時に:at the same time,
	これまで無かった:no previous
	委ねられ:left for
	備考:Notes
	とされる:mark
	織り込ん:taking into account／:account
	次に従って:as follows
	不都合:bad
	逆にconversely
	にもかかわらず:despite that
	伏せている:gloss over
	良い:good
	し易く／~~促して:help
	頭の中:mental
	~~目的に:objectively
	ため:the sake of
	見受けられる:seem
	寄せてほしい:welcome
	ぜひ:very
	加えて:in addition／:in addition to
	呼ばれる:called
	場合によっては:possibly
	〜し易く:easy
	必要:need
	必要とされ:necessary
	必要に迫られ:out of necessity
	従う:follow
	方法:how to
	特に:in-particular
	見よ:see
	適する:suited to
	関わらず:regardless
	対照的に:in contrast
	要約:abstract
	主要な:key
	-:potential
	:per

	●仕様（動詞
feedback:::フィードバック
test:::テスト
制御-:control:~
制御:control:~
	制御を司る:take control over
目指す:aim する:~
代替:alternate:~
見做す:assumeする:~
	見做す下で:assuming
分岐:divergence:~
最大化-:maximize:~
最小化-:minimize:~
読者:reader:~
精緻化:refinement:~
解決策:solution:~
切替える:switchする:切り替える
上書き:override:~
期待-:expect:~
予測-:predict:~
	予測-不能:unpredictable
予見-:believe:~
代替:alternative:~
作者:author:~
供-:provide:~
協力者:contributor:~
協力-:contribute:~
	協力-:contribution
	感謝:thank
依存-:depend:~
保つ:keep する:~
働く:workする:~
公開-:expose:~
利用-:use:~
	利用して:using:~
利用者:user:~
到達-:reach:~
	到達-不能:unreachable
	到達-可能:reachable
制限-:limit:~
取扱う:handle する:~
取組まれ:addressされ:取り組まれ
取組む:addressする:取り組む
可読性:readability:~
奨励-:encourage:~
存在-:exist:~
定義-:define:~
	により定義される:-defined
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
尊守-:honor:~
導入-:introduce:~
希望-:hope:~
意味-:mean:~
意味:meaning:~
抑制-:reduce:~
拡張-:extend:~
	拡張-可能:Extensible
拡張:extension:~
指定-:specify:~
	指定され:specified:~
指示-:indicate:~
挙動:behavior:ふるまい
除外:exclusion:~
除外-:exclude:~
	除外して:excluding:~
排他的:exclusive:~
探求-:explore:~
推奨-:recommend:~
提供-:offer:~
提案-:propose:~
改善-:improve:~
改善:improvement:~
	書く:write
欲され:desire され:~
求める:want する:~
決定-:determine:~
獲得-:acquire:~
相互作用:interaction:~
相互運用能:interoperability:~
確立-:establish:~
示唆:suggestion:~
築き:buildし:~
築く:buildする:~
築かれ:buildされ:~
体験:experience:~
	利用者~体験:UX
経験:experience:~
統合-:integrate:~
編集者:editor:~
考慮点:considerations:~
表出する:expressする:表す
表現-:represent:~
裁定:decision:~
裁定-:decide:~
要求-:require:~
要約-:summarize:~
要請:request:~
応答-:respond:~
応答:response:~
依頼-:ask:~
見なす:considerする:~
考慮-:consider:~
見做す:assumeする:~
設計-:design:~
許容-:allow:~
試み:attempt:~
test:::テスト
試験:experiment:~
試験的:experimental:~
認識-:recognize:~
認識:recognition:~
誘発-:trigger:~
論:discussion:~
	論の最中:under discussion
軽減-:mitigate:~
	軽減-法:mitigating:~
述べる:describeする:~
追加的な:additional:追加の
追加的に:additionalに:追加で
適用-:apply:~
選好-:prefer:~
選定-:select:~
避ける:avoidする:~
開発-:develop:~
関係-:relate:~
関連する:relevantな:~
防止-:prevent:~
	呼応して:in response to
落とさ:dropさ:~
壊す:breakする:~
選ばれ:chooseされ:~
選ん:chooseし:~
	:chosen
着想-:inspire:~
惑わす:confuseさせる:~
拡げる:expand する:~
選取って:pick して:選び取って
選取られ:pick され:選び取られ

	感じ:we feel
	必ず備えるようにするため:in order to make sure
	関わる:associate
	任意選択で~~選ぶ:opt into
	もたらし:cause
	自前の~algoを与える:roll our own

	●未分類（動詞
追加-:add:~
算出d:computed:算出
	算出d値:computed-value
編集-:edit:~
	編集-可能:editable
読込む:load する::読み込む:ロードする

アテガう:assignする::あてがう
生成-:generate::~
除去-:remove::~
継続-:continue:~
遭遇-:encounter:~
対応付ける:map する::~
参照-:reference:~
合致-:match::~
変更-:change:~
変化-:change:~

	在る:present
	生じ:occur
	示す:show
	除-:except
	行なった:done
	書く:write
	含めて:including
	対応する:corresponding

	●未分類
CSS:
DOM:
JS:JavaScript
	JS:Javascript
	Chrome
	WICD
clone:::クローン
code:::コード
computer:::コンピュータ
iframe:
instance:::インスタンス
interface:::インタフェース
keyword:::キーワード
logic:::ロジック
markup:::マークアップ
method:::メソッド
mode:::モード
primitive:::
source:::ソース
辞書:dictionary::~:ディクショナリ

prop:property::プロパティ
stylesheet:style sheet::スタイルシート
table:::テーブル
標的:target::~:ターゲット
text:::テキスト
view:::ビュー
	~view用:viewing
TV:
tabindex:
閲覧文脈:browsing context::~
公式:formula:~
値:value:~
処理能:performance:~
名前:name:~
宣言的:declarative::~
局所的:local::~
属性:attribute::~
所在:location::~
数量的:numerical:~
断片:fragment::~
早期の:earlier:~
構成子:constructs:~
無限:infinite:~
相対的:relative:~
絶対-:absolute:~
相対:relative:~
視野:scope::~:スコープ
角度:angle::~
論理的:logical:~

	依然として:still
	節:section
	負の:negative
	図:figure
	増やさな:increase しな
	無い:none
	TAG
	Working Group
	HTML Standard
	来たる:upcoming
	番組表:program schedule or calendar
	番組:TV shows or calendar entries
	成すように:made into
	~~反映する:mirror
	有無:presence
	高:high
	低:low
	-:(in alphabetical order)
	Bar:#
	Baz:#
	Foo:#


	●指示語
全部的:full:~
新たな:new:~
単独の:single:~
特定0の:particular:ある特定の
現在の:current:~
	現在:currently
自前の:own:~
	更なる／それ以上:further
	上:above
	下:below
	何回も:many times
	ほとんどの:most
	所与の:given
	与え／:give／:giving
	何らかの:some
	一部の:some
	何か:something
	一部:part-of
	両者:both
	他の:other
	他の場合:otherwise
	方々:individual
	別々の:separate
	別個のもの:separately
	別の:another
	前:before
	一部:part of
	後には，／:later:#2
	後で:later of
	いくつかの／何個かの:several
	ここ:here
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	その他:others
	それら:they
	それらの:their
	それらを:them
	自体／それら自身:themselves
	ほぼ:almost
	もの:thing
	一緒:together
	もの:one
	個目の:second／:fourth
	どこ:where
	そこ:there
	それ以上:any further
	〜以上／:at least
	〜以前にpredating:#1
	各:each
	合間:between
	同じ:same
	多い:often
	多くの:many
	後:after
	最初の:first
	最後の:last
	次の:the following
	様々な:various
	結果:result
	結果の:resulting
	自身:itself
	通:through
	間:during
	一連の:series of
	様な:like
	次回に:next time
	次にある:next
	さらにもう一回:additionalに
	もう一回:next
	周りに:around:::
	少数の:few
	先立って:prior to
	異なる:different:~
	それまで:previously
	それまでは:until then
	何もない:nothing／:there isn’t any
	上に:onto
	箇所:point
	~among

●●ref_normative

[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 31 July 2018. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-SCROLL-SNAP-1]
    Matt Rakow; et al. CSS Scroll Snap Module Level 1. 19 March 2019. CR. URL: https://www.w3.org/TR/css-scroll-snap-1/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSSOM-VIEW-1]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FEATURE-POLICY]
    Ian Clelland. Feature Policy. 16 April 2019. WD. URL: https://www.w3.org/TR/feature-policy-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead; Doug Schepers. UI Events. 8 November 2018. WD. URL: https://www.w3.org/TR/uievents/ 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[EXTENSIBLE]
    The Extensible Web Manifesto. 10 June 2013. URL: https://extensiblewebmanifesto.org/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Spatial Navigation Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新 発行バージョン
	https://www.w3.org/TR/css-nav-1/
最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-nav-1">GitHub Issues</a></dd>
編集
	<a href="mailto:jh.hong@lge.com">Jihye Hong</a> (LG Electronics)
	<a href="https://florian.rivoal.net">Florian Rivoal</a> (Invited Expert)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-nav-1/Overview.bs">GitHub Editor</a>

</script>

</head>
<body>

<!--%resource pool -->
<div id="_persisted_parts" hidden>
<img
	id="_dgm-spatnav-enable"
	src="css-nav/spatnav-enable.png"
	style="width: 500px;"
	alt="When elements are laid out in a grid pattern, spatial navigation makes it much easier to predict and control where focus should move to."
>
<img
	id="_dgm-spatnav-scroll-visible-1"
	src="css-nav/spatnav-scroll-visible-1.png"
	style="width:10em; height:23.75em;"
	alt=""
> 
<img
	id="_dgm-spatnav-scroll-visible-2"
	src="css-nav/spatnav-scroll-visible-2.png"
	style="width:10em; height:23.75em;"
	alt=""
>
<img
	id="_dgm-spatnav-scroll-invisible-1"
	src="css-nav/spatnav-scroll-invisible-1.png"
	style="width:10em; height:23.75em;"
	alt=""
> 
<img
	id="_dgm-spatnav-scroll-invisible-2"
	src="css-nav/spatnav-scroll-invisible-2.png"
	style="width:10em; height:23.75em;"
	alt=""
> 
<img
	id="_dgm-spatnav-scroll-invisible-3"
	src="css-nav/spatnav-scroll-invisible-3.png"
	style="width:10em; height:23.75em;"
	alt=""
> 
<img
	id="_dgm-spatnav-scroll-invisible-4"
	src="css-nav/spatnav-scroll-invisible-4.png"
	style="width:10em; height:23.75em;"
	alt=""
>
<img
	id="_dgm-focusableareas-visible-example"
	src="css-nav/focusableareas-visible-example.png"
	style="width:30em; height:13.8em;"
	alt="An image about focusableAreas()"
>
<img
	id="_dgm-navnotarget-example-1"
	src="css-nav/navnotarget-example-1.png"
	style="width:13em; height:21.2em;"
	alt="An image about navnotarget"
>
<img
	id="_dgm-navnotarget-example-2"
	src="css-nav/navnotarget-example-2.png"
	style="width:13em; height:21.2em;"
	alt="An image of the result about navnotarget"
>
<!-- 
<img
	id="_dgm-spatnav_processing_model_diagram"
	src="css-nav/spatnav_processing_model_diagram.svg"
	style="width:971px; height:1730px;"
	alt="An image of the result about navnotarget"
>
 -->
<img
	id="_dgm-projected_overlap"
	src="css-nav/projected_overlap.svg"
	style="width:32em; height:16em"
	alt=""
>
<img
	id="_dgm-spatnav-action"
	src="css-nav/spatnav-action.png"
	style="width:500px; height:407px"
	alt=""
>
</div>


<header>
	<hgroup>
<h1>CSS Spatial Navigation Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>


<p>
この仕様は、矢印~keyを利用して~focusを~navigateするための一般~model, および関係する［
~CSS, ~JS特能, ~Event
］を定義する。
◎
This specification defines a general model for navigating the focus using the arrow keys, as well as related CSS, JavaScript features and Events.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
【！この節では、発行時点における…】
これは編集者草案の公開の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">~CSS日本語訳 共通ページ</a>に委譲。】
</p>

<p>
次に挙げる特能は~risk下にあり，勧告候補~期間に落とされるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul ><li>`getSpatialNavigationContainer()$m
</li><li>`focusableAreas()$m
</li><li>`spatial-navigation-contain$p
</li><li>`spatial-navigation-action$p 用の値 `scroll^v
</li></ul>


	</section>

<main id="MAIN0">

<!-- 
<p>
This specification is rather long.
To make it easier to read and focus on a particular area,
a few checkboxes are provided below.
Checking them hides part of the specification.
This is only meant as a reading aid,
the specification remains the full document.
</p>

<input id="api-check" type="checkbox">
<label for="api-check">Hide JavaScript APIs, including events</label>
<br> 
<input id="cssapi-check" type="checkbox">
<label for="cssapi-check">Hide CSS properties that enable selecting behavior variants, and related information</label>
<br> 
<input id="verbose-check" type="checkbox">
<label for="verbose-check">Hide informative sections that explain and summarize normative sections without adding more information</label>

 -->

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
歴史的に，ほとんどの~browserは、~focusをある方向へ移動する特能を利用者に提供していなかった。
~TV~browserなど，一部のものは、必要に迫られ，利用者が矢印~keyを利用して~focusを移動するのを可能化する
— 典型的な~TV~remote-controlには可用な入力の仕組みが他にないので。
◎
Historically, most browsers have not offered features to let users move the focus directionally. Some, such as TV browsers, have enabled users to move the focus using the arrow keys out of necessity, since no other input mechanism is available on a typical TV remote control.
</p>

<p>
その他ものは、空間的~naviを制御するための，異なる~key組合わせを可能化していた
— `Shift$kY ~keyと矢印~keyを一緒に~pressするなど。
◎
Others, have enabled different key combinations to control spatial navigation, such as pressing the Shift key together with arrow keys.
</p>

<p>
ある方向へ，頁を巡って移動するこの能は、
`空間的~navi@
と呼ばれる。
◎
This ability to move around the page directionally is called spatial navigation.
</p>

<p>
`空間的~navi$は、格子~状の~layoutその他のおよそ一次元的でない~layoutを利用して築かれた~web頁~用に有用になり得る。
下の図は、格子~layoutに配列された写真展示を表現する。
利用者が `Tab$kY ~keyを~pressして~focusを移動した場合、欲される要素へ到達するまで，~keyを何回も~pressする必要がある。
また，格子~layoutは、要素の~layoutを~source順序とは独立に配列し得る。
したがって `Tab$kY ~keyを利用する逐次的~naviによる~focus~naviを予測-不能にする。
対照的に，`空間的~navi$は、~focus可能な要素たちの間で，それらの位置に依存して~focusを移動することで、逐次的~naviに遭遇した問題に取組むことを許容している。
◎
Spatial navigation can be useful for a web page built using a grid-like layout, or other predominantly non linear layouts. The figure below represents a photo gallery arranged in a grid layout. If the user presses the Tab key to move focus, they need to press the key many times to reach the desired element. Also, the grid layout may arrange the layout of elements independently of their source order. Therefore sequential navigation using the Tab key makes focus navigation unpredictable. In contrast, spatial navigation moves the focus among focusable elements depending on their position allowing it to address problems encountered with sequential navigation.
</p>

<figure>`spatnav-enable^dgm

<figcaption>
格子~状の~layoutを利用してている~app。
◎
Application using a grid-like layout.
</figcaption></figure>

<p>
矢印~keyは，空間的~naviを制御するには自然に適するが、それがどう働くベキで, どう制御されてヨイ／できるかを述べる仕様は，これまで無かった。
この仕様は、［
空間的~navi用の処理~model
］, および［
作者が，空間的~naviがどう働くかを［
制御する／上書きする
］ことを可能化する~API
］を導入する。
◎
While arrow keys are naturally suited to control spatial navigation, no previous specification describes how that should work, or how it may be controlled. This specification introduces a processing model for spatial navigation, as well as APIs enabling authors to control and override how spatial navigation works.
</p>

<p class="note">注記：
この仕様を成す一部の側面
— ~JS［
~Event／~API
］など —
は、逐次的~naviにも拡張できる
— ~keyboard~naviが一般に一貫する, かつ きちんと定義された~modelを必ず備えるようにするための。
◎
Note: Some aspects of this specification, such as the JavaScript Events and APIs could also be extended to sequential navigation, in order to make sure that keyboard navigation in general has a consistent and well defined model.
</p>

<p class="note">注記：
一般~原則として、~keyboard~navi, 特に空間的~naviは，~JSなしに利用したり制御することがアリになるベキであり、したがって宣言的な解決策が選好される。
空間的~naviは~layoutに依存するので、概して，~CSSが空間的~naviに関係する制御-を定義するための~rightな仕組みになることを意味する。
しかしながら，`拡張-可能な~Web$ `EXTENSIBLE$r の精神においては、~rightな~JS~primitiveを供して，作者に問題~空間を試験して探求してもらうことが重要であると感じられる。
後には、そのような~JS用法を通して獲得された~feedbackと経験に基づいて，より宣言的な特能が追加されるであろう。
◎
Note: As a general principle, keyboard navigation, and spatial navigation in particular, should be possible to use and control without JavaScript, and declarative solutions are therefore preferred. Since spatial navigation depends on layout, that means CSS is typically the right mechanism to define spatial navigation related controls. However, in the spirit of the Extensible Web Manifesto [EXTENSIBLE], we feel it is important to provide the right JavaScript primitives to let authors experiment and explore the problem space. More declarative features may be added later, based on feedback and experience acquired through such JavaScript usage.
</p>

<p class="note">注記：
少数の特能は、
`~risk下@
にあるとされる。
編集者は、それらが［
この仕様に定義される特能の利用者や作者による体験
］を成す重要な一部を表現すると予見している。
と同時に、この仕様を成す中核の機能性は，これらを実装せずに実装できるので、最初の実装の視野を抑制するため，実装者は それらの優先度を下げることもあり得ると見受けられる。
これらの特能は
— 実装されることになると希望されているが —
最優先でないかもしれない認識の下で，~risk下にあるとされる。
◎
Note: A few features are marked at-risk. The editors of this specification believe they represent an important part of the user or author experience of the features defined in the specification. At the same time, the core functionality of this specification can be implemented without implementing these so it seems possible that implementors may choose to down-prioritize them to reduce the scope of a first implementation. While it is hoped that these features will be implemented as well, they are marked at-risk in recognition that they might not be at first.
</p>

	</section>
	<section id="interaction">
<h2 title="Module interaction">2. ~module間の相互作用</h2>

<p>
この文書は `infra$r に依存する。
◎
This document depends on the Infra Standard [infra].
</p>

<p>
【以下略：<a href="index.html#rfc2119-phrase">RFC 2119 が規定する句に利用される対訳</a>を参照されたし。】
◎
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in RFC 2119. [RFC2119]
</p>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
	</section>
	<section id="overview" class="verbose">
<h2 title="Overview">3. 概観</h2>

~INFORMATIVE

<p>
~UAにより定義される仕組みを利用して（概して矢印~key，場合によっては `Shift$kY や `Control$kY の様な修飾keyとの組合わせで）、利用者は特定0の方向へ~navigateするよう~UAに依頼することもある。
これは、その現在の所在から要請された方向に~focus可能な新たな~itemが在れば，そこへ~focusを移動し、適切な~itemが無ければ~scrollすることになる。
◎
Using a UA-defined mechanism (typically arrow keys, possibly in combination with modifier keys like Shift or Control), the user may ask the User Agent to navigate in a particular direction. This will either move the focus from its current location to a new focusable item in the direction requested, or scroll if there is no appropriate item.
</p>

<p>
より特定的には、~UAは先ず，［
現在の`空間的~navi容器$の中で指示された方向にある，可視かつ~focus可能な~item
］を探索することになる
（`空間的~navi容器$は、既定では，［
根~要素, ~scroll可能な要素, ~iframe
］いずれかであるが、
`spatial-navigation-contain$p ~propを利用すれば，他の要素も`空間的~navi容器$を成すようにできる）。
◎
More specifically, the User Agent will first search for visible and focusable items in the direction indicated within the current spatial navigation container (by default the root element, scrollable elements, and iframes, but other elements can be made into spatial navigation containers using the spatial-navigation-contain property).
</p>

<p>
何かが見出された場合、その方向にある最良の 1 つを選取って，~focusをそこへ移動することになる。
◎
If it finds any, it will pick the best one for that direction, and move the focus there.
</p>

<p>
何も見出されなかった場合、~focusを移動する代わりに，要請された方向へ`空間的~navi容器$を~scrollすることになる。
その結果，~focus可能な要素が~~現れ得る
— その場合、次回に同じ方向へ空間的~naviが要請されたとき，それが~focusを移動する適格な標的になるであろう。
◎
If it does not, it will scroll the spatial navigation container in the requested direction instead of moving focus. Doing so may uncover focusable elements which would then be eligible targets to move the focus to next time spatial navigation in the same direction is requested.
</p>

<p>
［
~scroll可能な要素でないか，すでにその方向へ~scrollし切った
］ため，`空間的~navi容器$を~scrollできない場合、~UAは先祖上の連鎖を遡って次にある`空間的~navi容器$を選定して，何らかの［
~focus／~scroll
］可能な要素を見出すか，根~要素に到達するまで，上の処理-を再帰的に繰返すことになる。
◎
If the spatial navigation container cannot be scrolled, either because it is not a scrollable element or because it is already scrolled to the maximum in that direction, the User Agent will select the next spatial navigation container up the ancestry chain, and recursively repeat the above process until it finds some element to focus or scroll, or reaches the root element.
</p>

<p class="note">注記：
この処理~modelの帰結として、逐次的~naviにより到達-可能な要素たちは，空間的~naviにより到達-可能なものとほぼ同じになる。
現在~scroll可能な要素の表示域の外側にある要素へは、空間的~naviにより~viewの中へ~scrollされたときに限り到達できる。
したがって，~viewの中へ~scrollできない要素（例えば，負の~offsetに配置されているもの）は、空間的~naviでも到達できない。
◎
Note: As a consequence of this processing model, the elements that are reachable by sequential navigation and by spatial navigation are almost the same. Elements that are currently outside of the viewport of a scrollable element can only be reached by spatial navigation once they have been scrolled into view. Therefore, elements that cannot be scrolled into view (for example because they are placed at a negative offset) cannot be reached by spatial navigation.
</p>

<div class="api">

<p>
この［
空間的~navi要請に対し適切な応答を得るため，探索する間
］の主要な箇所にて，~UAは~eventを発火することになる。
これらは、作者が来たる動作を防止すること（ `preventDefault()$m を~callして），および
欲されるなら代替~動作
— 作者が選んだ異なる要素に対し `focus()$m ~methodを利用するなど —
を供することを可能化する。
◎
At key points during this search for the appropriate response to the spatial navigation request, the User Agent will fire events. These enable authors to prevent the upcoming action (by calling preventDefault()), and if desired to provide an alternate action, such as using the focus() method on a different element of the author’s choosing.
</p>

<p>
作者がそのような代替~動作を書き易くするため、および`拡張-可能な~Web$ `EXTENSIBLE$r の原則の下に，下層の~platform~primitiveを公開する一部として、この仕様は，下層の~modelの主要な構成子を公開する~JS~APIも定義する。
◎
To help authors write such alternate actions, and as part of exposing underlying platform primitives as per the Extensible Web principles, this specification also defines JavaScript APIs that expose key constructs of the underlying model.
</p>

<p>
~JS~APIについての詳細は
<a href="#js-api">§ ~JS~API</a> ／
様々な~eventについての詳細は
<a href="#events-nav-type">§ ~navi~event型</a> ／
~CSS~propについての詳細は
<a href="#declarative">§ 宣言的な手段による空間的~naviの制御-法</a>
を見よ。
◎
See §5 JavaScript API for details about the JavaScript API, §6.2 Navigation Event Types for details about the various events, and §9 Controlling spatial navigation through declarative means for details about the CSS properties.
</p>

</div>

<div class="example">

<p>
この例は、~scroll可能な要素~内に配列された一連の~focus可能な要素が，空間的~naviを利用して どう~navigateされるかを示す。
記述を単純に保つため、この例の空間的~naviは，矢印~keyを利用して誘発されるものと見做す。
【！User Agent where】
◎
This example shows how a series of focusable elements arranged in a scrollable element would be navigated when using spatial navigation. For the sake of keeping the description simple, this example assumes a User Agent where spatial navigation is triggered using arrow keys.
</p>

<figure>
`spatnav-scroll-visible-1^dgm
`spatnav-scroll-visible-2^dgm
<figcaption>
`空間的~navi容器$内の可視な要素へ，~focusを移動する。
◎
Moving focus to the visible element in the spatial navigation container.
</figcaption></figure>

<p>
上の図では、左端にある "Box 2" が~focusされている。
`ArrowDown$kY ~keyを~pressすると、~scrollすることなく，~focusは "Box 3" へ移動する
— "Box 3" は`空間的~navi容器$の`~scrollport$内に可視なので。
◎
On the left of figure 2, "Box 2" is focused. Pressing the ArrowDown key moves the focus to "Box 3" without scrolling because "Box 3" is visible in the scrollport of the spatial navigation container.
</p>


<figure>
`spatnav-scroll-invisible-1^dgm
`spatnav-scroll-invisible-2^dgm
`spatnav-scroll-invisible-3^dgm
`spatnav-scroll-invisible-4^dgm
<figcaption>
`空間的~navi容器$内にある隠れていた要素へ~focusを移動する様子。
◎
Moving focus to the hidden element in the spatial navigation container.
</figcaption></figure>

<p>
上の 1 個目の図において、`~scrollport$内には， "Box 3" の下には可視な要素は無い。
したがって， `ArrowDown$kY を~pressしたときの効果は、 2 個目の図に示されるように下へ~downへ~scrollする。
もう一回 `ArrowDown^kY ~keyが~pressされると `~scrollport$の中へ "Box 4" が来るようになり（ 3 個目の図）、さらにもう一回 `ArrowDown^kY が~pressされると，~focusは そこへ移動することになる（ 4 個目の図）。
◎
On the first of figure 3, under "Box 3", there isn’t any visible element in the scrollport. Therefore, the effect of pressing the ArrowDown is to scroll down, as shown in the second. The next press of the ArrowDown key makes "Box 4" come into the scrollport, and the focus will move to it when there is additional pressing the ArrowDown, as the fourth.
</p>

<p>
この例では、次の~markupが利用されている：
◎
This example uses the markup as follows:
</p>

<pre class="lang-css">
#scroller {
    width: 700px;
    height: 700px;
    overflow-x: hidden;
    overflow-y: auto;
}

.box {
    width: 150px;
    height: 110px;
    background-color: blue;
}

.box:focus {
    background-color: red;
}
</pre>

<pre class="lang-html">
&lt;div id="scroller"&gt;
    &lt;div class="box" tabindex="0"&gt;Box 1&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 2&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 3&lt;/div&gt;
    &lt;div class="box" tabindex="0"&gt;Box 4&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

	</section>
	<section id="triggering">
<h2 title="Triggering Spatial Navigation">4. 空間的~naviの誘発-法</h2>

<p>
利用者が所与の方向への空間的~naviを誘発するとき、~UAは，その方向への`空間的~navi手続き$を走らすモノトスル。
◎
When the user triggers spatial navigation in a given direction, the User Agent must run the spatial navigation steps in that direction.
</p>

<p>
この仕様は、~UAが［
空間的~naviを誘発する~UIの仕組み
］として何を利用者に提供するベキかは，定義しない。
これは、意図的に~UAの裁定に委ねられている。
◎
This specification does not define what UI mechanism User Agents should offer to users to trigger spatial navigation. This intentionally left for User Agents to decide.
</p>

<p class="note">注記：
［
~remote-controlで操作oされる~TV,
~feature-phone,
~game~controllerで操作oされている機器
］など，入力~能力が制限された機器~上の~UAは、第一の, または排他的な~naviの仕組みとして，空間的~naviを利用することになるものと期待される。
◎
Note: It is expected that User Agents on devices with limited input capabilities, such as TVs operated with a remote control, feature phones, or devices operated with a game controller, will use spatial navigation as their primary or exclusive navigation mechanism.
</p>

<p>
~UAにとっては，［
空間的~navi自体を直に誘発する手段を利用者に与えることなく，処理~model, 仕様に定義される~APIを実装する
］こともアリだが、この仕様は，そうしないことを推奨する。
~UAは、~APIを利用せずに直に空間的~naviを誘発する手段を，利用者に提供するベキである。
◎
Although it is possible for User Agents to implement the processing model and APIs defined by the specification without giving any direct means to the user to trigger spatial navigation themselves, this specification recommends not to do so: User Agents should offer a means for users to trigger spatial navigation directly, without having to use the APIs.
</p>

<p class="note">注記：
逆に，作者は、~APIを呼出さないときでも［
空間的~naviは、利用者~動作に呼応して，~UAにより誘発され得る
］ものと見做すベキである。
◎
Note: Conversely, authors should assume that spatial navigation may be triggered by the User Agent in response to user actions even if the author has not invoked any of the APIs.
</p>

<p>
空間的~naviを誘発するために選ばれる実際の仕組みに関わらず，次に挙げる要件が適用される：
◎
Regardless of the actual mechanism chosen to trigger spatial navigation, the following requirements apply:
</p>

<ul>
	<li>
<p>
空間的~naviを誘発するために利用者が利用しなければナラナイ仕組みが，通常は `UIEvent$I を発火する場合
⇒
`空間的~navi手続き$を走らすに先立って，その~eventを発火した上で、その~eventの`取消d~flag$が ~ON にされた場合には，この手続きを走らせないモノトスル。
◎
If the mechanism the user must use to trigger spatial navigation would normally fire a UIEvent, the event must be fired prior to running the spatial navigation steps and these steps must not be run if that event’s canceled flag gets set.
<p>

<div class="example">

<p>
~game用~機器の十字キーが~pressされたとき、空間的~naviを誘発し得る。
これは、~keyが［
`ArrowDown$kY, `ArrowLeft$kY, `ArrowRight$kY, `ArrowUp$kY
］いずれかに設定された `keydown$et ~eventを発火する結果になる。
これが取消されなかった場合、`空間的~navi手続き$を走らす
— 関連する `NavigationEvent$I を発火することも含め。
◎
Gaming devices may trigger spatial navigation based on pressing the D-pad. This would result in firing a keydown event with the key set to one of ArrowDown, ArrowLeft, ArrowRight, or ArrowUp, followed if not canceled by running the spatial navigation steps, including firing the relevant NavigationEvents.
</p>

<p>
~keyboardの矢印~keyを利用して空間的~naviを誘発する，~desktop~computer上の~UAは、同じ連列に従うことになる。
◎
A User Agent on a desktop computer that triggers spatial navigation using the arrow keys of the keyboard would follow the same sequence.
</p>

</div>

	</li>
	<li>
<p>
空間的~naviを誘発するために利用者が利用しなければナラナイ仕組みが，何らかの文脈においては他の動作を誘発することになる場合、~UAは［
そのような文脈においては，それら他の動作に優先度を与えて、空間的~naviの代わりに，それらを実行する
］ベキであり，両者とも誘発しないモノトスル。
◎
If the mechanism the user must use to trigger spatial navigation would trigger other actions in some contexts, the User Agent should in these contexts give priority to these other actions and execute them instead of spatial navigation. It must not trigger both.
<p>

<p class="example">
修飾keyなしの矢印~key利用して，空間的~naviを誘発し，同じ矢印~keyを~text挿入~caretを移動するためにも利用する~UAにおいて、編集-可能な要素に~focusされたときは，矢印~keyは，既定では~caretを移動するベキである。
空間的~naviは、［
~focusされた要素が編集-可能でないか、編集-可能であるが，~caretは要請された方向へそれ以上~移動できないとき
］に限り，矢印~keyにより誘発されることになる。
◎
In a User Agent that triggers spatial navigation using the arrow keys without modifier keys, and uses these same arrow keys to move the text insertion caret when an editable element is focused, the arrow keys should by default to moving the caret. Spatial navigation would only be triggered by the arrow keys when the focused element is not editable, or when it is editable but the caret cannot move any further in the requested direction.
</p>

<p>
ただし、~scrollingには例外がある：
空間的~navi自体は（~focusを移動することに加えて）~scrollingも取扱うので、~UAは，同じ仕組みを［
空間的~navi, 空間的~naviとは別々の~scrollingの挙動
］の両者を誘発するものとして提供するベキでない。
しかしながら，~UAは、［
それらの間で異なる~modeに切替える仕方，あるいは
異なる~UIの仕組みに基づいて両者
］を利用者に提供してもヨイ。
◎
An exception is made for scrolling: since spatial navigation itself handles scrolling (in addition to moving the focus) User Agents should not offer the same mechanism to trigger both spatial navigation and a scrolling behavior separate from spatial navigation. User Agents may however, offer a way for the user to switch between different modes, or offer both based on different UI mechanism.
</p>

<p class="example">
~UAは、［
空間的~navi用, ~scrolling用
］のどちらに修飾keyなしの矢印~keyを利用するか，利用者に選んでもらう設定ngを備えることもあろう。
別の~UAは、［
~scroll用には修飾keyなしの矢印~key
］,
空間的~navi用には［
矢印~keyが `Shift$kY ~keyと一緒に~pressされたとき，あるいは［
`W^kY `A^kY `S^kY `D^kY
］~key
］を提供することもあろう。
矢印~keyを~pressしたときに［
空間的~navi, ~scrolling
］どちらかのみを応答として提供する可能性もある。
◎
A User Agent may have a setting to let the user choose between using the arrow keys without modifier keys for spatial navigation or for scrolling. Another one may offer scrolling on arrow keys without modifiers, and spatial navigation on arrow keys when pressed together with the Shift key, or on the W A S D keys. Offering only spatial navigation or only scrolling as responses to pressing arrow keys would also be possibilities.
</p>
	</li>
</ul>

	</section>
	<section id="js-api" class="api">
<h2 title="JavaScript API">5. ~JS~API</h2>

		<section id="high-level-api">
<h3 title="Triggering Navigation Programmatically">5.1. ~program的な~naviの誘発-法</h3>
<p>
`navigate()$m ~methodは、空間的~naviを~program的に誘発することを作者に可能化する
— 利用者が手動でそれを行なったかのように（一例として，矢印~keyが空間的~naviを誘発する仕方である~browser内で矢印~keyを~pressすることにより）。
◎
The navigate() method enables the author to trigger spatial navigation programmatically, as if the user had done so manually (for instance, by pressing the arrow keys in a browser where that is the way to trigger spatial navigation).
</p>

<p class="note">注記：
これは，手動~naviと同じ処理~modelを誘発するので、まったく同じ結果
— 同じ~eventの連鎖が発火され，同じ要素が［
~scroll／~focus
］されるよう —
になるベキと期待される。
◎
Note: As this triggers the same processing model as a manual navigation, all the same results should be expected: the same chain of events will be fired and the same element will be scrolled or focused.
</p>

<p class="note">注記：
これを利用すれば、作者は，~UAがアテガうものと異なる~UIの仕組みに基づいて空間的~naviを誘発できる
— ［
異なる~keyに対応付ける ／
~screen上の~click可能な十字キーから空間的~naviを誘発する ／
~UI以外の~eventに対する反応において
］など。
それはまた、作者が［
~naviを中断して，何らかの非同期的な演算を行って（例：無限~scroller内にもっと内容を読込む），取消した所から~naviを再開したい
］と求めるときにも利用できる。
◎
Note: Authors can use this to trigger spatial navigation based on a different UI mechanism than the one assigned by the User Agent, such as mapping to different keys, or triggering spatial navigation from a clickable on-screen directional pad, or in reaction to other events than UI ones. It could also be used when an author wants to interrupt navigation to do some asynchronous operation (e.g. load more content in an infinite scroller) then resume the navigation where they cancelled.
</p>

<p class="note">注記：
この~APIは、~testする目的にも有用になる
— ~vendorに特有な~UI規約に依存しない，空間的~naviを誘発する仕方は、他に無いので。
◎
Note: This API is also useful for testing purposes, as there is no other way to trigger spatial navigation that does not depend on vendor specific UI conventions.
</p>

<pre class="idl">
enum `SpatialNavigationDirection@I {
    `up@l,
    `down@l,
    `left@l,
    `right@l,
};

partial interface `Window$I {
    void `navigate$m(`SpatialNavigationDirection$I %dir);
};
</pre>

<dl class="idl-def">
	<dt>`navigate(dir)@m</dt>
	<dd>
被呼出時には、次を走らすモノトスル：
⇒
~IF［
%dir ~IN { `up^l, `down^l, `left^l, `right^l }
］
⇒
`空間的~navi手続き$( %dir )
◎
When the navigate(dir) method is called, the User Agent must run the following step:
• If dir is "up", "down", "left", or "right", run the spatial navigation steps in direction dir.
</dd>
	<dd class="issue">
この~APIの名前は、論の最中にある
`3387$issue
◎
The name of this API is under discussion &lt;https://github.com/w3c/csswg-drafts/issues/3387&gt;
</dd>
</dl>

		</section>
		<section id="low-level-api">
<h3 title="Low level APIs">5.2. 低~levelな~API</h3>

<p class="note">注記：
これらの~APIは、処理~modelに近く従っている低~levelな構成子として設計されている。
そのようなわけで、それらは空間的~naviが働く仕方を拡張したり上書きしたいと求める作者に利用し易くあるベキである。
◎
Note: These APIs are designed to be low level constructs following the processing model closely. As such, they should be easy to use by authors who want to extend or override the way spatial navigation works.
</p>

<pre class="idl">
enum `FocusableAreaSearchMode@I {
    `visible@l,
    `all@l
};

dictionary `FocusableAreasOption@I {
    `FocusableAreaSearchMode$I `mode@m;
};

dictionary `SpatialNavigationSearchOptions@I {
    required `SpatialNavigationDirection$I `dir@mSO;
    sequence&lt;`Node$I&gt;? `candidates@mSO;
    `Node$I? `container@mSO;
};

partial interface `Element$I {
    `Node$I `getSpatialNavigationContainer$m();
    sequence&lt;`Node$I&gt; `focusableAreas$m(optional `FocusableAreasOption$I %option);
    `Node$I? `spatialNavigationSearch$m(`SpatialNavigationSearchOptions$I %options);
};
</pre>

<p class="note">注記：
方向を表出する仕方は、必要とされれば，後で上下左右~naviより拡げることも許容するようにしてある。
方向を表す~keywordや数量的な角度もさらに追加され得る。
◎
Note: The way the direction is expressed allows us to expand to more than 4-way navigation later of if this is found necessary. More directional keywords or a numerical angle could be added.
</p>

<p class="note">注記：
`focusableAreas()$m,
`getSpatialNavigationContainer()$m
~methodは`~risk下$にある。
◎
Note: the focusableAreas() and getSpatialNavigationContainer() methods are at-risk.
◎
When these methods are called, the User Agent must run the steps described below:
</p>

<dl>
	<dt>`getSpatialNavigationContainer()@m</dt>
	<dd>
被呼出時には、次を返すモノトスル
⇒
［
此れの先祖であって`空間的~navi容器$であるもの
］が［
在るならば それらのうち此れに最も近いもの ／
無いならば `文書$
］
◎
Return the nearest ancestor of the element that is a spatial navigation container, or the document if the nearest spatial navigation container is the viewport.
</dd>
	<dd class="note">注記：
この要素~自身が`空間的~navi容器$であっても、先祖（または文書）を返す。
◎
Note: If the element is a spatial navigation container, getSpatialNavigationContainer() also returns the nearest spatial navigation container, not the element itself.
</dd>

	<dt>`focusableAreas(option)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
↑↑</p>
		<ol>
			<li>
%可視のみ ~LET ［
%option ~EQ `all$l ならば ~F ／
~ELSE_ ~T
］
◎
Let visibleOnly be false if option is present and its value is equal to all, or true otherwise.
</li>
			<li>
%~anchorたち ~LET `要素の中で~focus可能な区画を見出す$( 此れ, %可視のみ )
◎
Let areas be the result of finding focusable areas within the element with visibleOnly as argument.
◎
（cloneは不要）
Let anchors be a clone of areas,＼
</li>
			<li>
%~anchorたち を成す
~EACH( %~focus可能な区画 )
に対し
⇒
~IF［
%~focus可能な区画 は`~node$でない
］
⇒
%~anchorたち の中で %~focus可能な区画 を［
%~focus可能な区画 の`~DOM~anchor$
］に`置換する$set
◎
with every focusable area which is not itself a Node replaced with its DOM anchor.
</li>
			<li>
~RET %~anchorたち
◎
Return anchors
</li>
		</ol>
	</dd>
	<dd class="example" id="focusAreas-visible">

<p>
次の~codeは、
`focusableAreas()$m を利用して，現在の頁~内の可視かつ~focus可能な要素~すべてを取得する方法を示す。
~methodが`空間的~navi容器$を見出した場合、その内側にある`~focus可能な区画$たちを再帰的に見出す。
しかしながら、この~methodの `mode$m 属性は `visible^c に設定され，`~scrollport$の内側にない~focus可能な要素は結果から除外される。
◎
The following code shows how to get all the visible focusable elements in the current page using focusableAreas(). If the method finds a spatial navigation container, it recursively finds focusable areas inside it. However, as the mode attribute of this method is set to visible, the focusable element which isn’t inside the scrollport is excluded from the result.
</p>
<pre>
&lt;body&gt;
    &lt;button&gt;&lt;/button&gt;
    &lt;div style="width:300px; height:200px; overflow-x: scroll;"&gt;
        &lt;button style="left:25px;"&gt;&lt;/button&gt;
        &lt;button style="left:150px;"&gt;&lt;/button&gt;
        &lt;button style="left:350px;"&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
</pre>

<pre>
const %focusableAreas = document.body.focusableAreas({mode: 'visible'});
%focusableAreas &amp;&amp; %focusableAreas.forEach(%focusable =&gt; {
  %focusable.style.outline = '5px solid red';
});
</pre>

<p>
この~codeの結果を下の図に示す：
◎
The figure below is the result of this code.
</p>

<figure>`focusableareas-visible-example^dgm
<figcaption>
文書の内側にあるすべての可視かつ`~focus可能な区画$たちを見出す。
◎
Find all visible focusable areas inside the document.
</figcaption></figure>

	</dd>

	<dt>`spatialNavigationSearch(options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
↑↑</p>
		<ol>
			<li>
%方向 ~LET %options の `dir$mSO 属性の値
◎
Let direction be the value of dir attribute of options.
</li>
			<li>
~IF［
%options の `candidates$mSO 属性の値 ~NEQ ~NULL
］
⇒
%区画たち ~LET その値
◎
If the value of candidates attribute of options is not null, then let areas be the that value
</li>
			<li>
<p>
~ELSE：
◎
else,
<p>
				<ol>
					<li>
~IF［
%options の `container$mSO 属性の値 ~NEQ ~NULL
］
⇒
%容器 ~LET その値
◎
If the value of container attribute of options is not null, let container be that value
</li>
			<li>
~ELSE
⇒
%容器 ~LET 此れの先祖の`空間的~navi容器$のうち要素に最も近いもの
◎
else, let container be the element’s nearest spatial navigation container ancestor.
</li>
			<li>
%区画たち ~LET `要素の中で~focus可能な区画を見出す$( %容器 )
◎
Let areas be the result of finding focusable areas within container.
</li>
		</ol>
	</li>
	<li>
~RET `最良の候補を選定する$( %区画たち, %方向, 此れ )
◎
Return the result of selecting the best candidate within areas in direction direction from the element.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
容器（ `container$mSO ）も候補の~list（ `candidates$mSO ）も供されていないとき、これは，［
先祖の`空間的~navi容器$のうち最も近いもの
］に限り，可視かつ`~focus可能な区画$たちを探索する。
`何もない場合、先祖上の連鎖を更に遡ることはなく，結果は ~NULL になる。^em
◎
Note: When neither a container nor a list of candidates is provided, this only searches through the visible focusable areas of the nearest spatial navigation container ancestor. If there isn’t any, this does not climb further up the ancestry chain, and the result will be null.
</p>

<div class="example" id="delegation">

<p>
次の~codeは、空間的~naviの挙動を変更する
— ~scroll容器が~focusを取得したとき，可視かつ~focus可能な子孫が 1 個~以上あるならば、~focusは自動的にそこへ転送されるよう，再帰的に。
◎
The following code changes the behavior of spatial navigation so that when a scroll container would get focused, if it has at least one visible focusable descendant, the focus is automatically transferred to it, recursively.
</p>
<pre>
document.addEventListener('navbeforefocus', function(%e) {
    %e.preventDefault();

    let %target = %e.relatedTarget;
    while (%target.isSameNode(%target.getSpatialNavigationContainer())) {
        const %areas = %target.focusableAreas();

        if (%areas.length === 0) { break; }

        %target = target.spatialNavigationSearch({
            dir:  %e.dir,
            candidates: %areas
        });
    }
    %target.focus();
});
</pre>
</div>

<div class="example" id="loop">
<p>
次の~codeは、`空間的~navi容器$の中の~focusを捕えるよう，空間的~naviの挙動を変更する：
［
要請された方向には，~focus可能な要素はそれ以上~見出されない
］かつ［
`空間的~navi容器$はそれ以上~scrollできない
］ときは、~focusを容器の外側へ移動する代わりに，~~反対~側へ~loopして戻るようにする
— ~focusするか~scrollするか可用な方に依存して。
◎
The following code changes the behavior of spatial navigation to trap the focus within a spatial navigation container: when no further focusable elements can be found in the requested direction and the spatial navigation container cannot be scrolled any further, the focus loops back to the other side instead of moving outside of it, either by focusing or scrolling depending on what is available.
</p>

<p>
しかしながら、~focusは［
逐次的~navi／
~mouseによるヤリトリ ／
`focus()$m を~program的に~callする
］などにより，依然として外側へ移動できる。
◎
However, the focus can still be moved outside by sequential navigation, mouse interaction, or programmatic calls to focus()…
</p>

<pre>
document.addEventListener('navnotarget', function(%e) {
    %e.preventDefault();

    const %container = %e.relatedTarget;
    const %areas = %container.focusableAreas({mode: 'all'});

    if (%areas.length === 0) {
        switch (%e.dir) {
            case 'down':
                %container.scrollTop = 0;
                break;
            case 'up':
                %container.scrollTop = container.scrollHeight;
                break;
            case 'right':
                %container.scrollLeft = 0;
                break;
            case 'left':
                %container.scrollLeft = container.scrollWidth;
                break;
        }
    } else {
        const %target = %container.spatialNavigationSearch({
            dir: %e.dir,
            candidates: %areas
        });
        %target.focus();
    }
});
</pre>

</div>

		</section>
	</section>
	<section id="events-navigationevent" class="api">
<h2 title="Navigation Events">6. ~navi~event</h2>

		<section id="interface-focusevent">
<h3 title="Interface NavigationEvent">6.1. ~interface `NavigationEvent^I</h3>

<p>
`NavigationEvent$I ~interfaceは、空間的~naviに特有の文脈~上の情報を供する。
◎
The NavigationEvent interface provides specific contextual information associated with spatial navigation.
</p>

<p>
`NavigationEvent$I ~interfaceの~instanceを作成するときは、
`NavigationEvent$I 構築子を利用する
— `NavigationEventInit$I 辞書（省略可）を渡して。
◎
To create an instance of the NavigationEvent interface, use the NavigationEvent constructor, passing an optional NavigationEventInit dictionary.
</p>

<pre class="idl">
[`Exposed$=Window,
  `NavigationEvent@mC(`DOMString$ %type, optional `NavigationEventInit$I %eventInitDict)]
interface `NavigationEvent@I : `UIEvent$I {
    readonly attribute `SpatialNavigationDirection$I `dir@m;
    readonly attribute `EventTarget$I? `relatedTarget@m;
};

dictionary `NavigationEventInit@I : `UIEventInit$I {
    `SpatialNavigationDirection$I `dir@nEI;
    `EventTarget$I? `relatedTarget@nEI = null;
};
</pre>

		</section>
		<section id="events-nav-type">
<h3 title="Navigation Event Types">6.2. ~navi~event型</h3>

<p>
`この節とその下位節は規範的でない。^em
◎
This section and its subsections are not normative.
</p>

<p>
~navi~event型は、以下に要約される。
規範的かつ全部的な詳細は、
<a href="#processing-model">§ 処理~model</a>
を見よ。
◎
The Navigation event types are summarized below. For full normative details, see §8 Processing Model.
</p>

			<section id="event-type-navbeforefocus">
<h4 title="navbeforefocus">6.2.1. `navbeforefocus^et</h4>

<p>
`navbeforefocus@et
~eventは、空間的~naviにより~focusが変化する前に生じる。
◎
The navbeforefocus event occurs before spatial navigation changes the focus.
</p>

◎イ型 `navbeforefocus^et
◎界面 `NavigationEvent$I
◎浮上 する
◎取消 可
◎文脈

<p>
`NavigationEvent$I の：
</p>

<ul>
	<li>
`relatedTarget$m
⇒
~focusされることになる`~focus可能な区画$の`~DOM~anchor$。
</li>
	<li>
`dir$m
⇒
利用者から要請された~naviの方向。
</li>
</ul>

◎
The DOM anchor of the focusable area that will be focused
◎
The direction of the navigation as requested by the user
◎表終

<div class="example">

<p>
この例は、 `ArrowRight$kY ~keyを~pressしたときの`~event序列$を示す。
記述を単純に保つため、この例の空間的~naviは，矢印~keyを利用して誘発されるものと見做す。
◎
This example shows the UI Events §event-order when pressing the ArrowRight key. For the sake of keeping the description simple, this example assumes a User Agent where spatial navigation is triggered using arrow keys.
</p>

<table class="complex data">

<thead>

<tr><th>
<th>~event型
<th>`KeyboardEvent$I.`key$m
<th>備考
</thead>

<tbody>

<tr><td>1
<td>`keydown$et
<td>`ArrowRight$kY
<td>
矢印~keyなどの，空間的~naviを作動化できる~keyでなければナラナイ。
他の場合、空間的~naviは作動化されない。
◎
MUST be a key which can activate spatial navigation, such as the arrow keys, or spatial navigation is not activated.

<tr><td>2
<td>`navbeforefocus$et
<td>
<td>
空間的~navi用の候補が無い【！ is not null】の場合に送信される。
他の場合、これは生成されない。
◎
Sent if the candidates for spatial navigation is not null, or this is not generated.

<tr><td>3
<td>`focusin$et
<td>
<td>
標的~要素が~focusを受取る前に送信される。
◎
Sent before the target element receives focus.

<tr><td>4
<td>`focus$et
<td>
<td>
標的~要素が~focusを受取った後に送信される。
◎
Sent after the target element receives focus.

</tbody></table>

</div>

			</section>
			<section id="event-type-navnotarget">
<h4 title="navnotarget">6.2.2. `navnotarget@et</h4>

<p>
`navnotarget$et ~eventは、空間的~naviが［
現在の`空間的~navi容器$の中の候補を見出すのに失敗した ／
`空間的~navi容器$は~scroll可能である所で更に~scrollできない
］とき，［
先祖の`空間的~navi容器$のうち最も近いもの内で候補たちを探索する
］ために木を遡ろうとする前に生じる。
◎
The navnotarget event occurs before going up the tree to search candidates in the nearest ancestor spatial navigation container when spatial navigation has failed to find any candidate within the current spatial navigation container, and in cases where the spatial navigation container is scrollable, when it cannot be scrolled further.
</p>

◎イ型 `navnotarget$et
◎界面 `NavigationEvent$I
◎浮上 する
◎取消 可
◎文脈

<p>
`NavigationEvent$I の：
</p>

<ul>
	<li>
`relatedTarget$m
⇒
~~内部が探索された`空間的~navi容器$。
</li>
	<li>
`dir$m
⇒
利用者から要請された~naviの方向。
</li>
</ul>
◎
The spatial navigation container that was searched in.
◎
The direction of the navigation as requested by the user
◎表終

<div class="example">

<p>
この例は、次の図の様な状況において
`ArrowDown$kY ~keyが~pressされたときの`~event序列$を示す。
記述を単純に保つため、この例の空間的~naviは，矢印~keyを利用して誘発されるものと見做す。
◎
This example shows the UI Events §event-order when pressing the ArrowDown key in the situation like the following figure. For the sake of keeping the description simple, this example assumes a User Agent where spatial navigation is triggered using arrow keys.
</p>

<figure>`navnotarget-example-1^dgm
<figcaption>
`~scroll容器$内に候補が無いときに、~focusを移動する様子。
◎
Moving focus when there isn’t any candidate in the scroll container.
</figcaption></figure>

<table class="complex data">
<thead><tr><th>
<th>~event型
<th>~event標的
<th>`relatedTarget^m
<th>備考
</thead>

<tbody>
<tr><td>1
<td>`keydown$et
<td>`#box2^c
<td>N/A
<td>
矢印~keyなどの空間的~naviを作動化できる~keyでなければナラナイ。
他の場合、空間的~naviは誘発されない。
◎
MUST be a key which can activate spatial navigation, such as the arrow keys, otherwise spatial navigation is not triggered.

<tr><td>2
<td>`navnotarget$et
<td>`#box2^c
<td>`#scrollContainer^c
<td>
`#scrollContainer^c が候補を包含しないかつ~scrollできない場合に送信される。
他の場合、これは生成されない。
◎
Sent if #scrollContainer doesn’t contain any candidate and cannot be scrolled, otherwise this would not be generated.

<tr><td>3
<td>`navbeforefocus$et
<td>`#box2^c
<td>`#box3^c
<td>
`#container^c 内に候補が無い【！ is not null】場合に送信される。
他の場合、これは発火されない。
◎
Sent if the candidates in #container is not null, otherwise this would not be fired.

<tr><td>4
<td>`focusin$et
<td>`#box3^c
<td>N/A
<td>
標的~要素が~focusを受取る前に送信される。
◎
Sent before the target element receives focus.

<tr><td>5
<td>`focus$et
<td>`#box3^c
<td>N/A
<td>
標的~要素が~focusを受取った後に送信される。
◎
Sent after the target element receives focus.
</tbody></table>

<p>
この例の結果は、次のような図になる：
◎
The result of this example is the figure as follows:
</p>

<figure>
`navnotarget-example-2^dgm
<figcaption>
`~scrollport$内に候補が無く，`~scroll容器$も~scrollできないときには、~focusを移動する結果になる。
◎
The result of moving focus when there isn’t any candidate in the scrollport and scroll container cannot be scrolled.
</figcaption></figure>

<p>
この例では、次の~markupが利用されている：
◎
This example uses the markup as follows:
</p>

<pre class="lang-css">
#container {
    width: 900px;
    height: 1400px;
}

#scrollContainer {
    width: 700px;
    height: 700px;
    overflow-x: hidden;
    overflow-y: auto;
}

.item {
    width: 150px;
    height: 110px;
    background-color: blue;
}

.item:focus {
    background-color: red;
}
</pre>

<pre class="lang-html">
&lt;div id="container"&gt;
    &lt;div id="scrollContainer"&gt;
        &lt;div id="box1" class="item" tabindex="0"&gt;Box 1&lt;/div&gt;
        &lt;div id="box2" class="item" tabindex="0"&gt;Box 2&lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="box3" class="item" tabindex="0"&gt;Box 3&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

			</section>
		</section>
	</section>
	<section id="policy-feature">
<h2 title="The navigation-override policy-controlled feature">7. ~navi上書き 施策により制御される特能</h2>

<p>
`~navi上書き@
は，`施策により制御される特能$であり、［
頁~作者が［
空間的~naviの挙動に対する制御を司る／空間的~naviを即座に取消す
］ことを可能化する仕組み
］の可用性を制御する。
◎
The navigation-override policy-controlled feature controls the availability of mechanisms that enables page authors to take control over the behavior of spatial navigation, or to cancel it outright.
</p>

<ul>
	<li>
この特能の名前は、`navigation-override^l とする。
◎
The feature name is "navigation-override"
</li>
	<li>
`~navi上書き$用の`既定の許容list$は、 `'self'^l とする。
◎
The default allowlist for navigation-override is "self"
</li>
</ul>

<p>
`§ ~navi$にて更なる詳細が定義されるように、
ある文書~内で`~navi上書き$が不能化された場合、~navi~event（
<a href="#events-navigationevent">§ ~navi~event</a>
を見よ）は発火されないことになる。
◎
As defined in further details in §8.2 Navigation, if navigation-override is disabled in a document, the navigation events (see §6 Navigation Events) will not be fired.
</p>

<p class="note">注記：
これは、敵対的な~iframeがこれらの~eventを利用して~focusを乗取ることを防止する。
空間的~navi以前に、悪意的な作者が［
~focusがどこへ行くか制御する，利用者の能
］に干渉することにも利用できるような他の仕組みが存在することは認識されている。
にもかかわらず、この攻撃~面を増やさない試みに~~価値はあると見受けられる
— そのような攻撃は、この試みを~~無為にするほど，すでに容易に遂行することがアリだが。
この論題に対し，実装の経験やそのような攻撃の軽減-法に基づく更なる~feedbackがあれば、ぜひ寄せてほしい。
◎
Note: This is to prevent a hostile iframe from using these events in order to highjack the focus. We recognize that there exist other mechanisms predating spatial navigation that malicious authors could use to interfere with the user’s ability to control where the focus goes. Despite that, it seems worthwhile to attempt not to increase this attack surface, although it is possible that such attacks are already sufficiently easy to perform that this is a lost cause. Further feedback on this topic, based on experience with implementation or with mitigating such attacks, is very welcome.
</p>

	</section>
	<section id="processing-model">
<h2 title="Processing Model">8. 処理~model</h2>

<div class="verbose">

<p>
<a href="#overview">§ 概観</a>
では、空間的~naviがどう働くか, および
この仕様の読者が頭の中に一般的な~modelを築き易くするための，高~levelな案を与えた。
それは，直感的だが精確でない各種用語を利用し、可読性のため多くの詳細を伏せていた。
◎
The §3 Overview section gives a high level idea of how spatial navigation works, to help readers of this specification build a general mental model. It uses intuitive but imprecise terminology, and glosses over many details for the sake of readability.
</p>

<p>
この節では、対応する規範的な挙動を定義し，その挙動を全部的に定義するために必要とされる詳細を与えることを目指す。
◎
This section defines the corresponding normative behavior and aims for as much detail as necessary to fully define the behavior.
</p>

</div>

<p class="issue">
<a href="https://github.com/WICG/overscroll-behavior">`overscroll-behavior^p 仕様</a>†
が現在~提案されているが、以下のものは，まだ それを織り込んでいない。
`3376$issue
【†現在は、<a href="~CSSOVERSCROLL">草案</a>として仕様~化されている。】
◎
The following currently does not account for the proposed overscroll-behavior specification. &lt;https://github.com/w3c/csswg-drafts/issues/3376&gt;
</p>

		<section id="grouping">
<h3 title="Groupings of elements">8.1. 要素の~group化</h3>

<p>
空間的~navi用の一般~modelは［
文書の~layout, ~focus可能な要素の相対的~位置
］から働くが、~UAには，局所的かつ論理的な~group化から優先的に要素を見出すことが要求される
— ~group化の内側で探してから、相応しいものを見出せなかったときに限り，外側で~focus可能な要素を探すように（詳細は`§ ~navi$を見よ）。
◎
While the general model for spatial navigation is to work from the layout of the document and the relative position of focusable elements, the User Agent is required to prioritize finding elements from a local logical grouping, only looking for focusable elements outside of the grouping if a suitable one cannot be found inside it (see §8.2 Navigation for details).
</p>

<p>
そのような~group化は、
`空間的~navi容器@
と呼ばれる。
◎
Such groupings are called spatial navigation containers.
</p>

<p>
既定では、`空間的~navi容器$は，次により確立される：
◎
By default, spatial navigation containers are established by:
</p>

<ul>
	<li>
`閲覧文脈$の表示域（`~top-level閲覧文脈$に制限されない）
◎
The viewport of a browsing context (not limited to the top-level browsing context)
</li>
	<li>
`~scroll容器$
◎
scroll containers
</li>
</ul>

<p class="cssapi">
`spatial-navigation-contain$p ~propを利用すれば、`空間的~navi容器$を追加的に作成できる
（
<a href="#container">§ 追加的な空間的~navi容器の作成-法</a>
を見よ）。
◎
Additional spatial navigation containers can be created using the spatial-navigation-contain property (see §9.1 Creating additional spatial navigation containers: the spatial-navigation-contain property).
</p>

		</section>
		<section id="nav">
<h3 title="Navigation">8.2. ~navi</h3>

<figure class="verbose non-normative">

<figcaption>
次の図は、規範的でない。
それは、この節に定義される更なる処理~modelの概観を与える
— `spatial-navigation-action$p ~propは初期~値 `auto$v をとると見做す下で。
◎
This figure is not normative. It gives an overview of the processing model further defined in this section, assuming that the spatial-navigation-action property has its initial value of auto.
</figcaption>
<p class="trans-note">【
下の`空間的~navi手続き$の概略的な流れ図。
この図は未訳なので、
<a href="~CSSWG/css-nav-1/images/spatnav_processing_model_diagram.svg">原文の図式</a>
を参照されたし。
】</p>
【！spatnav_processing_model_diagram】
</figure>

<p>
`空間的~navi始点@
は、初期~時には ε （未設定）とする。
~UAは、利用者がそれを移動するベキと指示したときには，何かに設定してもヨイ。
◎
There can be a spatial navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>

<p class="note">注記：
例えば~UAは、［
利用者が文書~内容~上で~clickしたときは ~clickした位置に設定する ／
（空間的~naviその他の手段により）~focusが移動されたときは ε に設定する
］こともできる。
◎
Note: For example, the user agent could set it to the position of the user’s click if the user clicks on the document contents, and unset when the focus is moved (by spatial navigation or any other means).
</p>

<p>
~UAは、［
`空間的~navi始点$,
`逐次的~focus~naviの始点$
］両者とも【非 ε に？】設定する場合，それらを同じ値に設定するモノトスル。
◎
If the User Agent sets both a spatial navigation starting point and a sequential focus navigation starting point, they must not be set differently.
</p>

<div class="algorithm">

<p>
`空間的~navi手続き@
は、所与の
( %方向 )
に対し，次を走らす：
◎
To run the spatial navigation steps in direction, do the following:
</p>

<ol>
	<li>
%探索~起点 ~LET `~top-level閲覧文脈の現在の被focus区画$の`~DOM~anchor$
◎
Let searchOrigin be the DOM anchor of the currently focused area of a top-level browsing context.
</li>
	<li>
~IF［
`空間的~navi始点$ ~NEQ ε【！~NULL】
］~AND［
`空間的~navi始点$は %探索~起点 の内側にある
］
⇒
%探索~起点 ~SET `空間的~navi始点$
◎
If the spatial navigation starting point is not null and it is inside searchOrigin then set searchOrigin to the spatial navigation starting point.
</li>
	<li>
%~event標的 ~LET %探索~起点
◎
↓</li>
	<li>
<p>
~IF［
%探索~起点 は`~node$でない（位置である）
］
⇒
%~event標的 ~SET %探索~起点 を包含する`~node$
</p>

<p class="trans-note">【
“位置” とは、上の注記（~clickした位置）を意図していると見受けられる。
】【
%~event標的 は~text~nodeにもなり得ることになる（どの~nodeも `EventTarget$I を実装する）。
】</p>

◎
If searchOrigin is an node, let eventTarget be searchOrigin
◎
else (assert: searchOrigin is a position) let eventTarget be the node which contains searchOrigin
</li>
	<li>
%文書 ~LET %~event標的 の`~node文書$
◎
↓</li>
	<li>
~IF［
%~event標的 は［
`文書$／`文書~要素$
］である
］
⇒
%~event標的 ~SET ［
%文書 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %文書 の`文書~要素$
］
◎
If eventTarget is the Document or the document element, set eventTarget be the body element if it is not null or to the document element otherwise.
</li>
	<li>
~IF［
%探索~起点 は`手動で~scrollできる$
【！ 不要：%探索~起点 は`~scroll容器$である】
］~AND［
%探索~起点 上の `spatial-navigation-action$p ~propの算出d値 ~EQ `scroll$v
］
⇒＃
`要素をある方向へ~scrollする$( %探索~起点, %方向 )；
~RET
◎
If searchOrigin is scroll container and the computed value of the spatial-navigation-action property on searchOrigin is scroll and searchOrigin can be manually scrolled, then directionally scroll the element searchOrigin and return.
</li>
	<li>
<p>
~IF［
%探索~起点 は［
`~scroll容器$ ／ `文書$
］である
］：
◎
Else, if searchOrigin is either a scroll container or the document
<p>
		<ol>
			<li>
%候補たち ~LET `要素の中で~focus可能な区画を見出す$( %探索~起点,
［
%探索~起点 上の `spatial-navigation-action$p ~propの算出d値 ~EQ `focus$v
ならば ~F ／
~ELSE_ ~T
］ )
◎
Let candidates be the result of finding focusable areas within searchOrigin with the argument set to false if computed value of the spatial-navigation-action property on searchOrigin is focus or to true otherwise.
</li>
			<li>
<p>
~IF［
%候補たち は空でない
］：
◎
If candidates contains at least 1 item:
<p>
				<ol>
					<li>
%最良の候補 ~LET
`最良の候補を選定する$( %候補たち, %方向, %探索~起点 )
◎
Let bestCandidate be the result of selecting the best candidate within candidates in direction starting from searchOrigin
</li>
					<li>
<p>
~IF［
`文書~内の特能は生成元~用に可能化されるか？$(
`navigation-override$l,
%文書,
`~top-level閲覧文脈$にて`作動中の文書$の`生成元$
) ~EQ `可能化される^i
］：
◎
If navigation-override is enabled in the node document of eventTarget for the origin of the active document of the top-level browsing context, then＼
<p>
						<ol>
							<li>
%~event標的 に向けて名前 `navbeforefocus$et の`~eventを発火する$
— `NavigationEvent$I を利用して，次のように初期化して
⇒＃
`dir$m ~SET %方向,
`relatedTarget$m ~SET %最良の候補,
`bubbles^m 属性 ~SET ~T,
`cancelable^m 属性 ~SET ~T
◎
fire an event named navbeforefocus at eventTarget using NavigationEvent with:
• dir set to direction
• relatedTarget set to bestCandidate
• the bubbles and cancelable attributes set to true
</li>
							<li>
~IF［
前~段の結果 ~EQ ~F
］
⇒
~RET
◎
and return if the result is false.
</li>
						</ol>
					</li>
					<li>
`~objを~focusする$( %最良の候補 )
◎
Run the focusing steps for bestCandidate and＼
</li>
					<li>
~RET
◎
return
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~event標的 上の `spatial-navigation-action$p ~propの算出d値 ~NEQ `focus$v
］~AND［
%~event標的 は`手動で~scrollできる$
］：
</p>
				<ol>
					<li>
`要素をある方向へ~scrollする$( %~event標的, %方向 )；
</li>
					<li>
~RET
</li>
				</ol>
◎
Else if the computed value of the spatial-navigation-action property on eventTarget is not focus and eventTarget can be manually scrolled, then directionally scroll the element eventTarget in direction and return.
◎
Else, fallback to the next step.
</li>
		</ol>
	</li>
	<li>
%容器 ~LET ［
%~event標的 の先祖である`空間的~navi容器$のうち， %~event標的 に最も近いもの
］
◎
Else, fallback to the next step.
◎
Let container be the nearest ancestor of eventTarget that is a spatial navigation container.
</li>
	<li>
%候補たち ~LET ε
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
◎
Loop:＼
</p>
		<ol>
			<li>
%可視のみ ~LET %容器 上の `spatial-navigation-action$p ~propの算出d値に応じて
⇒＃
`focus$v ならば ~F ／
~ELSE_ ~T
◎
↓</li>
			<li>
%候補たち ~SET `要素の中で~focus可能な区画を見出す$( %容器, %可視のみ )
【！excluding searchOrigin 不要？】
◎
Let candidates be the result of finding focusable areas within container with the argument set to false if computed value of the spatial-navigation-action property on container is focus or to true otherwise, excluding searchOrigin
</li>
			<li>
~IF［
%候補たち は空でない
］
⇒
~BREAK
◎
If candidates is empty:
</li>
			<li>
<p>
~IF［
%可視のみ ~EQ ~T
］~AND［
%容器 は`手動で~scrollできる$
【！不要`~scroll容器$である】
］：
</p>
				<ol>
					<li>
`要素をある方向へ~scrollする$( %容器, %方向 )；
</li>
					<li>
~RET
</li>
				</ol>
◎
If the computed value of the spatial-navigation-action property on container is not focus and container is a scroll container that can be manually scrolled, directionally scroll the element container in direction and return.
◎
Else,
</li>
			<li>
<p>
~IF［
`文書~内の特能は生成元~用に可能化されるか？$(
`navigation-override$l,
%~event標的 の`~node文書$,
`~top-level閲覧文脈$にて`作動中の文書$の`生成元$
) ~EQ `可能化される^i
］：
◎
If navigation-override is enabled in the node document of eventTarget for the origin of the active document of the top-level browsing context, then＼
<p>
				<ol>
					<li>
%~event標的 に向けて名前 `navnotarget$et の`~eventを発火する$
— `NavigationEvent$I を利用して，次のように初期化して
⇒＃
`dir$m ~SET %方向,
`relatedTarget$m ~SET %容器,
`bubbles^m 属性 ~SET ~T,
`cancelable^m 属性 ~SET ~T
◎
• dir set to direction
• relatedTarget set to container
• the bubbles and cancelable attributes set to true
◎
fire an event named navnotarget at eventTarget using NavigationEvent with:
</li>
					<li>
~IF［
前~段の結果 ~EQ ~F
］
⇒
~RET
◎
and return if the result is false.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%容器 は`文書~要素$である
］：
</p>
				<ol>
					<li>
%B ~LET %容器 の`~node文書$が`属する閲覧文脈$
</li>
					<li>
~IF［
%B は`~top-level閲覧文脈$である
］
⇒
~RET
— ~UAは、 %方向 を尊守しつつ，自前の~controlがあれば ~focusをそこへ転送してもヨイ。
</li>
					<li>
%探索~起点 ~SET %B を`入子にしている閲覧文脈~容器$
</li>
					<li>
%~event標的 ~SET %探索~起点
</li>
					<li>
%容器 ~SET %探索~起点
</li>
				</ol>
◎
If container is the document element of the top-level browsing context, then return. The User Agent may transfer focus to its own controls (if any) honouring direction.
◎
Else, if container is the document element of a nested browsing context then:
• Set searchOrigin to container’s browsing context container
• Set eventTarget be searchOrigin
• Set container to the nearest ancestor of searchOrigin that is a spatial navigation container.
• Return to the step labeled loop.
</li>
			<li>
%容器 ~SET %容器 の先祖である`空間的~navi容器$のうち %容器 に最も近いもの
◎
Else, set container to its closest ancestor that is itself a spatial navigation container and return to the step labeled loop.
</li>
		</ol>
	</li>
	<li>
%最良の候補 ~LET
`最良の候補を選定する$( %候補たち, %方向, %探索~起点 )
◎
Let bestCandidate be the result of selecting the best candidate within candidates in direction starting from searchOrigin.
</li>
	<li>
<p>
~IF［
`文書~内の特能は生成元~用に可能化されるか？$(
`navigation-override$l,
%~event標的 の`~node文書$,
`~top-level閲覧文脈$にて`作動中の文書$の`生成元$
) ~EQ `可能化される^i
］：
◎
If navigation-override is enabled in the node document of eventTarget for the origin of the active document of the top-level browsing context, then＼
<p>
		<ol>
			<li>
%~event標的 に向けて名前 `navbeforefocus$et の`~eventを発火する$
— `NavigationEvent$I を利用して，次のように初期化して
⇒＃
`dir$m ~SET %方向,
`relatedTarget$m ~SET %最良の候補,
`bubbles^m 属性 ~SET ~T,
`cancelable^m 属性 ~SET ~T
◎
fire an event named navbeforefocus at eventTarget using NavigationEvent with:
• dir set to direction
• relatedTarget set to bestCandidate
• the bubbles and cancelable attributes set to true
</li>
			<li>
~IF［
前~段の結果 ~EQ ~F
］
⇒
~RET
◎
and return if the result is false.
</li>
		</ol>
	</li>
	<li>
`~objを~focusする$( %最良の候補 )
◎
Run the focusing steps for bestCandidate and return.
</li>
</ol>

</div>

		</section>
		<section id="heuristics">
<h3 title="Focus Navigation Heuristics">8.3. ~focus~naviの経験則</h3>

<p class="note">注記：
次の~algoは、 Chrome の実装, および
<a href="https://www.w3.org/TR/WICD/#focus-handling">旧 WICD 仕様</a>
から着想されている。
これらの~approachより良い~approachや精緻化を見出した実装者には
— この仕様の改善を~~促して，相互運用能を最大化するため —
~feedbackを供することが強く奨励される。
特に，~UAが`要素の中で~focus可能な区画を見出す$方法に分岐があると、何らかの要素が~focus可能かどうかが~UAごとにまちまちになり，利用者にとって不都合になる。
◎
Note: The following algorithms are inspired from Chrome’s implementation as well as from the old WICD Spec. Implementors who find better approaches or refinements to these approaches are strongly encouraged to provide feedback and help improve this specification in order to maximize interoperability. In particular, divergences in how User Agents find focusable areas may cause some elements to be focusable in some User Agents but not in others, which would be bad for users.
</p>

<p>
この節における幾何-演算は、すべて，~CSS~layoutの結果に対し働くよう定義される
— `相対~位置決め$や `CSS-TRANSFORMS-1$r などの すべての~graphic的な変形nも含めて。
◎
All geometrical operations in this section are defined to work on the result of CSS layout, including all graphical transformations, such as relative positioning or [CSS-TRANSFORMS-1].
</p>

<p>
~objの
`境界~box@
は、~objに応じて，次に従って定義される：
◎
The boundary box of an object is defined as follows:
</p>

<ul>
	<li>
~objは~pointである場合
⇒
その~point
◎
if the object is a point, the boundary box is that point
</li>
	<li>
~objは［
`~box$／`~box断片$
］である場合
⇒
~objの`~border~box$
◎
if the object is a box or box fragment, the boundary box is the border box of that box or fragment.
</li>
	<li>
~objは`~focus可能な区画$であって要素でない場合
⇒
~objの限界~box
— その各~辺は軸に平行な
◎
if the object is a focusable area which is not an element, the boundary box is the axis-aligned the bounding box of that focusable area
</li>
</ul>

<p class="issue">
~CSSには
“`border-radius^p の様な隅~形状付け~propを織り込んだ~border~box”
用の用語があるベキである。
`2324$issue
◎
CSS should have a term for “border box taking into account corner shaping properties like border-radius”. &lt;https://github.com/w3c/csswg-drafts/issues/2324&gt;
</p>

<div class="algorithm">

<p>
`要素の中で~focus可能な区画を見出す@
ときは、所与の
( 要素 %C, 真偽値 %可視のみ （省略時は ~T ）)
に対し，次の手続きを走らす：
◎
To find focusable areas within a containing element C, with an optional visibleOnly argument that defaults to true, run the following steps:
</p>

<ol>
	<li>
%~focus可能~集合 ~LET ［
`~focus可能な区画$のうち，その`~DOM~anchor$は %C の子孫であるもの
］からなる`有順序~集合$
— ただし、`~box$が何個かの`~box断片$からなる事例では，各`~box断片$を別個のものと見なす。
◎
Let focusables be the set of all the focusable areas whose DOM anchor are descendants of C. In the case of boxes with several box fragments, each box fragment is considered separately.
</li>
	<li>
<p>
~UAは、次を行うベキである
⇒
%~focus可能~集合 から次を満たす~itemを`除去する$
⇒
~itemの`~DOM~anchor$の `tabindex$a 属性は負の値に設定されている
◎
The User Agent should remove from focusables items that have a DOM anchor whose tabindex attribute is set to a negative value.
<p>

<p class="note">注記：
これが、 “ベキ” とされているのは、`逐次的~focus~navi順序$からの［
負の~tabindexを伴う要素の除外
］を~~反映するためである。
`HTML$r の `tabindex^a にて定義されるように
【`~tabindex値$を見よ】
。
◎
Note: This is a "SHOULD" in order to mirror the exclusion of elements with negative tabindex from the sequential focus navigation order as defined in HTML Standard §attr-tabindex.
</p>

	</li>
	<li>
<p>
~IF［
%可視のみ ~EQ ~F
］
⇒
~RET %~focus可能~集合
◎
If visibleOnly is false, return focusables.
<p>

<p class="note">注記：
%~focus可能~集合 は空になることもある。
◎
Note: focusables may be empty
</p></li>
	<li>
%内側~区画 ~LET %C に応じて
⇒＃
`~scroll容器$であるならば %C の`最適な~view用~領域$／
~ELSE_ `文書$であるならば %C の`閲覧文脈$の表示域 ／
~ELSE_ %C の`~border~box$
◎
Let insideArea be
• the optimal viewing region of C if C is a scroll container,
• the viewport of C’s browsing context if C is a Document,
• the border box of C otherwise.
</li>
	<li>
<p>
%可視~集合 ~LET %~focus可能~集合 から次に該当する~itemは除去する
⇒
その`境界~box$は %内側~区画 の中に一部でも入らないもの
◎
Let visibles be the subset of items in focusables whose boundary box is at least partly within insideArea.
<p>

<p class="advisement non-normative">
~scroll容器~内で現在~可視でない要素は除き、空間的~naviは，~clickできない要素
— 例えば，他の要素により遮られていることに因り —
を自動的に除外しない。
［
利用者が そのような要素を実際に~focusして作動化した場合に，~app~logicにおける前提を壊すのを避ける
］ため，および［
不可視あるいは外見的に到達-不能な要素に~focusして，利用者を惑わすのを避ける
］ためには、作者は［
要素を逐次的~naviから到達-不能にするのと同じ最善の実施
］を利用して，これらの要素を空間的~naviから到達-不能にするベキである
— `tab-index="-1"^c や `inert$a 属性 などを利用して。
◎
Except for elements that are in the currently non visible part of a scroller, spatial navigation does not automatically exclude elements which cannot be clicked on, for example due to being obscured by some other element. To avoid breaking assumptions in the application logic if a user actually focuses and activates such an element, and to avoid confusing users by focusing invisible or apparently unreachable elements, authors should use make these elements unreachable to spatial navigation using the same best practices as for making elements unreachable to sequential navigation, such as using tab-index="-1" or the inert attribute.
</p>

	</li>
	<li>
<p>
~RET %可視~集合
◎
Return visibles.
<p>

<p class="note">注記：
%可視~集合 は空になることもある。
◎
Note: visibles may be empty
</p></li>
</ol>

</div>

<div class="algorithm">

<p>
`最良の候補を選定する@
ときは、所与の
( `有順序~集合$ %候補たち, 方向 %方向, %探索~起点 )
に対し，次の手続きを走らす：
◎
To select the best candidate within a set of candidates in a direction dir, starting from searchOrigin, run the following steps:
</p>

<ol>
	<li>
~IF［
%候補たち は`空$である
］
⇒
~RET ~NULL
◎
If candidates is empty, return null
</li>
	<li>
~IF［
%候補たち は 1 個の~itemのみからなる
］
⇒
~RET その~item
◎
If candidates contains a single item, return that item
</li>
	<li>
%内側~区画 ~LET %探索~起点 に応じて
⇒＃
`~scroll容器$であるならば %探索~起点 の`最適な~view用~領域$／
~ELSE_ `文書$であるならば表示域 ／
~ELSE_ %C の`~border~box$
◎
Let insideArea be
• the optimal viewing region of searchOrigin if searchOrigin is a scroll container,
• the viewport if searchOrigin is a Document,
• the border box of searchOrigin otherwise.
</li>
	<li>
<p>
%内側にあるものたち ~LET %候補たち を成す~itemのうち，次を満たすものからなる下位集合
⇒
［
その`~DOM~anchor$は %探索~起点 の子孫である
］~AND［
その`境界~box$は %方向 に応じて次を満たす
］：
◎
Let insiders be the subset of candidates items whose DOM anchor are descendants of searchOrigin and whose boundary box’s
<p>
		<ul>
			<li>
`down$l
⇒
上端~辺は %内側~区画 の上端~辺より下にある
◎
top edge is below the top edge of insideArea if dir is down
</li>
			<li>
`up$l
⇒
下端~辺は %内側~区画 の下端~辺より上にある
◎
bottom edge is above the bottom edge of insideArea if dir is up
</li>
			<li>
`left$l
⇒
右端~辺は %内側~区画 の右端~辺より左端にある
◎
right edge is left of the right edge of insideArea if dir is left
</li>
			<li>
`right$l
⇒
左端~辺は %内側~区画 の左端~辺より右端にある
◎
left edge is right of the left edge of insideArea if dir is right
</li>
		</ul>

<p class="note">注記：
この下位集合~化は、要請された方向の反対へ行くのを避けるために必要とされる。
◎
Note: this sub-setting is necessary to avoid going in the opposite direction than the one requested.
</p>
	</li>
	<li>
<p>
~IF［
%内側にあるものたち は空でない
］
⇒
◎
If insiders is non empty,
<p>

		<ol>
			<li>
<p>
%最も近いものたち ~LET 
%内側にあるものたち を成す~itemのうち［
その`境界~box$は %方向 に応じて次を満たすものからなる下位集合
］：
◎
Let closest subset be the subset of insiders whose boundary box’s
<p>

				<ul>
					<li>
`down$l
⇒
上端~辺は %内側~区画 の上端~辺に最も近い
◎
top edge is closest to the top edge of insideArea if dir is down
</li>
					<li>
`up$l
⇒
下端~辺は
%内側~区画 の下端~辺に最も近い
◎
bottom edge is closest to the bottom edge of insideArea if dir is up
</li>
					<li>
`left$l
⇒
右端~辺は
%内側~区画 の右端~辺に最も近い

◎
right edge is closest to the right edge of insideArea if dir is left
</li>
					<li>
`right$l
⇒
左端~辺は
%内側~区画 の左端~辺に最も近い
◎
left edge is closest to the left edge of insideArea if dir is right
</li>
				</ul>
			</li>
			<li>
%最も近いものたち から次を満たす~item %A をすべて除去する†
⇒
%最も近いものたち 内に別の~item %B が在って，次を満たす
⇒
［
%A, %B の`境界~box$は重合する
］~AND［
%A より %B の方が`~CSS塗ng順序$において上層にある
］
◎
If closest subset contains a single item, return that item, else return the first item of closest subset in document order, unless its boundary box overlaps with the boundary box of another item and that item is higher in the CSS painting order. In that case, return that item instead, unless it too is overlapped with another higher item, recursively.
</li>
			<li>
~RET %最も近いものたち 内の文書~順序で最初の~item
◎
↑</li>
		</ol>

<p class="trans-note">【†
原文の再帰を孕む記述は，解りにくい（そのまま訳すと条件の適用-順序が不明瞭になる）ので、この訳では等価に変形している。
下に現れる似た記述も同様。
】</p>

	</li>
	<li>
<p>
~ELSE：
◎
Else
<p>
		<ol>
			<li>
%候補たち から次を満たす~itemを除去する
⇒
~itemの`境界~box$の幾何的な中心は、次を満たす境界を伴う閉半平面の中にない
⇒
［
%探索~起点 の幾何的な中心を通る
］~AND［
%方向 に垂直
］
◎
Set candidates be the subset of its items whose boundary box’s geometric center is within the closed half plane whose boundary goes through the geometric center of the searchOrigin and is perpendicular to dir.
</li>
			<li>
%候補たち を成す
~EACH( %候補 )
に対し
⇒
%候補 の `距離^i ~SET `最短~距離を見出す$( %探索~起点, %候補, %方向 )
◎
For each candidate in candidates, find the shortest distance between searchOrigin and candidate in direction dir.
</li>
			<li>
%候補たち から次を満たす~itemをすべて除去する
⇒
%候補たち 内の別の~itemより `距離^i が長い
◎
Return the item of the candidates set that has the smallest distance.＼
</li>
			<li>
%候補たち から次を満たす~item %A をすべて除去する
⇒
%候補たち 内に別の~item %B が在って，次を満たす
⇒
［
%A, %B の`境界~box$は重合する
］~AND［
%A より %B の方が`~CSS塗ng順序$において上層にある
］
◎
If several have the same distance, return the first one in document order, unless its boundary box overlaps with the boundary box of an other item at the same distance, and that item is higher in the CSS painting order. In that case, return that item instead, unless it too is overlapped with another higher item at the same distance, recursively.
</li>
			<li>
~RET %候補たち 内の文書~順序で最初の~item
◎
↑</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">

<p>
`最短~距離を見出す@
ときは、所与の
( %基準, %候補, %方向 )
に対し，［
%基準 の境界~box ／ %候補 の境界~box
］の中にある~point［
%P1 ／ %P2
］を見出す
— 次に定義される %距離 を最小化するような
⇒
%距離 ~EQ %~euclidean距離 ~PLUS %転移 ~MINUS %整列 ~MINUS %重合する面積の平方根
◎
To find the shortest distance between a reference and a candidate in direction dir, find the points P1 and P2, respectively within the boundary boxes of the reference and of the candidate, that minimize the distance as defined as below:
• distance = euclidean + displacement - alignment - sqrt(Overlap)
</p>

<p>
各~項の意味は、以下に従う：
◎
The meaning of each term is as follows:
</p>

<dl class="def-list">
	<dt>%~euclidean距離</dt>
	<dd>
%P1 から %P2 までの~euclidean距離
◎
The euclidean distance between P1 and P2
</dd>

	<dt>%転移</dt>
	<dd>
［
%基準, %候補
］どうしの %方向 における転移の度合い【直交-方向におけるずれ】
⇒
%転移 ~EQ ( ( %方向 に直交する軸における %P1 から %P2 までの絶対-距離 )
~PLUS %直交-偏り ) ~MUL %直交-重み
◎
The degree of displacement in dir between the reference and the candidate, defined as
◎
displacement = (absolute distance on the axis orthogonal to dir between P1 and P2 + orthogonalBias) * orthogonalWeight
</dd>

	<dt>%直交-偏り</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
%基準 の限界~boxの縦幅 ~DIV 2 
</li>
			<li>
`up$l ／ `down$l
⇒
%基準 の限界~boxの横幅 ~DIV 2 
</li>
		</ul>

<p>
限界~boxの各~辺は、軸に平行とする
</p>

◎
If the dir is left or right, the height of the axis-aligned bounding box of reference / 2
◎
Else if the dir is up or down, the width of the axis-aligned bounding box of reference / 2
</dd>

	<dt>%直交-重み</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
30
</li>
			<li>
`up$l ／ `down$l
⇒
2
</li>
		</ul>

【この相違が何に由来するのかは不明。仮に，横組みにおける行の方向に起因するならば、縦組みの下では入れ替える必要があろう。】

◎
If the dir is left or right, 30
◎
Else if the dir is up or down, 2
</dd>

	<dt>%整列</dt>
	<dd>
%方向 における %基準, %候補 どうしの整列の度合い
⇒
%整列 ~EQ %整列-偏り ~MUL %整列-重み
◎
The degree of alignment in dir between the reference and the candidate, defined as:
• alignment = alignBias * alignWeight
</dd>

	<dt>%整列-偏り</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
%射影が重合する長さ ~DIV %基準 の限界~boxの縦幅
</li>
			<li>
`up$l ／ `down$l
⇒
%射影が重合する長さ ~DIV %基準 の限界~boxの横幅
</li>
		</ul>
<p>
限界~boxの各~辺は、軸に平行とする
</p>

◎
If the dir is left or right, projectedOverlap / height of the axis-aligned bounding box of reference
◎
Else if the dir is up or down, projectedOverlap / width of the axis-aligned bounding box of reference
</dd>

	<dt>%射影が重合する長さ</dt>
	<dd>
<p>
%方向 に応じて：
</p>
		<ul class="switch">
			<li>
`left$l ／ `right$l
⇒
［
%基準, %候補
］の横方向への射影が縦~軸~上で重合する長さ
</li>
			<li>
`up$l ／ `down$l
⇒
［
%基準, %候補
］の縦方向への射影が横~軸~上で重合する長さ
</li>
		</ul>
◎
If the dir is left or right, the length of the overlap between the horizontal projections onto the vertical axis of the reference and the candidate
◎
Else if the dir is up or down, the length of the overlap between the vertical projections onto the horizontal axis of the reference and the candidate
</dd>

	<dd>
<figure>`projected_overlap^dgm
<figcaption>
%射影が重合する長さ
◎
projectedOverlap
</figcaption></figure>
	</dd>

	<dt>%整列-重み</dt>
	<dd>5</dd>

	<dt>%重合する面積の平方根</dt>
	<dd>
%基準, %候補 が［
重合するならば その面積の平方根 ／
重合しないならば 0
］
◎
The square root of area of overlap between the reference and the candidate, or 0 if they do not overlap.
</dd>
</dl>

<p class="note">注記：
この一般~公式は、いくつかの，良さげな代替から選取られた
— 一連の
<a href="https://wicg.github.io/spatial-navigation/tests/ux/list.html">利用者~体験~test事例</a>
にて、最良の候補を選定するために利用されるとき，最も直感に合致するものに基づいて。
同様に，
%整列-重み, %直交-重み
の値も同じ~test事例に基づいて試験的に決定された。
結果の公式は、いくぶん複雑ではあるが，良い答えを与えるように見受けられる。
改善や単純~化の示唆があれば寄せてほしい。
◎
Note: This general formula was picked from several plausible alternatives, based on which one most often match intuition when used to select the best candidate in a series of UX test cases. Similarly, the values of alignWeight and orthogonalWeight were also determined experimentally based on the same test cases. The resulting formula is somewhat complicated, but seems to give good answers. Suggestions on improvements or simplifications are welcome.
</p>

</div>

		</section>
	</section>
	<section id="declarative">
<h2 title="Controlling spatial navigation through declarative means">9. 宣言的な手段による空間的~naviの制御-法</h2>

<div class="cssapi">

		<section id="container">
<h3 title="Creating additional spatial navigation containers: the spatial-navigation-contain property">9.1. 追加的な空間的~navi容器の作成-法： `spatial-navigation-contain^p ~prop</h3>

◎名 `spatial-navigation-contain@p
◎値 `auto^v | `contain$v
◎初 `auto^v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎順 文法に従う
◎ア 離散的
◎表終

<dl>
	<dt><dfn id="valdef-spatial-navigation-contain-auto">`auto^v</dfn></dt>
	<dd>
当の要素は`~scroll容器$である場合に限り，`空間的~navi容器$を確立する
◎
If the element is a scroll container then it establishes a spatial navigation container, otherwise it does not.
</dd>

	<dt>`contain@v</dt>
	<dd>
当の要素は`空間的~navi容器$を確立する
◎
The element establishes a spatial navigation container
</dd>
</dl>

<p class="note">注記：
加えて、<a href="#grouping">§ 要素の~group化</a>に従い，`閲覧文脈$（`~top-level閲覧文脈$に制限されない）の表示域も`空間的~navi容器$を確立する。
◎
Note: In addition, as per §8.1 Groupings of elements, the viewport of a browsing context (not limited to the top-level browsing context) also establishes a spatial navigation container.
</p>

<div class="example">

<p>
次の例は、単純~化された~TV番組表を示す。
それは、番組を表現している要素たちが成す格子があり，その周りにいくつか~UI~buttonを備える。
◎
The following example shows a simplified TV program schedule or calendar. It has a grid of elements representing TV shows or calendar entries, and some UI buttons around it.
</p>

<p>
この事例では，格子の中はスカスカである。
なので、利用者が "Foo" から~downへ移動しようと試行した場合、~focusは "次週" へ移動することになる
— それが~down方向において~~目的により近いので。
同じことは "Bar" から ~downへ行くときも該当し、~focusは "前週" へ移動することになる。
◎
In this case, the grid is quite sparse, so if the user tries to move down from "Foo", focus would be moved to "Next Week", as it is objectively closer in the down direction. The same is true for going down from "Bar": the focus would be moved to "Previous Week".
</p>

<div id="_ex-TV-program">
<button>前週</button>
<table><tbody><tr><td><th>月<th>火<th>水<th>~~木<th>金<th>土<th>日
  <tr><td>0 〜 6時<td><td><td><td><td><td><td><a href="#">Foo</a>
  <tr><td>6 〜 9時<td><a href="#">Bar</a><td><td><td><td><td><td>
  <tr><td>9 〜 12時<td><td><td><td><td><td><td>
  <tr><td>12 〜 18時<td><td><td><td><td><td><td>
  <tr><td>18 〜 21時<td><td><td><td><td><td><td>
  <tr><td>21 〜 24時<td><td><td><td><td><td><a href="#">Baz</a><td>
</tbody></table>
<button>次週</button>
</div>

<!-- 
same is true for going down from "Bar": the focus would be moved to "Previous Week".
	M 	T 	W 	T 	F 	S 	S
0-6 							Foo
6-9 	Bar 						
9-12 							
12-18 							
18-21 							
21-24 						Baz 	
-->

<pre>
&lt;div&gt;
&lt;button&gt;前週&lt;/button&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;th&gt;月&lt;th&gt;火&lt;th&gt;水&lt;th&gt;~~木&lt;th&gt;金&lt;th&gt;土&lt;th&gt;日
  &lt;tr&gt;&lt;td&gt;0 〜 6時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Foo&lt;/a&gt;
  &lt;tr&gt;&lt;td&gt;6 〜 9時&lt;td&gt;&lt;a href="#"&gt;Bar&lt;/a&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;9 〜 12時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;12 〜 18時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;18 〜 21時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;tr&gt;&lt;td&gt;21 〜 24時&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;a href="#"&gt;Baz&lt;/a&gt;&lt;td&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;button&gt;次週&lt;/button&gt;
&lt;/div&gt;
</pre>

<pre>
table, td, th {
    border-collapse: collapse;
    border: solid 1px;
}
td { width: 12.5%; }
div {
    display: grid;
    grid-template-columns: auto 1fr auto;
}
button { align-self: center; }
</pre>

<p>
~table内の要素たちは，互いに意味論的に関係するので、作者は，格子~内の~itemが~focusされたとき，格子の内側における動きの優先度を与えて，異なる~navi体験を供したいと求めることもあろう。
◎
Because the elements in the table are semantically related to each other, the author may want to provide a different navigation experience giving priority to movements inside the grid once you have focused one of its items.
</p>

<p>
~stylesheetに
`table { spatial-navigation-contain: contain; }^css
を追加すれば、結果は この挙動になる。
~focusを~tableの外へ移動することも，依然としてアリになる。
例えば， "Foo" から右へ行くことにより。
格子~内には右には何もないので，~focusは "次週" へ移動することになる。
◎
Adding table { spatial-navigation-contain: contain; } to the stylesheet would result this behavior. It would still be possible to move the focus out of the table, for example by going right from "Foo". Since there is nothing in the grid that is to the right, the focus would move to "Next week".
</p>

<p>
しかしながら，利用者が "Foo" から~downへ~navigateした場合、格子の内側に何かがあるので，~focusはそこへ移動することになる
— 外側にあるものを考慮することなく。
◎
However, if the user navigates down from "Foo", there is something inside the grid, so focus will move there without considering things that are outside.
</p>

</div>

<p class="note">注記：
`spatial-navigation-contain$p ~propは`~risk下$にある。
◎
Note: the spatial-navigation-contain property is at-risk.
</p>

</section></div>

		</section>
		<section id="css-property-spatialnavigationaction">
<h3 title="Controlling the interaction with scrolling: the spatial-navigation-action property">9.2. ~scrollingとの相互作用の制御-法： `spatial-navigation-action$p property</h3>

◎名 `spatial-navigation-action@p
◎値 `auto$v | `focus$v | `scroll$v
◎初 `auto^v
◎適 `~scroll容器$
◎継 されない
◎百 受容しない
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~focusが~scroll容器の内側にあって，
利用者が空間的~naviを誘発したとき、利用者が
— ~focusをその方向へ移動するのか, 文書をその方向へ~scrollするのか —
どちらを要請しているのか，いくぶん多義的になる。
これは，既定では自動的に決定されるが、この~propは，
~focusするのか, ~scrollするのか裁定することを作者に許容する。
◎
When the focus is inside of a scroll container and the user triggers spatial navigation, it is somewhat ambiguous whether they are requesting that the focus be moved in that direction, or whether the document should be scrolled in that direction. By default, this is automatically determined, but this property allows the author to decide between focusing or scrolling.
</p>

<p>
精確な挙動は`§ ~navi$に定義されるが、各~値による効果の高~levelな記述は下に供される。
◎
The precise behavior is defined in §8.2 Navigation, but a high level description of the effect of each value is provided below.
</p>

<p>
空間的~naviが誘発されたときの挙動は、［
現在~focusされている要素, またはその先祖
］のうち要素に最も近い`~scroll容器$の `spatial-navigation-action$p の値に依存する。
◎
When spatial navigation is triggered, the behavior depends on the value of the spatial-navigation-action on the currently focused element if that element is a scroll container, or of its nearest scroll container ancestor if it isn’t.
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
`~scroll容器$の中の要請された方向に，可視かつ~focus可能な要素が在る場合、それらのうち最も近いものが~focusされるようになる。
他の場合、`~scroll容器$は要請された方向へ~scrollされる。
◎
If there are visible focusable elements within the scroll container in the direction requested, the closest one becomes focused. Otherwise, the scroll container is scrolled in the direction requested.
</dd>

	<dt>`focus@v</dt>
	<dd>
`~scroll容器$の中【の要請された方向】に，~focus可能な要素が在れば
— それが可視かどうかに関わらず —
~focusは，それらのうち最も近いものへ移動される。
無い場合、~scroll容器は`~scrollされない^emことに加え、探索は先祖上の連鎖へ遡るように継続される。
◎
The focus is moved to the nearest focusable element within the scroll container, regardless of whether it is visible. If there are none, the scroll container is not scrolled, and the search continues up the ancestry chain instead.
</dd>
	<dd class="note">注記：
`~scroll容器$は、直には~scrollされない
— それまで~viewになかった要素を~focusすることによる副作用として，~scrollされることはあるが。
◎
Note: The scroll container may be scrolled as a side effect of focusing an element which was previously not in view, but it will not be scrolled directly.
</dd>
	<dd class="note">注記：
`spatial-navigation-action$p に `focus$v 値を与えた場合、`空間的~navi容器$の表示域の中で，所与の方向に可視な候補が無いときは， `navnotarget$et ~eventが生じる
— 当の容器をもっと~scrollできるときでも。
◎
Note: If the focus value is given to spatial-navigation-action, navnotarget event occurs when there isn’t any visible candidate in the given direction within the viewport of the spatial navigation container even if the container can be scrolled more.
</dd>

	<dt>`scroll@v</dt>
	<dd>
現在~focusされている要素が`~scroll容器$でない場合、先祖`~scroll容器$上のこの値は `auto$v と同じ効果になる。
◎
If the currently focused element is not itself a scroll container, this value on an ancestor scroll container has the same effect as auto.
</dd>
	<dd>
現在~focusされている要素が`~scroll容器$である場合、~focus可能な子孫の有無に関わらず，要請された方向に~scrollされ、どの要素が~focusされているかは変更しない。
◎
If the currently focused element is a scroll container, it is scrolled in the direction requested without changing which element is in focus, regardless of the presence of focusable descendants.
</dd>
	<dd class="note">注記：
このことは、［
~focusを`~scroll容器$へ移動して，そこへ~scrollしつつ、その子孫へは~focusを移動しない
］ことに，空間的~naviを利用できることを意味する。
しかしながら，~focusが他の何らかの手段（
`Tab$kY ~keyを~pressしたり， `focus()$m ~methodを利用するなど
）により子孫に移動された場合は、空間的~naviは，~focusを他の~focus可能な子孫へ移動することに利用され得る。
◎
Note: This means that spatial navigation can be used to move the focus to a scroll container and to scroll it, but not to move the focus to its descendants. However, if the focus is moved to a descendant by some other mean (such as pressing the Tab key or using the &lt;focus()&gt; method) spatial navigation can be used to move the focus to other focusable descendants.
</dd>
	<dd class="note">注記：
`scroll^v 値は`~risk下$にある。
◎
Note: The scroll value is at-risk.
</dd>
</dl>

<p class="note">注記：
この仕様の早期の~versionは、［
`focus$v により定義される挙動を任意選択で~~選ぶための宣言的な仕方
］を提供していなかった代わりに，作者がその挙動を自身で実装できるよう［
~scrollする前に発火される取消~可能な~event
］を提供していた。
しかしながら，~scrollingに関係する取消~可能な~eventは処理能の問題をもたらし得るので、この~eventは除去され，代わりに `spatial-navigation-action$p ~propが導入された。
◎
Note: Earlier version of this specification did not offer a declarative way to opt into the behavior defined by focus, and instead offered a cancellable event that would be fired before scrolling, so that authors could implement that behavior themselves. However, cancellable events related to scrolling can cause performance problems, so this event was removed and the spatial-navigation-action property was introduced instead.
</p>

<div class="example">

<p>
この例においては、ある~scroll可能な容器の `spatial-navigation-action$p に `focus^v が指定されている。
容器の内側には、`~scrollport$の中の~viewの外に要素がある。
~down矢印~keyを~pressすると，~focusは直にそこへ移動する
— 手動で~scrollしなくとも。
◎
In this example, a scrollable container is specified with spatial-navigation-action: focus. Inside the container, there is an element which is out of the view within a scrollport. Pressing the down arrow key moves the focus directly to it without scrolling manually.
</p>

<figure>`spatnav-action^dgm
<figcaption>
手動で~scrollすることなく，~focusを "Box 2" から "Box 3" へ移動する
◎
Moving focus from "Box 2" to "Box 3" without manually scrolling
</figcaption></figure>

<pre>
&lt;div class='scroller'&gt;
    &lt;button class='item'&gt;Box 1&lt;/button&gt;
    &lt;button class='item'&gt;Box 2&lt;/button&gt;
    &lt;button class='item'&gt;Box 3&lt;/button&gt;
&lt;/div&gt;
</pre>

<pre>
.scroller {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    height: 300px;
    width: 200px;
    overflow-y: scroll;
    spatial-navigation-action: focus;
}
.item {
    height: 100px;
    width: 100px;
    margin: 50px auto;
    background-color: blue;
}
:focus {
    background-color: red;
}
</pre>

</div>

	</section>
	<section id="scrolling">
<h2 title="Appendix A. Scroll extensions">付録 A. ~scroll拡張</h2>

<p>
この節は、~CSSに対する少数の拡張を提案する。
それは，上流~仕様に統合されるベキであるが、それまでは，ここに~hostされる。
◎
This section proposes a few extensions to CSS that should be integrated in upstream specifications, but are hosted here until then.
</p>

<div class="algorithm">

<p class="issue">
この様な各種用語は、
`CSSOM-VIEW-1$r,
`CSS-OVERFLOW-3$r,
`CSS-SCROLL-SNAP-1$r
にて与えられる~ベキである。
`2322$issue
◎
Terminology like this should be in [CSSOM-VIEW-1], [CSS-OVERFLOW-3], [CSS-SCROLL-SNAP-1]. &lt;https://github.com/w3c/csswg-drafts/issues/2322&gt;
</p>

<p>
次をすべて満たす要素 %要素 は、所与の方向 %方向 へ
`手動で~scrollできる@
とされる：
◎
An element e can be manually scrolled in a given direction d if:
</p>

<ul>
	<li>
%要素 が確立する`首要~box$ %~box は、`~scroll容器$である
◎
The principal box established by e is a scroll container, and
</li>
	<li>
<p>
%方向 に応じて，次が満たされる：
</p>
		<ul class="switch">
			<li>
`up^l ／ `down^l
⇒
%要素 の `overflow-y$p ~propの算出d値 ~NEQ `hidden$v
◎
if d is up or down, the computed value of the overflow-y property is not hidden, and
</li>
			<li>
`left^l ／ `right^l
⇒
%要素 の `overflow-x$p ~propの算出d値 ~NEQ `hidden$v
◎
if d is left or right, the computed value of the overflow-x property is not hidden, and
</li>
		</ul>
	</li>
	<li>
%~box は
%方向 において`~scroll境界$に来てはいない
◎
e is not at the scroll boundary in the direction d
</li>
	<li>
%~box は
%方向 において最後の `mandatory$v `留め位置$に留められてはいない
◎
e is not snapped to the last mandatory snap point in direction d
</li>
</ul>

</div>

<div class="algorithm">

<p class="issue">
`CSSOM-VIEW-1$r は、おそらく［
明示的な位置を伴わずに所与の方向へ~scrollを遂行する方法
］を定義するベキである。
それまでは、ここに自前の~algoを与える。
`2323$issue
◎
[CSSOM-VIEW-1] should probably define how to perform a scroll in a given direction without an explicit position. Until then, we roll our own. &lt;https://github.com/w3c/csswg-drafts/issues/2323&gt;
</p>

<p>
`要素をある方向へ~scrollする@
ときは、所与の
( %要素, %方向 )
に対し：
◎
To directionally scroll an element e in direction dir:
</p>

<ol>
	<li>
%距離 ~LET ~UAにより定義される距離
◎
Let d be a User Agent defined distance.
</li>
	<li>
%x ~LET x 軸における， %要素 の現在の~scroll位置
◎
Let x be e’s current scroll position on the x axis.
</li>
	<li>
%y ~LET y 軸における， %要素 の現在の~scroll位置
◎
Let y be e’s current scroll position on the y axis.
</li>
	<li>
%位置 ~LET %方向 に応じて
⇒＃
`up^l ならば ( %x, %y ~MINUS %距離 ) ／
`down^l ならば ( %x, %y ~PLUS %距離 ) ／
`left^l ならば ( %x ~MINUS %距離, %y ) ／
`right^l ならば ( %x ~PLUS %距離, %y )
◎
↓</li>
	<li>
`要素を~scrollする$( %要素, %位置 )
`CSSOM-VIEW-1$r
◎
Use the scroll an element algorithm from [CSSOM-VIEW-1] on e to
• (x, y - d) if dir is up
• (x, y + d) if dir is down
• (x - d, y) if dir is left
• (x + d, y) if dir is right
</li>
</ol>

</div>

	</section>
	<section id="privsec">
<h2 title=" Appendix B. Privacy and Security Considerations">付録 B. ~privacyと~securityの考慮点</h2>

<p>
この仕様の協力者たちは、この仕様に関わる既知の~security~riskは，すべて必要十分に取組まれたものと予見している。
更なる詳細は、下に供される。
◎
The specification contributors believe that all known potential security risks associated with this specification have been adequately addressed. Further details are provided below.
</p>

<p>
TAG 【 `W3C Technical Architecture Group^en 】は、各［
編集者／ Working Group
］が~~策定する仕様により導入され得る~riskを評価し易くするための自己考査~質問票を開発した。
その回答は、以下に供される
【…以下、未訳。】
◎
The TAG has developed a self-review questionaire to help editors and Working Groups evaluate the risks introduced by their specifications. Answers are provided below.
</p>

	</section>
	<section id="ack">
<h2 title="Acknowledgements">謝辞</h2>

<p>
編集者は、この仕様に~feedbackを寄せられ，協力された次の方々に感謝したい：
◎
The editors of this specification would like to thank the following individuals for their feedback and contributions (in alphabetical order):
</p>

<div lang="en-x-a0">
Alice Boxhall
Brian Kardell
Elika Etemad
Hugo Holgersson
Hyojin Song
Jeonghee Ahn
Junho Seo
Rob Dodson
Seungcheon Baek
</div>

	</section>
</main></div>

