<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Flexible Box Layout Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />


<!--%style （例示用）-->
<style>
.code-and-figure {
	display: table;
	margin: 0 auto;
	border-spacing: 1em;
}
.code-and-figure > div {
	display: table-cell;
	vertical-align: middle;
}

/* Overview catalog example */
#_dgm-overview-example {
	display:table;
	margin: 0 auto 1em;
	border-spacing: .5em 0;
	min-width: 672px;
}
#_dgm-overview-example > ._col {
	display: table-column;
	background: hsl(60 100% 90%);
}
#_dgm-overview-example > ._desc {
	display: table-cell;
	vertical-align: top;
	width: 300px;
	padding: 1em 1em 0;
	text-align: left;
	border: thick solid hsl(60 80% 50%);
	border-radius: 1em 1em 0 0;
	border-bottom: none;
}
#_dgm-overview-example > ._desc > img {
	margin: 0 auto;
	display: block;
}
#_dgm-overview-example > ._desc > h1 {
	background: transparent;
}
#_dgm-overview-example > ._buttons {
	display: table-row;
}
#_dgm-overview-example > ._buttons > div {
	display: table-cell;
	border: thick solid hsl(60 80% 50%);
	border-radius: 0 0 1em 1em;
	border-top: none;
	text-align: center;
}
#_dgm-overview-example button {
	background-color: hsl(120 100% 40%);
	border: medium inset hsl(120 70% 40%);
	border-radius: 1em;
	padding: .5em;
	font-weight: bold;
	color: white;
	font-size: 1.6em;
	cursor: pointer;
	width: 90%;
	margin: 1em auto;
}

/* Visibility: Collapse example */
#_dgm-visibility-collapse-example {
	display: table;
	width: 100%;
	box-shadow: 3px 3px 10px #333;
}
#_dgm-visibility-collapse-example > article,
#_dgm-visibility-collapse-example > nav {
	display: table-cell;
}
#_dgm-visibility-collapse-example > article {
	width: 100%;
	background: white;
}
#_dgm-visibility-collapse-example ul,
#_dgm-visibility-collapse-example li {
	list-style: none;
	margin: 0;
	padding: 0;
}
#_dgm-visibility-collapse-example > nav > ul {
	background: #444;
	border-radius: 0.5em;
	padding: 0.075em;
}
#_dgm-visibility-collapse-example li {
	padding: 0 0.5em;
	background: #ddd;
	color: black;
	border-radius: 0.40em;
	border: #444 solid 0.075em;
}
#_dgm-visibility-collapse-example li li {
	background: #444;
	color: white;
	margin: 0 -0.5em;
	border-radius: 0;
}
#_dgm-visibility-collapse-example li li:first-child {
	border-radius: 0.375em 0.375em 0 0;
}
#_dgm-visibility-collapse-example a {
	background: transparent;
	color: inherit;
}
#_dgm-visibility-collapse-example > nav > ul > li:target,
#_dgm-visibility-collapse-example > nav > ul > li:hover {
	background: #888;
	color: white;
}
#_dgm-visibility-collapse-example > nav > ul > li:not(:target):not(:hover) > ul {
	height: 0;
	overflow: hidden;
}

#_dgm-auto-bar {
	overflow: hidden;
	padding: .25em 1em;
	background: #ddd;
	list-style: none ;
	margin: 0;
	border-radius: .3em;
}
#_dgm-auto-bar > li {
	float: left;
	color: black;
	margin: 0;
	list-style: none ; /* 追加 */
}
#_dgm-auto-bar > li:first-child:after,
#_dgm-auto-bar > li:first-child + li:after {
	content: " |  ";
	white-space: pre;
}
#_dgm-auto-bar > li > a {
	display: inline-block;
	padding: 0 .25em;
	border-radius: .3em;
}
#_dgm-auto-bar > li > a:not(:hover):not(:focus) {
	text-decoration: none;
}
#_dgm-auto-bar > li > a:hover {
	color: #ddd;
	background: #444;
}


#_dgm-cross-auto-figure > div > div {
	margin: 0 auto;
	width: 70px;
	background: #888;
	padding: 0 .5em;
	border-radius: 1em;
	border: 1px solid transparent;
}
#_dgm-cross-auto-figure > div > div > div {
	border-spacing: 0;
	display: table;
	background: #ddd;
	color: black;
	text-align: center;
	margin: .5em auto;
	padding: .5em;
	border-radius: .5em;
}

.axis { color: hsl(  0 80% 40%); }
.side { color: hsl(240 80% 50%); }
.size { color: hsl(120 80% 30%); }

#_dgm-flex-order-example { position: relative; height: 100px;}
#_dgm-flex-order-example > div {
	position: absolute;
	font-size: 16px;
	color: gray;
	border: solid gray 2px;
	background: white;
	width: 48px;
	height: 24px;
	padding-left: 10px;
	border-top-left-radius: 5px;
	border-top-right-radius: 5px;
	border-bottom: none;
}


#_dgm-flex-pack > div {
	margin-top: 2px;
	width: 500px;
	height: 45px;
	line-height: 50px;
	position: relative;
	border: solid gray 2px;
	background: gray;
	text-align: center;
	font-family: monospace;
}

#_dgm-flex-pack > div > div {
	position: absolute;
	top:0;
	bottom:0;
}
#_dgm-flex-pack > div > div:nth-child(1) {
	width:98px;
	background:#fcc;
}
#_dgm-flex-pack > div > div:nth-child(2) {
	width:78px;
	background:#cfc;
}
#_dgm-flex-pack > div > div:nth-child(3) {
	width:198px;
	background:#ccf;
}

#_dgm-flex-pack > div > div:nth-child(4) {
	left:0;
	right:0;
	background:transparent;
	font-size: 30px;
	color: black;
}


#_dgm-align-content-example > div {
	display: inline-block;
	width: 200px;
	height: 250px;
	position: relative;
	border: solid gray 2px;
	background: gray;
	text-align: center;
	font-family: monospace;
}

#_dgm-align-content-example > div > div {
	position: absolute;
	left:0;
	right:0;
	height:50px;
	background: url("data:image/png;base64,\
iVBORw0KGgoAAAANSUhEUgAAAFAAAAAyAgMAAAC2Q7RvAAAABGdBTUEAALGPC/xh\
BQAAAAFzUkdCAK7OHOkAAAAJUExURf/MzM3M/8z+zURRUVcAAAAaSURBVDjLY2AA\
glVgEAoHDKOCo4KjgiNbEABLjm1MVvs8tQAAAABJRU5ErkJggg==");
}
#_dgm-align-content-example > div > div:nth-child(1) {
	
}
#_dgm-align-content-example > div > div:nth-child(2) {
	background-position: left 40px top 0;
}
#_dgm-align-content-example > div > div:nth-child(3) {
	background-size: 100px 50px;
}
#_dgm-align-content-example > div > div:nth-child(4) {
	font-size: 24px;
	top:112px;
	background: transparent;
	color: black;
}



#_dgm-flex-align > div {
	display: inline-block;
	width: 45%;
	height: 6rem;
	margin-right: 1%;
	position: relative;
	border: solid gray 2px;
	background: #AAA;
	text-align: center;
	font-family: monospace;
}

#_dgm-flex-align > div > div {
	position: absolute;
	left:0;
	right:0;
	white-space: nowrap;
	overflow: hidden;
	line-height: 1em;
}

#_dgm-flex-align > div > div:nth-child(1) {
	background: #fcf;
	height: 5rem;
	left: 0%;
	width: 20%;
}
#_dgm-flex-align > div > div:nth-child(2) {
	background: #cfc;
	height: 3rem;
	left: 20%;
	width: 16%;
}
#_dgm-flex-align > div > div:nth-child(3) {
	background: #ccf;
	height: 4rem;
	left: 36%;
	width: 40%;
}
#_dgm-flex-align > div > div:nth-child(4) {
	background: #cff;
	height: 6rem;
	left: 76%;
	width: 24%;
}
#_dgm-flex-align > div > div:nth-child(5) {
	font-size: 2rem;
	top:2.3rem;
	background: transparent;
	color: black;
}

#_dgm-flex-align > div > div > div {
	border-bottom: dashed black 1px;
	line-height:0.9em;
	position: absolute;
	text-align: left;
	color: gray;
}


.flex-flow {
	background: #444;
	position: relative;
	border: solid #444 3px;
	border-radius: 6px;
	font-family: sans-serif;
	font-size: 30px;
	text-align: center;
	line-height: 40px;
	color: white;
}

.flex-flow > div {
	position: absolute;
	width: 40px;
	height: 40px;
	border-radius: 3px;
	background: #888;
}

.flex-flow.横組 > div:nth-child(2) {
	width: 50px;
}
.flex-flow.横組 > div:nth-child(4) {
	width: 60px;
}
.flex-flow.縦組 > div:nth-child(2) {
	height: 50px;
	line-height: 50px;
}
.flex-flow.縦組 > div:nth-child(4) {
	height: 60px;
	line-height: 60px;
}


#_dgm-flex-order-page {
	width:360px;
	height:300px;
	font-family: monospace;
	font-size: 18px;
}

#_dgm-flex-order-page > div {
	top:50px; bottom:50px;
	left:0; right:0;
	position: absolute;
	height:auto;
	width:auto;
}

#_dgm-multiline-flex > div {
	width: 93px;
}
#_dgm-multiline-no-flex > div {
	width: 77px;
}

.rel-vs-abs {
	margin: 10px;
	height: 4.5em;
}

.rel-vs-abs > div {
	background: gray;
	position: relative;
	border: solid gray 3px;
	border-radius: 6px;
	text-align: center;
	width: calc(25em + 6px) ;
	height: 1.8em;
	font-family: sans-serif;
	line-height: 1.8em;
}

.rel-vs-abs > div > div {
	position: absolute;
	height: 1.8em;
	border-radius: 3px;
	background: #DDD;
}

.rel-vs-abs > div > div > div {
	position: absolute;
	top:calc( 1.8em + 6px );
	height: 0.6em;
	left:0px;
	right:0px;
	border: solid 2px black;
	border-top: 0;
	line-height: 3em;
}

#flex-direction-terms text {
	fill: currentColor;
	stroke: none;
}
#flex-direction-terms path {
	stroke: currentColor;
	fill: none;
}

#_dgm-flex-item-determination {
	background: #444;
	border: solid #444 3px;
	border-radius: 6px;
	display: inline-block;
	white-space: nowrap;
}
#_dgm-flex-item-determination > div {
	margin-right: 3px;
	padding: 0 3px;
	border-radius: 3px;
	background: #888;
	display: inline-block;
	vertical-align: top;
	color: white;
}

</style>

<!--%style -->
<style>
.axis-mapping td,
.axis-mapping > thead th {
	white-space: nowrap;
}

.matrix td, .matrix th {
	border: solid 1px silver;
}

.css {
	white-space: nowrap;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){

	const source_data = {
		val_prop_map: Util.get_mapping(PAGE_DATA.val_prop_map),
		collectParts: Util.collectParts,
		generate: expand,
	};
	
	delete PAGE_DATA.val_prop_map;

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const val_prop_map = this.val_prop_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)(?::([\w\-]+))?/g,
		create_html
	);

	function create_html(match, key, indicator, klass, values){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'v': // css values
	if(values){
		href = `#valdef-${val_prop_map[values]}-${key}`;
		values = '';
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s?\[.+/, '');
	break;
case 'tp': // property value type
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'cg':
	text = '変更箇所';
	href = `#${key}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

if(values) {
	text = 
		'<code class="css">'
		+ text
		+ ': <code class="value">'
		+ values.replace(/_/g, ' ')
		+ '</code></code>'
}

return text;

	}
}



</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Flexible Box Layout Module Level 1
spec_date:2020-08-10
trans_update:2020-08-07
source_checked:180604
page_state_key:CSS
original_url:https://drafts.csswg.org/css-flexbox-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,layout,css
conformance:css
copyright:2020,permissive
trans_1st_pub:2013-10-13


●●class_map
p:property
pe:pseudo
d:descriptor
v:value
t:type
tp:type
a:attr
op:op

●●tag_map
p:code
pe:code
d:code
v:code
t:var
tp:var
V:var
a:code
i:i
op:span
em:em

●●original_id_map

feedback:
valdef-flex-basis-auto:auto
valdef-flex-basis-content:content

●●mdn_urls
propdef-align-content:CSS/align-content
propdef-align-items:CSS/align-items
propdef-align-self:CSS/align-self
propdef-flex:CSS/flex
propdef-flex-basis:CSS/flex-basis
propdef-flex-direction:CSS/flex-direction
propdef-flex-flow:CSS/flex-flow
propdef-flex-grow:CSS/flex-grow
propdef-flex-shrink:CSS/flex-shrink
propdef-flex-wrap:CSS/flex-wrap
propdef-justify-content:CSS/justify-content
propdef-order:CSS/order

●●val_prop_map

d:display
f:flex
fd:flex-direction
fg:flex-grow
fs:flex-shrink
fb:flex-basis
fw:flex-wrap
ff:flex-flow
o:order
j:justify-content
ais:align-items
as:align-self
ac:align-content

●●words_table1

auto_v:<code class="value">auto</code> 
autoS:auto

●●words_table

	●layout（次元／向き
col:column
row:

主-:main-::~
	主-:main
主size:main-size::主 size:主サイズ
交叉-:cross-::~
	交叉-:cross
交叉size:cross-size::交叉 size:交叉サイズ
	交叉-~~方向:cross-wise
縦:vertical::~
縦方向:vertical::~
縦書き:vertical::~
横:horizontal::~
横方向:horizontal::~
横書き:horizontal::~
直交:orthogonal::~
垂直:perpendicular::~
平行:parallel::~
中央:center::~
	中央~寄せ:centered
	中央に寄せる
	中央~寄せ
	中央に据える:centering
	置く:place
	向き

左方:leftwards:~
右方:rightwards:~
下方:downwards:~
上方:upwards:~
一次元:linear:~
二次元:two-dimensional:~
	二次元:2D
	最も始端:startmost
	最も終端:endmost
	両端:either end

	●layout（配分／空間／整列
配分-:distribute::~
配分:distribution::~
	配分-法:distributing
分布-:distribute::~
矩形:rectangle::~

収まる:fitする::~
収まら:fitし::~
収まり:fitし::~
埋める:fillする:~
埋めら:fillさ:~
埋尽くし:fill upし:埋め尽くし
自由空間:free-space:::free 空間
部屋:room::~
	部屋が尽きる:no more room
間隔:spacing::~
合間:between:~
支柱:strut::~

縮短-:shrink::~
伸長-:grow::~
係数:factor::~

基底s:basis::基底
割合分:fraction::~
比率:ratio::~
接合-:flush するように place:~
隣接な:adjacentな:隣接する
伸張-:stretch::~
総和:sum:~
吸収-:absorb:~
沿いの:方向の
沿いに:方向に
	沿い:along
clearance:
節減-:reduce:~

切詰めた:clampした:切り詰めた
切詰める:clampする:切り詰める
切詰めら:clampさ:切り詰めら
切詰め:clamping:切り詰め
切上げる:floorする:切り上げる
転換:transferred:~

整列-:align::~
整列:alignment::~
基底線:baseline::~::ベースライン
合成-:synthesize::~
拡幅-:expand::~
押出され:pushされ:押し出され
押出す:pushする:押し出す
遭遇-:encounter:~

	押しやられ:-
	force:押しやる
	引き上げ:pull
	揃え
	均等:evenly
	比例するよう:proportional
	比例分:proportion
	等しく／等量:equally
	等しい／等:equal
	等量:equal／equal amount
	~~区画:entry／entry box
	余った:extra
	残りの:remaining
	残された:leftover
	残された空間:space left
	空いた空間:empty space
	幅:wide
	負にならない所まで:down to, but not past, zero
	〜に寄せる:toward
	小さく:small
	幅の狭い:narrow
	~~長い:long
	半分:half
	離れた所:apart


固定-:fix::~
固定d:fixed::固定
	固定d~size:fixed-size
延伸-:extend::~
増大-:increase::~

折返す:wrapする::折り返す
折返ng:wrapping::折り返し
折返され:wrapされ::折り返され

相殺-:collapse::~
畳む:collapseする::~
畳める:collapseさせる::~
畳まれ:collapseされ::~
畳んだ:collapseした::~
	畳まれない／〜逆:uncollapse
	畳まれるかどうか:collapsed and uncollapsed
収納-:pack::~
	収納-法:packing
	消え去る:disappear する
	現れる:appear
	出現:appearing
	占める:takes up／-
	奪われ:stolen
	尽きた:ran out
	居残る:leaves behind
	伸縮可能
	伸縮~mode
	伸縮不可

	●layout（flex
行f:line°::行°
単-:single-::~
複-:multi-::~
駒:item:::アイテム

flexbox:
flex:
	~flexが効き過ぎた:over-flexed
	~flex~~処理:flexing
	~flex可能:flexible
	~flex不能:inflexible
	~flex能:flexibility
	~flex~level:flex-level


	●layout（一般
table:
	table-row:
	table-column:
	table-cell:
	~table状:tabular format
cell:
字l:letter::字°
	塊~容器
	包含している:containing
複柱:multi-column::複 column::複カラム
包装:wrapper::~
浮動体:float::~
浮動-:float::~
	静的~位置~用の:static-position
自動:auto::~
auto:
積層:stacking::~
堆積:stack::~
	積層／積まれて／
重合する:overlapする:重なり合う
溢れる:spillする:~
変形n:transformation::変形
	~lay-outされ:laid out
	塊~layout:Block Layout

	●layout（アルゴリズム
再開始する:restartする:やり直す
	再び走らす:re-run
	飛ばす:skip
	先に進んで:skip past
補正-:fix:~
不定:indefinite::~
確定的:definite::~
	収集-済みでない:uncollected
	解決-法:resolving
	解決できない:unresolvable
供与:contribution::~
供与-:contribute::~
外在的:extrinsic::~
	固有の
縦横比:aspect ratio::~

最小-:min-::~
最大-:max-::~
	最~小:smallest
	最~大／max(:largest
内容収納:fit-content::~
拡縮済み:scaled:~
昇格-:promote:~
完結-:finalize:~

	和:sum
	~flow内:in-flow
	順方向:forward direction
	逆方向
	~PLUS:+
	~MUL:
	~MINUS:minus
	増加:incrementing
	合計:combined
	抜ける:exit
	やり直す:redo
	~~記録:note
	下位手続き:substep
	~restart:
	解消:fixing
	仮の:hypothetical

	●順序
序数:ordinal::~
並替える:reorderする::並び替える
並替えら:reorderさ::並び替えら
	逆順:reverse
	配置替え:rearrangement／rearrange:
	z ~~方向の順序付け:z-ordering
陳列-:display:~
空間的:spatial:~

	●分断
強制d:forced::強制
分断:break::~
分断-:break::~
分断処理:breaking::~
	分断~機会:break opportunities
	分断され:broken
	分断-不能:unbreakable
	改行で折返され:broken onto a new line
機会:opportunity::~
断片:fragment::~
断片化-:fragment 化::~
	断片化-法:fragmenting
断片化:fragmentation::~

	~~移動:shift
	~page割り:pagination
	~page割り:paginate
	~page先頭:top of the page

	●CSS
書字:writing::~
書字mode:writing mode::書字 mode:書字モード
使用-:use::~
未指定の:unspecified::~
発話:speech::読み上げ
	speech rendering
塗ng:painting::塗り
塗られ:paintされ::~
単位:unit:~
	単位なしの:unitless
連なり:run::~
実数:number:~

	一連の子:children
	種類:type
	指定d値:as specified
	~group分け:grouping

	●UI
action::::アクション
	~access可能にする:accessible
caption:
hover:
drag-and-drop:::ドラッグ＆ドロップ
sidebar::::サイドバー
bar::::バー
tab::::タブ
	タブ化された:tabbed
footer::::フッタ
pane::::ペイン
scroll::::スクロール
	下位~menu:submenu
逐次的:sequential:~
	揺らがす:wobble
	触れずに:intact
	隠す:hide
	操作中:target
	~~認識:perception

	●仕様（動詞
	適合していない:non-conforming
	作用:interacts with
適応-:accommodate:~
注目-:focus:~
誂える:tailorする:あつらえる
改良-:improve:~
誤解釈:misinterpretation:~
改正-:amend:~
制止-:preclude:~
release::::リリース
	ある程度の制御を供する:exerts some control
	見込まれる:likely
	様に:like
	貫き続ける:stick to
	保つ:keep
	取って代わる:supersede
	可能にする:allow
	~~尊守:respect
	さほど関わり無く:without much regard
	定義する側面がある:defining aspect
	難解な詳細を理解する切迫した~~動機:deep-seated urge to understand arcane details
	補助:helps
	加味-:honor
	加味-:respect
	^en:fall out
	重きが置かれる:biased-to
	詳細を与える:detailing
	~~述べ易く:easier to talk
	にあたる:consulted
	~~追加の特典:added bonus
	策定を遅らせ:slow down advancement
	注目を引く:compelling:
	損ない:ruin
	書かれ:written
	~~考慮-:with regards to
	感じられ:feel
	選ぶ:chose
	〜しないように:prevent
	示す:illustrates
	図示:illustration
	課される:imposed／subject to
	未使用の:unused
	呼ばれ／称され:called

	●仕様
editor::::エディタ
	specification
参考:informative:~
	~~明確な:very explicit
自明:trivial:~

理論的簡潔さ:theoretical simplicity:~
安定:stable:~
不安定:fragile:~
高価:expensive:~
高度な:advanced:~
	~~帰結 corollary
	この~~目的のため、:To this end,
正す:correctする:~
演習:exercise:~
特典:bonus:~
表面的:superficial:~
適度:reasonable:~
完璧:perfect:~
	insanely ひどく
	~~主要な:major
欠点:drawback:~
	単純なものも:simply
道具:tool:~::ツール
	~~実際 indeed
	~~相当に:noticeably
	近く:close to
	〜に従う:per 〜
	~~主対象に:centric
	歪み:distortation
	好ましい:better
	足りない:insufficient
	年月に渡り:over the years
	感応する:sensitive
	~~意味を成す:sensible
	気の利いた:intelligent
	無用に:gratuitously
	分岐:dichotomy
	図:figure
	真の~~意味の:true
	due
	how
	like
	unlike
	wish
	-: ways
	-:designer
	きちんと:well-
	いきなり:suddenly
	より詳しい:more

	●未分類（動詞
獲得-:acquire:~
展開-:expand:~
対応関係:mapping:~
	基になる:used to produce
再現-:reproduce:~
生きた:live:~
走査-:traverse:~
走査:traversal:~
分割-:split:~
切替える:switchする:切り替える
入換わる:swapされる:入れ換わる
侵入-:intrude:~
前置-:precede:~
費やさ:consumeさ:~
乗算-:multiply:~

	becomes
	cause
	causing
	come
	continue
	doesn’t
	ensure
	followed／following／follows
	従って:as follows
	gets
	going
	having
	makes
	means
	need
	seen
	using
	委ねる:Defers
	取り除く／外される:remove
	~~取得:retrieve
	別々の…に分ける:separate … distinct
	-:deals
	得る:achieve
	得る:gains
	応じて:respond
	戻され:reverted … back
	戻る:return
	指す:refer
	欠く:lacks
	終える／最後:finish
	結び付けられている:associated
	色分けされた:colored
	読み取れる:readable
	読む:read
	進む:proceed
	遅らせる:slow down
	先行する:preceding
	対応:respective
	属する:belong to
	leaving
	numbered
	served
	sketch
	test
	turn into
	beginning
	respecting
	振り分け直され:rebalance
	近づく:approach

	●未分類
公式:formula:~
	counter:::カウンタ
hack::::ハック
近似:approximation:~

初期設定:initial setup:~
	側:side
代用:substitute:~

日本語:Japanese:~
英語:English:~
Farsi::ペルシャ語
	絶対値:magnitude／absolute value
連続性:continuity:~
連続的:continuous:~
滑らか:smooth:~
等価性:equivalency:~

	~~説明:description
	~~見出し:text
	~~見出し:title
	写真:photo
	目録:catalog
	部品:parts
	購入:purchase
	-:against
	time
	そのまま:raw
	~~形:shape
	bases
	数:number

	●指示語

	~~部分的:partway
	第二の:secondary
	後方の／~~後の:later
	後続の:subsequent
	最低の:lowest
	最終的な:final
	-:final
	-:finally
	最終的にeventually
	種々の:various
	次の:next
	残りの部分:rest
	総／総じて:overall
	占める〜の~size:overall size
	総／合計:total
	様々な:many
	それぞれ／同順:respectively
	ほぼ:mostly
	まだ:not already
	already
	以上の点:previous point
	just
	among
	besides
	ever
	most
	much
	necessary
	neither
	none
	once
	onto
	のみ:only
	sole
	thereof
	under
	upon
	より大:larger
	より小:less than
	より小さい:smaller
	一部分:fraction
	中段:middle
	今や:no longer
	別に:Aside
	反対／反対側:opposite
	同時に:together
	よく似:very similar
	渡る:across
	previously
	previous
	part
	whichever
	~~主に:mainly
	~~先行する:prior
	〜から:starting
	囲う:around
	片側または両側:at least one
	両側:these
	連続している:contiguous
	連続する:consecutive
	開始:starting
	開始:starting from
	順次に:one by one
	周目:round
	より大きい:larger
	少し:slightly
	二重に:double-
	ある:somewhat
	近くなった:underflow
	次第に:gradual
	満たない:less than
	-:amount
	-:small


●●link_map


	●p
p.align-content:#propdef-align-content
p.align-items:#propdef-align-items
p.align-self:#propdef-align-self
p.flex-basis:#propdef-flex-basis
p.flex-direction:#propdef-flex-direction
p.flex-flow:#propdef-flex-flow
p.flex-grow:#propdef-flex-grow
p.flex-shrink:#propdef-flex-shrink
p.flex-wrap:#propdef-flex-wrap
p.flex:#propdef-flex
p.justify-content:#propdef-justify-content
p.order:#propdef-order

p.margin:~CSSBOX#propdef-margin
p.margin-left:~CSSBOX#propdef-margin-left
p.margin-top:~CSSBOX#propdef-margin-top
	p.page-break-after:~CSS22/page.html#propdef-page-break-after
	p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.max-height:~CSS2VISUDET#propdef-max-height
p.max-width:~CSS2VISUDET#propdef-max-width
p.min-height:~CSS2VISUDET#propdef-min-height
p.min-width:~CSS2VISUDET#propdef-min-width
p.vertical-align:~CSSINLINE#propdef-vertical-align
p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height
p.visibility:~CSS2VISUFX#propdef-visibility
p.float:~CSS2VISUREN#propdef-float
p.clear:~CSS2VISUREN#propdef-clear

	p.justify-content:~CSSALIGN#justify-content
	p.align-content:~CSSALIGN#align-content
p.break-after:~CSSBREAK#propdef-break-after
p.break-before:~CSSBREAK#propdef-break-before
p.break-*:~CSSBREAK#propdef-break-before

p.overflow:~CSSOVERFLOW3#propdef-overflow

p.position:~CSSPOS#propdef-position
p.z-index:~CSS2VISUREN#propdef-z-index
p.white-space:~CSSTEXT#propdef-white-space
	p.white-space:~CSSWG/css-text-4/#propdef-white-space

p.box-sizing:~SIZING#propdef-box-sizing
p.writing-mode:~CSSWM#propdef-writing-mode
p.direction:~CSSWM#propdef-direction
p.display:~CSSDISP#propdef-display
p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration

v.horizontal-tb:~CSSWM#valdef-writing-mode-horizontal-tb
v.ltr:~CSSWM#valdef-direction-ltr
v.rtl:~CSSWM#valdef-direction-rtl
v.vertical-rl:~CSSWM#valdef-writing-mode-vertical-rl

v.~autoS:~SIZING#valdef-width-auto

	d.min-width:~TR/css3-mediaqueries/#min-width
d.min-width:~MQ4#width

pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.first-letter:~CSSPSEUDO#selectordef-first-letter

t.integer:~CSSVAL#integer-value
t.number:~CSSVAL#number-value
t.length:~CSSVAL#length-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.percentage:~CSSVAL#percentage-value

a.tabindex:~HTMLinteraction#attr-tabindex

	valdef-order-integer:#<var>&lt;integer&gt;</var>//
	//valdef-number0
	valdef-flex-grow-number:#<var>&lt;number&gt;</var>
	//valdef-number
	valdef-flex-shrink-number:#<var>&lt;number&gt;</var>

	●用語
確定的:#definite
不定:#definite
改変された文書~順序:#order-modified-document-order

~flex整形~文脈:#flex-formatting-context
~flex~layout:#flex-layout
~flex基底s:#flex-flex-basis
~flex基底~size:#flex-base-size
~flex容器:#flex-container
~flex係数:#flex-factor
~flex伸長-係数:#flex-flex-grow-factor
~flex縮短-係数:#flex-flex-shrink-factor
~flex駒:#flex-item

~flex行l:#flex-line
~flex~level:#flex-level

v.initial:#flex-initial
	~CASCADE#valdef-all-initial

主-軸:#main-axis
主-軸 基底線~集合:#main-axis-baseline
主-次元:#main-dimension
主size~prop:#main-size-property
最小-主size~prop:#min-main-size-property
最大-主size~prop:#max-main-size-property
主size:#main-size
最小-主size:#min-main-size
最大-主size:#max-main-size
主-終端:#main-end
主-始端:#main-start

交叉-軸:#cross-axis
交叉-軸 基底線~集合:#cross-axis-baseline
交叉-次元:#cross-dimension
交叉size~prop:#cross-size-property
最小-交叉size~prop:#min-cross-size-property
最大-交叉size~prop:#max-cross-size-property
交叉size:#cross-size
最小-交叉size:#min-cross-size
最大-交叉size:#max-cross-size
交叉-終端:#cross-end
交叉-始端:#cross-start
	aligned:#alignment
	整列~prop:#propdef-align-items
	畳まれた駒:#visibility-collapse
	common cases:#flex-common
	common uses:#flex-common
	~flow方向:#flex-direction-property
	have equal height:#align-self
	<span class="css">initial</span>:#flex-initial
	rearranged:#order-property
	resolve the flexible lengths:#resolve-flexible-lengths
	reverse:#valdef-row-reverse
	wrapped:#flex-wrap-property

行f分断処理~段:#algo-line-break
	longhand:#flex-components

~flex~layout~algo:#layout-algorithm
主-軸の整列:#main-alignment
交叉-軸の整列:#cross-alignment
主sizeの決定:#main-sizing
交叉sizeの決定:#cross-sizing
行f~sizeの決定:#line-sizing

単-行f:#single-line-flex-container
複-行f:#multi-line-flex-container
~flex方向:#flex-direction
	＊畳まれた~flex駒:#collapsed-flex-item
畳まれ:#collapsed-flex-item
畳む:#collapsed-flex-item
基底線~整列に関与-:#baseline-participation
支柱~size:#_strut-size
伸張-:#stretched

~auto_v~margin:#auto-margins

内容に基づく最小~size:#content-based-minimum-size
内容~size示唆:#content-size-suggestion
指定d~size示唆:#specified-size-suggestion
転換~size示唆:#transferred-size-suggestion
全部的に~flex不能:#fully-inflexible
~flex可能:#flexible

共通的な用途:#flex-common

	■§9.7 flexible 長さの解決
仮の交叉size:#hypothetical-cross-size
仮の主size:#hypothetical-main-size
~target主size:#target-main-size

	V.自由空間:#free-space
	V.初期~自由空間:#initial-free-space
	V.残りの自由空間:#remaining-free-space
i.拡縮済み~flex縮短-係数:#scaled-flex-shrink-factor

~boxの寸法:~CSSBOX#box-model
~flow内:~CSSDISP#in-flow
~flow外:~CSSDISP#out-of-flow
~flow~layout:~CSSDISP#flow-layout
置換され:~CSSDISP#replaced-element

絶対的に位置され:~CSSPOS#absolute-position
	#abs-non-replaced-width
静的~位置:~CSSPOS#_static-position
静的~位置~矩形:~CSSPOS#static-position-rectangle

	●CSS2
整形~構造:~CSS2CONFORM#formatting-structure
浮動体:~CSS2VISUREN#floats
浮動-:~CSS2VISUREN#floats
~clearance:~CSS2VISUREN#clearance
相殺-:~CSS2BOX#collapsing-margins

	●display
塊~化:~CSSDISP#blockify
塊~level:~CSSDISP#block-level
行内~level:~CSSDISP#inline-level
塊~容器:~CSSDISP#block-container
表示~型:~CSSDISP#display-type
匿名:~CSSDISP#anonymous
塊~box:~CSSDISP#block-box
包含塊:~CSSDISP#containing-block
~text連なり:~CSSDISP#text-run
~text~node:~CSSDISP#text-nodes
	~CSSDISP#outer-display-type
	~CSS2VISUREN#propdef-display
独立な整形~文脈を確立する:~CSSDISP#establish-an-independent-formatting-context
整形~文脈:~CSSDISP#formatting-context

	●cascade
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value

	● writing
塊-軸:~CSSWM#block-axis
塊-終端:~CSSWM#block-end
塊-始端:~CSSWM#block-start
始端:~CSSWM#css-start
終端:~CSSWM#css-end
行内-軸:~CSSWM#inline-axis
行内-終端:~CSSWM#inline-end
行内-始端:~CSSWM#inline-start
書字mode:~CSSWM#writing-mode
	論理-縦幅:~CSSWM#logical-height
塊~size:~CSSWM#block-size
行内~size:~CSSWM#inline-size
	:~CSSWM#fit-content
	:~CSSWM#max-content
	~CSSWG/css-box/#fit-content
塊~flow方向:~CSSWM#block-flow-direction

	●break0
A類の分断~機会:~CSSBREAK#btw-blocks
C類の分断~機会:~CSSBREAK#end-block

	●break
	補完
断片化~文脈:~CSSBREAK#fragmentation-context
	断片化された~flow:~CSSBREAK#fragmented-flow
断片化~容器:~CSSBREAK#fragmentation-container
	＊断片化~容器:~CSSBREAK#fragmentainer
断片化による分断:~CSSBREAK#fragmentation-break

	●SIZING
最小-内容 拘束:~SIZING#min-content-constraint
最大-内容 拘束:~SIZING#max-content-constraint
最小-内容 供与:~SIZING#min-content-contribution
最大-内容 供与:~SIZING#max-content-contribution
最小-内容~size:~SIZING#min-content
最大-内容~size:~SIZING#max-content
最小~size:~SIZING#minimum-size
選好d~size:~SIZING#preferred-size
自動的な最小~size:~SIZING#automatic-minimum-size
自動的な塊~size:~SIZING#automatic-block-size

fX.最大-内容 供与:#intrinsic-item-contributions
fX.最小-内容 供与:#intrinsic-item-contributions

	v.fit-content:~TR/css-sizing-3/#valdef-width-fit-content
v.max-content:~SIZING#valdef-width-max-content
v.min-content:~SIZING#valdef-width-min-content
	#valdef-width-*

可用な空間:~SIZING#available
内容収納~行内~size:~SIZING#fit-content-inline-size
内在的~sizing:~SIZING#intrinsic-sizing
~autoとして挙動する:~SIZING#behave-as-auto

指定d~size:~CSSIMAGE#specified-size

	●align
整列~容器:~CSSALIGN#alignment-container
基底線~集合:~CSSALIGN#baseline-export
生成される:~CSSALIGN#generate-baselines
整列~基底線:~CSSALIGN#alignment-baseline
整列~prop:~CSSALIGN#box-alignment-properties
整列~文脈:~CSSALIGN#shared-alignment-context
	（補完）
最初の基底線~集合:~CSSALIGN#first-baseline-set
基底線を合成-:~CSSALIGN#synthesize-baseline
合成-:~CSSALIGN#synthesize-baseline

	●mediaqueries
	width:~mediaqueries#min-width

整形される最初の行l:~CSSPSEUDO#first-formatted-line
~scroll容器:~CSSOVERFLOW3#scroll-container
複柱~容器:~CSSMCOL#multi-column-container
~table包装~box:~CSSTABLE#table-wrapper-box

●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. CSS Box Alignment Module Level 3. 21 April 2020. WD. URL: https://www.w3.org/TR/css-align-3/ 
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. CSS Containment Module Level 2. 3 June 2020. WD. URL: https://www.w3.org/TR/css-contain-2/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Images Module Level 3. 10 October 2019. CR. URL: https://www.w3.org/TR/css-images-3/ 
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. CSS Inline Layout Module Level 3. 4 June 2020. WD. URL: https://www.w3.org/TR/css-inline-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 3 June 2020. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Elika Etemad; et al. CSS Positioned Layout Module Level 3. 19 May 2020. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 25 February 2019. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. CSS Intrinsic & Extrinsic Sizing Module Level 3. 22 May 2019. WD. URL: https://www.w3.org/TR/css-sizing-3/ 
[CSS-TEXT-4]
    Elika Etemad; et al. CSS Text Module Level 4. 13 November 2019. WD. URL: https://www.w3.org/TR/css-text-4/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-BREAK]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 4 December 2018. CR. URL: https://www.w3.org/TR/css-break-3/ 
[CSS3-WRITING-MODES]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 10 December 2019. REC. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 

●●ref_informative

[CSS-TEXT-DECOR-4]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 4. 6 May 2020. WD. URL: https://www.w3.org/TR/css-text-decor-4/ 
[CSS3UI]
    Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI). 21 June 2018. REC. URL: https://www.w3.org/TR/css-ui-3/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Flexible Box Layout Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-flexbox-1/

編集者草案
	https://drafts.csswg.org/css-flexbox/

以前のバージョン
	https://www.w3.org/TR/2018/CR-css-flexbox-1-20181119/
	https://www.w3.org/TR/2018/CR-css-flexbox-1-20181108/
	https://www.w3.org/TR/2017/CR-css-flexbox-1-20171019/
	https://www.w3.org/TR/2016/CR-css-flexbox-1-20160526/
	https://www.w3.org/TR/2016/CR-css-flexbox-1-20160301/
	https://www.w3.org/TR/2015/WD-css-flexbox-1-20150514/
	https://www.w3.org/TR/2014/WD-css-flexbox-1-20140925/
	https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/
	https://www.w3.org/TR/2012/CR-css3-flexbox-20120918/
	https://www.w3.org/TR/2012/WD-css3-flexbox-20120612/
	https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/
	https://www.w3.org/TR/2011/WD-css3-flexbox-20111129/
	https://www.w3.org/TR/2011/WD-css3-flexbox-20110322/
	https://www.w3.org/TR/2009/WD-css3-flexbox-20090723/

テスト一式
	http://test.csswg.org/suites/css-flexbox-1_dev/nightly-unstable/
テスト
	https://test.csswg.org/harness/test/css-flexbox-1_dev/

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="mailto:ratan@microsoft.com">Rossen Atanassov</a> (Microsoft)

前任編集者
	<a href="mailto:alexmog@microsoft.com">Alex Mogilevsky</a> (Microsoft Corporation)
	<a href="https://dbaron.org/">L. David Baron</a> (Mozilla)
	<a href="mailto:enndeakin@gmail.com">Neil Deakin</a> (Mozilla Corporation)
	<a href="mailto:ian@hixie.ch">Ian Hickson</a> (formerly of Opera Software)
	<a href="mailto:hyatt@apple.com">David Hyatt</a> (formerly of Netscape Corporation)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-flexbox-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/css-flexbox-1

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-flexbox-1">GitHub Issues</a>

課題一覧
	https://drafts.csswg.org/css-flexbox-1/issues

</script>

</head>
<body>


<!--%resource pool -->
<div id="_persisted_parts" hidden>

<pre
	id="_dgm-overview-example-code"
	class="lang-html">&lt;section id="deals"&gt;
  &lt;section class="sale-item"&gt;
    &lt;h1&gt;入門用パソコン一式&lt;/h1&gt;
    &lt;p&gt;とにかく安い。
    &lt;ul&gt;
      &lt;li&gt;コンピュータ
      &lt;li&gt;モニタ
      &lt;li&gt;キーボード
      &lt;li&gt;マウス
    &lt;/ul&gt;
    &lt;img src="images/computer.jpg"
         alt="パソコン（白）と周辺機器一式"&gt;
    &lt;button&gt;今すぐ買う&lt;/button&gt;
  &lt;/section&gt;
  &lt;section class="sale-item"&gt;
    …
  &lt;/section&gt;
  …
&lt;/section&gt;
</pre>

<div id="_dgm-overview-example">
	<div class="_col"></div>
	<div class="_col"></div>
	<div class="_desc">
<img
	src="css-flexbox/computer.jpg"
	alt="パソコン（白）と周辺機器一式"
>
<!--
You get: a white computer with matching peripherals.
You get: a white computer with matching keyboard and monitor." -->
			<h1 style="font-size: 1.4em;">入門用パソコン一式</h1>
<p>
とにかく安い。
</p>
			<ul>
				<li>コンピュータ</li>
				<li>モニタ</li>
				<li>キーボード</li>
				<li>マウス</li>
			</ul>
		</div>
<!-- 
Computer Starter Kit

This is the best computer money can buy, if you don’t have much money.

    Computer
    Monitor
    Keyboard
    Mouse

BUY NOW
-->

	<div class="_desc">
<img
	src="css-flexbox/printer.png"
	alt="You get: beautiful ASCII art."
>
			<h1 style="font-size: 1.4em;">プリンタ</h1>
<p>
ASCII アートしか印刷できない。
</p>

<ul><li>
紙とインクは付属しません。
</li></ul>
	</div>
	<div class="_buttons">
		<div><button>今すぐ買う</button></div>
		<div><button>今すぐ買う</button></div>
	</div>
<!-- 
Printer

Only capable of printing ASCII art.

    Paper and ink not included.
-->
</div>

<!-- ＊
<img
	id="_dgm-flex-item-determination"
	src="css-flexbox/flex-item-determination.png"
>
-->

<div
	id="_dgm-flex-item-determination"
><div>blcok<br>&nbsp;<br>&nbsp;</div
><div>float<br>&nbsp;<br>&nbsp;</div
><div>anonymous item 3<br>&nbsp;<br>&nbsp;</div
><div style="text-align: center; margin-right:0;">item 4<br><q>item 4</q><br>item 4</div></div>

<div
	id="_dgm-flex-flow1"
	class="flex-flow 横組"
	style="width:160px; height:40px;"
>
	<div style="left:0;">1</div>
	<div style="left: 43px;">2</div>
	<div style="left: 96px;">3</div>
	<div style="left: 139px;">4</div>
</div>

<div
	id="_dgm-flex-flow2"
	class="flex-flow 縦組"
	style="width:83px;height:160px;"
>
	<div style="top: 0;">1</div>
	<div style="top: 43px;">2</div>
	<div style="top: 96px;">3</div>
	<div style="top: 0; left:43px;">4</div>
</div>

<div
	id="_dgm-flex-flow3"
	class="flex-flow 横組"
	style="width:160px;height:83px;"
>
	<div style="right: 0; bottom:0;">1</div>
	<div style="right: 43px; bottom:0;">2</div>
	<div style="right: 96px; bottom:0;">3</div>
	<div style="right: 0;">4</div>
</div>

<div
	id="_dgm-flex-flow-english"
	class="flex-flow 横組"
	style="width:160px;height:83px;"
>
	<div style="left:0;">A</div>
	<div style="left: 43px;">B</div>
	<div style="left: 96px;">C</div>
	<div style="left: 0;top:43px;">D</div>
</div>

<div
	id="_dgm-flex-flow-japanese"
	class="flex-flow 縦組"
	style="width:83px;height:160px;"
>
	<div style="top: 0; right:0;">一</div>
	<div style="top: 43px; right:0;">二</div>
	<div style="top: 96px; right:0;">三</div>
	<div style="top: 0; left:0;">四</div>
</div>

<div id="_dgm-flex-order-example">
<div style="top: 0; left: 70px;">一番</div>
<div style="top: 0; left: 135px;">二番</div>
<div style="top: 0; left: 200px;">四番</div>
<div style="top: 24px; left: 0; width: 500px; height: 80px; border-color: black; color: black;">
<p style="padding: 20px;">三番のタブに結び付けられている内容</p></div>
<div style="top: 0; left: 5px; border-color: black; color: black;">三番</div>
</div>

<div id="_dgm-flex-order-page" class="flex-flow"
	title="このページでは、 header は上端に， footer は下端に位置し、 article は，左の nav, 右の aside に挟まれた中央に位置する／In this page the header is at the top and the footer at the bottom, but the article is in the center, flanked by the nav on the right and the aside on the left."
>
	<div style="height:47px;top:0; bottom:auto;">&lt;header&gt;</div>
	<div style="right:auto; width:80px;">&lt;nav&gt;</div>
	<div style="left:83px; right:83px;">&lt;article&gt;</div>
	<div style="left:auto; width:80px;">&lt;aside&gt;</div>
	<div style="height:47px;top:auto; bottom:0;">&lt;footer&gt;</div>
</div>

<div
	id="_dgm-multiline-flex"
	class="flex-flow 横組"
	style="width:285px; height:83px;"
>
	<div style="left:0;">1</div>
	<div style="left:96px;">2</div>
	<div style="left:192px;">3</div>
	<div style="left:0;width:auto;right:0;top:43px;">4</div>
</div>

<div
	id="_dgm-multiline-no-flex"
	class="flex-flow 横組"
	style="width:285px; height:83px;"
>
	<div style="left:0;">1</div>
	<div style="left:80px;">2</div>
	<div style="left:160px;">3</div>
	<div style="left:0;top:43px;">4</div>
</div>

<div
	id="_dgm-rel-vs-abs-flex-a"
	class="rel-vs-abs"
><div>
	<div style="left:0; width:6.25em;">短い<div>1</div></div>
	<div style="left:calc(6.25em + 3px); width:6.25em;">なが〜〜い<div>1</div></div>
	<div style="left:calc(12.5em + 6px); width:12.5em;">短い<div>2</div></div>
</div></div>

<div
	id="_dgm-rel-vs-abs-flex-b"
	class="rel-vs-abs"
><div>
	<div style="left:0; width:6em;">
<div style="width:calc(2em - 4px);right:auto;">1</div>
短い
<div style="width:calc(2em - 4px);left:auto;">1</div>
</div>
	<div style="left:calc(6em + 3px); width:9em;">
<div style="width:calc(2em - 4px);right:auto;">1</div>
なが〜〜い
<div style="width:calc(2em - 4px);left:auto;">1</div>
	</div>
	<div style="left:calc(15em + 6px); width:10em;">
<div style="width:calc(4em - 8px);right:auto;">2</div>
短い
<div style="width:calc(4em - 8px);left:auto;">2</div>
</div>
</div>
</div>

<ul id="_dgm-auto-bar">
	<li><a href="#_dummy">About</a></li>
	<li><a href="#_dummy">Projects</a></li>
	<li><a href="#_dummy">Interact</a></li>
	<li style="float: right;"><a href="#_dummy">Login</a></li>
</ul>

<div
	id="_dgm-cross-auto-figure"
	style="display:table; margin: 0 auto 1em;"
>
	<div style="display:table-cell; padding-right: 50px;">
		<div>
			<div>About</div>
			<div>Authoritarianism</div>
			<div>Blog</div>
		</div>
	</div>
	<div style="display:table-cell; padding-left: 50px;">
		<div>
			<div>About</div>
			<div style="margin-left: -31px;">Authoritarianism</div>
			<div>Blog</div>
		</div>
	</div>
</div>

<div id="_dgm-flex-pack">
<div>
<div style="left:0px;"></div>
<div style="left:100px;"></div>
<div style="left:180px;"></div>
<div>flex-start</div>
</div>
<div>
<div style="right:280px;"></div>
<div style="right:200px;"></div>
<div style="right:0px;"></div>
<div>flex-end</div>
</div>
<div>
<div style="left:61px;"></div>
<div style="left:161px;"></div>
<div style="right:61px;"></div>
<div>center</div>
</div>
<div>
<div style="left:0;"></div>
<div style="left:161px;"></div>
<div style="right:0;"></div>
<div>space-between</div>
</div>
<div>
<div style="left:21px;"></div>
<div style="left:161px;"></div>
<div style="right:21px;"></div>
<div>space-around</div>
</div>
</div>

<div id="_dgm-flex-align" style="min-width:20em; max-width: 50em;">

	<div>
<div style="top:0"></div>
<div style="top:0"></div>
<div style="top:0"></div>
<div style="top:0"></div>
<div>flex-start</div>
	</div><div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div>flex-end</div>
	</div>
	<div>
<div style="top:0.5rem"></div>
<div style="top:1.5rem"></div>
<div style="top:1rem"></div>
<div style="top:0"></div>
<div>center</div>

	</div><div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div>stretch</div>
	</div>
<!--
	bottom1 + bottom2 = 4.6,
	bottom2 + font-size = 5/3/4/6 − 0.3
-->
	<div style="width:91.6%; height:7rem;">
<div style="bottom:1.2rem;"><div style="bottom:3.4rem;font-size:1.3rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:2.9rem;"><div style="bottom:1.7rem;font-size:0.9rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:3.0rem;"><div style="bottom:1.6rem;font-size:2rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:0;"><div style="bottom:4.6rem;font-size:1.1rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div>baseline</div>
	</div>

</div>


<div id="_dgm-align-content-example">

	<div>
<div style="top:0"></div>
<div style="top:50px"></div>
<div style="top:100px"></div>
<div>flex-start</div>
	</div>
	<div>
<div style="bottom:100px"></div>
<div style="bottom:50px"></div>
<div style="bottom:0"></div>
<div>flex-end</div>
	</div>
	<div>
<div style="top:50px"></div>
<div style="top:100px"></div>
<div style="bottom:50px"></div>
<div>center</div>
	</div>
	<div>
<div style="top:0px"></div>
<div style="top:100px"></div>
<div style="bottom:0px"></div>
<div>space-between</div>
	</div>
	<div>
<div style="top:17px"></div>
<div style="top:100px"></div>
<div style="bottom:17px"></div>
<div>space-around</div>
	</div>
	<div>
<div style="height:83px;top:0"></div>
<div style="height:84px;top:83px"></div>
<div style="height:83px;bottom:0"></div>
<div>stretch</div>
	</div>
</div>

</div>

<header>
	<hgroup>
<h1 id="title">CSS 自在ボックス レイアウト — CSS Flexible Box Layout Module Level 1</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~UI設計に最適化された CSS ~box~modelについて述べる。
~flex~layout~modelにおいては，
~flex容器の一連の子を任意の方向に~lay-outしつつ，それらの大きさも “`flex^en （伸縮可能）” にする
—
すなわち，未使用の空間を埋めるように大きくしたり, 逆に 親からはみ出さないように縮めたりできる。
また、縦横いずれの方向にも，一連の子の整列を容易に操作できる。
これらの~boxの入子ng（縦~boxの内側の横~box, あるいは その逆）も，二次元な~layoutを築くために利用できる。
◎
The specification describes a CSS box model optimized for user interface design. In the flex layout model, the children of a flex container can be laid out in any direction, and can “flex” their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated. Nesting of these boxes (horizontal inside vertical, or vertical inside horizontal) can be used to build layouts in two dimensions.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
これは編集者草案の公な複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">~CSS日本語訳 共通~page</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
CSS 2.1 にて定義される~layout~mode
—
~boxの~sizeと位置を，その同胞の~boxと, その先祖の~boxとの関係性に基づいて決定する~algo
—
には，次の４種がある：
◎
CSS 2.1 defined four layout modes — algorithms which determine the size and position of boxes based on their relationships with their sibling and ancestor boxes:
</p>

<ul class="compact">
	<li>
文書を~lay-outするために設計された塊~layout
◎
block layout, designed for laying out documents
</li>
	<li>
~textを~lay-outするために設計された行内~layout
◎
inline layout, designed for laying out text
</li>
	<li>
二次元な~dataを~table状に~lay-outするために設計された~table~layout
◎
table layout, designed for laying out 2D data in a tabular format
</li>
	<li>
文書~内の他の要素にさほど関わり無く，~~明確な位置決めにより~lay-outするために設計された positioned ~layout
【 `position$p:fixed や `position$p:absolute 等による ~layout 】
◎
positioned layout, designed for very explicit positioning without much regard for other elements in the document
</li>
</ul>

<p>
この~moduleは，新たな~layout~mode
`~flex~layout@
を導入する。
それは，より複階的な~appや~web~pageを~lay-outするために設計されたものである。
◎
This module introduces a new layout mode, flex layout, which is designed for laying out more complex applications and webpages.
</p>

		<section id="overview">
<h3 title="Overview">1.1. 概観</h3>

~INFORMATIVE

<p>
~flex~layoutは、表面的には塊~layoutに類似する。
それは、［
`float$p
や
<a href="~CSSMCOL">~col</a>
］などの，塊~layoutに利用できる［
より複階的な，~textや文書を~~主対象にする 多くの~prop
］は欠く一方で、~web~appや複階的な~web~pageによく必要とされるような，種々の［
空間の配分-法や内容の整列-法
］のための，単純かつ強力な道具を得られる。
~flex容器の内容は：
◎
Flex layout is superficially similar to block layout. It lacks many of the more complex text- or document-centric properties that can be used in block layout, such as floats and columns. In return it gains simple and powerful tools for distributing space and aligning content in ways that web apps and complex web pages often need. The contents of a flex container:
</p>

<ul>
	<li>
どの
<a href="#flex-direction-property">~flow方向</a>
にも（左方, 右方, 下方, あるいは上方へも！）~lay-outできる
◎
can be laid out in any flow direction (leftwards, rightwards, downwards, or even upwards!)
</li>
	<li>
それらの陳列-順序を~style層にて，
<a href="#valdef-flex-direction-row-reverse">逆順</a>にしたり,
<a href="#order-property">配置替え</a>できる（すなわち，~sourceや発話の順序とは独立に，視覚的な順序を与えられる）
◎
can have their display order reversed or rearranged at the style layer (i.e., visual order can be independent of source and speech order)
</li>
	<li>
単独の軸（ `主-軸$ ）沿いに一次元に~lay-outしたり,
第二の軸（ `交叉-軸$ ）沿いに, 複数~行fに渡るように
<a href="#flex-wrap-property">折返す</a>ことができる。
◎
can be laid out linearly along a single (main) axis or wrapped into multiple lines along a secondary (cross) axis
</li>
	<li>
それらの~sizeは`可用な空間$に応じて
<a href="#flexibility">“~flex”</a>
（伸縮可能）になれる。
◎
can “flex” their sizes to respond to the available space
</li>
	<li>
それらを，それらの容器に対して, あるいは互いどうしを`交叉-軸$沿いに<a href="#alignment">整列させ</a>られる。
【 整列 — この訳の中の語 “~~整列” はすべて， “ソート（ `sort^en ）” ではなく “揃え（ `align^en ）” の方を意味する。】
◎
can be aligned with respect to their container or each other on the secondary (cross)
</li>
	<li>
容器の`交叉size$は保全しつつ、`主-軸$沿いに，動的に
<a href="#visibility-collapse">畳んだり</a>（ `collapse^en ）, その逆にできる。
◎
can be dynamically collapsed or uncollapsed along the main axis while preserving the container’s cross size
</li>
</ul>

<div class="example">

<p>
ここに、各~駒が［
~~見出し, 写真, ~~説明, 購入ボタン
］を備えている，ある目録の例を示す。
~layoutの中で各~駒が占める~~区画の~sizeは，~~説明の長さに関わらず どれも同じになり、各~~区画の中では，写真が~~見出しより上に~~位置し, 購入ボタンは下端に整列されるようにしたいとする。
この設計の多くの側面は、~flex~layoutにより，容易に為せる：
◎
Here’s an example of a catalog where each item has a title, a photo, a description, and a purchase button. The designer’s intention is that each entry has the same overall size, that the photo be above the text, and that the purchase buttons are aligned at the bottom, regardless of the length of the item’s description. Flex layout makes many aspects of this design easy:
</p>

<ul>
	<li>
目録では，一連の駒を 何本かの~rowに渡って横方向に~lay-outした上で、同じ~rowの中では その中の各~駒の縦幅が等しくなるように，~flex~layoutを利用する。
各~~~区画は、それ自身が 1 本の~colを成す~flex容器になり，その内容を縦方向に~lay-outする。
◎
The catalog uses flex layout to lay out rows of items horizontally, and to ensure that items within a row are all equal-height. Each entry is then itself a column flex container, laying out its contents vertically.
</li>
	<li>
各~~区画の中では，~source文書~内容の論理-順序【 “文書~順序” 】は［
~~見出し, ~~説明, 写真
］の順にされる。
これは，発話や非~CSS~browserにおいても~~意味を成す順序付けを供する一方で、より視覚的な呈示においては、
`order$p を利用して 内容の後方に在る画像を上端に引き上げ，
`align-self$p を利用して それを横方向の中央に~~位置させることで，より注目を引くものにできる。
◎
Within each entry, the source document content is ordered logically with the title first, followed by the description and the photo. This provides a sensible ordering for speech rendering and in non-CSS browsers. For a more compelling visual presentation, however, order is used to pull the image up from later in the content to the top, and align-self is used to center it horizontally.
</li>
	<li>
購入ボタンに対する上側の`~auto_v~margin$により、どの~~区画の中でも，駒の~~説明の縦幅に関わらず，ボタンを下端に押しやる。
◎
An auto margin above the purchase button forces it to the bottom within each entry box, regardless of the height of that item’s description.
</li>
</ul>

<pre class="lang-css">
#deals {
  `display$p:flex;
      /* <span class="comment">
~flex~layoutにより，一連の駒は <a href="#propdef-align-self">縦幅が等しくされる</a>
◎
Flex layout so items have equal height
</span> */

  `flex-flow$p:row_wrap;
      /* <span class="comment">
一連の駒を，複数~行fに渡って折返す
◎
Allow items to wrap into multiple lines
</span> */
}
.sale-item {
  `display$p:flex;
      /* <span class="comment">
各~駒の内容も，~flex~layoutを利用して~lay-outする
◎
Lay out each item using flex layout
</span> */

  `flex-flow$p:column;
      /* <span class="comment">
駒の内容は縦方向に~lay-outする
◎
Lay out item’s contents vertically
</span> */
}
.sale-item &gt; img {
  `order$p:-1;
      /* <span class="comment">
画像を（視覚的な順序で）他の内容より前に~~移動する
◎
Shift image before other content (in visual order)
</span> */

  `align-self$p:center;
      /* <span class="comment">
画像を交叉-~~方向（横方向）の中央に据える
◎
Center the image cross-wise (horizontally)
</span> */
}
.sale-item &gt; button {
  `margin-top$p:auto;
      /* <span class="comment">
上端の`~auto_v~margin$によりボタンは下端へ押しやられる
◎
Auto top margin pushes button to bottom
</span> */
}
</pre>

`overview-example-code^dgm

<figure>`overview-example^dgm
<figcaption>
上の~codeの描画~例
◎
An example rendering of the code above.
</figcaption></figure>

</div>

		</section>
		<section id="placement">
<h3 title="Module interactions">1.2. ~module間の相互作用</h3>

<p>
この~moduleは、新たな［
`塊~level$, `行内~level$
］の`表示~型$を追加し，新たな種類の整形~文脈を その~layoutを制御する~propと伴に定義することにより、
`CSS2$r による `display$p ~propの定義を<a href="#propdef-display">拡張する</a>。
この~moduleにて定義される どの~propも，
`first-line$pe ／ `first-letter$pe
疑似要素には適用されない。
◎
This module extends the definition of the display property [CSS2], adding a new block-level and new inline-level display type, and defining a new type of formatting context along with properties to control its layout. None of the properties defined in this module apply to the ::first-line or ::first-letter pseudo-elements.
</p>

<p>
<a href="~CSSALIGN">CSS Box Alignment Module</a>
は、ここに導入する`整列~prop$（
`justify-content$p, `align-items$p, `align-self$p, `align-content$p
）の定義を拡張して，それらに取って代わる。
◎
The CSS Box Alignment Module extends and supersedes the definitions of the alignment properties (justify-content, align-items, align-self, align-content) introduced here.
</p>

		</section>
		<section id="values">
<h3 title="Values Definitions">1.3. 値~定義</h3>

<p class="trans-note">【
この節の内容は <a href="css-common-ja.html#values">~CSS日本語訳 共通~page</a> に委譲。
】</p>

		</section>
	</section>
	<section id="box-model">
<h2 title="Flex Layout Box Model and Terminology">2. ~flex~layoutの~box~modelとその各種用語</h2>

<p>
`~flex容器@
とは、［
`display$p ~propの算出d値が［
`flex$v:d または `inline-flex$v:d
］になる要素
］により生成される~boxである。
~flex容器の`~flow内$にある各~子は，
`~flex駒@
と呼ばれ、~flex~layout~modelを利用して~lay-outされる。
◎
A flex container is the box generated by an element with a computed display of flex or inline-flex. In-flow children of a flex container are called flex items and are laid out using the flex layout model.
</p>

<p>
~layoutの計算は、
<a href="~CSSWM#abstract-box">［ 塊／行内 ］~flow方向</a>
に重きが置かれた［
塊／行内
］~layoutとは異なり，~flex~layoutでは
`~flex方向@
に重きが置かれる。
~flex~layoutについて~~述べ易くするため、この節では~flex~flowに相対的な用語を定義する。
`flex-flow$p 値と`書字mode$は、これらの用語が，どのように物理的な［
方向（上端／右端／下端／左端）,
軸（縦／横）,
~size（横幅／縦幅）
］に対応付けられるかを決定する。
◎
Unlike block and inline layout, whose layout calculations are biased to the block and inline flow directions, flex layout is biased to the flex directions. To make it easier to talk about flex layout, this section defines a set of flex flow–relative terms. The flex-flow value and the writing mode determine how these terms map to physical directions (top/right/bottom/left), axes (vertical/horizontal), and sizes (width/height).
</p>

<figure>

【！ flex-direction-terms^dgm】

<svg
	id="flex-direction-terms"
	xmlns="http://www.w3.org/2000/svg"
	width="100%"
	style="max-width: 680px;"
	viewBox="-50 -40 680 280"

	font-family="sans-serif"
	text-anchor="middle"
	font-size="18"
	color="black"
>

	<g fill="#ddd" stroke="none">
<rect fill="#888" x="0" y="0" width="500" height="120" rx="10" ry="10" />
<rect x="5" y="5" width="150" height="110" rx="5" ry="5" />
<rect x="160" y="5" width="335" height="110" rx="5" ry="5" />
	</g>

	<g
color="white"
font-size="40"
font-weight="bold"
	>
<text x="75" y="75">1</text>
<text x="328" y="75">2</text>
	</g>

	<g
font-size="16"
font-style="italic"
fill="#444"
	>
<text x="150" y="110" text-anchor="end">~flex駒</text>
<text x="165" y="110" text-anchor="start">~flex駒</text>
<text x="155" y="136">~flex容器</text>
	</g>

	<g
class="side"
stroke-width="3"
stroke-dasharray="5 5"
	>
		<g transform="translate(1.5,120)">
<path d="M 0 -10 v 40"/>
<text x="0" y="40">主-始端</text>
		</g>
		<g transform="translate(498.5,120)">
<path d="M 0 -10 v 40"/>
<text x="0" y="40">主-終端</text>
		</g>
		<g transform="translate(503,1.5)">
<path d="M -10 0 h 40"/>
<text x="25" y="4" style="text-anchor: start;">交叉-始端</text>
		</g>
		<g transform="translate(503,118.5)">
<path d="M -10 0 h 40"/>
<text x="25" y="4" style="text-anchor: start; ">交叉-終端</text>
		</g>
	</g>

	<g
class="axis"
stroke-width="3"
	>
		<g transform="translate(0,60)">
<path
	d="
M7.5,0
a5,5 0,0,0 -10,0 a5,5 0,0,0 10,0
h 600
h-5 l0,-3 10,3 -10,3 0,-3"
/>
<text x="550" y="-8">主-軸</text>
		</g>
		<g transform="translate(250,0)rotate(90)">
<path
	d="
M 7.5 0
a5,5 0,0,0 -10,0 a5,5 0,0,0 10,0
h 220
h-5 l0,-3 10,3 -10,3 0,-3"
/>
<text x="180" y="-8">交叉-軸</text>
		</g>
	</g>

	<g
class="size"
stroke-width="2"
	>
		<g transform="translate(0,-15)">
<path d="M1,10 v-10 h498 v10" />
<text x="250" y="-4">主size</text>
		</g>
		<g transform="translate(-15,120) rotate(-90)">
<path d="M1,10 v-10 h118 v10" />
<text x="60" y="-4">交叉size</text>
		</g>
	</g>

</svg>

<figcaption>
`row$v:fd ~flex容器に適用される種々の［
方向や~sizing
］のための用語の図示
◎
An illustration of the various directions and sizing terms as applied to a row flex container.
</figcaption></figure>

<dl id="main">
	<dt class="axis" title="main axis">主-軸</dt>
	<dt class="axis" title="main dimension">主-次元</dt>
	<dd>
~flex容器の
`主-軸@
とは、`~flex駒$がその軸~沿いに~lay-outされ,
`主-次元@
に延伸する，首な軸である。
◎
The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.
</dd>
	<dd class="trans-note">【
この仕様の “~~次元（ `dimension^en ）” は、もっぱら，縦横いずれかの軸~方向の計量を意味する。
】</dd>

	<dt class="side" title="main-start">主-始端</dt>
	<dt class="side" title="main-end">主-終端</dt>
	<dd>
一連の`~flex駒$は，
`主-始端@
側から
`主-終端@
側へ向けて
容器~内に配置される。
◎
The flex items are placed within the container starting on the main-start side and going toward the main-end side.
</dd>

	<dt class="size" title="main size">主size</dt>
	<dt class="size" title="main size property">主size~prop</dt>
	<dd>
［
`~flex容器$／`~flex駒$
］の［
横幅, 縦幅
］のうち，`主-次元$に属する方が，その
`主size@
になる。
その~boxの
`主size~prop@
は、［
`width$p, `height$p
］のうち，`主-次元$に属する方の~propを指す。
◎
The width or height of a flex container or flex item, whichever is in the main dimension, is that box’s main size. Its main size property is thus either its width or height property, whichever is in the main dimension.＼
</dd>
	<dd>
同様に，［
`最小-主size~prop@
／
`最大-主size~prop@
］は、［［
`min-width$p, `min-height$p
］ ／ ［
`max-width$p, `max-height$p
］］のうち，`主-次元$に属する方の~propを指し、［
`最大-主size@
／
`最小-主size@
］を決定する。
◎
Similarly, its min and max main size properties are its min-width/max-width or min-height/max-height properties, whichever is in the main dimension, and determine its min/max main size.
</dd>
</dl>

<dl id="cross">
	<dt class="axis" title="cross axis">交叉-軸</dt>
	<dt class="axis" title="cross dimension">交叉-次元</dt>
	<dd>
`主-軸$に垂直な軸は
`交叉-軸@
と呼ばれ，
`交叉-次元@
に延伸する。
◎
The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.
</dd>
	<dd class="trans-note">【
この訳では、 “`cross^en” の対訳に “~~交差” ではなく “~~交叉” を用いる。
“~~叉” の方が視覚的なイメージに合うこと, および
“~~交差” は “`intersect^en” の対訳に利用される場合も多いので。
】</dd>

	<dt class="side" title="cross-start">交叉-始端</dt>
	<dt class="side" title="cross-end">交叉-終端</dt>
	<dd>
それぞれが一連の駒により埋められる，一連の
<a href="#flex-lines">~flex行l</a>
は、~flex容器の
`交叉-始端@
側から
`交叉-終端@
側に向けて，容器~内に配置される
◎
Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.
</dd>

	<dt class="size" title="cross size">交叉size</dt>
	<dt class="size" title="cross size property">交叉size~prop</dt>
	<dd>
［
`~flex容器$／`~flex駒$
］の［
横幅, 縦幅
］のうち，`交叉-次元$に属する方が，その
`交叉size@
になる。
その~boxの
`交叉size~prop@
は、［
`width$p, `height$p
］のうち，`交叉-次元$に属する方の~propを指す。
◎
The width or height of a flex container or flex item, whichever is in the cross dimension, is that box’s cross size. Its cross size property is thus either its width or height property, whichever is in the cross dimension.
</dd>
	<dd>
同様に，［
`最小-交叉size~prop@
／
`最大-交叉size~prop@
］は、［［
`min-width$p, `min-height$p
］ ／ ［
`max-width$p, `max-height$p
］］のうち，`交叉-次元$に属する方の~propを指し、［
`最大-交叉size@
／
`最小-交叉size@
］を決定する。
◎
Similarly, its min and max cross size properties are its min-width/max-width or min-height/max-height properties, whichever is in the cross dimension, and determine its min/max cross size
</dd>
</dl>

<p>
この仕様に利用される，~sizingに関する追加的な用語は、
<a href="~SIZING">CSS 内在的＆外在的~sizing</a>
仕様にて定義される。
`CSS-SIZING-3$r 
◎
Additional sizing terminology used in this specification is defined in CSS Intrinsic and Extrinsic Sizing. [CSS-SIZING-3]
</p>

	</section>
	<section id="flex-containers">
<h2 title="Flex Containers: the flex and inline-flex display values">3. ~flex容器： `display^p 値 `flex^v, `inline-flex^v</h2>

◎名 <a id="propdef-display">`display$p</a>
◎新値 `flex$v:d | `inline-flex$v:d
◎表終

<dl>
	<dt>`flex@v:d</dt>
	<dd>
この値は、要素に`~flex容器$~boxを生成させる
— `~flow~layout$内に配置されたときには、`塊~level$になるような。
◎
This value causes an element to generate a flex container box that is block-level when placed in flow layout.
</dd>

	<dt>`inline-flex@v:d</dt>
	<dd>
この値は、要素に`~flex容器$~boxを生成させる
— `~flow~layout$内に配置されたときには、`行内~level$になるような。
◎
This value causes an element to generate a flex container box that is inline-level when placed in flow layout.
</dd>
</dl>

<p>
`~flex容器$は、その内容に対し，新たな
`~flex整形~文脈@
を確立する。
これは、その内容の~layoutおいては，塊~layoutに代えて~flex~layoutが利用されることを除き，塊~整形~文脈を確立することと同じになる：
例えば、`浮動体$が~flex容器~内に侵入することはなく，~flex容器の~marginとその内容の~marginとの間も相殺されることはない。
`~flex容器$は、自身の内容~用の包含塊を，
<a href="~CSS2VISUDET#containing-block-details">塊~容器と正確に同じ様に</a>
形成する
`CSS2$r
。
`overflow$p ~propは、`~flex容器$にも適用される。
◎
A flex container establishes a new flex formatting context for its contents. This is the same as establishing a block formatting context, except that flex layout is used instead of block layout. For example, floats do not intrude into the flex container, and the flex container’s margins do not collapse with the margins of its contents. Flex containers form a containing block for their contents exactly like block containers do. [CSS2] The overflow property applies to flex containers.
</p>

<p>
~flex容器は`塊~容器$ではないので、塊~layoutを前提に設計された一部の~propは，~flex~layoutの文脈~下では適用されない。
特に：
◎
Flex containers are not block containers, and so some properties that were designed with the assumption of block layout don’t apply in the context of flex layout. In particular:
</p>

<ul>
	<li>
`float$p は、`~flex駒$を浮動させたり，それを`~flow外$にすることはない。
`clear$p も~flex駒に対する`~clearance$を作成しない。
◎
float and clear do not create floating or clearance of flex item, and do not take it out-of-flow.
</li>
	<li>
`vertical-align$p は、~flex駒に対しては 効果はない。
◎
vertical-align has no effect on a flex item.
</li>
	<li>
<p>
疑似要素［
`first-line$pe ／ `first-letter$pe
］は、`~flex容器$には適用されない。
`~flex容器$は、［
`整形される最初の行l$や, 最初の字l
］を先祖に供与しない。
◎
the ::first-line and ::first-letter pseudo-elements do not apply to flex containers, and flex containers do not contribute a first formatted line or first letter to their ancestors.
</p>

	</li>
</ul>

<div class="p">
<p>
要素に指定された `display$p が `inline-flex$v:d である場合、その `display$p ~propの算出d値は，一定の状況下で `flex$v:d になる —
<a href="~CSS2VISUREN#dis-pos-flo">CSS 2.1, § 9.7</a>
の表は、次の行を追加するように改正される：
</p>

<table><thead><tr><th>指定d値
<th>算出d値
</thead>

<tbody><tr><td>`inline-flex$v:d
<td>`flex$v:d
</tbody></table>

◎
If an element’s specified display is inline-flex, then its display property computes to flex in certain circumstances: the table in CSS 2.1 Section 9.7 is amended to contain an additional row, with inline-flex in the "Specified Value" column and flex in the "Computed Value" column.
</div>

	</section>
	<section id="flex-items">
<h2 title="Flex Items">4. ~flex駒</h2>

<p>
大雑把に言えば、`~flex容器$の`~flex駒$とは，その`~flow内$にある内容を表現している~boxである。
◎
Loosely speaking, the flex items of a flex container are boxes representing its in-flow contents.
</p>

<p>
`~flex容器$の`~flow内$にある各~子は，`~flex駒$になり、各［
`~flex容器$内の連続している子が成す，`~text連なり$
］は，`匿名$かつ`塊~容器$である`~flex駒$で包装される。
ただし，そのような`~text連なり$が
<a href="~CSS22/text.html#white-space-prop">空白</a>
（すなわち， `white-space$p ~propに影響され得る文字
【 <a href="~CSSTEXT#white-space" >文書~空白~文字</a>】
）のみからなる場合、描画されない（対応する`~text~node$は `display$p:none にされていたかのように）。
◎
Each in-flow child of a flex container becomes a flex item, and each contiguous sequence of child text runs is wrapped in an anonymous block container flex item. However, if the entire sequence of child text runs contains only white space (i.e. characters that can be affected by the white-space property) it is instead not rendered (just as if its text nodes were display:none).
</p>

<div class="example">
<p>
~flex駒のいくつかの例：
◎
Examples of flex items:
</p>

<pre class="lang-html">
&lt;div style="`display$p:flex"&gt;

    &lt;!-- <span class="comment">
~flex駒：子~塊
◎
flex item: block child
</span> --&gt;
    &lt;div id="item1"&gt;block&lt;/div&gt;

    &lt;!-- <span class="comment">
~flex駒： 浮動された要素 — その効果は無視される
◎
flex item: floated element; floating is ignored
</span> --&gt;
    &lt;div id="item2" style="`float$p:left;"&gt;float&lt;/div&gt;

    &lt;!-- <span class="comment">
~flex駒： 行内~内容を囲う匿名~塊~box
◎
flex item: anonymous block box around inline content
</span> --&gt;
    anonymous item 3

    &lt;!-- <span class="comment">
~flex駒： 行内の子
◎
flex item: inline child
</span> --&gt;
    &lt;span&gt;
        item 4
        &lt;!-- <span class="comment">
~flex駒は塊の周囲で分割されることはない
◎
flex items do not split around blocks
</span> --&gt;
        &lt;q style="display: block" id=not-an-item&gt;item 4&lt;/q&gt;
        item 4
    &lt;/span&gt;
&lt;/div&gt;
</pre>

<figure>
<figcaption>
上の~code~blockから決定される~flex駒
（<a href="~CSSWG/css-flexbox/examples/flex-item-determination.html">実演</a>）
◎
Flex items determined from above code block
</figcaption>
`flex-item-determination^dgm
</figure>

<p>
要素~間の空白は、消え去ることに注意：
要素たちの狭間の~textは，自前の匿名~flex駒~内で `包装される^emが、それでも空白のみが~flex駒を成すことはない。
◎
Note that the inter-element white space disappears: it does not become its own flex item, even though the inter-element text does get wrapped in an anonymous flex item.
</p>

<p>
匿名~駒の~boxには、~style規則をアテガう要素がないため，~styleをあてがえないことに注意。
しかしながら、その内容は，~flex容器から~styleを継承する（~font設定群など）。
◎
Note also that the anonymous item’s box is unstyleable, since there is no element to assign style rules to. Its contents will however inherit styles (such as font settings) from the flex container.
</p>

</div>

<p>
`~flex駒$は、その内容~用に`独立な整形~文脈を確立する$。
しかしながら、~flex駒~自体は，`塊~level$の~boxではなく，
`~flex~level@
の~boxになる：
それらは、塊~整形~文脈ではなく，容器の~flex整形~文脈に関与する。
◎
A flex item establishes an independent formatting context for its contents. However, flex items themselves are flex-level boxes, not block-level boxes: they participate in their container’s flex formatting context, not in a block formatting context.
</p>

<hr />

<p class="note">注記：
この仕様を読む~web~page作者【 以下，単に “作者” 】は、以下に与える~box生成と静的~位置についての詳細を飛ばして，<a href="#item-margins">先に進んでも</a>よい。
◎
Note: Authors reading this spec may want to skip past the following box-generation and static position details.
</p>

<p>
所与の要素に対し，［
その先祖であって `display$p の`算出d値$が `contents^v でないもののうち，要素に最も近いもの
］の `display$p の`算出d値$が［
`flex$v:d ／ `inline-flex$v:d
］である場合、要素の自前の `display$p 値は，`塊~化$される。
（この種の `display$p 値の変換の詳細は、
<a href="~CSS2VISUREN#dis-pos-flo">CSS2.1, § 9.7</a>
`CSS2$r と
<a href="~CSSDISP#transformations">§ ~box型の自動的な変形n</a>
`CSS-DISPLAY-3$r
を見よ。）
◎
If the computed display value of an element’s nearest ancestor element (skipping display:contents ancestors) is flex or inline-flex, the element’s own display value is blockified. (See CSS2.1§9.7 [CSS2] and CSS Display 3 §2.7 Automatic Box Type Transformations for details on this type of display value conversion.)
</p>

<p class="note">注記：
この塊~化は、当の［
`flex^v ／ `inline-flex^v
］にされた先祖が`~flex容器$を生成しない場合でも，依然として生じる
— 例： それが［
`置換され$る ／ `display$p:none にされた下位tree内にある
］場合でも。
◎
Note: Blockification still occurs even when the flex or inline-flex element does not end up generating a flex container box, e.g. when it is replaced or in a display: none subtree.
</p>

<p class="note">注記：
`display$p の値のうち，一部のものは、通常は，元の~boxを囲う匿名~boxの作成を誘発する。
そのような~boxが`~flex駒$であった場合、最初に`塊~化$されるので，匿名~boxの作成は起こらない。
例えば，連続する 2 個の［
`display$p:table-cell にされた子~要素
］が与えられた下では、その 2 個が単独の匿名~table~boxに包装されることはなく，別々の `display$p:block にされた`~flex駒$になる。
◎
Note: Some values of display normally trigger the creation of anonymous boxes around the original box. If such a box is a flex item, it is blockified first, and so anonymous box creation will not happen. For example, two contiguous flex items with display: table-cell will become two separate display: block flex items, instead of being wrapped into a single anonymous table.
</p>

<p>
`~flex駒$が `display$p:table にされた事例では、その~flex駒が`~table包装~box$になり， `order$p, `align-self$p ~propも適用される。
~caption~boxもあれば、その内容は~table包装~boxの［
`最小-内容~size$, `最大-内容~size$
］の計算に供与される。
しかしながら，［
`width$p, `height$p
］と同様、
`flex$p の各種 下位propは，次に従うように~table~boxに適用される：
`~flex駒$ の最終的な~sizeは、［［
~table包装~boxの各~辺と~table~boxの各~内容~辺との合間の距離
］が［
~table~boxの ~borderと~padding区画の全部
］を成していて, ~table~boxは`~flex駒$であった
］かのように，~layoutを遂行することにより計算される。
◎
In the case of flex items with display: table, the table wrapper box becomes the flex item, and the order and align-self properties apply to it. The contents of any caption boxes contribute to the calculation of the table wrapper box’s min-content and max-content sizes. However, like width and height, the flex longhands apply to the table box as follows: the flex item’s final size is calculated by performing layout as if the distance between the table wrapper box’s edges and the table box’s content edges were all part of the table box’s border+padding area, and the table box were the flex item.
</p>

		<section id="abspos-items">
<h3 title="Absolutely-Positioned Flex Children">4.1. 絶対的に位置された子 ~flex</h3>

<p>
`~flex容器$（以下，この節では単に %容器 と記す）の子のうち，`絶対的に位置され$たもの（以下，単に %子 と記す）は、`~flow外$にあるので，~flex~layoutには関与しない。
◎
As it is out-of-flow, an absolutely-positioned child of a flex container does not participate in flex layout.
</p>

<p>
%子 の`静的~位置$は、［
%子 も %容器 も［
その~sizeは，各自の使用~sizeに固定された~boxである
］と見做す下で、 %子 を［
それが %容器 の中の唯一の`~flex駒$であった
］かのように位置する
］ことにより，決定される。
この目的においては、~marginに対する `auto^v は， 0 に扱われる。
◎
The static position of an absolutely-positioned child of a flex container is determined such that the child is positioned as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed-size boxes of their used size. For this purpose, auto margins are treated as zero.
</p>

<div class="note">

<p id="static-position-rectangle">注記：
言い換えれば、
%子 の`静的~位置~矩形$は， %容器 の内容~boxで与えられ、それが
%子 の`静的~位置$の~offsetを決定するために利用される`整列~容器$になる。
◎
In other words, the static-position rectangle of an absolutely-positioned child of a flex container is the flex container’s content box, where the static-position rectangle is the alignment container used to determine the static-position offsets of an absolutely-positioned box.
</p>

<p>
（塊~layoutにおける`静的~位置~矩形$は、
CSS2.1
【！<a href="~CSS2VISUDET#abs-non-replaced-width">CSS2.1, § 10.3.7</a>】
に述べられている
“<a href="~CSSPOS#_css2-static-position">仮の~box</a>”
の位置に対応する。
CSS2.1 の下では，`整列~prop$は無いため、`静的~位置~矩形$の中での`絶対的に位置され$た~boxの整列には，常に［
`塊-始端$／`行内-始端$
］が利用される。
この定義は、最終的には， `CSS-POSITION-3$r に移動されることに注意。）
◎
(In block layout the static position rectangle corresponds to the position of the “hypothetical box” described in CSS2.1§10.3.7. Since it has no alignment properties, CSS2.1 always uses a block-start inline-start alignment of the absolutely-positioned box within the static-position rectangle. Note that this definition will eventually move to the CSS Positioning module.)
</p>

</div>

<div class="example">
<p>
このことから、例えば， %子 に `align-self$p:center を設定した場合、
%子 に対する `auto^v による~offsetは， %容器 の`交叉-軸$において中央~寄せにすることになる。
◎
The effect of this is that if you set, for example, align-self: center; on an absolutely-positioned child of a flex container, auto offsets on the child will center it in the flex container’s cross axis. 
</p>

<p>
しかしながら、 絶対的に位置された~boxは，
“固定d~size”
と見なされるので、値 `stretch$v:ais は， `flex-start$v:ais と同じに扱われる。
◎
However, since the absolutely-positioned box is considered to be “fixed-size”, a value of stretch is treated the same as flex-start.
</p>

</div>

		</section>
		<section id="item-margins">
<h3 title="Flex Item Margins and Paddings">4.2. ~flex駒の~marginと~padding</h3>

<p>
隣接な 2 個の`~flex駒$の~marginは`相殺-$されない。
◎
The margins of adjacent flex items do not collapse.
</p>

<p>
`~flex駒$ %駒 上の百分率による［
~margin／~padding
］は、 %駒 の`包含塊$の`行内~size$を基準に解決される
— `塊~box$のときと同様に。
例えば，横書き`書字mode$の下では、［
左端, 右端, 上端, 下端
］のいずれも，百分率は包含塊の横幅を基準に解決される。
◎
Percentage margins and paddings on flex items, like those on block boxes, are resolved against the inline size of their containing block, e.g. left/right/top/bottom percentages all resolve against their containing block’s width in horizontal writing modes.
</p>

<p>
自動~marginは、対応する次元の余った空間を吸収するように拡幅される。
これを利用して、~flex駒に対し，互いを整列させたり, 隣接なものを離れた所へ押出すことができる。
`~auto_v~margin$による整列-法を見よ。
◎
Auto margins expand to absorb extra space in the corresponding dimension. They can be used for alignment, or to push adjacent flex items apart. See Aligning with auto margins.
</p>

		</section>
		<section id="painting">
<h3 title="Flex Item Z-Ordering">4.3. ~flex駒の z ~~方向の順序付け</h3>

<p>
`~flex駒$は、次の二点を除いて，行内~塊 `CSS2$r と正確に同じに塗られる：
◎
Flex items paint exactly the same as inline blocks [CSS2], except that＼
</p>
<ul>
	<li>
そのままの文書~順序に代えて，
`order$p により`改変された文書~順序$が利用される。
◎
order-modified document order is used in place of raw document order,＼
</li>
	<li>
`position$p が `static^v であっても、［
`auto^v 以外の `z-index$p 値
］により，積層~文脈が作成される（ `position$p が `relative^v であったときと正確に同じに挙動する）。
◎
and z-index values other than auto create a stacking context even if position is static (behaving exactly as if position were relative).
</li>
</ul>

<p class="note">注記：
~flex駒の子孫は、駒の外側に位置させられても，駒により確立される積層~文脈に関与する。
◎
Note: Descendants that are positioned outside a flex item still participate in any stacking context established by the flex item.
</p>

		</section>
		<section id="visibility-collapse">
<h3 title="Collapsed Items">4.4. 畳まれる駒</h3>

<p>
~flex駒~上にて
`visibility$p:collapse
を指定することにより，~flex駒は
`畳まれ@
、［
`table-row^v や `table-column^v 上の `visibility$p:collapse
］と類似な効果を生産する：
`畳まれ$た~flex駒は，描画~対象からは まるごと外されるが、~flex行lの交叉sizeを安定に保つため， “支柱【概念的な突っ支い棒】” だけ居残るようにされる。
したがって，~flex容器の~flex行lが一本だけの場合、駒が`畳まれ$るかどうかが動的に~~変化しても，`~flex容器$の`主size$は変化し得るが，`交叉size$には効果を及ぼさず、~pageの~layoutの残りの部分を “揺らがす” ことはないことが保証される。
一方で，複数~行fを伴う~flex容器の交叉sizeは、［
~flex行lの折返ngが，駒を畳んだ後にも `再び行われる^em†
］ので，変化し得る。
◎
Specifying visibility:collapse on a flex item causes it to become a collapsed flex item, producing an effect similar to visibility:collapse on a table-row or table-column: the collapsed flex item is removed from rendering entirely, but leaves behind a "strut" that keeps the flex line’s cross-size stable. Thus, if a flex container has only one flex line, dynamically collapsing or uncollapsing items may change the flex container’s main size, but is guaranteed to have no effect on its cross size and won’t cause the rest of the page’s layout to "wobble". Flex line wrapping is re-done after collapsing, however, so the cross-size of a flex container with multiple lines might or might not change.
</p>

<p class="trans-note">【
“畳む”（ `collapse^en する）
— ~marginの~~相殺（ `collapse^en ）とは ある~~意味~~似て異なる（一般英語としては同じ概念であろうが）。
】【†
すなわち，駒が`畳まれ$ることにより、次の行fに折返された後続の駒が，駒と同じ行fに繰り上げられる。
】</p>

<p>
`畳まれ$た~flex駒は描画されないが，`整形~構造$には現れる。
従って，
`display$p:none `CSS2$r
にされた駒と異なり、整形~構造の下で~boxの出現に依存する効果（ `counter^en の増加, あるいは~animationや遷移【 CSS Animation, CSS Transition 】を走らす, 等々）は、依然として，`畳まれ$た駒に対しても演算される。
◎
Though collapsed flex items aren’t rendered, they do appear in the formatting structure. Therefore, unlike on display:none items [CSS2], effects that depend on a box appearing in the formatting structure (like incrementing counters or running animations and transitions) still operate on collapsed items.
</p>

<div class="example">
<p>
次の例では、左に位置する~sidebarが，その内容を収めるように~sizeされる。
~navi~sidebarの部品を
— その最も幅広な駒（ “Architecture” ）が畳まれる区分に入っているとしても，~sidebarの横幅に影響しないように —
動的に隠すために， `visibility$p:collapse が利用される。
◎
In the following example, a sidebar is sized to fit its content. visibility: collapse is used to dynamically hide parts of a navigation sidebar without affecting its width, even though the widest item (“Architecture”) is in a collapsed section.
</p>

<figure>

<figcaption>
下記の~code例の生きた描画~見本：
◎
Sample live rendering for example code below
</figcaption>

<div id="_dgm-visibility-collapse-example">
	<nav>
		<ul>
			<li id="nav-about"><a href="#nav-about">About</a>
				<ul>
<li><a href="#_dummy">History</a></li>
<li><a href="#_dummy">Mission</a></li>
<li><a href="#_dummy">People</a></li>
				</ul>
			</li>
			<li id="nav-projects"><a href="#nav-projects">Projects</a>
				<ul>
<li><a href="#_dummy">Art</a></li>
<li><a href="#_dummy">Architecture</a></li>
<li><a href="#_dummy">Music</a></li>
				</ul>
			</li>
				<li id="nav-interact"><a href="#nav-interact">Interact</a>
				<ul>
<li><a href="#_dummy">Blog</a></li>
<li><a href="#_dummy">Forums</a></li>
				</ul>
			</li>
		</ul>
	</nav>
	<article>
左の~menu上を~hoverすると、~hoverされた~menu項目は，その下位~駒を示すように拡幅される。
~sidebarの横幅（および この主-区画の横幅）を安定に保つため、
`display$p:none に代えて，
`visibility$p:collapse が利用される。
この結果，~sidebarは常に、普段は可視でない長めの単語 “Architecture” にも十分な幅がとられる。
◎
Hover over the menu to the left: each section expands to show its sub-items. In order to keep the sidebar width (and this main area width) stable, visibility: collapse is used instead of display: none. This results in a sidebar that is always wide enough for the word “Architecture”, even though it is not always visible.
	</article>
</div>

<p>【このページの実際の~codeでは、（~flex~~未対応~browserでも~~動作するように，）等価な挙動を模倣する~styleがあてがわれている。】</p>
</figure>

<pre class="lang-css">
@media (`min-width$d:60em) {
  /* <span class="comment">
（既定の~text~sizeに比して）十分な部屋があるときだけ， 2 本の~colで~layoutする◎
two column layout only when enough room (relative to default text size)
</span> */
  div { `display$p:flex; }
  #main {
    `flex$p:1;         /* <span class="comment">
残りの空間すべては <code class="css">#main</code> が占める
◎
Main takes up all remaining space
</span> */
    `order$p:1;        /* <span class="comment">
~navi（ <code class="element">nav</code> ）の後ろ（右側）に配置する
◎
Place it after (to the right of) the navigation
</span> */
    `min-width$p:12em; /* <span class="comment">
主-内容~区画の~sizingを最適化する
◎
Optimize main content area sizing
</span> */
  }
}
/* <span class="comment">
`visibility$p:collapse が働くよう，~menu項目には~flex~layoutを利用する
◎
menu items use flex layout so that visibility:collapse will work
</span> */
nav &gt; ul &gt; li {
  `display$p:flex;
  `flex-flow$p:column;
}
/* <span class="comment">
操作中でない下位~menuは，動的に畳まれる
◎
dynamically collapse submenus when not targetted
</span> */
nav &gt; ul &gt; li:not(:target):not(:hover) &gt; ul {
  `visibility$p:collapse;
}
</pre>

<pre class="lang-html">
&lt;/header&gt;
&lt;div&gt;
  &lt;article id="main"&gt;
    Interesting Stuff to Read
  &lt;/article&gt;
  &lt;nav&gt;
    &lt;ul&gt;
      &lt;li id="nav-about"&gt;&lt;a href="#nav-about"&gt;About&lt;/a&gt;
        …
      &lt;li id="nav-projects"&gt;&lt;a href="#nav-projects"&gt;Projects&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href="…"&gt;Art&lt;/a&gt;
          &lt;li&gt;&lt;a href="…"&gt;Architecture&lt;/a&gt;
          &lt;li&gt;&lt;a href="…"&gt;Music&lt;/a&gt;
        &lt;/ul&gt;
      &lt;li id="nav-interact"&gt;&lt;a href="#nav-interact"&gt;Interact&lt;/a&gt;
        …
    &lt;/ul&gt;
  &lt;/nav&gt;
&lt;/div&gt;
&lt;footer&gt;
…
</pre>

</div>

<p>
`支柱~size$を算出するためには：
◎
To compute the size of the strut,＼
</p>
<ol>
	<li>
最初に，すべての駒は`畳まれ$ないとする下で ~flex~layoutを遂行する。
◎
flex layout is first performed with all items uncollapsed,＼
</li>
	<li>
次に，`畳まれ$る各~駒が［
駒の元の行fの元の交叉sizeを保守するような支柱
］に置換した上で、~flex~layoutを再び走らす。
◎
and then re-run with each collapsed item replaced by a strut that maintains the original cross-size of the item’s original line.＼
</li>
</ol>

<p>
`visibility$p:collapse
が，~flex~layoutにどう作用するかについての規範的な定義は、`~flex~layout~algo$を見よ。
◎
See the Flex Layout Algorithm for the normative definition of how visibility:collapse interacts with flex layout.
</p>

<p class="note">注記：
~flex駒~上における
`visibility$p:collapse
の利用は、最も高価な手続きである
~flex~layout~algoを，~~部分的に繰返し走らすことになる。
作者には、`畳まれ$るかどうかが動的に~~変化しない駒を隠す際には、
`display$p:none
を利用し続けることが推奨される。
その方が~layout~engineにとってはより効率的になるので。
（しかしながら， `visibility$p の変化-時には，手続きの必要な部分のみ繰返されるので、動的な場合には，依然として
`visibility$p:collapse
が推奨される。）
◎
Note: Using visibility:collapse on any flex items will cause the flex layout algorithm to repeat partway through, re-running the most expensive steps. It’s recommended that authors continue to use display:none to hide items if the items will not be dynamically collapsed and uncollapsed, as that is more efficient for the layout engine. (Since only part of the steps need to be repeated when visibility is changed, however, 'visibility: collapse' is still recommended for dynamic cases.)
</p>

		</section>
		<section id="min-size-auto">
<h3 title="Automatic Minimum Size of Flex Items">4.5. ~flex駒の自動的な最小~size</h3>

<p class="note">注記：
`自動的な最小~size$を表現する `~autoS$v ~keywordは、［
`min-width$p ／ `min-height$p
］~propの新たな初期~値である。
この~keywordは、この仕様にて以前に定義されていたが，今や `CSS-SIZING-3$r ~moduleにて定義される。
◎
Note: The auto keyword, representing an automatic minimum size, is the new initial value of the min-width and min-height properties. The keyword was previously defined in this specification, but is now defined in the CSS Sizing module.
</p>

<p>
`~flex駒$ %駒 用に，より適度な既定の`最小~size$を供するため、`主-軸$における %駒 の`自動的な最小~size$の使用~値は，［
%駒 は`~scroll容器$でないならば `内容に基づく最小~size$ ／
~scroll容器であるならば 通例通り 0
］になるとする。
◎
To provide a more reasonable default minimum size for flex items, the used value of a main axis automatic minimum size on a flex item that is not a scroll container is a content-based minimum size; for scroll containers the automatic minimum size is zero, as usual.
</p>

<div class="p">

<p>
`内容に基づく最小~size@
は、次で与えられる：
</p>

<ol>
	<li>
［
%駒 は`指定d~size$を縦横とも有さない
］~AND［
%縦横比 ~NEQ ε
］ならば
⇒
`min^op( %駒 の`内容~size示唆$, %駒 の`転換~size示唆$ )
</li>
	<li>
他の場合
⇒
`min^op( %駒 の`内容~size示唆$, %駒 の`指定d~size示唆$ )
</li>
</ol>

<p>
ここで：
</p>

<ul>
	<li>
%縦横比 は、 %駒 が内在的~縦横比を有するならば［
`主-軸$~size ~DIV `交叉-軸$~size 
］を表すそれ ／
~ELSE_ ε とする。
</li>
	<li>
［
`min^op(…) ／ `max^op(…)
］は、各~引数の［
最小／最大
］値とる関数であり、引数のうち ε を値にとるものは，無視するものとする。
</li>
	<li>
記号 ε は、値が［
定義されない／不定である
］ことを表す，特別な値である（他のどの値とも異なる）。
</li>
</ul>

<p>
これらは、以下の計算にも利用される。
</p>

◎
In general, the content-based minimum size of a flex item is the smaller of its content size suggestion and its specified size suggestion. However, if the box has an aspect ratio and no specified size, its content-based minimum size is the smaller of its content size suggestion and its transferred size suggestion. If the box has neither a specified size suggestion nor an aspect ratio, its content-based minimum size is the content size suggestion.
</div>

<div class="p">

<p>
%駒 の［
`内容~size示唆$, `指定d~size示唆$, `転換~size示唆$
］は、以下に定義される
— これらには、`内容に基づく最小~size$が作者から供された拘束に干渉しないように，関連な［
最小-／最大-／選好d
］~size~propも織り込まれる：
</p>

<ul>
	<li>
［
%主size ／ %最大-主size ／ %最小-主size
］は、 %駒 の［
`主size~prop$ ／ `最大-主size~prop$ ／`最小-主size~prop$
］の算出d値を表すとする。
</li>
	<li>
［
%交叉size ／ %最大-交叉size ／ %最小-交叉size
］は、 %駒 の［
`交叉size~prop$ ／ `最大-交叉size~prop$ ／`最小-交叉size~prop$
］の算出d値を表すとする。
</li>
	<li>
これらはそれぞれ、算出d値が`確定的$でない場合は， ε を値にとるとする。
</li>
</ul>

◎
The content size suggestion, specified size suggestion, and transferred size suggestion used in this calculation account for the relevant min/max/preferred size properties so that the content-based minimum size does not interfere with any author-provided constraints, and are defined below:
</div>

<dl>
	<dt>`指定d~size示唆@</dt>
	<dd>
［
%主size ~NEQ ε
］ならば
⇒
`min^op( %主size, %最大-主size )
◎
If the item’s computed main size property is definite, then the specified size suggestion is that size (clamped by its max main size property if it’s definite).＼
</dd>
	<dd>
~ELSE_ ε
◎
It is otherwise undefined.
</dd>
	<dd>

	<dt>`転換~size示唆@</dt>
	<dd>
［
%縦横比 ~NEQ ε
］~AND［
%交叉size ~NEQ ε
］ならば
⇒
`max^op( `min^op( %交叉size, %最大-交叉size ), %最小-交叉size ) ~MUL %縦横比
◎
If the item has an intrinsic aspect ratio and its computed cross size property is definite, then the transferred size suggestion is that size (clamped by its min and max cross size properties if they are definite), converted through the aspect ratio.＼
</dd>
	<dd>
~ELSE_ ε
◎
It is otherwise undefined.
</dd>

	<dt>`内容~size示唆@</dt>
	<dd>
<p>
`主-軸$における %駒 の`最小-内容~size$を %s とするとき：
</p>
		<ol>
			<li>
%縦横比 ~NEQ ε ならば、
%s を，次で与える値に置換する
⇒
`max^op( `min^op( %s ~DIV %縦横比, %最大-交叉size ), %最小-交叉size ) ~MUL %縦横比
</li>
			<li>
結果の値は、
`min^op( %s, %最大-主size )
で与えられる。
</li>
		</ol>
◎
The content size suggestion is the min-content size in the main axis, clamped, if it has an aspect ratio, by any definite min and max cross size properties converted through the aspect ratio, and then further clamped by the max main size property if that is definite.
</dd>
</dl>

<p>
~boxの内在的~size（例： 要素の`最小-内容~size$）を計算する目的においては、`内容に基づく最小~size$は，当の軸における~boxの~sizeを不定にする（例えば~boxの `width$p ~propが`確定的$な~sizeを指定していても）。
このことは、この~sizeを基準に計算される百分率が`~autoとして挙動する$ことを意味することに注意。
◎
For the purpose of calculating an intrinsic size of the box (e.g. the box’s min-content size), a content-based minimum size causes the box’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size). Note this means that percentages calculated against this size will behave as auto.
</p>

<p>
いずれにせよ，これは、一部の事例において百分率を再度~解決するために，追加的な~layoutを要することもあるが、この値は，駒の中の百分率~sizeを解決できなくするものではない（ `CSS-SIZING-3$r に定義される値［
`min-content$v, `max-content$v, `fit-content^v
］と同様に）。
◎
Nonetheless, although this may require an additional layout pass to re-resolve percentages in some cases, this value (like the min-content, max-content, and fit-content values defined in [CSS-SIZING-3]) does not prevent the resolution of percentage sizes within the item.
</p>

<div class="note" id="min-size-opt">
<p>
大抵の場合、内容に基づく最小~sizeは適切であり，［
内容が重合する／容器の外側に溢れる
］ことはないようにするが、一部の事例ではそうならない：
◎
Note that while a content-based minimum size is often appropriate, and helps prevent content from overlapping or spilling outside its container, in some cases it is not:
</p>

<p>
特に，文書の~~主要な内容~区画に~flex~sizingを利用する場合、~font~sizeに相対的な，最小~横幅（ `min-width$p:12em など）を明示的に設定した方がよい。
最小~横幅が内容に基づく場合、巨大な［
~tableや画像
］があるときに，内容~区画~全体の~sizeを~overflowする地帯にまで伸張させ、~text行lを無用に~~長く, 読みづらくさせることになる。
◎
In particular, if flex sizing is being used for a major content area of a document, it is better to set an explicit font-relative minimum width such as min-width: 12em. A content-based minimum width could result in a large table or large image stretching the size of the entire content area into an overflow zone, and thereby making lines of text gratuitously long and hard to read.
</p>

<p>
多量の内容を伴う駒に内容に基づく~sizingを利用した場合、~layout~engineは，その最小~sizeを見出す前に その内容すべてを走査しなければならなくなる。
作者が明示的な最小~sizeを設定しておけば、これは不要になる。
（駒の内容が少量であれば、その走査は自明なので，処理能の懸念はない）
◎
Note also, when content-based sizing is used on an item with large amounts of content, the layout engine must traverse all of this content before finding its minimum size, whereas if the author sets an explicit minimum, this is not necessary. (For items with small amounts of content, however, this traversal is trivial and therefore not a performance concern.)
</p>

</div>

		</section>
	</section>
	<section id="flow-order">
<h2 title="Ordering and Orientation">5. 順序付けと方位</h2>

<p>
~flex容器の内容は、任意の方向, 任意の順序で~lay-outできる。
これにより、作者は，以前までは
`float$p, `clear$p
~propの併用による~hackなど，複階的, あるいは不安定な手法を要していた効果も、自明に得られるようになる。
この機能性は
`flex-direction$p,
`flex-wrap$p,
`order$p
~propを通して公開される。
◎
The contents of a flex container can be laid out in any direction and in any order. This allows an author to trivially achieve effects that would previously have required complex or fragile methods, such as hacks using the float and clear properties. This functionality is exposed through the flex-direction, flex-wrap, and order properties.
</p>

<p class="note">注記：
~flex~layoutによる並替ngの能力は，意図的に
`~~描画（視覚的な具現化）に限り^em
影響するようにされており、発話~順序や, ~source順序に基づく~naviは，そのままにされる。
これにより，作者は、［
非~CSS~UA, あるいは
発話や逐次的~naviなどの一次元な~model
］のための~source順序には触れずに，視覚的な呈示を操作できるようになる。
この，~accessibilityを改善する分岐の用例については、
<a href="#order-accessibility">並替ngと~accessibility</a>,
<a href="#overview">~flex~layoutの概観</a>
を見よ。
◎
Note: The reordering capabilities of flex layout intentionally affect only the visual rendering, leaving speech order and navigation based on the source order. This allows authors to manipulate the visual presentation while leaving the source order intact for non-CSS UAs and for linear models such as speech and sequential navigation. See Reordering and Accessibility and the Flex Layout Overview for examples that use this dichotomy to improve accessibility.
</p>

<p class="advisement"><strong>
作者は、
`flex-flow$p／`flex-direction$p
に対する `*-reverse^v 値を，~source順序付けを正すための代用として 利用しては`ナラナイ^em。
文書の~accessibilityを損ないかねないので。
</strong>
◎
Authors must not use order or the *-reverse values of flex-flow/flex-direction as a substitute for correct source ordering, as that can ruin the accessibility of the document.
</p>

		<section id="flex-direction-property">
<h3 title="Flex Flow Direction: the flex-direction property">5.1. ~flexの~flow方向： `flex-direction^p ~prop</h3>

◎名 `flex-direction@p
◎値
`row$v:fd |
`row-reverse$v:fd |
`column$v:fd |
`column-reverse$v:fd
◎初 `row$v:fd
◎適 `~flex容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`flex-direction$p ~propは、~flex容器の`主-軸$の方向を設定することにより，`~flex駒$が~flex容器の中で
どのように配置されるかを指定する。
これは、一連の~flex駒が~lay-outされていく方向を決定する：
◎
The flex-direction property specifies how flex items are placed in the flex container, by setting the direction of the flex container’s main axis. This determines the direction in which flex items are laid out.
</p>

<dl>
	<dt>`row@v:fd</dt>
	<dd>
~flex容器の`主-軸$は、現在の`書字mode$の`行内-軸$と同じ方位になるようにされる。
`主-始端$／`主-終端$
の方向は、現在の`書字mode$の［
`行内-始端$／`行内-終端$
］方向に等価になる。
◎
The flex container’s main axis has the same orientation as the inline axis of the current writing mode. The main-start and main-end directions are equivalent to the inline-start and inline-end directions, respectively, of the current writing mode.
</dd>

	<dt>`row-reverse@v:fd</dt>
	<dd>
`主-始端$と`主-終端$
の方向が入換わることを除き， `row$v:fd と同じ。
◎
Same as row, except the main-start and main-end directions are swapped.
</dd>

		<dt>`column@v:fd</dt>
		<dd>
~flex容器の`主-軸$は、現在の`書字mode$の`塊-軸$と同じ方位になるようにされる。
`主-始端$／`主-終端$
の方向は、現在の`書字mode$の
`塊-始端$／`塊-終端$
の方向に等価になる。
◎
The flex container’s main axis has the same orientation as the block axis of the current writing mode. The main-start and main-end directions are equivalent to the block-start and block-end directions, respectively, of the current writing mode.
</dd>

		<dt>`column-reverse@v:fd</dt>
		<dd>
`主-始端$と`主-終端$
の方向が入換わることを除き， `column$v:fd と同じ。
◎
Same as column, except the main-start and main-end directions are swapped.
</dd>
</dl>

<p class="note">注記：
`row-reverse^v ／ `column-reverse^v
値は、~boxの順序付けを “逆順” にするものではない
—
`writing-mode$p, `direction$p `CSS3-WRITING-MODES$r
と同様に，それらは~flowの方向のみを変化させる。
塗ng,
発話,
逐次的~navi
の順序は影響されない。
◎
Note: The reverse values do not reverse box ordering: like writing-mode and direction [CSS3-WRITING-MODES], they only change the direction of flow. Painting order, speech order, and sequential navigation orders are not affected.
</p>

		</section>
		<section id="flex-wrap-property">
<h3 title="Flex Line Wrapping: the flex-wrap property">5.2. ~flex行lの折返ng： `flex-wrap^p ~prop</h3>

◎名 `flex-wrap@p
◎値
`nowrap$v:fw |
`wrap$v:fw |
`wrap-reverse$v:fw
◎初 `nowrap$v:fw
◎適 `~flex容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<div class="p">
<p>
`flex-wrap$p ~propは、次の 2 つを制御する：
</p>

<ul>
	<li>
~flex容器は［
`単-行f$, `複-行f$
］どちらになるか。
</li>
	<li>
~flex容器の`交叉-軸$の向き
— これは、~flex容器~内で新たな行fが堆積されていく方向（順方向か逆方向か）を決定する。
</li>
</ul>
◎
The flex-wrap property controls whether the flex container is single-line or multi-line, and the direction of the cross-axis, which determines the direction new lines are stacked in.
</div>

<dl>
	<dt>`nowrap@v:fw</dt>
	<dd>
~flex容器は`単-行f$になる。
◎
The flex container is single-line.
</dd>
	<dd>
`交叉-軸$の向きは、 `wrap$v:fw のときと同じになる。
◎
↓↓</dd>

	<dt>`wrap@v:fw</dt>
	<dd>
~flex容器は`複-行f$になる。
◎
The flex container is multi-line.
</dd>
	<dd>
`交叉-軸$の向きは、順方向
— すなわち、`交叉-始端$は［
現在の`書字mode$の［
`行内-始端$, `塊-始端$
］のうち`交叉-軸$に属する方
］になり，`交叉-終端$はその反対側になる。
◎
↓↓</dd>

	<dt>`wrap-reverse@v:fw</dt>
	<dd>
~flex容器は`複-行f$になる。
◎
Same as wrap.
</dd>
	<dd>
`交叉-軸$の向きは、逆方向
— すなわち、［
`交叉-始端$, `交叉-終端$
］は `wrap$v:fw のときと入換わる。
◎
For the values that are not wrap-reverse, the cross-start direction is equivalent to either the inline-start or block-start direction of the current writing mode (whichever is in the cross axis) and the cross-end direction is the opposite direction of cross-start. When flex-wrap is wrap-reverse, the cross-start and cross-end directions are swapped.
</dd>
</dl>

		</section>
		<section id="flex-flow-property">
<h3 title="Flex Direction and Wrap: the flex-flow shorthand">5.3. ~flexの~flow方向と折返ng： `flex-flow^p 略式~prop</h3>

◎名 `flex-flow@p
◎値 `flex-direction$tp || `flex-wrap$tp
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 個々の~propを見よ
◎表終

<p>
`flex-flow$p ~propは，［
`flex-direction$p, `flex-wrap$p
］~propを設定するための略式~propであり，
~flex容器の［
主-軸, 交叉-軸
］を同時に定義する。
◎
The flex-flow property is a shorthand for setting the flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes.
</p>

<div class="example">
<p>
英語~文書（ `left-to-right^en【！＊】, 横書き書字mode）の下での妥当な~flowの例：
◎
Some examples of valid flows in an English (left-to-right, horizontal writing mode) document:
</p>

<dl>
	<dt>`flex-flow$p:row</dt>
	<dd>
<p>
初期~値。
主-軸は行内, 折返ngなし。
（駒たちは，容器に収まるように縮短されるか, または~overflowする。)
◎
Initial value. Main-axis is inline, no wrapping.
(Items will either shrink to fit or overflow.)
</p>

`flex-flow1^dgm

	<dd>
	<dt>`flex-flow$p:column_wrap</dt>
	<dd>
<p>
主-軸は塊~方向（上端から下端へ）になり,
一連の行fは行内~方向（右方）に折返される。
◎
Main-axis is block-direction (top to bottom)
and lines wrap in the inline direction (rightwards).
</p>

`flex-flow2^dgm

	<dd>
	<dt>`flex-flow$p:row-reverse_wrap-reverse</dt>
	<dd>
<p>
主-軸は行内~方向の反対（右端から左端へ）。
新たな行fは上方に折返される。
◎
Main-axis is the opposite of inline direction
(right to left). New lines wrap upwards.
</p>

`flex-flow3^dgm
	<dd>
</dl>

</div>

<div class="note">
<p>注記：
`flex-flow$p 方向は`書字mode$に感応する。
縦書き日本語の下では、 `row$v:fd ~flex容器は，例えば次の様に その内容を上端から下端へ~lay-outする。
◎
Note that the flex-flow directions are writing mode sensitive. In vertical Japanese, for example, a row flex container lays out its contents from top to bottom, as seen in this example:
</p>

<dl>
	<dt title="English">横書き（英語）</dt>
	<dd>
<pre class="lang-css">
`flex-flow$p:___row_wrap;
`writing-mode$p:horizontal-tb;
</pre>

`flex-flow-english^dgm
	</dd>

	<dt title="Japanese">縦書き（日本語）</dt>
	<dd>
<pre class="lang-css">
`flex-flow$p:___row_wrap;
`writing-mode$p:vertical-rl;
</pre>

`flex-flow-japanese^dgm
</dd>
</dl>

</div>

		</section>
		<section id="order-property">
<h3 title="Display Order: the order property">5.4. 陳列-順序： `order^p ~prop</h3>

<p>
`~flex駒$は，既定では、それらが~source文書に現れるのと同じ順序で，陳列され, ~lay-outされる。
この順序付けは、 `order$p ~propを利用して変更できる。
◎
Flex items are, by default, displayed and laid out in the same order as they appear in the source document. The order property can be used to change this ordering.
</p>

◎名 `order@p
◎値
`integer$t
◎初 `0^v
◎適 
`~flex駒$
◎
flex items
◎継 されない
◎百 受容しない
◎算 指定された整数
◎順 文法に従う
◎ア 算出d値の型による
◎表終

<p>
`order$p ~propは、一連の`~flex駒$を［
序数がアテガわれたいくつかの~groupに仕分ける
］ことを通して，［
~flex容器の中に~flex駒たちが現れる順序
］を制御する。
それは、［
`~flex駒$がどの~groupに属するかを表す序数
］を指定する， 1 個の
<dfn id="valdef-order-integer">`integer$t</dfn>
を値にとる。
◎
The order property controls the order in which flex items appear within the flex container, by assigning them to ordinal groups. It takes a single &lt;integer&gt; value, which specifies which ordinal group the flex item belongs to.
</p>

<p>
~flex容器は、その内容を，
`order$p ~propにより
`改変された文書~順序@
で
— すなわち，序数が最低の~groupから順に —
~lay-outする。
同じ序数の~groupに属する駒たちを~lay-outする順序は、~source文書に現れる順序に従う。
これらによる順序は、
<a href="~CSS22/zindex.html#elaborate-stacking-contexts">塗ng順序</a>
`CSS2$r
にも，~flex駒たちが~source文書~内で並替えられていたかのように影響する。
`~flex容器$の子のうち，絶対的に位置されたもの【したがって，~flex駒ではない】は、~flex駒との相対的な塗ng順序を決定する目的においては，序数 0 の~groupに属するものと扱われる。
◎
A flex container lays out its content in order-modified document order, starting from the lowest numbered ordinal group and going up. Items with the same ordinal group are laid out in the order they appear in the source document. This also affects the painting order [CSS2], exactly as if the flex items were reordered in the source document. Absolutely-positioned children of a flex container are treated as having order: 0 for the purpose of determining their painting order relative to flex items.
</p>

<div class="example">

<p>
次の図に，単純な~tab化された~UIを示す。
作動中の~pane用の~tabは，常に最初に来るようにされる：
◎
The following figure shows a simple tabbed interface, where the tab for the active pane is always first:
</p>

<figure>`flex-order-example^dgm</figure>

<p>
これは，次の~CSSで実装できる（関連な~codeのみを示す）：
◎
This could be implemented with the following CSS (showing only the relevant code):
</p>

<pre class="lang-css">
.tabs {
  `display$p:flex;
}
.tabs &gt; .current {
  `order$p:-1; /* <span class="comment">
既定の値 0 を下回る値
◎
Lower than the default of 0
</span> */
}
</pre>

</div>

<p>
将来~仕様により 特に指定されない限り、この~propの効果は，`~flex駒$でない~boxにはない。
◎
Unless otherwise specified by a future specification, this property has no effect on boxes that are not flex items.
</p>

			<section id="order-accessibility">
<h4 title="Reordering and Accessibility">5.4.1. 並替ngと~accessibility</h4>

<p>
`order$p ~propは、視覚的でない媒体（
<a href="~TR/css3-speech/">発話</a>
など）の順序付けには`影響しない^em。
同様に， `order$p は、逐次的~navi~modeの下での既定の走査~順序（一連の~linkに渡る巡回など — 例えば `tabindex$a `HTML$r など）にも，影響しない。
◎
The order property does not affect ordering in non-visual media (such as speech). Likewise, order does not affect the default traversal order of sequential navigation modes (such as cycling through links, see e.g. tabindex [HTML]). 
</p>

<p class="advisement"><strong>
作者は、もっぱら視覚的であって, 論理的でないような 内容の並替ngに限って， `order$p を利用し`なければナラナイ^em。
論理的に並替えるために `order$p を利用するような~stylesheetは、適合していない。
◎
Authors must use order only for visual, not logical, reordering of content. Style sheets that use order to perform logical reordering are non-conforming.
</strong></p>

<p class="note">注記：
これは、視覚的な順序を誂えるために `order$p を利用しつつ（視覚的な~~認識は二次元であり, 一次元ではないので、欲される視覚的な順序が常に論理-順序に一致するとは限らない）、概して内容を一次元に呈示する 視覚的でない媒体や非~CSS~UAが，~sourceの論理-順序に依拠できるようにするためである。
◎
Note: This is so that non-visual media and non-CSS UAs, which typically present content linearly, can rely on a logical source order, while order is used to tailor the visual order. (Since visual perception is two-dimensional and non-linear, the desired visual order is not always logical.)
</p>

<div class="example">
<p>
多くの~web~pageは、類似な~~形に~markupされている
—
上端に~header, 下端に~footerがあって，中段に内容~区画と 1 本か 2 本の追加的な~colがある様なものなど。
一般に、~~主~内容は，追加的な~colより前の, ~pageの~source~codeの最初に来ることが望ましい。
しかしながら，これを得ることは、［
追加的な~colが左に, 内容~区画が右に~~位置するような単純なものも含め，共通的な多くの設計
］においては，困難である。
これは，年月に渡り 様々な仕方で取組まれており、追加的な~colが 2 本~在るものは，しばしば “Holy Grail Layout” （ “聖なる~layout” ）と称されている。
`order$p は これを自明にする。
例えば次の様な，~pageの~code, および欲される~layoutがあるとする：
◎
Many web pages have a similar shape in the markup, with a header on top, a footer on bottom, and then a content area and one or two additional columns in the middle. Generally, it’s desirable that the content come first in the page’s source code, before the additional columns. However, this makes many common designs, such as simply having the additional columns on the left and the content area on the right, difficult to achieve. This has been addressed in many ways over the years, often going by the name "Holy Grail Layout" when there are two additional columns. order makes this trivial. For example, take the following sketch of a page’s code and desired layout:
</p>

<div class="code-and-figure">
<div><pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;header&gt;...&lt;/header&gt;
&lt;main&gt;
   &lt;article&gt;...&lt;/article&gt;
   &lt;nav&gt;...&lt;/nav&gt;
   &lt;aside&gt;...&lt;/aside&gt;
&lt;/main&gt;
&lt;footer&gt;...&lt;/footer&gt;
</pre></div>

<div>`flex-order-page^dgm</div>
</div>

<p>
この~layoutは，~flex~layoutにより容易に得られる：
◎
This layout can be easily achieved with flex layout:
</p>

<pre class="lang-css">
main { `display$p:flex; }
main &gt; article { `order$p:2; `min-width$p:12em; `flex$p:1; }
main &gt; nav     { `order$p:1; `width$p:200px; }
main &gt; aside   { `order$p:3; `width$p:200px; }
</pre>

<p>
~~追加の特典として、一連の~colは，既定で
<a href="#valdef-align-items-stretch">縦幅が等しく揃えられる</a>ようになり、主-内容は，~screenを埋める必要に応じた幅にされる。
加えて，媒体~queryと組合せることにより、狭い~screen幅の下では，すべてを縦方向に~layoutするように切替えることも可能になる：
◎
As an added bonus, the columns will all be equal-height by default, and the main content will be as wide as necessary to fill the screen. Additionally, this can then be combined with media queries to switch to an all-vertical layout on narrow screens:
</p>

<pre class="lang-css">
@media all and (`max-width$p:600px) {
  /* <span class="comment">
3 本の~colには狭過ぎるときの~support
◎
Too narrow to support three columns
</span> */
  main { `flex-flow$p:column; }
  main &gt; article, main &gt; nav, main &gt; aside {
  /* <span class="comment">
文書~順序に戻す
◎
   Return them to document order
</span> */
    `order$p:0; `width$p:auto;
  }
}
</pre>

<p><small>（
より気の利いた折返ngを得るための，複-行f ~flex容器の更なる利用は、読者への演習として残しておく。
）</small>
◎
(Further use of multi-line flex containers to achieve even more intelligent wrapping left as an exercise for the reader.)
</p>

</div>

<p>
作者が意図する順序付けを，すべての呈示~modeにわたって保全するため、著作~toolは（ WYSIWYG ~editorや~webに基づく著作~援助その他も含め），
`order$p を利用して並替えることなく，下層の文書~sourceを並替えることが要求される
— 作者から，（発話や~navi順序を決定する）下層の文書~順序と視覚的な順序は`違えるべき^em と明示的に指示された場合は別として。
◎
In order to preserve the author’s intended ordering in all presentation modes, authoring tools—including WYSIWYG editors as well as Web-based authoring aids—must reorder the underlying document source and not use order to perform reordering unless the author has explicitly indicated that the underlying document order (which determines speech and navigation order) should be out-of-sync with the visual order.
</p>

<div class="example">
<p>
例えば、［
~drag-and-dropによる~flex駒の並替ng
］と［
~screen~sizeのある範囲ごとに~layoutを別々に~~用意するような媒体~queryの取扱い
］の両者を提供する~toolもある。
◎
For example, a tool might offer both drag-and-drop reordering of flex items as well as handling of media queries for alternate layouts per screen size range.
</p>

<p>
ほとんどの場合、どの~screen~sizeに対しても，並替ngは~navi／発話 の順序にも同じように影響するべきであり、~toolは，~drag-and-dropによる視覚的な並替ngに合わせて DOM 層における並替ngを遂行する。
しかしながら、作者が~screen~sizeごとに異なる視覚的な順序付けを求める事例もある。
~toolは、媒体~queryと `order$p を併用して，この機能性を提供することもできる
— 最~小な~screen~sizeに対する順序付けは，（論理的な呈示~順序にほぼ近い）下層の DOM 順序に基づかせつつ、他の~size範囲に対しては， `order$p を利用して視覚的な呈示~順序を決定するなど。
◎
Since most of the time, reordering should affect all screen ranges as well as navigation and speech order, the tool would perform drag-and-drop reordering at the DOM layer. In some cases, however, the author may want different visual orderings per screen size. The tool could offer this functionality by using order together with media queries, but also tie the smallest screen size’s ordering to the underlying DOM order (since this is most likely to be a logical linear presentation order) while using order to determine the visual presentation order in other size ranges.
</p>

<p>
上述のようにする~toolであれば，適合tであろうが、~drag-and-dropによる並替ngを取扱うときに `order$p のみを利用する~toolは，（その方が実装は簡便かもしれないが）適合tでないことになる。
◎
This tool would be conformant, whereas a tool that only ever used order to handle drag-and-drop reordering (however convenient it might be to implement it that way) would be non-conformant.
</p>

</div>

<p class="note">注記：
［
~browser,  ~access可能にする技術, 拡張
］も含め，~UAは、空間的~navi特能を提供してヨイ。
この節は、そのような空間的~navi~modeにおける要素の順序付けを `order$p ~propも加味して決定することを制止するものではない
— ~~実際、そのような特能が働くためには必要と見なされている。
が、考慮する必要がある~CSS~propは， `order$p のみに限られない（それは、首な~propですらない）。
きちんと実装された空間的~navi特能は、~CSSの~layout特能のうち，空間的な関係性を改変するものすべてを考慮する必要がある。
◎
Note: User agents, including browsers, accessible technology, and extensions, may offer spatial navigation features. This section does not preclude respecting the order property when determining element ordering in such spatial navigation modes; indeed it would need to be considered for such a feature to work. But order is not the only (or even the primary) CSS property that would need to be considered for such a spatial navigation feature. A well-implemented spatial navigation feature would need to consider all the layout features of CSS that modify spatial relationships.
</p>

			</section>
		</section>
	</section>
	<section id="flex-lines">
<h2 title="Flex Lines">6. ~flex行l</h2>

<p>
`~flex容器$内の一連の`~flex駒$は、一連の
`~flex行l@
（ `flex line^en）
— 略して，行f† —
の中へ，~lay-outされ, 整列される
— 各~行fは、~layout~algoにおいて，~group分けと整列に利用される仮の容器を成す。
【†~textの “行l” （`~flow~layout$の行l~box）と混同されないよう，この訳では "°" を付与して記す。】
◎
Flex items in a flex container are laid out and aligned within flex lines, hypothetical containers used for grouping and alignment by the layout algorithm.＼
</p>

<p>
`~flex容器$は、 `flex-wrap$p ~propに依存して，`単-行f$にも`複-行f$にもなり得る：
◎
A flex container can be either single-line or multi-line, depending on the flex-wrap property:
</p>

<ul>
	<li>
`単-行f@
な`~flex容器$（すなわち， `flex-wrap$p:nowrap ）は、そのすべての子を，それらの内容が~overflowするかどうかに関わらず, 単独の行f内に~lay-outする。
◎
A single-line flex container (i.e. one with flex-wrap: nowrap) lays out all of its children in a single line, even if that would cause its contents to overflow.
</li>
	<li>
`複-行f@
な`~flex容器$（すなわち，
`flex-wrap$p:wrap ／
`flex-wrap$p:wrap-reverse
）は、その一連の`~flex駒$を，既存の行fに収めるには幅が広過ぎるときには，~textが改行で折返されるのと類似に, 複数の行fに分断する。
【 1 本の行fに収まるときでも、その挙動は単-行fと異なる。】
そのように作成された追加的な行fたちは、
`flex-wrap$p ~propに則って，~flex容器の中で`交叉-軸$沿いに堆積されていく。
~flex容器~自身が完全に空でない限り、どの行fも 1 個以上の`~flex駒$を包含する。
【完全に空ならば、行fは まったく作成されない…と見なしてよさそうだが、はっきりしない。】
◎
A multi-line flex container (i.e. one with flex-wrap: wrap or flex-wrap: wrap-reverse) breaks its flex items across multiple lines, similar to how text is broken onto a new line when it gets too wide to fit on the existing line. When additional lines are created, they are stacked in the flex container along the cross axis according to the flex-wrap property. Every line contains at least one flex item, unless the flex container itself is completely empty.
</li>
</ul>

<div class="example">
<p>
次の例に，横方向に収まり切らず 複数~行fに折返される，
4 個のボタンを示す：
◎
This example shows four buttons that do not fit side-by-side horizontally, and therefore will wrap into multiple lines.
</p>

<pre class="lang-css">
#flex {
  `display$p:flex;
  `flex-flow$p:row_wrap;
  `width$p:300px;
}
.item {
  `width$p:80px;
}
</pre>

<pre class="lang-html">
&lt;div id="flex"&gt;
  &lt;div class="item"&gt;1&lt;/div&gt;
  &lt;div class="item"&gt;2&lt;/div&gt;
  &lt;div class="item"&gt;3&lt;/div&gt;
  &lt;div class="item"&gt;4&lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
容器は 300px 幅なので、単独の行fには 3 個までの駒しか収まらない。
それらは 240px を占め，残りの空間に 60px が残される。
 `flex-flow$p ~propの値には，`複-行f$な~flex容器を指定する， `wrap$v:fw ~keywordが現れているので、~flex容器は，最後の駒を包含するための追加的な行fを作成することになる。
◎
Since the container is 300px wide, only three of the items fit onto a single line. They take up 240px, with 60px left over of remaining space. Because the flex-flow property specifies a multi-line flex container (due to the wrap keyword appearing in its value), the flex container will create an additional line to contain the last item.
</p>

<figure>`multiline-no-flex^dgm
<figcaption>
複-行f ~flex容器の描画~例
◎
An example rendering of the multi-line flex container.
</figcaption></figure>

	</div>

<p>
内容が一連の行fに分断されたなら，各~行fは独立に~lay-outされる。
~flex可能な長さ, および
`justify-content$p, `align-self$p
~propは、個別の行fごとにその一連の駒に対し~~適用される。
◎
Once content is broken into lines, each line is laid out independently; flexible lengths and the justify-content and align-self properties only consider the items on a single line at a time.
</p>

<p>
`複-行f$な~flex容器においては（行fが 1 本だけであっても）、各~行fの`交叉size$は，その行f上の一連の`~flex駒$を（ `align-self$p による整列の後で）包含するために必要な最小な~sizeになり、一連の行fは， `align-content$p ~propにより ~flex容器~内で整列される。
`単-行f$な~flex容器においては、その行fの`交叉size$は ~flex容器の`交叉size$になり， `align-content$p の効果はない。
行fの`主size$は，~flex容器の内容~boxの`主size$と常に同じになる。
◎
In a multi-line flex container (even one with only a single line), the cross size of each line is the minimum size necessary to contain the flex items on the line (after alignment due to align-self), and the lines are aligned within the flex container with the align-content property. In a single-line flex container, the cross size of the line is the cross size of the flex container, and align-content has no effect. The main size of a line is always the same as the main size of the flex container’s content box.
</p>

<div class="example">
<p>
すべての~flex駒に `flex$p:auto が与えられていることを除いて，前と同じにされている例を、次に示す。
最初の行fには残りの空間が 60px あり,
そのすべての駒に同じ~flex能が備わるので、行f上の 3 個の駒それぞれは，余った横幅から 20px ずつ受取る結果, 100px 幅になる。
残る 1 個の駒はそれのみで行fを占め，その行fの横幅~全体, すなわち 300px まで伸張されることになる。
◎
Here’s the same example as the previous, except that the flex items have all been given flex: auto. The first line has 60px of remaining space, and all of the items have the same flexibility, so each of the three items on that line will receive 20px of extra width, each ending up 100px wide. The remaining item is on a line of its own and will stretch to the entire width of the line, i.e. 300px.
</p>

<figure>`multiline-flex^dgm
<figcaption>
すべての駒に `flex$p:auto が与えられていることを除いて，上と同じときの描画
◎
A rendering of the same as above, but with the items all given flex: auto.
</figcaption></figure>
	</div>

	</section>
	<section id="flexibility">
<h2 title="Flexibility">7. ~flex能</h2>

<p>
~flex~layoutには、一連の`~flex駒$を “~flex” にして、`主-次元$において`可用な空間$を埋めるために，それらの横幅／縦幅を改めることを可能にする能を定義する側面がある。
これは， `flex$p ~propを通して行われる。
~flex容器は、自身を埋めるように，その駒たちに自由空間を（`~flex伸長-係数$に比例する分だけ）配分するか、または，自身を~overflowしないように駒たちを（各~駒の`~flex縮短-係数$に比例する分だけ）縮短する。
◎
The defining aspect of flex layout is the ability to make the flex items “flex”, altering their width/height to fill the available space in the main dimension. This is done with the flex property. A flex container distributes free space to its items (proportional to their flex grow factor) to fill the container, or shrinks them (proportional to their flex shrink factor) to prevent overflow.
</p>

<p>
`~flex駒$は、［
`flex-grow$p, `flex-shrink$p
］いずれの値も 0 ならば
`全部的に~flex不能@
とされ，そうでないならば
`~flex可能@
とされる。
◎
A flex item is fully inflexible if both its flex-grow and flex-shrink values are zero, and flexible otherwise.
</p>

		<section id="flex-property">
<h3 title="The flex Shorthand">7.1. `flex^p 略式~prop</h3>

◎名 `flex@p
◎値 
`none$v:f | [
`flex-grow$tp
`flex-shrink$tp? ||
`flex-basis$tp
]
◎初 `0 1 auto^v
◎適 `~flex駒$
◎継 されない
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 算出d値の型による
◎表終

<div class="p">
<p>
`flex$p ~propは、次の成分からなる，~flex可能な~size【！~flex可能な長さ】を指定する：
</p>
<ul>
	<li>
`~flex伸長-係数$,
`~flex縮短-係数$
— これらは、
`~flex係数@
と総称される。
</li>
	<li>
`~flex基底s$
</li>
</ul>

<p>
~boxが`~flex駒$である場合、その`主size$の決定には，`主size~prop$の`代わりに^em `flex$p にあたる。
~boxが`~flex駒$でない場合、 `flex$p の効果はない。
</p>

◎
The flex property specifies the components of a flexible size: the flex factors (grow and shrink) and the flex basis. When a box is a flex item, flex is consulted instead of the main size property to determine the main size of the box. If a box is not a flex item, flex has no effect.
</div>

<dl>
	<dt class="value production" id="valdef-flex-grow">`flex-grow$tp</dt>
	<dd>
この `number [0,∞]$t 成分は、
`flex-grow$p <a href="#flex-components">下位prop</a>を設定して，
`~flex伸長-係数@
を指定する。
それは、~flex容器の中で正な自由空間が配分される際に，
`~flex駒$が他の一連の`~flex駒$に比して どれだけ伸長することになるのかを決定する。
省略されたときは、 `1^v に設定される。
◎
This &lt;number [0,∞]&gt; component sets flex-grow longhand and specifies the flex grow factor, which determines how much the flex item will grow relative to the rest of the flex items in the flex container when positive free space is distributed. When omitted, it is set to 1.
</dd>
	<dd>
<details class="note">
<summary>
0 〜 1 の合間の~flex値には、ある特別な挙動がある：
同じ行f上にある駒たちの~flex値の総和が 1 に満たない場合、それらが占める自由空間は 100% に満たなくなる。
◎
Flex values between 0 and 1 have a somewhat special behavior: when the sum of the flex values on the line is less than 1, they will take up less than 100% of the free space.
</summary>

<p>
駒の `flex-grow$p 値は、実質的に自由空間の比例分を要請する
— 値 `1^v は “自由空間 の 100%” を意味する。
ある行f上の駒たちが要請している自由空間が，合計で 100% を超える場合、互いの比を保ちながら正確に 100% を利用し尽くすように，振り分け直される
— 一方で 100% を下回る場合（それぞれが `flex-grow$p:.25 にされた 3 個の駒がある場合など）、各~駒は正確に要請した分だけ取得する（各~駒は自由空間の 25% を取得し，残る 25% は埋められない）。
自由空間がどう配分されるかの正確な詳細は、
<a href="#resolve-flexible-lengths">~flex可能な長さの解決-法</a>
を見よ。
◎
An item’s flex-grow value is effectively a request for some proportion of the free space, with 1 meaning “100% of the free space”; then if the items on the line are requesting more than 100% in total, the requests are rebalanced to keep the same ratio but use up exactly 100% of it. However, if the items request less than the full amount (such as three items that are each flex-grow: .25) then they’ll each get exactly what they request (25% of the free space to each, with the final 25% left unfilled). See § 9.7 Resolving Flexible Lengths for the exact details of how free space is distributed.
</p>

<p>
この~patternは、 `flex-grow$p が 0 に近づくときの挙動を連続的にするために要求される（すなわち、駒は自由空間をまったく占めないことが求まれる）。
さもなければ、駒は `flex-grow$p が `0^v にどこまで近づこうが
— `1^v のときと同じく —
自由空間すべてを占め， 0 に十分~近くなった所で，いきなり，まったく占めなくなる。
この挙動があれば、 `flex-grow$p が `1^v から下へ縮短するに伴い［
駒が占める自由空間は、次第に減り， 0 の所で無くなる
］ように滑らかに遷移することになる。
◎
This pattern is required for continuous behavior as flex-grow approaches zero (which means the item wants none of the free space). Without this, a flex-grow: 1 item would take all of the free space; but so would a flex-grow: 0.1 item, and a flex-grow: 0.01 item, etc., until finally the value is small enough to underflow to zero and the item suddenly takes up none of the free space. With this behavior, the item instead gradually takes less of the free space as flex-grow shrinks below 1, smoothly transitioning to taking none of the free space at zero.
</p>

<p>
作者は、この “部分的に埋める” 挙動が`特定的に^em欲されない限り，
1 以上の値を貫き続けるべきである。
例えば `1^v, `2^v を利用する方が `.33^v, `.67^v を利用するより，通例的に良い
— その方が、駒が追加-／除去されたり, 行fが折返されたときにも，意図される挙動が保たれると見込まれるので。
◎
Unless this “partial fill” behavior is specifically what’s desired, authors should stick to values ≥ 1; for example, using 1 and 2 is usually better than using .33 and .67, as they’re more likely to behave as intended if items are added, removed, or line-wrapped.
</p>
</details>
	</dd>

	<dt class="value production" id="valdef-flex-shrink">`flex-shrink$tp</dt>
	<dd>
この `number [0,∞]$t 成分は、
`flex-shrink$p <a href="#flex-components">下位prop</a>を設定して，
`~flex縮短-係数@
を指定する。
それは、~flex容器の中で負な自由空間が配分される際に，
`~flex駒$が他の一連の`~flex駒$に比して どれだけ縮短することになるのかを決定する。
省略されたときは、 `1^v に設定される。
負な自由空間を配分する際には、`~flex縮短-係数$は，`~flex基底s$で乗算される。
◎
This &lt;number [0,∞]&gt; component sets flex-shrink longhand and specifies the flex shrink factor, which determines how much the flex item will shrink relative to the rest of the flex items in the flex container when negative free space is distributed. When omitted, it is set to 1.
</dd>
	<dd class="note">注記：
負な空間を配分する際には、`~flex縮短-係数$は，`~flex基底~size$で乗算されることに注意。
これにより、負な空間は，駒が縮短できる量に比例するように配分され、例えば，大きい駒が~~相当に縮短されない限り，小さい駒が 0 まで縮短されないようにする。
◎
Note: The flex shrink factor is multiplied by the flex base size when distributing negative space. This distributes negative space in proportion to how much the item is able to shrink, so that e.g. a small item won’t shrink to zero before a larger item has been noticeably reduced.
</dd>

	<dt class="value production" id="valdef-flex-basis">`flex-basis$tp</dt>
	<dd>
この成分は、
`flex-basis$p <a href="#flex-components">下位prop</a>を設定して，
`~flex基底s@
を指定する。
それは、一連の~flex係数に則って自由空間が配分される前の，`~flex駒$の初期`主size$を与える。
◎
This component sets the flex-basis longhand, which specifies the flex basis: the initial main size of the flex item, before free space is distributed according to the flex factors.
</dd>
	<dd>
<p>
この成分は、 `width$p, `height$p ~propと同じ値を受容する（ただし， `auto$v:fb の扱いは異なる）ことに加えて，~keyword `content$v:fb も受容する：
◎
&lt;‘flex-basis’&gt; accepts the same values as the width and height properties (except that auto is treated differently) plus the content keyword:
</p>

		<dl>
			<dt>`auto@v:fb</dt>
			<dd>
~flex駒にこの~keywordが指定された場合、
`flex-basis$p の使用~値は，`主size~prop$の値から~~取得される。
その値も `~autoS$v である場合の使用~値は， `content$v:fb になる。
◎
When specified on a flex item, the auto keyword retrieves the value of the main size property as the used flex-basis. If that value is itself auto, then the used value is content.
</dd>

			<dt>`content@v:fb</dt>
			<dd>
`~flex駒$の内容に基づく自動的~size（
<a href="#algo-main-item">詳細</a>は`~flex~layout~algo$を見よ
）を指示する（概して，`最大-内容~size$に等価になるが、［
縦横比, 内在的~sizing拘束, 直交~flow
］を取扱うための調整も伴う）。
◎
Indicates an automatic size based on the flex item’s content. (It is typically equivalent to the max-content size, but with adjustments to handle aspect ratios, intrinsic sizing constraints, and orthogonal flows; see details in § 9 Flex Layout Algorithm.)
</dd>
			<dd class="note">注記：
この値は、この仕様の初期~releaseには無かったものであり，一部の古い実装では~supportされない。
等価な効果は、`主size~prop$ に `~autoS$v をあてがった上で， `auto^v を利用して得られる。
◎
Note: This value was not present in the initial release of Flexible Box Layout, and thus some older implementations will not support it. The equivalent effect can be achieved by using auto together with a main size (width or height) of auto.
</dd>

			<dt>`width$tp</dt>
			<dd>
他のすべての値に対しては、 `width$p, `height$p に対するときと同じ仕方で解決される。
◎
For all other values, flex-basis is resolved the same way as for width and height.
</dd>
		</dl>
	</dd>
	<dd>
`flex$p 略式~propから省略された場合の指定d値は、 `0^v になる。
◎
When omitted from the flex shorthand, its specified value is 0.
</dd>

	<dt>`none@v:f</dt>
	<dd>
~keyword `none$v:f は，`0 0 auto^v に展開される。
◎
The keyword none expands to 0 0 auto.
</dd>
</dl>

<hr />

<figure>

	<figure><figcaption>
すべての空間が配分される（ `flex-basis$p:0 ）：
◎
All Space Distributed (flex-basis:0)
</figcaption>
`rel-vs-abs-flex-a^dgm
</figure>

	<figure><figcaption>
余った空間が配分される（ `flex-basis$p:auto ）：
◎
Extra Space Distributed (flex-basis:auto)
</figcaption>
`rel-vs-abs-flex-b^dgm
</figure>

<figcaption>
（基底s 0 による） “絶対的” ~flexと,
（ 駒の内容~sizeから得られる基底sによる） “相対的” ~flex
との間の相違を示す図式。
3 個の駒の~flex係数は、順に `1^v, `1^v, `2^v にされているとする。
~flex係数 `2^v を伴う駒が他の二倍 伸長することに注目。
【前者の“絶対的” ~flexでは、各~駒が，いったん幅 0 の~~状態にされるので，可用な幅~全部が自由空間にあてがわれた上で、それが~flex係数に応じた比率で各~駒に配分される。】
【！（内容~sizeが配分された幅を超える駒については、内容がはみ出すことになる）】
◎
A diagram showing the difference between "absolute" flex (starting from a basis of zero) and "relative" flex (starting from a basis of the item’s content size). The three items have flex factors of 1, 1, and 2, respectively: notice that the item with a flex factor of 2 grows twice as fast as the others.
</figcaption></figure>

<p>
`flex$p の個々の成分の初期~値による値は、
<a href="#flex-initial">`flex$p:0_1_auto</a>
に等価になる。
◎
The initial values of the flex components are equivalent to flex: 0 1 auto.
</p>

<p class="note">注記：
`flex$p 略式~propから省略されたときの，
`flex-grow$p, `flex-basis$p
の初期~値は、いずれも，それらの個別の下位propの既定~値とは異なる。
これは、<a href="#flex-common">最も共通的な事例</a>に，`flex$p 略式~propがより良く適応できるようにするために、そのようにされている。
◎
Note: The initial values of flex-grow and flex-basis are different from their defaults when omitted in the flex shorthand. This is so that the flex shorthand can better accommodate the most common cases.
</p>

<p>
［
2 個の~flex係数
］が前置されていない，単位なしの 0 は、~flex係数として解釈されるモノトスル。
誤解釈や無効な宣言を避けるため、作者は，単位を伴う 0 `flex-basis$tp 成分を指定するか, あるいは
その前に 2 個の~flex係数を置かなければナラナイ。
◎
A unitless zero that is not already preceded by two flex factors must be interpreted as a flex factor. To avoid misinterpretation or invalid declarations, authors must specify a zero &lt;‘flex-basis’&gt; component with a unit or precede it by two flex factors.
</p>

			<section id="flex-common">
<h3 title="Basic Values of flex">7.1.1. 基本的な `flex^p 値</h3>

~INFORMATIVE

<p>
以下に、最も共通的に欲される効果を表現する，
4 種の `flex$p 値による効果を要約する：
◎
The list below summarizes the effects of the four flex values that represent most commonly-desired effects:
</p>

<dl>
	<dt id="flex-initial">`flex$p:initial</dt>
	<dd>
`flex$p:0_1_auto に等価（これが初期~値）。
駒を，その
`width$p ／ `height$p
~propに基づいて~sizeする。
（駒の`主size~prop$が `~autoS$v に算出される場合、これは，その駒をその内容に基づいて~sizeすることになる。）
正な自由空間があるときは，~flex駒を~flex不能にする一方で、空間が足りないときは，その最小~sizeへの縮短-を許容する。
<a href="#alignment">整列~能</a>や `~auto_v~margin$を利用すれば、一連の~flex駒を`主-軸$沿いに整列させられる。
◎
Equivalent to flex: 0 1 auto. (This is the initial value.) Sizes the item based on the width/height properties. (If the item’s main size property computes to auto, this will size the flex item based on its contents.) Makes the flex item inflexible when there is positive free space, but allows it to shrink to its minimum size when there is insufficient space. The alignment abilities or auto margins can be used to align flex items along the main axis.
</dd>

	<dt>`flex$p:auto</dt>
	<dd>
`flex$p:1_1_auto に等価。
駒を，その
`width$p ／ `height$p
~propに基づいて駒を~sizeしつつ、`主-軸$沿いの自由空間を吸収させるために，それらを全部的に~flex可能にする。
どの駒も， `flex$p が［
`auto^v, `initial^v, `none^v
］のいずれかである場合、それらの駒が~sizeされた後の正な自由空間は，
`flex$p:auto
を伴う駒に均等に配分されることになる。
◎
Equivalent to flex: 1 1 auto. Sizes the item based on the width/height properties, but makes them fully flexible, so that they absorb any free space along the main axis. If all items are either flex: auto, flex: initial, or flex: none, any positive free space after the items have been sized will be distributed evenly to the items with flex: auto.
</dd>

	<dt>`flex$p:none</dt>
	<dd>
`flex$p:0_0_auto に等価。
この値は、
`width$p ／ `height$p
~propに則って駒を~sizeしつつ，~flex駒を`全部的に~flex不能$にする。
これは、~overflowが生じる状況~下でも 一連の~flex駒に対する縮短-が許容されないことを除いて，
`initial$v と類似する。
◎
Equivalent to flex: 0 0 auto. This value sizes the item according to the width/height properties, but makes the flex item fully inflexible. This is similar to initial, except that flex items are not allowed to shrink, even in overflow situations.
</dd>

	<dt><code class="css">`flex$p: `number [1,∞]$t</code></dt>
	<dd>
<code class="css">flex: `number [1,∞]$t `1 0^v</code>
に等価。
~flex駒を~flex可能にして，`~flex基底s$を 0 に設定する。
その結果、駒は，指定された比例分による［
~flex容器の中の自由空間
］を受取る。
~flex容器の中のすべての駒が この~patternを利用している下での，それらの~sizeは、~flex係数に指定された値に比例するようになる。
◎
Equivalent to ''flex: &lt;number [1,∞]&gt; 1 0''. Makes the flex item flexible and sets the flex basis to zero, resulting in an item that receives the specified proportion of the free space in the flex container. If all items in the flex container use this pattern, their sizes will be proportional to the specified flex factor.
</dd>
</dl>

<p>
既定では、~flex駒がその内容の最小~size（単語や固定d~sizeの要素の最~大な長さ）を下回るまで縮短することはない。
このふるまいを変えるには、［
`min-width$p ／ `min-height$p
］~propを設定する（
<a href="#min-size-auto">~flex駒の自動的な最小~size</a>
節を見よ）。
◎
By default, flex items won’t shrink below their minimum content size (the length of the longest word or fixed-size element). To change this, set the min-width or min-height property. (See § 4.5 Automatic Minimum Size of Flex Items.)
</p>

			</section>
		</section>
		<section id="flex-components">
<h3 title="Components of Flexibility">7.2. ~flex能の各~成分</h3>

<p>
~flex能の個々の成分は，下位propにより独立に制御できる。
◎
Individual components of flexibility can be controlled by independent longhand properties.
</p>

<p class="advisement"><strong>
作者には、 `flex$p 略式~propを利用して ~flex能を制御することが奨励される
— その各種~下位propを直に利用するのでなく。
この略式~propは、`共通的な用途$に適応するように，未指定の成分を正しく再設定するので。
</strong>
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with its longhand properties directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

			<section id="flex-grow-property">
<h4 title="The flex-grow property">7.2.1 `flex-grow^p ~prop</h4>

◎名 `flex-grow@p
◎値 `number [0,∞]$t
◎初 `0^v
◎適 `~flex駒$
◎継 されない
◎百 受容しない
◎算 指定された実数
◎順 文法に従う
◎ア 算出d値の型による
◎表終

<p class="advisement"><strong>
作者には、
`flex-grow$p を直に利用せずに，
`flex$p 略式~propを利用して ~flex能を制御することが奨励される。
この略式~propは、`共通的な用途$に適応するように，未指定の成分を正しく再設定するので。
</strong>
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-grow directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

<dl>
	<dt id="valdef-flex-grow-number">`number$t</dt>
	<dd>
`flex-grow$p ~propは、`~flex伸長-係数$を供された `number^t に設定する。
負な数は許容されない。
◎
The flex-grow property sets the flex grow factor to the provided &lt;number&gt;. Negative values are not allowed.
</dd>
</dl>

			</section>
			<section id="flex-shrink-property">
<h4 title="The flex-shrink property">7.2.2 `flex-shrink^p ~prop</h4>

◎名 `flex-shrink@p
◎値 `number [0,∞]$t
◎初 `1^v
◎適 `~flex駒$
◎継 されない
◎百 受容しない
◎算 指定された実数
◎順 文法に従う
◎ア 算出d値の型による
◎表終

<p class="advisement"><strong>
作者には、
`flex-shrink$p を直に利用せずに，
`flex$p 略式~propを利用して ~flex能を制御することが奨励される。
この略式~propは、`共通的な用途$に適応するように，未指定の成分を正しく再設定するので。
</strong>
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-shrink directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

<dl>
	<dt id="valdef-flex-shrink-number">`number$t</dt>
	<dd>
`flex-shrink$p ~propは、`~flex縮短-係数$を 供された `number^t に設定する。
負な数は許容されない。
◎
The flex-shrink property sets the flex shrink factor to the provided &lt;number&gt;. Negative values are not allowed.
</dd>
</dl>

			</section>
			<section id="flex-basis-property">
<h4 title="The flex-basis property">7.2.3 `flex-basis^p ~prop</h4>

◎名 `flex-basis@p
◎値 `content$v:fb | `width$tp
◎初 `auto$v:fb
◎適 `~flex駒$
◎継 されない
◎百
`~flex容器$の<a href="#_def-inner-outer">内縁</a> `主size$に相対的
◎
relative to the flex container’s inner main size
◎算 
指定された~keyword あるいは算出された `length-percentage$t 値
◎
specified keyword or a computed &lt;length-percentage&gt; value
◎順 文法に従う
◎ア 算出d値の型による
◎表終

<p class="advisement"><strong>
作者には、
`flex-basis$p を直に利用せずに，
`flex$p 略式~propを利用して ~flex能を制御することが奨励される。
この略式~propは、`共通的な用途$に適応するように，未指定の成分を正しく再設定するので。
</strong>
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-basis directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

<p>
`flex-basis$p ~propは、`~flex基底s$を設定する。
それは `width$p ／ `height$p ~propが受容する値に加えて，値
`content$v:fb も受容する。
◎
The flex-basis property sets the flex basis. It accepts the same values as the width and height property, plus content.
</p>

<p>
上に定義された
`auto$v:fb, `content$v:fb
以外のすべての値に対しては、横書き書字modeの下では，
`flex-basis$p は `width$p と同じ仕方で解決される `CSS2$r 。
ただし、値が `width$p 用の `~autoS$v に解決される場合は，代わりに
`flex-basis$p 用の `content$v:fb に解決される。
例えば、
`flex-basis$p に対する百分率~値は，~flex駒の包含塊（すなわち，その~flex容器）を基準に解決され、包含塊の~sizeが`不定$である場合の `flex-basis$p の使用~値は， `content$v:fb になる。
別の~~帰結として、
`box-sizing$p など 他から指定されない限り， `flex-basis$p は内容~boxの~sizeを決定する。
◎
For all values other than auto and content (defined above), flex-basis is resolved the same way as width in horizontal writing modes [CSS2], except that if a value would resolve to auto for width, it instead resolves to content for flex-basis. For example, percentage values of flex-basis are resolved against the flex item’s containing block (i.e. its flex container); and if that containing block’s size is indefinite, the used value for flex-basis is content. As another corollary, flex-basis determines the size of the content box, unless otherwise specified such as by box-sizing [CSS3UI].
</p>

			</section>
		</section>
	</section>

	<section id="alignment">
<h2 title="Alignment">8. 整列</h2>

<p>
~flex容器の内容がそれらの~flex~~処理を終えて，すべての~flex駒【の~flex~sizeを】について両~次元とも完結したなら、それらは，~flex容器~内で整列できるようになる。
◎
After a flex container’s contents have finished their flexing and the dimensions of all flex items are finalized, they can then be aligned within the flex container.
</p>

<p>
`margin$p ~propを，塊~layoutの下で~marginが行えるものに類似するが, より強力な方式で駒を整列するために利用できる。
`~flex駒$はまた、
Box Alignment 仕様 `CSS-ALIGN-3$r
による`整列~prop$も~~尊守する
— これにより，`主-軸$, `交叉-軸$ いずれについても、~keywordに基づく駒の整列は容易に可能になる。
これらの~propは、［
CSS 2.1 の下では非常に困難であった，縦横 両~方向の中央~寄せ
］なども含む，共通的にある型の整列を自明にする。
◎
The margin properties can be used to align items in a manner similar to, but more powerful than, what margins can do in block layout. Flex items also respect the alignment properties from CSS Box Alignment, which allow easy keyword-based alignment of items in both the main axis and cross axis. These properties make many common types of alignment trivial, including some things that were very difficult in CSS 2.1, like horizontal and vertical centering.
</p>

<p class="note">注記：
この節に~~現れる各種~整列~propは， Box Alignment 仕様に定義されているが、仕様の策定を遅らせないため，この仕様では、規範的な依存関係は作成せずに，関連な部分の定義を ここに再現する。
これらの~propは、 Box Alignment Level 3 が策定を終え, 他の~layout~mode用の効果を定義するまでは、~flex~layoutにのみ適用される。
加えて、Box Alignment ~moduleに定義される新たな値は，~flex~layoutにも適用される
— 言い換えれば、 Box Alignment ~moduleが完了した時点で，ここに与える定義に取って代わることになる。
◎
Note: While the alignment properties are defined in CSS Box Alignment [CSS-ALIGN-3], Flexible Box Layout reproduces the definitions of the relevant ones here so as to not create a normative dependency that may slow down advancement of the spec. These properties apply only to flex layout until CSS Box Alignment Level 3 is finished and defines their effect for other layout modes. Additionally, any new values defined in the Box Alignment module will apply to Flexible Box Layout; in other words, the Box Alignment module, once completed, will supersede the definitions here.
</p>

		<section id="auto-margins">
<h3 title="Aligning with auto margins">8.1. `auto^v ~marginによる整列-法</h3>

<p>
`この節は参考である。^em
~marginが~flex駒にどのように影響するかについての規範的な定義は、
§ `~flex~layout~algo$
にて与えられる。
◎
This section is non-normative. The normative definition of how margins affect flex items is in the Flex Layout Algorithm section.
</p>

<p>
~flex駒に対する自動（ `auto^en ）~marginの効果は、塊~flowの下での自動~marginととてもよく似る：
◎
Auto margins on flex items have an effect very similar to auto margins in block flow:
</p>

<ul>
	<li>
~flex基底s, ~flex可能な長さの計算を行う間は，
自動~marginは `0^v に扱われる。
◎
During calculations of flex bases and flexible lengths, auto margins are treated as 0.
</li>
	<li>
`justify-content$p, `align-self$p
による整列に先立って，
正な自由空間は、その次元に属する自動~marginに配分される。
◎
Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.
</li>
	<li>
~overflowする一連の~boxは、それらの`終端$方向の 自動~margin, ~overflow を無視する。
◎
Overflowing boxes ignore their auto margins and overflow in the end direction.
</li>
</ul>

<p class="note">注記：
自由空間が自動~marginに配分される場合、各種 `整列~prop$による，その次元に対する効果はなくなる。
~flex~~処理の後に残される自由空間すべては、~marginにより奪われることになるので。
◎
Note: If free space is distributed to auto margins, the alignment properties will have no effect in that dimension because the margins will have stolen all the free space left over after flexing.
</p>

<div class="example">
<p>
`auto^v ~marginの用途の一つに、一連の~flex駒を，主-軸の中で 別々の “一連の~group” に分けることが挙げられる。
これを利用して、共通的な~UI~pattern
—
左端に整列されるものと, 右端に整列されるものに分けられた，いくつかの~actionからなる単独の~bar
—
を再現する例を次に示す：
◎
One use of auto margins in the main axis is to separate flex items into distinct "groups". The following example shows how to use this to reproduce a common UI pattern - a single bar of actions with some aligned on the left and others aligned on the right.
</p>

<figure>

<figcaption>
下の~codeの描画~見本：
◎
Sample rendering of the code below.
</figcaption>
`auto-bar^dgm
</figure>

<pre class="lang-css">
nav &gt; ul {
  `display$p:flex;
}
nav &gt; ul &gt; #login {
  `margin-left$p:auto;
}
</pre>

<pre class="lang-html">
&lt;nav&gt;
  &lt;ul&gt;
&lt;li&gt;&lt;a href=/about&gt;About&lt;/a&gt;
&lt;li&gt;&lt;a href=/projects&gt;Projects&lt;/a&gt;
&lt;li&gt;&lt;a href=/interact&gt;Interact&lt;/a&gt;
&lt;li id="login"&gt;&lt;a href=/login&gt;Login&lt;/a&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
</pre>

</div>

<div class="example">
<p>
~overflowが生じる状況~下で、`~auto_v~margin$を利用した場合と,
<a href="#propdef-align-items">整列~prop</a>
を利用した場合との間の，交叉-軸~沿いの整列の相違を下の図に示す：
◎
The figure below illustrates the difference in cross-axis alignment in overflow situations between using auto margins and using the alignment properties.
</p>

<figure>`cross-auto-figure^dgm
<figcaption>
図左の一連の駒は，~marginにより中央~寄せにされる一方、図右のものは `align-self$p により中央~寄せにされている。
この~col~flex容器が~pageの左~辺に配置される場合、図左の，~~長い駒も全部的に読み取れる~marginによる挙動の方が，望ましいものになるであろう。
他の状況下では，図右の “真の~~意味の” 中央~寄せの挙動の方が好ましいものになり得る。
◎
The items in the figure on the left are centered with margins, while those in the figure on the right are centered with align-self. If this column flex container was placed against the left edge of the page, the margin behavior would be more desirable, as the long item would be fully readable. In other circumstances, the true centering behavior might be better.
</figcaption></figure>

</div>

		</section>
		<section id="justify-content-property">
<h3 title="Axis Alignment: the justify-content property">8.2. 主-軸~沿いの整列： `justify-content^p ~prop</h3>
【！align.justify-content】

◎名 `justify-content@p
◎値
`flex-start$v:j |
`flex-end$v:j |
`center$v:j |
`space-between$v:j |
`space-around$v:j
◎初 `flex-start$v:j
◎適 `~flex容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`justify-content$p ~propは、~flex容器の現在の行fの`主-軸$沿いに，`~flex駒$を整列する。
これは、~flex可能な長さおよび`~auto_v~margin$が解決された`後に^em行われる。
これは概して、行f上の`~flex駒$すべてについて，それぞれが［
~flex不能, または
~flex可能であるが その最大~sizeに到達している
］ときの，残されて余った 自由空間の配分を補助する。
それはまた、行fを~overflowする駒の整列について、ある程度の制御を~~供する。
◎
The justify-content property aligns flex items along the main axis of the current line of the flex container. This is done after any flexible lengths and any auto margins have been resolved. Typically it helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.
</p>

<dl>
	<dt>`flex-start@v:j</dt>
	<dd>
`~flex駒$は行fの始端に寄せるように収納される：
行f上の最初の`~flex駒$の`主-始端$ ~margin辺は，行fの`主-始端$辺に接合され、後続の各`~flex駒$は，先行する駒に接合される。
◎
Flex items are packed toward the start of the line. The main-start margin edge of the first flex item on the line is placed flush with the main-start edge of the line, and each subsequent flex item is placed flush with the preceding item.
</dd>

	<dt>`flex-end@v:j</dt>
	<dd>
`~flex駒$は行fの終端に寄せるように収納される：
行f上の最後の`~flex駒$の`主-始端$ ~margin辺は，行fの`主-終端$辺に接合され、先行する各`~flex駒$は，後続の駒に接合される。
◎
Flex items are packed toward the end of the line. The main-end margin edge of the last flex item is placed flush with the main-end edge of the line, and each preceding flex item is placed flush with the subsequent item.
</dd>

	<dt>`center@v:j</dt>
	<dd>
`~flex駒$は行fの中央に寄せるように収納される：
行f上の一連の`~flex駒$は、互いに接合された上で、［
行fの`主-始端$辺と行f上の最初の駒との間
］, および［
行fの`主-終端$辺と行f上の最後の駒との間
］の空間が等量になるように，行fの中央に寄せるように整列される。
（残された自由空間が負である場合、`~flex駒$は両~方向に等しく~overflowすることになる。）
◎
Flex items are packed toward the center of the line. The flex items on the line are placed flush with each other and aligned in the center of the line, with equal amounts of space between the main-start edge of the line and the first item on the line and between the main-end edge of the line and the last item on the line. (If the leftover free-space is negative, the flex items will overflow equally in both directions.)
</dd>

	<dt>`space-between@v:j</dt>
	<dd>
`~flex駒$は行f内に均等に分布される：
残された自由空間が負である場合，あるいは
行f上に在る`~flex駒$ が 1 個だけの場合、この値の効果は `flex-start$v:j と一致する。
他の場合、行f上の［
最初／最後
］の`~flex駒$の［
`主-始端$／`主-終端$
］~margin辺が，行fの［
`主-始端$／`主-終端$
］辺に接合され、行f上の残りの`~flex駒$については，隣接な 2 つの駒の間隔がすべて一致するように，自由空間が配分される。
◎
Flex items are evenly distributed in the line. If the leftover free-space is negative or there is only a single flex item on the line, this value is identical to flex-start. Otherwise, the main-start margin edge of the first flex item on the line is placed flush with the main-start edge of the line, the main-end margin edge of the last flex item on the line is placed flush with the main-end edge of the line, and the remaining flex items on the line are distributed so that the spacing between any two adjacent items is the same.
</dd>

	<dt>`space-around@v:j</dt>
	<dd>
一連の`~flex駒$は、両端には半分~sizeの空間を伴う様に，行f内に均等に分布される：
残された自由空間が負であるか, または
行f上に在る`~flex駒$が 1 個だけの場合、この値の効果は `center$v:j と一致する。
他の場合、行f上の隣接な どの 2 つの`~flex駒$の間隔も同じ~sizeになり，その半分~sizeが［
行f上の［
最初／最後
］の`~flex駒$と［
`~flex容器$辺
］との間隔
］に一致するように、自由空間が配分される。
◎
Flex items are evenly distributed in the line, with half-size spaces on either end. If the leftover free-space is negative or there is only a single flex item on the line, this value is identical to center. Otherwise, the flex items on the line are distributed such that the spacing between any two adjacent flex items on the line is the same, and the spacing between the first/last flex items and the flex container edges is half the size of the spacing between flex items.
</dd>
</dl>

<figure>`flex-pack^dgm
<figcaption>
5 種の `justify-content$p ~keywordによる，~flex容器~上の効果を、 3 色に色分けされた駒で図示
◎
An illustration of the five justify-content keywords and their effects on a flex container with three colored items.
</figcaption></figure>

l		</section>
		<section id="align-items-property">
<h3 title="Cross-axis Alignment: the align-items and align-self properties">8.3. 交叉-軸~沿いの整列： `align-items^p と `align-self^p ~prop</h3>

◎名 `align-items@p
◎値
`flex-start$v:ais |
`flex-end$v:ais |
`center$v:ais |
`baseline$v:ais |
`stretch$v:ais
◎初 `stretch$v:ais
◎適 `~flex容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

◎名 `align-self@p
◎値
`auto$v:as |
`flex-start$v:ais |
`flex-end$v:ais |
`center$v:ais |
`baseline$v:ais |
`stretch$v:ais
◎初 `auto$v:as
◎適 `~flex駒$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~flex容器の行fの中の一連の`~flex駒$は、方向が垂直にされることを除いて `justify-content$p と類似に，行fの`交叉-軸$~~方向に整列させることができる。
`align-items$p は、匿名`~flex駒$も含め，~flex容器のすべての`~flex駒$用の既定の整列を設定する。
`align-self$p は、この既定の整列を，個々の`~flex駒$について上書きできるようにする。
（匿名~flex駒に対しては、 `align-self$p は，それに結び付けられている~flex容器~上の `align-items$p の値に常に合致する。）
◎
Flex items can be aligned in the cross axis of the current line of the flex container, similar to justify-content but in the perpendicular direction. align-items sets the default alignment for all of the flex container’s items, including anonymous flex items. align-self allows this default alignment to be overridden for individual flex items. (For anonymous flex items, align-self always matches the value of align-items on their associated flex container.)
</p>

<p>
`~flex駒$の交叉-軸~marginが両側とも `auto^v である場合、
`align-self$p の効果はない。
◎
If either of the flex item’s cross-axis margins are auto, align-self has no effect.
</p>

<p>
各種~値の意味は、次で与えられる：
◎
Values have the following meanings:
</p>

<dl>
	<dt>`auto@v:as</dt>
	<dd>
`交叉-軸$の整列~制御を，親~box上の `align-items$p の値に委ねる。
（これが `align-self$p の初期~値。）
◎
Defers cross-axis alignment control to the value of align-items on the parent box. (This is the initial value of align-self.)
</dd>

	<dt>`flex-start@v:ais</dt>
	<dd>
`~flex駒$の`交叉-始端$ ~margin辺は，行fの`交叉-始端$辺に接合される。
◎
The cross-start margin edge of the flex item is placed flush with the cross-start edge of the line.
</dd>

	<dt>`flex-end@v:ais</dt>
	<dd>
`~flex駒$の`交叉-終端$ ~margin辺は，行fの`交叉-終端$辺に接合される。
◎
The cross-end margin edge of the flex item is placed flush with the cross-end edge of the line.
</dd>

	<dt>`center@v:ais</dt>
	<dd>
`~flex駒$の~margin~boxは，行f内の`交叉-軸$の中で中央~寄せにされる。
（
~flex行lの`交叉size$が`~flex駒$のそれより小さい場合、
それは両~方向に等しく~overflowすることになる。
）
◎
The flex item’s margin box is centered in the cross axis within the line. (If the cross size of the flex line is less than that of the flex item, it will overflow equally in both directions.)
</dd>

	<dt>`baseline@v:ais</dt>
	<dd>
`~flex駒$は
`基底線~整列に関与-@
する — 
すなわち、行f上の，関与しているすべての`~flex駒$は、それらの基底線が互いに整列するように, かつ それらのうち［［［
自身の［
基底線と［
`交叉-始端$ ~margin辺
］］の間の距離
］が最~大になる駒
］が，行fの`交叉-始端$ 辺に接合される
］ように，整列される。
整列する軸に基底線を持たない`~flex駒$の基底線は、その~border~boxから`合成-$されるとする。
◎
The flex item participates in baseline alignment: all participating flex items on the line are aligned such that their baselines align, and the item with the largest distance between its baseline and its cross-start margin edge is placed flush against the cross-start edge of the line. If the item does not have a baseline in the necessary axis, then one is synthesized from the flex item’s border box.
</dd>

	<dt>`stretch@v:ais</dt>
	<dd>
`交叉size~prop$が `~autoS$v に算出され, かつ
交叉-軸~marginの両側とも非 `auto^v の場合、`~flex駒$は
`伸張-@
される。
その場合の使用~値は，［
`min-height$p ／
`min-width$p ／
`max-height$p ／
`max-width$p
］により課される拘束の下で，［
その駒の~margin~boxの`交叉size$が，その行fと同じ~sizeにアリな限り近くされる
］ような長さになる。
◎
If the cross size property of the flex item computes to auto, and neither of the cross-axis margins are auto, the flex item is stretched. Its used value is the length necessary to make the cross size of the item’s margin box as close to the same size as the line as possible, while still respecting the constraints imposed by min-height/min-width/max-height/max-width.
</dd>
	<dd class="note">注記：
~flex容器の縦幅が拘束されている場合、この値により，`~flex駒$の内容が駒を~overflowさせ得る。
◎
Note: If the flex container’s height is constrained this value may cause the contents of the flex item to overflow the item.
</dd>
	<dd>
`~flex駒$の`交叉-始端$~margin辺は，その行fの`交叉-始端$辺に接合される。
◎
The cross-start margin edge of the flex item is placed flush with the cross-start edge of the line.
</dd>
</dl>

<figure>`flex-align^dgm
<figcaption>
~flex容器~上における， 5 種の `align-items$p ~keywordによる効果を、 4 色に色分けされた駒で図示。
◎
An illustration of the five align-items keywords and their effects on a flex container with four colored items.
</figcaption></figure>

		</section>
		<section id="align-content-property">
<h3 title="Packing Flex Lines: the align-content property">8.4. 一連の~flex行lの収納-法： `align-content^p ~prop</h3>

◎名 `align-content@p
◎値
`flex-start$v:ac |
`flex-end$v:ac |
`center$v:ac |
`space-between$v:ac |
`space-around$v:ac |
`stretch$v:ac
◎初 `stretch$v:ac
◎適 `複-行f$な`~flex容器$
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`align-content$p ~propは、`交叉-軸$に余った空間があるときに，~flex容器の一連の行fを~flex容器の中で整列する
—
`justify-content$p が個々の駒を`主-軸$の中で整列するときと類似に。
この~propは，`単-行f$な~flex容器に対しては 効果はないことに注意。
各種~値の意味は，次で与えられる：
◎
The align-content property aligns a flex container’s lines within the flex container when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note, this property has no effect on a single-line flex container. Values have the following meanings:
</p>

<dl>
	<dt>`flex-start@v:ac</dt>
	<dd>
一連の行fは，~flex容器の始端に寄せるように収納される：
~flex容器の中の最初の行fの`交叉-始端$辺は，~flex容器の`交叉-始端$辺に接合され、後続の各~行fは，先行する行fに接合される。
◎
Lines are packed toward the start of the flex container. The cross-start edge of the first line in the flex container is placed flush with the cross-start edge of the flex container, and each subsequent line is placed flush with the preceding line.
</dd>

	<dt>`flex-end@v:ac</dt>
	<dd>
一連の行fは，~flex容器の終端に寄せるように収納される：
~flex容器の中の最後の行fの`交叉-終端$辺は，~flex容器の`交叉-終端$辺に接合され、後続の各~行fは，先行する行fに接合される。
◎
Lines are packed toward the end of the flex container. The cross-end edge of the last line is placed flush with the cross-end edge of the flex container, and each preceding line is placed flush with the subsequent line.
</dd>

	<dt>`center@v:ac</dt>
	<dd>
一連の行fは，~flex容器の中央に寄せるように収納される：
~flex容器の中の一連の行fは、互いに接合された上で，~flex容器の中央に整列される
—［
~flex容器の`交叉-始端$内容~辺と ~flex容器の最初の行fとの合間,
］, および［
~flex容器の`交叉-終端$内容~辺と ~flex容器の最後の行fとの合間
］の空間が等量になるように（残された自由空間が負である場合，一連の行fは両~方向に等しく~overflowすることになる）。
◎
Lines are packed toward the center of the flex container. The lines in the flex container are placed flush with each other and aligned in the center of the flex container, with equal amounts of space between the cross-start content edge of the flex container and the first line in the flex container, and between the cross-end content edge of the flex container and the last line in the flex container. (If the leftover free-space is negative, the lines will overflow equally in both directions.)
</dd>

	<dt>`space-between@v:ac</dt>
	<dd>
一連の行fは、~flex容器の中で均等に分布される：
残された自由空間が負である場合, または
~flex容器~内の~flex行lが 1 本だけの場合、この値の効果は， `flex-start$v:ac と一致する。
他の場合、~flex容器の中の［
最初／最後
］の行fの［
`交叉-始端$／`交叉-終端$
］辺が，~flex容器の［
`交叉-始端$／`交叉-終端$
］内容~辺に接合され，~flex容器の中の残りの行fについては，隣接な どの 2 本の行fの間隔も同じになるように、自由空間が配分される。
◎
Lines are evenly distributed in the flex container. If the leftover free-space is negative or there is only a single flex line in the flex container, this value is identical to flex-start. Otherwise, the cross-start edge of the first line in the flex container is placed flush with the cross-start content edge of the flex container, the cross-end edge of the last line in the flex container is placed flush with the cross-end content edge of the flex container, and the remaining lines in the flex container are distributed so that the spacing between any two adjacent lines is the same.
</dd>

	<dt>`space-around@v:ac</dt>
	<dd>
一連の`~flex駒$は、両端には半分~sizeの空間を伴う様に，~flex容器の中で均等に分布される：
残された自由空間が負である場合、この値の効果は `center$v:ac と一致する。
他の場合、~flex容器の中の一連の行fは［
隣接な どの 2 本の行fの間隔も同じ~sizeになり，その半分~sizeが［［
最初／最後
］の行fと［
`~flex容器$辺
］との間隔
］になるように、自由空間が配分される。
◎
Lines are evenly distributed in the flex container, with half-size spaces on either end. If the leftover free-space is negative this value is identical to center. Otherwise, the lines in the flex container are distributed such that the spacing between any two adjacent lines is the same, and the spacing between the first/last lines and the flex container edges is half the size of the spacing between flex lines.
</dd>

	<dt>`stretch@v:ac</dt>
	<dd>
一連の行fは、残りの空間を占めるように伸張される：
残された自由空間が負である場合，この値の効果は `flex-start$v:ac に一致する。
他の場合、自由空間は，すべての行fの合間が等しくになるように分割された上で
それらの交叉sizeを増大させる。
◎
Lines stretch to take up the remaining space. If the leftover free-space is negative, this value is identical to flex-start. Otherwise, the free-space is split equally between all of the lines, increasing their cross size.
</dd>
</dl>

<p class="note">注記：
`複-行f$な~flex容器のみが、`交叉-軸$~~方向に自由空間を持ち，一連の行fは その中で整列されることになる。
`単-行f$な~flex容器における唯一の行fは，空間を埋めるために自動的に伸張されるので。
◎
Note: Only multi-line flex containers ever have free space in the cross-axis for lines to be aligned in, because in a single-line flex container the sole line automatically stretches to fill the space.
</p>

<figure>`align-content-example^dgm
<figcaption>
各種 `align-content$p ~keywordによる，`複-行f$な~flex容器に対する効果の図示
◎
An illustration of the align-content keywords and their effects on a multi-line flex container.
</figcaption></figure>

		</section>
		<section id="flex-baselines">
<h3 title="Flex Container Baselines">8.5. ~flex容器の基底線</h3>

<p>
`~flex容器$自身
— 以下，単に %容器 と記す —
を`基底線~整列に関与-$させるためには（例： %容器 が，外縁の`~flex容器$内の`~flex駒$であるとき）、自身の内容を最も良く表現するような基底線の位置を %容器 に提出させる必要がある。
この~~目的において，
%容器 の`基底線~集合$は、（ `order$p による並替ngの後, かつ `flex-direction$p も織り込んだ上で，）以下に従って決定される基底線 %整列~基底線 から`生成される$
— 以下 “／” は同順とする：
◎
In order for a flex container to itself participate in baseline alignment (e.g. when the flex container is itself a flex item in an outer flex container), it needs to submit the position of the baselines that will best represent its contents. To this end, the baselines of a flex container are determined as follows (after reordering with order, and taking flex-direction into account):
</p>

<dl class="def-list">
	<dt>
`主-軸 基底線~集合@
【主-軸に平行な基底線~集合】
◎
first/last main-axis baseline set
</dt>
	<dd>
<p>
%容器 の［
`行内-軸$と`主-軸$
］が合致する場合、
%容器 の［
最初／最後
］の`主-軸 基底線~集合$は，次に従って決定される：
◎
When the inline axis of the flex container matches its main axis, its baselines are determined as follows:
</p>

		<ol>
			<li>
<p>
%容器 内に次をいずれも満たすような`~flex駒$は在るならば：
</p>

				<ul>
					<li>
<p>
最も［
始端／終端
］にある`~flex行l$に配置される
</p>

<p class="trans-note">【
“最も始端（終端）”
は、おそらく~layout後の位置を意味する。
したがって，原文には記述がないが、
`flex-wrap$p により指定される堆積~方向も織り込まれることになるはず。
】</p>

					</li>
					<li>
`基底線~整列に関与-$する
</li>
				</ul>
<p>
そのような駒たちが共有する`整列~基底線$が %整列~基底線 を与える。
</p>

◎
If any of the flex items on the flex container’s startmost/endmost flex line participate in baseline alignment, the flex container’s first/last main-axis baseline set is generated from the shared alignment baseline of those flex items.
</li>
			<li>
<p>
他の場合， %容器 内に`~flex駒$はあるならば、［
それらのうち最も［
始端／終端
］にある駒
］ %駒 が［
%容器 の`主-軸$に平行な`整列~基底線$
］を：
</p>
<ul><li>持つならば、それが %整列~基底線 を与える。
</li><li>持たないならば、 %駒 の~border~boxから`合成-$される`整列~基底線$が %整列~基底線 を与える。
</li></ul>
◎
Otherwise, if the flex container has at least one flex item, the flex container’s first/last main-axis baseline set is generated from the alignment baseline of the startmost/endmost flex item. (If that item has no alignment baseline parallel to the flex container’s main axis, then one is first synthesized from its border edges.)
</li>
			<li>
他の場合， %容器 は［
最初／最後
］の`基底線~集合$を持たない
— この場合
⇒
%容器 が属する`整列~文脈$の規則に則って`合成-$した結果が %整列~基底線 を与える。
◎
Otherwise, the flex container has no first/last main-axis baseline set, and one is synthesized if needed according to the rules of its alignment context.
</li>
		</ol>
	</dd>

	<dt>
`交叉-軸 基底線~集合@
【交叉-軸に平行な基底線~集合】
◎
first/last cross-axis baseline set
</dt>
	<dd>
<p>
%容器 の［
`行内-軸$と`交叉-軸$
］が合致する場合、
%容器 の［
最初／最後
］の`交叉-軸 基底線~集合$は、次に従って決定される：
◎
When the inline axis of the flex container matches its cross axis, its baselines are determined as follows:
</p>

		<ol>
			<li>
<p>
%容器 内に`~flex駒$はあるならば、それらのうち最も［
始端／終端
］にある駒 %駒 が［
%容器 の`交叉-軸$に平行な`整列~基底線$
］を：
</p>
<ul><li>持つならば、それが %整列~基底線 を与える。
</li><li>持たないならば、 %駒 の~border~boxから`合成-$される`整列~基底線$が %整列~基底線 を与える。
</li></ul>

◎
If the flex container has at least one flex item, the flex container’s first/last cross-axis baseline set is generated from the alignment baseline of the startmost/endmost flex item. (If that item has no alignment baseline parallel to the flex container’s cross axis, then one is first synthesized from its border edges.)
</li>
			<li>
他の場合， %容器 は［
最初／最後
］の`基底線~集合$を持たない
— この場合
⇒
%容器 が属する`整列~文脈$の規則に則って`合成-$した結果が %整列~基底線 を与える。
◎
Otherwise, the flex container has no first/last cross-axis baseline set, and one is synthesized if needed according to the rules of its alignment context.
</li>
		</ol>
	</dd>
</dl>

<p>
上述の規則に則って基底線を計算する際に，基底線を供与している~boxの `overflow$p が~scrollを許容する値にされている場合、その基底線を決定する目的においては，その~boxは初期~scroll位置にあるものと扱うモノトスル。
◎
When calculating the baseline according to the above rules, if the box contributing a baseline has an overflow value that allows scrolling, the box must be treated as being in its initial scroll position for the purpose of determining its baseline.
</p>

<p>
<a href="~CSS22/tables.html#height-layout">~table~cellの基底線の決定</a>
の際には、行l~boxや `table-row^v `CSS2$r のときとちょうど同じ様に，~flex容器が基底線を供する。
◎
When determining the baseline of a table cell, a flex container provides a baseline just as a line box or table-row does. [CSS2]
</p>

<p>
基底線についての詳細は、
CSS Writing Modes 3 の
<a href="~CSSWM#intro-baselines">§ 基底線 — 序論</a>,
および CSS Alingment Module の
<a href="~CSSALIGN#baseline-rules">§ 基底線~整列の詳細</a>
を見よ。
◎
See CSS Writing Modes 3 § 4.1 Introduction to Baselines and CSS Box Alignment 3 § 9 Baseline Alignment Details for more information on baselines.
</p>
		</section>
	</section>
	<section id="layout-algorithm">
<h2 title="Flex Layout Algorithm">9. ~flex~layout~algo</h2>

<p>
この節には、~flex容器とその内容の正確な~layoutの挙動について詳細を与える，規範的な~algoが含められている。
~algoは，可読性と理論的簡潔さを最適化するように書かれているので、効率的とは限らない。
実装は，実際の~algoに何を利用してもヨイが、ここに述べる~algoと同じ結果を生産するモノトスル。
◎
This section contains normative algorithms detailing the exact layout behavior of a flex container and its contents. The algorithms here are written to optimize readability and theoretical simplicity, and may not necessarily be the most efficient. Implementations may use whatever actual algorithms they wish, but must produce the same results as the algorithms described here.
</p>

<p class="note">注記：
この節は、~~主に実装者~向けに意図されている。
~web~page作者にとっては、一般に，個々の~propの記述にて十分になるべきであり、~CSS~layoutについての難解な詳細を理解する切迫した~~動機がない限り，この節を読む必要はない。

◎
Note: This section is mainly intended for implementors. Authors writing web pages should generally be served well by the individual property descriptions, and do not need to read this section unless they have a deep-seated urge to understand arcane details of CSS layout.
</p>

<p>
以下の下位~節にて，~flex容器とその内容を~lay-outするための~algoを定義する。
◎
The following sections define the algorithm for laying out a flex container and its contents.
</p>

<p class="note">注記：
~flex~layoutは、元の文書~順序ではなく `order$p により`改変された文書~順序$の下で，`~flex駒$たちに対し働く。
◎
Note: Flex layout works with the flex items in order-modified document order, not their original document order.
</p>

<p class="trans-note">【
以下の~algoの中の，
~IF, ~ELSE
等の記号の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
】</p>

<p class="trans-note" id="_def-inner-outer">【
以下に現れる［
“内縁（ `inner^en ）” ／ “外縁（ `outer^en ）”
］〜~sizeは、`~boxの寸法$にて定義される~boxの［
内容~辺 ／ ~margin辺
］が成す区画の~sizeを指す。
】</p>

		<section id="box-manip">
<h3 title="Initial Setup">9.1. 初期設定</h3>

<ol start="1">

<li id="algo-anon-box">
<a href="#flex-items">§ ~flex駒</a>
の記述に従って，
<strong>一連の匿名~flex駒を生成する</strong>。
◎
Generate anonymous flex items as described in § 4 Flex Items.
</li>
</ol>

		</section>
		<section id="line-sizing">
<h3 title="Line Length Determination">9.2. 行f長さの決定</h3>

<ol class="continue">
	<li id="algo-available">
<p><strong>（
［
主-沿い, 交叉-沿い
］それぞれについて，一連の~flex駒に可用な空間を決定する
）</strong>
◎
Determine the available main and cross space for the flex items.＼
</p>

<p>
`~flex容器$ %容器 の内容に`可用な空間$は、それぞれの次元について，次に従って与えられる：
◎
For each dimension,＼
</p>

		<ol>
			<li>
~IF［
%容器 の内容~boxの~sizeは、その次元において`確定的$である
］
⇒
その~size。
◎
if that dimension of the flex container’s content box is a definite size, use that;＼
</li>
			<li>
~ELIF［
%容器 の内容~boxは、その次元において［
`最小-内容 拘束$または`最大-内容 拘束$
］の下で~sizeされている
］
⇒
その拘束として与えられる。
◎
if that dimension of the flex container is being sized under a min or max-content constraint, the available space in that dimension is that constraint;＼
</li>
			<li>
<p>
~ELSE
⇒
その次元において、 %容器 に`可用な空間$から %容器 の［
~margin + ~border + ~padding
］の分を減算した結果の値。
<span class="note">この値は無限にもなり得る。</span>
◎
otherwise, subtract the flex container’s margin, border, and padding from the space available to the flex container in that dimension and use that value.
This might result in an infinite value.
</p>
			</li>
		</ol>

<div class="example">
<p>
例えば，［
`~autoS$v に~sizeされていて,
`浮動-$している`~flex容器$
］の中の~flex駒に`可用な空間$は【横組みの下では】：
◎
For example, the available space to a flex item in a floated auto-sized flex container is:
</p>

<ul>
	<li>
横~次元においては：
( `~flex容器$の包含塊の横幅 ) ~MINUS ( `~flex容器$の横~次元の［
~margin + ~border + ~padding
］ )
◎
the width of the flex container’s containing block minus the flex container’s margin, border, and padding in the horizontal dimension
</li>
	<li>
縦~次元においては：無限
◎
infinite in the vertical dimension
</li>
</ul>

</div>

	</li>
	<li id="algo-main-item">
<div class="p">
<p><strong>（
~flex駒の`~flex基底~size$を`仮の主size$決定する
）</strong></p>

<p>
各 `~flex駒$ %駒 の
`~flex基底~size@
は、次の手続きの結果で与えられる：
</p>

◎
Determine the flex base size and hypothetical main size of each item:
</div>
		<ol>
			<li>
~IF［
%駒 の使用`~flex基底s$は`確定的$である
］
⇒
~RET その~size
◎
If the item has a definite used flex basis, that’s the flex base size.
</li>
			<li>
<p>
~IF［
%駒 は次のいずれも満たす
］…：
◎
If the flex item has ...
</p>
				<ul>
					<li>
内在的~縦横比を有する
◎
an intrinsic aspect ratio,
</li>
					<li>
使用`~flex基底s$ ~EQ `content$v:fb
◎
a used flex basis of content, and
</li>
					<li>
`交叉size$は`確定的$である
◎
a definite cross size,
</li>
				</ul>
<p>
…ならば
⇒
~RET %駒 の使用`交叉size$を %駒 の内在的~縦横比の`使用~値$で乗除算して，主-次元に換算した結果
◎
then the flex base size is calculated from its used cross size and the flex item’s intrinsic aspect ratio.
</p>
			</li>
			<li>
<p>
~IF［
%駒 の使用`~flex基底s$ ~EQ `content$v:fb
］~OR［
%駒 の使用`~flex基底s$は %駒 に`可用な空間$に依存する
］：
◎
↓</p>
				<ol>
					<li>
~IF［
~flex容器は［
`最小-内容 拘束$または`最大-内容 拘束$
］の下で~sizeされている（例えば
<a href="~CSS22/tables.html#auto-table-layout">自動的~table~layout</a>
`CSS2$r
を遂行するとき）
］
⇒
~RET %駒 をその拘束の下で~sizeした結果の， %駒 の`主size$
◎
If the used flex basis is content or depends on its available space, and the flex container is being sized under a min-content or max-content constraint (e.g. when performing automatic table layout [CSS2]), size the item under that constraint. The flex base size is the item’s resulting main size.
</li>
					<li>
<p>
~ELSE（すなわち， %駒 に可用な主sizeは無限であり, %駒 の`行内-軸$は`主-軸$に平行である）
⇒
~RET ［
%駒 を<a href="~CSSWM#orthogonal-flows">直交~flow下にある~box用の規則</a>
`CSS3-WRITING-MODES$r
］を利用して~lay-outした結果の， %駒 の最大-内容 `主size$
◎
Otherwise, if the used flex basis is content or depends on its available space, the available main size is infinite, and the flex item’s inline axis is parallel to the main axis, lay the item out using the rules for a box in an orthogonal flow [CSS3-WRITING-MODES]. The flex base size is the item’s max-content main size.
</p>

<p class="note">注記：
この事例は，例えば、横書き`書字mode$の英語~文書が包含している~col~flex容器が，縦書き日本語`~flex駒$を包含しているときに生じる。
◎
Note: This case occurs, for example, in an English document (horizontal writing mode) containing a column flex container containing a vertical Japanese (vertical writing mode) flex item.
</p>

					</li>
				</ol>
			</li>
			<li>
<p>
%駒 の使用`~flex基底s$を %駒 の`主size$に利用する下で， %駒 を`可用な空間$の中で~sizeする
— ここで：
</p>

<ul ><li>`~flex基底s$に対する値 `content$v:fb は `max-content$v として扱う
</li><li>`主size$を決定する際に`交叉size$が必要であり（例えば %駒 の`主size$が %駒 の塊-軸に沿うとき）, かつ［
%駒 の交叉sizeが `~autoS$v であって，`確定的$でない
］ならば、 %駒 の`交叉size$には `fit-content^v を利用する
</li></ul>

<p>
~RET ~sizeした結果の %駒 の`主size$
</p>

◎
Otherwise, size the item into the available space using its used flex basis in place of its main size, treating a value of content as max-content. If a cross size is needed to determine the main size (e.g. when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not definite, in this calculation use fit-content as the flex item’s cross size. The flex base size is the item’s resulting main size.
</li>
		</ol>

<p>
`~flex基底~size$を決定するときは、
%駒 の［
`最小-主size$, `最大-主size$
］は無視される（切詰めは生じない）。
加えて、 `box-sizing$p を適用するときに内容~boxの~sizeを 0 以上に切上げる計算も無視される。
（例えば、駒に［
~size 0, 正な~padding, `box-sizing$p:border-box
］が指定されている場合、駒の外縁`~flex基底~size$は 0 になる結果，その内縁`~flex基底~size$は負になる。）
◎
When determining the flex base size, the item’s min and max main sizes are ignored (no clamping occurs). Furthermore, the sizing calculations that floor the content box size at zero when applying box-sizing are also ignored. (For example, an item with a specified size of zero, positive padding, and box-sizing: border-box will have an outer flex base size of zero—and hence a negative inner flex base size.)
</p>
	</li>
	<li>
<p><strong>（
~flex駒の`仮の主size$を決定する
）</strong></p>

<p>
各 `~flex駒$ %駒 の
`仮の主size@
は、次で与えられる
⇒
 %駒 の`~flex基底~size$を %駒 の使用［
`最小-主size$, `最大-主size$
］に則って（および，内容~boxの~sizeは 0 以上に切上げるように）切詰めた結果
</p>
◎
The hypothetical main size is the item’s flex base size clamped according to its used min and max main sizes (and flooring the content box size at zero).
</li>
	<li id="algo-main-container">
<p><strong>（
~flex容器の`主size$を決定する
）</strong>
◎
Determine the main size of the flex container＼
</p>

<p>
`~flex容器$の`主size$を、それが関与する`整形~文脈$の規則を利用して決定する
◎
using the rules of the formatting context in which it participates.
</p>

<div class="note">
<p>注記：
`~flex容器$ %容器 が`塊~level$である場合、
%容器 の`自動的な塊~size$は，
%容器 の`最大-内容~size$になる。
◎
The automatic block size of a block-level flex container is its max-content size.
</p>
<p>
“塊~layout仕様” が，この等価性を定義するべきであるが、まだ存在しない。
◎
The Block Layout spec should define this equivalency, but it doesn’t exist yet.
</p>
</div>

	</li>
</ol>

		</section>
		<section id="main-sizing">
<h3 title="Main Size Determination">9.3. 主sizeの決定</h3>

<ol class="continue">
	<li id="algo-line-break">
<p><strong>
一連の~flex行lの中に，~flex駒を収集する
</strong>：
◎
Collect flex items into flex lines:
</p>
		<dl class="switch">
			<dt>~flex容器は`単-行f$ならば</dt>
			<dd>
すべての~flex駒を単独の~flex行lに収集する
◎
If the flex container is single-line, collect all the flex items into a single flex line.
</dd>

			<dt>~flex容器は`複-行f$ならば</dt>
			<dd>
収集-済みでない最初の駒から順に，連続する駒を，［
収集される`次の^em駒が，~flex容器の内縁 主sizeに収まらないような最初のものになる
］まで, または［
強制d分断に遭遇する（
<a href="#pagination">§ ~flex~layoutの断片化</a>
を見よ）
］まで、順次 収集していく。
ただし，いきなり収集-済みでない最初の駒が収まり切らないようであれば、単に，それのみを~~現在の行fに収集する。
◎
Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size (or until a forced break is encountered, see § 10 Fragmenting Flex Layout). If the very first uncollected item wouldn’t fit, collect just it into the line.
</dd>
			<dd>
この段においては、~flex駒の~sizeは，その外縁 `仮の主size$とする。
<span class="note">注記：
これは負にもなり得る。
</span>
◎
For this step, the size of a flex item is its outer hypothetical main size. (Note: This can be negative.)
</dd>
			<dd>
すべての~flex駒が，一連の~flex行lに収集されるまで、上を繰返す。
◎
Repeat until all flex items have been collected into flex lines.
</dd>
			<dd class="note">注記：
“可能な限り収集する” ことにより、~size 0 の~flex駒は，最後の非 0 ~sizeの駒が行fを正確に “埋尽くして” いたとしても，前の行fの終端に収集されることになる。
◎
Note that the "collect as many" line will collect zero-sized flex items onto the end of the previous line even if the last non-zero item exactly "filled up" the line.
</dd>
		</dl>
	</li>
	<li id="algo-flex">
<a href="#resolve-flexible-lengths">~flex可能な長さを解決-</a>して、すべての~flex駒について，その使用`主size$を見出す。
◎
Resolve the flexible lengths of all the flex items to find their used main size. See § 9.7 Resolving Flexible Lengths.
</li>
</ol>

		</section>
		<section id="cross-sizing">
<h3 title="Cross Size Determination">9.4. 交叉sizeの決定</h3>

<ol class="continue">
	<li id="algo-cross-item">
<p><strong>（
駒の仮の交叉sizeを決定する
）</strong></p>
<p>
各~駒の
`仮の交叉size@
を、［
駒は`~flow内$にある`塊~level$の~boxで，その使用`主size$【は前節で決定したそれ】を伴うものであった
］かのように，所与の`可用な空間$において~layoutを遂行することにより決定する
— `~autoS$v 【`交叉size$】は `fit-content^v として扱う下で。
</p>
◎
Determine the hypothetical cross size of each item by performing layout as if it were an in-flow block-level box with the used main size and the given available space, treating auto as fit-content.
</li>
	<li id="algo-cross-line">
<p><strong>（
各~flex行lの交叉sizeを計算する
）</strong>：
◎
Calculate the cross size of each flex line.
</p>
		<ol>
			<li>
~IF［
~flex容器は`単-行f$である
］~AND［
~flex容器の`交叉size$は`確定的$である
］
⇒
~flex行lの`交叉size$ ~SET `~flex容器$の内縁 `交叉size$
◎
If the flex container is single-line and has a definite cross size, the cross size of the flex line is the flex container’s inner cross size.
</li>
			<li>
<p>
~IF［
`~flex容器$は`複-行f$である
］：
◎
Otherwise, for each flex line:
</p>
				<ol>
					<li>
<p>
~EACH( `~flex行l$ %行f ) に対し：
</p>
						<ol>
							<li>
( %交叉size, %上面~size, %下面~size ) ~LET ( 0, 0, 0 )
</li>
							<li>
<p>
%行f 内の
~EACH( `~flex駒$ %駒 )
に対し：
</p>

								<ol>
									<li>
<p>
~IF［
%駒 は次をすべて満たす
］…：
</p>

<ul><li>行内-軸は主-軸に平行である
</li><li>`align-self$p は `baseline$v:ais
</li><li>交叉-軸~marginは両側とも非 `auto^v
</li></ul>

<p>
…ならば：
</p>

<ol ><li>%上面~size ~SET `max^op( %上面~size, %駒 の基底線と %駒 の仮の外縁 交叉-始端~辺との合間の距離 )
</li><li>%下面~size ~SET `max^op( %下面~size, %駒 の基底線と %駒 の仮の外縁 交叉-終端~辺との合間の距離 )
</li></ol>
									</li>
									<li>
~ELSE
⇒
%交叉size ~SET `max^op( %交叉size, %駒 の外縁 `仮の交叉size$ )
</li>
								</ol>
◎
Collect all the flex items whose inline-axis is parallel to the main-axis, whose align-self is baseline, and whose cross-axis margins are both non-auto. Find the largest of the distances between each item’s baseline and its hypothetical outer cross-start edge, and the largest of the distances between each item’s baseline and its hypothetical outer cross-end edge, and sum these two values.
◎
Among all the items not collected by the previous step, find the largest outer hypothetical cross size.
</li>
							<li>
%行f の使用~交叉size は次で与えられる
⇒
`max^op( %交叉size, ( %上面~size ~PLUS %下面~size ) )
◎
The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF［
~flex容器は`単-行f$である
］
⇒
その行fの~交叉sizeを 容器の算出d［
`最小-交叉size$, `最大-交叉size$
］で切詰める。
<span class="note">
CSS 2.1 による `min/max-width/height^p の定義が より一般に適用される場合、この挙動は自動的に `fall out^en することに注意【？】。【！＊】
</span>
◎
If the flex container is single-line, then clamp the line’s cross-size to be within the container’s computed min and max cross sizes. Note that if CSS 2.1’s definition of min/max-width/height applied more generally, this behavior would fall out automatically.
</li>
		</ol>
	</li>
	<li id="algo-line-stretch">
<p><strong>（
`align-content^p:stretch を取扱う
）</strong>
◎
Handle 'align-content: stretch'.＼
</p>

<div class="p">
<p>
~IF［
~flex容器は次をすべて満たす
］…：
</p>

<ul ><li>交叉sizeは`確定的$である
</li><li>`align-content$p は `stretch$v:ac
</li><li>内縁 交叉size ~GT 一連の~flex行lの交叉sizeの総和
</li></ul>
◎
If the flex container has a definite cross size, align-content is stretch, and the sum of the flex lines' cross sizes is less than the flex container’s inner cross size,＼
</div>

<p>
…ならば
⇒
各~flex行lの交叉sizeを，次が満たされるように等量に増大させる
⇒
すべての~flex行lの交叉sizeの総和 ~EQ ~flex容器の内縁 交叉size
◎
increase the cross size of each flex line by equal amounts such that the sum of their cross sizes exactly equals the flex container’s inner cross size.
</p>
	</li>
	<li id="algo-visibility">
<p><strong>（
`visibility^p:collapse にされている駒を`畳む$
）</strong>
◎
Collapse visibility:collapse items.＼
</p>

<p>
~IF［
`visibility$p:collapse にされている~flex駒はある
］：
◎
If any flex items have visibility: collapse,＼
</p>
		<ol>
			<li>
そのような
~EACH( %駒 )
に対し
⇒
%駒 の
`支柱~size@
~SET %駒 が属する行fの`交叉size$
◎
note the cross size of the line they’re in as the item’s strut size, and＼
</li>
			<li>
<p>
~layoutを最初から再開始する
— この 2 周目の~layout回においては：
◎
restart layout from the beginning.
◎
In this second layout round,＼
</p>

			<ul>
					<li>
<a href="#algo-line-break">駒を一連の行fに収集する</a>段においては
⇒
`畳まれ$た駒の`主size$は， 0 として扱う
◎
when collecting items into lines, treat the collapsed items as having zero main size.＼
</li>
					<li>
前項の段から <a href="#algo-cross-line">各~行fの交叉sizeを計算する段</a>までは
⇒
`畳まれ$た駒については，まるごと（ `display$p:none であったかのように）無視する
◎
For the rest of the algorithm following that step, ignore the collapsed items entirely (as if they were display:none) except that＼
</li>
					<li>
前項より後の段においては
⇒
各~行fの交叉sizeを［
その行f内の`畳まれ$た すべての駒の中で最~大な`支柱~size$
］以上になる様に切り上げる。
◎
after calculating the cross size of the lines, if any line’s cross size is less than the largest strut size among all the collapsed items in the line, set its cross size to that strut size.
</li>
				</ul>
			</li>
		</ol>

<p>
2 周目の~layout回においては，この段は飛ばす。
◎
Skip this step in the second layout round.
</p>

	</li>
	<li id="algo-stretch">
<p><strong>（
各~flex駒の使用~交叉sizeを決定する
）</strong>
◎
Determine the used cross size＼
</p>

<p>
~EACH( `~flex駒$ %駒 )
に対し：
◎
of each flex item.＼
</p>
		<ol>
			<li>
<p>
~IF［
%駒 は次をすべて満たす
］…：
</p>

<ul ><li>`align-self$p:stretch にされている【！指定d値？】
</li><li>`交叉size~prop$の算出d値は `~autoS$v
</li><li>交叉-軸~marginは両側とも非 `auto^v
</li></ul>

<p>
…ならば
⇒
%駒 の使用（外縁）交叉size ~SET ［
%駒 が属する~flex行lの使用~交叉size
］を %駒 の使用［
`最小-交叉size$, `最大-交叉size$
］に則って切詰めた結果
</p>
◎
If a flex item has align-self: stretch, its computed cross size property is auto, and neither of its cross-axis margins are auto, the used outer cross size is the used cross size of its flex line, clamped according to the item’s used min and max cross sizes.＼
</li>
			<li>
~ELSE
⇒
%駒 の使用~交叉size ~SET %駒 の`仮の交叉size$
◎
Otherwise, the used cross size is the item’s hypothetical cross size.
</li>
			<li>
~IF［
%駒 は `align-self$p:stretch にされている
］
⇒
~sizeが百分率の子を解決できるようにするため、前~段で得られた使用~sizeを %駒 の確定的な交叉sizeとして扱う下で，
%駒 の内容の~layoutをやり直す
◎
If the flex item has align-self: stretch, redo layout for its contents, treating this used size as its definite cross size so that percentage-sized children can be resolved.
</li>
		</ol>

<p class="note">注記：
この段は %駒 の`主size$には影響しない。
それが内在的~縦横比を有していたとしても。
◎
Note that this step does not affect the main size of the flex item, even if it has an intrinsic aspect ratio.
</p>

	</li>
</ol>

		</section>
		<section id="main-alignment">
<h3 title="Main-Axis Alignment">9.5. 主-軸~沿いの整列</h3>

<ol>
	<li id="algo-main-align">
<p><strong>（
自由空間を配分する
）</strong>
◎
Distribute any remaining free space.＼
</p>

<p>
~EACH( ~flex行l %行f )
に対し：
◎
For each flex line:
</p>

		<ol>
			<li>
%自由空間 ~LET `max^op( %行f の自由空間, 0 )
◎
↓</li>
			<li>
~IF［
%行f の主-軸~marginは両側とも `auto^v
］
⇒
両側の~margin ~SET %自由空間 ~DIV 2
◎
If the remaining free space is positive and at least one main-axis margin on this line is auto, distribute the free space equally among these margins.＼
◎
Otherwise, set all auto margins to zero.
</li>
			<li>
~ELIF［
%行f の主-軸~marginは片側だけ `auto^v
］
⇒
その~~側の~margin ~SET %自由空間
◎
↑</li>
			<li>
%行f 内の一連の駒を，
`justify-content$p に従って主-軸~沿いに整列させる
◎
Align the items along the main-axis per justify-content.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="cross-alignment">
<h3 title="Cross-Axis Alignment">9.6. 交叉-軸~沿いの整列</h3>

<ol class="continue">
	<li id="algo-cross-margins">
<div >
<p><strong>（
交叉-軸 `auto^v ~marginを解決する
）</strong></p>

<p>
この段における［
始端 ／ 終端
］は、`交叉-軸$における［
`始端$／`終端$
］を指すとする。
</p>

<p>
~EACH( ~flex駒 %駒 )
に対し：
</p>
◎
Resolve cross-axis auto margins.＼
</div>
		<ol>
			<li>
~IF［
%駒 の交叉-軸~marginは両側とも非 `auto^v
］
⇒
~CONTINUE
◎
If a flex item has auto cross-axis margins:
</li>
			<li>
%交叉size ~LET %駒 が属する~flex行lの交叉size
◎
↓</li>
			<li>
%差分~size ~LET
%交叉size ~MINUS ［
`auto^v ~marginは 0 として扱う下での， %駒 の外縁 交叉size
］
◎
↓</li>
			<li>
~IF［
%差分~size ~GT 0
］
⇒
%駒 の［
始端, 終端
］~marginのうち `auto^v にされている各側に， %差分~size を等量に配分する
◎
If its outer cross size (treating those auto margins as zero) is less than the cross size of its flex line, distribute the difference in those sizes equally to the auto margins.
</li>
			<li>
~ELIF［
%駒 の始端~margin は `auto^v
］
⇒
%駒 の始端~margin ~SET 0
◎
Otherwise, if the block-start or inline-start margin (whichever is in the cross axis) is auto, set it to zero.＼
</li>
			<li>
<p>
%駒 の終端~marginを ［
%駒 の外縁 交叉size ~EQ %交叉size
］になるように設定する
</p>

<p class="trans-note">【
原文の記述は、前~段の条件が満たされる場合に限り，この段を行うようにも読め、はっきりしない。
】</p>
◎
Set the opposite margin so that the outer cross size of the item equals the cross size of its flex line.
</li>
		</ol>
	</li>
	<li id="algo-cross-align">
<p><strong>（
%駒 を交叉-軸~沿いに整列する
）</strong></p>

<p>
~EACH( ~flex駒 %駒 )
に対し
⇒
~IF［
%駒 の交叉-軸~marginは両側とも非 `auto^v
］
⇒
%駒 の `align-self$p に従って， %駒 を交叉-軸~沿いに整列する
</p>
◎
Align all flex items along the cross-axis per align-self, if neither of the item’s cross-axis margins are auto.
</li>
	<li id="algo-cross-container">
<p><strong>（
`~flex容器$の使用`交叉size$を決定する
）</strong>
◎
Determine the flex container’s used cross size＼
</p>

<p>
~flex容器が関与する`整形~文脈$の規則を利用して。
内容に基づく`交叉size$が必要な場合、各`~flex行l$たちの`交叉size$の総和を利用する。
◎
using the rules of the formatting context in which it participates. If a content-based cross size is needed, use the sum of the flex lines' cross sizes.
</p>
	</li>
	<li id="algo-line-align">
<p><strong>（
すべての~flex行lを整列する
）</strong></p>
<p>
~flex容器~内のすべての~flex行lを，容器の `align-content$p に従って整列する
</p>
◎
Align all flex lines per align-content.
</li>
</ol>

		</section>
		<section id="resolve-flexible-lengths">
<h3 title="Resolving Flexible Lengths">9.7. ~flex可能な長さの解決-法</h3>

<p>
所与の~flex行l上の一連の`~flex駒$（以下，単に “駒” ）の~flex可能な長さを，以下に従って解決する【それらの駒の使用`主size$を確定する】：
◎
To resolve the flexible lengths of the items within a flex line:
</p>
<ol>
	<li>
%容器~size ~LET ~flex容器の内縁`主size$
◎
↓</li>
	<li>
%伸縮~mode ~LET ［
各 駒の外縁`仮の主size$の総和 ~LT %容器~size
ならば `伸長-^i ／
~ELSE_ `縮短-^i
］
⇒
以下における “駒の `~flex係数^i” は、 %伸縮~mode に応じて，次を表すとする
⇒＃
`伸長-^i ならば 駒の`~flex伸長-係数$ ／
`縮短-^i ならば 駒の`~flex縮短-係数$
◎
Determine the used flex factor. Sum the outer hypothetical main sizes of all items on the line. If the sum is less than the flex container’s inner main size, use the flex grow factor for the rest of this algorithm; otherwise, use the flex shrink factor.
</li>
	<li>
各~駒には
`~target主size@
があり，初期~時には`~flex基底~size$に設定されるとする。
◎
Each item in the flex line has a target main size, initially set to its flex base size.＼
</li>
	<li>
<p>
各~駒は、初期~時には `未~凍結-^i とする
— 駒は、以下のある時点で凍結されることになる。
◎
Each item is initially unfrozen and may become frozen.
</p>
<p class="note">注記：
凍結された駒の`~target主size$は、それ以降，変化しない。
◎
Note: An item’s target main size doesn’t change after freezing.
</p>
	</li>
	<li>
<p><strong>（
~flex不能な駒を~sizeする
）</strong>
◎
Size inflexible items.＼
</p>

<p>
~EACH( %駒 )
に対し：
◎
Freeze, setting its target main size to its hypothetical main size…
</p>
		<ol>
			<li>
~IF［
%駒 の`~flex係数^i ~NEQ 0
］
⇒
~CONTINUE
◎
any item that has a flex factor of zero
</li>
			<li>
~IF［
%伸縮~mode ~EQ `伸長-^i
］~AND［
%駒 の`~flex基底~size$ ~LTE %駒 の`仮の主size$
］
⇒
~CONTINUE
◎
if using the flex grow factor: any item that has a flex base size greater than its hypothetical main size
</li>
			<li>
~ELIF［
%伸縮~mode ~EQ `縮短-^i
］~AND［
%駒 の`~flex基底~size$ ~GTE %駒 の`仮の主size$
］
⇒
~CONTINUE
◎
if using the flex shrink factor: any item that has a flex base size smaller than its hypothetical main size
</li>
			<li>
%駒 の`~target主size$ ~SET `仮の主size$
◎
↑</li>
			<li>
%駒 を凍結する
◎
↑</li>
		</ol>
	</li>
	<li>
%初期~自由空間 ~LET %容器~size ~MINUS ( すべての駒の`~target主size$の総和 )
◎
Calculate initial free space. Sum the outer target main sizes of all items on the line, and subtract this from the flex container’s inner main size.
</li>
	<li>
<p>
~WHILE［
未~凍結-な駒はある
］：
◎
Loop:
◎
Check for flexible items. If all the flex items on the line are frozen, free space has been distributed; exit this loop.
</p>
		<ol>
			<li id="free-space">
%残りの自由空間 ~LET %容器~size ~MINUS ( すべての駒の`~target主size$の総和 )
◎
Calculate the remaining free space as for initial free space, above.＼
</li>
			<li>
%~flex係数の総和 ~LET 未~凍結-な すべての駒の `~flex係数^i の総和
◎
If the sum of the unfrozen flex items’ flex factors＼
</li>
			<li>
<p>
~IF［
%~flex係数の総和 ~LT 1
］：
</p>
				<ol>
					<li>
%上限 ~LET %初期~自由空間 ~MUL %~flex係数の総和
</li>
					<li>
~IF［
%残りの自由空間 の絶対値 ~GT %上限 の絶対値
］
⇒
%残りの自由空間 ~SET %上限
</li>
				</ol>
◎
is less than one, multiply the initial free space by this sum. If the magnitude of this value is less than the magnitude of the remaining free space, use this as the remaining free space.
</li>
			<li>
<p>
<strong>（
~flex係数に比例するように自由空間を配分する
）</strong>
◎
↓</p>

<p>
~IF［
%残りの自由空間 ~NEQ 0
］：
◎
If the remaining free space is non-zero, distribute it proportional to the flex factors:
</p>
				<ol>
					<li>
~IF［
%伸縮~mode ~EQ `伸長-^i
］
⇒
未~凍結-な
~EACH( %駒 )
に対し
⇒
%駒 の`~target主size$ ~SET
%駒 の`~flex基底~size$ ~PLUS (
%残りの自由空間 ~MUL (
( %駒 の `~flex係数^i ) ~DIV %~flex係数の総和
))
◎
If using the flex grow factor
◎
For every unfrozen item on the line, find the ratio of the item’s flex grow factor to the sum of the flex grow factors of all unfrozen items on the line. Set the item’s target main size to its flex base size plus a fraction of the remaining free space proportional to the ratio.
</li>
					<li>
<p>
~ELSE（ %伸縮~mode ~EQ `縮短-^i ）：
</p>

<p>
この段においては、各 駒は
`拡縮済み~flex縮短-係数@i
を持つ。
</p>

						<ol>
							<li>
未~凍結-な
~EACH( %駒 )
に対し
⇒
%駒 の `拡縮済み~flex縮短-係数^i ~SET ( %駒 の `~flex係数^i ) ~MUL ( %駒 の内縁`~flex基底~size$ )
</li>
							<li>
%係数の総和 ~LET
未~凍結-な すべての %駒 の `拡縮済み~flex縮短-係数^i の総和
</li>
							<li>
未~凍結-な
~EACH ( %駒 )
に対し
⇒
%駒 の`~target主size$ ~SET
( %駒 の`~flex基底~size$ ) ~MINUS (
( %残りの自由空間 の絶対値 ) ~MUL (
( %駒 の `拡縮済み~flex縮短-係数^i ) ~DIV %係数の総和
))
</li>
						</ol>

<p class="note">注記：
これにより、駒の内縁 `主size$は，一時的に負になり得るが，次の段で正される。
</p>

◎
If using the flex shrink factor
◎
For every unfrozen item on the line, multiply its flex shrink factor by its inner flex base size, and note this as its scaled flex shrink factor. Find the ratio of the item’s scaled flex shrink factor to the sum of the scaled flex shrink factors of all unfrozen items on the line. Set the item’s target main size to its flex base size minus a fraction of the absolute value of the remaining free space proportional to the ratio. Note this may result in a negative inner main size; it will be corrected in the next step.
</li>
				</ol>
			</li>
			<li>
<p><strong>（
最小-／最大-
違反を補正する
）</strong></p>

<p>
未~凍結-な
~EACH( %駒 )
に対し
⇒
%駒 の`~target主size$ ~SET %駒 の`~target主size$を %駒 の使用［
`最小-主size$, `最大-主size$
］で
— %駒 の内容~boxの~sizeは 0 以上に切上げるように —
切詰めた結果
</p>

<p>
これにより，`~target主size$が［
増えた駒は “最小-違反” ／ 減った駒は “最大-違反”
］とされる。
</p>

◎
Fix min/max violations. Clamp each non-frozen item’s target main size by its used min and max main sizes and floor its content-box size at zero. If the item’s target main size was made smaller by this, it’s a max violation. If the item’s target main size was made larger by this, it’s a min violation.
</li>
			<li>
<p><strong>（
~flexが効き過ぎている駒を凍結する
）</strong>
◎
Freeze over-flexed items.＼
</p>

<p>
未~凍結-な駒のうち，次に該当するものを凍結する
⇒
前~段による切詰め量の総和（減った量は負であるとみなす）に応じて
⇒＃
0 ならば すべて ／
正であるならば 最小-違反とされたもの ／
負であるならば 最大-違反とされたもの
◎
The total violation is the sum of the adjustments from the previous step ∑(clamped size - unclamped size). If the total violation is:
• Zero
•• Freeze all items.
• Positive
•• Freeze all the items with min violations.
• Negative
•• Freeze all the items with max violations.
</p>

<p class="note">注記：
これは 1 個以上の駒を凍結するので、~loopは進捗して最終的に終了する。
◎
Note: This freezes at least one item, ensuring that the loop makes progress and eventually terminates.
◎
• Return to the start of this loop.
</p>

			</li>
		</ol>
	</li>
	<li>
~EACH( %駒 )
に対し
⇒
%駒 の使用`主size$ ~SET %駒 の`~target主size$
◎
Set each item’s used main size to its target main size.
</li>
</ol>

		</section>
		<section id="definite-sizes">
<h3 title="Definite and Indefinite Sizes">9.8. 確定的な~sizeと不定な~size</h3>

<p>
`CSS-SIZING-3$r は，長さが［
<a href="~SIZING#definite">確定的</a> ／
<a href="~SIZING#indefinite">不定</a>
］であることを定義しているが、~flex~layout【！Flexbox】においては，長さが
`確定的@
と見なされ得る追加的な事例が いくつかある：
◎
Although CSS Sizing [CSS-SIZING-3] defines definite and indefinite lengths, Flexbox has several additional cases where a length can be considered definite:
</p>
<ol>
	<li>
`単-行f$な`~flex容器$の`交叉size$が確定的である場合、`伸張-$されているどの`~flex駒$についても，その外縁 `交叉size$は［
~flex容器の（`~flex駒$の［
最小-, 最大-
］`交叉size$に切詰められた）内縁 `交叉size$
］になり，`確定的$と見なされる。
◎
If a single-line flex container has a definite cross size, the outer cross size of any stretched flex items is the flex container’s inner cross size (clamped to the flex item’s min and max cross size) and is considered definite.
</li>
	<li>
`~flex容器$の`主size$は`確定的$である場合、`~flex駒$ %駒 の~flex後の`主size$は`確定的$と扱われる
— それが、同じ行f内にある他の~flex駒の`不定$な~sizeに依拠できるとしても。
◎
If the flex container has a definite main size, a flex item’s post-flexing main size is treated as definite, even though it can rely on the indefinite sizes of any flex items in the same line.
</li>
	<li>
`~flex行l$の`交叉size$が決定されたなら、［
自動-~sizeされた~flex容器
］内にある駒の`交叉size$は，~layoutの目的においては確定的と見なされる
— <a href="#algo-stretch">駒の交叉sizeを決定する段</a>
を見よ。
◎
Once the cross size of a flex line has been determined, the cross sizes of items in auto-sized flex containers are also considered definite for the purpose of layout; see step 11.
</li>
</ol>

<p class="note">注記：
次を満たす駒の~sizeは、定義により`確定的$になる
⇒
`全部的に~flex不能$である, かつ`~flex基底s$は確定的である
◎
Note: The main size of a fully inflexible item with a definite flex basis is, by definition, definite.
</p>

		</section>
		<section id="intrinsic-sizes">
<h3 title="Intrinsic Sizes">9.9. 内在的~size</h3>

<p>
`~flex容器$の`内在的~sizing$は、種々の型の 内容に基づく自動的~sizingの基になる
— `内容収納~行内~size$（内容収納（ `fit-content^en ）公式が利用される）や,
内容に基づく`塊~size$（`最大-内容~size$が利用される）など。
この算出にあたっては、~flex駒に対する `auto^v ~marginは `0^v として扱われる。
◎
The intrinsic sizing of a flex container is used to produce various types of content-based automatic sizing, such as shrink-to-fit logical widths (which use the fit-content formula) and content-based logical heights (which use the max-content size). For these computations, auto margins on flex items are treated as 0.
</p>

<p>
この節に現れる各種~用語については、`CSS-SIZING-3$r を見よ。
◎
See [CSS-SIZING-3] for a definition of the terms in this section.
</p>

			<section id="intrinsic-main-sizes">
<h4 title="Flex Container Intrinsic Main Sizes">9.9.1. ~flex容器の内在的~主size</h4>

<p>
`~flex容器$ %容器 の`主-軸$沿いの`最大-内容~size$は、［［
%容器 内の一連の`~flex駒$の`最大-内容 供与$fXを，駒の自前の~flex能に許容される限り保守する
］下で， %容器 が占め得る
］ような，最~小な~sizeであり、次に従って計算される：
◎
The max-content main size of a flex container is the smallest size the flex container can take while maintaining the max-content contributions of its flex items, insofar as allowed by the items’ own flexibility:
</p>

<ol>
	<li>
<p>
%容器 内の
~EACH( %駒 )
に対し：
</p>
		<ol>
			<li>
%~flex量 ~SET ( %駒 の`最大-内容 供与$fX ) ~MINUS ( %駒 の外縁`~flex基底~size$ )
</li>
			<li>
%駒 の `~flex係数^i ~LET ［
%~flex量 ~GTE 0 ならば `max^op( %駒 の `~flex伸長-係数$, 1 ) ／
~ELSE_ ［
%駒 の`~flex縮短-係数$を 1 以上に切り上げた下での【？】，
%駒 の`拡縮済み~flex縮短-係数$i
］
</li>
			<li>
%駒 の `最大-内容~flex割合分^i ~LET %~flex量 ~DIV %駒 の `~flex係数^i
</li>
		</ol>
◎
For each flex item, subtract its outer flex base size from its max-content contribution size. If that result is positive, divide by its flex grow factor floored at 1; if negative, divide by its scaled flex shrink factor having floored the flex shrink factor at 1. This is the item’s max-content flex fraction.
</li>
	<li>
%容器 内のすべての`~flex駒$を、長さ無限な行fたちの中に配置する
◎
Place all flex items into lines of infinite length.
</li>
	<li>
<p>
%容器 を成す
~EACH( 行f %行f )
に対し，
%行f の `~size^i を次に従って計算する：
◎
Within each line,＼
</p>
		<ol>
			<li>
%L ~LET %行f 内に~layoutされる`~flex駒$たちの集合
◎
↓</li>
			<li>
%最~大~flex割合分 ~LET `max^op( %駒 の `最大-内容~flex割合分^i ； %駒 ~IN %L )
◎
find the largest max-content flex fraction among all the flex items.＼
</li>
			<li>
<p>
%L 内の各~駒の `~size^i を次に従って計算する：
</p>
				<ol>
					<li>
%~size ~LET ( %駒 の `~flex係数^i ) ~MUL %最~大~flex割合分 ~PLUS ( %駒 の`~flex基底~size$ )
</li>
					<li>
%~size ~SET `min^op( %~size, ( %駒 の`最大-主size$ ) )
</li>
					<li>
%駒 の `~size^i ~LET `max^op( %~size, ( %駒 の`最小-主size$ ) )
</li>
				</ol>

◎
Add each item’s flex base size to the product of its flex grow factor (or scaled flex shrink factor, if the chosen max-content flex fraction was negative) and the chosen max-content flex fraction, then clamp that result by the max main size floored by the min main size.
</li>
			<li>
%行f の `~size^i ~LET ∑ %駒 の `~size^i  ； %駒 ~IN %L
◎
↓</li>
		</ol>
	</li>
	<li>
`~flex容器$ %容器 の`最大-内容~size$は、次で与えられる
⇒
`max^op( %行f の `~size^i ； %行f ~IN { %容器 を成す行fたち } )
◎
The flex container’s max-content size is the largest sum of the afore-calculated sizes of all items within a single line.
</li>
</ol>

<div class="p">
<p>
`~flex容器$ %容器 の`主-軸$沿いの`最小-内容~size$は：
</p>

<dl class="switch">
	<dt>%容器 は`単-行f$ならば：</dt>
	<dd>
［
`~flex駒$の`最小-内容 供与$fXが その`最大-内容 供与$fXに代わって利用される
］ことを除いて， %容器 の`主-軸$沿いの`最大-内容~size$と同じに計算される。
</dd>

	<dt>%容器 は`複-行f$ならば：</dt>
	<dd>
単に， %容器 内のすべての`~flex駒$による`最小-内容 供与$fXの最~大。
</dd>
</dl>

◎
The min-content main size of a single-line flex container is calculated identically to the max-content main size, except that the flex item’s min-content contribution is used instead of its max-content contribution. However, for a multi-line container, it is simply the largest min-content contribution of all the flex items in the flex container.
</div>

<details class="note">
<summary>注記：
~flexの総和 ~LT 1 のときにおける，この~algoの含意
◎
Implications of this algorithm when the sum of flex is less than 1
</summary>

<p>
上の~algoは、次の 2 つの事例に対し，正しい挙動を与えるよう設計されている
— 特に 2 つの合間で，`~flex容器$の~sizeが連続的に遷移するようにする：
◎
The above algorithm is designed to give the correct behavior for two cases in particular, and make the flex container’s size continuous as you transition between the two:
</p>

<ol>
	<li>
`~flex容器$を成す どの駒も~flex不能な場合、`~flex容器$はそれらの`~flex基底~size$の総和に~sizeされる。
（~flex不能な`~flex基底~size$は、基本的に［
`width$p ／ `height$p
］の代用になる
— それは，指定されていれば、塊~layoutにおいて，`最大-内容 供与$が基づくものを与える。）
◎
If all items are inflexible, the flex container is sized to the sum of their flex base size. (An inflexible flex base size basically substitutes for a width/height, which, when specified, is what a max-content contribution is based on in Block Layout.)
</li>
	<li>
すべての駒が［
~flex可能かつ `~flex係数$ ~GTE 1
］である場合、`~flex容器$は，それを成す駒たちの`最大-内容 供与$の総和に~sizeされる（あるいは、たぶん，少し大きい~sizeになる
— どの~flex駒も，その`最大-内容 供与$ `以上の~sizeになる^emようにしつつ、その~flex能により決定される~sizeの，他の駒の~sizeに対する比率が正しくなるように）。
◎
When all items are flexible with flex factors ≥ 1, the flex container is sized to the sum of the max-content contributions of its items (or perhaps a slightly larger size, so that every flex item is at least the size of its max-content contribution, but also has the correct ratio of its size to the size of the other items, as determined by its flexibility).
</li>
</ol>

<p>
例えば、`~flex容器$を成す`~flex駒$は 1 個だけで,
駒の `flex-basis$p は `100px^v で,
駒の最大-内容~sizeは `200px^v にあるとき、`~flex容器$（および~flex駒）の幅は，
駒の `flex-grow$p に応じて
⇒
`0^v ならば `100px^v になるが、
`1^v 以上ならば `200px^v になる。
◎
For example, if a flex container has a single flex item with flex-basis: 100px; but a max-content size of 200px, then when the item is flex-grow: 0, the flex container (and flex item) is 100px wide, but when the item is flex-grow: 1 or higher, the flex container (and flex item) is 200px wide.
</p>

<p>
これらの 2 つの事例
— 特に，ある行f上の駒たちの~flex能の総和が 0 〜 1 の範囲にあるとき —
の挙動の合間を総じて連続的にするアリな仕方は，いくつかあるが、どれも欠点がある。
ここでは，感じられる不良な含意ができるだけ少ないものを選んだが、あいにく［
~flex能の総和 ~LT 1
］のときに，~flex能を “二重に適用する” 。
上の例では、駒の `flex-grow$p が `.5^v の場合，`~flex容器$は `150px^v 幅になるが、駒は通常のように可用な空間の中に~sizeされ， `125px^v 幅になる。
◎
There are several possible ways to make the overall behavior continuous between these two cases, particularly when the sum of flexibilities on a line is between 0 and 1, but all of them have drawbacks. We chose one we feel has the least bad implications; unfortunately, it "double-applies" the flexibility when the sum of the flexibilities is less than 1. In the above example, if the item has flex-grow: .5, then the flex container ends up 150px wide, but the item then sizes normally into that available space, ending up 125px wide.
</p>
</details>

			</section>
			<section id="intrinsic-cross-sizes">
<h4 title="Flex Container Intrinsic Cross Sizes">9.9.2. ~flex容器の内在的~交叉size</h4>

<p >
`~flex容器$ %容器 の［
`交叉-軸$沿いの`最小-内容~size$
／
`交叉-軸$沿いの`最大-内容~size$
］（以下，同順）は、次で与えられる：
◎
↓</p>

<dl class="switch">
	<dt>%容器 は`単-行f$ならば：</dt>
	<dd>
%容器 の各`~flex駒$の［
`最小-内容 供与$ ／ `最大-内容 供与$
］の最~大。
◎
The min-content/max-content cross size of a single-line flex container is the largest min-content contribution/max-content contribution (respectively) of its flex items.
</dd>

	<dt>%容器 は`複-行f$ならば：</dt>
	<dd>
%容器 を`交叉-軸$~~方向の［
`最小-内容 拘束$ ／ `最大-内容 拘束$
］の下で~sizeした結果から得られる，すべての~flex行lの`交叉size$の総和。
◎
For a multi-line flex container, the min-content/max-content cross size is the sum of the flex line cross sizes resulting from sizing the flex container under a cross-axis min-content constraint/max-content constraint (respectively).＼
</dd>
	<dd>
<p>
ただし、 %容器 が `flex-flow$p:column_wrap にされている場合、
%容器 は次のように~sizeされる：
◎
However, if the flex container is flex-flow: column wrap;, then＼
</p>

		<ol>
			<li>
先ず、 %容器 内のすべての`~flex駒$にわたる`交叉-軸$の［
`最小-内容 供与$ ／ `最大-内容 供与$
］のうち，最~大のものを見出す。
◎
it’s sized by first finding the largest min-content/max-content cross-size contribution among the flex items (respectively), then＼
</li>
			<li>
前~段の結果の~sizeを，~layout時において［
各`~flex駒$に対し，`交叉-軸$の`可用な空間$
］に利用する。
◎
using that size as the available space in the cross axis for each of the flex items during layout.
</li>
		</ol>
	</dd>
	<dd class="note">
<p>注記：
この `column wrap^v にされた`~flex容器$用の経験則は、次をいずれも満たすような，`~flex容器$のあるべき~sizeに対する適度な近似を与えるが：
◎
Note: This heuristic for column wrap flex containers gives a reasonable approximation of the size that the flex container should be, with＼
</p>

		<ul>
			<li>
各~flex駒の結果の~sizeは
⇒
`min^op( ［
その駒の自前の最大-内容~size
］, ［
すべての駒の最小-内容~sizeのうちの最大
］ )
◎
each flex item ending up as min(item’s own max-content, maximum min-content among all items), and＼
</li>
			<li>
各`~flex行l$は、その中の最~大の`~flex駒$より大きくならない。
◎
each flex line no larger than its largest flex item.＼
</li>
		</ul>

<p>
が、一部の事例では，完璧に収まるもの`ではない^em。
完全に正しくやるのは，ひどく高価であり、これでも適度に働く。
◎
It’s not a perfect fit in some cases, but doing it completely correct is insanely expensive, and this works reasonably well.
</p>
	</dd>
</dl>

			</section>
			<section id="intrinsic-item-contributions">
<h4 title="Flex Item Intrinsic Size Contributions">9.9.3. ~flex駒の内在的~size供与</h4>

<div class="p">
<p>
`~flex駒$ %駒 の主sizeに対する［
`最小-内容 供与$／`最大-内容 供与$
］は、次に従って与えられる：
</p>

<ol>
	<li>
%~size ~LET ［
最小-…／最大-…
］に応じて， %駒 の`外縁^em［
`最小-内容~size$ ／ `最大-内容~size$
］
</li>
	<li>
%選好d~size ~LET %駒 の外縁`選好d~size$
</li>
	<li>
~IF［
%選好d~size は `~autoS$v でない
］
⇒
%~size ~SET `max^op( %~size, %選好d~size )
</li>
	<li>
~IF［
%駒 は伸長できない【すなわち，`~flex伸長-係数$ ~EQ 0 】
］
⇒
%~size ~SET `min^op( %~size, %駒 の`~flex基底~size$ )
</li>
	<li>
~IF［
%駒 は縮短できない【すなわち，`~flex縮短-係数$ ~EQ 0 】
］
⇒
%~size ~SET `max^op( %~size, %駒 の`~flex基底~size$ )
</li>
	<li>
~RET `max^op( `min^op( %~size, %駒 の`最大-主size$ ), %駒 の`最小-主size$ )
</li>
</ol>

◎
The main-size min-content contribution of a flex item is the larger of its outer min-content size and outer preferred size (its width/height as appropriate) if that is not auto, clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size.
◎
The main-size max-content contribution of a flex item is the larger of its outer max-content size and outer preferred size (its width/height as appropriate) clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size.
</div>

			</section>
		</section>
	</section>
	<section id="pagination">
<h2 title="Fragmenting Flex Layout">10. ~flex~layoutの断片化-法</h2>

<p>
~flex容器は、［
駒どうしの合間
］, あるいは［
（`複-行f$~mode下における）いくつかの駒からなる行fどうしの合間
］, あるいは［
駒の内側
］にて，何~pageかに渡って分断され得る。
各種 `break-*$p ~propは、通常の［
`塊~level$／`行内~level$
］の~boxに対するときと同様に，~flex容器にも適用される。
この節では、それらがどのように ~flex駒とその内容に適用されるかを定義する。
より詳しい文脈は `CSS3-BREAK$r を見よ。
◎
Flex containers can break across pages between items, between lines of items (in multi-line mode), and inside items. The break-* properties apply to flex containers as normal for block-level or inline-level boxes. This section defines how they apply to flex items and the contents of flex items. See the CSS Fragmentation Module for more context [CSS3-BREAK].
</p>

<p>
以下の分断処理~規則の下での， “~page” とは、`断片化~容器$を指す。
同じ規則は，他の`断片化~文脈$においても適用される（必要に応じて， “~page” を適切な`断片化~容器$の種別に読み替える）。
可読性のため、この節の用語
“~row”, “~col”
は、`~flex容器$ 自身のそれではなく，［
`断片化~文脈$の`塊~flow方向$
］に相対的な~flex容器の方位を指すとする。
【 “~col” が塊~flow方向】
◎
The following breaking rules refer to the fragmentation container as the “page”. The same rules apply in any other fragmentation context. (Substitute “page” with the appropriate fragmentation container type as needed.) For readability, in this section the terms "row" and "column" refer to the relative orientation of the flex container with respect to the block flow direction of the fragmentation context, rather than to that of the flex container itself.
</p>

<p>
~flex容器が断片化されるときの正確な~layoutは、この仕様のこの~levelでは定義されない。
しかしながら，~flex容器の内側における分断には、次の規則が課される（ `order$p により`改変された文書~順序$を利用して解釈する下で）：
◎
The exact layout of a fragmented flex container is not defined in this level of Flexible Box Layout. However, breaks inside a flex container are subject to the following rules (interpreted using order-modified document order):
</p>

<ul>
	<li>
<p>
~row~flex容器においては：
◎
In a row flex container,＼
</p>
		<ul>
			<li>
~flex駒~上の［
`break-before$p ／ `break-after$p
］値は，~flex行lに伝播する。
◎
the break-before and break-after values on flex items are propagated to the flex line.＼
</li>
			<li>
［
最初の行f上の `break-before$p 値 ／
最後の行f上の `break-after$p 値
］は、~flex容器に伝播する。
◎
The break-before values on the first line and the break-after values on the last line are propagated to the flex container.
</li>
		</ul>

<p class="note">注記：
分断の伝播は、`算出d値$には影響しない（ `text-decoration$p の伝播の様に）。
◎
Note: Break propagation (like text-decoration propagation) does not affect computed values.
</p>
	</li>
	<li>
<p>
~col~flex容器においては：
◎
In a column flex container,＼
</p>
		<ul>
			<li>
［
最初の駒~上の`break-before$p 値 ／
最後の駒~上の`break-after$p 値
］は、~flex容器に伝播する。
◎
the break-before values on the first item and the break-after values on the last item are propagated to the flex container.＼
</li>
			<li>
他の駒~上の強制d分断は、その駒~自身に適用される。
◎
Forced breaks on other items are applied to the item itself.
</li>
		</ul>
	</li>
	<li>
~flex駒の内側の強制d分断は、実質的に，その内容の~sizeを増大させる。
それは、他の同胞~駒の内側に強制d分断を誘発することはない。
◎
A forced break inside a flex item effectively increases the size of its contents; it does not trigger a forced break inside sibling items.
</li>
	<li>
<p>
~row~flex容器においては：
◎
In a row flex container,＼
</p>
		<ul>
			<li>
一連の同胞~flex行lの各~合間に，
`A類の分断~機会$が生じる。
◎
Class A break opportunities occur between sibling flex lines, and＼
</li>
			<li>
［［
最初／最後
］の~flex行l
］と［
~flex容器の内容~辺
］との合間に，
`C類の分断~機会$が生じる。
◎
Class C break opportunities occur between the first/last flex line and the flex container’s content edges.
</li>
		</ul>
	</li>
	<li>
<p>
~col~flex容器においては：
◎
In a column flex container,＼
</p>
		<ul>
			<li>
一連の同胞~flex駒の各~合間に，
`A類の分断~機会$が生じる。
◎
Class A break opportunities occur between sibling flex items, and＼
</li>
			<li>
［
行f上の［
最初／最後
］の~flex駒
］と［
~flex容器の内容~辺
］との合間に
`C類の分断~機会$が生じる。
◎
Class C break opportunities occur between the first/last flex items on a line and the flex container’s content edges. [CSS3-BREAK]
</li>
		</ul>
<p>
`CSS3-BREAK$r
</p>
	</li>
	<li>
~flex容器が分断の後にも継続されるとき、その`~flex駒$に`可用な空間$は（`断片化~文脈$の塊~flow方向においては），それまでの一連の~page上の一連の~flex容器~断片に費やされた空間により，節減される。
~flex容器~断片に費やされる空間が、当の~page上のその内容~boxの~sizeになる。
この可用な空間の調整の結果が負になった場合、それは 0 に設定される。
◎
When a flex container is continued after a break, the space available to its flex items (in the block flow direction of the fragmentation context) is reduced by the space consumed by flex container fragments on previous pages. The space consumed by a flex container fragment is the size of its content box on that page. If as a result of this adjustment the available space becomes negative, it is set to zero.
</li>
	<li>
~flex容器の最初の断片が~pageの上端に来ない, かつ
~page上の残りの空間に収まる~flex駒はない場合、その断片~全体が次の~pageへ移動される。
◎
If the first fragment of the flex container is not at the top of the page, and none of its flex items fit in the remaining space on the page, the entire fragment is moved to the next page.
</li>
	<li>
`複-行f$な~col~flex容器が分断されるときは、［
`複柱~容器$を成す各~断片が自前の［
一連の~col~boxからなる~row
］を持つ
］のと同じ様に，各~断片が自前の［
一連の~flex行lからなる， “堆積”
］を持つ。
◎
When a multi-line column flex container breaks, each fragment has its own "stack" of flex lines, just like each fragment of a multi-column container has its own row of column boxes.
</li>
	<li>
以上により課される，一連の駒の配置替えとは別に、~UAは，~flowの断片化による~flex容器の歪みを最小限にするよう試みるべきである。
◎
Aside from the rearrangement of items imposed by the previous point, UAs should attempt to minimize distortion of the flex container with respect to unfragmented flow.
</li>
</ul>

		<section id="pagination-algo">
<h3 title="Sample Flex Fragmentation Algorithm">10.1. ~flex断片化~algoの見本</h3>

<p>
この参考節では、~flex容器の断片化~algoとしてアリなものを示す。
実装者には，この~algoを改良して
CSS Working Group まで
<a href="#feedback">~feedbackを寄せられる</a>
よう願う。
◎
This informative section presents a possible fragmentation algorithm for flex containers. Implementors are encouraged to improve on this algorithm and provide feedback to the CSS Working Group.
</p>

<div class="example">

<p class="note">注記：
この~algoは、~page割りが常に順方向に進む（後戻りしない）ものと見做している。
したがって、~page割りに~~先行する整列は，ほぼ無視される。
より高度な~layout~engineは、複数の断片に渡る整列も加味し得る。
◎
This algorithm assumes that pagination always proceeds only in the forward direction; therefore, in the algorithms below, alignment is mostly ignored prior to pagination. Advanced layout engines may be able to honor alignment across fragments.
</p>

<dl>
	<dt>`単-行f$な~col~flex容器</dt>
	<dd>
		<ol>
			<li>
~flex~layout~algoを，`交叉sizeの決定$の所まで走らす（~page割りは~~考慮せずに）
◎
Run the flex layout algorithm (without regards to pagination) through Cross Sizing Determination.
</li>
			<li>
アリな限り多くの（ただし， 1 個以上, またはその断片の）連続する［
~flex駒 または駒~断片
］を、最初から順に，~page上の部屋が尽きるか, または強制d分断に遭遇するまで，~lay-outする
◎
Lay out as many consecutive flex items or item fragments as possible (but at least one or a fragment thereof), starting from the first, until there is no more room on the page or a forced break is encountered.
</li>
			<li>
<p>
~IF［
前~段により部屋が尽きた
］~AND［
自由空間は正である
］
⇒
~UAは，次の分断-不能な［
駒／断片
］用の部屋を作るために，この~page上に配分される自由空間を節減してもヨイ（負にならない所まで）。
◎
If the previous step ran out of room and the free space is positive, the UA may reduce the distributed free space on this page (down to, but not past, zero) in order to make room for the next unbreakable flex item or fragment.＼
</p>

<p>
~ELSE
⇒
収まり切らない［
駒／断片
］は，次の~pageに押出される。
~UAは，
50% より多くの断片が残りの空間に収まる場合は引き上げ,
そうでなければ押出すべきである。
◎
Otherwise, the item or fragment that does not fit is pushed to the next page. The UA should pull up if more than 50% of the fragment would have fit in the remaining space and should push otherwise.
</p>
			</li>
			<li>
~IF［
これまでの手続きで~lay-outされなかった［
駒／断片
］が在る
］
⇒
~flex~layout~algoの，`行f~sizeの決定$から`交叉sizeの決定$までの部分を、次の~pageの~sizeの下に, （すでに~lay-outされたものも含めた）内容 `すべて^emにより再び走らせた上で、まだ~lay-outされていない最初の［
駒／断片
］から開始する下で，前~段へ戻る。
◎
If there are any flex items or fragments not laid out by the previous steps, rerun the flex layout algorithm from Line Length Determination through Cross Sizing Determination with the next page’s size and all the contents (including those already laid out), and return to the previous step, but starting from the first item or fragment not already laid out.
</li>
			<li>
~flex容器~内の各~断片に対し、~flex~layout~algoの，`主-軸の整列$から その最後までの部分を継続する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Main-Axis Alignment to its finish.
</li>
		</ol>

<p class="note">注記：
この~algoでは意図的に、~col方向かつ`単-行f$な~flex容器が，塊~flowとごく似る様に~page割りしている。
その意図の~~元は、［
`justify-content$p:start にされ, かつ ~flex可能な駒を伴わない
］ような~flex容器による~page割りと，［
その~flex容器と同じ［
内容, 使用~size, 使用~margin
］を伴う，`~flow内$の子
］を持つような塊による~page割りが，一致するべきである所に由来する。
◎
It is the intent of this algorithm that column-direction single-line flex containers paginate very similarly to block flow. As a test of the intent, a flex container with justify-content:start and no flexible items should paginate identically to a block with in-flow children with same content, same used size and same used margins.
</p>
	</dd>

	<dt>`複-行f$な~col~flex容器</dt>
	<dd>
		<ol>
			<li>
~page割りを~~考慮した`上で^em（~flex容器の最大~行f長さを~page上に残された空間に制限した下で）、~flex~layout~algoの，`交叉sizeの決定$の所までを走らす。
◎
Run the flex layout algorithm with regards to pagination (limiting the flex container’s maximum line length to the space left on the page) through Cross Sizing Determination.
</li>
			<li>
<p>
アリな限り多く（ただし， 1 本以上）の~flex行lを、交叉-次元にて~flex容器の部屋が尽きるか, または 強制d分断に遭遇するまで，~lay-outする：
◎
Lay out as many flex lines as possible (but at least one) until there is no more room in the flex container in the cross dimension or a forced break is encountered:
</p>
				<ol>
					<li>
アリな限り多く（ただし， 1 つ以上）の連続する~flex駒を、最初のものから順に，~page上の部屋が尽きるか, または 強制d分断に遭遇するまで，~lay-outする。
ただし，~flex駒の`中の^em強制d分断は無視する。
◎
Lay out as many consecutive flex items as possible (but at least one), starting from the first, until there is no more room on the page or a forced break is encountered. Forced breaks within flex items are ignored.
</li>
					<li>
~IF［
これが最初の~flex容器~断片である
］~AND［
この行fは ~page上に残された空間より大きい単独の~flex駒のみを包含する
］~AND［
この~flex容器はすでに~page先頭に来ているのではない
］
⇒
その~flex容器を次の~pageに移動した上で，~flex容器~layout全体を再開始する
◎
If this is the first flex container fragment, this line contains only a single flex item that is larger than the space left on the page, and the flex container is not at the top of the page already, move the flex container to the next page and restart flex container layout entirely.
</li>
					<li>
~IF［
最初の段にて~lay-outされていない~flex駒がある
］
⇒
~flex~layout~algoの，`主sizeの決定$から`交叉sizeの決定$までの部分を、前の行f上に~lay-outされていない駒のみを利用して，再び走らせた上で、まだ~lay-outされていない最初の駒から開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the first step, rerun the flex layout algorithm from Main Sizing Determination through Cross Sizing Determination using only the items not laid out on a previous line, and return to the previous step, starting from the first item not already laid out.
</li>
				</ol>
			</li>
			<li>
~IF［
前~段で~lay-outされていない~flex駒が在る
］
⇒
次の~pageの~size, および まだ~lay-outされていない駒のみを利用して
~flex~layout~algoの
`行f~sizeの決定$から`交叉sizeの決定$までの部分を再び走らせた上で、まだ~lay-outされていない最初の駒から開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the previous step, rerun the flex layout algorithm from Line Sizing Determination through Cross Sizing Determination with the next page’s size and only the items not already laid out, and return to the previous step, but starting from the first item not already laid out.
</li>
			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`主-軸の整列$から その最後までの部分を継続する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Main-Axis Alignment to its finish.
</li>
</ol>

<p class="note">注記：
単独の~page上に~flex駒の全体が収まり切らない場合、
`複-行f$な~col~flex容器の中に~page割りされる`ことはない^em。
◎
If a flex item does not entirely fit on a single page, it will not be paginated in multi-line column flex containers.
</p>
	</dd>

	<dt>`単-行f$な~row~flex容器</dt>
	<dd>
		<ol>
			<li>
［
`flex-start$v:ais, `baseline$v:ais
］以外のどの `align-self$p 値も `flex-start$v:ais として扱う下で、~flex~layout~algo全体を（~page割りは~~考慮せずに）走らす。
◎
Run the entire flex layout algorithm (without regards to pagination), except treat any align-self other than flex-start or baseline as flex-start.
</li>
			<li>
~IF［
分断-不能な駒が~page上に残された空間に収まり切らない
］~AND［
この~flex容器が~page先頭に来てはいない
］
⇒
その~flex容器を次の~pageへ移動した上で，~flex容器~layout全体を再開始する。
◎
If an unbreakable item doesn’t fit within the space left on the page, and the flex container is not at the top of the page, move the flex container to the next page and restart flex container layout entirely.
</li>
			<li>
<p>
各~駒に対し、その内容を~page上に残された空間に収まる限り，~lay-outする。
残りの内容を次の~page上に断片化する
—
`すべての^em内容（前の~page上で完了した駒も含む）を利用して，新たな~page~sizeの下で，~flex~layout~algoの，`行f~sizeの決定$から`主-軸の整列$までの部分を再び走らせた上で。
◎
For each item, lay out as much of its contents as will fit in the space left on the page, and fragment the remaining content onto the next page, rerunning the flex layout algorithm from Line Length Determination through Main-Axis Alignment into the new page size using all the contents (including items completed on previous pages).
</p>

<p class="note">注記：
それまでの断片たちの中に全体が収まる~flex駒は、依然として，後方の断片たちにおける主-軸の空間を占める。
◎
Any flex items that fit entirely into previous fragments still take up space in the main axis in later fragments.
</li>
			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`交叉-軸の整列$から 最後までの部分を再び走らす。
最初のもの以外のすべての断片に対し
⇒
すべての駒~断片と行fに対し，［
`align-self$p, `align-content$p
］は `flex-start$v:ais として扱う
◎
For each fragment of the flex container, rerun the flex layout algorithm from Cross-Axis Alignment to its finish. For all fragments besides the first, treat align-self and align-content as being flex-start for all item fragments and lines.
</li>
			<li>
~IF［
駒を、その元の `align-self$p 値に則って［［
すべての~flex容器~断片
］の`交叉size$の合計
］の中で整列させたとするときに，［
単独の~flex容器~断片~内に全体が収まる
］ことになる
］
⇒
その駒を，その断片の中に~~移動して, 適切に整列してヨイ。
◎
If any item, when aligned according to its original align-self value into the combined cross size of all the flex container fragments, would fit entirely within a single flex container fragment, it may be shifted into that fragment and aligned appropriately.
</li>
		</ol>
	</dd>

	<dt>`複-行f$な~row~flex容器</dt>
	<dd>
		<ol>
			<li>
~flex~layout~algoの，`交叉sizeの決定$の所までを（~page割りは~~考慮せずに）走らす。
◎
Run the flex layout algorithm (without regards to pagination), through Cross Sizing Determination.
</li>
			<li>
<p>
アリな限り多く（ただし， 1 本以上）の~flex行lを，
最初から順に，~page上の部屋が尽きるか, または 強制d分断に遭遇するまで，~lay-outする。
◎
Lay out as many flex lines as possible (but at least one), starting from the first, until there is no more room on the page or a forced break is encountered.
</p>

<p>
~IF［
行fは［
~pageに収まり切らない
］~AND［
~page先頭に来てはいない
］］
⇒
行fを次の~pageに移動させた上で、それらの駒のみを利用して，この行fに後続するように
~flex~layout~algo全体を再開始する。
◎
If a line doesn’t fit on the page, and the line is not at the top of the page, move the line to the next page and restart the flex layout algorithm entirely, using only the items in and following this line.
</p>

<p>
~IF［
~flex駒それ自身が強制d分断を生じさせている
］
⇒
この行fと後続の行f上の駒のみを利用して, ［
`行f分断処理~段$において自動的な分断により新たな行fを開始させた駒
］は利用せずに、
~flex~layout~algoの，`主sizeの決定$から`主-軸の整列$までの部分を再び走らせた上で，この段を継続する。
~flex駒 `内の^em強制d分断は無視される。
◎
If a flex item itself causes a forced break, rerun the flex layout algorithm from Main Sizing Determination through Main-Axis Alignment, using only the items on this and following lines, but with the item causing the break automatically starting a new line in the line breaking step, then continue with this step. Forced breaks within flex items are ignored.
</li>
			<li>
~IF［
前~段により~lay-outされなかった~flex駒がある
］
⇒
次の~pageの~sizeおよび
まだ~lay-outされていない駒のみを利用して、~flex~layout~algoの，`行f~sizeの決定$から`主-軸の整列$までの部分を再び走らせた上で，まだ~lay-outされていない最初の行fから開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the previous step, rerun the flex layout algorithm from Line Length Determination through Main-Axis Alignment with the next page’s size and only the items not already laid out. Return to the previous step, but starting from the first line not already laid out.
</li>
			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`交叉-軸の整列$から その最後までの部分を継続する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Cross Axis Alignment to its finish.
</li>
		</ol>
	</dd>
</dl>
</div>

		</section>
	</section>
	<section id="axis-mapping">
<h2 title="Appendix A: Axis Mappings">付録 A. 各~軸の対応関係</h2>

~INFORMATIVE

<p>
以下に現れる `(no)wrap^v は、［
`wrap$v:fw または `nowrap$v:fw
］の略記である。
</p>

<div style="overflow: auto;">

<table class="matrix axis-mapping" id="axis-mapping-table-en">
<caption>
［
`ltr$v + `horizontal-tb$v
］`書字mode$（例： 英語）における各~軸の対応関係
◎
Axis Mappings for ltr + horizontal-tbWriting Mode (e.g. English)
</caption>

<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
<th>`主-軸$
<th>`始端$
<th>`終端$
<th>`交叉-軸$
<th>`始端$
<th>`終端$
</thead>

<tbody><tr><th>`row$v:fd + `(no)wrap^v
<td rowspan="4">横方向
<td>左端
<td>右端
<td rowspan="4">縦方向
<td rowspan="2">上端
<td rowspan="2">下端

<tr><th>`row-reverse$v:fd + `(no)wrap^v
<td>右端
<td>左端

<tr><th>`row$v:fd + `wrap-reverse$v:fw
<td>左端
<td>右端
<td rowspan="2">下端
<td rowspan="2">上端

<tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
<td>右端
<td>左端

<tr><th>`column$v:fd + `(no)wrap^v
<td rowspan="4">縦方向
<td>上端
<td>下端
<td rowspan="4">横方向
<td rowspan="2">左端
<td rowspan="2">右端

<tr><th>`column-reverse$v:fd + `(no)wrap^v
<td>下端
<td>上端

<tr><th>`column$v:fd + `wrap-reverse$v:fw
<td>上端
<td>下端
<td rowspan="2">右端
<td rowspan="2">左端

<tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
<td>下端
<td>上端
</tbody></table>

<table class="matrix axis-mapping" id="axis-mapping-table-fa">
<caption>
［
`rtl$v + `horizontal-tb$v 
］`書字mode$（例： ~Farsi）における各~軸の対応関係
◎
Axis Mappings for rtl + horizontal-tbWriting Mode (e.g. Farsi)
</caption>
<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
<th>`主-軸$
<th>`主-始端$
<th>`主-終端$
<th>`交叉-軸$
<th>`交叉-始端$
<th>`交叉-終端$
</thead>

<tbody><tr><th>`row$v:fd + `(no)wrap^v
<td rowspan="4">横方向
<td>右端
<td>左端
<td rowspan="4">縦方向
<td rowspan="2">上端
<td rowspan="2">下端

<tr><th>`row-reverse$v:fd + `(no)wrap^v
<td>左端
<td>右端

<tr><th>`row$v:fd + `wrap-reverse$v:fw
<td>右端
<td>左端
<td rowspan="2">下端
<td rowspan="2">上端

<tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
<td>左端
<td>右端

<tr><th>`column$v:fd + `(no)wrap^v
<td rowspan="4">縦方向
<td>上端
<td>下端
<td rowspan="4">横方向
<td rowspan="2">右端
<td rowspan="2">左端

<tr><th>`column-reverse$v:fd + `(no)wrap^v
<td>下端
<td>上端

<tr><th>`column$v:fd + `wrap-reverse$v:fw
<td>上端
<td>下端
<td rowspan="2">左端
<td rowspan="2">右端

<tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
<td>下端
<td>上端
</tbody></table>

<table class="matrix axis-mapping" id="axis-mapping-table-ja">
<caption>
［
`ltr$v + `vertical-rl$v
］`書字mode$（例： 日本語）における各~軸の対応関係
◎
Axis Mappings for ltr + vertical-rlWriting Mode (e.g. Japanese)
</caption>
<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
<th>`主-軸$
<th>`始端$
<th>`終端$
<th>`交叉-軸$
<th>`始端$
<th>`終端$
</thead>

<tbody><tr><th>`row$v:fd + `(no)wrap^v
<td rowspan="4">縦方向
<td>上端
<td>下端
<td rowspan="4">横方向
<td rowspan="2">右端
<td rowspan="2">左端

<tr><th>`row-reverse$v:fd + `(no)wrap^v
<td>下端
<td>上端

<tr><th>`row$v:fd + `wrap-reverse$v:fw
<td>上端
<td>下端
<td rowspan="2">左端
<td rowspan="2">右端

<tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
<td>下端
<td>上端

<tr><th>`column$v:fd + `(no)wrap^v
<td rowspan="4">縦方向
<td>右端
<td>左端
<td rowspan="4">横方向
<td rowspan="2">上端
<td rowspan="2">下端

<tr><th>`column-reverse$v:fd + `(no)wrap^v
<td>左端
<td>右端

<tr><th>`column$v:fd + `wrap-reverse$v:fw
<td>右端
<td>左端
<td rowspan="2">下端
<td rowspan="2">上端

<tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
<td>左端
<td>右端
</tbody></table>

</div>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの~feedbackと貢献に謝意を：
◎
Thanks for feedback and contributions to
</p>

<p lang="en-x-a0">
Erik Anderson,
Christian Biesinger,
Tony Chang,
Phil Cupp,
Arron Eicholz,
James Elmore,
Andrew Fedoniouk,
Brian Heuston,
Shinichiro Hamaji,
Daniel Holbert,
Ben Horst,
John Jansen,
Brad Kemper,
Kang-hao Lu,
Markus Mielke,
Peter Moulder,
Robert O’Callahan,
Christoph Päper,
Ning Rogers,
Peter Salas,
Elliott Sprehn,
Morten Stenshorne,
Christian Stockwell,
Ojan Vafai,
Eugene Veselov,
Greg Whitworth,
Boris Zbarsky.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p class="trans-note">【
この節の内容は未訳。
】</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacyと~security上の考慮点</h2>

<p>
この仕様【！Flexbox】により、新たな~privacy漏洩や,［
“正しく実装すること” を超えるような~security上の考慮点
］が導入されることはない。
◎
Flexbox introduces no new privacy leaks, or security considerations beyond "implement it correctly".
</p>
	</section>
</main></div>
