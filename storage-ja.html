<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Storage （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}


let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2019-02-14
trans_update:2019-02-15
source_checked:170112
spec_status:LS
original_url:https://storage.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:storage
copyright:2019,whatwg
trans_1st_pub:2017-02-15


●●class_map
E:error

●●tag_map
I:code
m:code
E:code
c:code

●●original_id_map

●●words_table1



PERMISSIONS:webappsec-permissions-ja.html
	https://w3c.github.io/permissions/


●●link_map


Exposed:~WEBIDL#Exposed
SameObject:~WEBIDL#SameObject
SecureContext:~WEBIDL#SecureContext
NoInterfaceObject:~WEBIDL#NoInterfaceObject

boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

I.Navigator:~WAPI#navigator
I.NavigatorStorage:#navigatorstorage
I.StorageEstimate:#dictdef-storageestimate
I.StorageManager:#storagemanager
I.WorkerNavigator:~WORKERS#workernavigator

E.TypeError:~WEBIDL#exceptiondef-typeerror

m.estimate:#dom-storagemanager-estimate
m.persist:#dom-storagemanager-persist
m.persisted:#dom-storagemanager-persisted
m.quota:#dom-storageestimate-quota
m.storage:#dom-navigatorstorage-storage
m.usage:#dom-storageestimate-usage

l.granted:~PERMISSIONS#dom-permissionstate-granted
l.persistent-storage:#dom-permissionname-persistent-storage

~bucket:#bucket
~mode:#bucket-mode
許可:#persistence
持続的:#persistent-bucket
持続的~bucket:#persistent-bucket
持続的でない:#non-persistent-bucket
持続的でない~bucket:#non-persistent-bucket
~schemeなし生成元~群:#schemeless-origin-group
~site~storage~quota:#site-storage-quota
~site~storage単位:#site-storage-unit
~site~storage使用量:#site-storage-usage
~site~storage:#site-storage

~taskを~queueする:~WAPI#queue-a-task
環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
関連な設定群~obj:~WAPI#relevant-settings-object

成分組~生成元:~ORIGIN#concept-origin-tuple
~host:~ORIGIN#concept-origin-host
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元:~ORIGIN#concept-origin

url.~domain:~URL1#concept-domain
並列的:~HTMLINFRA#in-parallel
許可~revocation~algo:~PERMISSIONS#permission-revocation-algorithm
許可~状態:~PERMISSIONS#permission-state
強力な特能:~PERMISSIONS#powerful-feature
利用する許可を要請-:~PERMISSIONS#request-permission-to-use

登録-可能~domain:https://publicsuffix.org/list/


●●words_table



	●仕様
統括-:consolidate:~
不便さ:inconvenience:~
	不便さ:inconveniencing
保守的:conservative:~
分離-:separate:~
問い:question:~
回答:answer:~
成長-:grow:~
抑える:reduceする:~
指標:indication:~
最終的:eventual:~
末端利用者:end user:~:::エンドユーザ
介入-:intervene:~
同意:consent:~
低level:low-level:低 level::低レベル
瑕疵:fault:~
想定-:suppose:~
尺度:scale:~
多様さ:diversity:~
介在:involvement:~

	主に関わる:primarily concerns
	ごく稀な:extremely rare
	生じるものとみなす必要がある:the unexpected does occur.
	何年かにわたりOver the years
	に利する:on behalf of
	特にparticularly
	もたらす:bring
	享受:enjoy
	不必要に:unannounced
	もう少し込み入った:slightly more involved
	ためのもの:equip
	既定のものになる:defaulted
	はっきりしなくなる:obscure
	ある程度の余裕:some wiggle room
	ある程度まで to some extent
	とされた:marked
	見分ける:differentiate
	気づいた:notice
	駆使:use
	書ける:can be written
	転化-:turn into
	頻用される:popular
	頻用度:popularity

	●storage
Storage:
bucket::::バケット
quota::::クォータ
storage::::ストレージ
clear::::クリア
空き:space::~
不可分:atomic::~
使用量:usage::~
持続性:persistence::~
持続ed:persisted::持続？
持続的:persistent::~
見積もり:estimate::~
量:amount:~
	byte数:amount of bytes 

重複集約:deduplication:重複の集約
圧縮:compression:~

単位:unit::~
復活-:revive:~
喪失-:lost:~
	get lost
使果たす:run outする:使い果たす
頻度:frequency:~
bookmark::::ブックマーク
近過去度:recency:~

	●network／navi
TLS:
offline::::オフライン
password::::パスワード
username::::ユーザ名
service-worker:service worker
群:group::~::グループ
証明書:certificate:~
認証:authentication:~
成分組:tuple::~

	●未分類
revocation::取り消し
alert:
自動生成-:autogenerate:~
chunk::::チャンク
dialog::::ダイアログ
地理情報:geolocation:~

	time
	十分な:sufficient
	%設定群~obj:settingsObject
	総計:total
	同時に:simultaneous
	同時期:around the same time
	少なく:less than
	ある:left
	からなる:consists of
	より大きい:larger

	●指示語
	1 個の:one
	何らかの:of some kind
	何種類かの:various kinds of
	まるごと:in its entirety
	ほとんどは:mostly
	重ねて:twice
	およその:rough
	何:how much
	何らかの類の:some kind of


●●ref_normative
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PERMISSIONS]
    Mounir Lamouri; Marcos Caceres; Jeffrey Yasskin. Permissions. URL: https://w3c.github.io/permissions/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">Storage Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/storage">GitHub whatwg/storage</a> (<a href="https://github.com/whatwg/storage/issues/new">new issue</a>, <a href="https://github.com/whatwg/storage/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/storage/commits
	<a href="https://storage.spec.whatwg.org/commit-snapshots/397ef13c3a76cb6660183bc1a29ae9b6f674220c/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/storagestandard">@storagestandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/storage">web-platform-tests storage/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/storage">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>

<a href="https://whatwg.org/"><img style="float: right;" alt="WHATWG" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPHBhdGggZD0iTTAsMEwyMCwwTDIwLDMwTDgwLDMwTDgwLDBMOTAsMEwxMDAsMTBMMTAwLDEwMEw5MCwxMDBMOTAsNDVMMTAsNDVMMTAsOTBMOTAsOTBMOTAsMTAwTDAsMTAwIiBmaWxsPSIjM2M3OTBhIi8+CjxyZWN0IHdpZHRoPSIxNSIgaGVpZ2h0PSIyNSIgeD0iNTcuNSIgeT0iMi41IiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo=" height="100"></a>

	<hgroup>
<h1 id="title">Storage</h1>
   </hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
~Storage標準は、持続的~storageと~quota見積もり用の~API, および
~platform~storage~architectureを定義する。
◎
The Storage Standard defines an API for persistent storage and quota estimates, as well as the platform storage architecture.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~webは、何年かにわたり~storage用に利用できる様々な~APIを成長させてきた
— 例えば
IndexedDB, `localStorage^c, `showNotification()^c
。
~Storage標準は、次を定義することにより，これらの~APIを統括する：
◎
Over the years the web has grown various APIs that can be used for storage, e.g., IndexedDB, localStorage, and showNotification(). The Storage Standard consolidates these APIs by defining:
</p>

<ul>
	<li>
これらの~APIが~dataを格納するための~primitiveとなる，~bucket。
◎
A bucket, the primitive these APIs store their data in
</li>
	<li>
その~bucketを持続的にする仕方。
◎
A way of making that bucket persistent
</li>
	<li>
与えられた`生成元$に対する使用量と~quota見積もりを取得する仕方。
◎
A way of getting usage and quota estimates for an origin
</li>
</ul>

<p>
伝統的に，これらの~APIにより格納された~dataは、機器~storageの空きを利用者が使果たすに伴い，利用者が介入できることなく喪失されていた。
が、持続的~bucketは，利用者の同意なくしては~clearできない。
したがってこれは、利用者が~webに~nativeな~platformで享受した~dataの保証をもたらす。
◎
Traditionally, as the user runs out of storage space on their device, the data stored with these APIs gets lost without the user being able to intervene. However, persistent buckets cannot be cleared without consent by the user. This thus brings data guarantees users have enjoyed on native platforms to the web.
</p>

<div class="example">
<p>
~storageを持続的にする単純な仕方は、
`persist()$m ~methodを呼出すことである。
それは同時に，末端利用者に許可を要請して、是認されれば，~storageを持続的になるよう変更する：
◎
A simple way to make storage persistent is through invoking the persist() method. It simultaneously requests the end user for permission and changes the storage to be persistent once granted:
</p>

<pre>
navigator.storage.persist().then(%persisted =&gt; {
  if(%persisted) {
    /* … */
  }
})
</pre>

<p>
~UAにより駆動される~dialogを 末端利用者に不必要に示さない，もう少し込み入った~codeも書ける：
◎
To not show user-agent-driven dialogs to the end user unannounced slightly more involved code can be written:
</p>


<pre>
Promise.all([
  navigator.storage.persisted(),
  navigator.permissions.query({name: "persistent-storage"})
]).then(([%persisted, %permission]) =&gt; {
  if(!%persisted &amp;&amp; %permission.status == "granted") {
    navigator.storage.persist().then( /* … */ )
  } else if(!%persistent &amp;&amp; %permission.status == "prompt") {
    showPersistentStorageExplanation()
  }
})
</pre>


<p>
`estimate()$m ~methodを利用すれば，~appが格納する内容に十分な空きがあるかどうかも決定できる：
◎
The estimate() method can be used to determine whether there is enough space left to store content for an application:
</p>


<pre>function retrieveNextChunk(%nextChunkInfo) {
  return navigator.storage.estimate().then(%info =&gt; {
    if(%info.quota - %info.usage &gt; %nextChunkInfo.size)
      return fetch(%nextChunkInfo.url)
    else throw new Error("次の~chunkを格納するための空きが足りません")
  }).then( /* … */ )
}
</pre>
<!-- "insufficient space to store next chunk"  -->

</div>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>


<p>
この仕様は、  Infra 標準 `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>


<p>
この仕様は、次に挙げる各種~標準による各種用語を利用する：
DOM, HTML, IDL, Permissions API, URL
`DOM$r
`HTML$r
`WEBIDL$r
`PERMISSIONS$r
`URL$r
◎
This specification uses terminology from the DOM, HTML, IDL, Permissions API, and URL Standards. [DOM] [HTML] [WEBIDL] [PERMISSIONS] [URL]
</p>


<p>
`~schemeなし生成元~群@
は、次のいずれかとして与えられる：
◎
A schemeless origin group is a group of one of the following:
</p>

<ul>
	<li>
互いに一致する`不透明な生成元$たち。
◎
Identical opaque origins.
</li>
	<li>
それぞれの`~host$が［
`~domain$urlでない, かつ
互いに一致する
］ような`成分組~生成元$たち。
◎
Tuple origins whose host is identical and not a domain.
</li>
	<li>
それぞれの`~host$が［
`~domain$urlである, かつ
`登録-可能~domain$である, かつ
互いに一致する
］ような`成分組~生成元$たち。
◎
Tuple origins whose host is a domain of which the registrable domain is identical.
</li>

</ul>


<p class="note">注記：
この定義は、最終的にはより相応しい箇所に移動されることになる。
◎
This definition will move to a more suitable location eventually.
</p>

	</section>
	<section id="infrastructure">
<h2 title="Infrastructure">3. 基盤</h2>


<p>
~UAは、次に挙げるような何種類かの~storageを備える：
◎
A user agent has various kinds of storage:
</p>

<dl>
	<dt>資格証~storage</dt>
	<dd>
末端利用者の資格証からなる
— ~HTML~formを通して提出された~usernameや~passwordなど。
◎
End-user credentials, such as username and passwords submitted through HTML forms
</dd>
	<dt>許可~storage</dt>
	<dd>
様々な特能
— 地理情報など —
に対する許可からなる。
◎
Permissions for various features, such as geolocation
</dd>

	<dt>~network~storage</dt>
	<dd>
次に挙げるもの, 等々からなる：
~HTTP~cache,
~cookie,
認証~entry,
~TLS~client証明書
◎
HTTP cache, cookies, authentication entries, TLS client certificates
</dd>

	<dt>~site~storage</dt>
	<dd>
次に挙げるもの, 等々からなる：
Indexed DB,
Cache API,
~service-worker登録,
`localStorage^m,
`history.pushState()^m,
~app~cache,
通知
◎
Indexed DB, Cache API, service worker registrations, localStorage, history.pushState(), application caches, notifications, etc.
</dd>
</dl>

<p>
この仕様が主に関わるのは、
`~site~storage@
である。
◎
This specification primarily concerns itself with site storage.
</p>

<p>
各`~site~storage$は、 0 個以上の
`~site~storage単位@
からなる。
◎
Site storage consists of zero or more site storage units.
</p>

<p>
各 `生成元$には、ある`~site~storage単位$が結付けられる。
各`~site~storage単位$は、 1 個の
`~bucket@
（ bucket, “バケツ” ）を包含する。
`HTML$r
◎
Each origin has an associated site storage unit. A site storage unit contains a single bucket. [HTML]
</p>

		<section id="buckets">
<h3 title="Buckets">3.1. ~bucket</h3>

<p>
各 `~bucket$には
`~mode@
があり、［
 `best-effort^l, `persistent^l 
］のいずれかにされる。
［
`~mode$ ~EQ `persistent^l
］なる`~bucket$を
`持続的@
という。
そうでない`~bucket$を
`持続的でない@
という†。
◎
A bucket has mode which is either "best-effort" or "persistent". A persistent bucket is a bucket whose mode is "persistent". A non-persistent bucket is a bucket whose mode is not "persistent".
</p>

<p class="trans-note">【†
この訳では、この用語は利用せず，単に “`持続的$でない” と記す。
】</p>

<p>
~bucketは、不可分な単位と見なされる。
~UAは、`~bucket$を~clearするときには，まるごと~clearするモノトスル。
◎
A bucket is considered to be an atomic unit. Whenever a bucket is cleared by the user agent, it must be cleared in its entirety.
</p>


		</section>
	</section>
	<section id="persistence">
<h2 title="Persistence permission">4. 持続性~許可</h2>

<p>
`~bucket$が`持続的$に転化されるのは、利用者（または，利用者に利する~UA）が `persistent-storage$l 特能を利用する許可を是認したときに限られる。
◎
A bucket can only be turned into a persistent bucket if the user (or user agent on behalf of the user) has granted permission to use the "persistent-storage" feature.
</p>


<p class="note">注記：
`生成元$に是認されたなら、持続性~許可は，［
~UAによる ~storageを~clearするための施策
］から保護するために利用できる。
~UAは、`生成元$や利用者の介在~抜きには，持続的にされた~storageを~clearできない。
これは特に、利用者が~offlineの間に可用にする必要がある資源や, 利用者が局所的に作成した資源に対し，有用になる。
◎
When granted to an origin, the persistence permission can be used to protect storage from the user agent’s clearing policies. The user agent cannot clear storage marked as persistent without involvement from the origin or user. This makes it particularly useful for resources the user needs to have available while offline or resources the user creates locally.
</p>


<p>
この仕様は、`強力な特能$（ powerful feature ）として，
`persistent-storage@l
を定義する。
その許可に関係する各種［
~flag, ~algo, 型
］は、次を除いて既定のものになる：
◎
The "persistent-storage" powerful feature’s permission-related flags, algorithms, and types are defaulted, except for:
</p>

<dl>
	<dt>`許可~状態$（ permission state ）</dt>
	<dd>
`persistent-storage$l の`許可~状態$の値は、同じ`生成元$を伴う すべての`環境~設定群~obj$にわたり，同じにするモノトスル。
<!-- `生成元$enV？ -->
◎
"persistent-storage"'s permission state must have the same value for all environment settings objects with a given origin.
</dd>

	<dt>`許可~revocation~algo$（ permission revocation algorithm ）</dt>
	<dd>
<p>
次を走らす：
</p>
		<ol>
			<li>
~IF［
`persistent-storage$l の`許可~状態$ ~NEQ `granted$l 
］
⇒
現在の`生成元$の`~site~storage単位$の`~bucket$の`~mode$ ~SET `best-effort^l
</li>
		</ol>
◎
If "persistent-storage"'s permission state is not "granted", then set the current origin’s site storage unit’s bucket’s mode to "best-effort".
</dd>
</dl>


	</section>
	<section id="usage-and-quota">
<h2 title="Usage and quota">5. 使用量と~quota</h2>

<p>
`生成元$ %生成元 の
`~site~storage使用量@
は、およその見積もりによる，
%生成元 の`~site~storage単位$内で利用されている~byte数である。
◎
The site storage usage of an origin origin is a rough estimate of the amount of bytes used in origin’s site storage unit.
</p>


<p class="note">注記：
これは正確な量にはなり得ない。
~UAは、`生成元$が正確に何~byte利用しているか はっきりしなくなるような，重複集約, 圧縮, その他の技法を駆使してるかもしれず、また そうすることが~UAには奨励されるので。
◎
This cannot be an exact amount as user agents might, and are encouraged to, use deduplication, compression, and other techniques that obscure exactly how much bytes an origin uses.
</p>


<p>
`生成元$ %生成元 の
`~site~storage~quota@
は、保守的な見積もりによる， %生成元 の`~site~storage単位$に可用な~byte数である。
この量は、利用者に ある程度の余裕を与えるため，機器~storageの可用な空きの総計より少なくなるべきである。
◎
The site storage quota of an origin origin is a conservative estimate of the amount of bytes available to origin’s site storage unit. This amount should be less than the total available storage space on the device to give users some wiggle room.
</p>


<p class="note">注記：
~UAには、 “頻用される” `生成元$には より大きい`~site~storage~quota$を供することが強く奨励される。
“頻用度” の指標としては、
~naviの頻度,
訪問の近過去度,
~bookmarkされたかどうか,
`persistent-storage$l に対する`許可$
などの要因を利用できる。
◎
User agents are strongly encouraged to provide "popular" origins with a larger site storage quota. Factors such as navigation frequency, recency of visits, bookmarking, and permission for "persistent-storage" can be used as indications of "popularity".
</p>



	</section>
	<section id="ui-guidelines">
<h2 title="User Interface Guidelines">6. ~UI指針</h2>

<p>
~UAは、自身の~UIにおいて~network~storageと`~site~storage$を判別させるべきでない。
代わりに、所与の`~schemeなし生成元~群$に属する すべての~storageを除去する能を，利用者に提供するべきである。
これは、［
~network~storageを利用しても，`~site~storage$は復活できなくする
］ことを，ある程度まで確保する。
これはまた、`~schemeなし生成元~群$が~dataを格納できる種々の仕方について，利用者が知る必要がある量を抑える。
◎
User agents should not distinguish between network storage and site storage in their user interface. Instead user agents should offer users the ability to remove all storage for a given schemeless origin group. This ensures to some extent that network storage cannot be used to revive site storage. This also reduces the amount users need to know about the different ways in which a schemeless origin group can store data.
</p>


<p>
資格証~storageは、他から分離されるべきである
— それは、自動生成された~passwordなど，利用者が復活できないような~dataを包含するかもしれないので。
許可~storageも，ほとんどは単純な真偽値たちからなるので、利用者の不便さを避けるため分離できる。
資格証や許可は、~network~storageや`~site~storage$よりも，利用者にとって解したり見分けるのはいくぶん容易でもある。
◎
Credentials storage should be separated as it might contain data the user might not be able to revive, such as an autogenerated password. Since permissions storage is mostly simple booleans it too can be separated to avoid inconveniencing the user. Credentials and permissions are also somewhat easier to understand and differentiate for users from network storage and site storage.
</p>

		<section id="storage-pressure">
<h3 title="Storage Pressure">6.1. ~storageの逼迫</h3>

<p>
~UAは、~storageが逼迫してきて，［
`~site~storage$の中の ［
~network~storageや`持続的$でない~bucket
］を~clearすることでは，十分な空きを~~確保できない
］ことに気づいたときは、利用者に~alertして，`持続的~bucket$を~clearする仕方を提供するべきである。
◎
When the user agent notices it comes under storage pressure and it cannot free up sufficient space by clearing network storage and non-persistent buckets within site storage, then the user agent should alert the user and offer a way to clear persistent buckets.
</p>

		</section>
	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<pre class="idl">
[`SecureContext$]
interface mixin `NavigatorStorage@I {
  [`SameObject$] readonly attribute `StorageManager$I `storage$m;
};

`Navigator$I includes `NavigatorStorage$I;
`WorkerNavigator$I includes `NavigatorStorage$I;
</pre>

<p>
各`環境~設定群~obj$ `HTML$r には、
`StorageManager$I ~objが結付けられる。
◎
Each environment settings object has an associated StorageManager object. [HTML]
</p>

<dl>
	<dt>`storage@m</dt>
	<dd>
取得子は、此れに`関連な設定群~obj$の `StorageManager$I ~objを返すモノトスル。
◎
The storage attribute’s getter must return context object’s relevant settings object’s StorageManager object.
</dd>
</dl>

<pre class="idl">
[`SecureContext$,
 `Exposed$=(Window,Worker)]
interface `StorageManager@I {
  Promise&lt;boolean&gt; `persisted$m();
  [`Exposed$=Window] Promise&lt;boolean&gt; `persist$m();

  Promise&lt;`StorageEstimate$I&gt; `estimate$m();
};

dictionary `StorageEstimate@I {
  unsigned long long `usage@m;
  unsigned long long `quota@m;
};
</pre>

<dl>
	<dt>`persisted()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The persisted() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
			<li>
%生成元 ~LET 此れに`関連な設定群~obj$の`生成元$enV
◎
Let origin be context object’s relevant settings object’s origin.
</li>
			<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
`TypeError$E で %~promise を却下する
◎
If origin is an opaque origin, then reject promise with a TypeError.
</li>
			<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>
				<ol>
					<li>
<p>
%持続ed ~LET ［
%生成元 の`~site~storage単位$の`~bucket$は`持続的$ならば ~T ／
~ELSE_ ~F
］
◎
Let persisted be true if origin’s site storage unit’s bucket is a persistent bucket, and false otherwise.
</p>
<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
					</li>
					<li>
次を走らす`~taskを~queueする$
⇒
%持続ed で %~promise を解決する
◎
Queue a task to resolve promise with persisted.
</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</dd>

	<dt>`persist()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The persist() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
			<li>
%生成元 ~LET 此れに`関連な設定群~obj$の`生成元$enV
◎
Let origin be context object’s relevant settings object’s origin.
</li>
			<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
`TypeError$E で %~promise を却下する
◎
If origin is an opaque origin, then reject promise with a TypeError.
</li>
			<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>

				<ol>
					<li>
%生成元 ~LET %設定群~obj の`生成元$enV
◎
Let origin be settingsObject’s origin.
</li>
					<li>
<p>
%許可 ~LET
`persistent-storage$l を`利用する許可を要請-$した結果
◎
Let permission be the result of requesting permission to use "persistent-storage".
</p>


<p class="note">注記：
~UAには、同じ`生成元$に対し，同時期に利用者にこの問いに重ねて回答させないことが奨励される。
この
【許可を要請する】
~algoは、そのような局面を取扱うためのものではない。
◎
User agents are encouraged to not let the user answer this question twice for the same origin around the same time and this algorithm is not equipped to handle such a scenario.
</p>
	</li>
					<li>
<p>
%持続ed ~LET ［
%生成元 の`~site~storage単位$の`~bucket$は`持続的$ならば ~T ／
~ELSE_ ~F
］
◎
Let persisted be true, if origin’s site storage unit’s bucket is a persistent bucket, and false otherwise.
</p>
<p class="note">注記：
内部~errorが生じたときは ~F になる。
◎
It will be false when there’s an internal error.
</p>
					</li>
					<li>
<p>
~IF［
%持続ed ~EQ ~F
］~AND［
%許可 ~EQ `granted$l
］：
◎
If persisted is false and permission is "granted", then:
</p>
						<ol>
							<li>
%生成元 の`~site~storage単位$の`~bucket$の`~mode$ ~SET `persistent^l
◎
Set origin’s site storage unit’s bucket’s mode to "persistent".
</li>
							<li>
~IF［
内部~errorは生じていない
］
⇒
%持続ed ~SET ~T
◎
If there was no internal error, then set persisted to true.
</li>
						</ol>
					</li>
					<li>
次を走らす`~taskを~queueする$
⇒
%持続ed で %~promise を解決する
◎
Queue a task to resolve promise with persisted.
</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</dd>

	<dt>`estimate()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The estimate() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
			<li>
%生成元 ~LET 此れに`関連な設定群~obj$の`生成元$enV
◎
Let origin be context object’s relevant settings object’s origin.
</li>
			<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
`TypeError$E で %~promise を却下する
◎
If origin is an opaque origin, then reject promise with a TypeError.
</li>
			<li>
<p>
~ELSE
⇒
次の手続きを`並列的$に走らす：
◎
Otherwise, run these steps in parallel:
</p>

				<ol>
					<li>
%使用量 ~LET %生成元 の`~site~storage使用量$
◎
Let usage be site storage usage for origin.
</li>
					<li>
%~quota ~LET %生成元 の`~site~storage~quota$
◎
Let quota be site storage quota for origin.
</li>
					<li>
%辞書 ~LET 次のようにされた新たな `StorageEstimate$I 辞書
⇒＃
`usage$m ~member ~SET %使用量,
`quota$m ~member ~SET %~quota
◎
Let dictionary be a new StorageEstimate dictionary whose usage member is usage and quota member is quota.
</li>
					<li>
<p>
~IF［［
%使用量, %~quota を得る間に何らかの内部~errorが生じた
］
⇒
次を走らす`~taskを~queueする$
⇒
`TypeError$E で %~promise を却下する
◎
If there was an internal error while obtaining usage and quota, then queue a task to reject promise with a TypeError.
</p>

<p class="note">注記：
内部~errorはごく稀にしか生じないと想定されており，何らかの類の低levelな［
~platform／~hardware
］における瑕疵を指示する。
しかしながら，~webにおける［
実装／~platform
］の多様さの尺度からは、生じるものとみなす必要がある。
◎
Internal errors are supposed to be extremely rare and indicate some kind of low-level platform or hardware fault. However, at the scale of the web with the diversity of implementation and platforms, the unexpected does occur.
</p>
					</li>
					<li>
~ELSE
⇒
次を走らす`~taskを~queueする$
⇒
%辞書 で %~promise を解決する
◎
Otherwise, queue a task to resolve promise with dictionary.
</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</dd>
</dl>


	</section>

</main></div><!-- MAIN -->

	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの貢献に感謝する：
</p>

<div lang="en-x-a0">

<p>
With that, many thanks to
Adrian Bateman,
Alex Russell,
Aislinn Grigas,
Ali Alabbas,
Ben Kelly,
Ben Turner,
Dale Harvey,
David Grogan,
fantasai,
Jake Archibald,
Jeffrey Yasskin,
Jinho Bang,
Jonas Sicking,
Joshua Bell,
Kenji Baheux,
Kinuko Yasuda,
Luke Wagner,
Michael Nordman,
Mounir Lamouri,
Shachar Zohar,
<span lang="zh">黃強</span> (Shawn Huang), and
<span lang="zh">簡冠庭</span> (Timothy Guan-tin Chien)
for being awesome!
</p>

<p>This standard is written by <a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> (<a href="https://www.mozilla.org/">Mozilla</a>, <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).</p>

<p>Copyright © 2019 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.</p>

</div>

	</section>
