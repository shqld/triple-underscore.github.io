<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web IDL （第 2 版 — 日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

.advisement { /* 警告 */
	text-align: left;
}

.deprecated {
	background: #FFEECC; /* .advisement と同じ */
	/* color: #9D937D; */
}

pre {
	white-space: pre-wrap;
}

code {
	color: #aa2300; /* #ff4500; 変更 */
}

/* 追加 */

.hex-value {
	font-family: sans-serif0, sans-serif;
}

.char-symbol {
	color: gray;
	font-family: monospace;
}

.charname {
	font-size: 85%
}

/* 節リンク */
.sec::before {
	content: '「';
	color: gray;
}
.sec::after {
	content: '」節';
	color: gray;
}

/* 拡張属性 */
.xattr {
	font-family: monospace0, monospace;
	color: purple;
}

/* IDL, ECMAScript 型／値 */

.idltype,
.idlmember,
.idlvalue {
	font-family: monospace0, monospace;
}

.idltype,
.idlvalue,
.idlmember {
	color: #017;
}

.js-property {
	color: #061;
}

.js-error,
error {
	color: #006633;
}

/* ECMAScript
	プロパティ記述子,
	内部プロパティ ／ well-known symbol,
	intrinsic/prototype object
*/
.descriptor {
	color: #061;
}

/* 仮想の定数 */
i.const {
	text-decoration: underline;
}

	/* コードブロック */
pre {
	margin: 0.5em 0 0.5em 0.5em;
	padding: 0.5em 1em;
}

pre.syntax,
pre.webidl,
pre.es-code,
pre.html-code {
}

pre.webidl,
pre.syntax{
	background:hsl(24, 20%, 95%);
}

pre.es-code {
	background: #FCFADC;
}

/* 引用例 */
blockquote {
	padding: 1px 1em;
	margin-left: 2em;
	margin-right: 2em;
}

.example blockquote {
	background: #f0f6ff;
}

/* 抽象演算 */
.abstract {
	color: green;
	font-family: sans-serif0, sans-serif;
}

/* 文法 */
.g {
	font-style: italic;
}

.sym {
	color: black;
}

dl.grammar {
	background: #eee;
}
dl.grammar > dt {
	font-weight: normal;
}
dl.grammar > dd {
	margin-left: 6em;
	white-space: pre-line;
}

dl.grammar > dt::after {
	content: " ::";
}

	/* 終端記号 */
#terminals > dd {
	margin-left: 4em;
}

#terminals > dt::after {
	content: " =";
}
#terminals > dd.regex::before,
#terminals > dd.regex::after {
	position:static;
	content: "/";
	color: orangered;
}

/* アルゴリズム */

dd > :first-child {
  margin-top: 0;
}

a.placeholder {
  color: #00e;
}

/* 集合 */
div.set {
  margin-left: 3em;
  margin-bottom: 1em;
  text-indent: -1em;
}

/* table */

table {
	border-style:hidden hidden none hidden;
}
table thead {
	border-bottom: solid medium gray;
}

table td, table th {
	border: solid thin gray;
	border-top: none;
	padding:0.2em;
}

	/* 表 整形 */
#matrix-idl-floats th,
#matrix-idl-integers th {
	white-space: nowrap;
}
#matrix-idl-integers td:nth-child(2),
#matrix-idl-integers td:nth-child(3),
#matrix-integers td,
#matrix-integers th {
	text-align: right;
	white-space: nowrap;
}
#matrix-integers th {
	min-width: 4em;
}
#matrix-buffer-sources td:first-child {
	white-space: pre-line;
}

/* 判別表 */

#distinguishable-table > thead {
	border-bottom: 1px solid #90b8de;
}

#distinguishable-table th {
	border: 1px solid #90b8de;
}

#distinguishable-table td {
	border: 1px solid #90b8de;
	text-align: center;
	background: #f0f6ff;
}

#distinguishable-table td[colspan] {
	background: #ddd;
}

#distinguishable-table > tbody > tr > th:first-child {
	text-align: right;
}

@supports (writing-mode: vertical-rl) {
	#distinguishable-table > thead > tr > th > span {
		display: block;
		writing-mode: vertical-rl;
		white-space: nowrap;
		min-width: 1.5em; /* FF bug. 本来は不要 */
	}
}

</style>
<!-- 

/* IDL 構文の参考例 */
pre.syntax {
	background: #ddffdd;
	padding: 1em;
	margin: 1em 2em;
}

/* IDL 構文 
pre.syntax {
	font-weight: bold;
}
pre.syntax em, pre.syntax i { font-weight: normal; }
pre.syntax em { color: red }
*/

 -->

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->

<script>

const source_data = {
	toc_main: 'MAIN0',
};

Util.ready = function(){

	source_data.grammar_tables = buildGrammerTables(),
	Util.switchWordsInit(source_data);
	return;

// 文法ブロック生成
// 逆参照機能があるので、文法一覧 → 本文リンクは省略
	function buildGrammerTables(){
	//
		const g_data = PAGE_DATA.d_grammar_table;
		delete PAGE_DATA.d_grammar_table;
		const g_table = C('dl');

		const lhs = Object.create(null);
		const rhs = Object.create(null);
		let index = 0;//＊

		g_table.className = 'grammar';
		g_table.innerHTML = '<dd>' + g_data
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/\s(?=[A-Za-z])/g, '$&＠')
			.replace(/"([ -~]+?)"/g, '<code class="sym">$1</code>')
			.replace(/\s*●(\w+)\s*/g, function(t, name){
				lhs[name] = index++;
				return ( `</dd><dt>＠${name}</dt><dd>` );
			})
			.replace(/＠(\w+)/g, ' <a class="g" href="#prod-$1">$1</a>')
			+ '</dd>\n'
		;

		g_table.removeChild(g_table.firstChild);

		const dts = g_table.getElementsByTagName('dt');
		const span = C('span');
		span.className = 'g';

		for(let name in lhs){
			const dt = dts.item(lhs[name]);
			rhs[name] = dt.nextElementSibling;
			lhs[name] = dt.cloneNode(true);

			dt.id = `prod-${name}`;
			const s = span.cloneNode(false);
			s.textContent = name;
			dt.replaceChild(s, dt.lastChild);
		}

		return {dom: g_table, dt: lhs, dd: rhs};///
	}
}

/*内容変換生成*/
source_data.generate = function(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const tf_map = { T: 'true', F: 'false', 0: '0', 1: '1' };

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'g': // 非終端記号／生成規則／regex
	href = `#prod-${key}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${key}</code>"`
	break;
case 'jE': // ES error 型
	href = `#exceptiondef-${key.toLowerCase()}`;
	break;
case 'E': // error 名
	href = `#${key.toLowerCase()}`;
	break;
case 'Ec': // error code
	href = `#dom-domexception-${key.toLowerCase()}`;
	break;
case 'T': // IDL 型
	href = `#idl-${key.replace(/ /g, '-')}`;
	break;
case 'A': // ES 抽象演算
	href = `~TC39#sec-${key.toLowerCase()}`;
	break;
case 'x': // 拡張属性
	href = `#${key}`;
	text = `[${key}]`;
	break;
case 'X': // byte value
	text = `0x${key}`;
	break;
case 'U': // Unicode code point
	return ( `<span class="code-point">U+${key}</span>` );
	break;
case 'U1': // Unicode code point
	return (
`<span class="code-point">U+${key}</span> (<span class="char-symbol">&#x${key};</span>)`
	);
	break;
case 'sl': // 内部 slot
	text = `[[${key}]]`
	break;
case 'jI': // ES intrinsic/prototype object
	text = `%${key}%`;
	break;
//	jt:  // ES 型, ES class
case 'jIsl':
	href = link_map[`jI.${key}`];
	if(!href) return match;//＊
	return (
`<span class="js-slot">[[Intrinsics]]</span>.<span class="js-slot">[[<a href="${href}"><code class="js-intrinsic">%${key}%</code></a>]]</span>`
	);
	break;
case 'jS': // ES well-known symbols
	href = '~TC39#sec-well-known-symbols';
	text = `@@${key}`;
	break;
case 'desc': // ES property descriptor
	return desc(key);
	break;
case 'sec':  // 節
	return `<a class="sec" href="#${key}">${link_map['#' + key] || '＊'}</a>`;
	break;
case 'fI':
	href = `https://github.com/heycam/webidl/issues/new?title=${key.replace(/ /g, '%20')}`;
	text = '課題を申請-';
	break;
case 'href':
	{
		const n = key.indexOf('＠');
		if(n > 0) {
			text = key.slice(0, n);
			href = key.slice(n + 1);
		}
	}
	break;
case 'en': // english words
	return `<span lang="en-x-a0">${key}</span>`
	break;

//	sym: 終端記号
//	char: Unicode 符号位置
//	i: i syntax変数
//	C: 仮想定数
//	mk: syntax強調
//	V: IDL 値
//	jp: ES property
//	jv: ES 値
//	sl: 内部 slot
//	op: 算術演算
//	A: ES 抽象演算
//	M: IDL メンバ
//	x: 拡張属性

default:
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}

	function desc(id){// ES プロパティ記述子
		const Val = (id.length > 3) ?
			`,
[[Value]]: ${TFmap(id.slice(4))}` : '';
		return (
`{ [[Writable]]: ${TFmap(id[0])},
[[Enumerable]]: ${TFmap(id[1])},
[[Configurable]]: ${TFmap(id[2])}${Val}
}`
		);
		function TFmap(c){
			const s = tf_map[c];
			return s ?
				`<span class="js-value">${s}</span>` : 
				`<var>${c}</var>`;
		}
	}
}

source_data.populate = function(){

// 内容複製
	duplicate();
	
	function duplicate(){
		const visited = Object.create(null);
		const iter = document.createNodeIterator(
			E('MAIN0'), NodeFilter.SHOW_COMMENT, null, null
		);
		let node;
		while(node = iter.nextNode()){
			const id = node.data;
			if(id.slice(0, 3) !== 'cp-'){
				continue;
			}
			let e = visited[id] || E(id);
			if(!e){
//				console.log(id);
				continue;
			}
			if(!visited[id]){
				e.removeAttribute('id');
//				e.style.outline = 'solid green 1px'
				visited[id] = e;
			}
			e = e.cloneNode(true);
//			e.style.outline = 'dashed green 1px'
			node.parentNode.replaceChild(e, node);
		}
	}

// 文法ブロック
	const G = this.grammar_tables;
	const lhs = G.dt;
	const rhs = G.dd;

	repeat('data.grammar', function(data){
		const dl = C('dl');
		dl.className = 'grammar';
		data.value.match(/\w+/g).forEach(function(name){
			if(!(name in lhs)) return;// throw name;
			dl.appendChild(lhs[name].cloneNode(true));
			dl.appendChild(rhs[name].cloneNode(true));
		});
		data.parentNode.replaceChild(dl, data);
	});

	const grammar_table = E('_p-grammar-table');
	grammar_table.parentNode.replaceChild(G.dom, grammar_table);

/*
	Util.del_j();
	repeat('pre span[title]', function(e){
		e.textContent = e.title;//.replace(/^/gm, '// ');
	});
	repeat('h2, h3, h4, h5', function(e){
		const t = e.title;
		if(!t) return;
		e.textContent = e.textContent.replace(/\. .+/, '. ' + t);
	});
	repeat('dl.grammar > dt', function(e){
		e.insertBefore(C('br'), e.firstChild);
		e.appendChild(document.createTextNode(' ::'));
	});
	repeat('.algorithm li', function(e){
		e.insertBefore(C('br'), e.firstChild);
	});

*/

}


</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Web IDL
spec_date:2019-10-14
trans_update:2019-10-15
source_checked:190404
original_url:https://heycam.github.io/webidl/
	abbr_url:WEBIDL
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
	conformance:w3c
copyright:2019,permissive
trans_1st_pub:2013-08-22


●●class_map
g:g
sym:sym
char:char
C:const
E:error
jE:js-error
Ec:error
T:idltype
V:idlvalue
jv:js-value
jp:js-property
jt:js-type
jI:js-intrinsic
jS:js-symbol
A:abstract
M:idlmember
x:xattr
sl:js-slot
X:hex-value
op:op

●●tag_map
g:span
sym:code
char:span
sup:sup
c:code
i:i
C:i
mk:mark
E:code
Ec:code
jE:code
V:code
T:code
jt:code
jI:code
jS:code
jp:code
jv:code
sl:span
op:span
A:span
M:code
x:span
X:span
var:var
em:em
cite:cite

●●original_id_map

ol-callable:
ol-optionality-list:
ol-type-list:
dfn-variadic-argument:
idl-integers:
idl-floats:
dfn-function-like:

	idl-DOMException:dfn-DOMException

normative:normative-references
informative:informative-references

●●words_table1

WEBGLEXT:https://www.khronos.org/registry/webgl/extensions
GEOLOCATION:https://www.w3.org/TR/geolocation-API/
HTMLWPROXY:HTML-windowproxy-ja.html

throwTypeError:<a href="#ecmascript-throw"><b>THROW</b></a> <a href="https://tc39.github.io/ecma262/#sec-native-error-types-used-in-this-standard-typeerror"><code class="error">TypeError</code></a>
SLASH:<code class="sym">/</code>
SPACE:<span class="charname">SPACE</span>

record_KV:<span class="idltype">record&lt;<var>K</var>, <var>V</var>&gt;</span>

DOMException:<span class="idltype">DOMException</span> 
promise_T:<span class="idltype">Promise&lt;<var>T</var>&gt;</span>
sequence_T:<span class="idltype">sequence&lt;<var>T</var>&gt;</span>
FrozenArray_T:<span class="idltype">FrozenArray&lt;<var>T</var>&gt;</span>
toJSON: <code>toJSON</code> 
varT:<var>T</var>

●●words_table

	●データ／型／構造
octet::::オクテット
浮動小数点:floating point::~
浮動小数点数:floating point number::~
数量-:numeric::~
ns:namespace::名前空間
	列挙-不能:unenumerable
	列挙-可能:enumerable
	並び:sequence
共用体:union:::~:ユニオン
set:::::セット
和集合:union::~
	instance化:instantiate
value:::::値
	//EN dash
key-value:key–value pair::key–value ペア::{キー：値} ペア
maplike:::map 類::マップ類
setlike:::set 類::セット類
定数:constant::~::コンスタント
	定数:const
演算子:operator::~
対応関係:mapping::対応付け
	昇順
	降順
	昇順／:in ascending numerical order
	作成した順に:in ascending chronological order
連鎖:chain::~
連鎖-:chain::~
chunk::::チャンク
循環:cycle::~
循環-:cycle::~

	●型注釈
随意:optional::::オプショナル
	随意~性:optionality
	随意~引数
省略可否:optionality::~
省略可:optional::~
必須:required::~
必須の:required::~
	必須:non-optional
内縁:inner::~::インナー
最内縁の:innermost::~::最インナーの
	最も内縁:innermost
nullable:::null 可能
正則:regular::~::レギュラー
特殊:special::~::スペシャル
exotic:
有限:finite::~
無限大:infinity::~
単精度:single-precision::~
倍精度:double-precision::~
無符号:unsigned:::符号なし
有符号:signed:::符号あり
符号:sign::~
首:primary::~
	//EN dash
可書:read–write:::読み書き可能
writable:::書き込み可能
	旧来のものでない:non-legacy
	LegacyWindowAlias:legacy window alias
typedef:
普通の:ordinary::~
内在的:intrinsic::~

	●データ演算
削除子:deleter::~
文字列化子:stringifier::~
	文字列~化-:stringify
	文字列~化:stringification
可反復:iterable:::~:イテラブル
	反復-可能:iterable
	反復される値:iterated value
	非同期c可反復:asynchronously iterable

連結:concatenation:~
連結-:concatenate:~
	連結-:prepended

決着-:settle::~
代入-:assign::~
代入:assignment::~

直列形:serialized::~::シリアル形
逆直列化-:deserialize::~::逆シリアル化
逆直列化:deserialization::~::逆シリアル化
添付-:attach::~

	~LET ε:Let 〜 be an uninitialized variable
	設定しておく:set up
	取得-:getting
	除去-:removal

	●一般処理
渡す:passする:~
渡され:passされ:~
渡し:passし:~
渡さず:passせず:~
渡せる:passできる:~
値渡し:passed by value:value 渡し:~
	~~渡しで:で pass byされ
梱包-:package::~
片付ける:clean upする:~
計算:computation:~
切詰める:clampする::切り詰める
切詰めら:clampさ::切り詰めら
切落す:truncateする:切り落とす
合格-:pass:~
準備-:prepare:~
検索-:look up::~::ルックアップ
検索:lookup::~::ルックアップ
切離す:detachする::切り離す
切離され:detachされ::切り離され
main::::メイン

	転換-:turn into
	存続する限り:lifetime
	投出し直す:rethrow
	渡り
	~~入力にとる:take
	~~入力の:incoming
	走り得る:run
	when invoked
	~call元:caller
	既定に初期化され:default-initialized

	●JS
ES:ECMAScript
symbol:
List:
strict-mode:strict mode
trace::::トレース
bind:
callable:
configure:
	~configure不能:non-configurable
export:
import:
	~importするもの:imports
具体:concrete::~
合成な:synthetic::合成
essential:
原型:prototype::::プロトタイプ
原型鎖:prototype chain::::プロトタイプチェイン
pdesc:Property Descriptor::property 記述子::プロパティ記述子
scope::::スコープ
中途完了:abrupt completion::~
正常完了:normal completion::~
完了record:Completion Record::完了 record
EnvironmentRecord:
Module-Record:Module Record
PromiseCapability:

	●IDL
DOMException:
ifc:interface::::インタフェース
	~ifc化:interface with
partial:
mb:member:::メンバ
meth:method::::メソッド
iframe:
accessor::::アクセサ
	引数~list:argument values／:the only argument value／:passing no arguments
	引数たち:arguments
内包-:include::~
includes:
引数個数:argument count:~
可変個的な:variadicな::可変個の引数をとる
可変個:variadic::~
判別:distinguishing:~
拡張属性:extended attribute::~
index-:index::index アクセス
多重定義:overload::~::オーバーロード
	多重定義:overloading
有効:effective:~
	有効~多重定義~集合:effective overload set
有修飾:qualified::~
片:fragment::~::フラグメント
形:form::~
言語束縛:language binding:言語 binding:~::言語バインディング
平坦:flat:~
	平坦~化:flatten
	flattened
文:statement:~
現任の:incumbent::~
隠蔽:shadow:~
	invalid
ms:milliseconds:::ミリ秒

	相互に参照しあう:mutually referential
	継承していない:non-inherited
	多重~継承:multiple inheritance
	継承されて:inherited
	予約-済み:reserved
	時間:time
	時間切れ:timed out
	時間差:amount of time
	起点:epoch
	定義し直す:redefine
	〜により定義される:-defined

	●保安
偽造-:forge::~
	偽造-不能:unforgeable
計時:timing::~
無効化-:invalidate:~
層:layer::~
	~secureでない:insecure
	導き:lead

	●動詞（未分類
back:
現れる:appearする:~
現れて:appearして:~
現れ:appearし:~
出現:appearing:~
	現れる:appearance of
在する:presentする:在る
在さな:presentしな:無
	在さない:not present
存在p:presence:存在
	~~不在:absent
	有無:existence
分割-:split:~
正準化-:canonicalize:~
強制-:coerce:~
保有-:keep:~
回送-:forward:~
進行中の:ongoing:~
open:
	~open中の:open
	`username^M:username
	完遂d:finished
	まだ開始されてない:not yet started
	戻され:back

	●構文／文字
scalar::::スカラー
literal::::リテラル
escape::::エスケープ
記号:symbol::~
終端記号:terminal symbol::~
引用符:quotes::~::クォート
正規表現:regular expression:~
surrogate::::サロゲート
	代用対:surrogate pair
式:expression:~
注釈付きの:annotatedな::~
注釈付き:annotated::~
UTF-16:
接頭-:prefix::~
単語:word:~
命名法:naming scheme:~
最長合致:longest possible match:~
等号:equals sign:~
semicolon::::セミコロン
colon::::コロン
comma::::カンマ
dash::::ダッシュ
underscore:
波括弧:braces:~
丸括弧:parenthesis:~
角括弧:square brackets:~
山括弧:angle brackets:~
	括弧対:balanced brackets
辞書式:lexicographic:~
分離子:separator:~
分離-:separate:~
区切る:separateする:~
区切らな:separateしな:~
区切られ:separateされ:~
区切りの:-separated:~

	範囲~外:out-of-range
	構文解析-時:parsing

	●仕様
WebIDL:
通用する:agnosticな:~
規範:normative:~
系列:variety:~
査読者:reviewer:~
不用意:accidental:~
直接間接に:direct または indirect に:直接, 間接を問わず
略記形:bare form:~
変種:variant:~
略記:shorthand:~
私的:private:~
交換-:interchange:~
	交換-可能に:interchangeably
手引き:guide:~
目安:guidance:~
クラス:class::~
精度:precision:~
自由:free:~
今日:today:~
成句的:idiomatic:~
首尾一貫した:coherentな:~
候補:candidate:~
命令的:imperative:~
代替の:alternativeな:~
力:power:~
問題ある:problematicな:~
複雑な:complicatedな:~

	~~問題:matter
	~~問題ない:Fine;
	省略符:ellipsis
	標準でない:non-standard
	編集を補佐する:editorial aide
	有意になる:has significance
	考慮点:consideration
	手続き:action
	実質的:In effect,
	終始:consistently
	~~通常:Fine
	効果なし:no effect
	~~正しい:right
	通例的でない:unusual
	あり得る:possible
	難がある:difficulties
	間違って:wrong
	誤った:erroneous
	同様な:similar
	似た:similar
	よく似ている:very similar
	類似する:similar to
	のときと同じく:As with
	~~理由:because
	必要:have to
	不要:need not
	なるとは限らない:not necessarily
	にもなり得る:possibly
	分類:categories／
	より問題になる:problem is exacerbated
	記述例／用例:examples of
	用語例
	~~自動的:no need to also
	~~確認:checked to ensure
	表記:
	謝意
	~~例外
	何故
	参照文献
	参考例
	~~意図的に:deliberate
	-:be true
	把握:unaware
	休み:unavailable to do so
	もまた，:By extension,
	-:terminology
	場合分け:case／:casing
	仮想の:-
	文献:
	担当グループ:group responsible for work
	選り分ける:reason about
	著しく:remarkably
	そのようなわけで、:that being said,
	相当の:substantialな
	あてはまらない:not the case for
	ほとんどの場合:most likely
	~~模範的:boilerplate-
	そのわけは:This is because
	今は無き:defunct
	責を負う:responsibility
	~~名残:left over
	~~協同で:in concert with
	対称にする:symmetry
	事実:fact
	上手く:wellに
	もちろん:of course
	支持を受けて:in favor of
	足る:sufficient

	●仕様（動詞
給-:supply:~
	~~給-:-
付帯-:accompany:~
競合-:conflict:~
心配:concern:~
論交する:discussする:論を交わす
発行-:publish:~
出荷-:ship:~
申請-:file:~
注記:note:~
警告:warning:~
勧める:adviseする:~
併合-:merge:~
	~~併合:conflate
	~~併合:mixed
分類-:categorize:~
分類:category:~
再現-:replicate:~
移行-:migrate:~
表出力:expressiveness:表現力
	表出力のある:expressive
問い:question:~
答える:answerする:~
関心ng:interesting:関心事になる

	~~実現できそう:viable solution
	~~実現:done
	仕様~化:specify
	~~説明:description
	他が指定されない限り:unless otherwise specified
	その指定-対象である:it helps specify
	~~供:be a
	-:plan
	したい:plan
	意外な:surprising
	伝え:convey
	気付く:notice
	注意:notice
	惑わす:confusing
	~~特別な:discriminated
	表す:denote
	見誤られ:looking like
	順繰りに挙げ:loop through
	強調-:highlight
	予測-不能:unpredictable
	細心の注意を払う必要がある:Extreme care must be taken
	見つけ:look for
	易くする:help
	付与:mark／
	課す:impose
	~~調整を通す:coordinate
	混ぜ合わせる:mix and match
	乏しく:decreasing
	無為に:defeat
	委ねる:leave
	読み難く:less readable
	読める:readable
	読む:read
	収まる:fit 
	壊し:break
	見える:seem
	まかなう:cater
	間もなく解消に向けて:in shortly
	感謝
	集約:-
	とする:suppose
	書く:write
	書き直す:rewrite
	予め〜され:pre-
	裁定-:decision
	特に〜挙げられる:notably
	好ましい:favor
	行われ:carry out
	受け入れる:adopt
	上で言及した:abovementioned

	●未分類（動詞
派生:derived::~
	継承~階層において最も末端:most-derived／:derived-most
終端-:end:終了
encapsulate::::カプセル化
encapsulation::::カプセル化
開いた:openした:~
超過-:exceed:~
quota:

	置く:place
	前に〜を置く:precede
	選ぶ:choose／choice
	重複:duplicates
	~~重複する:overlap
	開始:starting with
	なくする:prevent
	listed in 〜／
	指す:refer
	指す:address
	用いられる:triggerする
	出自に:originate
	変形-:
	~~区別-:-
	~~捕える:intercept
	組にされ:coupling
	になる:yielding
	行く:go
	ある:contain

	●事例
叩いた:hitした:~
押した:pressした:~
polyfill:
project::::プロジェクト
記憶域:memory::~::メモリ
合計:total:~
句:phrase:~
集成-:aggregate::~
bookmark::::ブックマーク
illustrate::説明
末端利用者:end-user:~:::エンドユーザ
自立的:standalone:~
非同期性:asynchronicity::~
非同時性:asynchrony::~
即時な:immediateな:即時の
	環境による:environmental
	~~定式化:encode
	-:maximum
	姓名:names
	矩形:rectangle
	英単語:English word
	英字:letter
	指向:oriented
	グラム／単位
	米／肉／麺／魚／その他:rice／sandwich／noodles／dumplings／other
	挨拶:greeting
	ほぼ同様:much like
	取り出され:drawn
	何度も行われる:iterative
	現実にありそうな:more real-world
	訴えかける:appealing
	選ぶ:make a choice
	何箇所か:place
	よく似た:very similar
	余分な:extra

	●未分類
代理:proxy::~
	それを代理する:by proxy
transaction::::トランザクション
database::::データベース
runtime:
singleton:
仮数:significand:~
偶数:even:~
基数:base:~
実数:real number:~
計数:counter:~
可視性判定:visibility:~
signature::::シグネチャ
pointer::::ポインタ
固定的:fixed:~
実体:entity::~
種類:kind:~
数学的:mathematical:~

	下位~節:sub-section
	表／一覧:table
	^en:place holder
	unwrap
	最小:shortest
	series
	~~基準
	等距離:equally close／lies halfway between two
	何もしない:no-op
	数値:value
	数字:-
	条件:
	-:clause
	-:just
	過去:
	2 の補数:two’s complement

	●訳注／meta
	導入-:
	~link:
	原文:-
	総称:-
	~~参照:-
	定訳:-
	対訳:-
	訳者:-
	非公式:-

	●指示語
現在:currently:~
main:
次回の:next:~
位置:位置
位置-:位置
	に位置する／の位置:at
	位置:position
新-:new:~
旧-:old:~

	素の:bare
	素の:plain
	直後:
	~~種別
	多少:
	種:
	項:
	合間:
	余分:
	全体:
	前回:
	前~段:
	前述:
	前項:

	／-:known
	粗い:low
	最低:lowest
	最新の:latest
	最終的:eventual
	最長:longest
	次項:
	唯一の:only
	同じ:the same
	後続:
	同様:
	自身:
	複数:
	以上
	以下
	以外
	任意の:any／arbitrary
	場合:
	部分:parts／
	最大:
	最小:
	類似:
	片方
	一方
	両方同時
	一連
	一部:part of
	広義
	時点
	この時点:at this point
	末尾
	前者:
	先頭
	下端:
	右側:right-hand side／right
	左側:left-hand side／left
	場所:
	一環:as part of
	一種:
	上述:
	一過性の:transientな
	今度:this time
	以前:
	同時:
	周囲:
	広範囲:wide
	類:category
	数~段~先:subsequently
	不定:indeterminate
	冒頭:
	頭部:
	一例:
	のみ／~~唯一の:sole
	もっぱら:solely
	~~仮に:instead
	近く:closely
	単に:simply
	回数:how many
	該当:
	他所で:other parts
	まずない:almost never 
	はるかに:much more
	少ししかない:little to no
	ときには／こともある:sometimes
	9 回重ねる:nine times
	個数:
	個
	1 個だけ:only
	個数:length
	先ず，:first
	他方:one other
	ここでも:again
	全く:distinctively
	およそ:about
	つつある:about to be
	引数を省いた:alone
	さらに／より:further
	より短い:shorter
	またがって／:across
	自体:itself
	対象に:target
	以前は:previously
	一つに:together
	様々な／各種:various
	種々の:variety
	まるごと:altogether
	-:rest
	他と伴に:among other things
	ほぼ:nearly
	早期の:earlier
	上端を成す:top of
	最初の:smallest
	より後:greater than

	●変数名
es:
idl:
	%識別子:id
	%値:value
	%~key:key
	%~idl~key:idlKey
	%~es~key:esKey
	%~key~IDL:keyIDL
	%値~IDL:valueIDL
	%~idl値:idlValue
	%~es値:esValue
	%~idl~obj:idlObject
	%値~引数:valueArg
	%~key引数:keyArg
	%長さ:length
	%~class文字列:classString
	%~scope不能~obj:unscopableObject
	%M:modifiable
	%~ifc原型~obj:interfaceProtoObj
	%記述子:desc
	%属性:attr
	%定数:const
	%原型:proto
	%arg
	%args:args
	%演算／op:op
	%新-~target:newTarget
	%~target~realm:targetRealm:#2
	%~ifc~obj:interfaceObject
	%~ns~obj:namespaceObject
	%有名~構築子:namedConstructor
	%偽造-不能~obj:unforgeables
	%~key~list:keys
	%有型:typed
	%有型~key:typedKey
	%有型~値:typedValue
	%作成した:created
	%~pair~list:pairs
	%~key型:keyType
	%値~型:valueType
	%作成する:creating
	%~call結果:callResult
	%name:name
	%function
	%型:type
	%却下される~promise:rejectedPromise
	%反復子:iter
	%反復子:iterator
	%可反復:iterable
	%~export名~list:exportNames
	%評価~手続き:evaluationSteps
	%~realm:realm
	%~hostが定義するもの:hostDefined
	%~module:module
	%~module文脈:moduleCxt
	%~export名:exportName
	%~export値:exportValue
	%exportStarSet:exportStarSet
	%解決-集合:resolveSet
	%環境:env
	%環境~record:envRec
	%completion:completion
	%旧-状態:oldState
	%新-状態:newState
	%次回の手続き:nextSteps
	%次回の~promise:nextPromise
	%次回の~promise能力:nextPromiseCapability
	%解決-手続き:resolveSteps
	%この検証~promise能力:thisValidationPromiseCapability
	%後の進行中の~promise能力:afterOngoingPromiseCapability

	%~promise能力:promiseCapability
	%失敗~手続き:failureSteps
	%充足-時の手続き:onFulfilledSteps
	%却下-時の手続き:onRejectedSteps
	%onRejected
	%onFulfilled
	%新たな能力:newCapability
	%~promise~index:promiseIndex
	%成功~手続き:successSteps
	%充足~handler:fulfillmentHandler
	%充足-回数:fullfilledCount
	%却下された:rejected
	%却下~handler手続き:rejectionHandlerSteps
	%却下~handler:rejectionHandler
	%応答~promiseたち:responsePromises
	%~promiseたち:promises
	%結果たち:results
	%合計:total
	%url:url
	%urls:urls
	%~metadata:info
	%~task源:taskSource

●●link_map

T.Promise:#idl-promise
T.WindowProxy:~HTMLWPROXY#windowproxy
T.Window:~WINDOW#window
T.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
T.Worklet:~WORKLETS1#worklet
T.Document:~DOM4#document
T.DocumentOrShadowRoot:~DOM4#documentorshadowroot
T.HTMLCollection:~DOM4#htmlcollection
T.NamedNodeMap:~DOM4#namednodemap
T.DOMMatrix:~GEOMETRY#dommatrix
T.DOMPoint:~GEOMETRY#dompoint
T.DOMRect:~GEOMETRY#domrect
T.DOMStringMap:~HTMLdom#domstringmap
T.EventHandlerNonNull:~WAPI#eventhandlernonnull
T.HTMLAllCollection:~HTMLLS/common-dom-interfaces.html#htmlallcollection
T.HTMLAudioElement:~HEmedia#htmlaudioelement
T.HTMLFormElement:~HEforms#htmlformelement
T.HTMLImageElement:~HEimages#htmlimageelement
T.HTMLOptionElement:~HEforms#htmloptionelement
T.MimeTypeArray:~HTMLnavigator#mimetypearray
T.Location:~HISTORY#location
T.OnBeforeUnloadEventHandlerNonNull:~WAPI#onbeforeunloadeventhandlernonnull
T.OnErrorEventHandlerNonNull:~WAPI#onerroreventhandlernonnull
T.Plugin:~HTMLnavigator#dom-plugin
T.PluginArray:~HTMLnavigator#pluginarray
T.URL:~URL1#url
T.CSS:~CSSOM1#namespacedef-css
T.CanvasDrawPath:~HEcanvas#canvasdrawpath
T.Path2D:~HEcanvas#path2d
T.CanvasDrawPath:~HEcanvas#canvasdrawpath
T.EventListener:~DOM4#callbackdef-eventlistener

T.DeviceAcceleration:https://w3c.github.io/deviceorientation/spec-source-orientation.html#device_acceleration
T.DeviceRotationRate:https://w3c.github.io/deviceorientation/spec-source-orientation.html#device_rotation_rate
T.ConstrainablePattern:https://w3c.github.io/mediacapture-main/#dom-constrainablepattern
T.ANGLE_instanced_arrays:~WEBGLEXT/ANGLE_instanced_arrays/#angle_instanced_arrays
T.EXT_blend_minmax:~WEBGLEXT/EXT_blend_minmax/#ext_blend_minmax
T.EXT_color_buffer_float:~WEBGLEXT/EXT_color_buffer_float/#ext_color_buffer_float
T.EXT_disjoint_timer_query:~WEBGLEXT/EXT_disjoint_timer_query/#ext_disjoint_timer_query
T.OES_standard_derivatives:~WEBGLEXT/OES_standard_derivatives/#oes_standard_derivatives
T.OES_vertex_array_object:~WEBGLEXT/OES_vertex_array_object/#oes_vertex_array_object
T.WEBGL_compressed_texture_astc:~WEBGLEXT/WEBGL_compressed_texture_astc/#webgl_compressed_texture_astc
T.WEBGL_compressed_texture_s3tc_srgb:~WEBGLEXT/WEBGL_compressed_texture_s3tc_srgb/#webgl_compressed_texture_s3tc_srgb
T.WEBGL_draw_buffers:~WEBGLEXT/WEBGL_draw_buffers/#webgl_draw_buffers
T.WEBGL_lose_context:~WEBGLEXT/WEBGL_lose_context/#webgl_lose_context
T.Coordinates:~GEOLOCATION#coordinates
T.Geolocation:~GEOLOCATION#geolocation
T.Position:~GEOLOCATION#position
T.PositionError:~GEOLOCATION#position-error
T.Response:~FETCH#response

M.supports():~CSSCOND#the-css-namespace
	~CSSCOND#dom-css-supports
	~CSSCOND#dom-css-supports-conditiontext
M.stroke():~HEcanvas#dom-context-2d-stroke
M.onmouseenter:~WAPI#handler-onmouseenter
M.onmouseleave:~WAPI#handler-onmouseleave
M.onreadystatechange:~WAPI#handler-onreadystatechange

M.implementation:~DOM4#dom-document-implementation
M.createElement():~DOM4#dom-document-createelement
M.fullscreenElement:~FULLSCREEN#dom-document-fullscreenelement
M.fullscreen:~FULLSCREEN#dom-document-fullscreen
M.fullscreenEnabled:~FULLSCREEN#dom-document-fullscreenenabled
M.fetch():~FETCH#dom-global-fetch

	●用語
~IDL片:#dfn-idl-fragment
定義:#dfn-definition
有名~定義:#dfn-named-definition
識別子:#dfn-identifier
予約-済み識別子:#dfn-reserved-identifier
有修飾~名:#qualified-name

~ifc:#dfn-interface
~ifc~mb:#dfn-interface-member
継承-:#dfn-inherit
継承した~ifcたち:#dfn-inherited-interfaces
自身も含む継承した~ifcの~list:#interface-inclusive-inherited-interfaces
部分的~ifc定義:#dfn-partial-interface
部分的~ifc:#dfn-partial-interface
~ifc~mixin:#interface-mixin
~ifc~mixin~mb:#interface-mixin-member
部分的~ifc~mixin:#partial-interface-mixin
部分的~ifc~mixin定義:#partial-interface-mixin
~includes文:#includes-statement
内包-:#include
~host~ifc:#host-interfaces
~callback~ifc:#dfn-callback-interface
~callback~ifc~mb:#callback-interface-member
~mb:#dfn-member

V.this:#this
所与の値:#the-given-value

定数:#dfn-constant
属性:#dfn-attribute
正則~属性:#dfn-regular-attribute
属性の下層~値を取得する:#get-the-underlying-value
読専:#dfn-read-only
取得子を継承する:#dfn-inherit-getter
演算:#dfn-operation
正則~演算:#dfn-regular-operation
返り値~型:#dfn-return-type
可変個的な:#dfn-variadic
可変個~引数:#dfn-variadic-argument
随意~引数:#dfn-optional-argument
既定~値:#dfn-optional-argument-default-value
stR.値:#value-of-string-literal-tokens
符号単位:#dfn-code-unit
~JSON型:#dfn-json-types
構築子~演算:#idl-constructors
特殊~演算:#dfn-special-operation
特殊~keyword:#dfn-special-keyword
取得子:#dfn-getter
設定子:#dfn-setter
削除子:#dfn-deleter
文字列化子:#dfn-stringifier
文字列~化の挙動:#dfn-stringification-behavior

有index~prop:#idl-indexed-properties
有index~prop取得子:#dfn-indexed-property-getter
有index~prop設定子:#dfn-indexed-property-setter
有index~propを~support:#dfn-support-indexed-properties
~supportする~prop~index:#dfn-supported-property-indices
有index~propの値を決定する:#dfn-determine-the-value-of-an-indexed-property
既存の有index~propを設定する:#dfn-set-the-value-of-an-existing-indexed-property
新たな有index~propを設定する:#dfn-set-the-value-of-a-new-indexed-property

有名~prop:#idl-named-properties
有名~prop取得子:#dfn-named-property-getter
有名~prop設定子:#dfn-named-property-setter
有名~prop削除子:#dfn-named-property-deleter
有名~propを~support:#dfn-support-named-properties
~supportする~prop名:#dfn-supported-property-names
有名~propの値を決定する:#dfn-determine-the-value-of-a-named-property
既存の有名~propを設定する:#dfn-set-the-value-of-an-existing-named-property
新たな有名~propを設定する:#dfn-set-the-value-of-a-new-named-property
既存の有名~propを削除する:#dfn-delete-an-existing-named-property

静的~属性:#dfn-static-attribute
静的~演算:#dfn-static-operation
oP.静的:#dfn-static-operation

多重定義:#dfn-overloaded
有効~多重定義~集合:#dfn-effective-overload-set
関数類:#dfn-function-like
oL.~callable:#effective-overload-set-tuple-callable
oL.型~list:#type-list
oL.省略可否~list:#optionality-list
省略可否 値:#dfn-optionality-value
有効~多重定義~集合を算出する:#compute-the-effective-overload-set
判別-可能:#dfn-distinguishable
最内縁の型:#_innermost-type
判別~引数~index:#dfn-distinguishing-argument-index
可反復:#dfn-iterable
可反復~宣言:#dfn-iterable-declaration
値~反復子:#dfn-value-iterator
~pair反復子:#dfn-pair-iterator
反復される値~pair:#dfn-value-pairs-to-iterate-over
値~pair:#value-pair
vP.~key:#value-pair-key
vP.値:#value-pair-value
非同期c可反復~宣言:#dfn-async-iterable-declaration
非同期~反復子~初期化~手続き:#asynchronous-iterator-initialization-steps
現在の状態:#current-state
次回の反復~結果を取得する:#dfn-get-the-next-iteration-result
~maplike:#dfn-maplike
~maplike 宣言:#dfn-maplike-declaration
~map~entry:#dfn-map-entries
~setlike:#dfn-setlike
~setlike 宣言:#dfn-setlike-declaration
~set~entry:#dfn-set-entries
~ns:#dfn-namespace
~ns~mb:#dfn-namespace-member
部分的~ns定義:#dfn-partial-namespace
部分的~ns:#dfn-partial-namespace
辞書:#dfn-dictionary
辞書~mb:#dfn-dictionary-member
diC.継承-:#dfn-inherit-dictionary
継承した辞書たち:#dfn-inherited-dictionaries
在する:#dfn-present
在さない:#dfn-present
diC.既定~値:#dfn-dictionary-member-default-value
必須~辞書~mb:#dfn-required-dictionary-member
部分的~辞書~定義:#dfn-partial-dictionary

例外:#dfn-exception
~error名:#dfn-exception-error-name
~message:#dfn-exception-message
単純~例外:#dfn-simple-exception
例外を作成する:#dfn-create-exception
例外を投出する:#dfn-throw
~error名~一覧:#dfn-error-names-table

列挙:#dfn-enumeration
列挙~値:#dfn-enumeration-value
~callback関数:#dfn-callback-function
~typedef:#dfn-typedef
新たな名前が与えられる型:#type-being-given-a-new-name
~platform~obj:#dfn-platform-object
旧来の~platform~obj:#dfn-legacy-platform-object

型:#idl-types
型~名:#dfn-type-name
整数~型:#dfn-integer-type
数量-型:#dfn-numeric-type
~primitive型:#dfn-primitive-type
文字列~型:#dfn-string-type
~Unicode~scalar値~列に変換-:#dfn-obtain-unicode
有型~配列~型:#dfn-typed-array-type
~buffer~source型:#dfn-buffer-source-type
~obj型:#dfn-object-type

特有~型:#dfn-specific-type
~symbol型:#idl-symbol
~ifc型:#idl-interface
~callback文脈:#dfn-callback-context
~callback~ifc型:#idl-callback-interface
辞書~型:#idl-dictionary
列挙~型:#idl-enumeration
~callback関数~型:#idl-callback-function
~nullable型:#dfn-nullable-type
~nullable:#dfn-nullable-type
~nullable~mb型の個数:#dfn-number-of-nullable-member-types
~nullable型を内包する:#dfn-includes-a-nullable-type
内縁~型:#dfn-inner-type
連列~型:#sequence-type
~sequence_T:#idl-sequence
~record型:#record-type
~record_KV:#idl-record
~promise型:#dfn-promise-type
~promise_T:#idl-promise
共用体~型:#dfn-union-type
~mb型:#dfn-union-member-type
平坦~化~mb型:#dfn-flattened-union-member-types
凍結d配列~型:#dfn-frozen-array-type
~FrozenArray_T:#idl-frozen-array
参照／複製を取得-:#dfn-get-buffer-source-reference
	参照を取得-:#dfn-get-buffer-source-reference
	複製を取得-:#dfn-get-buffer-source-copy

注釈付きの型:#annotated-types
anO.内縁~型:#annotated-types-inner-type
型に適用-可能:#extended-attributes-applicable-to-types

拡張属性:#dfn-extended-attribute
結付けられている拡張属性:#idl-type-extended-attribute-associated-with
拡張属性が結付けられ:#idl-type-extended-attribute-associated-with

引数をとらない:#dfn-xattr-no-arguments
引数~listを引数にとる:#dfn-xattr-argument-list
有名~引数~listを引数にとる:#dfn-xattr-named-argument-list
有名~引数~list:#dfn-xattr-named-argument-list
識別子を引数にとる:#dfn-xattr-identifier
識別子~listを引数にとる:#dfn-xattr-identifier-list

	●用語（ JS 束縛

~class文字列:#dfn-class-string
~THROW:#ecmascript-throw
初期~obj:#dfn-initial-object

公開~集合:#dfn-exposure-set
自前の公開~集合:#own-exposure-set
公開され:#dfn-exposed
公開されて:#dfn-exposed
属する~Realm:#dfn-associated-realm

~IDL値に変換-:#dfn-convert-ecmascript-to-idl-value
~ES値に変換-:#dfn-convert-idl-to-ecmascript-value

反応する:#dfn-perform-steps-once-promise-is-settled
新たな~promise:#a-new-promise
却下する:#reject
解決する:#resolve
却下される~promise:#a-promise-rejected-with
解決される~promise:#a-promise-resolved-with
充足-時:#upon-fulfillment
却下-時:#upon-rejection
すべての~promiseを待機する:#wait-for-all
すべてを待機する~promiseを取得する:#waiting-for-all-promise
準備済み~promise:#environment-ready-promise

連列~値を作成-:#create-sequence-from-iterable
凍結d配列~値を作成-:#create-frozen-array-from-iterable
凍結d配列を作成する:#dfn-create-frozen-array
切離す:#dfn-detach
切離された:#dfn-detach

大域~名:#dfn-global-name
wA.識別子:#legacywindowalias-identifier
nC.識別子:#namedconstructor-identifier

~secure文脈~下でなくとも可用:#available-in-both-secure-and-non-secure-contexts
~secure文脈~下に限り可用:#dfn-available-only-in-secure-contexts
~security検査を遂行する:#dfn-perform-a-security-check
偽造-不能:#dfn-unforgeable-on-an-interface
偽造-不能な~prop名:#dfn-unforgeable-property-name

多重定義~解決~algo:#dfn-overload-resolution-algorithm

~ifc~obj:#dfn-interface-object
構築子を上書きする手続き:#overridden-constructor-steps
~ifc~objを作成する:#create-an-interface-object
有名~構築子:#dfn-named-constructor
有名~構築子を作成する:#create-a-named-constructor
~ifc原型~obj:#dfn-interface-prototype-object
~ifc原型~objを作成する:#create-an-interface-prototype-object

有名~prop~obj:#dfn-named-properties-object
有名~prop~objを作成する:#create-a-named-properties-object
定数を定義する:#define-the-constants
正則~属性を定義する:#define-the-regular-attributes
静的~属性を定義する:#define-the-static-attributes
偽造-不能な正則~属性を定義する:#define-the-unforgeable-regular-attributes
属性を定義する:#define-the-attributes
属性~取得子:#dfn-attribute-getter
属性~取得子を作成する:#dfn-attribute-getter
属性~設定子:#dfn-attribute-setter
属性~設定子を作成する:#dfn-attribute-setter
正則~演算を定義する:#define-the-regular-operations
静的~演算を定義する:#define-the-static-operations
偽造-不能な正則~演算を定義する:#define-the-unforgeable-regular-operations
演算を定義する:#define-the-operations
演算~関数を作成する:#dfn-create-operation-function
対応する既定の演算:#corresponding-default-operation
既定の~toJSON演算:#default-tojson-operation
継承~stackの属性~値を収集する:#collect-attribute-values-of-an-inheritance-stack
属性~値を収集する:#collect-attribute-values
継承~stackを作成する:#create-an-inheritance-stack

既定の反復子~obj:#dfn-default-iterator-object
反復子~原型~obj:#dfn-iterator-prototype-object
非同期~反復子~原型~obj:#dfn-asynchronous-iterator-prototype-object
既定の非同期~反復子~obj:#dfn-default-asynchronous-iterator-object

aI.種類:#default-asynchronous-iterator-object-kind
aI.進行中の~promise:#default-asynchronous-iterator-object-ongoing-promise
aI.状態:#default-asynchronous-iterator-object-state
aI.~target:#default-asynchronous-iterator-object-target
反復子~結果:#iterator-result
内部~map~objへ回送する:#dfn-forwards-to-the-internal-map-object
~map~size取得子:#dfn-map-size-getter
内部~set~objへ回送する:#dfn-forwards-to-the-internal-set-object
~set~size取得子:#dfn-set-size-getter

~platform~objである:#is-a-platform-object
実装-:#implements
~ifcを実装する新たな~objを作成する:#new
~ifcを実装する新たな~objを内部的に作成する:#internally-create-a-new-object-implementing-the-interface

大域~prop参照を定義する:#define-the-global-property-references
首~ifc:#dfn-primary-interface
変化-:#dfn-change-global-environment

配列~indexで:#is-an-array-index
有名~propの可視性判定~algo:#dfn-named-property-visibility
有名~propは可視か？:#dfn-named-property-visibility
有index~prop設定子を呼出す:#invoke-indexed-setter
有名~prop設定子を呼出す:#invoke-named-setter

C.missing:#_missing
	C.完遂d:finished
	C.まだ開始されてない:not yet started
~Web~IDL引数~list:#web-idl-arguments-list
~ES引数~listに変換する:#web-idl-arguments-list-converting
利用元~objの演算を~callする:#call-a-user-objects-operation
~callback this 値:#dfn-callback-this-value
旧来の~callback~ifc~obj:#dfn-legacy-callback-interface-object
旧来の~callback~ifc~objを作成する:#create-a-legacy-callback-interface-object
~callback関数を呼出す:#invoke-a-callback-function
~callback関数で構築する:#construct-a-callback-function
~ns~obj:#dfn-namespace-object
~ns~objを作成する:#create-a-namespace-object
例外が投出された:#an-exception-was-thrown


	●§共通の定義／規約

ArrayBufferView:#ArrayBufferView
BufferSource:#BufferSource
DOMTimeStamp:#DOMTimeStamp
Function:#Function
VoidFunction:#VoidFunction

	~DOMException:#idl-DOMException
M.name:#dom-domexception-name
M.message:#dom-domexception-message
M.code:#dom-domexception-code
eX.名前:#domexception-name
eX.~message:#domexception-message

適合~ES実装:#dfn-conforming-ecmascript-implementation
適合~IDL片の集合:#dfn-conforming-set-of-idl-fragments
適合~実装:#dfn-conforming-implementation
用語例:#dfn-example-term


	●外部

~list:~INFRA#list
~size:~INFRA#list-size
~item:~INFRA#list-item
空:~INFRA#list-is-empty
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
	~IN:~INFRA#list-contain
有順序~map:~INFRA#ordered-map
~entry:~INFRA#map-entry
~key:~INFRA#map-key
値:~INFRA#map-value
	←:~INFRA#map-set
構造体:~INFRA#struct
sct.名前:~INFRA#struct-name

有順序~集合:~INFRA#ordered-set
集合:~INFRA#ordered-set
交差集合:~INFRA#set-intersection
下位集合:~INFRA#set-subset
set.付加する:~INFRA#set-append

~tuple:~INFRA#tuple
sct.~item:~INFRA#struct-item

~stack:~INFRA#stack
~cloneする:~INFRA#list-clone
~popする:~INFRA#stack-pop
~pushする:~INFRA#stack-push

	~EACH:~INFRA#list-iterate
	~BREAK:~INFRA#iteration-break
	~WHILE:~INFRA#iteration-while
	~EACH:~INFRA#map-iterate
	~CONTINUE:~INFRA#iteration-continue

~JS文字列:~INFRA#javascript-string
連結-:~INFRA#string-concatenate
範囲:~INFRA#the-range


大域~obj:~WAPI#concept-realm-global
関連な~Realm:~WAPI#concept-relevant-realm
関連な設定群~obj:~WAPI#relevant-settings-object
設定群~obj:~WAPI#concept-realm-settings-object
現任の設定群~obj:~WAPI#incumbent-settings-object
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script
走らせた~callbackを片付ける:~WAPI#clean-up-after-running-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~callbackを走らすために準備する:~WAPI#prepare-to-run-a-callback
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~task源:~WAPI#task-source
小taskを~queueする:~WAPI#queue-a-microtask
~taskを~queueする:~WAPI#queue-a-task

Serializable:~HTMLcloning#serializable
直列化-可能:~HTMLcloning#serializable-objects
直列化~手続き:~HTMLcloning#serialization-steps
逆直列化~手続き:~HTMLcloning#deserialization-steps

並列的:~HTMLINFRA#in-parallel

	●JS

合成な~Module-Record:#synthetic-module-record

	A.XxxYyy:~TC39#sec-xxxyyy
A.CleanupSettings:#_CleanupSettings
A.PrepareSettings:#_PrepareSettings
A.LegacyPlatformObjectGetOwnProperty:#LegacyPlatformObjectGetOwnProperty
A.IntegerPart:#abstract-opdef-integerpart
A.ConvertToInt:#abstract-opdef-converttoint
A.CreateSyntheticModule:#abstract-opdef-createsyntheticmodule
A.SetSyntheticModuleExport:#abstract-opdef-setsyntheticmoduleexport
A.Evaluate:#abstract-opdef-synthetic-module-record-evaluate
A.GetExportedNames:#abstract-opdef-synthetic-module-record-getexportednames
A.Link:#abstract-opdef-synthetic-module-record-link
A.ResolveExport:#abstract-opdef-synthetic-module-record-resolveexport

A.Type:~TC39#sec-ecmascript-data-types-and-values
A.Get:~TC39#sec-get-o-p
A.Set:~TC39#sec-set-o-p-v-throw
A.SetImmutablePrototype:~TC39#sec-set-immutable-prototype


	op.

jI.FunctionPrototype:~TC39#sec-properties-of-the-function-prototype-object
jI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
jI.ErrorPrototype:~TC39#sec-properties-of-the-error-prototype-object
jI.ArrayProto_values:~TC39#sec-array.prototype.values
jI.ArrayProto_forEach:~TC39#sec-array.prototype.foreach
jI.ArrayProto_entries:~TC39#sec-array.prototype.entries
jI.ArrayProto_keys:~TC39#sec-array.prototype.keys
jI.IteratorPrototype:~TC39#sec-%iteratorprototype%-object
jI.AsyncIteratorPrototype:~TC39#sec-asynciteratorprototype
jI.Promise:~TC39#sec-promise-constructor
jI.Promise_resolve:~TC39#sec-promise.resolve
jI.Promise_reject:~TC39#sec-promise.reject

jE.SyntaxError:~TC39#sec-native-error-types-used-in-this-standard-syntaxerror

	// js class
jt.Map:~TC39#sec-map-objects
jt.Set:~TC39#sec-set-objects
jt.Error:~TC39#sec-error-objects
jt.ArrayBuffer:~TC39#sec-arraybuffer-objects
jt.DataView:~TC39#sec-dataview-objects
jt.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects
jt.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
jt.Number:~TC39#sec-ecmascript-language-types-number-type
jt.Array:~TC39#sec-array-objects
jt.object:~TC39#sec-object-type
	jt.Function
	jt.Undefined
	jt.Null
	jt.Object
	jt.Function
	jt.Boolean
	jt.String
	jt.Symbol

i.NumericLiteral:~TC39#sec-literals-numeric-literals
	~TC39#sec-well-known-symbols
	jS.iterator:
	jS.unscopables:
	jS.toStringTag:

c.JSON.stringify():~TC39#sec-json.stringify
c.Promise.all():~TC39#sec-promise.all
c.Promise.then():~TC39#sec-promise.prototype.then
NewTarget:~TC39#sec-built-in-function-objects

op.floor:~TC39#eqn-floor
op.abs:~TC39#eqn-abs
op.modulo:~TC39#eqn-modulo
op.max:~TC39#eqn-max
op.min:~TC39#eqn-min
	op.typeof:~TC39#sec-typeof-operator

~error~obj:~TC39#sec-error-objects
完了record:~TC39#sec-completion-record-specification-type
中途完了:~TC39#sec-completion-record-specification-type
	正常完了:~TC39#normal-completion
	~TC39#sec-completion-record-specification-type
構築子:~TC39#constructor
関数~obj:~TC39#function-object
組込みの関数~obj:~TC39#sec-built-in-function-objects
~Realm:~TC39#realm
現在の~Realm:~TC39#current-realm
~callable:~TC39#sec-iscallable
配列~反復子~obj:~TC39#sec-array-iterator-objects
配列~index:~TC39#array-index
~pdesc:~TC39#sec-property-descriptor-specification-type
Assert:~TC39#sec-algorithm-conventions
変異-不能な原型~exotic~obj:~TC39#sec-immutable-prototype-exotic-objects
内部~slot:~TC39#sec-object-internal-methods-and-internal-slots
内部~meth:~TC39#sec-object-internal-methods-and-internal-slots
eS.要素:~TC39#sec-ecmascript-language-types-string-type
	eS.型:~TC39#sec-ecmascript-data-types-and-values
実行~文脈~stack:~TC39#execution-context-stack
走っている実行~文脈:~TC39#running-execution-context
~ES~code実行~文脈:~TC39#sec-execution-contexts
~EnvironmentRecord:~TC39#sec-lexical-environments
~Module-Record:~TC39#sec-abstract-module-records
~source~text~Module-Record:~TC39#sourctextmodule-record
~PromiseCapability:#sec-promisecapability-records


普通の~objの内部~methと内部~slot:~TC39#sec-ordinary-object-internal-methods-and-internal-slots
~algo規約:~TC39#sec-algorithm-conventions

	~TC39#sec-returnifabrupt-shorthands
	ResolvedBinding Record:~TC39#resolvedbinding-record
	Completion:~TC39#sec-completion
	SetMutableBinding:~TC39#table-15
	Realm／Function:~TC39#table-22
	VariableEnvironment／LexicalEnvironment:~TC39#table-23
	Module Record Fields:~TC39#table-36


	●他
~Unicode~scalar値:https://www.unicode.org/glossary/#unicode_scalar_value

~node~tree:~DOM4#concept-node-tree
文書:~DOM4#concept-document
~secure文脈:~SECURE-CONTEXT#secure-contexts

	●§
#idl:~ifc定義~言語
#idl-interfaces:~ifc
#idl-interface-mixins:~ifc~mixin
#idl-callback-interfaces:~callback~ifc
#using-mixins-and-partials:~mixinと~partialの利用-法
#idl-namespaces:~ns
#idl-objects:~ifcを実装している~obj
#idl-types:型
#idl-extended-attributes:拡張属性
#idl-tojson-operation:~toJSON
#idl-special-operations:特殊~演算
#idl-stringifiers:文字列化子
#idl-indexed-properties:有index~prop
#idl-named-properties:有名~prop
#idl-overloading-vs-union:多重定義 vs. 共用体~型

	●§JS 束縛
#es-creating-throwing-exceptions:例外の作成-法と投出-法

#es-type-mapping:~ES型との対応関係
#es-any:<code class="idltype">any</code>
	#es-void:<code class="idltype">void</code>
	#es-boolean:<code class="idltype">boolean</code>
#es-integer-types:整数~型
	#es-byte:<code class="idltype">byte</code>
	#es-octet:<code class="idltype">octet</code>
	#es-short:<code class="idltype">short</code>
	#es-unsigned-short:<code class="idltype">unsigned short</code>
	#es-long:<code class="idltype">long</code>
	#es-unsigned-long:<code class="idltype">unsigned long</code>
	#es-long long:<code class="idltype">long long</code>
	#es-unsigned-long-long:<code class="idltype">unsigned long long</code>
	#es-float:<code class="idltype">float</code>
	#es-unrestricted-float:<code class="idltype">unrestricted float</code>
	#es-double:<code class="idltype">double</code>
#es-unrestricted-double:<code class="idltype">unrestricted double</code>
#es-DOMString:<code class="idltype">DOMString</code>
	#es-ByteString:<code class="idltype">ByteString</code>
	#es-USVString:<code class="idltype">USVString</code>
	#es-object:<code class="idltype">object</code>
#es-symbol:<code class="idltype">symbol</code>
#es-interface:~ifc型
#es-callback-interface:~callback~ifc型
	#es-dictionary:辞書~型
	#es-enumeration:列挙~型
#es-callback-function:~callback関数~型
#es-nullable-type:~nullable型
	#es-sequence:連列~型
	#es-record:~record型
	#es-promise:~promise型
	#es-union:共用体~型
#es-buffer-source-types:~buffer~source型
	#es-frozen-array:凍結d配列~型

#es-extended-attributes:~ESに特有な拡張属性
#es-interfaces:~ifc
#interface-object:~ifc~obj
#named-constructors:有名~構築子
#interface-prototype-object:~ifc原型~obj
#named-properties-object:有名~prop~obj
#es-constants:定数
#es-attributes:属性
#es-operations:演算
#es-stringifier:文字列化子
#es-iterators:反復子に共通な挙動
#es-iterable:可反復~宣言
#es-maplike:~maplike 宣言
#es-setlike:~setlike 宣言
#es-platform-objects:~ifcを実装している~platform~obj
#platform-object-setprototypeof:[[SetPrototypeOf]]
#es-legacy-platform-objects:旧来の~platform~obj
#legacy-platform-object-getownproperty:[[GetOwnProperty]]
#legacy-platform-object-defineownproperty:[[DefineOwnProperty]]
#legacy-platform-object-set:[[Set]]
#legacy-platform-object-delete:[[Delete]]
#legacy-platform-object-preventextensions:[[PreventExtensions]]
#legacy-platform-object-ownpropertykeys:[[OwnPropertyKeys]]

#namespace-object:~ns~obj
#es-DOMException-specialness:~DOMException~custom言語束縛

#idl-grammar:~IDL文法


●●d_grammar_table


●Definitions
ExtendedAttributeList Definition Definitions
ε

●Definition
CallbackOrInterfaceOrMixin
Namespace
Partial
Dictionary
Enum
Typedef
IncludesStatement

●ArgumentNameKeyword
"async"
"attribute"
"callback"
"const"
"constructor"
"deleter"
"dictionary"
"enum"
"getter"
"includes"
"inherit"
"interface"
"iterable"
"maplike"
"namespace"
"partial"
"required"
"setlike"
"setter"
"static"
"stringifier"
"typedef"
"unrestricted"

●CallbackOrInterfaceOrMixin
"callback" CallbackRestOrInterface
"interface" InterfaceOrMixin

●InterfaceOrMixin
InterfaceRest
MixinRest

●InterfaceRest
identifier Inheritance "{" InterfaceMembers "}" ";"

●Partial
"partial" PartialDefinition

●PartialDefinition
"interface" PartialInterfaceOrPartialMixin
PartialDictionary
Namespace

●PartialInterfaceOrPartialMixin
PartialInterfaceRest
MixinRest

●PartialInterfaceRest
identifier "{" PartialInterfaceMembers "}" ";"

●InterfaceMembers
ExtendedAttributeList InterfaceMember InterfaceMembers
ε

●InterfaceMember
PartialInterfaceMember
Constructor

●PartialInterfaceMembers
ExtendedAttributeList PartialInterfaceMember PartialInterfaceMembers
ε

●PartialInterfaceMember
Const
Operation
Stringifier
StaticMember
Iterable
AsyncIterable
ReadOnlyMember
ReadWriteAttribute
ReadWriteMaplike
ReadWriteSetlike

●Inheritance
":" identifier
ε

●MixinRest
"mixin" identifier "{" MixinMembers "}" ;

●MixinMembers
ExtendedAttributeList MixinMember MixinMembers
ε

●MixinMember
Const
RegularOperation
Stringifier
ReadOnly AttributeRest

●IncludesStatement
identifier "includes" identifier ;

●CallbackRestOrInterface
CallbackRest
"interface" identifier { CallbackInterfaceMembers } ;

●CallbackInterfaceMembers
ExtendedAttributeList CallbackInterfaceMember CallbackInterfaceMembers
ε

●CallbackInterfaceMember
Const
RegularOperation

●Const
"const" ConstType identifier "=" ConstValue ";"

●ConstValue
BooleanLiteral
FloatLiteral
integer

●BooleanLiteral
"true"
"false"

●FloatLiteral
decimal
"-Infinity"
"Infinity"
"NaN"

●ConstType
PrimitiveType
identifier

●ReadOnlyMember
"readonly" ReadOnlyMemberRest

●ReadOnlyMemberRest
AttributeRest
MaplikeRest
SetlikeRest

●ReadWriteAttribute
"inherit" AttributeRest
AttributeRest

●AttributeRest
"attribute" TypeWithExtendedAttributes AttributeName ";"

●AttributeName
AttributeNameKeyword
identifier

●AttributeNameKeyword
"async"
"required"

●ReadOnly
"readonly"
ε

●DefaultValue
ConstValue
string
"[" "]"
"{" "}"
"null"

●Operation
RegularOperation
SpecialOperation

●RegularOperation
ReturnType OperationRest

●SpecialOperation
Special RegularOperation

●Special
"getter"
"setter"
"deleter"

●OperationRest
OptionalOperationName "(" ArgumentList ")" ";"

●OptionalOperationName
OperationName
ε

●OperationName
OperationNameKeyword
identifier

●OperationNameKeyword
"includes"

●ArgumentList
Argument Arguments
ε

●Arguments
"," Argument Arguments
ε

●Argument
ExtendedAttributeList ArgumentRest

●ArgumentRest
"optional" TypeWithExtendedAttributes ArgumentName Default
Type Ellipsis ArgumentName

●ArgumentName
ArgumentNameKeyword
identifier

●Ellipsis
"..."
ε

●ReturnType
Type
"void"

●Constructor
"constructor" "(" ArgumentList ")" ";"

●Stringifier
"stringifier" StringifierRest

●StringifierRest
ReadOnly AttributeRest
RegularOperation
";"

●StaticMember
"static" StaticMemberRest

●StaticMemberRest
ReadOnly AttributeRest
RegularOperation

●Iterable
"iterable" "<" TypeWithExtendedAttributes OptionalType ">" ";"

●OptionalType
"," TypeWithExtendedAttributes
ε

●AsyncIterable
"async" "iterable" "<" TypeWithExtendedAttributes "," TypeWithExtendedAttributes ">" ";"

●ReadWriteMaplike
MaplikeRest

●MaplikeRest
"maplike" "<" TypeWithExtendedAttributes "," TypeWithExtendedAttributes ">" ";"

●ReadWriteSetlike
SetlikeRest

●SetlikeRest
"setlike" "<" TypeWithExtendedAttributes ">" ";"

●Namespace
"namespace" identifier "{" NamespaceMembers "}" ";"

●NamespaceMembers
ExtendedAttributeList NamespaceMember NamespaceMembers
ε

●NamespaceMember
RegularOperation
"readonly" AttributeRest

●Dictionary
"dictionary" identifier Inheritance "{" DictionaryMembers "}" ";"

●DictionaryMembers
DictionaryMember DictionaryMembers
ε

●DictionaryMember
ExtendedAttributeList DictionaryMemberRest

●DictionaryMemberRest
"required" TypeWithExtendedAttributes identifier ";"
Type identifier Default ";"

●PartialDictionary
"dictionary" identifier "{" DictionaryMembers "}" ";"

●Default
"=" DefaultValue
ε

●Enum
"enum" identifier "{" EnumValueList "}" ";"

●EnumValueList
string EnumValueListComma

●EnumValueListComma
"," EnumValueListString
ε

●EnumValueListString
string EnumValueListComma
ε

●CallbackRest
identifier "=" ReturnType "(" ArgumentList ")" ";"

●Typedef
"typedef" TypeWithExtendedAttributes identifier ";"

●Type
SingleType
UnionType Null

●TypeWithExtendedAttributes
ExtendedAttributeList Type

●SingleType
DistinguishableType
"any"
PromiseType

●UnionType
"(" UnionMemberType "or" UnionMemberType UnionMemberTypes ")"

●UnionMemberType
ExtendedAttributeList DistinguishableType
UnionType Null

●UnionMemberTypes
"or" UnionMemberType UnionMemberTypes
ε

●DistinguishableType
PrimitiveType Null
StringType Null
identifier Null
"sequence" "<" TypeWithExtendedAttributes ">" Null
"object" Null
"symbol" Null
BufferRelatedType Null
"FrozenArray" "<" TypeWithExtendedAttributes ">" Null
RecordType Null

●PrimitiveType
UnsignedIntegerType
UnrestrictedFloatType
"boolean"
"byte"
"octet"

●UnrestrictedFloatType
"unrestricted" FloatType
FloatType

●FloatType
"float"
"double"

●UnsignedIntegerType
"unsigned" IntegerType
IntegerType

●IntegerType
"short"
"long" OptionalLong

●OptionalLong
"long"
ε

●StringType
"ByteString"
"DOMString"
"USVString"

●PromiseType
"Promise" "<" ReturnType ">"

●RecordType
"record" "<" StringType "," TypeWithExtendedAttributes ">"

●Null
"?"
ε

●BufferRelatedType
"ArrayBuffer"
"DataView"
"Int8Array"
"Int16Array"
"Int32Array"
"Uint8Array"
"Uint16Array"
"Uint32Array"
"Uint8ClampedArray"
"Float32Array"
"Float64Array"

●ExtendedAttributeList
"[" ExtendedAttribute ExtendedAttributes "]"
ε

●ExtendedAttributes
"," ExtendedAttribute ExtendedAttributes
ε

●ExtendedAttribute
"(" ExtendedAttributeInner ")" ExtendedAttributeRest
"[" ExtendedAttributeInner "]" ExtendedAttributeRest
"{" ExtendedAttributeInner "}" ExtendedAttributeRest
Other ExtendedAttributeRest

●ExtendedAttributeRest
ExtendedAttribute
ε

●ExtendedAttributeInner
"(" ExtendedAttributeInner ")" ExtendedAttributeInner
"[" ExtendedAttributeInner "]" ExtendedAttributeInner
"{" ExtendedAttributeInner "}" ExtendedAttributeInner
OtherOrComma ExtendedAttributeInner
ε

●Other
integer
decimal
identifier
string
other
"-"
"-Infinity"
"."
"..."
":"
";"
"<"
"="
">"
"?"
"ByteString"
"DOMString"
"FrozenArray"
"Infinity"
"NaN"
"USVString"
"any"
"boolean"
"byte"
"double"
"false"
"float"
"long"
"null"
"object"
"octet"
"or"
"optional"
"sequence"
"short"
"true"
"unsigned"
"void"
ArgumentNameKeyword
BufferRelatedType

●OtherOrComma
Other
","

●IdentifierList
identifier Identifiers

●Identifiers
"," identifier Identifiers
ε

●ExtendedAttributeNoArgs
identifier

●ExtendedAttributeArgList
identifier "(" ArgumentList ")"

●ExtendedAttributeIdent
identifier "=" identifier

●ExtendedAttributeIdentList
identifier "=" "(" IdentifierList ")"

●ExtendedAttributeNamedArgList
identifier "=" identifier "(" ArgumentList ")"


●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMA-262]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[IEEE-754]
    IEEE Standard for Floating-Point Arithmetic. 29 August 2008. URL: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PERLRE]
    Perl regular expressions (Perl 5.8.8). February 2006. URL: http://search.cpan.org/dist/perl/pod/perlre.pod 
[RFC2781]
    P. Hoffman; F. Yergeau. UTF-16, an encoding of ISO 10646. February 2000. Informational. URL: https://tools.ietf.org/html/rfc2781 
[RFC3629]
    F. Yergeau. UTF-8, a transformation format of ISO 10646. November 2003. Internet Standard. URL: https://tools.ietf.org/html/rfc3629 
[SECURE-CONTEXTS]
    Mike West. Secure Contexts. URL: https://w3c.github.io/webappsec-secure-contexts/ 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 

●●ref_informative

[CSS3-CONDITIONAL]
    David Baron. CSS Conditional Rules Module Level 3. URL: https://drafts.csswg.org/css-conditional-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). URL: https://drafts.csswg.org/cssom/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FULLSCREEN]
    Philip Jägenstedt. Fullscreen API Standard. Living Standard. URL: https://fullscreen.spec.whatwg.org/ 
[GEOLOCATION-API]
    Andrei Popescu. Geolocation API Specification 2nd Edition. URL: https://w3c.github.io/geolocation-api/ 
[GEOMETRY]
    Simon Pieters; Chris Harrelson. Geometry Interfaces Module Level 1. URL: https://drafts.fxtf.org/geometry/ 
[JSSTDLIB]
    Standard Library Proposal. URL: https://github.com/tc39/proposal-javascript-standard-library/ 
[MEDIACAPTURE-STREAMS]
    Daniel Burnett; et al. Media Capture and Streams. URL: https://w3c.github.io/mediacapture-main/ 
[OMGIDL]
    CORBA 3.1 – OMG IDL Syntax and Semantics chapter. January 2008. URL: http://www.omg.org/cgi-bin/doc?formal/08-01-04.pdf 
[ORIENTATION-EVENT]
    Rich Tibbett; et al. DeviceOrientation Event Specification. URL: https://w3c.github.io/deviceorientation/ 
[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBGL]
    Dean Jackson; Jeff Gilbert. WebGL 2.0 Specification. 12 August 2017. URL: https://www.khronos.org/registry/webgl/specs/latest/2.0/ 
[WORKLETS-1]
    Ian Kilpatrick. Worklets Level 1. URL: https://drafts.css-houdini.org/worklets/ 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案（ Editor’s Draft ）として公開された 
<a href="~SPEC_URL">Web IDL</a>
（第 2 版）を日本語に翻訳したものです。
~PUB
<!-- <time>2012-05-15</time>（第１版） -->
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/WebIDL-1/
バージョン履歴
	https://github.com/heycam/webidl/commits/master

フィードバック
	<a href="mailto:public-script-coord@w3.org?subject=%5BWebIDL%5D%20YOUR%20TOPIC%20HERE">public-script-coord@w3.org</a> with subject line “<kbd>[WebIDL] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-script-coord/" rel="discussion">archives</a>)
	<a href="https://github.com/heycam/webidl">GitHub</a> ( <a href="https://github.com/heycam/webidl/issues/new">new issue</a>, <a href="https://github.com/heycam/webidl/issues">open issues</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=WebIDL&amp;resolution=---">legacy bug tracker</a>)

編集
	<a href="mailto:bzbarsky@mit.edu">Boris Zbarsky</a> (Mozilla Corporation)
前任編集者
	<a href="http://mcc.id.au/">Cameron McCormack</a> (Mozilla Corporation) <a href="mailto:cam@mcc.id.au">cam@mcc.id.au</a>
	<a href="http://tobie.me">Tobie Langel</a> <a href="mailto:tobie@codespeaks.com">tobie@codespeaks.com</a>

</script>

</head>

<body>

<header>
<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 title="Web IDL">Web IDL</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<p>
この文書は、~ifc定義~言語， ~Web~IDLを定義する
— それは、~Web~browserが実装するものと意図される~ifcを記述するために利用できる。
~Web~IDLは，~IDLの変種であり、［
~Web~platformにおいて共通な~script~objに対し，その挙動を より容易に指定できるようにする
］ための，いくつもの特能を備える。
この文書では、［
~Web~IDLで記述される~ifcが，~ES実行~環境の構成子にどう対応するか
］についても，詳細に述べられる。
この文書は、［
既に発行-済みの仕様 ／
新たに発行され, この文書を参照する仕様
］に適合している~ifcの実装が相互運用可能になるための，実装者~向けの手引きになるものと期待されている。
◎
This document defines an interface definition language, Web IDL, that can be used to describe interfaces that are intended to be implemented in web browsers. Web IDL is an IDL variant with a number of features that allow the behavior of common script objects in the web platform to be specified more readily. How interfaces described with Web IDL correspond to constructs within ECMAScript execution environments is also detailed in this document. It is expected that this document acts as a guide to implementors of already-published specifications, and that newly published specifications reference this document to ensure conforming implementations of interfaces are interoperable.
</p>

	</section>
	<section id="sotd">

~STATUSofTHIS

<p>
`この節では…^em
【以下、この節の他の内容は `W3C 日本語訳 共通ページ＠w3c-common-ja.html#status$hrefに委譲。】
</p>

<p><strong>
この文書に対する変更点は、
`https://github.com/heycam/webidl＠https://github.com/heycam/webidl$href
から追跡できます。
</strong>
◎
Changes to this document may be tracked at https://github.com/heycam/webidl.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
W3C により発行される技術-報告に含められる~programming言語~ifcは、概して
Object Management Group による~IDL（ `Interface Definition Language^en ）
`OMGIDL$r を利用して記述されていた。
この~IDLは、これらの~ifcを，言語に依存しない方式で記述する手段を供する。
通例的に，その種の文書には、［
~IDLで記述された~ifcを，所与の言語を成す構成子にどう対応するかの詳細
］を述べる，言語束縛~用の追加的な付録が含められる。
◎
Technical reports published by the W3C that include programming language interfaces have typically been described using the Object Management Group’s Interface Definition Language (IDL) [OMGIDL]. The IDL provides a means to describe these interfaces in a language independent manner. Usually, additional language binding appendices are included in such documents which detail how the interfaces described with the IDL correspond to constructs in the given language.
</p>

<p>
しかしながら、~Web上で最も共通的に利用されている言語, ~ESに対しては、これらの仕様における言語束縛は，終始~粗い精度で指定されていたため、相互運用能の課題も生じていた。
加えて、それぞれの仕様が同じ基本的な情報を述べなければならない
— 例えば、
~IDLで記述される~DOM~ifcが~ES大域~objの~propに対応していることや,
`unsigned long$T ~IDL型が~ESの `Number^jt 型に対応付けられることなど。
◎
However, the bindings in these specifications for the language most commonly used on the web, ECMAScript, are consistently specified with low enough precision as to result in interoperability issues. In addition, each specification must describe the same basic information, such as DOM interfaces described in IDL corresponding to properties on the ECMAScript global object, or the unsigned long IDL type mapping to the Number type in ECMAScript.
</p>

<p>
この仕様は、~Web~API用の~ifcを定義する仕様で利用できる， OMG ~IDLに似た~IDL言語を定義する。
この~IDLには、以前は注釈文による記述を要していた共通の機能性を~supportするために，いくつもの拡張が加えられた。
加えて、~ES言語~用の精確な言語束縛も与えられた。
◎
This specification defines an IDL language similar to OMG IDL for use by specifications that define interfaces for Web APIs. A number of extensions are given to the IDL to support common functionality that previously must have been written in prose. In addition, precise language bindings for the ECMAScript language are given.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, `~THROW$, ~WHILE, ~GOTO, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
ただし，`~THROW$ の意味は、この仕様に定義され（~link先を~~参照），もっぱら~ES言語束縛にて利用される。
</p>

<p>
この仕様~自身にも，`表記規約がある＠#conventions$href。
</p>

	</section>
	<section id="idl">
<h2 title="Interface definition language">2. ~ifc定義~言語</h2>

<p>
この節では、~Web~platform~API用の~ifcを定義するために利用できる言語，
`~Web~IDL^em について述べる。
~Web~APIを定義する仕様は、［
その仕様が定義する~API用の~ifc（~objが表出し得る状態と挙動）
］を記述する， 1 個~以上の
`~IDL片@
を含み得る。
`~IDL片$は、いくつかの［
文法~記号 `Definitions$g に合致する定義
］からなる並びである。
実装が~supportする `~IDL片$の集合は、順序付けられない。
完全な文法と利用される記法の説明については、
`idl-grammar$sec
を見よ。
◎
This section describes a language, Web IDL, which can be used to define interfaces for APIs in the Web platform. A specification that defines Web APIs can include one or more IDL fragments that describe the interfaces (the state and behavior that objects can exhibit) for the APIs defined by that specification. An IDL fragment is a sequence of definitions that matches the Definitions grammar symbol. The set of IDL fragments that an implementation supports is not ordered. See IDL grammar for the complete grammar and an explanation of the notation used.
</p>

<p>
`~IDL片$に現れ得る
`定義@
には、次の種類があり，すべて後続の節にて定義される
⇒＃
`~ifc$,
`部分的~ifc定義$,
`~ifc~mixin$,
`部分的~ifc~mixin定義$,
`~callback関数$,
`~callback~ifc$,
`~ns$,
`部分的~ns定義$,
`辞書$,
`部分的~辞書~定義$,
`~typedef$,
`~includes文$
◎
The different kinds of definitions that can appear in an IDL fragment are: interfaces, partial interface definitions, interface mixins, partial mixin definitions, callback functions, callback interfaces, namespaces, partial namespace definitions, dictionaries, partial dictionary definitions, typedefs and includes statements. These are all defined in the following sections.
</p>

<p>
各`定義$（ `Definition$g に合致-）の前には、［
`拡張属性$の~list（ `ExtendedAttributeList$g に合致-）
］を置ける
— それらは、［
当の定義が，言語束縛において どう取扱われるか
］を制御する。
この仕様が定義する拡張属性の，どの言語束縛にも通用する部分については
`idl-extended-attributes$sec
にて論じられ、~ES言語束縛に特有な部分については
`es-extended-attributes$sec
にて論じられる。
◎
Each definition (matching Definition) can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the definition will be handled in language bindings. The extended attributes defined by this specification that are language binding agnostic are discussed in § 2.14 Extended attributes, while those specific to the ECMAScript language binding are discussed in § 3.3 ECMAScript-specific extended attributes.
</p>

<pre class="syntax">
[`extended_attributes^mk]
interface `identifier^i {
  /* interface_members... */
};
</pre>

<data class="grammar" value="
Definitions
Definition
"></data>

<div class="example">
<p>
 `~IDL片$の例を示す：
◎
The following is an example of an IDL fragment.
</p>

<pre class="webidl">
[Exposed=Window]
interface Paint { };

[Exposed=Window]
interface SolidColor : Paint {
  attribute double red;
  attribute double green;
  attribute double blue;
};

[Exposed=Window]
interface Pattern : Paint {
  attribute DOMString imageURL;
};

[Exposed=Window]
interface GraphicalWindow {
  constructor();
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;

  attribute Paint currentPaint;

  void drawRectangle(double %x, double %y, double %width, double %height);

  void drawText(double %x, double %y, DOMString %text);
};
</pre>

<p>
ここでは、 4 個の`~ifc$が定義されている。
`GraphicalWindow^T ~ifcには、
2 個の`読専$な`属性$,
1 個の~writableな属性,
2 個の`演算$
が定義されている。
`GraphicalWindow^T ~ifcを実装する~objは、利用されている 特定0の言語に適切な方式で，これらの属性と演算を公開することになる。
◎
Here, four interfaces are being defined. The GraphicalWindow interface has two read only attributes, one writable attribute, and two operations defined on it. Objects that implement the GraphicalWindow interface will expose these attributes and operations in a manner appropriate to the particular language being used.
</p>

<p>
~ESにおいては、~IDL~ifc上の属性／演算は、すべての `GraphicalWindow^T ~objにおいて，その原型~obj上の［
`組込みの関数~obj$を値とする~data~propとして与えられる［
~accessor~prop ／ 演算
］］として，公開されることになる。
`GraphicalWindow^T を実装する各~ES~objは、その原型鎖の中にその原型~objを持つことになる。
◎
In ECMAScript, the attributes on the IDL interfaces will be exposed as accessor properties and the operations as data properties whose value is a built-in function object on a prototype object for all GraphicalWindow objects; each ECMAScript object that implements GraphicalWindow will have that prototype object in its prototype chain.
</p>

<p>
`GraphicalWindow^T 上に現れる`構築子~演算$により、［
`new GraphicalWindow()^c の~callに対し，この~ifcを実装する新たな~objを返す`構築子$
］が，~ES実装に存在することになる。
◎
The constructor operation that appears on GraphicalWindow causes a constructor to exist in ECMAScript implementations, so that calling new GraphicalWindow() would return a new object that implemented the interface.
</p>

<p>
どの`~ifc$にも `Exposed$x `拡張属性$があり、~ifcは［
`大域~obj$が `Window$T ~objである`~Realm$
］内に限り可用になることを確保する。
◎
All interfaces have the [Exposed] extended attribute, which ensures the interfaces are only available in Realms whose global object is a Window object.
</p>

</div>

		<section id="idl-names">
<h3 title="Names">2.1. 名前（識別子）</h3>

<p>
どの［
`~ifc$ ／
`部分的~ifc定義$ ／
`~ns$ ／
`部分的~ns定義$ ／
`辞書$ ／
`部分的~辞書~定義$ ／
`列挙$ ／
`~callback関数$ ／
`~callback~ifc$ ／
`~typedef$
］も（これらは総称して
`有名~定義@
と呼ばれる）, および
どの［
`定数$ ／
`属性$ ／
`辞書~mb$
］も、何らかの`演算$を行うための
`識別子@
を持つ。
識別子はその宣言~内のどこかに在る `identifier$g ~tokenから決定される：
◎
Every interface, partial interface definition, namespace, partial namespace definition, dictionary, partial dictionary definition, enumeration, callback function, callback interface and typedef (together called named definitions) and every constant, attribute, and dictionary member has an identifier, as do some operations. The identifier is determined by an identifier token somewhere in the declaration:
</p>

<ul>
	<li>
<p>
`有名~定義$に対しては、~keyword［
`interface^sym ／
`namespace^sym ／
`dictionary^sym ／
`enum^sym ／
`callback^sym
］の直後に現れる `identifier$g ~tokenがその定義の識別子を決定する。
◎
For named definitions, the identifier token that appears directly after the interface, namespace, dictionary, enum or callback keyword determines the identifier of that definition.
</p>

<pre class="syntax">
interface `interface_identifier^mk { /* interface_members... */ };
partial interface `interface_identifier^mk { /* interface_members... */ };
namespace `namespace_identifier^mk { /* namespace_members... */ };
partial namespace `namespace_identifier^mk { /* namespace_members... */ };
dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
partial dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
enum `enumeration_identifier^mk { "enum", "values" /* , ... */ };
callback `callback_identifier^mk = return_type (/* arguments... */);
callback interface `callback_interface_identifier^mk { /* interface_members... */ };
</pre>
	</li>
	<li>
<p>
`属性$,
`~typedef$,
`辞書~mb$
に対しては、宣言の末尾の~semicolonの前に在る最後の `identifier$g ~tokenが識別子を決定する。
◎
For attributes, typedefs and dictionary members, the final identifier token before the semicolon at the end of the declaration determines the identifier.
</p>

<pre class="syntax">
[`extended_attributes^i]
interface `identifier^i {
  attribute `type^i `attribute_identifier^mk;
};

typedef `type^i `typedef_identifier^mk;

dictionary `identifier^i {
  `type^i `dictionary_member_identifier^mk;
};
</pre>

</li>
	<li>
<p>
`定数$に対しては、等号の前に在る
`identifier$g ~tokenが識別子を決定する。
◎
For constants, the identifier token before the equals sign determines the identifier.
</p>

<pre class="syntax">
const `type^i `constant_identifier^mk = 42;
</pre>

</li>
	<li>
<p>
`演算$に対しては、返り値~型の後，かつ左~丸括弧の前に現れる `identifier$g ~token（ `OperationRest$g の中の文法~記号 `OptionalOperationName$g が成す部分に合致-）が、その演算の識別子を決定する。
そのような `identifier$g ~tokenが無い場合、その演算は識別子を持たない。
◎
For operations, the identifier token that appears after the return type but before the opening parenthesis (that is, one that is matched as part of the OptionalOperationName grammar symbol in an OperationRest) determines the identifier of the operation. If there is no such identifier token, then the operation does not have an identifier.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^mk(/* arguments... */);
};
</pre>

</li>
</ul>

<p class="note">注記：
［
取得子や設定子などの，
`特殊な種類の演算＠#idl-special-operations$href
］を宣言する演算は、識別子を持たないことがある。
◎
Note: Operations can have no identifier when they are being used to declare a special kind of operation, such as a getter or setter.
</p>

<p>
これらの構成子のすべてにおいて、
`identifier$g ~tokenから先頭の文字 `005F^U1 を（もし在れば）除去した値が`識別子$になる。
◎
For all of these constructs, the identifier is the value of the identifier token with any leading U+005F LOW LINE ("_") character (underscore) removed.
</p>

<p class="note">注記：
先頭の
`"_"^char
は、識別子を~escapeして，予約-済みの語と見誤られなくするために利用される。
例えば、 `interface^l という名前を持つ~ifcも定義できる。
先頭の
`"_"^char
は識別子の~escapeを外す際に落とされる。
◎
Note: A leading "_" is used to escape an identifier from looking like a reserved word so that, for example, an interface named "interface" can be defined. The leading "_" is dropped to unescape the identifier.
</p>

<p>
演算~引数がとり得る識別子は、もう少し広い集合になる。
演算の宣言においては、引数の識別子はその型の直後に指定され、
`identifier$g ~tokenか, または `ArgumentNameKeyword$g 記号に合致する~keywordで与えられる。
これらの~keywordのいずれかが利用される場合、先頭の~underscoreによる~escapeは不要である。
◎
Operation arguments can take a slightly wider set of identifiers. In an operation declaration, the identifier of an argument is specified immediately after its type and is given by either an identifier token or by one of the keywords that match the ArgumentNameKeyword symbol. If one of these keywords is used, it need not be escaped with a leading underscore.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^i(argument_type `argument_identifier^mk /* , ... */);
};
</pre>

<data class="grammar" value="
ArgumentNameKeyword
"></data>

<p>
演算~引数に `identifier$g ~tokenが利用された場合、その`識別子$はその~tokenから先頭の文字 `005F^U1 （ `underscore^en ）を取り除いた値になる。
代わりにいずれかの `ArgumentNameKeyword$g ~keyword~tokenが利用された場合、演算~引数の`識別子$は単にその~tokenになる。
◎
If an identifier token is used, then the identifier of the operation argument is the value of that token with any leading U+005F LOW LINE ("_") character (underscore) removed. If instead one of the ArgumentNameKeyword keyword token is used, then the identifier of the operation argument is simply that token.
</p>

<p>
上で言及したどの~IDL構成子も，（演算の引数は除いて）その`識別子$は［
`constructor^l ／ `toString^l
］になってはナラナイ。
また、文字 `005F^U1 から始まってはナラナイ。
これらは
`予約-済み識別子@
と呼ばれる。
◎
The identifier of any of the abovementioned IDL constructs (except operation arguments) must not be "constructor", "toString", or begin with a U+005F LOW LINE ("_") character. These are known as reserved identifiers.
</p>

<p>
`識別子$ `toJSON^l は`予約-済み識別子$ではないが、
`idl-tojson-operation$sec
に述べるように，利用されるのは［
~objを`~JSON型$に変換する`正則~演算$
］に限られなければナラナイ。
◎
Although the "toJSON" identifier is not a reserved identifier, it must only be used for regular operations that convert objects to JSON types, as described in § 2.5.3.1 toJSON.
</p>

<p class="note">注記：
後の節にて、一部の特定0の構成子に対しては，識別子の名前に更なる制約が課され得る。
◎
Note: Further restrictions on identifier names for particular constructs may be made in later sections.
</p>

<p>
所与の実装が~supportする`~IDL片$の集合に属する、どの［
`~ifc$ ／
`~ns$ ／
`辞書$ ／
`列挙$ ／
`~callback関数$ ／
`~callback~ifc$ ／
`~typedef$
］の`識別子$も，他のそれと互いに同じになってはナラナイ
— 同じ~~種別に限らず。
◎
Within the set of IDL fragments that a given implementation supports, the identifier of every interface, namespace, dictionary, enumeration, callback function, callback interface and typedef must not be the same as the identifier of any other interface, namespace, dictionary, enumeration, callback function, callback interface or typedef.
</p>

<p>
`~IDL片$の中では、`定義$への参照は，参照~先の定義の宣言より後に現れる必要はない。
参照は複数の`~IDL片$をまたがることもできる。
◎
Within an IDL fragment, a reference to a definition need not appear after the declaration of the referenced definition. References can also be made across IDL fragments.
</p>

<div class="example">
<p>
したがって，次の`~IDL片$は妥当である：
◎
Therefore, the following IDL fragment is valid:
</p>

<pre class="webidl">
[Exposed=Window]
interface B : A {
  void f(SequenceOfLongs %x);
};

[Exposed=Window]
interface A {
};

typedef sequence&lt;long&gt; SequenceOfLongs;
</pre>
</div>

<div class="example">
<p>
`定義$／`~ifc~mb$に，`識別子$を与える例を、次の`~IDL片$に示す：
◎
The following IDL fragment demonstrates how identifiers are given to definitions and interface members.
</p>

<pre class="webidl">
/* <span class="comment">
~typedef識別子： `number^l
◎
Typedef identifier: "number"
</span> */
typedef double number;

/* <span class="comment">
~ifc識別子： `System^l
◎
Interface identifier: "System"
</span> */
[Exposed=Window]
interface System {

  /* <span class="comment">
演算~識別子： `createObject^l
◎
Operation identifier:  "createObject"
</span> */
  /* <span class="comment">
演算~引数~識別子： `interface^l
◎
Operation argument identifier: "interface"
</span> */
  object createObject(DOMString _interface);

  /* <span class="comment">
演算~引数~識別子： `interface^l
◎
Operation argument identifier: "interface"
</span> */
  sequence&lt;object&gt; getObjects(DOMString interface);

  /* <span class="comment">
演算は識別子を持たない。取得子を宣言する。
◎
Operation has no identifier; it declares a getter.
</span> */
  getter DOMString (DOMString keyName);
};

/* <span class="comment">
~ifc識別子： `TextField^l
◎
Interface identifier: "TextField"
</span> */
[Exposed=Window]
interface TextField {

  /* <span class="comment">
属性~識別子： `const^l
◎
Attribute identifier: "const"
</span> */
  attribute boolean _const;

  /* <span class="comment">
属性~識別子： `value^l
◎
Attribute identifier: "value"
</span> */
  attribute DOMString? _value;
};
</pre>

<p>
`TextField^T `~ifc$の 2 個目の`属性$は（ `value^l は~IDL文法の~keywordではないので）~underscoreで~escapeする必要はないが、属性の`識別子$を得る際には，依然として~escapeは外される。
◎
Note that while the second attribute on the TextField interface need not have been escaped with an underscore (because "value" is not a keyword in the IDL grammar), it is still unescaped to obtain the attribute’s identifier.
</p>
</div>
		</section>
		<section id="idl-interfaces">
<h3 title="Interfaces">2.2. ~ifc</h3>

<p>
`~IDL片$は~obj指向~systemの記述に利用される。
その種の~systemにおいては、~objは同一性（ `identity^en ）を備える実体であり，状態と挙動の~encapsulationである。
`~ifc@
は、［
その~ifcを実装する~objが公開することになる，何らかの状態や挙動
］を宣言する，`定義$（ `interface^sym `InterfaceRest$g に合致-）である。
◎
IDL fragments are used to describe object oriented systems. In such systems, objects are entities that have identity and which are encapsulations of state and behavior. An interface is a definition (matching interface InterfaceRest) that declares some state and behavior that an object implementing that interface will expose.
</p>

<pre class="syntax">
[`extended_attributes^i]
interface `identifier^i {
  /* interface_members... */
};
</pre>

<p>
~ifcは、その宣言における波括弧の合間に現れる，一連の`~mb$が成す集合（ `InterfaceMembers$g に合致-）の指定である。
これらの~mbは、
`~ifc~mb@
と称される。
◎
An interface is a specification of a set of interface members (matching InterfaceMembers). These are the members that appear between the braces in the interface declaration.
</p>

<p>
~Web~IDLの~ifcは，その~ifcを実装する~objが どう挙動するかを記述する。
~obj指向~言語~用の言語束縛においては、特定0の~IDL~ifcを実装する~objは，［
~objの状態を検分したり改変する仕方，~ifcに記述された挙動を呼出す仕方
］を供することが期待されている。
◎
Interfaces in Web IDL describe how objects that implement the interface behave. In bindings for object oriented languages, it is expected that an object that implements a particular IDL interface provides ways to inspect and modify the object’s state and to invoke the behavior described by the interface.
</p>

<p>
~ifcは，別の~ifc（の~mb）を
`継承-@
するようにも定義できる。
~ifcの識別子に文字 `003A^U1 と`識別子$が後続している場合、後者の識別子が，継承される~ifcを識別する。
ある~ifc %I を継承する~ifcを実装する~objは， %I も実装する。
~objはしたがって， %I からの~ifc~mbに対応する~mbも持つことになる。
◎
An interface can be defined to inherit from another interface. If the identifier of the interface is followed by a U+003A COLON (":") character and an identifier, then that identifier identifies the inherited interface. An object that implements an interface that inherits from another also implements that inherited interface. The object therefore will also have members that correspond to the interface members from the inherited interface.
</p>

<pre class="syntax">
interface `identifier^i : `identifier_of_inherited_interface^mk {
  /* interface_members... */
};
</pre>

<p>
~mbたちが現れる順序は、
`~ES言語束縛＠#es-interfaces$href
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcは、継承される~ifcの~mbと同じ名前を持つ，~ifc~mbを指定してもよい。
派生~ifcを実装する~objは、派生~ifc上でそれらの~mbを公開することになる。
その~obj上で上書きされた~mbに~accessできるかどうかは、言語束縛に特有になる。
◎
Interfaces may specify an interface member that has the same name as one from an inherited interface. Objects that implement the derived interface will expose the member on the derived interface. It is language binding specific whether the overridden member can be accessed on the object.
</p>

<div class="example">
<p>
次の 2 つの~ifcを考える
◎
Consider the following two interfaces.
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  void f();
  void g();
};

[Exposed=Window]
interface B : A {
  void f();
  void g(DOMString %x);
};
</pre>

<p>
~ES言語束縛においては、
`B^T の~instanceは，次の様な原型鎖を持つことになる：
◎
In the ECMAScript language binding, an instance of B will have a prototype chain that looks like the following:
</p>

<div style="white-space:pre;margin-left:2em;">
[ `Object.prototype^jv ： `Object^jt 原型~obj]
              ↑
[ `A.prototype^jv ： `A^T の~ifc原型~obj]
              ↑
[ `B.prototype^jv ： `B^T の~ifc原型~obj]
              ↑
[ `B^T の~instance]</div>

<!-- 
[Object.prototype: the Object prototype object]
[B.prototype: interface prototype object for B]
[instanceOfB]
 -->
<p>
~ESにおける `instanceOfB.f()^c の~callは、
`B^T 上で定義された `f^M を呼出すことになる。【！ ＊ f】
しかしながら， `A^T 上の `f^M も、依然として
`A.prototype.f.call(instanceOfB)^c
の~callにより， `B^T を実装する~obj上で呼出せる。
◎
Calling instanceOfB.f() in ECMAScript will invoke the f defined on B. However, the f from A can still be invoked on an object that implements B by calling A.prototype.f.call(instanceOfB).
</p>

</div>

<p>
所与の~ifc %A が
`継承した~ifcたち@
とは、［
%A が直接間接に継承する，すべての~ifc
］からなる集合である。
%A が 他の~ifcを`継承-$しない場合、集合は空になる。
他の場合、集合は［
%A が継承した~ifc %B,
%B が`継承した~ifcたち$すべて
］を含む。
◎
The inherited interfaces of a given interface A is the set of all interfaces that A inherits from, directly or indirectly. If A does not inherit from another interface, then the set is empty. Otherwise, the set includes the interface B that A inherits from and all of B’s inherited interfaces.
</p>

<p>
~ifcは、その継承~階層が循環するように宣言されてはナラナイ。
すなわち、~ifc %A は自身を継承することも,
%A を継承する別の~ifc %B を継承することもできない，等々。
◎
An interface must not be declared such that its inheritance hierarchy has a cycle. That is, an interface A cannot inherit from itself, nor can it inherit from another interface B that inherits from A, and so on.
</p>

<div class="algorithm">

<p>
所与の`~ifc$ %I の
`自身も含む継承した~ifcの~list@
は、次に従って定義される`~list$である：
◎
The list of inclusive inherited interfaces of an interface I is defined as follows:
</p>

<ol>
	<li>
%結果 ~LET « »
◎
Let result be « ».
◎
Let interface be I.
</li>
	<li>
<p>
~WHILE［
%I ~NEQ ~NULL
］：
◎
While interface is not null:
</p>
		<ol>
			<li>
%結果 に %I を`付加する$
◎
Append interface to result.
</li>
	<li>
%I ~SET %I が`継承-$する`~ifc$が［
【！ ＊that I inherits from】
在れば それ ／
無ければ ~NULL
］
◎
Set interface to the interface that I inherits from, if any, and null otherwise.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

</div>

<p>
~ifcの一般的な多重~継承は~supportされず，~objは~ifcの任意の集合を実装することはできないことに注意。
~objは、所与の単独の~ifc %A を実装するように
— すなわち %A が`継承した~ifcたち$すべてを実装するように —
定義できる。
加えて，`~includes文$を利用すれば、［
ある~ifc %A を実装している~objが，常に［
%A が`内包-$する各`~ifc~mixin$を成す各`~ifc~mixin~mb$を内包する
］］ように定義することもできる。
◎
Note that general multiple inheritance of interfaces is not supported, and objects also cannot implement arbitrary sets of interfaces. Objects can be defined to implement a single given interface A, which means that it also implements all of A’s inherited interfaces. In addition, an includes statement can be used to define that objects implementing an interface A will always also include the members of the interface mixins A includes.
</p>

<p>
各~ifc~mbの前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致-）を置くことができる
— それらは、その~ifc~mbが，言語束縛において どう取扱われるかを制御する。
◎
Each interface member can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the interface member will be handled in language bindings.
</p>

<pre class="syntax">
[`extended_attributes^i]
interface `identifier^i {

  [`extended_attributes^mk]
  const `type^i `constant_identifier^i = 42;

  [`extended_attributes^mk]
  attribute `type^i `identifier^i;

  [`extended_attributes^mk]
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>

<p>
~ifc用の~IDLは、
`部分的~ifc定義@
（ `partial^sym `interface^sym `PartialInterfaceRest$g に合致-）を利用して，複数の部分に分割できる。
部分的~ifc定義の`識別子$は、その~ifc定義の識別子と同じでなければナラナイ。
各 部分的~ifcに現れる，すべての~mbは、その~ifc自身を成す~mbと見なされる。
◎
The IDL for interfaces can be split into multiple parts by using partial interface definitions (matching partial interface PartialInterfaceRest). The identifier of a partial interface definition must be the same as the identifier of an interface definition. All of the members that appear on each of the partial interfaces are considered to be members of the interface itself.
</p>

<pre class="syntax">
interface `SomeInterface^mk {
  /* interface_members... */
};

partial interface `SomeInterface^mk {
  /* interface_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義に意図される用途は、~ifcの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補佐することである。
◎
Note: Partial interface definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p>
`~ifc$定義, およびその`部分的~ifc定義$が現れる順序は~~問題にされない。
◎
The order of appearance of an interface definition and any of its partial interface definitions does not matter.
</p>

<p class="note">注記：
部分的~ifc定義においては、別の~ifcからの`継承-$は指定できない。
継承は元の`~ifc$定義に指定されなければナラナイ。
◎
Note: A partial interface definition cannot specify that the interface inherits from another interface. Inheritance must be specified on the original interface definition.
</p>

<p>
関連な言語束縛が，~ifcと［
言語の構成子
］とがどう対応するかを決定する。
◎
The relevant language binding determines how interfaces correspond to constructs in the language.
</p>

<p>
`~ifc$に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`Global$x,
`LegacyWindowAlias$x,
`NamedConstructor$x,
`NoInterfaceObject$x,
`OverrideBuiltins$x,
`SecureContext$x
◎
The following extended attributes are applicable to interfaces: [Exposed], [Global], [LegacyWindowAlias], [NamedConstructor], [NoInterfaceObject], [OverrideBuiltins], and [SecureContext].
</p>

<p>
`部分的~ifc$に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`OverrideBuiltins$x,
`SecureContext$x
◎
The following extended attributes are applicable to partial interfaces: [Exposed], [OverrideBuiltins], and [SecureContext].
</p>

<p>
`NoInterfaceObject$x `拡張属性$で注釈されていない`~ifc$は、
`Exposed$r `拡張属性$で注釈されなければナラナイ。
◎
Interfaces which are not annotated with a [NoInterfaceObject] extended attribute must be annotated with an [Exposed] extended attribute.
</p>

<div class="algorithm">

<p>
`~ifc$ %~ifc の
`有修飾~名@
は、次に従って定義される：
◎
The qualified name of an interface interface is defined as follows:
</p>

<ol>
	<li>
%識別子 ~LET %~ifc の`識別子$
◎
Let identifier be the identifier of interface.
</li>
	<li>
<p>
~IF［
%~ifc は `LegacyNamespace$x `拡張属性$を伴う
］：
◎
If interface has a [LegacyNamespace] extended attribute, then:
</p>
		<ol>
			<li>
%~ns ~LET `LegacyNamespace$x `拡張属性$の識別子~引数
◎
Let namespace be the identifier argument of the [LegacyNamespace] extended attribute.
</li>
			<li>
~RET
« %~ns, %識別子 »
を分離子 `002E^U1 で`連結-$した結果
◎
Return the concatenation of « namespace, identifier » with separator U+002E FULL STOP (".").
</li>
		</ol>
	</li>
	<li>
~RET %識別子
◎
Return identifier.
</li>
</ol>

</div>

<data class="grammar" value="
CallbackOrInterfaceOrMixin
InterfaceOrMixin
InterfaceRest
Partial
PartialDefinition
PartialInterfaceOrPartialMixin
PartialInterfaceRest
InterfaceMembers
InterfaceMember
PartialInterfaceMembers
PartialInterfaceMember
Inheritance
"></data>


<div class="example">

<p>
次の`~IDL片$に、 2 つの相互に参照しあう`~ifc$
— `Human^T と `Dog^T —
の定義~例を示す。
いずれも `Animal^T を継承するので、 2 つの~ifcいずれかを実装する~objは， `name^M 属性も持つことになる。
◎
The following IDL fragment demonstrates the definition of two mutually referential interfaces. Both Human and Dog inherit from Animal. Objects that implement either of those two interfaces will thus have a name attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface Animal {
  attribute DOMString name;
};

[Exposed=Window]
interface Human : Animal {
  attribute Dog? pet;
};

[Exposed=Window]
interface Dog : Animal {
  attribute Human? owner;
};
</pre>
</div>

<div class="example">
<p>
次の`~IDL片$は、ある~DOM`~ifc$と`~callback~ifc$を単純~化した~versionを定義する。
◎
The following IDL fragment defines simplified versions of a DOM interfaces and a callback interface.
</p>

<pre class="webidl">
[Exposed=Window]
interface Node {
  readonly attribute DOMString nodeName;
  readonly attribute Node? parentNode;
  Node appendChild(Node %newChild);
  void addEventListener(DOMString %type, EventListener %listener);
};

callback interface EventListener {
  void handleEvent(Event %event);
};
</pre>

<p>
素の~objは、 `EventListener$T の様な`~callback~ifc$を実装できる：
◎
Plain objects can implement a callback interface like EventListener:
</p>

<pre class="es-code">
var %node = getNode();  /* <span class="comment" id="cp-get-Node">
`Node^T の~instanceを得る。
◎
Obtain an instance of Node.
</span> */

var %listener = {
  handleEvent: function(%event) {
    /* <span class="comment" id="cp-some-code">...</span> */
  }
};
%node.addEventListener("click", %listener);            /* <span class="comment">
これは働く。
◎
This works.
</span> */

%node.addEventListener("click", function() { ... });  /* <span class="comment">
これと同様に。
◎
As does this.
</span> */
</pre>

<p>
しかしながら，そのような~objが `Node^T の様な`~ifc$を実装することはアリでない：
◎
It is not possible for such an object to implement an interface like Node, however:
</p>

<pre class="es-code">
var %node = getNode();  /* <!--cp-get-Node--> */

var %newNode = {
  nodeName: "span",
  parentNode: null,
  appendChild: function(%newchild) {
    /* <!--cp-some-code--> */
  },
  addEventListener: function(%type, %listener) {
    /* <!--cp-some-code--> */
  }
};
%node.appendChild(%newNode);  /* <span class="comment">
`TypeError^jE 例外が投出されることになる。
◎
This will throw a TypeError exception.
</span> */
</pre>
</div>

		</section>
		<section id="idl-interface-mixins">
<h3 title="Interface mixins">2.3. ~ifc~mixin</h3>

<p class="trans-note">【
この節に定義される `includes^sym 文は、従来の `implements^sym 文を置き換えるものになる（が、他の一部の仕様には、まだ `implements^sym 文のまま更新されていないものもある）。
】</p>

<p>
`~ifc~mixin@
は、［
それを`内包-$する`~ifc$を実装する各~obj
］により公開される状態や挙動を宣言する，`定義$（
`interface^sym `MixinRest$g
に合致-）である。
`~ifc~mixin$は、複数の`~ifc$に`内包-$され得る。
◎
An interface mixin is a definition (matching interface MixinRest) that declares state and behavior that can be included by one or more interfaces, and that are exposed by objects that implement an interface that includes the interface mixin.
</p>

<pre class="syntax">
interface mixin `identifier^i {
  /* mixin_members... */
};
</pre>

<p class="note">注記：
`~ifc~mixin$に意図されている用途は、`部分的~ifc$と同様に，［
複数の~ifcに
— 場合によっては複数の文書にわたって —
内包されるような，首尾一貫した機能性の集合
］を一つに~group化できるようにして，仕様の編集を補佐することである。
それには、言語束縛を通して公開されることは意味されていない。
［
`部分的~ifc$, `~ifc~mixin$, `部分的~ifc~mixin$
］のどれを選ぶかについての目安は、
`using-mixins-and-partials$sec
に見出せる。
◎
Note: Interface mixins, much like partial interfaces, are intended for use as a specification editorial aide, allowing a coherent set of functionalities to be grouped together, and included in multiple interfaces, possibly across documents. They are not meant to be exposed through language bindings. Guidance on when to choose partial interfaces, interface mixins, or partial interface mixins can be found in § 2.3.1 Using mixins and partials.
</p>

<p>
`~ifc~mixin$は、その宣言を成す波括弧の合間に現れる，一連の`~mb$
— ［
`定数$,
`正則~演算$,
`正則~属性$,
`文字列化子$
］ —
が成す集合（
`MixinMembers$g
に合致-）の指定である。
これらの~mbは、
`~ifc~mixin~mb@
と称され、それぞれが［
当の`~ifc~mixin$を`内包-$する`~ifc$
］に指定されていたかのように，~objに実装できる挙動を述べる。
◎
An interface mixin is a specification of a set of interface mixin members (matching MixinMembers), which are the constants, regular operations, regular attributes, and stringifiers that appear between the braces in the interface mixin declaration.
◎
These constants, regular operations, regular attributes, and stringifiers describe the behaviors that can be implemented by an object, as if they were specified on the interface that includes them.
</p>

<p>
`~ifc~mixin$の宣言には、次に挙げるものは現れ得ない
⇒
`静的~属性$ ／
`静的~演算$ ／
`文字列化子$を除く`特殊~演算$ ／
`可反復~宣言$ ／
`非同期c可反復~宣言$／
`~maplike 宣言$ ／
`~setlike 宣言$
◎
Static attributes, static operations, special operations except for stringifiers, and iterable, asynchronously iterable, maplike, and setlike declarations cannot appear in interface mixin declarations.
</p>

<p>
~ifcのときと同じく，`~ifc~mixin$用の~IDLは、
`部分的~ifc~mixin@
定義（
`partial^sym `interface^sym `MixinRest$g
に合致-）を利用して，複数の部分に分割できる。
`部分的~ifc~mixin$`定義$の`識別子$は、`~ifc~mixin$`定義$の`識別子$と同じでなければナラナイ。
各`部分的~ifc~mixin$`定義$に現れる どの`~ifc~mixin~mb$も，［
`~ifc~mixin$自身に加え，当の`~ifc~mixin$を
— 拡張により —
`内包-$している`~ifc$
］を成す`~mb$と見なされる。
◎
As with interfaces, the IDL for interface mixins can be split into multiple parts by using partial interface mixin definitions (matching partial interface MixinRest). The identifier of a partial interface mixin definition must be the same as the identifier of an interface mixin definition. All of the members that appear on each of the partial interface mixin definitions are considered to be members of the interface mixin itself, and—by extension—of the interfaces that include the interface mixin.
</p>

<pre class="syntax">
interface mixin `SomeMixin^mk {
  /* mixin_members... */
};

partial interface mixin `SomeMixin^mk {
  /* mixin_members... */
};
</pre>

<p>
~mbたちが現れる順序は、
`~ES言語束縛＠#es-namespaces$href
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
`~ifc$や`辞書$と違って、`~ifc~mixin$は，型を作成しないことに注意。
◎
Note that unlike interfaces or dictionaries, interface mixins do not create types.
</p>

<p>
この仕様に定義される拡張属性のうち，`~ifc~mixin$に適用-可能な拡張属性は、
`Exposed$x, `SecureContext$x
に限られる。
◎
Of the extended attributes defined in this specification, only the [Exposed] and [SecureContext] extended attributes are applicable to interface mixins.
</p>

<p>
`~includes文@
は、
（ 1 個目の`識別子$により識別される）`~ifc$ %I が
（ 2 個目の`識別子$により識別される）`~ifc~mixin$ %M を
`内包-@
すること
— すなわち，［
%I を実装している すべての~objは、 %M を成す各~mbも内包するモノトスル
］こと —
を宣言するために利用される，`定義$（
`IncludesStatement$g
に合致-）である。
◎
An includes statement is a definition (matching IncludesStatement) used to declare that all objects implementing an interface I (identified by the first identifier) must additionally include the members of interface mixin M (identified by the second identifier). Interface I is said to include interface mixin M.
</p>

<pre class="syntax">
`interface_identifier^i includes `mixin_identifier^i;
</pre>
【！＊mixin_indentifier】

<p>
1 個目の`識別子$は `~ifc$ %I を参照しなければナラナイ。
2 個目の識別子は `~ifc~mixin$ %M を参照しなければナラナイ。
◎
The first identifier must reference a interface I. The second identifier must reference an interface mixin M.
</p>

<p>
%M を成す各`~ifc~mixin~mb$は、 %M を`内包-$する各`~ifc$［
%I, %J, %K, …
］を成す`~mb$と見なされる
— 各~ifcごとに，`~ifc~mixin~mb$の複製が作られたかのように。
すなわち，
%M のある~mb %m に対し、~ifc［
%I ／ %J ／ %K ／ …
］は`~mb$［
%m<sub>%I</sub> ／ %m<sub>%J</sub> ／ %m<sub>%K</sub> ／ …
］を持つと見なされ，［
%m<sub>%I</sub> ／ %m<sub>%J</sub> ／ %m<sub>%K</sub> ／ …
］の
`~host~ifc@
は［
%I ／ %J ／ %K ／ …
］になる。
◎
Each member of M is considered to be a member of each interface I, J, K, … that includes M, as if a copy of each member had been made. So for a given member m of M, interface I is considered to have a member mI, interface J is considered to have a member mJ, interface K is considered to have a member mK, and so on. The host interfaces of mI, mJ, and mK, are I, J, and K respectively.
</p>

<div class="note">
<p>注記：
このことは，~ESにおいては、次のことを含意する
— `~ifc~mixin$ %M にて`~ifc~mixin~mb$として宣言された各 %m に対し：
</p>

<ul>
	<li>
%m は［
`正則~演算$であり，`組込みの関数~obj$値を伴うものとして公開される~data~prop
］になるならば、［
%M を`内包-$する 各`~ifc$に結付けられている`~ifc原型~obj$
］ごとに，別個の`組込みの関数~obj$がある。
</li>
	<li>
%m は`属性$ならば、その~accessor~propの各~複製ごとに別個の`組込みの関数~obj$が，［
取得子 ／ 設定子
］用にある。
</li>
</ul>

◎
Note: In ECMAScript, this implies that each regular operation declared as a member of interface mixin M, and exposed as a data property with a built-in function object value, is a distinct built-in function object in each interface prototype object whose associated interface includes M. Similarly, for attributes, each copy of the accessor property has distinct built-in function objects for its getters and setters.
</div>

<p>
`~includes文$が現れる順序は、それらの`~ifc~mixin$が`~host~ifc$に`内包-$される順序に影響する。
◎
The order of appearance of includes statements affects the order in which interface mixin are included by their host interface.
</p>

<p class="trans-note">【
同じ~host~ifcを指定する複数の~includes文が，同じ~IDL片の中に現れるならば（そのような~includes文が複数の~IDL片にわたって現れる場合の順序は未解決（次に述べる課題））。
これは、~ES言語束縛における~prop列挙に影響する。
】</p>

<p class="issue">
`~ifc~mixin~mb$の順序は、まだ明瞭に指定されていない
— 特に、`~ifc~mixin$が別々の文書~内に定義されている場合には。
`issue #432＠https://github.com/heycam/webidl/issues/432$href
にて論じられている。
◎
Member order isn’t clearly specified, in particular when interface mixins are defined in separate documents. It is discussed in issue #432.
</p>

<p>
`~includes文$に適用-可能な`拡張属性$は、この仕様には定義されていない。
◎
No extended attributes defined in this specification are applicable to includes statements.
</p>

<div class="example">

<p>
次の`~IDL片$は、［
`~ifc$ `Entry^T,
`~ifc~mixin$ `Observable^T
］を定義する。
`~includes文$は、［
`Observable^T の`~ifc~mixin~mb$は，
`Entry^T を実装している~objに常に内包される
］ことを指定する。
◎
The following IDL fragment defines an interface, Entry, and an interface mixin, Observable. The includes statement specifies that Observable’s members are always included on objects implementing Entry.
</p>

<pre class="webidl">
interface Entry {
  readonly attribute unsigned short entryType;
  /* <!--cp-some-code--> */
};

interface mixin Observable {
  void addEventListener(DOMString %type, EventListener %listener, boolean %useCapture);
  /* <!--cp-some-code--> */
};

Entry includes Observable;
</pre>

<p>
~ES実装は、各 `Entry^T ごとに，その原型鎖~内に
`addEventListener^jp ~propを有することになる：
◎
An ECMAScript implementation would thus have an addEventListener property in the prototype chain of every Entry:
</p>

<pre class="es-code">
var %e = getEntry();          /* <span class="comment">
`Entry^T の~instanceを得る。
◎
Obtain an instance of Entry.
</span> */
typeof %e.addEventListener;   /* <!--cp-eval-function--> */
</pre>
</div>

<data class="grammar" value="
CallbackOrInterfaceOrMixin
InterfaceOrMixin
Partial
PartialDefinition
MixinRest
MixinMembers
MixinMember
IncludesStatement
"></data>

			<section id="using-mixins-and-partials">
<h4 title="Using mixins and partials">2.3.1. ~mixinと~partialの利用-法</h4>

~INFORMATIVE

<p>
`~ifc~mixin$は、［
`属性$ ／ `定数$ ／ `演算$
］を，`複数^emの`~ifc$から共有できるようにする。
単独の~ifcを拡張したければ、代わりに`部分的~ifc$の利用を考えるであろう。
◎
Interface mixins allow the sharing of attributes, constants, and operations across multiple interfaces. If you’re only planning to extend a single interface, you might consider using a partial interface instead.
</p>

<p>
例えば，次に代えて：
◎
For example, instead of:
</p>

<pre class="webidl">
interface mixin WindowSessionStorage {
  readonly attribute Storage sessionStorage;
};
Window includes WindowSessionStorage;
</pre>

<p>
次にするなど：
◎
do:
</p>

<pre class="webidl">
partial interface Window {
  readonly attribute Storage sessionStorage;
};
</pre>

<p>
加えて，共通的な利用事例
— 一連の［
`属性$, `定数$, `演算$
］の集合を，
~window, ~worker
両~文脈に`公開され$るようにするなど —
を~~対象にするため、他の仕様により公開される`~ifc~mixin$を拡張することに依拠できる。
◎
Additionally, you can rely on extending interface mixins exposed by other specifications to target common use cases, such as exposing a set of attributes, constants, or operations across both window and worker contexts.
</p>

<p>
例えば、共通的にあるが冗長な，次のものに代えて：
◎
For example, instead of the common but verbose:
</p>

<pre class="webidl">
interface mixin GlobalCrypto {
  readonly attribute Crypto crypto;
};

Window includes GlobalCrypto;
WorkerGlobalScope includes GlobalCrypto;
</pre>

<p>
`部分的~ifc~mixin$を利用すれば，
`WindowOrWorkerGlobalScope$T `~ifc~mixin$を拡張できる：
◎
you can extend the WindowOrWorkerGlobalScope interface mixin using a partial interface mixin:
</p>

<pre class="webidl">
partial interface mixin WindowOrWorkerGlobalScope {
  readonly attribute Crypto crypto;
};
</pre>

			</section>
		</section>
		<section id="idl-callback-interfaces">
<h3 title="Callback interfaces">2.4. ~callback~ifc</h3>

<p>
`~callback~ifc@
は，［
`callback^sym `interface^sym `InterfaceRest$g
］に合致する`定義$であり、
`idl-objects$sec
にて述べるように，任意の~objがそれを実装し得る。
◎
A callback interface is a definition matching callback interface InterfaceRest. It can be implemented by any object, as described in § 2.12 Objects implementing interfaces.
</p>


<p class="note">注記：
`~callback~ifc$は、`~ifc$ではない。
この名前と構文にされているのは、その概念がもっと共通的にあった，この標準の早期の~versionによる~~名残である。
◎
Note: A callback interface is not an interface. The name and syntax are left over from earlier versions of this standard, where these concepts had more in common.
</p>

<p>
`~callback~ifc$は、その宣言における波括弧の合間に現れる，一連の`~mb$が成す集合（ `CallbackInterfaceMembers$g に合致-）の指定である。
これらの~mbは、
`~callback~ifc~mb@
と称される。
◎
A callback interface is a specification of a set of callback interface members (matching CallbackInterfaceMembers). These are the members that appear between the braces in the interface declaration.
</p>


<pre class="syntax">
callback interface `identifier^i {
  /* interface_members... */
};
</pre>

<p class="note">注記：
似た命名の`~callback関数$定義も見よ。
◎
Note: See also the similarly named callback function definition.
</p>

<p>
`~callback~ifc$は、正確に 1 個の`正則~演算$を定義しなければナラナイ。
◎
Callback interfaces must define exactly one regular operation.
</p>

<div class="advisement">

<p>
仕様~策定者は、既存の~APIの要件を述べるために要求されない限り，`~callback~ifc$を定義するべきでない。
代わりに，`~callback関数$が利用されるべきである。
◎
Specification authors should not define callback interfaces unless required to describe the requirements of existing APIs. Instead, a callback function should be used.
</p>

<p>
`~callback~ifc$である `EventListener$T の定義は、［
その~ifcを［
所与の~prop（この場合は `handleEvent^jp ）を伴う~obj
］により実装できるようにする必要がある
］ものと見なされている，既存の~APIの例である。
新たな~API, あるいは互換性の心配がない~API用の`~callback関数$には、（~ES言語束縛においては）`関数~obj$のみが許容されることになる。
◎
The definition of EventListener as a callback interface is an example of an existing API that needs to allow objects with a given property (in this case handleEvent) to be considered to implement the interface. For new APIs, and those for which there are no compatibility concerns, using a callback function will allow only a function object (in the ECMAScript language binding).
</p>

</div>

<p>
`定数$を宣言する`~callback~ifc$は、
`Exposed$r `拡張属性$で注釈されなければナラナイ。
◎
Callback interfaces which declare constants must be annotated with an [Exposed] extended attribute.
</p>

<data class="grammar" value="
CallbackRestOrInterface
CallbackInterfaceMembers
CallbackInterfaceMember
"></data>


		</section>
		<section id="idl-members">
<h3 title="Members">2.5. ~mb</h3>

<p>
［
`~ifc$ ／ `~ifc~mixin$ ／ `~ns$
］ %A は、その宣言を成す波括弧の合間に現れる，一連の
`~mb@
— ［
`定数$, `属性$, `演算$, その他の宣言
］ —
からなる集合（［
`InterfaceMembers$g ／ `MixinMembers$g ／ `NamespaceMembers$g
］に合致-）の指定である。
%A を実装している~objを %O とするとき
⇒＃
`属性$は、 %O が公開することになる状態を述べる。
`演算$は、 %O 上で呼出せる挙動を述べる。
`定数$は、 %O に公開される有名~定数~値を宣言する — ~systemにおける %O の利用者~用の便利として。
◎
Interfaces, interface mixins, and namespaces are specifications of a set of members (respectively matching InterfaceMembers, MixinMembers, and NamespaceMembers), which are the constants, attributes, operations, and other declarations that appear between the braces of their declarations. Attributes describe the state that an object implementing the interface, interface mixin, or namespace will expose, and operations describe the behaviors that can be invoked on the object. Constants declare named constant values that are exposed as a convenience to users of objects in the system.
</p>

<p class="note">注記：
所与の`~ifc$ %A が，ある`~ifc~mixin$を`内包-$している場合、その`~ifc~mixin~mb$も %A の~mbと見なされる。
対照的に， %A が`継承-$している`~ifc~mb$は、 %A の~mbとは見なされない。
◎
When an interface includes an interface mixin, each member of the interface mixin is also considered a member of the interface. In contrast, inherited interface members are not considered members of the interface.
</p>

<p>
`~ifc$または`~ifc~mixin$上に定義された各［
`正則~演算$取得子／
`正則~属性$取得子／
`正則~属性$設定子
］用の~algoを成す手続きは、
`this@V
値への~accessを持つ。
それは、当の~mbが［
`~ifc$上に宣言されているならば その~ifc型 ／
`~ifc~mixin$上に宣言されているならば それを`内包-$する【いずれかの】~ifc型
］の~IDL値である。
◎
The algorithm steps for every regular operation, regular attribute getter, and regular attribute setter’s defined on an interface or interface mixin have access to a this value, which is an IDL value of the interface type that the member is declared on or that includes the interface mixin the member is declared on.
</p>

<p class="trans-note">【
`概ね^em，~ES `this^jv 値に対応する。
他の仕様の和訳における “此れ” 。
】【
`this^V 値は、構築子に対しても定義される（`構築子~演算$を見よ）。
】</p>

<p>
各［
`属性$設定子
］用の~algoを成す手続きは、
`所与の値@
（ `given value^en ）への~accessを持つ。
それは、当の`属性$に宣言された型の~IDL値である。
【すなわち、属性の設定子に渡された値を~IDL値に変換した結果。】
◎
Attribute setter’s algorithm steps also have access to the given value, which is an IDL value of the type the attribute is declared as.
</p>

<p>
［
`~ifc$,
`~ifc~mixin$,
`~callback~ifc$,
`~ns$
］が~supportする`~mb$の~~種類は、それぞれに異なる
— それらは順に
`idl-interfaces$sec,
`idl-interface-mixins$sec,
`idl-callback-interfaces$sec,
`idl-namespaces$sec
にて指定され，次の表（参考）に要約される：
◎
Interfaces, interface mixins, callback interfaces and namespaces each support a different set of members, which are specified in § 2.2 Interfaces, § 2.3 Interface mixins, § 2.4 Callback interfaces, and § 2.6 Namespaces, and summarized in the following informative table:
</p>

<table><thead><tr><th>
<th>`~ifc$
<th>`~callback~ifc$
<th>`~ifc~mixin$
<th>`~ns$
</thead><tbody>

<tr><th>`定数$
<td>●
<td>●
<td>●
<td>

<tr><th>`正則~属性$
<td>●
<td>
<td>●
<td>`読専$な属性のみ

<tr><th>`静的~属性$
<td>●
<td>
<td>
<td>

<tr><th>`正則~演算$
<td>●
<td>●
<td>●
<td>●

<tr><th>`特殊~演算$
<td>●
<td>
<td>`文字列化子$のみ
<td>

<tr><th>`静的~演算$
<td>●
<td>
<td>
<td>

<tr><th>`非同期c可反復~宣言$
<td>●
<td>
<td>
<td>

<tr><th>`可反復~宣言$
<td>●
<td>
<td>
<td>

<tr><th>`~maplike 宣言$
<td>●
<td>
<td>
<td>

<tr><th>`~setlike 宣言$
<td>●
<td>
<td>
<td>
</tbody></table>

			<section id="idl-constants">
<h4 title="Constants">2.5.1. 定数</h4>

<p>
`定数@
は、定数~値を名前に束縛するために利用される，宣言（ `Const$g に合致-）である。
定数は［
`~ifc$／`~callback~ifc$
］に現れ得る。
◎
A constant is a declaration (matching Const) used to bind a constant value to a name. Constants can appear on interfaces and callback interfaces.
</p>

<p class="advisement">
過去においては，定数は、主に，有名~整数~codeを列挙する~styleで定義されていた。
~Web~platformは、文字列~利用の支持を受けて，この設計~patternから離れつつある。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use Constants$fI
した上で論交することを，強く勧める。
◎
Constants have in the past primarily been used to define named integer codes in the style of an enumeration. The Web platform is moving away from this design pattern in favor of the use of strings. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<pre class="syntax">
const `type^i `constant_identifier^i = 42;
</pre>

<p>
`定数$の`識別子$は、同じ［
`~ifc$／`~callback~ifc$
］上で定義される別の［
`~ifc~mb$／`~callback~ifc~mb$
］の識別子と同じになってはナラナイ。
また、識別子が［
`length^l ／ `name^l ／ `prototype^l
］になってはナラナイ。
◎
The identifier of a constant must not be the same as the identifier of another interface member or callback interface member defined on the same interface or callback interface. The identifier also must not be "length", "name" or "prototype".
</p>

<p class="note">注記：
これらの名前は、~ES言語束縛においては，`~ifc~obj$上に定義される~propの名前である。
◎
Note: These three names are the names of properties that are defined on the interface object in the ECMAScript language binding.
</p>

<p>
定数の型（ `ConstType$g に合致-）は、`~primitive型$でなければナラナイ。
`識別子$を利用する場合、その識別子は~primitive型の`~typedef$を参照しなければナラナイ。
◎
The type of a constant (matching ConstType) must not be any type other than a primitive type. If an identifier is used, it must reference a typedef whose type is a primitive type.
</p>

<div class="p">
<p>
定数~宣言の `ConstValue$g 部は定数の値を与え、次のいずれかとして与えられる：
</p>

<ul ><li>真偽~literal： `true^sym ／ `false^sym
</li><li>`integer$g
</li><li>`decimal$g
</li><li>特別な浮動小数点~定数~値： `-Infinity^sym ／ `Infinity^sym ／ `NaN^sym
</li></ul>

◎
The ConstValue part of a constant declaration gives the value of the constant, which can be one of the two boolean literal tokens (true and false), an integer token, a decimal token, or one of the three special floating point constant values (-Infinity, Infinity and NaN).
</div>

<p class="note">注記：
文字列や空~連列に加え，これらの値も［
辞書~mbの`既定~値$diCや, `随意~引数$の`既定~値$
］を指定するために利用できる。
［
文字列 ／
空~連列 `[]^sym ／
既定の辞書 `{}^sym
］は、`定数$の値には利用できないことに注意。
◎
Note: These values – in addition to strings and the empty sequence – can also be used to specify the default value of a dictionary member or of an optional argument. Note that strings, the empty sequence [], and the default dictionary {} cannot be used as the value of a constant.
</p>

<p>
真偽~literal~token［
`true^sym ／ `false^sym
］は、~IDL `boolean$T 値［
`true^V ／ `false^V
］になる。
◎
The value of the boolean literal tokens true and false are the IDL boolean values true and false.
</p>

<div class="algorithm">
<p>
`integer$g ~tokenの値は、それを成す文字~並び %S に対し，次に従って決定される整数~値になる：
◎
The value of an integer token is an integer whose value is determined as follows:
• Let S be the sequence of characters matched by the integer token.
</p>

<ol>
	<li>
%符号 ~LET 1
◎
↓</li>
	<li>
~IF［
%S の先頭の文字 ~EQ `002D^U1
］
⇒＃
%符号 ~SET −1；
%S から先頭の文字を除去する
◎
Let sign be −1 if S begins with U+002D HYPHEN-MINUS ("-"), and 1 otherwise.
</li>
	<li>
<p>
%基数 ~LET %S の頭部の文字~並びに応じて
⇒＃
`0X^l （ `0030^U1 `0058^U1 ）ならば 16 ／
`0x^l （ `0030^U1 `0078^U1 ）ならば 16 ／
`0030^U1 ならば 8 ／
~ELSE_ 10
◎
Let base be the base of the number based on the characters that follow the optional leading U+002D HYPHEN-MINUS ("-") character:
◎
U+0030 DIGIT ZERO ("0"), U+0058 LATIN CAPITAL LETTER X ("X")
U+0030 DIGIT ZERO ("0"), U+0078 LATIN SMALL LETTER X ("x")
• The base is 16.
U+0030 DIGIT ZERO ("0")
• The base is 8.
Otherwise
• The base is 10.
</li>
	<li>
~IF［
%基数 ~EQ 16
］
⇒
%S の先頭から 2 個の文字を除去する
◎
↓</li>
	<li>
%数 ~LET %S を基数 %基数 に基づいて整数に解釈した結果
◎
Let number be the result of interpreting all remaining characters following the optional leading U+002D HYPHEN-MINUS ("-") character and any characters indicating the base as an integer specified in base base.
</li>
	<li>
~RET %符号 ~MUL %数
◎
Return sign × number.
</li>
</ol>
</div>

<p>
`integer$g ~tokenの型は、それを値に利用している［
定数／辞書~mb／随意~引数
］の型と同じである。
`integer$g ~tokenの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入らなければナラナイ。
◎
The type of an integer token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the integer token must not lie outside the valid range of values for its type, as given in § 2.13 Types.
</p>

<div class="algorithm">
<p id="decimal-token-value">
`decimal$g ~tokenの値は、それを値に利用している［
定数／辞書~mb／随意~引数
］の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a decimal token is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument it is being used as the value for, determined as follows:
</p>

<ol>
	<li>
%S ~LET `decimal$g ~tokenに合致する文字~並び
◎
Let S be the sequence of characters matched by the decimal token.
</li>
	<li>
%結果 ~LET %S を~ES `NumericLiteral$i として構文解析して得られる `Mathematical Value^i
◎
Let result be the Mathematical Value that would be obtained if S were parsed as an ECMAScript NumericLiteral.
</li>
	<li>
<p>
`decimal$g ~tokenは どの型の値として利用されているかに応じて：
</p>
		<dl class="switch">
			<dt>`float$T</dt>
			<dt>`unrestricted float$T</dt>
			<dd>
~RET %結果 に最も近い IEEE 754 単精度 浮動小数点数
</dd>

			<dt>`double$T</dt>
			<dt>`unrestricted double$T</dt>
			<dd>
~RET %結果 に最も近い IEEE 754 倍精度 浮動小数点数
</dd>
		</dl>
<p>
`IEEE-754$r
</p>
◎
If the decimal token is being used as the value for a float or unrestricted float, then the value of the decimal token is the IEEE 754 single-precision floating point number closest to result.
◎
Otherwise, the decimal token is being used as the value for a double or unrestricted double, and the value of the decimal token is the IEEE 754 double-precision floating point number closest to result. [IEEE-754]
</li>
</ol>
</div>

<p>
`Infinity^sym, `-Infinity^sym, `NaN^sym
のいずれかとして指定された定数~値は、それを値に利用している［
定数／辞書~mb／随意~引数
］の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a constant value specified as Infinity, -Infinity or NaN is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument is is being used as the value for:
</p>

<dl class="switch">
	<dt>
`unrestricted float$T 型の定数~値 `Infinity^sym
◎
Type unrestricted float, constant value Infinity
</dt>
	<dd>
値は IEEE 754 単精度，正の無限大~値
◎
The value is the IEEE 754 single-precision positive infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `Infinity^sym
◎
Type unrestricted double, constant value Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，正の無限大~値
◎
The value is the IEEE 754 double-precision positive infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `-Infinity^sym
◎
Type unrestricted float, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 単精度，負の無限大~値
◎
The value is the IEEE 754 single-precision negative infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `-Infinity^sym
◎
Type unrestricted double, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，負の無限大~値
◎
The value is the IEEE 754 double-precision negative infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `NaN^sym
◎
Type unrestricted float, constant value NaN
</dt>
	<dd>
値は~bit~pattern `7fc00000^X の， IEEE 754 単精度 NaN
◎
The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `NaN^sym
◎
Type unrestricted double, constant value NaN
</dt>
	<dd>
値は~bit~pattern `7ff8000000000000^X の， IEEE 754 倍精度 NaN
◎
The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
</dd>
</dl>

<p>
`decimal$g ~tokenの型は、それを値に利用している［
定数／辞書~mb／随意~引数
］の型と同じになる。
`decimal$g ~tokenの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入らなければナラナイ。
また、［
`Infinity^sym, `-Infinity^sym, `NaN^sym
］が［
`float$T や `double$T
］の値として利用されてはナラナイ。
◎
The type of a decimal token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the decimal token must not lie outside the valid range of values for its type, as given in § 2.13 Types. Also, Infinity, -Infinity and NaN must not be used as the value of a float or double.
</p>

<p>
`null^sym ~tokenの値は、`~nullable型$に属する特別な `null^V 値である。
`null^sym ~tokenの型は、それを値に利用している［
定数／辞書~mb／随意~引数
］の型と同じになる。
◎
The value of the null token is the special null value that is a member of the nullable types. The type of the null token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of.
</p>

<p>
%VT を定数にあてがわれる値の型,
%DT を［
定数／辞書~mb／随意~引数
］自身の型とするとき、これらの型は互換，すなわち %DT と %VT が一致するか, または
%DT はその`内縁~型$が %VT であるような`~nullable型$でなければナラナイ。
◎
If VT is the type of the value assigned to a constant, and DT is the type of the constant, dictionary member or optional argument itself, then these types must be compatible, which is the case if DT and VT are identical, or DT is a nullable type whose inner type is VT.
</p>

<p>
`定数$は、それが現れる［
`~ifc$／`~callback~ifc$
］の特定0の~instanceには結付けられない。
`定数$が~instanceにも公開されるかどうかは、言語束縛に特有になる。
◎
Constants are not associated with particular instances of the interface or callback interface on which they appear. It is language binding specific whether constants are exposed on instances.
</p>

<div class="note">

<p>
~ES言語束縛では，しかしながら、`定数$が宣言されている~IDL`~ifc$を実装する~objを通して，`定数$への~accessが許容される。
例えば次の~IDLでは：
◎
The ECMAScript language binding does however allow constants to be accessed through objects implementing the IDL interfaces on which the constants are declared. For example, with the following IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  const short rambaldi = 47;
};
</pre>

<p>
~ESにおいては、この定数~値は，［
`A.rambaldi^c および (`A^T の~instance)`.rambaldi^c
］として~accessできる。
◎
the constant value can be accessed in ECMAScript either as A.rambaldi or instanceOfA.rambaldi.
</p>
</div>

<p>
定数に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to constants: [Exposed], [SecureContext].
</p>

<data class="grammar" value="
Const
ConstValue
BooleanLiteral
FloatLiteral
ConstType
"></data>

<div class="example">
<p>
次の`~IDL片$に、上の型の`定数$を定義する例を示す。
◎
The following IDL fragment demonstrates how constants of the above types can be defined.
</p>

<pre class="webidl">
[Exposed=Window]
interface Util {
  const boolean DEBUG = false;
  const octet LF = 10;
  const unsigned long BIT_MASK = 0x0000fc00;
  const double AVOGADRO = 6.022e23;
};
</pre>

</div>
			</section>
			<section id="idl-attributes">
<h4 title="Attributes">2.5.2. 属性</h4>

<p>
`属性@
（
`inherit^sym `AttributeRest$g ／
`static^sym `ReadOnly$g `AttributeRest$g ／
`stringifier^sym `ReadOnly$g `AttributeRest$g ／
`ReadOnly$g `AttributeRest$g ／
`AttributeRest$g
いずれかに合致-）は、［
`~ifc~mb$／`~ns~mb$
］であり，次を宣言するために利用される
⇒
当の［
`~ifc$／`~ns$
］を実装している~objは、所与の［
型, `識別子$
］により，値を［
検索取得できる／（一部の場合は）変更できる
］~data~fieldを持つ。
◎
An attribute is an interface member or namespace member (matching inherit AttributeRest, static ReadOnly AttributeRest, stringifier ReadOnly AttributeRest, ReadOnly AttributeRest, or AttributeRest) that is used to declare data fields with a given type and identifier whose value can be retrieved and (in some cases) changed.＼
</p>

<p>
`属性$は、次の 2 種類に分けられる：
◎
There are two kinds of attributes:
</p>

<ul>
	<li>
<p>
`正則~属性$は、次を宣言するために利用される
⇒
当の［
~ifc／~ns
］を実装している~objは、所与の`識別子$を伴う~data~field~mbを持つ
◎
regular attributes, which are those used to declare that objects implementing the interface will have a data field member with the given identifier
</p>

<pre class="syntax">
interface `interface_identifier^i {
  attribute `type^i `identifier^i;
};
</pre>

	</li>
	<li>
<p>
`静的~属性$は、次を宣言するために利用される
⇒
当の~ifcを実装している特定0の~objには結付けられない属性
◎
static attributes, which are used to declare attributes that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
interface `interface_identifier^i {
  static attribute `type^i `identifier^i;
};
</pre>

	</li>
</ul>

<p>
`static^sym ~keywordを伴わない属性は
`正則~属性@
を宣言する。
そうでなければ，`静的~属性$を宣言する。
`読専$な`正則~属性$には、`~ifc~mb$の他に，`~ns~mb$もあることに注意。
◎
If an attribute has no static keyword, then it declares a regular attribute. Otherwise, it declares a static attribute. Note that in addition to being interface members, read only regular attributes can be namespace members as well.
</p>

<div class="algorithm">
<p>
`属性の下層~値を取得する@
ときは、所与の
( %~target, 属性 %属性 )
に対し，次を走らす：
◎
To get the underlying value of an attribute attr given a value target,＼
</p>

<ol>
	<li>
~RET ［
%属性 は`取得子を継承する$ものと宣言されている場合は 継承されている属性 ／
~ELSE_ %属性
］の取得子の記述に挙げられている動作
］を［
%~target ~NEQ `null^V ならば `this$V として %~target
］を与える下で遂行した結果
◎
return the result of performing the actions listed in the description of attr that occur on getting, or those listed in the description of the inherited attribute, if attr is declared to inherit its getter, with target as this if it is not null.
</li>
</ol>

</div>

<p>
`属性$の`識別子$は［
同じ`~ifc$上に定義される別の`~ifc~mb$の識別子
］と同じになってはナラナイ。
静的~属性の識別子が `prototype^l になってはナラナイ。
◎
The identifier of an attribute must not be the same as the identifier of another interface member defined on the same interface. The identifier of a static attribute must not be "prototype".
</p>

<p>
属性の型は、 `attribute^sym ~keywordの後に現れる型（ `Type$g に合致-）で与えられる。
`Type$g が［
`識別子$, または `?^sym が後続する識別子
］である場合、その識別子は［
`~ifc$／`列挙$／`~callback関数$／`~callback~ifc$／`~typedef$
］を識別しなければナラナイ。
◎
The type of the attribute is given by the type (matching Type) that appears after the attribute keyword. If the Type is an identifier or an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function, callback interface or typedef.
</p>

<p>
属性の型は、~typedefの解決-後に，次に挙げる型, あるいはその`~nullable型$になってはナラナイ。
◎
The type of the attribute, after resolving typedefs, must not be a nullable or non-nullable version of any of the following types:
</p>

<ul id="cp-nullable-type-list">
	<li>
`連列~型$
◎
a sequence type
</li>
	<li>
`辞書~型$
◎
a dictionary type
</li>
	<li>
`~record型$
◎
a record type
</li>
	<li>
その`平坦~化~mb型$に［
［ ~nullable／非~nullable ］の連列~型 ／ 辞書 ／ ~record【！区切り？】
］を含んでいるような，`共用体~型$
【平坦~化~mb型は~nullableを含み得ないので，この “~nullable” の記述は不要では？】
◎
a union type that has a nullable or non-nullable sequence type, dictionary, or record as one of its flattened member types
</li>
</ul>

<p>
`attribute^sym ~keywordの前に `readonly^sym ~keywordが利用されている場合、属性は
`読専@（ `read only^en, 読み取りのみ）
になる。
［
読専の属性が定義されている~ifc
］を実装する~objにおいては、その属性に対する代入は許容されないことになる。
代入が、単に言語において許容されないのか,
無視されるのか,
あるいは例外が投出されるのか，については、言語束縛に特有になる。
◎
The attribute is read only if the readonly keyword is used before the attribute keyword. An object that implements the interface on which a read only attribute is defined will not allow assignment to that attribute. It is language binding specific whether assignment is simply disallowed by the language, ignored or an exception is thrown.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly attribute `type^i `identifier^i;
};
</pre>

<p>
`~promise型$である属性は、`読専$でなければナラナイ。
加えて、次の`拡張属性$は持てない
⇒
`LenientSetter$x,
`PutForwards$x,
`Replaceable$x,
`SameObject$x
◎
Attributes whose type is a promise type must be read only. Additionally, they cannot have any of the extended attributes [LenientSetter], [PutForwards], [Replaceable], or [SameObject].
</p>

<p>
`読専$でない`正則~属性$は、先祖の~ifcからその
`取得子を継承する@
ように宣言できる。
これにより、先祖~ifcの読専の属性を，派生~ifc上で~writableにできる。
属性は、その宣言が `inherit^sym を伴うとき，`取得子を継承する$ものとされる。
その属性が取得子を継承する読専の属性は、［
同じ識別子の属性が定義されている，先祖の~ifc
］のうち，最も末端の~ifcに属する属性である。
【！readonlyとは限らない？】
取得子を［
継承する側, される側
］の属性の型は同じでなければナラナイ。
◎
A regular attribute that is not read only can be declared to inherit its getter from an ancestor interface. This can be used to make a read only attribute in an ancestor interface be writable on a derived interface. An attribute inherits its getter if its declaration includes inherit in the declaration. The read only attribute from which the attribute inherits its getter is the attribute with the same identifier on the closest ancestor interface of the one on which the inheriting attribute is defined. The attribute whose getter is being inherited must be of the same type as the inheriting attribute.
</p>

<p class="note">注記：
`inherit^sym が［
`読専$な属性／`静的~属性$
］に現れることはない
— それは、文法により確保される。
◎
Note: The grammar ensures that inherit does not appear on a read only attribute or a static attribute.
</p>

<pre class="syntax">
[Exposed=Window]
interface `Ancestor^i {
  readonly attribute `TheType^i `theIdentifier^i;
};

[Exposed=Window]
interface `Derived^i : `Ancestor^i {
  inherit attribute `TheType^i `theIdentifier^i;
};
</pre>

<p>
`正則~属性$の宣言に `stringifier^sym ~keywordが利用されている場合、［
その~ifcを実装している~objを文字列~化するときは、その属性の値になる
］ことを指示する。
詳細は
`idl-stringifiers$sec
を見よ。
◎
When the stringifier keyword is used in a regular attribute declaration, it indicates that objects implementing the interface will be stringified to the value of the attribute. See § 2.5.5.1 Stringifiers for details.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<p>
［
`正則~属性$／`静的~属性$
］に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`SameObject$x,
`SecureContext$x
◎
The following extended attributes are applicable to regular and static attributes: [Exposed], [SameObject], [SecureContext].
</p>

<p>
次の`拡張属性$は、`正則~属性$にしか適用-可能でない
⇒
`LenientSetter$x,
`LenientThis$x,
`PutForwards$x,
`Replaceable$x,
`Unforgeable$x
◎
The following extended attributes are applicable only to regular attributes: [LenientSetter], [LenientThis], [PutForwards], [Replaceable], [Unforgeable].
</p>

<data class="grammar" value="
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteAttribute
AttributeRest
AttributeName
AttributeNameKeyword
ReadOnly
"></data>

<div class="example">
<p>
次の`~IDL片$に，`~ifc$上にて`属性$を宣言する例を示す：
◎
The following IDL fragment demonstrates how attributes can be declared on an interface:
</p>

<pre class="webidl">
[Exposed=Window]
interface Animal {

  /* <span class="comment">
単純な，任意の文字列に設定され得る属性。
◎
A simple attribute that can be set to any string value.
</span> */
  readonly attribute DOMString name;

  /* <span class="comment">
値を代入できる属性。
◎
An attribute whose value can be assigned to.
</span> */
  attribute unsigned short age;
};

[Exposed=Window]
interface Person : Animal {

  /* <span class="comment">
取得子の挙動を `Animal^T から継承する属性。
`Person^T の記述にて指定する必要はない。
◎
An attribute whose getter behavior is inherited from Animal, and need not be specified in the description of Person.
</span> */
  inherit attribute DOMString name;
};
</pre>
</div>
			</section>
			<section id="idl-operations">
<h4 title="Operations">2.5.3. 演算</h4>

<p>
`演算@
（
`static^sym `RegularOperation$g ／
`stringifier^sym `RegularOperation$g ／
`RegularOperation$g ／
`SpecialOperation$g
いずれかに合致-）は、［
`~ifc~mb$／`~callback~ifc~mb$／`~ns~mb$
］であり，当の［
`~ifc$／`~callback~ifc$／`~ns$
］を実装している~obj上で呼出せる挙動を定義する。
◎
An operation is an interface member, callback interface member or namespace member (matching static RegularOperation, stringifier RegularOperation, RegularOperation or SpecialOperation) that defines a behavior that can be invoked on objects implementing the interface.＼
</p>

<p>
演算には次の 3 種類がある：
◎
There are three kinds of operation:
</p>

<ul>
	<li>
<p>
`正則~演算$は、次を宣言するために利用される
⇒
当の［
~ifc／~ns
］を実装している~objは、所与の`識別子$を伴う~methを持つ
◎
regular operations, which are those used to declare that objects implementing the interface will have a method with the given identifier
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>

	</li>
	<li>
<p>
`特殊~演算$は、次を宣言するために利用される
⇒
~objの~index法や文字列~化などの，当の~ifcを実装している~obj上の特殊な挙動
◎
special operations, which are used to declare special behavior on objects implementing the interface, such as object indexing and stringification
</p>

<pre class="syntax">
interface `interface_identifier^i {
  /* special_keyword */ `return_type^i `identifier^i(/* arguments... */);
  /* special_keyword */ `return_type^i (/* arguments... */);
};
</pre>

	</li>
	<li>
<p>
`静的~演算$は、次を宣言するために利用される
⇒
当の~ifcを実装している特定0の~objには結付けられない演算
◎
static operations, which are used to declare operations that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
interface `interface_identifier^i {
  static `return_type^i `identifier^i(/* arguments... */);
};
</pre>

	</li>
</ul>

<p>
演算のうち，［
識別子を持つ
］~AND［
`static^sym ~keywordは伴わない
］ものは、
`正則~演算@
を宣言する。
`特殊~keyword$（すなわち，［
`Special$g に合致する~keyword, または
`stringifier^sym ~keyword
］）が宣言に利用されている演算は，`特殊~演算$を宣言する。
演算を，正則~演算と特殊~演算を兼ねるように宣言することもできる。
特殊~演算についての詳細は、
`idl-special-operations$sec
を見よ。
`正則~演算$には、`~ifc~mb$以外にも，`~callback~ifc~mb$や`~ns~mb$であるものもあることに注意。
◎
If an operation has an identifier but no static keyword, then it declares a regular operation. If the operation has a special keyword used in its declaration (that is, any keyword matching Special, or the stringifier keyword), then it declares a special operation. A single operation can declare both a regular operation and a special operation; see § 2.5.5 Special operations for details on special operations. Note that in addition to being interface members, regular operations can also be callback interface members and namespace members.
</p>

<p>
識別子を持たない演算は、いずれかの特殊~keywordを利用して，`特殊~演算$として宣言されなければナラナイ。
◎
If an operation has no identifier, then it must be declared to be a special operation using one of the special keywords.
</p>

<p>
`正則~演算$や`静的~演算$の識別子は、同じ［
`~ifc$／`~callback~ifc$／`~ns$
］上に定義される`定数$や`属性$の識別子と同じになってはナラナイ。
静的~演算の識別子は `prototype^l になってはナラナイ。
◎
The identifier of a regular operation or static operation must not be the same as the identifier of a constant or attribute defined on the same interface, callback interface or namespace. The identifier of a static operation must not be "prototype".
</p>

<p class="note">注記：
しかしながら、識別子をその~ifc上の別の演算と同じにすることはできる。
演算の多重定義は、これにより指定される。
◎
Note: The identifier can be the same as that of another operation on the interface, however. This is how operation overloading is specified.
</p>

<p>
`静的~演算$の`識別子$は、同じ`~ifc$上に定義される`正則~演算$の識別子と同じになってはナラナイ。
◎
The identifier of a static operation also must not be the same as the identifier of a regular operation defined on the same interface.
</p>

<p>
演算の
`返り値~型@
（ `ReturnType$g に合致-）は、［
随意な［
演算の`識別子$
］］の前に現れる型で与えられる。
返り値~型 `void$T は、演算は値を返さないことを指示する。
返り値~型が `?^sym 付きの`識別子$である場合、その識別子は［
`~ifc$／`辞書$／`列挙$／`~callback関数$／`~callback~ifc$／`~typedef$
］を識別しなければナラナイ。
◎
The return type of the operation is given by the type (matching ReturnType) that appears before the operation’s optional identifier. A return type of void indicates that the operation returns no value. If the return type is an identifier followed by ?, then the identifier must identify an interface, dictionary, enumeration, callback function, callback interface or typedef.
</p>

<p>
演算の引数たち（ `ArgumentList$g に合致-）は、宣言の中の丸括弧の合間にて与えられる。
各 引数は、型（ `Type$g に合致-）の後に
`識別子$（ `ArgumentName$g に合致-）を続けて指定される。
◎
An operation’s arguments (matching ArgumentList) are given between the parentheses in the declaration. Each individual argument is specified as a type (matching Type) followed by an identifier (matching ArgumentName).
</p>

<p class="note">注記：
表出力のため、演算~引数の識別子には， `ArgumentNameKeyword$g 記号に合致する~keywordも，~escapeを要することなく 指定できる。
【！＊】
◎
Note: For expressiveness, the identifier of an operation argument can also be specified as one of the keywords matching the ArgumentNameKeyword symbol without needing to escape it.
</p>

<div class="p">
<p>
演算~引数の型を与える `Type$g が：
</p>
<ul>
	<li>
`?^sym が後続する`識別子$である場合、その識別子は［
`~ifc$／`列挙$／`~callback関数$／`~callback~ifc$／`~typedef$
］を識別しなければナラナイ。
</li>
	<li>
`?^sym が後続しない`識別子$である場合、その識別子は［
`辞書$／前項に挙げたいずれかの定義
］を識別しなければナラナイ。
</li>
</ul>

◎
If the Type of an operation argument is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function, callback interface, or typedef. If the operation argument type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</div>

<p>
演算~引数の型が`~typedef$の解決-後に`~nullable型$になる場合、その`内縁~型$は`辞書~型$になってはナラナイ。
◎
If the operation argument type, after resolving typedefs, is a nullable type, its inner type must not be a dictionary type.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i `identifier^i /* , ... */);
};
</pre>

<p>
各~引数の識別子は、同じ演算~宣言~内の他の引数の識別子と同じになってはナラナイ。
◎
The identifier of each argument must not be the same as the identifier of another argument in the same operation declaration.
</p>

<p>
各~引数の前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致-）を置くことができる
— それらは、その引数として渡された値が，言語束縛において どう取扱われるかを制御する。
◎
Each argument can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how a value passed as the argument will be handled in language bindings.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i([`extended_attributes^mk] `type^i `identifier^i, [`extended_attributes^mk] `type^i `identifier^i /* , ... */);
};
</pre>

<div class="example">
<p>
次の`~IDL片$は
`~ifc$上に`正則~演算$を宣言する：
◎
The following IDL fragment demonstrates how regular operations can be declared on an interface:
</p>

<pre class="webidl">
[Exposed=Window]
interface Dimensions {
  attribute unsigned long width;
  attribute unsigned long height;
};

[Exposed=Window]
interface Button {

  /* <span class="comment">
引数をとらず, `boolean^T を返す演算
◎
An operation that takes no arguments and returns a boolean.
</span> */
  boolean isMouseOver();

  /* <span class="comment">
多重定義された演算。
◎
Overloaded operations.
</span> */
  void setDimensions(Dimensions %size);
  void setDimensions(unsigned long %width, unsigned long %height);
};
</pre>
</div>

<p>
［
演算／`構築子~演算$
］の 最後の引数 の引数~型の直後に `...^sym ~tokenが利用されている場合、その演算は
`可変個的な@
もの（ `variadic^en ）と見なされ、その最後の引数を指して
`可変個~引数@
という
【この用語は、参照し易くするため，この訳に導入している】
。
そのように宣言された演算は：
◎
An operation or constructor operation is considered to be variadic if the final argument uses the ... token just after the argument type.＼
</p>

<ul>
	<li>
`可変個~引数$の後に，任意~個数の引数を伴って呼出せることを指示し、それらの余分な暗黙の正式な引数の型は，`可変個~引数$と同じ型と見なされる。
◎
Declaring an operation to be variadic indicates that the operation can be invoked with any number of arguments after that final argument. Those extra implied formal arguments are of the same type as the final explicit argument in the operation declaration.＼
</li>
	<li>
呼出すときには、`可変個~引数$も省略できる。
◎
The final argument can also be omitted when invoking the operation.＼
</li>
	<li>
`可変個~引数$以外の引数は `...^sym ~tokenを伴って宣言されてはナラナイ。
◎
An argument must not be declared with the ... token unless it is the final argument in the operation’s argument list.
</li>
</ul>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i`...^em `identifier^i);
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i`...^em `identifier^i);
};
</pre>

<p>
`引数~listを引数にとる$`拡張属性$（この仕様に定義される `NamedConstructor$x ）, および
`~callback関数$についても、その引数~listに `...^sym ~tokenが利用されているならば，`可変個的な$ものと見なされる。
【以下の記述における可変個的な演算の “演算” には，これらの（構築子を与える）拡張属性や~callbackも含まれる。】
◎
Extended attributes that take an argument list ([NamedConstructor], of those defined in this specification) and callback functions are also considered to be variadic when the ... token is used in their argument lists.
</p>

<div class="example">
<p>
次の`~IDL片$は，可変個的な演算を 2 つ持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two variadic operations:
</p>

<pre class="webidl">
[Exposed=Window]
interface IntegerSet {
  readonly attribute unsigned long cardinality;

  void union(long... %ints);
  void intersection(long... %ints);
};
</pre>

<p>
~ES言語束縛においては、可変個的な演算は，後続の引数を受容できる関数により実装される：
◎
In the ECMAScript binding, variadic operations are implemented by functions that can accept the subsequent arguments:
</p>

<pre class="es-code">
var %s = getIntegerSet();  /* <span class="comment">
`IntegerSet^T の~instanceを得る。
◎
Obtain an instance of IntegerSet.
</span> */

%s.union();                /* <span class="comment">
`ints^l に対応する引数を~~省略。
◎
Passing no arguments corresponding to 'ints'.
</span> */
%s.union(1, 4, 7);         /* <span class="comment">
`ints^l に対応する 3 個の引数を渡す。
◎
Passing three arguments corresponding to 'ints'.
</span> */
</pre>

<p>
可変個的な関数を~supportしない言語~用の言語束縛においては、その種の演算には，整数の 配列または~list を明示的に渡すように指定することになるであろう。
◎
A binding for a language that does not support variadic functions might specify that an explicit array or list of integers be passed to such an operation.
</p>
</div>

<p>
`optional^sym ~keywordを伴って宣言された引数は、
`随意~引数@
であるものと見なされる。
`可変個的な$演算の`可変個~引数$も随意~引数と見なされる。
随意として宣言された引数は、［
演算を呼出すときに，その値を省略できる
］ことを指示する。
`可変個~引数$は、明示的に随意として宣言されてはナラナイ。
◎
An argument is considered to be an optional argument if it is declared with the optional keyword. The final argument of a variadic operation is also considered to be an optional argument. Declaring an argument to be optional indicates that the argument value can be omitted when the operation is invoked. The final argument in an operation must not explicitly be declared to be optional if the operation is variadic.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i);
};
</pre>

<p>
随意~引数には
`既定~値@
を指定できる。
引数の識別子に `003D^U1 と値（ `DefaultValue$g に合致-）が後続している場合、その値がその随意~引数の`既定~値$を与える。
ただし、`可変個的な$演算の`可変個~引数$には、既定~値が指定されてはナラナイ。
既定~値は、対応する引数が省略されて演算が~callされたときに，その引数がとる値と見做される。
◎
Optional arguments can also have a default value specified. If the argument’s identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the optional argument its default value. The implicitly optional final argument of a variadic operation must not have a default value specified. The default value is the value to be assumed when the operation is called with the corresponding argument omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i = "`value^i");
};
</pre>

<p class="advisement">
`boolean$T 型の引数には、`既定~値$として `true^V を利用しないことが強く示唆される。
さもなければ、 `undefined^jv に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
It is strongly suggested not to use a default value of true for boolean-typed arguments, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>

<p>
次をすべて満たす引数は、随意として指定され，既定~値が供されなければナラナイ。
◎
If＼
</p>

<ul>
	<li>
引数の型は、［
`辞書~型$である
］~OR［
`共用体~型$であって，その`平坦~化~mb型$に ある`辞書~型$を含んでいる
］
◎
the type of an argument is a dictionary type or a union type that has a dictionary type as one of its flattened member types, and＼
</li>
	<li>
前項の辞書~型と その先祖には、必須の~mbは無い
◎
that dictionary type and its ancestors have no required members, and＼
</li>
	<li>
［
引数は最後の引数である
］~OR［
引数に後続するどの引数も`随意~引数$である
］
◎
the argument is either the final argument or is followed only by optional arguments,＼
</li>
</ul>

<p>
【そのような辞書の各~mbは、`既定~値$diCがあれば それをとるものと扱われることになる。】
◎
then the argument must be specified as optional and have a default value provided.
</p>

<p class="note">注記：
これは、作者が辞書の既定~値のみの利用を望むときでも，空の辞書~値を渡さずに済むような~APIの設計を促すためにある。
◎
This is to encourage API designs that do not require authors to pass an empty dictionary value when they wish only to use the dictionary’s default values.
</p>

<p class="note">注記：
通例的に，供される既定~値は `{}^sym になるが、`共用体~型$であって，その`平坦~化~mb型$が`辞書~型$を含んでいる事例では、共用体の他の何らかの~mbを初期化する既定~値を供することもできる。
◎
Usually the default value provided will be {}, but in the case of a union type that has a dictionary type as one of its flattened member types a default value could be provided that initializes some other member of the union.
</p>

<p>
`既定~値$に［
`ConstValue$g ／ `null^sym
］が利用された場合、`定数$に対するときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a decimal token or one of the three special floating point literal values (Infinity, -Infinity or NaN) is used as the default value, it is interpreted in the same way as for a constant.
</p>

<div class="algorithm">
<p id="string-literal">
随意~引数の既定~値には、 `string$g ~tokenも指定できる。
それは、次に従って決定される`文字列~型$の
`値@stR
をとる：
◎
Optional argument default values can also be specified using a string token, whose value is a string type determined as follows:
</p>

<ol>
	<li>
%S ~LET `string$g ~tokenに合致する［
`~Unicode~scalar値$の並び
］から，先頭と末尾の文字 `0022^U1 を除去したもの
◎
Let S be the sequence of Unicode scalar values matched by the string token with its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
</li>
	<li>
<p>
`string$g ~tokenの値は、引数の型に応じて，次で与えられる：
◎
Depending on the type of the argument:
</p>

<dl class="switch">
	<dt>`DOMString$T</dt>
	<dt>`列挙$ 型</dt>
	<dd>
%S を~UTF-16符号化した結果に対応する， 16 ~bit無符号~整数~符号単位
— 以下、単に
`符号単位@
と略称される —
の並び
◎
The value of the string token is the sequence of 16 bit unsigned integer code units (hereafter referred to just as code units) corresponding to the UTF-16 encoding of S.
</dd>
	<dt>`ByteString$T</dt>
	<dd>
%S を~UTF-8符号化した結果に対応する， 8 ~bit無符号~整数~符号単位の並び
◎
The value of the string token is the sequence of 8 bit unsigned integer code units corresponding to the UTF-8 encoding of S.
</dd>
	<dt>`USVString$T</dt>
	<dd>
%S
◎
The value of the string token is S.
</dd>
</dl>
	</li>
</ol>
</div>

<p>
`随意~引数$の型が`列挙$である場合、その`既定~値$に指定される値は，その列挙を成すいずれかの`列挙~値$でなければナラナイ。
◎
If the type of the optional argument is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>

<p>
`連列~型$（`~nullable$も含む）の随意~引数の既定~値には、［
2 個の~tokenが成す値 `[]^sym
］を利用して，［
その型と同じ型の空~連列~値
］を表現する値も指定できる。
この既定~値の型は、次のいずれかでなければナラナイ
⇒＃
`連列~型$ ／
`~nullable$であって その`内縁~型$は`連列~型$であるもの ／
`共用体~型$または`~nullable$なそれであって その`平坦~化~mb型$は`連列~型$を含むもの
◎
Optional argument default values can also be specified using the two token value [], which represents an empty sequence value. The type of this value is the same as the type of the optional argument it is being used as the default value of. That type must be a sequence type, a nullable type whose inner type is a sequence type or a union type or nullable union type that has a sequence type in its flattened member types.
</p>

<p>
`辞書~型$の随意~引数の既定~値には、［
2 個の~tokenが成す値 `{}^sym
］を利用して，［
その型と同じ型の辞書~値であって，【各~mbが】既定に初期化されるもの
【！(as if from ES null or an object with no properties)】
］を表現する値も指定できる。
この既定~値の型は、次のいずれかでなければナラナイ
⇒＃
`辞書~型$ ／
`共用体~型$であって その`平坦~化~mb型$は`辞書~型$を含むもの
◎
Optional argument default values can also be specified using the two token value {}, which represents a default-initialized (as if from ES null or an object with no properties) dictionary value. The type of this value is the same as the type of the optional argument it is being used as the default value of. That type must be a dictionary type, or a union type that has a dictionary type in its flattened member types.
</p>

<div class="example">
<p>
次の`~IDL片$が定義する`~ifc$は、［
2 通りの引数~list長さで呼出せる， 1 個の`演算$
］を伴う：
◎
The following IDL fragment defines an interface with a single operation that can be invoked with two different argument list lengths:
</p>

<pre class="webidl">
[Exposed=Window]
interface ColorCreator {
  object createColor(double %v1, double %v2, double %v3, optional double %alpha);
};
</pre>

<p>
それは、［
`多重定義$された 2 個の`演算$
］を伴う，次の`~ifc$と等価になる：
◎
It is equivalent to an interface that has two overloaded operations:
</p>

<pre class="webidl">
[Exposed=Window]
interface ColorCreator {
  object createColor(double %v1, double %v2, double %v3);
  object createColor(double %v1, double %v2, double %v3, double %alpha);
};
</pre>
</div>

<div class="example">
<p>
次の`~IDL片$は、辞書~引数をとる演算を伴う`~ifc$を定義する：
◎
The following IDL fragment defines an interface with an operation that takes a dictionary argument:
</p>

<pre class="webidl">
dictionary LookupOptions {
  boolean caseSensitive = false;
};

[Exposed=Window]
interface AddressBook {
  boolean hasAddressForName(USVString %name, optional LookupOptions %options = {});
};</pre>

<p>
`hasAddressForName()^M が 1 個の引数のみで~callされた場合、
2 個目の引数は，既定に初期化される `LookupOptions^T 辞書になり，その
`caseSensitive^M は `false^V に設定されることになる。
◎
If hasAddressForName is called with only one argument, the second argument will be a default-initialized LookupOptions dictionary, which will cause caseSensitive to be set to false.
</p>
</div>

<p>
演算に適用-可能な拡張属性は
⇒＃
`Default$x,
`Exposed$x,
`NewObject$x,
`SecureContext$x,
`Unforgeable$x
◎
The following extended attributes are applicable to operations: [Default], [Exposed], [NewObject], [SecureContext], [Unforgeable].
</p>

<data class="grammar" value="
DefaultValue
Operation
RegularOperation
SpecialOperation
Special
OperationRest
OptionalOperationName
OperationName
OperationNameKeyword
ArgumentList
Arguments
Argument
ArgumentRest
ArgumentName
Ellipsis
ArgumentNameKeyword
ReturnType
"></data>

				<section id="idl-tojson-operation">
<h5 title="toJSON">2.5.3.1. ~toJSON</h5>

<p>
~toJSON`正則~演算$を宣言することにより、`~ifc$は，それを実装する~objを`~JSON型$に変換する方法を指定する。
◎
By declaring a toJSON regular operation, an interface specifies how to convert the objects that implement it to JSON types.
</p>

<p>
~toJSON`正則~演算$は、この用法のために予約される。
それは、
0 個の引数をとり，`~JSON型$を返さなければナラナイ。
◎
The toJSON regular operation is reserved for this usage. It must take zero arguments and return a JSON type.
</p>

<p>
次に挙げる型が
`~JSON型@
とされる：
◎
The JSON types are:
</p>

<ul>
	<li>
`数量-型$
◎
numeric types,
</li>
	<li>
`boolean$T 型
◎
boolean,
</li>
	<li>
`文字列~型$
◎
string types,
</li>
	<li>
`~nullable型$のうち，その`内縁~型$は`~JSON型$であるもの
◎
nullable types whose inner type is a JSON type,
</li>
	<li>
`注釈付きの型$のうち，その`内縁~型$anOは`~JSON型$であるもの
◎
annotated types whose inner type is a JSON type,
</li>
	<li>
`共用体~型$のうち，その どの`~mb型$も`~JSON型$であるもの
◎
union types whose member types are JSON types,
</li>
	<li>
`~typedef$のうち，それにより`新たな名前が与えられる型$は`~JSON型$であるもの
◎
typedefs whose type being given a new name is a JSON type,
</li>
	<li>
`連列~型$のうち，その~parameter化された型は`~JSON型$であるもの
◎
sequence types whose parameterized type is a JSON type,
</li>
	<li>
`凍結d配列~型$のうち，その~parameter化された型は`~JSON型$であるもの
◎
frozen array types whose parameterized type is a JSON type,
</li>
	<li>
`辞書~型$のうち，［
自身／自身が`継承した辞書たち$
］に宣言された どの`辞書~mb$の型も`~JSON型$であるもの
◎
dictionary types where the types of all members declared on the dictionary and all its inherited dictionaries are JSON types,
</li>
	<li>
`~record型$のうち，そのすべての`値$は`~JSON型$であるもの
◎
records where all of their values are JSON types,
</li>
	<li>
`object$T 型
◎
object,
</li>
	<li>
`~ifc型$のうち，［
自身または`継承した~ifcたち$
］上に~toJSON演算が宣言されているもの
◎
interface types that have a toJSON operation declared on themselves or one of their inherited interfaces.
</li>
</ul>

<p>
言語束縛において~toJSON`正則~演算$を~obj上でどう可用にするか, および
`~JSON型$を~JSON文字列に正確にどう変換するかは、言語束縛に特有になる。
◎
How the toJSON regular operation is made available on an object in a language binding, and how exactly the JSON types are converted into a JSON string, is language binding specific.
</p>

<p class="note">注記：
~ES言語束縛においては、これは，~toJSON~methを公開することにより行われる
— この~methは、`~JSON型$を［
`JSON.stringify()$c 関数により~JSON文字列に転換できるような，~ES値
］に変換して返す。
加えて，~ES言語束縛においては、~toJSON演算は `Default$x `拡張属性$をとれる
— その事例では、代わりに `既定の~toJSON演算$が公開される。
◎
Note: In the ECMAScript language binding, this is done by exposing a toJSON method which returns the JSON type converted into an ECMAScript value that can be turned into a JSON string by the JSON.stringify() function. Additionally, in the ECMAScript language binding, the toJSON operation can take a [Default] extended attribute, in which case the default toJSON operation is exposed instead.
</p>

<div class="example" id="tojson-example">

<p>
次の`~IDL片$は、~toJSON~methを持つような `Transaction^T ~ifcを定義する
— ~methは注釈文にて定義されることになる：
◎
The following IDL fragment defines an interface Transaction that has a toJSON method defined in prose:
</p>

<pre class="webidl">
[Exposed=Window]
interface Transaction {
  readonly attribute DOMString from;
  readonly attribute DOMString to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;
  TransactionJSON toJSON();
};

dictionary TransactionJSON {
  Account from;
  Account to;
  double amount;
  DOMString description;
};</pre>

<div class="algorithm">
<p>
`Transaction^T `~ifc$の~toJSON`正則~演算$は、［
被呼出時には次の手続きを走らす
］ように定義することもできる：
◎
The toJSON regular operation of Transaction interface could be defined as follows:
◎
To invoke the toJSON() operation of the Transaction interface, run the following steps:
</p>

<ol>
	<li>
%json ~LET 新たな `TransactionJSON^T 辞書
◎
Let json be a new TransactionJSON dictionary.
</li>
	<li>
<p>
属性`識別子$の`~list$ « `from^l, `to^l, `amount^l, `description^l » 内の
~EACH( %識別子 )
に対し：
◎
For each attribute identifier attr in « "from", "to", "amount", "description" »:
</p>
		<ol>
			<li>
%json [ %識別子 ] ~SET `属性の下層~値を取得する$( `this$V, %識別子 で識別される`属性$ )
◎
Let value be result of getting the underlying value of the attribute identified by attr, given this.
◎
Set json[attr] to value.
</li>
		</ol>
	</li>
	<li>
~RET %json
◎
Return json.
</li>
</ol>
</div>

<p>
~ES言語束縛においては、
`Transaction^T ~obj上に `toJSON()^M ~methが存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON() method on Transaction objects:
</p>

<pre class="es-code">
/* <span class="comment">
`Transaction^T の~instanceを取得する：
◎
Get an instance of Transaction.
</span> */
var %txn = getTransaction();

/* <span class="comment">
次の様な~objに評価される：
◎
Evaluates to an object like this:
</span> */
   {
     from: "Bob",
     to: "Alice",
     amount: 50,
     description: "books"
   }
*/
%txn.toJSON();

/* <span class="comment">
次の様な文字列に評価される：
◎
Evaluates to a string like this:
</span> */
   '{"from":"Bob","to":"Alice","amount":50,"description":"books"}'
*/
JSON.stringify(%txn);
</pre>
</div>
				</section>
			</section>
			<section id="idl-constructors">
<h4 title="Constructor operations">2.5.4. 構築子~演算</h4>

<p class="trans-note">【
この節の内容は、以前まで
`Constructor@x
`拡張属性$として定義されていた特能を置き換える。
`導入されてから日が浅い＠https://github.com/heycam/webidl/commit/91ca6ebb4d4fca9703309e19256bbc5f5dd77e3c$href
ので、まだ反映されていない仕様も多数ある。
】</p>

<p>
`~ifc$に`構築子~演算$~mb（ `Constructor$g に合致している）がある場合、［
`構築子$を利用して`~ifc$を`実装-$する~objを作成する
］ことがアリになることを指示する。
◎
If an interface has a constructor operation member (matching Constructor), it indicates that it is possible to create objects that implement the interface using a constructor.
</p>

<p>
所与の`~ifc$上に複数の`構築子~演算$が現れてもヨイ。
`~ifc$上の各`構築子~演算$ごとに，指定された引数を渡して~instanceを構築しようと試みる仕方があることになる。
◎
Multiple constructor operations may appear on a given interface. For each constructor operation on the interface, there will be a way to attempt to construct an instance by passing the specified arguments.
</p>

<p>
注釈文による`構築子~演算$の定義は、 `this$V として渡された値を初期化するか，例外を投出しなければナラナイ。
◎
The prose definition of a constructor operation must either initialize the value passed as this, or throw an exception.
</p>

<p>
`構築子~演算$がどう実装されるかの詳細は、
`interface-object$sec
を見よ。
◎
See § 3.6.1 Interface object for details on how a constructor operation is to be implemented.
</p>

<div class="example">

<p>
次の~IDLは 2 つの~ifcを定義する。
2 個目のものには`構築子~演算$がある一方，
1 個目のものにはない。
◎
The following IDL defines two interfaces. The second has constructor operations, while the first does not.
</p>

<pre class="webidl">
[Exposed=Window]
interface NodeList {
  Node item(unsigned long index);
  readonly attribute unsigned long length;
};

[Exposed=Window]
interface Circle {
  constructor();
  constructor(double radius);
  attribute double r;
  attribute double cx;
  attribute double cy;
  readonly attribute double circumference;
};
</pre>

<p>
これらの~ifcを~supportする~ES実装は、
`Circle^T ~ifc~obj上に，［
その~ifcを`実装-$する新たな~obj
］を返す `Construct^sl 内部~methを実装することになる。
それは 0 個または 1 個の引数をとる。
◎
An ECMAScript implementation supporting these interfaces would implement a [[Construct]] internal method on the Circle interface object which would return a new object that implements the interface. It would take either zero or one argument.
</p>

<p class="issue">
`NodeList^T ~ifc~objが `Construct^sl 内部~methを実装するかどうか不明瞭である。
いずれにせよ，それを構築子として利用しようと試行すると、
`TypeError$jE が投出されることになる。
（ `issue #698＠https://github.com/heycam/webidl/issues/698$href ）
◎
It is unclear whether the NodeList interface object would implement a [[Construct]] internal method. In any case, trying to use it as a constructor will cause a TypeError to be thrown. &lt;https://github.com/heycam/webidl/issues/698&gt;
</p>

<pre class="es-code">
var %x = new Circle();      /* <span class="comment">
これは，引数なしの構築子を利用して、 `Circle^T ~ifcを実装する~platform~objへの参照を作成する。
◎
The uses the zero-argument constructor to create a reference to a platform object that implements the Circle interface.
</span> */

var %y = new Circle(1.25);  /* <span class="comment">
今度は 1 個の引数をとる構築子を利用して `Circle^T ~objを作成する。
◎
This also creates a Circle object, this time using the one-argument constructor.
</span> */

var %z = new NodeList();    /* <span class="comment">
構築子が宣言されていないので `TypeError^jE が投出されることになる。
◎
This would throw a TypeError, since no constructor is declared.
</span> */
</pre>

</div>

<data class="grammar" value="
Constructor
ArgumentList
Arguments
Argument
ArgumentRest
ArgumentName
Ellipsis
ArgumentNameKeyword
"></data>

			</section>
			<section id="idl-special-operations">
<h4 title="Special operations">2.5.5. 特殊~演算</h4>

<p>
`特殊~演算@
は、［
その特殊~演算~宣言が現れる~ifcを実装する~obj
］上の［
一定の種類の特殊な挙動
］の宣言である。
`特殊~演算$は，演算~宣言において
`特殊~keyword@
を利用して宣言される。
◎
A special operation is a declaration of a certain kind of special behavior on objects implementing the interface on which the special operation declarations appear. Special operations are declared by using a special keyword in an operation declaration.
</p>

<p>
`特殊~演算$には、次の一覧に挙げる 4 種類がある。
一覧には、各~特殊~演算に対し，それを宣言するために利用される特殊~keyword, および演算の目的も示す：
◎
There are four kinds of special operations. The table below indicates for a given kind of special operation what special keyword is used to declare it and what the purpose of the special operation is:
</p>

<table><thead><tr><th>
`特殊~演算$
◎
Special operation
<th>~keyword
◎
Keyword
<th>
目的
◎
Purpose
</thead><tbody>

<tr><td>`取得子@
<td>`getter^sym
<td>
~propの検索取得~用に~objが~index-される際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property retrieval.

<tr><td>`設定子@
<td>`setter^sym
<td>
~prop［
代入／作成
］用に~objが~index-される際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property assignment or creation.

<tr><td>`削除子@
<td>`deleter^sym
<td>
~prop削除
用に~objが~index-される際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property deletion.

<tr><td>`文字列化子@
<td>`stringifier^sym
<td>
~objを `DOMString$T に変換する方法を定義する。
◎
Defines how an object is converted into a DOMString.

</tbody></table>

<p>
すべての言語束縛が、［
これら 4 種類の，~objの特殊な挙動
］すべてを~supportするわけではない。
`特殊~演算$が，識別子を伴わない演算を利用して宣言された場合、その特定0の種類の特殊~演算を~supportしない言語束縛においては，単にその機能性が存在しないことになる。
◎
Not all language bindings support all of the four kinds of special object behavior. When special operations are declared using operations with no identifier, then in language bindings that do not support the particular kind of special operations there simply will not be such functionality.
</p>

<div class="example">
<p>
次の~IDL片は、取得子と設定子を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with a getter and a setter:
</p>

<pre class="webidl">
[Exposed=Window]
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double (DOMString %propertyName);
  setter void (DOMString %propertyName, double %propertyValue);
};
</pre>

<p>
~propの取得子や設定子を~supportしない言語束縛では、
`Dictionary^T を実装している~objはこの特殊な挙動を持たないことになる。
◎
In language bindings that do not support property getters and setters, objects implementing Dictionary will not have that special behavior.
</p>

</div>

<p>
`特殊~演算$を`識別子$を伴わせて定義することは、その宣言から識別子のない特殊~演算を分離することと，等価である。
この書き方は、~ifcの演算についての注釈文の記述を単純~化するために許容されている。
◎
Defining a special operation with an identifier is equivalent to separating the special operation out into its own declaration without an identifier. This approach is allowed to simplify prose descriptions of an interface’s operations.
</p>

<div class="example">
<p>
次の 2 つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="webidl">
[Exposed=Window]
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double getProperty(DOMString %propertyName);
  setter void setProperty(DOMString %propertyName, double %propertyValue);
};
</pre>

<pre class="webidl">
[Exposed=Window]
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  double getProperty(DOMString %propertyName);
  void setProperty(DOMString %propertyName, double %propertyValue);

  getter double (DOMString %propertyName);
  setter void (DOMString %propertyName, double %propertyValue);
};
</pre>
</div>

<p>
1 つの演算に同じ`特殊~keyword$が複数~回 現れてはナラナイ。
◎
A given special keyword must not appear twice on an operation.
</p>

<p>
取得子, 設定子, 削除子は 2 種の系列に分類される：
◎
Getters and setters come in two varieties:＼
</p>

<ul id="_property-accessors">
	<li>
`有名~prop取得子@,
`有名~prop設定子@,
`有名~prop削除子@
と呼ばれる，~prop名として `DOMString$T をとるもの。
◎
ones that take a DOMString as a property name, known as named property getters and named property setters, and＼
</li>
	<li>
`有index~prop取得子@,
`有index~prop設定子@
と呼ばれる，~prop~indexとして `unsigned long$T をとるもの
— 有index~propには，`削除子は無い^em。
◎
ones that take an unsigned long as a property index, known as indexed property getters and indexed property setters. There is only one variety of deleter: named property deleters.＼
</li>
</ul>

<p>
詳細は、
`idl-indexed-properties$sec,
`idl-named-properties$sec
を見よ。
◎
See § 2.5.5.2 Indexed properties and § 2.5.5.3 Named properties for details.
</p>

<p>
所与の`~ifc$上に存在する，［
`文字列化子$, `削除子$ および, 各~系列の［
`取得子$, `設定子$
］］は、それぞれ，高々 1 個まででなければナラナイ。
◎
On a given interface, there must exist at most one stringifier, at most one named property deleter, and at most one of each variety of getter and setter.
</p>

<p>
~ifcが［
いずれかの系列の`設定子$,
あるいは`有名~prop削除子$
］を持つ場合、同じ系列の`取得子$も持たなければナラナイ。
◎
If an interface has a setter of a given variety, then it must also have a getter of that variety. If it has a named property deleter, then it must also have a named property getter.
</p>

<p>
演算を利用して宣言される`特殊~演算$は，［
`可変個的な$ ／
`随意~引数$をとる
］ようにされてはナラナイ。
◎
Special operations declared using operations must not be variadic nor have any optional arguments.
</p>

<p>
~objが，所与の`特殊~演算$を定義する複数の`~ifc$を実装する場合、その演算に対し，どの特殊~演算が呼出されるかは 未定義である。
◎
If an object implements more than one interface that defines a given special operation, then it is undefined which (if any) special operation is invoked for that operation.
</p>

				<section id="idl-stringifiers">
<h5 title="Stringifiers">2.5.5.1. 文字列化子</h5>

<p>
`~ifc$が`文字列化子$を持つならば、［
その~ifcを実装する~objは、文字列への既定でない変換を持つ
］ことを指示する。
上で言及したように、文字列化子は，［
`stringifier^sym ~keywordを伴って宣言される`演算$
］を利用して指定できる。
◎
When an interface has a stringifier, it indicates that objects that implement the interface have a non-default conversion to a string. As mentioned above, stringifiers can be specified using an operation declared with the stringifier keyword.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier DOMString `identifier^i();
  stringifier DOMString ();
};
</pre>

<p>
`文字列化子$を宣言するために利用された演算が`識別子$を持たない場合、~ifcに付帯する注釈文において，~ifcの
`文字列~化の挙動@
が定義されなければナラナイ。
演算が識別子を持つ場合、その演算の呼出ngにより，~objは文字列に変換される。
◎
If an operation used to declare a stringifier does not have an identifier, then prose accompanying the interface must define the stringification behavior of the interface. If the operation does have an identifier, then the object is converted to a string by invoking the operation to obtain the string.
</p>

<p>
演算により宣言される`文字列化子$は、［
0 個の引数をとり， `DOMString$T を返す
］ように宣言されなければナラナイ。
◎
Stringifiers declared with operations must be declared to take zero arguments and return a DOMString.
</p>

<p>
略記として、［
`stringifier^sym ~keywordを，識別子を伴わない演算を利用して宣言する
］場合，その演算の［
`返り値~型$, 引数~list
］を省略できる。
◎
As a shorthand, if the stringifier keyword is declared using an operation with no identifier, then the operation’s return type and argument list can be omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier;
};
</pre>

<div class="example">
<p>
次の 2 つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  stringifier DOMString ();
};
</pre>

<pre class="webidl">
[Exposed=Window]
interface A {
  stringifier;
};
</pre>
</div>

<p>
`stringifier^sym ~keywordは、`属性$上に置くこともできる。
この場合、その属性の値が，~objから文字列への変換-を与える。
`stringifier^sym ~keywordは、［
`静的~属性$ ／［
`DOMString$T／`USVString$T
］として宣言されていない属性
］上に置かれてはナラナイ。
◎
The stringifier keyword can also be placed on an attribute. In this case, the string to convert the object to is the value of the attribute. The stringifier keyword must not be placed on an attribute unless it is declared to be of type DOMString or USVString. It also must not be placed on a static attribute.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<data class="grammar" value="
Stringifier
StringifierRest
"></data>

<div class="example">
<p>
次の`~IDL片$は、 `name^M 属性の値に文字列~化する~ifcを定義する：
◎
The following IDL fragment defines an interface that will stringify to the value of its name attribute:
</p>

<pre class="webidl">
[Exposed=Window]
interface Student {
  constructor();
  attribute unsigned long id;
  stringifier attribute DOMString name;
};
</pre>

<p>
~ES言語束縛においては、文字列が期待されている文脈において
`Student^T
~objが利用されたときの結果は、その~objの `name^jp ~propの値になる：
◎
In the ECMAScript binding, using a Student object in a context where a string is expected will result in the value of the object’s name property being used:
</p>

<pre class="es-code">
var %s = new Student();
%s.id = 12345678;
%s.name = '周杰倫';

var %挨拶 = 'こんにちは、 ' + %s + ' さん。';
    /* <span class="comment">
`こんにちは、 周杰倫 さん。^l になる。
◎
Now greeting == 'Hello, 周杰倫!'.
</span> */
</pre>

<p>
次の`~IDL片$は、~IDL自身には指定されない~customな文字列~化の挙動を備える~ifcを定義する。
◎
The following IDL fragment defines an interface that has custom stringification behavior that is not specified in the IDL itself.
</p>

<pre class="webidl">
[Exposed=Window]
interface Student {
  constructor();
  attribute unsigned long id;
  attribute DOMString? familyName;
  attribute DOMString givenName;

  stringifier DOMString ();
};
</pre>

<p>
したがって、例えば次の段落の様な，文字列~化の挙動を説明する注釈文が要求される：
◎
Thus, prose is required to explain the stringification behavior, such as the following paragraph:
</p>

<blockquote>
`Student^T ~ifc を実装する~objを文字列~化した結果は、［
`familyName^M 属性の値が `null^V の場合は `givenName^M 属性の値／
~ELSE_ 次の連結
］になるモノトスル
⇒＃
`givenName^M 属性の値,
1 個の space 文字,
`familyName^M 属性の値
◎
Objects that implement the Student interface must stringify as follows. If the value of the familyName attribute is null, the stringification of the object is the value of the givenName attribute. Otherwise, if the value of the familyName attribute is not null, the stringification of the object is the concatenation of the value of the givenName attribute, a single space character, and the value of the familyName attribute.
</blockquote>

<p>
この~IDLの~ES実装は、次に従って挙動することになる：
◎
An ECMAScript implementation of the IDL would behave as follows:
</p>

<pre class="es-code">
var %s = new Student();
%s.id = 12345679;
%s.familyName = 'Smithee';
%s.givenName = 'Alan';

var %挨拶 = 'こんにちは、 ' + %s + ' さん。';
    /* <span class="comment">
`こんにちは、 Alan Smithee さん^l になる。
◎
Now greeting == 'Hi Alan Smithee'.
</span> */
</pre>
</div>
				</section>
				<section id="idl-indexed-properties">
<h5 title="Indexed properties">2.5.5.2. 有index~prop</h5>

<p>
`有index~prop取得子$を定義する`~ifc$は、
`有index~propを~support@
するという。
そのような~ifcを実装する`~platform~obj$もまた，`有index~propを~support$するという。
◎
An interface that defines an indexed property getter is said to support indexed properties. By extension, a platform object is said to support indexed properties if it implements an interface that itself does.
</p>

<p>
~ifcが`有index~propを~support$する場合、その~ifc定義には，所与の任意の時点で~objに~index-できる~indexについての記述も付帯していなければナラナイ。
これらの~indexは、~objが
`~supportする~prop~index@
と呼ばれる。
◎
If an interface supports indexed properties, then the interface definition must be accompanied by a description of what indices the object can be indexed with at any given time. These indices are called the supported property indices.
</p>

<p>
`有index~propを~support$する~ifcは、`整数~型$である 名前 `length^l の属性を定義しなければナラナイ。
◎
Interfaces that support indexed properties must define an integer-typed attribute named "length".
</p>

<p>
`有index~prop取得子$は、 1 個の `unsigned long$T 引数をとるように宣言されなければナラナイ。
有index~propの設定子は、 2 個の引数をとり,
1 個目の引数が `unsigned long$T をとるように宣言されなければナラナイ。
◎
Indexed property getters must be declared to take a single unsigned long argument. Indexed property setters must be declared to take two arguments, where the first is an unsigned long.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(unsigned long `identifier^i);
  setter `type^i `identifier^i(unsigned long `identifier^i, `type^i `identifier^i);

  getter `type^i (unsigned long `identifier^i);
  setter `type^i (unsigned long `identifier^i, `type^i `identifier^i);
};
</pre>

<p>
次の要件が，有index~propの［
取得子／設定子
］の定義に適用される：
◎
The following requirements apply to the definitions of indexed property getters and setters:
</p>
<ul>
	<li>
<p>
`有index~prop取得子$の宣言に利用された`演算$ %演算 が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合：
~objに対し［
所与の
( ~objが`~supportする~prop~index$ %index )
で~index-した
］ときの返り値は、［
%演算 を，その唯一の引数に %index を渡して呼出した
］ときと同じになる。
◎
If an indexed property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property index is the value that would be returned by invoking the operation, passing the index as its only argument.＼
</li>
			<li>
持たない場合：
その~ifc定義には，所与の~indexに対し
`有index~propの値を決定する@
方法を成す記述も付帯していなければナラナイ。
◎
If the operation used to declare the indexed property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of an indexed property for a given index.
</li>
		</ul>
	</li>
	<li>
<p>
`有index~prop設定子$の宣言に利用された`演算$ %演算 が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合：
~objに対し［
所与の
( ~objが`~supportする~prop~index$ %index, 値 %V )
で，~prop代入~用に~index-した
］ときに生じる挙動は、［
%演算 を，その ( 1 個目, 2 個目 ) の引数に
( %index, %V ) を渡して呼出した
］ときと同じになる。
◎
If an indexed property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property index and value is the same as if the operation is invoked, passing the index as the first argument and the value as the second argument.＼
</li>
			<li>
持たない場合：
その~ifc定義には，所与の
( ~prop~index, 値 )
に対し［
`既存の有index~propを設定する@
方法, および
`新たな有index~propを設定する@
方法
］を成す記述も付帯していなければナラナイ。
◎
If the operation used to declare the indexed property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing indexed property and how to set the value of a new indexed property for a given property index and value.
</li>
		</ul>
	</li>
</ul>

<div class="note">
<p>
`有index~prop$の［
取得子／設定子
］が，`識別子$を伴う`演算$を利用して指定されている場合、［
~objが`~supportする~prop~index$でない整数 %index
］で~index-したときの挙動が，
%index でその演算を呼出したときと同じになるとは限らない。
この事例における実際の挙動は、言語束縛に特有になる。
◎
Note that if an indexed property getter or setter is specified using an operation with an identifier, then indexing an object with an integer that is not a supported property index does not necessarily elicit the same behavior as invoking the operation with that index. The actual behavior in this case is language binding specific.
</p>

<p>
~ES言語束縛においては，定例の~prop検索が行われる。
例えば次の~IDLでは：
◎
In the ECMAScript language binding, a regular property lookup is done. For example, take the following IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  getter DOMString toWord(unsigned long %index);
};
</pre>

<p>
`A^T を実装している~objが`~supportする~prop~index$は、
0 以上 2 未満とする。
また、 `toWord^M は，引数の数字を英単語に変換した文字列を返すように定義されているとする。
範囲~外の~indexで`演算$を呼出したときの挙動は、~objを直に~index-したときとは異なる：
◎
Assume that an object implementing A has supported property indices in the range 0 ≤ index &lt; 2. Also assume that toWord is defined to return its argument converted into an English word. The behavior when invoking the operation with an out of range index is different from indexing the object directly:
</p>

<pre class="es-code">
var %a = getA();

%a.toWord(0);  /* <span class="comment">
`zero^l  に評価される。
◎
Evaluates to "zero".
</span> */
%a[0];         /* <span class="comment">
これも `zero^l に評価される。
◎
Also evaluates to "zero".
</span> */

%a.toWord(5);  /* <span class="comment">
`five^l に評価される。
◎
Evaluates to "five".
</span> */
%a[5];         /* <span class="comment">
~prop `5^l は存在しないので `undefined^jv に評価される。
◎
Evaluates to undefined, since there is no property "5".
</span> */
</pre>
</div>

<div class="example">
<p>
次の`~IDL片$は、名前または~indexにより値を［
検索取得できる／設定できる
］ようにする
`OrderedMap^T
~ifcを定義する：
◎
The following IDL fragment defines an interface OrderedMap which allows retrieving and setting values by name or by index number:
</p>

<pre class="webidl">
[Exposed=Window]
interface OrderedMap {
  readonly attribute unsigned long size;

  getter any getByIndex(unsigned long %index);
  setter void setByIndex(unsigned long %index, any %value);

  getter any get(DOMString %name);
  setter void set(DOMString %name, any %value);
};
</pre>

<p>
どの特殊~演算も識別子を伴う演算を利用して宣言されているので、必要とされる唯一の注釈文は，これらの集合が持つ~keyを与える記述になる。
`get()^M 演算が［
`OrderedMap^T 内に存在しない~itemを検索しようと試みられたときは， `null^V を返す
］ように定義されているとするとき、次の 2 つの~~文で足りるであろう：
◎
Since all of the special operations are declared using operations with identifiers, the only additional prose that is necessary is that which describes what keys those sets have. Assuming that the get() operation is defined to return null if an attempt is made to look up a non-existing entry in the OrderedMap, then the following two sentences would suffice:
</p>

	<blockquote>
<p>
`OrderedMap^T を実装する~obj %map は、範囲［
0 ~LTE %index ~LT `map.size^c
］の`有index~propを~support$する。
◎
An object map implementing OrderedMap supports indexed properties with indices in the range 0 ≤ index &lt; map.size.
</p>

<p>
そのような~objは、［
`get()^M に渡されたとき，非 `null^V 値を返す
］ような どの名前に対しても，有名~propを~supportする。
◎
Such objects also support a named property for every name that, if passed to get(), would return a non-null value.
</p>
	</blockquote>

<p>
`es-legacy-platform-objects$sec
に述べられるように、~ES実装は［
有名, 有index
］いずれの~propの集合に対しても、その集合に属する各項に対応する~propを［
`OrderedMap^T を実装している`旧来の~platform~obj$
］上に，作成することになる。
下に示すように、これらの~propは，［
~objの~methの呼出ngと同じ仕方で，~objとヤリトリする
］ために利用できる：
◎
As described in § 3.8 Legacy platform objects, an ECMAScript implementation would create properties on a legacy platform object implementing OrderedMap that correspond to entries in both the named and indexed property sets. These properties can then be used to interact with the object in the same way as invoking the object’s methods, as demonstrated below:
</p>

<pre class="es-code">
/* <span class="comment">
%map は `OrderedMap^T ~ifcを実装する旧来の~platform~objであるとする：
◎
Assume map is a legacy platform object implementing the OrderedMap interface.
</span> */
var %map = getOrderedMap();
var %x, %y;

%x = %map[0];       /* <span class="comment">
`map.length^c ~GT 0 ならば、これは
`x = map.getByIndex(0)^c
と等価になる（名前 `0^l の~propが %map 上に置かれるので）。
他の場合、名前 `0^l の~propは %map 上にないので，
%x は `undefined^jv に設定されることになる。
◎
If map.length &gt; 0, then this is equivalent to:

  x = map.getByIndex(0)

since a property named "0" will have been placed on map.
Otherwise, x will be set to undefined, since there will be
no property named "0" on map.
</span> */

%map[1] = false;   /* <span class="comment">
これは、
`map.setByIndex(1, false)^c
と等価な動作になる。
◎
This will do the equivalent of:

  map.setByIndex(1, false)
</span> */

%y = %map.apple;    /* <span class="comment">
名前 `apple^l の有名~propが存在する場合、
%map 上には名前 `apple^l の~propがあり，
`y = map.get('apple')^c
と等価な動作になる。
他の場合、 %map 上に名前 `apple^l の~propはないので，
%y は `undefined^jv に設定されることになる。
◎
If there exists a named property named "apple", then this
will be equivalent to:

  y = map.get('apple')

since a property named "apple" will have been placed on
map.  Otherwise, y will be set to undefined, since there
will be no property named "apple" on map.
</span> */

%map.berry = 123;  /* <span class="comment">
これは、
`map.set('berry', 123)^c
と等価な動作になる。
◎
This will do the equivalent of:

  map.set('berry', 123)
</span> */

delete %map.cake;  /* <span class="comment">
有名~prop `cake^l が存在するならば、 `cake^jp ~propは削除され，
`map.remove("cake")^c
と等価な動作になる。
◎
If a named property named "cake" exists, then the "cake"
property will be deleted, and then the equivalent to the
following will be performed:

	  map.remove("cake")
</span> */

</pre>
</div>

				</section>
				<section id="idl-named-properties">
<h5 title="Named properties">2.5.5.3. 有名~prop</h5>

<p>
`有名~prop取得子$を定義する`~ifc$は、
`有名~propを~support@
するという。
そのような~ifcを実装する`~platform~obj$もまた，`有名~propを~support$するという。
◎
An interface that defines a named property getter is said to support named properties. By extension, a platform object is said to support named properties if it implements an interface that itself does.
</p>

<p>
`有名~propを~support$する~ifcの~ifc定義には、［
所与の任意の時点で~objに~index-できるような名前からなる，有順序~集合
］についての記述も付帯していなければナラナイ。
これらの名前は、~objが
`~supportする~prop名@
と呼ばれる。
◎
If an interface supports named properties, then the interface definition must be accompanied by a description of the ordered set of names that can be used to index the object at any given time. These names are called the supported property names.
</p>

<p>
有名~propの取得子と削除子は、 1 個の `DOMString$T 引数をとるように宣言されなければナラナイ。
有名~propの設定子は、 2 個の引数をとり， 1 個目の引数に `DOMString$T をとるように宣言されなければナラナイ。
◎
Named property getters and deleters must be declared to take a single DOMString argument. Named property setters must be declared to take two arguments, where the first is a DOMString.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(DOMString `identifier^i);
  setter `type^i `identifier^i(DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i `identifier^i(DOMString `identifier^i);

  getter `type^i (DOMString `identifier^i);
  setter `type^i (DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i (DOMString `identifier^i);
};
</pre>

<p>
次の要件が，有名~propの［
取得子／設定子／削除子
］の定義に適用される：
◎
The following requirements apply to the definitions of named property getters, setters and deleters:
</p>
<ul>
	<li>
<p>
`有名~prop取得子$の宣言に利用された`演算$ %演算 が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合：
~objに対し［
所与の
( ~objが`~supportする~prop名$ %name )
で~index-した
］ときの返り値は、［
%演算 を，その唯一の引数に %name を渡して呼出した
］ときと同じになる。
◎
If a named property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property name is the value that would be returned by invoking the operation, passing the name as its only argument.＼
</li>
			<li>
持たない場合：
その~ifc定義には，所与の~prop名に対し
`有名~propの値を決定する@
方法を成す記述も付帯していなければナラナイ。
◎
If the operation used to declare the named property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of a named property for a given property name.
</li>
		</ul>
	</li>
	<li>
<p>
`有名~prop設定子$の宣言に利用された`演算$ %演算 が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合：
~objに対し［
所与の
( ~objが`~supportする~prop名$ %name, 値 %V )
で，~prop代入~用に~index-した
］ときに生じる挙動は、［
%演算 を，その ( 1 個目, 2 個目 ) の引数に ( %name, %V ) を渡して呼出した
］ときと同じになる。
◎
If a named property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property name and value is the same as if the operation is invoked, passing the name as the first argument and the value as the second argument.＼
</li>
			<li>
持たない場合：
その~ifc定義には，所与の
( ~prop名, 値 )
に対し［
`既存の有名~propを設定する@
方法, および
`新たな有名~propを設定する@
方法
］を成す記述も付帯していなければナラナイ。
◎
If the operation used to declare the named property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing named property and how to set the value of a new named property for a given property name and value.
</li>
		</ul>
	</li>
	<li>
<p>
`有名~prop削除子$の宣言に利用された`演算$ %演算 が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合：
~objに対し［
所与の
( ~objが`~supportする~prop名$ %name )
で，~prop削除~用に~index-した
］ときに生じる挙動は、［
%演算 を，その唯一の引数に %name を渡して呼出した
］ときと同じになる。
◎
If a named property deleter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property deletion with a given supported property name is the same as if the operation is invoked, passing the name as the only argument.＼
</li>
			<li>
持たない場合：
その~ifc定義には，所与の~prop名に対し
`既存の有名~propを削除する@
方法を成す記述も付帯していなければナラナイ。
◎
If the operation used to declare the named property deleter did not have an identifier, then the interface definition must be accompanied by a description of how to delete an existing named property for a given property name.
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`有index~prop$のときと同じく，`有名~prop$の［
取得子／設定子／削除子
］が`識別子$を伴う`演算$を利用して指定された場合、~objに対し［
~objが`~supportする~prop名$でない名前で~index-した
］ときの挙動が［
その名前でその演算を呼出した
］ときと同じになるとは限らない。
挙動は、言語束縛に特有になる。
◎
Note: As with indexed properties, if an named property getter, setter or deleter is specified using an operation with an identifier, then indexing an object with a name that is not a supported property name does not necessarily elicit the same behavior as invoking the operation with that name; the behavior is language binding specific.
</p>

				</section>
			</section>
			<section id="idl-static-attributes-and-operations">
<h4 title="Static attributes and operations">2.5.6. 静的~属性と静的~演算</h4>

<p>
<span>`静的~属性@</span>,
`静的~演算@
は、それが宣言される`~ifc$の特定0の~instance上には結付けられないものであり、代わりに，その ~ifc自身に結付けられる。
静的~属性と静的~演算は，それらの宣言の中で `static^sym ~keywordを利用して宣言される。
◎
Static attributes and static operations are ones that are not associated with a particular instance of the interface on which it is declared, and is instead associated with the interface itself. Static attributes and operations are declared by using the static keyword in their declarations.
</p>

<p>
［
静的~演算を呼出す／
静的~属性を取得する／
静的~属性を設定する
］ことが，~ifcの~instanceへの参照を通してアリかどうかは、言語束縛に特有になる。
◎
It is language binding specific whether it is possible to invoke a static operation or get or set a static attribute through a reference to an instance of the interface.
</p>

<data class="grammar" value="
StaticMember
StaticMemberRest
"></data>

<div class="example">
<p>
次の`~IDL片$は、静的~演算が宣言されている
`Circle^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Circle that has a static operation declared on it:
</p>

<pre class="webidl">
[Exposed=Window]
interface Point { /* ... */ };

[Exposed=Window]
interface Circle {
  attribute double cx;
  attribute double cy;
  attribute double radius;

  static readonly attribute long triangulationCount;
  static Point triangulate(Circle %c1, Circle %c2, Circle %c3);
};
</pre>

<p>
~ES言語束縛においては、
`Circle^T 用の`~ifc~obj$上に，
`triangulate^M に対応する`関数~obj$, および
`triangulationCount^M に対応する~accessor~prop
が存在することになる：
◎
In the ECMAScript language binding, the function object for triangulate and the accessor property for triangulationCount will exist on the interface object for Circle:
</p>

<pre class="es-code">
var %circles = getCircles();        /* <span class="comment">
`Circle^T ~objの `Array^jt
◎
an Array of Circle objects
</span> */

typeof Circle.triangulate;         /* <span class="comment" id="cp-eval-function">
`function^l に評価される。
◎
Evaluates to "function"
</span> */
typeof Circle.triangulationCount;  /* <span class="comment">
`number^l に評価される。
◎
Evaluates to "number"
</span> */
Circle.prototype.triangulate;      /* <span class="comment" id="cp-eval-undefined">
`undefined^jv に評価される。
◎
Evaluates to undefined
</span> */
Circle.prototype.triangulationCount;  /* <span class="comment">
これも `undefined^jv に評価される。
◎
Also evaluates to undefined
</span> */
%circles[0].triangulate;            /* <span class="comment">
これも。
◎
As does this
</span> */
%circles[0].triangulationCount;     /* <span class="comment">
これも。
◎
And this
</span> */

/* <span class="comment">
静的~演算の~call：
◎
Call the static operation
</span> */
var %triangulationPoint = Circle.triangulate(%circles[0], %circles[1], %circles[2]);

/* <span class="comment">
`triangulate^M を呼んだ回数を調べる：
◎
Find out how many triangulations we have done
</span> */
window.alert(Circle.triangulationCount);

</pre>

</div>
			</section>
			<section id="idl-overloading">
<h4 title="Overloading">2.5.7. 多重定義</h4>

<p>
`~ifc$上に定義される［
`正則~演算$／`静的~演算$
］が，その~ifc上の同じ種類の別の（正則／静的）演算と
同じ`識別子$を持つ場合、その演算は
`多重定義@
されているという。
その~ifcを実装する~obj上で［
それらの演算のどれかを呼出すために［
多重定義された演算の識別子
］が利用された
］ときに，どの演算が実際に呼出されるかは、演算に渡された
( 引数の個数, それらの各 型 )
により決定される。
`構築子~演算$も多重定義され得る。
多重定義された［
演算／構築子
］がとれるものと指定される引数には，一定の制約があり、これらの制約を記述するため，`有効~多重定義~集合$の観念が利用される。
◎
If a regular operation or static operation defined on an interface has an identifier that is the same as the identifier of another operation on that interface of the same kind (regular or static), then the operation is said to be overloaded. When the identifier of an overloaded operation is used to invoke one of the operations on an object that implements the interface, the number and types of the arguments passed to the operation determine which of the overloaded operations is actually invoked. Constructor operations can be overloaded too. There are some restrictions on the arguments that overloaded operations and constructors can be specified to take, and in order to describe these restrictions, the notion of an effective overload set is used.
</p>

<p>
`演算$は、複数の［
`~ifc$,
`部分的~ifc$,
`~ifc~mixin$,
`部分的~ifc~mixin$
］にまたがって多重定義されてはナラナイ。
◎
Operations must not be overloaded across interface, partial interface, interface mixin, and partial interface mixin definitions.
</p>

<div class="note">
<p>
例えば，次の様な `f^T, `g^T の多重定義は許容されない：
◎
For example, the overloads for both f and g are disallowed:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  void f();
};

partial interface A {
  void f(double %x);
  void g();
};

partial interface A {
  void g(DOMString %x);
};
</pre>

<p>
構築子の多重定義については、元々`部分的~ifc定義$上には［
`構築子~演算$ ／ `NamedConstructor$x `拡張属性$
］の出現が許容されていないので，同様の制約は~~自動的に満たされることに注意。
◎
Note that constructor operations and [NamedConstructor] extended attributes are disallowed from appearing on partial interface definitions, so there is no need to also disallow overloading for constructors.
</p>
</div>

<div class="p">
<p>
`有効~多重定義~集合@
は、特定0の
`関数類@
— ［
`演算$ ／
構築子（`構築子~演算$または `NamedConstructor$x により指定される） ／
`~callback関数$†
］ —
に許容され得る呼出nを表現する。
</p>

<p class="trans-note">【
“関数類（引数を伴って~callできる~IDL構成子）”
は、簡潔に総称できるよう，この訳にて導入した用語である。
】【†
`~callback関数$は、
`多重定義できないものとされた＠https://github.com/heycam/webidl/commit/b47c90c9c503b56d05bcfc30c12e2285ebe63a28$href
。
】</p>

<p>
`有効~多重定義~集合を算出する$ための~algoは、次に挙げる~IDL構成子いずれかに対し演算する。
算出するために必要な入力は、渡される引数の個数, および
`関数類$の~~種別に応じて，以下に示されるものになる：
</p>
◎
An effective overload set represents the allowable invocations for a particular operation, constructor (specified with a constructor operation or [NamedConstructor]), or callback function. The algorithm to compute the effective overload set operates on one of the following four types of IDL constructs, and listed with them below are the inputs to the algorithm needed to compute the set.
</div>

<dl class="switch">
	<dt>
正則~演算
◎
For regular operations
</dt>
	<dt>
静的~演算
◎
For static operations
</dt>
	<dd>
`演算$が見出される`~ifc$, および
演算の`識別子$
◎
the interface on which the operations are to be found
◎
the identifier of the operations
◎
the number of arguments to be passed
</dd>

	<dt>
構築子
◎
For constructors
</dt>
	<dd>
`構築子~演算$が見出される`~ifc$
◎
the interface on which the constructor operations are to be found
◎
the number of arguments to be passed
</dd>

	<dt>
有名~構築子
◎
For named constructors
</dt>
	<dd>
`NamedConstructor$x `拡張属性$が見出される`~ifc$, および
有名~構築子の`識別子$
◎
the interface on which the [NamedConstructor] extended attributes are to be found
◎
the identifier of the named constructors
◎
the number of arguments to be passed
</dd>
</dl>

<p>
`有効~多重定義~集合$は、~ifc上に多重定義された`関数類$たちに多義性があるかどうかを
— 他と伴に —
決定するために利用される。
◎
An effective overload set is used, among other things, to determine whether there are ambiguities in the overloaded operations and constructors specified on an interface.
</p>

<p>
`有効~多重定義~集合$は、`有順序~集合$であり，それを成す各`~item$は［
次に挙げる`~item$sctからなる`~tuple$
］である
— これらの~tupleは、 ( `~callable$oL, `型~list$oL, `省略可否~list$oL ) の形で記される：
◎
The items of an effective overload set are tuples of the form (callable, type list, optionality list) whose items are described below:
</p>

<dl class="def-list">
	<dt>`~callable@oL</dt>
	<dd>
<p>
`関数類$の~~種別に応じて，次で与えられる：
</p>
		<dl class="switch">
			<dt>`正則~演算$</dt>
			<dt>`静的~演算$</dt>
			<dt>`構築子~演算$</dt>
			<dd>
【同じ識別子を共有する】いずれかの`演算$
</dd>

			<dt>`有名~構築子$</dt>
			<dd>
【同じ識別子を共有する】いずれかの`拡張属性$
</dd>
		</dl>
◎
A callable is an operation if the effective overload set is for regular operations, static operations, or constructor operations; and it is an extended attribute if the effective overload set is for named constructors.
</dd>

	<dt>`型~list@oL</dt>
	<dd>
0 個~以上の~IDL型からなる`~list$
— `~callable$oL の引数たちにあてがわれているそれらになる。
◎
A type list is a list of IDL types.
</dd>

	<dt>`省略可否~list@oL</dt>
	<dd>
<p>
0 個~以上の
`省略可否 値@
からなる`~list$。
各 `省略可否 値$にアリな値は、次のいずれかであり，所与の~indexに位置する引数について指示する：
</p>

<ul><li>`必須^C
— 引数は省略できない
</li><li>`省略可^C
— `随意~引数$である
</li><li>`可変個^C
— `可変個~引数$である
</li></ul>

◎
An optionality list is a list of three possible optionality values – "required", "optional" or "variadic" – indicating whether the argument at a given index was declared as being optional or corresponds to a variadic argument.
</dd>
</dl>

<p>
各`~tuple$は、［
引数~値~listに伴われる一連の型であって，当の`関数類$の呼出nに許容され得るもの
］を表現する。
［
`随意~引数$／［
`可変個的な$`関数類$ （すなわち，演算または構築子）
］］の利用に因り、`有効~多重定義~集合$内には，同じ種類の`関数類$を識別する複数の~itemが存在し得る。
◎
Each tuple represents an allowable invocation of the operation, constructor, or callback function with an argument value list of the given types. Due to the use of optional arguments and variadic operations and constructors, there may be multiple items in an effective overload set identifying the same operation or constructor.
</p>

<div class="algorithm">
<p>
`有効~多重定義~集合を算出する@
方法は、以下の~algoに述べられる。
必要に応じて，上述の入力~変数が利用される：
◎
The algorithm below describes how to compute the effective overload set. The following input variables are used, if they are required:
</p>

<ul>
	<li>
%A は［
演算／有名~構築子
］の識別子
◎
the identifier of the operation or named constructor is A
</li>
	<li>
%N は引数個数
◎
the argument count is N
</li>
	<li>
%I は~ifc
◎
the interface is I
</li>
</ul>

<p>
以下において言及される，拡張属性の引数は、その`有名~引数~list$の引数を指すとする。
◎
Whenever an argument of an extended attribute is mentioned, it is referring to an argument of the extended attribute’s named argument list.
</p>

<ol>
	<li>
%S ~LET 新たな`有順序~集合$
◎
Let S be an ordered set.
</li>
	<li>
<p>
%F ~LET ［
`有効~多重定義~集合$の種類に応じて，次で与えられる~itemたち
］からなる新たな`有順序~集合$：
◎
Let F be an ordered set with items as follows, according to the kind of effective overload set:
</p>
		<ul class="switch">
			<li>
正則~演算
⇒
%I 上で定義された`正則~演算$のうち，［
その識別子 ~EQ %A
］なるもの
◎
For regular operations
• The elements of F are the regular operations with identifier A defined on interface I.
</li>
			<li>
静的~演算
⇒
%I 上で定義された`静的~演算$のうち，［
その識別子 ~EQ %A
］なるもの
◎
For static operations
• The elements of F are the static operations with identifier A defined on interface I.
</li>
			<li>
構築子
⇒
%I 上の`構築子~演算$たち
◎
For constructors
• The elements of F are the constructor operations on interface I.
</li>
			<li>
有名~構築子
⇒
%I 上の `NamedConstructor$x `拡張属性$のうち，［
その`有名~引数~list$の識別子 ~EQ %A
］なるもの
◎
For named constructors
• The elements of F are the [NamedConstructor] extended attributes on interface I whose named argument lists’ identifiers are A.
</li>
		</ul>
	</li>
	<li>
<p>
%maxarg ~LET ［
%F 内の各~item（`関数類$）が宣言している引数~個数
］の最大
— ただし，［
`可変個的な$`関数類$
］の中の`可変個~引数$は、 1 個の引数に数える
◎
Let maxarg be the maximum number of arguments the operations, constructor extended attributes or callback functions in F are declared to take. For variadic operations and constructor extended attributes, the argument on which the ellipsis appears counts as a single argument.
</p>

<p class="note">注記：
したがって
`void f(long x, long... y);^c
が宣言している引数~個数は 2 個と見なされる。
◎
Note: So void f(long x, long... y); is considered to be declared to take two arguments.
</p>
	</li>
	<li>
%max ~LET `max$op( %maxarg, %N )
◎
Let max be max(maxarg, N).
</li>
	<li>
<p>
%F 内の
~EACH( %X )
に対し：
◎
For each operation or extended attribute X in F:
</p>
		<ol>
			<li>
%引数~list ~LET %X がとるよう宣言されている引数たちからなる`~list$
◎
Let arguments be the list of arguments X is declared to take.
</li>
			<li>
%n ~LET %引数~list の`~size$
（したがって %n ~LTE %max ）
◎
Let n be the size of arguments.
</li>
			<li>
%型~list ~LET 新たな`~list$
（これは、`型~list$oLを与えることになる）
◎
Let types be a type list.
</li>
			<li>
%省略可否~list ~LET 新たな`~list$
（これは、`省略可否~list$oLを与えることになる）
◎
Let optionalityValues be an optionality list.
</li>
			<li>
<p>
%引数~list 内の
~EACH( %引数 )
に対し：
◎
For each argument in arguments:
</p>
				<ol>
					<li>
%型~list に %引数 の型を`付加する$
◎
Append the type of argument to types.
</li>
					<li>
%省略可否~list に［
%引数 に応じて，次で与えられる値
］を`付加する$
⇒＃
`可変個~引数$ならば `可変個^C ／
~ELSE_ `随意~引数$ならば `省略可^C ／
~ELSE_ `必須^C
◎
Append "variadic" to optionalityValues if argument is a final, variadic argument, "optional" if argument is optional, and "required" otherwise.
</li>
				</ol>
			</li>
			<li>
%S に
`~tuple$( %X, %型~list, %省略可否~list )
を`付加する$set
◎
Append the tuple (X, types, optionalityValues) to S.
</li>
			<li>
<p>
~IF［
%X は `可変個的な$ものと宣言されている
］：
◎
If X is declared to be variadic, then:
</p>
				<ol>
					<li>
<p>
%n ~LTE %i ~LT %max なる
~EACH( 整数 %i )
に対し，~~昇順に：
◎
For each i in the range n to max − 1, inclusive:
</p>
						<ol>
							<li>
%t ~LET %型~list の複製
◎
Let t be a type list.
</li>
							<li>
%o ~LET %省略可否~list の複製
◎
Let o be an optionality list.
◎
For each j in the range 0 to n − 1, inclusive:
• Append types[j] to t.
• Append optionalityValues[j] to o.
</li>
							<li>
<p>
%n ~LTE %j ~LTE %i なる
~EACH( 整数 %j )
に対し：
◎
For each j in the range n to i, inclusive:
</p>
								<ol>
									<li>
%t に %型~list[ %n ~MINUS 1] を`付加する$
◎
Append types[n − 1] to t.
</li>
									<li>
%o に `可変個^C を`付加する$
◎
Append "variadic" to o.
</li>
								</ol>
							</li>
							<li>
%S に`~tuple$( %X, %t, %o ) を`付加する$set
◎
Append the tuple (X, t, o) to S.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
%n ~GT %i ~GTE 0 なる
~EACH( 整数 %i )
に対し，~~降順に：
◎
Let i be n − 1.
◎
While i ≥ 0:
</p>
				<ol>
					<li>
~IF［
%省略可否~list[ %i ] ~EQ `必須^C
］
⇒
~BREAK
◎
If arguments[i] is not optional (i.e., it is not marked as "optional" and is not a final, variadic argument), then break.
</li>
					<li>
［
%t, %o
］ ~LET 順に［
%型~list, %省略可否~list
］の複製
◎
↓</li>
					<li>
［
%t, %o
］それぞれに対し，その尾部から 0 個~以上の~itemたちを［
その`~size$ ~EQ %i
］になるよう除去する
◎
Let t be a type list.
◎
Let o be an optionality list.
◎
For each j in the range 0 to i − 1, inclusive:
• Append types[j] to t.
• Append optionalityValues[j] to o.
</li>
					<li>
<p>
%S に`~tuple$( %X, %t, %o ) を`付加する$set
◎
Append the tuple (X, t, o) to S.
</p>

<p class="note">注記：
%i ~EQ 0 ならば %t, %o は`空$になる。
◎
Note: if i is 0, this means to add to S the tuple (X, « », « »); (where "« »" represents an empty list).
◎
Set i to i − 1.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>
</div>

<div class="example" id="_dist-example-1_">
<p>
次の~ifcに対し：
◎
For the following interface:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  /* f1 */ void f(DOMString %a);
  /* f2 */ void f(Node %a, DOMString %b, double... %c);
  /* f3 */ void f();
  /* f4 */ void f(Event %a, DOMString %b, optional DOMString %c, double... %d);
};
</pre>

<p>
`Node^T と `Event^T は、どの~objからも両方同時には実装できない，別々の~ifcとする。
［
識別子 `f^sym, 引数個数 4
］の`正則~演算$からなる`有効~多重定義~集合$は：
◎
assuming Node and Event are two other interfaces of which no object can implement both, the effective overload set for regular operations with identifier f and argument count 4 is:
</p>

<pre class="set">
«
  (f1, « DOMString »,                           « `必須^C »),
  (f2, « Node, DOMString »,                     « `必須^C, `必須^C »),
  (f2, « Node, DOMString, double »,             « `必須^C, `必須^C, `可変個^C »),
  (f2, « Node, DOMString, double, double »,     « `必須^C, `必須^C, `可変個^C, `可変個^C »),
  (f3, « »,                                     « »),
  (f4, « Event, DOMString »,                    « `必須^C, `必須^C »),
  (f4, « Event, DOMString, DOMString »,         « `必須^C, `必須^C, `省略可^C »),
  (f4, « Event, DOMString, DOMString, double », « `必須^C, `必須^C, `省略可^C, `可変個^C »)
»
</pre>

</div>

<div class="algorithm">
<p>
2 つの型は、次の~algoが ~T を返すならば，
`判別-可能@
であるとされる：
◎
Two types are distinguishable if the following algorithm returns true.
</p>

<ol>
	<li>
<div class="p">
<p>
~IF［
一方の型は`~nullable型を内包する$
］~AND［
他方の型は 次のいずれかを満たす
］
⇒
~RET ~F：
</p>

<ul><li>`~nullable型を内包する$
</li><li>［
`共用体~型$である
］~AND［
その`平坦~化~mb型$に`辞書~型$が含まれている
］
</li><li>`辞書~型$である
</li></ul>

◎
If one type includes a nullable type and the other type either includes a nullable type, is a union type with flattened member types including a dictionary type, or is a dictionary type, return false.
</div>

<div class="example">

<p>
次の各~pairは、いずれも判別-可能でない：
</p>

<ul><li>`double?^T と `Dictionary1^T
</li><li>`(Interface1 or long)?^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString?)^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString)?^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString?)^T
</li></ul>

<p>
（ `Interface1^T, `Interface2^T は ~ifc型，
`Dictionary1^T は 辞書~型とする）
</p>

◎
None of the following pairs are distinguishable:
•  double? and Dictionary1
• (Interface1 or long)? and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString?)
• (Dictionary1 or long) and (Interface2 or DOMString)?
• (Dictionary1 or long) and (Interface2 or DOMString?) 
</div>

	</li>
	<li>
~IF［
両方の型とも［
`共用体~型$ ／`~nullable$`共用体~型$
］である
］
⇒
~RET
両者のどの`~mb型$どうしも互いに判別-可能であるならば ~T ／
~ELSE_ ~F
◎
If both types are either a union type or nullable union type, return true if each member type of the one is distinguishable with each member type of the other, or false otherwise.
</li>
	<li>
~IF［
一方の型は［
`共用体~型$ ／~nullable共用体~型
］である
］
⇒
~RET 
その共用体のどの`~mb型$も 他方の型と`判別-可能$であるならば ~T ／
~ELSE_ ~F
◎
If one type is a union type or nullable union type, return true if each member type of the union type is distinguishable with the non-union type, or false otherwise.
</li>
	<li>
<div class="p">
<p>
~IF［
2 つ各 `最内縁の型$は，［
下の表に現れるか, 下の表に現れる分類に入る
］~AND［［
対応する欄に “●” 印がある
］~OR［
対応する欄に英字が在って，表の下に指定される追加的な要件を満たす
］］
⇒
~RET ~T
</p>

<p>
ここで、所与の型 %T の
`最内縁の型@
は，次に従って決定される型とする：
</p>
		<ol>
			<li>
~IF［
%T は`注釈付きの型$である
］
⇒
%T ~SET %T の`内縁~型$anO
</li>
			<li>
~IF［
%T は`~nullable型$である
］
⇒
%T ~SET %T の`内縁~型$
</li>
			<li>
~RET %T
</li>
		</ol>

◎
Consider the two "innermost" types derived by taking each type’s inner type if it is an annotated type, and then taking its inner type inner type if the result is a nullable type. If these two innermost types appear or are in categories appearing in the following table and there is a “●” mark in the corresponding entry or there is a letter in the corresponding entry and the designated additional requirement below the table is satisfied, then return true. Otherwise return false.
</div>

<p>
下の表に現れる分類は、次で定義される：
◎
Categories:
</p>

		<ul>
			<li>
~ifc類
⇒＃
`~ifc型$ ／
`~buffer~source型$
◎
interface-like
• interface types
• buffer source types
</li>
			<li>
辞書~類
⇒＃
`辞書~型$ ／
`~record型$ ／
`~callback~ifc型$
◎
dictionary-like
• dictionary types
• record types
• callback interface types
</li>
			<li>
連列~類
⇒＃
`連列~型$ ／
`凍結d配列~型$
◎
sequence-like
• sequence types
• frozen array types
</li>
</ul>

<div style="overflow:auto;">
<table id="distinguishable-table">
<thead><tr><th>
<th><span>`boolean$T
</span><th><span>`数量-型$
</span><th><span>`文字列~型$
</span><th><span>`object$T
</span><th><span>`symbol$T
</span><th><span>~ifc類
</span><th><span>`~callback関数$
</span><th><span>辞書~類
</span><th><span>連列~類
</span></thead><tbody>

<tr><th>`boolean$T
<td><td>●<td>●<td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`数量-型$
<td colspan="1"><td><td>●<td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`文字列~型$
<td colspan="2"><td><td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`object$T
<td colspan="3"><td><td>●<td><td><td><td>

<tr><th>`symbol$T
<td colspan="4"><td><td>●<td>●<td>●<td>●

<tr><th>~ifc~類
<td colspan="5"><td>(a)<td>●<td>●<td>●

<tr><th>~callback関数
<td colspan="6"><td><td><td>●

<tr><th>辞書~類
<td colspan="7">
<td><td>●

<tr><th>連列~類
<td colspan="8"><td>

</tbody></table></div>

<p>
(a) — 識別される 2 つの~ifc類の型が同じ`~platform~obj$に実装されることは、起こり得ない（特に， 2 つは同じ~ifcでない）。
◎
The two identified interface-like types are not the same, and no single platform object implements both interface-like types.
</p>

	</li>
	<li>
~RET ~F
◎
↑</li>
</ol>
</div>

<div class="example">

<ul>
	<li>
`double$T と `DOMString$T とは判別-可能になる
— `数量-型$と`文字列~型$の交差する欄に ● 印があるので。
◎
double and DOMString are distinguishable because there is a ● at the intersection of numeric types with string types.
</li>
	<li>
`double$T と `long$T は判別-可能でない
— 両者とも`数量-型$であり，`数量-型$と`数量-型$の交差する欄に ● 印はないので
◎
double and long are not distinguishable because they are both numeric types, and there is no ● or letter at the intersection of numeric types with numeric types.
</li>
	<li>
<p>
次の~IDL片が与えられたとするとき：
◎
Given:
</p>

<pre class="webidl">
callback interface CBIface {
    void handle();
};

[Exposed=Window]
interface Iface {
    attribute DOMString attr2;
};

dictionary Dict {
    DOMString field1;
};
</pre>

<p>
`CBIface^T は、
`Iface^T とは 判別-可能になる（辞書~類 と ~ifc類が交差する欄に ● があるので）が，
`Dict^T とは判別-可能にならない（辞書~類どうしが交差する欄に ● がないので）
◎
CBIface is distinguishable from Iface because there’s a ● at the intersection of dictionary-like and interface-like, but it is not distinguishable from Dict because there’s no ● at the intersection of dictionary-like and itself.
</li>
	<li>
`~promise型$は、上の表には現れていないので，他のどの型とも判別-可能でない。
◎
Promise types do not appear in the above table, and as a consequence are not distinguishable with any other type.
</li>
</ul>
</div>

<p>
所与の
( 負でない整数 %~size 【すなわち，引数~個数】, `有効~多重定義~集合$ %S )
に対し、
%T は %S を成す`~item$のうち［
その`型~list$oLの`~size$ ~EQ %~size
］を満たすものからなる集合とするとき，
%T が複数個の~itemからなるならば：
◎
If there is more than one item in an effective overload set that has a given type list size,＼
</p>

<ul>
	<li>
次を満たす~index %i ~IN { 0 〜 %~size ~MINUS 1 } が存在しなければナラナイ
⇒
任意の［
%A, %B ~IN %T
］に対し，次が満たされる
⇒
［
%A ~EQ %B
］~OR［
%A の`型~list$oL[ %i ],
%B の`型~list$oL[ %i ]
は`判別-可能$である
］
◎
then for those items there must be an index i such that for each pair of items the types at index i are distinguishable.＼
</li>
	<li>
<p>
前項の条件を満たす~indexのうち最小のものを，
%~size に対する
`判別~引数~index@
という。
◎
The lowest such index is termed the distinguishing argument index for the items of the effective overload set with the given type list size.
</p>

<div class="example">
<p>
前の例に示された`有効~多重定義~集合$を考える。
`型~list$oL ~size %~size ~IN { 2, 3, 4 } に対するそれは、いずれも複数の~itemを含む。
これらいずれの %~size に対しても、［
`Node^T, `Event^T
］は`判別-可能$になるので，`判別~引数~index$は 0 になる。
◎
Consider the effective overload set shown in the previous example. There are multiple items in the set with type lists 2, 3 and 4. For each of these type list size, the distinguishing argument index is 0, since Node and Event are distinguishable.
</p>

<p>
しかしながら，次の多重定義の利用は妥当でない：
◎
The following use of overloading however is invalid:
</p>

<pre class="webidl">
[Exposed=Window]
interface B {
  void f(DOMString %x);
  void f(USVString %x);
};
</pre>

<p>
`DOMString$T と `USVString$T は判別-可能でないので。
◎
since DOMString and USVString are not distinguishable.
</p>
</div>

	</li>
	<li>
<p>
加えて，任意の
%j ~IN { 0 〜 ( %~size に対する`判別~引数~index$ ~MINUS 1 ) }
に対し、次が満たされなければナラナイ
⇒
任意の［
%A, %B ~IN %T
］に対し，次が満たされる
⇒
［
%A の`型~list$oL[ %i ] ~EQ† %B の`型~list$oL[ %i ]
］~AND［
%A の`省略可否~list$oL[ %i ] ~EQ %B の`省略可否~list$oL[ %i ]
］
◎
In addition, for each index j, where j is less than the distinguishing argument index for a given type list size, the types at index j in all of the items’ type lists must be the same, and the optionality values at index j in all of the items’ optionality lists must be the same.
</p>

<p class="trans-note">【†
`注釈付きの型$とその`内縁~型$anOが，この比較において区別されるのかどうか、はっきりしない
】</p>

<div class="example">
<p>
次は妥当でない：
◎
The following is invalid:
</p>

<pre class="webidl">
[Exposed=Window]
interface B {
  /* f1 */ void f(DOMString %w);
  /* f2 */ void f(long %w, double %x, Node %y, Node %z);
  /* f3 */ void f(double %w, double %x, DOMString %y, Node %z);
};
</pre>

<p>
引数個数 4 に対する`有効~多重定義~集合$は：
◎
For argument count 4, the effective overload set is:
</p>

<pre class="set">
«
  (f1, « DOMString »,                       « `必須^C »),
  (f2, « long, double, Node, Node »,        « `必須^C, `必須^C, `必須^C, `必須^C »),
  (f3, « double, double, DOMString, Node », « `必須^C, `必須^C, `必須^C, `必須^C »)
»
</pre>

<p>
であり、`型~list$oL ~size 4 の~itemを調べると，
`Node^T と `DOMString$T は`判別-可能$なので、
`判別~引数~index$は 2 になる。
しかしながら，これらの 2 つの多重定義の~index 0 に位置する引数~型は異なるので、この多重定義は妥当でない。
◎
Looking at items with type list size 4, the distinguishing argument index is 2, since Node and DOMString are distinguishable. However, since the arguments in these two overloads at index 0 are different, the overloading is invalid.
</p>
</div>

	</li>
</ul>

<div class="trans-note">

<p>【
複雑な条件だが，概念的には、共用体~型を利用して，多重定義された宣言を等価な単独の宣言に併合するために必要な条件が意図されている様に見られる。
例えば、`先に挙げられた例＠#_dist-example-1_$hrefは，次のように書き換え得る：
】</p>

<pre class="webidl">
[Exposed=Window]
interface A {
             /*---f4----*/ /*-f2-*/     /*---f1----*/    /*-f3-*/
  void f(
    optional ( Event     or Node     or   DOMString ) %a, /*----*/
    optional   DOMString             %b, /*---------------------*/
    optional ( DOMString or double ) %c, /*---------------------*/
               double...             %d  /*---------------------*/
  );
};
</pre>

<p>【
これらの書き方の相違は、
`idl-overloading-vs-union$sec
に述べられている。
】</p>

</div>

				<section id="idl-overloading-vs-union">
<h4 title="Overloading vs. union types">2.5.7.1. 多重定義 vs. 共用体~型</h4>

~INFORMATIVE

<p>
~IDL`演算$を定義している仕様にとって、`多重定義$と［［
`共用体~型$, `随意~引数$
］の組合n
］とは，特能が~~重複しているように見えるかもしれない。
◎
For specifications defining IDL operations, it might seem that overloads and a combination of union types and optional arguments have some feature overlap.
</p>

<p>
先ず，重要な点として、`多重定義$の挙動は［
`共用体~型$, `随意~引数$
］の間で相違するので，他方を利用しても 全部的には`定義できない^emことに注意（もちろん、~Web~IDL型~systemの目的を無為にしかねない 追加的な注釈文が供されない限り）。
例えば `CanvasDrawPath$T ~ifcに定義される `stroke()$M 演算 `HTML$r を考える：
◎
It is first important to note that overloads have different behaviors than union types or optional arguments, and one cannot be fully defined using the other (unless, of course, additional prose is provided, which can defeat the purpose of the Web IDL type system). For example, consider the stroke() operations defined on the CanvasDrawPath interface [HTML]:
</p>

<pre class="webidl">
interface CanvasDrawPathExcerpt {
  void stroke();
  void stroke(Path2D %path);
};
</pre>

<p>
~ES言語束縛により、
`CanvasDrawPathExcerpt^T を実装している~obj上で
`stroke(undefined)^c
を~callした場合，
2 個目の多重定義を~callしようと試みる結果 `TypeError$jE になる
— `undefined^jv は `Path2D$T に`変換-＠#es-to-interface$hrefできないので。
しかしながら~~仮に、演算が，`随意~引数$を伴って定義されていて，一つに併合されていた場合：
◎
Per the ECMAScript language binding, calling stroke(undefined) on an object implementing CanvasDrawPathExcerpt would attempt to call the second overload, yielding a TypeError since undefined cannot be converted to a Path2D. However, if the operations were instead defined with optional arguments and merged into one,
</p>

<pre class="webidl">
interface CanvasDrawPathExcerptOptional {
  void stroke(optional Path2D %path);
};
</pre>

<p>
`多重定義~解決~algo$は、同じ
`stroke(undefined)^c
~callに対し， %path 引数 を在さないものと扱うことになり，例外は投出されない。
◎
the overload resolution algorithm would treat the path argument as not present given the same call stroke(undefined), and not throw any exceptions.
</p>

<p class="note">注記：
この特定0の例では、後者の挙動が，実際に~Web開発者たちが一般に期待するものである。
今日 `CanvasDrawPath$T を設計するなら、 `stroke()^M には`随意~引数$を利用することになるであろう。
◎
Note: For this particular example, the latter behavior is actually what Web developers would generally expect. If CanvasDrawPath were to be designed today, optional arguments would be used for stroke().
</p>

<p>
加えて，意味論的な相違点もある。
`共用体~型$は、通例的に
“どの型もおよそ同じ仕方で働く”
ようなイミで利用される。
対照的に，`多重定義$された演算は、 C++ の多重定義などの言語~特能に上手く対応付けられるように設計されており、通例的に，所与の引数の異なる型ごとに何を行うかについて相当の相違点がある演算たちに、より良く収まる。
しかしながら，ほとんどの事例では、そのような相違点がある演算たちには 異なる名前を伴わせて，~Web開発者からの混同を避けるのが最善になる
— ~ES言語は、言語~levelの多重定義を供さないので。
そのため，多重定義は、新たな~APIに適切になるのは稀であり，旧来の~APIや特化された状況下で現れることが多い。
◎
Additionally, there are semantic differences as well. Union types are usually used in the sense that "any of the types would work in about the same way". In contrast, overloaded operations are designed to map well to language features such as C++ overloading, and are usually a better fit for operations with more substantial differences in what they do given arguments of different types. However, in most cases, operations with such substantial differences are best off with different names to avoid confusion for Web developers, since the ECMAScript language does not provide language-level overloading. As such, overloads are rarely appropriate for new APIs, instead often appearing in legacy APIs or in specialized circumstances.
</p>

<p>
どの~Web~IDL言語~特能を利用するか決定するのに難がある事例のために、次の推奨と例を提供する：
◎
That being said, we offer the following recommendations and examples in case of difficulties to determine what Web IDL language feature to use:
</p>

<ul>
	<li>
<p>
演算の返り値~型を 引数の型ごとに異ならせる必要があるような，通例的でない事例では、`多重定義$の方が，より表出力のある~IDL片になる。
<span class="note">
これが適切な~API設計になることは、まずない。
そのような事例では、別個の名前を伴う別々の演算にする方が，通例的に良くなる。
</span>
◎
In the unusual case where the operation needs to return values of different types for different argument types, overloading will result in more expressive IDL fragments. This is almost never appropriate API design, and separate operations with distinct names usually are a better choice for such cases.
</p>

<p>
演算 `calculate()^M は，［
`long$T, `DOMString$T, `CalculatableInterface^T （ `~ifc型$ ）
］を受容する引数を 1 個だけとり，引数と同じ型の値を返すとする。
この場合、`多重定義$された演算を利用して~IDL片を書く方が明瞭になるであろう：
◎
Suppose there is an operation calculate() that accepts a long, DOMString, or CalculatableInterface (an interface type) as its only argument, and returns a value of the same type as its argument. It would be clearer to write the IDL fragment using overloaded operations as
</p>

<pre class="webidl">
interface A {
  long calculate(long %input);
  DOMString calculate(DOMString %input);
  CalculatableInterface calculate(CalculatableInterface %input);
};
</pre>

<p>
`~typedef$を伴う`共用体~型$を利用するよりも：
◎
than using a union type with a typedef as
</p>

<pre class="webidl">
typedef (long or DOMString or CalculatableInterface) Calculatable;
interface A {
  Calculatable calculate(Calculatable %input);
};
</pre>

<p>
これは、返り値が常に %入力 と同じ型になる事実を伝えないので。
◎
which does not convey the fact that the return value is always of the same type as input.
</p>

<p>
多重定義のいずれかの返り値~型が `void$T であるときには、より問題になる
— `共用体~型$は`~mb型$に `void$T すら包含できないので。
その事例では、返り値~型を定義する適切な注釈文を伴わせた上で，返り値~型に `any$T を利用する必要があり、表出力はさらに乏しくなる。
◎
The problem is exacerbated when one of the overloads has a return type of void, since union types cannot even contain void as a member type. In that case, a return type of any needs to be used with appropriate prose defining the return type, further decreasing expressiveness.
</p>

<p>
仕様~化する `calculate()^M が新たな~APIで，互換性の懸念はない場合、多重定義される演算に対しては，互いに異なる名前を利用することが示唆される
— おそらく，次のように：
◎
If the specified calculate() is a new API and does not have any compatibility concerns, it is suggested to use different names for the overloaded operations, perhaps as
</p>

<pre class="webidl">
interface A {
  long calculateNumber(long %input);
  DOMString calculateString(DOMString %input);
  CalculatableInterface calculateCalculatableInterface(CalculatableInterface %input);
};
</pre>

<p>
こうすれば、~Web開発者は，明示的かつ一義的な~codeを書けるようになる。
◎
which allows Web developers to write explicit and unambiguous code.
</p>
	</li>
	<li class="trans-note">
<p>【
他にも、演算ごとに異なる拡張属性や特殊~演算を指定する場合も、多重定義する他にないであろう
— 例えば：
】</p>

<pre class="webidl">
interface A {
  `NewObject$x X calculate(B %a);
              X calculate(C %a);
};
</pre>

<p>【
（このように指定される演算は，ほぼないと思われるが、このような指定-法を総じて禁止している箇所は，この仕様の中には見当たらない。）
】</p>

	</li>
	<li>
<p>
引数の型や個数ごとに，演算が意味論的に有意に異なる場合、`多重定義$が選好される。
ここでも，そのような局面では、別個の名前を伴わせた別々の演算を作成する方が通例的には良いが、旧来の~APIには，この~patternに従うものもある。
◎
When the operation has significantly different semantics for different argument types or lengths, overloading is preferred. Again, in such scenarios, it is usually better to create separate operations with distinct names, but legacy APIs sometimes follow this pattern.
</p>

<p>
例として，
`CSS$T ~ifc
【現在は`~ns$に変更されている】
の `supports()$M 演算
`CSS3-CONDITIONAL$r `CSSOM$r
は、次の~IDL片として定義されている：
◎
As an example, the supports(property, value) and supports(conditionText) operations of the CSS interface are defined as the following IDL fragment [CSS3-CONDITIONAL] [CSSOM].
</p>

<pre class="webidl">
partial interface CSS {
  static boolean supports(CSSOMString %property, CSSOMString %value);
  static boolean supports(CSSOMString %conditionText);
};
</pre>

<p>
この~IDL片は、`随意~引数$を利用して，次のように書き直すこともできる：
◎
Using optional arguments one can rewrite the IDL fragment as follows:
</p>

<pre class="webidl">
partial interface CSSExcerptOptional {
  static boolean supports(CSSOMString %propertyOrConditionText, optional CSSOMString %value);
};
</pre>

<p>
この~versionの~IDLは、最初のそれより短くなっているが， 1 個目の引数に全く異なる 2 つの概念が~~併合されている。
`多重定義$しない場合、注釈文による演算の定義を読むことなく，
“ %property ／ %conditionText は %value と~pairになるのか？ ”
のような問いに答えるのは、はるかに困難になる。
そのため、この~versionは，最初のものより著しく読み取り難くなっている。
◎
Even though the IDL is shorter in the second version, two distinctively different concepts are conflated in the first argument. Without overloads, the question "is property or conditionText paired with value?" is much more difficult to answer without reading the prose definition of the operation. This makes the second version remarkably less readable than the first.
</p>

<p>
別の考慮点として、`多重定義$された演算の注釈文は，演算ごとに別々の~block内に指定できるので、仕様を読むときにも書くときにも援助になることが挙げられる
— このことは、`随意~引数$にはあてはまらない。
すなわち，最初の事例に対しては、仕様~策定者は，演算の定義を 次のように注釈文に書けるようになる：
◎
Another consideration is that the prose for overloaded operations can be specified in separate blocks, which can aid in both reading and writing specifications. This is not the case for optional arguments. This means that in the first case the specification author can write the prose definition of the operations as:
</p>

<div class="algorithm">
<p>
<code class="idlmember">supports(%property, %value)</code>
~methの~call時には、次を走らすモノトスル：
◎
The supports(property, value) method, when called, must run these steps:
</p>

<ol><li>…
</li></ol>

<hr>

<p>
<code class="idlmember">supports(%conditionText)</code>
~methの~call時には、次を走らすモノトスル：
◎
The supports(conditionText) method, when called, must run these steps:
</p>

<ol><li>…
</li></ol>

</div>

<p>
それでも`随意~引数$として %value を利用する場合、仕様~策定者は，［
実質的に`多重定義~解決~algo$を再現するような，~~模範的~style
］で~textを書く必要がある。
◎
Yet using value as an optional argument, the specification author has to use more boilerplate-style text to effectively replicate the overload resolution algorithm.
</p>

<div class="algorithm">
<p>
<code class="idlmember">supports(%propertyOrConditionText, %value)</code>
~methの~call時には、次を走らすモノトスル：
◎
The supports(propertyOrConditionText, value) method, when called, must run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
%value は与えられている
］：
◎
If value is given, then:
</p>
				<ol>
					<li>
%property ~LET %propertyOrConditionText
◎
Let property be propertyOrConditionText.
</li>
					<li>
…
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%conditionText ~LET %propertyOrConditionText
◎
Let conditionText be propertyOrConditionText.
</li>
					<li>
…
</li>
				</ol>
			</li>
		</ol>

</div>

<p>
2 つの多重定義が共有する部分が少ししかないなら、多重定義~解決を~IDLの仕組みに委ねる方が良い。
◎
If the two overloads have little to no shared parts, it is better to leave overload resolution to the IDL mechanism.
</p>
	</li>
	<li>
<p>
演算が 複数の引数をとり，その それぞれが複数の型を受容していて，異なる引数どうしの型が組にされていない場合、`共用体~型$の他は~~実現できそうにないこともある。
◎
If the operation accepts multiple types for multiple arguments with no coupling between types of different arguments, union types can sometimes be the only viable solution.
</p>

<pre class="webidl">
typedef (long long or DOMString or CalculatableInterface) SupportedArgument;
interface A {
  void add(SupportedArgument %operand1, SupportedArgument %operand2);
};
</pre>

<p>
上の `add()^M 演算を，`多重定義$を利用して指定しようとした場合、次が要求されることになる：
◎
For the add() operation above, to specify it using overloads would require
</p>

<pre class="webidl">
interface A {
  void add(long long %operand1, long long %operand2);
  void add(long long %operand1, DOMString %operand2);
  void add(long long %operand1, CalculatableInterface %operand2);
  void add(DOMString %operand1, long long %operand2);
  void add(DOMString %operand1, DOMString %operand2);
  void add(DOMString %operand1, CalculatableInterface %operand2);
  void add(CalculatableInterface %operand1, long long %operand2);
  void add(CalculatableInterface %operand1, DOMString %operand2);
  void add(CalculatableInterface %operand1, CalculatableInterface %operand2);
};
</pre>

<p>
対応する注釈文も， 9 回重ねることになる。
◎
and nine times the corresponding prose!
</p>
			</li>
			<li>
<p>
仕様~策定者には、 `missing$C 引数と `undefined^jv 引数とを，~ES言語束縛において同じ仕方で扱うことが奨励される。
◎
Specification authors are encouraged to treat missing argument and undefined argument the same way in the ECMAScript language binding.
</p>

<p>
次の~IDL片が与えられたとき：
◎
Given the following IDL fragment:
</p>

<pre class="webidl">
interface A {
  void foo();
  void foo(Node? %arg);
};
</pre>

<p>
~ES言語束縛を利用する下で，
`foo()^M を~callするとき、引数に［
`undefined^jv ／ `null^jv
］を渡した場合は，
%arg を ~NULL に設定した上で 2 個目の `foo()^M 演算に対応する手続きを走らすことになる。
一方で、引数を省いた場合は， 1 個目の多重定義に行くことになり、多くの~API利用者にとって意外な挙動になるであろう。
仕様~策定者には、代わりに，`随意~引数$を利用することが奨励される
— そうすれば、引数が省かれたときも `undefined^jv のときも，
“%arg は在さない” 
に分類されることになる。
◎
Using the ECMAScript language binding, calling foo(undefined) and foo(null) would both run the steps corresponding to the foo(arg) operation, with arg set to null, while foo() alone would go to the first overload. This can be a surprising behavior for many API users. Instead, specification authors are encouraged to use an optional argument, which would categorize both foo() and foo(undefined) as "arg is not present".
</p>

<pre class="webidl">
interface A {
  void foo(optional Node? %arg);
};
</pre>

<p>
一般に，随意~性は、多重定義は利用せず， `optional^sym ~keywordを利用して表出するのが最善になる。
◎
In general, optionality is best expressed using the optional keyword, and not using overloads.
</p>

	</li>
</ul>

<p>
上のどの分類にも収まらない事例で，どの~styleを選ぶかは、仕様~策定者に委ねられる
— ほとんどの場合、どちらの~styleでも，意図される挙動を簡便に述べるに足るので。
しかしながら、［
`共用体~型$, `随意~引数$
］の定義と`変換~algo＠#es-to-union$hrefの方が，`多重定義$の`それ＠#dfn-overload-resolution-algorithm$hrefよりも実装して選り分けるのは単純であり、通例的に，~ES言語束縛において より成句的な~APIになる。
したがって，他の考慮点が適用されない限り、`共用体~型$や`随意~引数$を選ぶ方が既定になる。
◎
When the case fits none of the categories above, it is up to the specification author to choose the style, since it is most likely that either style would sufficiently and conveniently describe the intended behavior. However, the definition and conversion algorithms of union types and optional arguments are simpler to implement and reason about than those of overloads, and usually result in more idiomatic APIs in the ECMAScript language binding. Thus, unless any other considerations apply, union types (and/or optional arguments) are the default choice.
</p>

<p>
仕様~策定者は、適切かつ簡便であると見出したなら，共用体~型と多重定義を混ぜ合わせるのも自由である。
◎
Specifications are also free to mix and match union types and overloads, if the author finds it appropriate and convenient.
</p>

				</section>
			</section>
			<section id="idl-iterable">
<h4 title="Iterable declarations">2.5.8. 可反復~宣言</h4>

<p>
~ifcは
`可反復@
になるように宣言できる。
そのためには、`~ifc$の本体~内で
`可反復~宣言@
（`Iterable$g に合致-）を利用する。
◎
An interface can be declared to be iterable by using an iterable declaration (matching Iterable) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  iterable&lt;`value_type^i&gt;;
  iterable&lt;`key_type^i, `value_type^i&gt;;
};
</pre>

<p>
可反復として宣言された~ifcを実装している~objは、値の連列を得るために反復できるようになる。
◎
Objects implementing an interface that is declared to be iterable support being iterated over to obtain a sequence of values.
</p>

<p class="note">注記：
~ES言語束縛においては、可反復な~ifcは，その`~ifc原型~obj$上に［
`entries^jp, `forEach^jp, `keys^jp, `values^jp, `iterator$jS
］~propを持つことになる。
◎
Note: In the ECMAScript language binding, an interface that is iterable will have entries, forEach, keys, values, and @@iterator properties on its interface prototype object.
</p>

<p>
~parameterに与えられた型の個数が：
◎
↓</p>

<ul>
	<li>
1 個ならば，~ifcは
`値~反復子@
を持つことになる
— それは、所与の型の値たちを供する。
◎
If a single type parameter is given, then the interface has a value iterator and provides values of the specified type.＼
</li>
	<li>
2 個ならば，~ifcは
`~pair反復子@
を持つことになる
— それは、［
所与の
( ~key型, 値~型 )
の値からなる`値~pair$
］たちを供する。
◎
If two type parameters are given, then the interface has a pair iterator and provides value pairs with the given types.
</li>
</ul>

<p>
各
`値~pair@
は、
2 つの`~item$sct
( `~key$vP, `値$vP )
からなる`構造体$である：
◎
A value pair, given a key type and a value type, is a struct with two items:
</p>

<ol>
	<li>
`~key@vP
は、~key型の~IDL値を値にとる，［
`名前$sct ~EQ `key^l 【 “~key” 】
］なる`~item$sctである
◎
an item whose name is "key", which is referred to as the value pair's key, and whose value is an IDL value of the key type;
</li>
	<li>
`値@vP
は、値~型の~IDL値を値にとる，［
`名前$sct ~EQ `value^l 【 “値” 】
］なる`~item$sctである
◎
an item whose name is "value", which is referred to as the value pair's value, and whose value is an IDL value of the value type.
</li>
</ol>

<p>
`値~反復子$は、`有index~propを~support$する~ifc上を除き，宣言されてはナラナイ。
`値~反復子$の値~型は、`有index~prop取得子$が返す型と同じでなければナラナイ。
`値~反復子$は暗黙的に，当の~objの有index~prop上を反復するように定義される。
◎
A value iterator must only be declared on an interface that supports indexed properties. The value-type of the value iterator must be the same as the type returned by the indexed property getter. A value iterator is implicitly defined to iterate over the object’s indexed properties.
</p>

<p>
`~pair反復子$は、`有index~propを~support$する~ifc上に宣言されてはナラナイ。
◎
A pair iterator must not be declared on an interface that supports indexed properties.
</p>

<p>
`~pair反復子$を伴う`~ifc$は、付帯する注釈文にて，`~ifc$の各~instanceごとに［
`反復される値~pair@
の~listと称される，`値~pair$の`~list$
］を定義しなければナラナイ。
◎
Prose accompanying an interface with a pair iterator must define a list of value pairs for each instance of the interface, which is the list of value pairs to iterate over.
</p>

<div class="note">

<p>
`値~反復子$に対し生成される~ES `forEach^jp ~methは、
`Array.prototype.forEach^c が行うように，その~callbackを呼出す。
`~pair反復子$用の `forEach^jp ~methは、
`Map.prototype.forEach^c が行うように，その~callbackを呼出す。
◎
The ECMAScript forEach method that is generated for a value iterator invokes its callback like Array.prototype.forEach does, and the forEach method for a pair iterator invokes its callback like Map.prototype.forEach does.
</p>

<p>
現在，`値~反復子$は`有index~propを~support$する~ifcに限り許容されているので、
`forEach^jp ~methを配列のように利用することもイミを成す。
`値~反復子$は、次のものにも必要かもしれない：
(a) `有index~propを~support$しない~ifc上, あるいは
(b) ~callbackを，代わりに `Set.protoype.forEach^c のように呼出すような `forEach^jp ~methに対して（ここでの~keyは、値と同じ）。
そのような `forEach^jp ~methを必要とする~APIを再~作成している策定者は、`Enhancement request for Iterables$fIされたし。
◎
Since value iterators are currently allowed only on interfaces that support indexed properties, it makes sense to use an Array-like forEach method. There may be a need for value iterators (a) on interfaces that do not support indexed properties, or (b) with a forEach method that instead invokes its callback like Set.protoype.forEach (where the key is the same as the value). If you’re creating an API that needs such a forEach method, please file an issue.
</p>

</div>

<p class="note">注記：
`配列~反復子~obj$は，このように働く。
`有index~propを~support$する ~ifcに対しては、［
`entries^jp ／ `keys^jp ／ `values^jp ／ `iterator$jS
］から返される反復子~objは，実際の`配列~反復子~obj$である。
◎
Note: This is how array iterator objects work. For interfaces that support indexed properties, the iterator objects returned by entries, keys, values, and @@iterator are actual array iterator objects.
</p>

<p>
［
`可反復~宣言$を伴う`~ifc$, および それが`継承した~ifcたち$
］には、次に挙げる名前の`~ifc~mb$が在ってはナラナイ
⇒
`entries^l, `forEach^l, `keys^l, `values^l
◎
Interfaces with iterable declarations must not have any interface members named "entries", "forEach", "keys", or "values", or have any inherited interfaces that have members with these names.
</p>

<div class="example">
<p>
次の~ifcを考える。
`SessionManager^T は、文字列 %username を~keyに，一連の `Session^T ~objに~accessできるようにする：
◎
Consider the following interface SessionManager, which allows access to a number of Session objects keyed by username:
</p>

<pre class="webidl">
[Exposed=Window]
interface SessionManager {
  Session getSessionForUser(DOMString %username);

  iterable&lt;DOMString, Session&gt;;
};

[Exposed=Window]
interface Session {
  readonly attribute DOMString username;
  /* <!--cp-some-code--> */
};
</pre>

<p>
反復子の挙動は、次の様に定義することもできる：
◎
The behavior of the iterator could be defined like so:
</p>

<blockquote>
`反復される値~pair$の~listを成す各`値~pair$の
( `~key$vP / `値$vP )
~pairは，
( `username^M  / ［
`SessionManager^T ~obj上で open している `Session^T ~obj
］ )
で与えられ、~listは `username^M の昇順で~sortされる。
◎
The value pairs to iterate over are the list of value pairs with the key being the username and the value being the open Session object on the SessionManager object corresponding to that username, sorted by username.
</blockquote>

<p>
~ES言語束縛においては、
`SessionManager^T `~ifc$用の`~ifc原型~obj$は、次の~methを持つことになる：
◎
In the ECMAScript language binding, the interface prototype object for the SessionManager interface＼
</p>

<ul>
	<li>
`values^jp ~meth：
被呼出時には［［
次回に反復される値を返す `next^jp ~meth
］を持つ反復子~obj
］を返す関数。
◎
has a values method that is a function, which, when invoked, returns an iterator object that itself has a next method that returns the next value to be iterated over.＼
</li>
	<li>
`keys^jp ~meth：
一連の `Session^T ~objの `username^M を反復する。
◎
↓</li>
	<li>
`entries^jp ~meth：
一連の ( `username^M / `Session^T ~obj ) ~pairを反復する。
◎
It has keys and entries methods that iterate over the usernames of session objects and username/Session object pairs, respectively.＼
</li>
	<li>
`iterator$jS ~meth：
`entries^jp ~methと同じ値をとり，
`SessionManager^T を `for..of^c ~loopの中でも利用できるようする。
◎
It also has a @@iterator method that allows a SessionManager to be used in a for..of loop that has the same value as the entries method:
</li>
</ul>

<pre class="es-code">
/* <span class="comment">
`SessionManager^T の~instanceを取得する。
2 人の利用者 `anna^l, `brian^l 用の session があるとする：
◎
Get an instance of SessionManager. Assume that it has sessions for two users, "anna" and "brian".
</span> */
var %sm = getSessionManager();

typeof SessionManager.prototype.values;  /* <!--cp-eval-function--> */
var %it = %sm.values();    /* <span class="comment">
`values()^c は反復子~objを返す。
◎
values() returns an iterator object
</span> */
typeof %it.next;          /* <!--cp-eval-function--> */

/* <span class="comment">
次の~loopは、順に `anna^l, `brian^l を log することになる：
◎
This loop will log "anna" and then "brian".
</span> */
for (;;) {
  let %result = %it.next();
  if (%result.done) {
    break;
  }
  let %session = %result.value;
  console.log(%session.username);
}

/* <span class="comment">
次の~loopも、順に `anna^l, `brian^l を log することになる：
◎
This loop will also log "anna" and then "brian".
</span> */
for (let %username of %sm.keys()) {
  console.log(%username);
}

/* <span class="comment">
同じことを成遂げる別の仕方：
◎
Yet another way of accomplishing the same.
</span> */
for (let [%username, %session] of %sm) {
  console.log(%username);
}
</pre>

</div>

<p>
［
`可反復~宣言$を伴う~ifc, および それが`継承した~ifcたち$
］には、次に挙げるものが宣言されていてはナラナイ
⇒
別の`可反復~宣言$,
`非同期c可反復~宣言$,
`~maplike 宣言$,
`~setlike 宣言$
◎
An interface must not have more than one iterable declaration. The inherited interfaces of an interface with an iterable declaration must not also have an iterable declaration. An interface with an iterable declaration and its inherited interfaces must not have a maplike declaration, setlike declaration, or asynchronously iterable declaration.
</p>

<p>
`可反復~宣言$に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to iterable declarations: [Exposed], [SecureContext].

</p>

<data class="grammar" value="
Iterable
OptionalType
"></data>

			</section>
			<section id="idl-async-iterable">
<h4 title="Asynchronously iterable declarations">2.5.9. 非同期に反復-可能な宣言</h4>

<p>
`~ifc$は、非同期に反復-可能（ `asynchronously iterable^en ）になるように宣言できる。
そのためには、`~ifc$の本体~内で
`非同期c可反復~宣言@
（ `AsyncIterable$g に合致-）を利用する。
◎
An interface can be declared to be asynchronously iterable by using an asynchronously iterable declaration (matching AsyncIterable) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  async iterable&lt;`key_type^i, `value_type^i&gt;;
};
</pre>

<p>
非同期に反復-可能になるよう宣言された`~ifc$を`実装-$する~objは、非同期に値の連列を得るように反復できるようになる。
◎
Objects that implement an interface that is declared to be asynchronously iterable support being iterated over asynchronously to obtain a sequence of values.
</p>

<p class="note">注記：
~ES言語~束縛においては、非同期に反復-可能な~ifcは，その`~ifc原型~obj$上に［
`entries^jp, `keys^jp, `values^jp, `asyncIterator$jS
］~propを持つことになる。
◎
Note: In the ECMAScript language binding, an interface that is asynchronously iterable will have entries, keys, values, and @@asyncIterator properties on its interface prototype object.
</p>

<p>
`非同期c可反復~宣言$を伴う`~ifc$ %I は、付帯する注釈文にて，
`次回の反復~結果を取得する@
~algoを定義しなければナラナイ。
この~algoは、所与の
( %I の~instanceを与える `this$V 値,
`現在の状態@
)
に対し，
`~promise_T$ を返さなければナラナイ
— それは、［
反復の終端-を通達する `undefined^jv ／ 次の 3 要素からなる~tuple
］で解決される：
◎
Prose accompanying an interface with an asynchronously iterable declaration must define a get the next iteration result algorithm. This algorithm receives a this value, which is an instance of the interface that it is defined for, and the current state. It must return a Promise that either resolves with undefined – to signal the end of the iteration – or a tuple with three elements:
</p>

<ol>
	<li>
宣言に与えられた 1 個目の型の値
◎
a value of the first type given in the declaration;
</li>
	<li>
宣言にて与えられた 2 個目~型の値
◎
a value of the second type given in the declaration;
</li>
	<li>
~algoの次回の呼出nにて，`現在の状態$として渡し戻される不透明な値
◎
an opaque value that is passed back to the next invocation of the algorithm as the current state.
</li>
</ol>

<p>
注釈文は、`非同期c可反復~宣言$を伴う`~ifc$用に
`非同期~反復子~初期化~手続き@
を定義してもヨイ。
それは、新たに作成された反復子~objを伴って~callされることになる。
◎
The prose may also define asynchronous iterator initialization steps for the interface with an asynchronously iterable declaration, which would then be called with the newly created iterator object.
</p>

<p>
［
`非同期c可反復~宣言$を伴う`~ifc$, および それが`継承した~ifcたち$
］には、次に挙げる名前の`~ifc~mb$が在ってはナラナイ
⇒
`entries^l, `keys^l, `values^l
◎
Interfaces with an asynchronously iterable declaration must not have any interface members named "entries", "keys", or "values", or have any inherited interfaces that have interface members with these names.
</p>

<div class="example">

<p>
次の~ifcを考える。
`SessionManager^T は、文字列 %username を~keyに，一連の `Session^T ~objに~accessできるようにする：
◎
Consider the following interface SessionManager, which allows access to a number of Session objects keyed by username:
</p>

<pre>
[Exposed=Window]
interface SessionManager {
  Session getSessionForUser(DOMString %username);

  async iterable&lt;DOMString, Session&gt;;
};

[Exposed=Window]
interface Session {
  readonly attribute DOMString username;
  // ...
};
</pre>

<p>
反復子の挙動は、次の様に定義することもできる：
◎
The behavior of the iterator could be defined like so:
</p>

<blockquote>

<p>
`SessionManager^T 用の`次回の反復~結果を取得する$ときは、次の手続きを走らす：
◎
To get the next iteration result for SessionManager, run the following steps:
</p>

<ol>
	<li>
%promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
<p>
%key ~LET ［
`現在の状態$に応じて，対応する条件を満たす値が存在するならば それ ／
~ELSE_ ~NULL
］：
◎
Let key be the following value, if it exists, or null otherwise:
</p>
		<dl class="switch">
			<dt>
`まだ開始されてない^C
◎
If current state is "not yet started"
</dt>
			<dd>
`this$V 内の各［
~open中の~sessionの `username^M
］のうち，辞書式~順序で最初のもの
◎
the smallest username in this’s open sessions, in lexicographical order
</dd>

			<dt>
その他
◎
Otherwise
</dt>
			<dd>
`this$V 内の各［
~open中の~sessionの `username^M
］のうち，辞書式~順序で［
`現在の状態$より後, かつ最初の
］もの
◎
the smallest username in this’s open sessions that is greater than current state, in lexicographical order
</dd>
		</dl>

<p class="note">注記：
`現在の状態$は、もはや，~open中の~sessionでないこともある。
◎
Note: current state might no longer be present in the open sessions.
</p>
	</li>
	<li>
~IF［
%key ~NEQ ~NULL
］
⇒
`undefined^jv で %promise を解決する
◎
If key is null, then:
• Resolve promise with undefined.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%session ~LET %key に対応する `Session^T ~obj
◎
Let session be the Session object corresponding to key.
</li>
			<li>
( %username, %session, %username )
で %promise を解決する
◎
Resolve promise with (username, session, username).
</li>
		</ol>
	</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>

</blockquote>

<div class="p">
<p>
~ES言語束縛においては、
`SessionManager^T `~ifc$用の`~ifc原型~obj$は、次の~methを持つことになる：
◎
In the ECMAScript language binding, the interface prototype object for the SessionManager interface has＼
</p>

<ul>
	<li>
`values^jp ~meth：
被呼出時には［［
次回に反復される値を返す `next^jp ~meth
］を持つ非同期~反復子~obj
］を返す関数。
◎
a values method that is a function, which, when invoked, returns an asynchronous iterator object that itself has a next method that returns the next value to be iterated over.＼
</li>
	<li>
`keys^jp ~meth：
一連の `Session^T ~objの `username^M を反復する。
◎
↓</li>
	<li>
`entries^jp ~meth：
一連の ( `username^M / `Session^T ~obj ) ~pairを反復する。
◎
It has keys and entries methods that iterate over the usernames of session objects and (username, Session) object pairs, respectively.＼
</li>
	<li>
`asyncIterator$jS ~meth：
`entries^jp ~methと同じ値をとり，
`SessionManager^T を `for await..of^c ~loopの中でも利用できるようする。
◎
It also has a @@asyncIterator method that allows a SessionManager to be used in a for await..of loop that has the same value as the entries method:
</li>
</ul>

</div>

<pre class="es-code">
/* <span class="comment">
`SessionManager^T の~instanceを取得する。
2 人の利用者 `anna^l, `brian^l 用の session があるとする：
◎
Get an instance of SessionManager. Assume that it has sessions for two users, "anna" and "brian".
</span> */

var %sm = getSessionManager();

typeof SessionManager.prototype.values;  /* <!--cp-eval-function--> */
var %it = %sm.values();    /* <span class="comment">
`values()^c は反復子~objを返す。
◎
values() returns an iterator object
</span> */
typeof %it.next;          /* <!--cp-eval-function--> */

/* <span class="comment">
次の~loopは、順に `anna^l, `brian^l を log することになる：
◎
This loop will log "anna" and then "brian".
</span> */
for await (let %username of %sm.keys()) {
  console.log(%username);
}

/* <span class="comment">
同じことを成遂げる別の仕方：
◎
Yet another way of accomplishing the same.
</span> */
for await (let [%username, %session] of %sm) {
  console.log(%username);
}
</pre>

</div>

<p>
［
`非同期c可反復~宣言$を伴う~ifc, および それが`継承した~ifcたち$
］には、次に挙げるものが宣言されていてはナラナイ
⇒
`可反復~宣言$,
別の`非同期c可反復~宣言$,
`~maplike 宣言$,
`~setlike 宣言$
◎
An interface must not have more than one asynchronously iterable declaration. The inherited interfaces of an interface with an asynchronously iterable declaration must not also have an asynchronously iterable declaration. An interface with an asynchronously iterable declaration and its inherited interfaces must not have a maplike declaration, setlike declaration, or iterable declaration.
</p>

<p>
`非同期c可反復~宣言$に適用-可能な拡張属性は
⇒＃
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to asynchronously iterable declarations: [Exposed], [SecureContext].
</p>

<p class="issue">
これらの`拡張属性$は、現時点では まだ【他の仕様に】織り込まれていない。
織り込まれたときには、その効果は，期待されるものになることになる。
◎
these extended attributes are not currently taken into account. When they are, the effect will be as you would expect.
</p>

<data class="grammar" value="
AsyncIterable
"></data>

			</section>
			<section id="idl-maplike">
<h4 title="Maplike declarations">2.5.10. ~maplike 宣言</h4>

<p>
~ifcは
`~maplike@
（ `maplike^en ）になるように宣言できる。
そのためには、`~ifc$の本体~内で
`~maplike 宣言@
（
`ReadWriteMaplike$g ／
`readonly^sym `MaplikeRest$g
いずれかに合致-）を利用する。
◎
An interface can be declared to be maplike by using a maplike declaration (matching ReadWriteMaplike or readonly MaplikeRest) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly maplike&lt;`key_type^i, `value_type^i&gt;;
  maplike&lt;`key_type^i, `value_type^i&gt;;
};
</pre>

<p>
~maplikeになるように宣言された~ifcを実装する~objは、その一連の［
`~map~entry@
と呼ばれる~key-value
］からなる，有順序~listを表現する。
~keyおよび~valueに利用される型は、~maplike 宣言の山括弧の中で与えられる。
それらの~keyは一意になることが要求される。
◎
Objects implementing an interface that is declared to be maplike represent an ordered list of key–value pairs known as its map entries. The types used for the keys and values are given in the angle brackets of the maplike declaration. Keys are required to be unique.
</p>

<p>
`~maplike$ ~ifcを実装している~objの`~map~entry$の~listは、~objの作成~時には空である。
これらの`~map~entry$が どう変化するかは、~ifcに付帯している注釈文にて述べれる。
◎
The map entries of an object implementing a maplike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the map entries of an object change.
</p>

<p>
~maplike~ifcは、一連の~map~entryを~queryするための，言語束縛に適切な~APIを~supportする。
`readonly^sym ~keywordが利用されなかった場合†、~map~entryを改変するための~APIも~supportする。
【† 以下， “可書~maplike” とも記される】
◎
Maplike interfaces support an API for querying the map entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the map entries.
</p>

<p class="note">注記：
~ES言語束縛においては、一連の~map~entryとヤリトリするための~APIは，
~ESにて可用な `Map$jt ~objに類似する。
`readonly^sym ~keywordが利用された場合、それは［
`entries^jp, `forEach^jp, `get^jp, `has^jp, `keys^jp, `values^jp, `iterator$jS
］~meth, および `size^jp 取得子を含む。
可書~maplikeに対しては、更に［
`clear^jp, `delete^jp, `set^jp
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the map entries is similar to that available on ECMAScript Map objects. If the readonly keyword is used, this includes entries, forEach, get, has, keys, values, @@iterator methods, and a size getter. For read–write maplikes, it also includes clear, delete, and set methods.
</p>

<p>
［
~maplike~ifc, および それが`継承した~ifcたち$
］には、次に挙げる名前の`~ifc~mb$が在ってはナラナイ
⇒
`entries^l, `forEach^l, `get^l, `has^l, `keys^l, `size^l, `values^l
◎
Maplike interfaces must not have any interface members named "entries", "forEach", "get", "has", "keys", "size", or "values", or have any inherited interfaces that have members with these names.＼
</p>
<p>
［
可書~maplike~ifc, および それが`継承した~ifcたち$
］には、次に挙げる名前の［
`属性$／`定数$
］が在ってはナラナイ
⇒
`clear^l, `delete^l, `set^l
◎
Read–write maplike interfaces must not have any attributes or constants named "clear", "delete", or "set", or have any inherited interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
［
名前 ~IN { `clear^l, `delete^l, `set^l }
］なる演算は，可書~maplike~ifc上にも許容され、その場合，~ES言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named "clear", "delete", or "set" are allowed on read–write maplike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
［
~maplike~ifc, および それが`継承した~ifcたち$
］には、次に挙げるものが宣言されていてはナラナイ
⇒
`可反復~宣言$,
`非同期c可反復~宣言$,
別の`~maplike 宣言$,
`~setlike 宣言$,
`有index~prop取得子$
◎
An interface must not have more than one maplike declaration. The inherited interfaces of a maplike interface must not also have a maplike declaration. A maplike interface and its inherited interfaces must not have an iterable declaration, an asynchronously iterable declaration, a setlike declaration, or an indexed property getter.
</p>

<data class="grammar" value="
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteMaplike
MaplikeRest
"></data>

<p>
`~maplike 宣言$に適用-可能な`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to maplike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>

			</section>
			<section id="idl-setlike">
<h4 title="Setlike declarations">2.5.11. ~setlike 宣言</h4>

<p>
~ifcは
`~setlike@
（ `setlike^en ）になるように宣言できる。
そのためには、`~ifc$の本体~内で
`~setlike 宣言@
（
`ReadWriteSetlike$g ／
`readonly^sym `SetlikeRest$g
いずれかに合致-）を利用する。
◎
An interface can be declared to be setlike by using a setlike declaration (matching ReadWriteSetlike or readonly SetlikeRest) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly setlike&lt;`type^i&gt;;
  setlike&lt;`type^i&gt;;
};
</pre>

<p>
~setlikeになるように宣言された~ifcを実装する~objは、その一連の［
`~set~entry@
と呼ばれる~value
］からなる，有順序~listを表現する。
~valueに利用される型は、~setlike 宣言の山括弧の中で与えられる。
それらの~valueは一意になることが要求される。
◎
Objects implementing an interface that is declared to be setlike represent an ordered list of values known as its set entries. The type of the values is given in the angle brackets of the setlike declaration. Values are required to be unique.
</p>

<p>
`~setlike$ ~ifcを実装している~objの`~set~entry$の~listは、~objの作成~時には空である。
これらの`~set~entry$が どう変化するかは、~ifcに付帯している注釈文にて述べれる。
◎
The set entries of an object implementing a setlike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the set entries of an object change.
</p>

<p>
~setlike~ifcは、一連の~set~entryを~queryするための，言語束縛に適切な~APIを~supportする。
`readonly^sym ~keywordが利用されなかった場合†、~set~entryを改変するための API も~supportする。
【† 以下， “可書~setlike” とも記される】
◎
Setlike interfaces support an API for querying the set entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the set entries.
</p>

<p class="note">注記：
~ES言語束縛においては、一連の~set~entryとヤリトリするための~APIは，
~ESにて可用な `Set$jt ~objに類似する。
`readonly^sym ~keywordが利用された場合、それは［
`entries^jp, `forEach^jp, `has^jp, `keys^jp, `values^jp, `iterator$jS
］~meth, および `size^jp 取得子を含む。
可書~setlikeに対しては、更に［
`add^jp, `clear^jp, `delete^jp
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the set entries is similar to that available on ECMAScript Set objects. If the readonly keyword is used, this includes entries, forEach, has, keys, values, @@iterator methods, and a size getter. For read–write setlikes, it also includes add, clear, and delete methods.
</p>

<p>
［
~setlike~ifc, および それが`継承した~ifcたち$
］には、次に挙げる名前の`~ifc~mb$が在ってはナラナイ
⇒
`entries^l, `forEach^l, `has^l, `keys^l, `size^l, `values^l
◎
Setlike interfaces must not have any interface members named "entries", "forEach", "has", "keys", "size", or "values", or have any inherited interfaces that have members with these names.＼
</p>

<p>
［
可書~setlike~ifc, および それが`継承した~ifcたち$
］には、次に挙げる名前の［
`属性$／`定数$
］が在ってはナラナイ
⇒
`add^l, `clear^l, `delete^l
◎
Read–write setlike interfaces must not have any attributes or constants named "add", "clear", or "delete", or have any inherited interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
名前［
`add^l／`clear^l／`delete^l
］の演算は，可書~setlike~ifc上にも許容され、その場合，~ES言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named "add", "clear", or "delete" are allowed on read–write setlike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
［
~setlike~ifc, および それが`継承した~ifcたち$
］には、次に挙げるものが宣言されていてはナラナイ
⇒
`可反復~宣言$,
`非同期c可反復~宣言$,
`~maplike 宣言$,
別の`~setlike 宣言$,
`有index~prop取得子$
◎
An interface must not have more than one setlike declaration. The inherited interfaces of a setlike interface must not also have a setlike declaration. A setlike interface and its inherited interfaces must not have an iterable declaration, an asynchronously iterable declaration, a maplike declaration, or an indexed property getter.
</p>

<data class="grammar" value="
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteSetlike
SetlikeRest
"></data>

<p>
`~setlike 宣言$に適用-可能な`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to setlike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>

			</section>
		</section>
		<section id="idl-namespaces">
<h3 title="Namespaces">2.6. ~ns</h3>

<p>
`~ns@
（ `namespace^en ）は、いくつかの挙動が結付けられた 大域~singletonを宣言する，`定義$（ `Namespace$g に合致-）である。
◎
A namespace is a definition (matching Namespace) that declares a global singleton with associated behaviors.
</p>

<p class="trans-note">【
すなわち、~instanceは 1 個しか存在し得ない（かつ，その 1 個は常に存在する）ような~ifcのようなものと捉えればよいであろう。
】</p>

<pre class="syntax">
namespace `identifier^i {
  /* namespace_members... */
};
</pre>

<p>
`~ns$は、その宣言を成す波括弧の合間に現れる［
`正則~演算$, `読専$な`正則~属性$
］の集合（ `NamespaceMembers$g に合致-）の指定である
— これらの［
演算／属性
］~mbは、
`~ns~mb@
と称され，~nsの中に梱包された挙動を述べる。
◎
A namespace is a specification of a set of namespace members (matching NamespaceMembers), which are the regular operations and read only regular attributes that appear between the braces in the namespace declaration. These operations and attributes describe the behaviors packaged into the namespace.
</p>

<p>
~ifcのときと同じく，~ns用の~IDLは、
`部分的~ns定義@
（ `partial^sym `Namespace$g に合致-）を利用して，複数の部分に分割できる。
部分的~ns定義の`識別子$は、その~ns定義の識別子と同じでなければナラナイ。
各 部分的~nsに現れる，すべての~mbは、その~ns自身を成す~mbと見なされる。
◎
As with interfaces, the IDL for namespaces can be split into multiple parts by using partial namespace definitions (matching partial Namespace). The identifier of a partial namespace definition must be the same as the identifier of a namespace definition. All of the members that appear on each of the partial namespace definitions are considered to be members of the namespace itself.
</p>

<pre class="syntax">
namespace `SomeNamespace^mk {
  /* namespace_members... */
};

partial namespace `SomeNamespace^mk {
  /* namespace_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義のときと同じく，部分的~ns定義に意図される用途は、~nsの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補佐することである。
◎
Note: As with partial interface definitions, partial namespace definitions are intended for use as a specification editorial aide, allowing the definition of a namespace to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p>
~mbたちが現れる順序は、
`~ES言語束縛＠#es-namespaces$href
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcや辞書と違って、~nsは型を作成しないことに注意。
◎
Note that unlike interfaces or dictionaries, namespaces do not create types.
</p>

<p>
この仕様に定義される拡張属性のうち，~nsに適用-可能なのは
`Exposed$x, `SecureContext$x
に限られる。
◎
Of the extended attributes defined in this specification, only the [Exposed] and [SecureContext] extended attributes are applicable to namespaces.
</p>

<p>
`~ns$は、 `Exposed$x `拡張属性$で注釈されなければナラナイ。
◎
Namespaces must be annotated with the [Exposed] extended attribute.
</p>

<data class="grammar" value="
Partial
PartialDefinition
Namespace
NamespaceMembers
NamespaceMember
"></data>

<div class="example">

<p>
次の`~IDL片$は、`~ns$を定義する：
◎
The following IDL fragment defines a namespace.
</p>

<pre class="webidl">
[Exposed=Window]【！＊原文抜け】
namespace VectorUtils {
  readonly attribute Vector unit;
  double dotProduct(Vector %x, Vector %y);
  Vector crossProduct(Vector %x, Vector %y);
};
</pre>

<p>
~ES実装は、（原型 `ObjectPrototype$jI を伴う）単純~objであった `VectorUtils^jp ~data~propを，宣言された各［
演算に対する列挙-可能な~data~prop ／
属性に対する列挙-可能な取得-のみの~accessor
］たちで公開することになる：
◎
An ECMAScript implementation would then expose a global VectorUtils data property which was a simple object (with prototype %ObjectPrototype%) with enumerable data properties for each declared operation, and enumerable get-only accessors for each declared attribute:
</p>

<pre class="es-code">
Object.getPrototypeOf(VectorUtils);  /* <span class="comment">
`Object.prototype^c に評価される。
◎
Evaluates to Object.prototype.
</span> */
Object.keys(VectorUtils);            /* <span class="comment">
<samp>[`dotProduct^l, `crossProduct^l]</samp> に評価される。
◎
Evaluates to ["dotProduct", "crossProduct"].
</span> */
Object.getOwnPropertyDescriptor(VectorUtils, "dotProduct"); /*
<span class="comment">
<samp>{ value: &lt;ある関数&gt;, enumerable: true,  configurable: true, writable: true }</samp>
に評価される。
◎
Evaluates to { value: &lt;a function&gt;, enumerable: true, configurable: true, writable: true }.
</span> */
Object.getOwnPropertyDescriptor(VectorUtils, "unit");        /*
<span class="comment">
<samp>{ get: &lt;ある関数&gt;, enumerable: true, configurable: true }</samp>
に評価される。
◎
Evaluates to { get: &lt;a function&gt;, enumerable: true, configurable: true }.
</span> */
</pre>
</div>

		</section>
		<section id="idl-dictionaries">
<h3 title="Dictionaries">2.7. 辞書</h3>

<p>
`辞書@
（ `dictionary^en ）は、［
有順序かつ固定的な，一連の［
`辞書~mb@
と呼ばれる`~entry$
］からなる`有順序~map$~data型
］を定義するために利用される，`定義$（ `Dictionary$g に合致-）である。
各`~entry$の`~key$は文字列であり，その`値$は定義の中で指定される特定0の型に属する。
◎
A dictionary is a definition (matching Dictionary) used to define an ordered map data type with a fixed, ordered set of entries, termed dictionary members, where keys are strings and values are of a particular type specified in the definition.
</p>

<pre class="syntax">
dictionary `identifier^i {
  /* dictionary_members... */
};
</pre>

<p>
辞書は常に値渡しである。
辞書が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に辞書が渡された際に，その辞書への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの辞書も複製であり、それに対する改変は~platform~objからは可視にならないことになる。
◎
Dictionaries are always passed by value. In language bindings where a dictionary is represented by an object of some kind, passing a dictionary to a platform object will not result in a reference to the dictionary being kept by that object. Similarly, any dictionary returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
辞書は 別の辞書を
`継承-@diC
するように定義できる。
辞書の識別子に~colonと`識別子$が後続する場合、後者の識別子が，継承される辞書を識別する。
この識別子は、辞書を識別するものでなければナラナイ。
◎
A dictionary can be defined to inherit from another dictionary. If the identifier of the dictionary is followed by a colon and a identifier, then that identifier identifies the inherited dictionary. The identifier must identify a dictionary.
</p>

<p>
辞書は、その継承~階層が循環するように宣言されてはナラナイ。
すなわち，辞書 %D は、 %D 自身を継承することも,
%D を継承する別の辞書を継承することもできない，等々。
◎
A dictionary must not be declared such that its inheritance hierarchy has a cycle. That is, a dictionary A cannot inherit from itself, nor can it inherit from another dictionary B that inherits from A, and so on.
</p>

<pre class="syntax">
dictionary `Base^mk {
  /* dictionary_members... */
};

dictionary `Derived^i : `Base^mk {
  /* dictionary_members... */
};
</pre>

<p>
所与の辞書~型 %D が
`継承した辞書たち@
とは、
%D が直接間接に継承するすべての辞書が成す集合である。
%D が他の辞書を`継承-$diCしない場合、集合は空になる。
他の場合、集合は［
%D が`継承-$diCした辞書 %E,
%E が`継承した辞書たち$すべて
］を含む。
◎
The inherited dictionaries of a given dictionary D is the set of all dictionaries that D inherits from, directly or indirectly. If D does not inherit from another dictionary, then the set is empty. Otherwise, the set includes the dictionary E that D inherits from and all of E’s inherited dictionaries.
</p>

<p>
型 %D の辞書~値 %d は、［
%D および %D が`継承した辞書たち$
］上で定義される辞書~mbに対応する~key-valueを持ち得る。
%d 上における各~辞書~mbの存在pは、それが %D において`必須~辞書~mb$であると指定されていない限り，随意である。
辞書~mbは、［
%d が~mbの`識別子$を
`~keyに伴う~entryを包含する＠~INFRA#map-exists$href
］ならば， %d 上に
`在する@
（ `present^en ）といい，そうでなければ
<dfn>`在さない$</dfn>
（ `not present^en ）という。
辞書~mbは，随意で
`既定~値@diC
も持ち得る。
それは、 %d 上にその~mb値が指定されずに %d が`~platform~obj$に渡された際に，辞書~mbに利用される値になる。
既定~値を伴う辞書~mbは常に在するものと見なされる。
◎
A dictionary value of type D can have key–value pairs corresponding to the dictionary members defined on D and on any of D’s inherited dictionaries. On a given dictionary value, the presence of each dictionary member is optional, unless that member is specified as required. A dictionary member is said to be present in a dictionary value if the value contains an entry with the key given by the member’s identifier, otherwise it is not present. Dictionary members can also optionally have a default value, which is the value to use for the dictionary member when passing a value to a platform object that does not have a specified value. Dictionary members with default values are always considered to be present.
</p>

<p class="note">注記：
~ES言語束縛においては、
`undefined^jv 値は`在さない$ものと扱われ，適用-可能な所では`既定~値$diCが用いられることになる。
◎
In the ECMAScript binding, a value of undefined is treated as not present, or will trigger the default value where applicable.
</p>

<div class="p">
<p>
`有順序~map$ %M は、次をすべて満たすならば，暗黙的に辞書~型 %D の値として扱える：
</p>

<ul>
	<li>
%M を成すどの`~entry$に対しても，次を満たす［
%D を成す`辞書~mb$
］がある
⇒
［
`~key$は、辞書~mbの`識別子$に一致する文字列である
］~AND［
`値$は、辞書~mbの型の値である
］
</li>
	<li>
前項による対応の下で
⇒
［
%M における~entryたちの順序は、 %D における辞書~mbたちの順序に一致する
］~AND［
%D を成すどの`必須~辞書~mb$にも，対応する %M の~entryがある
］
</li>
</ul>

◎
An ordered map with string keys can be implicitly treated as a dictionary value of a specific dictionary D if all of its entries correspond to dictionary members, in the correct order and with the correct types, and with appropriate entries for any required dictionary members.
</div>

<div class="example">

<pre class="idl">
dictionary Descriptor {
  DOMString name;
  sequence&lt;unsigned long&gt; serviceIdentifiers;
};
</pre>

<p>
`Descriptor^T 辞書は、次の手続きのように作成することもできる：
◎
A Descriptor dictionary could be created as in the following steps:
</p>

<ol>
	<li>
%識別子 ~LET « 1, 3, 7 »
◎
Let identifiers be « 1, 3, 7 ».
</li>
	<li>
~RET «[ `name^l → `test^l, `serviceIdentifiers^l → %識別子 ]»
◎
Return «[ "name" → "test", "serviceIdentifiers" → identifiers ]».
</li>
</ol>
</div>

<p class="advisement">
演算~引数の`既定~値$のときと同じく，
`boolean$T 型の`辞書~mb$に対しては、`既定~値$diCとして `true^V を利用しないことが強く示唆される。
さもなければ、 `undefined^jv に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
As with operation argument default values, it is strongly suggested not to use true as the default value for boolean-typed dictionary members, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>

<p>
各`辞書~mb$（ `DictionaryMember$g に合致-）は、型（ `Type$g に合致-）および, 後続の（ `identifier$g ~tokenで与えられる）`識別子$により指定され、その識別子が~key-valueの~key名になる。
◎
Each dictionary member (matching DictionaryMember) is specified as a type (matching Type) followed by an identifier (given by an identifier token following the type). The identifier is the key name of the key–value pair.＼
</p>

<div class="p">
<p>
辞書~mb型を与える `Type$g が：
</p>

<ul>
	<li>
`?^sym が後続する`識別子$である場合、その識別子は［
`~ifc$／`列挙$／`~callback関数$／`~callback~ifc$／`~typedef$
］を識別しなければナラナイ。
</li>
	<li>
`?^sym が後続しない`識別子$である場合、その識別子は［
`辞書$／前項に挙げたいずれかの定義
］を識別しなければナラナイ。
</li>
</ul>

◎
If the Type is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function, callback interface or typedef. If the dictionary member type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</div>

<p>
`辞書~mb$の型が`~typedef$の解決-後に`~nullable型$になる場合、その`内縁~型$は，`辞書~型$になってはナラナイ。
◎
If the type of the dictionary member, after resolving typedefs, is a nullable type, its inner type must not be a dictionary type.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i;
};
</pre>

<p>
識別子に `003D^U1 と値（ `DefaultValue$g に合致-）が後続している場合、それが辞書~mbの`既定~値$diCを与える。
◎
If the identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the dictionary member its default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i = "value";
};
</pre>

<p>
`既定~値$diCに［
`ConstValue$g ／
`null^sym ／
`string$g ~token ／
2 個の~token並び `[]^sym ／
2 個の~token並び `{}^sym
］が利用された場合、`演算$の引数の`既定~値$のときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a decimal token, one of the three special floating point literal values (Infinity, -Infinity or NaN), a string token, the two token sequence [], or the two token sequence {} is used as the default value, it is interpreted in the same way as for an operation’s optional argument default value.
</p>

<p>
`辞書~mb$の型が`列挙$である場合、その`既定~値$diCに指定される値は，その`列挙~値$のいずれかでなければナラナイ。
◎
If the type of the dictionary member is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>

<p>
辞書~mbの型の前に ~keyword `required^sym が置かれた場合、その~mbは
`必須~辞書~mb@
と見なされ，辞書~上に`在する$ことが要求される。
◎
If the type of the dictionary member is preceded by the required keyword, the member is considered a required dictionary member and must be present on the dictionary.
</p>

<pre class="syntax">
dictionary `identifier^i {
  required `type^i `identifier^i;
};
</pre>

<p>
辞書を成すどの~mbも、その型は，当の`辞書~型$を`内包して^iはナラナイ。
次のいずれかを満たす型 %T は、辞書~型 %D を`内包して^iいるとされる：
◎
The type of a dictionary member must not include the dictionary it appears on. A type includes a dictionary D if at least one of the following is true:
</p>

<ul>
	<li>
%T は %D である
◎
the type is D
</li>
	<li>
%T は %D を`継承-$diCしている辞書である
◎
the type is a dictionary that inherits from D
</li>
	<li>
%T は`~nullable型$であり，その`内縁~型$は %D を`内包して^iいる
◎
the type is a nullable type whose inner type includes D
</li>
	<li>
%T は［
`連列~型$／`凍結d配列~型$
］であり，その要素~型は %D を`内包して^iいる
◎
the type is a sequence type or frozen array whose element type includes D
</li>
	<li>
%T は`共用体~型$であり，そのいずれかの`~mb型$は %D を`内包して^iいる
◎
the type is a union type, one of whose member types includes D
</li>
	<li>
%T は辞書であり，そのいずれかの［
自前の／継承している
］~mbの型は %D を`内包して^iいる
◎
the type is a dictionary, one of whose members or inherited members has a type that includes D
</li>
	<li>
%T は `~record_KV$ であり， %V は %D を`内包して^iいる
◎
the type is record&lt;K, V&gt; where V includes D
</li>
</ul>

<p>
~ifcのときと同じく、辞書~用の~IDLは
`部分的~辞書~定義@
（ `partial^sym `Dictionary$g に合致-）を利用して複数の部分に分割できる。
部分的~辞書~定義の`識別子$は、当の辞書~定義の識別子と同じでなければナラナイ。
各 部分的~辞書~定義に現れるすべての~mbは、辞書~自身を成す~mbと見なされる。
◎
As with interfaces, the IDL for dictionaries can be split into multiple parts by using partial dictionary definitions (matching partial Dictionary). The identifier of a partial dictionary definition must be the same as the identifier of a dictionary definition. All of the members that appear on each of the partial dictionary definitions are considered to be members of the dictionary itself.
</p>

<pre class="syntax">
dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};

partial dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義のときと同じく，部分的~辞書~定義に意図される用途は、辞書の定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補佐することである。
◎
Note: As with partial interface definitions, partial dictionary definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p id="_order-of-dict-members_">
所与の辞書~上の`辞書~mb$は、継承された辞書~mbが 継承していない~mbより前に位置するように順序付けられる。
同じ辞書~定義~上の（部分的~辞書~定義もすべて含めた）すべての辞書~mbは、それらの識別子を構成する~Unicode符号位置により，辞書式に順序付けられる。
◎
The order of the dictionary members on a given dictionary is such that inherited dictionary members are ordered before non-inherited members, and the dictionary members on the one dictionary definition (including any partial dictionary definitions) are ordered lexicographically by the Unicode codepoints that comprise their identifiers.
</p>

<div class="note">
<p>
例えば，次の定義では：
◎
For example, with the following definitions:
</p>

<pre class="webidl">
dictionary B : A {
  long b;
  long a;
};

dictionary A {
  long c;
  long g;
};

dictionary C : B {
  long e;
  long f;
};

partial dictionary A {
  long h;
  long d;
};
</pre>

<p>
型 `C^T の辞書~値を成す`辞書~mb$の順序は［
`c^M, `d^M, `g^M, `h^M, `a^M, `b^M, `e^M, `f^M
］になる。
◎
the order of the dictionary members of a dictionary value of type C is c, d, g, h, a, b, e, f.
</p>

<p>
辞書の~mbは順序付けられることが要求される。
一部の言語束縛においては、~platform~objに辞書~値を渡した際に観測される挙動が，辞書~mbを取りに行く順序に依存するので。
例えば，次の追加的な~ifc：
◎
Dictionaries are required to have their members ordered because in some language bindings the behavior observed when passing a dictionary value to a platform object depends on the order the dictionary members are fetched. For example, consider the following additional interface:
</p>

<pre class="webidl">
[Exposed=Window]
interface Something {
  void f(A %a);
};
</pre>

<p>
および，次の~ES~codeを考えるとき：
◎
and this ECMAScript code:
</p>

<pre class="es-code">
var %something = getSomething();  /* <span class="comment">
`Something^T の~instanceを取得する。
◎
Get an instance of Something.
</span> */
var %x = 0;

var %dict = { };
Object.defineProperty(dict, "d", { get: function() { return ++%x; } });
Object.defineProperty(dict, "c", { get: function() { return ++%x; } });

%something.f(%dict);
</pre>

<p>
辞書~mbを取りに行く順序が、それらがとることになる値を決定する。
`A^T における順序は， `c^M の次が `d^M と定義されるので、
`c^M に対する値は 1 になり, `d^M に対する値は 2 になる。
◎
The order that the dictionary members are fetched in determines what values they will be taken to have. Since the order for A is defined to be c then d, the value for c will be 1 and the value for d will be 2.
</p>
</div>

<p>
辞書~mbの識別子は、その［
辞書, または それが`継承した辞書たち$
］上で定義される，別の辞書~mbの識別子と同じになってはナラナイ。
◎
The identifier of a dictionary member must not be the same as that of another dictionary member defined on the dictionary or on that dictionary’s inherited dictionaries.
</p>

<p>
辞書は［
`属性$／`定数$
］の型に利用されてはナラナイ。
◎
Dictionaries must not be used as the type of an attribute or constant.
</p>

<p>
`辞書$には、適用-可能な`拡張属性$はない。
◎
No extended attributes are applicable to dictionaries.
</p>

<data class="grammar" value="
Partial
PartialDefinition
Dictionary
DictionaryMembers
DictionaryMember
DictionaryMemberRest
PartialDictionary
Default
DefaultValue
Inheritance
"></data>

<div class="example">
<p>
辞書~型の利用の一つは、`演算$に対し、呼出ng~codeの所で指定される順序に制約を課すことなく，随意~引数をいくつでも与えられるようにすることである。
例えば，次の`~IDL片$を考える：
◎
One use of dictionary types is to allow a number of optional arguments to an operation without being constrained as to the order they are specified at the call site. For example, consider the following IDL fragment:
</p>

<pre class="webidl">
[Exposed=Window]
interface Point {
  constructor();
  attribute double x;
  attribute double y;
};

dictionary PaintOptions {
  DOMString? fillPattern = "black";
  DOMString? strokePattern = null;
  Point position;
};

[Exposed=Window]
interface GraphicsContext {
  void drawRectangle(
    double %width, double %height,
    optional PaintOptions %options
  );
};
</pre>

<p>
この~IDLの~ES実装においては、随意な `PaintOptions^T 辞書により， `Object^jt を渡すことができる：
◎
In an ECMAScript implementation of the IDL, an Object can be passed in for the optional PaintOptions dictionary:
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する。
◎
Get an instance of GraphicsContext.
</span> */
var %ctx = getGraphicsContext();

/* <span class="comment">
矩形を描く。
◎
Draw a rectangle.
</span> */
%ctx.drawRectangle(
    300, 200,
    { fillPattern: "red", position: new Point(10, 10) }
);
</pre>

<p>
`fillPattern^M, `strokePattern^M とも`既定~値$diCが与えられているので、
`drawRectangle^M の定義においては［
それらが省略された場合でも所与の既定~値を持つ
］と見做すことができ，［
それらが`在さない$場合に取扱う方法についての明示的な言い回し
］は不要になる。
◎
Both fillPattern and strokePattern are given default values, so if they are omitted, the definition of drawRectangle can assume that they have the given default values and not include explicit wording to handle their non-presence.
</p>
</div>
		</section>
		<section id="idl-exceptions">
<h3 title="Exceptions">2.8. 例外</h3>

<p>
`例外@
とは、~errorを表現する~objの型であり，実装により［
投出される, または first ~class値として扱われる
］ものである。
~Web~IDLでは，例外を定義することは許容されないが、代わりに
仕様が参照し，その演算, 属性, 等々の定義にて投出できるような，いくつもの定義済みな例外がある。
◎
An exception is a type of object that represents an error and which can be thrown or treated as a first class value by implementations. Web IDL does not allow exceptions to be defined, but instead has a number of pre-defined exceptions that specifications can reference and throw in their definition of operations, attributes, and so on.＼
</p>

<div class="p">
<p>
各 例外は、次のものを持つ：
</p>

<dl>
	<dt>`~error名@</dt>
	<dd>
`DOMString$T による，例外が表現する~errorの型
</dd>

	<dt>`~message@（随意）</dt>
	<dd>
~errorの詳細を人が読める~~形で供する，~UAにより定義される値
</dd>
</dl>
◎
Exceptions have an error name, a DOMString, which is the type of error the exception represents, and a message, which is an optional, user agent-defined value that provides human readable details of the error.
</div>

<p>
仕様にて投出するために可用な例外には 2 つの種類がある。
まず、次のいずれかの型として識別される
`単純~例外@
：
◎
There are two kinds of exceptions available to be thrown from specifications. The first is a simple exception, which is identified by one of the following types:
</p>

<ul ><li>`EvalError@jE
</li><li>`RangeError@jE
</li><li>`ReferenceError@jE
</li><li>`TypeError@jE
</li><li>`URIError@jE
</li></ul>

<p>
これらは、~ES`~error~obj$に対応する（ただし， `SyntaxError^jE, `Error$jt は除く — 順に ~ES構文解析器~用, 作者~用に予約されているので、~~意図的に除かれている）。
各 `単純~例外$の意味は、~ES仕様における対応する~error~objに合致する。
◎
These correspond to all of the ECMAScript error objects (apart from SyntaxError and Error, which are deliberately omitted as they are reserved for use by the ECMAScript parser and by authors, respectively). The meaning of each simple exception matches its corresponding error object in the ECMAScript specification.
</p>

<p>
もう一種の例外は `DOMException$T である
— それは，歴史的に，~DOMにて定義された例外との互換性を得るための例外であり、名前と整数~code（後者は随意）を，~encapsulateする。
◎
The second kind of exception is a DOMException, which is an exception that encapsulates a name and an optional integer code, for compatibility with historically defined exceptions in the DOM.
</p>

<p>
`単純~例外$に対しては、`~error名$がその例外の型になる。
`DOMException$T の`~error名$は、後に示す`~error名~一覧$に挙げられている いずれかの名前でなければナラナイ。
その一覧には、その~error名に対する `DOMException$T の整数~codeも（もし在れば）指示される。
◎
For simple exceptions, the error name is the type of the exception. For a DOMException, the error name must be one of the names listed in the error names table below. The table also indicates the DOMException's integer code for that error name, if it has one.
</p>

<p class="note">注記：
`DOMException$T は`~ifc型$なので，~IDLにおいて型として利用できる。
これにより、例えば`演算$の`返り値~型$を `DOMException$T に宣言することも可能になる。
◎
Note: As DOMException is an interface type, it can be used as a type in IDL. This allows for example an operation to be declared to have a DOMException return type.
</p>

<p>
`例外を作成する@
よう記すときは、`単純~例外$に対しては その`~error名$，
`DOMException$T に対しては `~error名$に `DOMException$T も加えて表記する。
例外は、`例外を作成する$ために要求される詳細を供して
`例外を投出する@
よう表記することもできる。
◎
Simple exceptions can be created by providing their error name. A DOMException can be created by providing its error name followed by DOMException. Exceptions can also be thrown, by providing the same details required to create one.
</p>

<p>
例外を作成したり, 作成した例外を投出した結果の挙動は、言語束縛に特有になる。
◎
The resulting behavior from creating and throwing an exception is language binding-specific.
</p>

<p class="note">注記：
~ES言語束縛の場合にどうなるかについては、
`es-creating-throwing-exceptions$sec
を見よ。
◎
Note: See § 3.12.3 Creating and throwing exceptions for details on what creating and throwing an exception entails in the ECMAScript language binding.
</p>

<div class="example">

<p>
例外を作成して投出する言い回しの用例をここに示す†。
名前 `TypeError^jE の新たな `単純~例外$を投出するときは：
◎
Here is are some examples of wording to use to create and throw exceptions. To throw a new simple exception named TypeError:
</p>

<blockquote lang="en-x-a0">
Throw a `TypeError^jE.
</blockquote>

<p>
`~error名$ `NotAllowedError$E の新たな `DOMException$T を投出するときは：
◎
To throw a new DOMException with error name "NotAllowedError":
</p>

<blockquote lang="en-x-a0">
Throw an "`NotAllowedError^E" `DOMException^T.
</blockquote>

<p>
`~error名$ "`SyntaxError$E" の新たな `DOMException$T を作成するときは：
◎
To create a new DOMException with error name "SyntaxError":
</p>

<blockquote lang="en-x-a0">
Let %object be a newly created "`SyntaxError^E" `DOMException^T.
</blockquote>

</div>

<div class="trans-note">
<p>【†
このサイトの和訳全般においては、次のように例外~名の引用符や “`DOMException^T” を省略して表記している：
</p>

<ul><li>`~THROW$ `TypeError^jE
</li><li>`~THROW$ `NotAllowedError^E
</li><li>%object ~LET 新たな `SyntaxError^E 例外
</li></ul>

<p>
投出-の表記は，`単純~例外$も `DOMException$T も同じ表記になっているが、単純~例外は一握りしかない上、これらが同じ名前を共有することも，まずないと考えられるので（詳細は、~SYMBOL_DEF_REFを~~参照されたし）。
】</p>

</div>

			<section id="idl-DOMException-error-names">
<h4 title="Error names">2.8.1. ~error名</h4>

<p>
下の
`~error名~一覧@
は、 `DOMException$T に許容されるすべての~error名, ~~説明, および 旧来の~code名とその値の一覧である。
◎
The error names table below lists all the allowed error names for DOMException, a description, and legacy code values.
</p>

<p class="advisement">
“非推奨d” と記されている `DOMException$T 名は、旧来の目的~用に保たれてはいるが，利用しないことが奨励される。
◎
The DOMException names marked as deprecated are kept for legacy purposes but their usage is discouraged.
</p>

<p class="note">注記：
ここに挙げられていない~error名があれば、この仕様の冒頭に指示したように, ~bugを申請されるよう願う。
間もなく解消に向けて取組まれることになる。
Thanks! 
◎
Note: If an error name is not listed here, please file a bug as indicated at the top of this specification and it will be addressed shortly. Thanks!
</p>

<p class="note">注記：
ここに定義される `SyntaxError$E `DOMException$T 例外と ~ESの `SyntaxError$jE とを混同しないように。
前者は
— 例えば選択子を構文解析するときなど —
~Web~APIにおける構文解析-時の~errorを報告するために利用される一方で、後者は~ES構文解析器~用に予約されている。
これをより一義化し易くするため、単に `SyntaxError$E を利用せずに，常に［
"`SyntaxError$E" `DOMException$T
］と表記して `DOMException$T を指す方が好ましい。
【が，上述したように、他の~Web仕様の和訳では， `DOMException^T は省略している — ~ES `SyntaxError^jE は，それらの仕様には現れないので。】
`DOM$r
◎
Note: Don’t confuse the "SyntaxError" DOMException defined here with ECMAScript’s SyntaxError. "SyntaxError" DOMException is used to report parsing errors in web APIs, for example when parsing selectors, while the ECMAScript SyntaxError is reserved for the ECMAScript parser. To help disambiguate this further, always favor the "SyntaxError" DOMException notation over just using SyntaxError to refer to the DOMException. [DOM]
</p>

<div style="overflow:auto;"><table id="error-names">
<thead><tr><th>名前
◎
Name
<th>~~説明
◎
Description
<th>
旧来の~code名（括弧内は数値）
◎
Legacy code name and value
</thead><tbody>

<tr class="deprecated"><td>`IndexSizeError@E
<td>
非推奨d。
`RangeError$jE を利用すること。
◎
Deprecated. Use RangeError instead.
<td>`INDEX_SIZE_ERR@Ec (1)

<tr class="deprecated"><td>`DOMStringSizeError@E
<td>
非推奨d。
`RangeError$jE を利用すること。
◎
Deprecated. Use RangeError instead.
<td>`DOMSTRING_SIZE_ERR@Ec (2)

<tr><td>`HierarchyRequestError@E
<td>
演算から不正な`~node~tree$が得られることになる。
`DOM$r
◎
The operation would yield an incorrect node tree. [DOM]
<td>`HIERARCHY_REQUEST_ERR@Ec (3)

<tr><td>`WrongDocumentError@E
<td>
~objが属している`文書$は間違っている。
`DOM$r
◎
The object is in the wrong document. [DOM]
<td>`WRONG_DOCUMENT_ERR@Ec (4)

<tr><td>`InvalidCharacterError@E
<td>
文字列に妥当でない文字が含まれている。
◎
The string contains invalid characters.
<td>`INVALID_CHARACTER_ERR@Ec (5)

<tr class="deprecated"><td>`NoDataAllowedError@E
<td>
非推奨d。
◎
Deprecated.
<td>`NO_DATA_ALLOWED_ERR@Ec (6)

<tr><td>`NoModificationAllowedError@E
<td>
~objは改変できない。
◎
The object can not be modified.
<td>`NO_MODIFICATION_ALLOWED_ERR@Ec (7)

<tr><td>`NotFoundError@E
<td>
~objは見出せなかった。
◎
The object can not be found here.
<td>`NOT_FOUND_ERR@Ec (8)

<tr><td>`NotSupportedError@E
<td>
演算は~supportされていない。
◎
The operation is not supported.
<td>`NOT_SUPPORTED_ERR@Ec (9)

<tr><td>`InUseAttributeError@E
<td>
属性は利用-中にある。
◎
The attribute is in use.
<td>`INUSE_ATTRIBUTE_ERR@Ec (10)

<tr><td>`InvalidStateError@E
<td>
~objは不正な状態にある。
◎
The object is in an invalid state.
<td>`INVALID_STATE_ERR@Ec (11)

<tr><td>`SyntaxError@E
<td>
文字列は期待される~patternに合致していない。
◎
The string did not match the expected pattern.
<td>`SYNTAX_ERR@Ec (12)

<tr><td>`InvalidModificationError@E
<td>
~objはこの仕方では改変できない。
◎
The object can not be modified in this way.
<td>`INVALID_MODIFICATION_ERR@Ec (13)

<tr><td>`NamespaceError@E
<td>
演算は `Namespaces in XML^cite において許容されない。
`XML-NAMES$r
◎
The operation is not allowed by Namespaces in XML. [XML-NAMES]
<td>`NAMESPACE_ERR@Ec (14)

<tr class="deprecated"><td>`InvalidAccessError@E
<td>
非推奨d。
代わりに、［
妥当でない引数に対しては `TypeError$jE ／
未~supportの演算に対しては `NotSupportedError$E ／
否認された要請に対しては `NotAllowedError$E
］を利用すること。
◎
Deprecated. Use TypeError for invalid arguments, "NotSupportedError" DOMException for unsupported operations, and "NotAllowedError" DOMException for denied requests instead.
<td>`INVALID_ACCESS_ERR@Ec (15)

<tr class="deprecated"><td>`ValidationError@E
<td>
非推奨d。
◎
Deprecated.
<td>`VALIDATION_ERR@Ec (16)

<tr class="deprecated"><td>`TypeMismatchError@E
<td>
非推奨d。
代わりに、 `TypeError$jE を利用すること。
◎
Deprecated. Use TypeError instead.
<td>`TYPE_MISMATCH_ERR@Ec (17)

<tr><td>`SecurityError@E
<td>
演算は~secureでない。
◎
The operation is insecure.
<td>`SECURITY_ERR@Ec (18)

<tr><td>`NetworkError@E
<td>
~network~errorが生じた。
◎
A network error occurred.
<td>`NETWORK_ERR@Ec (19)

<tr><td>`AbortError@E
<td>
演算は中止された。
◎
The operation was aborted.
<td>`ABORT_ERR@Ec (20)

<tr><td>`URLMismatchError@E
<td>
所与の URL は他方の URLに合致していない。
◎
The given URL does not match another URL.
<td>`URL_MISMATCH_ERR@Ec (21)
 

<tr><td>`QuotaExceededError@E
<td>
~quotaを超過した。
◎
The quota has been exceeded.
<td>`QUOTA_EXCEEDED_ERR@Ec (22)

<tr><td>`TimeoutError@E
<td>
演算は時間切れになった。
◎
The operation timed out.
<td>`TIMEOUT_ERR@Ec (23)

<tr><td>`InvalidNodeTypeError@E
<td>
給された~nodeは不正か, またはこの演算において不正な先祖を持つ。
◎
The supplied node is incorrect or has an incorrect ancestor for this operation.
<td>`INVALID_NODE_TYPE_ERR@Ec (24)

<tr><td>`DataCloneError@E
<td>
~objは~cloneできない。
◎
The object can not be cloned.
<td>`DATA_CLONE_ERR@Ec (25)

<tr><td>`EncodingError@E
<td>
符号化する演算に失敗した（符号化-時, 復号-時とも含め）。
◎
The encoding operation (either encoded or decoding) failed.
<td>—

<tr><td>`NotReadableError@E
<td>
I/O 読み取り演算に失敗した。
◎
The I/O read operation failed.
<td>—

<tr><td>`UnknownError@E
<td>
未知な一過性の事由により，演算に失敗した（例：記憶域を使い果たした）。
◎
The operation failed for an unknown transient reason (e.g. out of memory).
<td>—

<tr><td>`ConstraintError@E
<td>
~transactionにおける変異~演算は、拘束を満たせないため，失敗した。
◎
A mutation operation in a transaction failed because a constraint was not satisfied.
<td>—

<tr><td>`DataError@E
<td>
供された~dataは、必要十分でない。
◎
Provided data is inadequate.
<td>—

<tr><td>`TransactionInactiveError@E
<td>
現在~作動中でない／すでに終わった ~transactionに対し，要請が行われた。
◎
A request was placed against a transaction which is currently not active, or which is finished.
<td>—

<tr><td>`ReadOnlyError@E
<td>
“読専” （ `readonly^l ~mode）の~transactionにおいて，変異させようとする演算が試みられた。
◎
The mutating operation was attempted in a "readonly" transaction.
<td>—

<tr><td>`VersionError@E
<td>
既存の~versionより低い~versionを利用して~databaseを open しようとした。
◎
An attempt was made to open a database using a lower version than the existing version.
<td>—

<tr><td>`OperationError@E
<td>
演算に特有な事由により，演算に失敗した。
◎
The operation failed for an operation-specific reason.
<td>—

<tr><td>`NotAllowedError@E
<td>
要請された演算は、現在の文脈においては
~UA／~platform
からは
— 場合によっては，利用者が否認したことにより —
許容されない。
◎
The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.
<td>—

</tbody></table></div>

			</section>
		</section>
		<section id="idl-enums">
<h3 title="Enumerations">2.9. 列挙</h3>

<p>
`列挙@
（ `enumeration^en ）は、［
妥当な値の集合が，定義済みな文字列の集合になる
］ような型を宣言するために利用される，`定義$（ `Enum$g に合致-）である。
`属性$に代入できる／`演算$に渡せる `DOMString$T 値を制約する用途に，列挙を利用できる。
◎
An enumeration is a definition (matching Enum) used to declare a type whose valid values are a set of predefined strings. Enumerations can be used to restrict the possible DOMString values that can be assigned to an attribute or passed to an operation.
</p>

<pre class="syntax">
enum `identifier^i { "enum", "values" /* , ... */ };
</pre>

<p>
一連の
`列挙~値@
は、
`string$g ~literalの~comma区切りの~listとして指定される。
`列挙~値$の~list内に重複が在ってはナラナイ。
◎
The enumeration values are specified as a comma-separated list of string literals. The list of enumeration values must not include duplicates.
</p>

<p class="advisement">
別の命名法を利用する理由が特にない限り、列挙~値は，すべて小文字にすることが強く示唆される
— 複数の単語は，~dashで区切るか全く区切らないことにして。
例えば、~objが作成されるべきであることを指示する列挙~値は，
`createobject^l や `create-object^l
などと命名することもできる。
列挙~値の単語を~dashで区切るかどうか裁定するときは、類似の他の~APIと一貫するように，関係する列挙~値の利用を考慮すること。
◎
It is strongly suggested that enumeration values be all lowercase, and that multiple words be separated using dashes or not be separated at all, unless there is a specific reason to use another value naming scheme. For example, an enumeration value that indicates an object should be created could be named "createobject" or "create-object". Consider related uses of enumeration values when deciding whether to dash-separate or not separate enumeration value words so that similar APIs are consistent.
</p>

<p>
妥当な列挙~値のいずれでもない文字列~値が，［
列挙~型の`属性$に代入するときや, 列挙~型の`演算$に渡される引数
］に利用されたときの挙動は、言語束縛に特有になる。
◎
The behavior when a string value that is not one a valid enumeration value is used when assigning to an attribute, or passed as an operation argument, whose type is the enumeration, is language binding specific.
</p>

<p class="note">注記：
~ES言語束縛においては、`属性$への妥当でない文字列~値の代入は無視される一方，そのような値を他の文脈（例えば`演算$の引数）で渡したときには例外が投出される。
◎
Note: In the ECMAScript binding, assignment of an invalid string value to an attribute is ignored, while passing such a value in other contexts (for example as an operation argument) results in an exception being thrown.
</p>

<p>
`列挙$に適用-可能な`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to enumerations.
</p>

<data class="grammar" value="
Enum
EnumValueList
EnumValueListComma
EnumValueListString
"></data>

<div class="example">
<p>
次の`~IDL片$は
1 個の`属性$と 1 個の`演算$引数の型として利用される
`列挙$を定義する
◎
The following IDL fragment defines an enumeration that is used as the type of an attribute and an operation argument:
</p>

<pre class="webidl">
enum MealType { "米", "麺", "その他" };

[Exposed=Window]
interface Meal {
  attribute MealType type;
  attribute double size;     /* <span class="comment">
グラム~~単位
◎
in grams
</span> */

  void initialize(MealType %type, double %size);
};
</pre>

<p>
~ES実装は、 type ~propに代入され得る, あるいは
`initialize^M 関数に渡され得る文字列を，
`列挙$内にて識別されるものに制約することになる。
◎
An ECMAScript implementation would restrict the strings that can be assigned to the type property or passed to the initializeMeal function to those identified in the enumeration.
</p>

<pre class="es-code">
var %meal = getMeal();          /* <span class="comment">
`Meal^T の~instanceを取得する。
◎
Get an instance of Meal.
</span> */

%meal.initialize("米", 200);    /* <span class="comment">
演算は通常通り呼出される。
◎
Operation invoked as normal.
</span> */

try {
  %meal.initialize("肉", 100);  /* <span class="comment">
`TypeError^jE が投出される。
◎
Throws a TypeError.
</span> */
} catch (%e) {
}

%meal.type = "麺";              /* <span class="comment">
属性は通常通り代入される。
◎
Attribute assigned as normal.
</span> */
%meal.type = "魚";              /* <span class="comment">
属性~代入は無視される。
◎
Attribute assignment ignored.
</span> */
%meal.type == "麺";             /* <span class="comment" id="cp-eval-true">
`true^jv に評価される。
◎
Evaluates to true.
</span> */
</pre>
</div>

		</section>
		<section id="idl-callback-functions">
<h3 title="Callback functions">2.10. ~callback関数</h3>

<p class="issue">
“`Custom DOM Elements^cite” 仕様からは、`~callback関数~型$を，~platform~objから供される関数に利用することが求まれている。
“~callback関数” を，両方の目的に利用できることを明らかにするため、単に “関数” と改称するべきだろうか？
◎
The “Custom DOM Elements” spec wants to use callback function types for platform object provided functions. Should we rename “callback functions” to just “functions” to make it clear that they can be used for both purposes?
</p>

<p>
`~callback関数@
は、関数~型を宣言するときに利用される，`定義$（ `callback^sym `CallbackRest$g に合致-）である。
◎
A callback function is a definition (matching callback CallbackRest) used to declare a function type.
</p>

<pre class="syntax">
callback `identifier^i = `return_type^i (/* arguments... */);
</pre>

<p class="note">注記：
似た命名の`~callback~ifc$も見よ。
◎
Note: See also the similarly named callback interfaces.
</p>

<p>
等号の左側の`識別子$が
`~callback関数$の名前を与える。
等号の右側の［
返り値~型（ `ReturnType$g に合致-）
と［
引数~list（ `ArgumentList$g に合致-）
【による一連の型】
］］が，`~callback関数~型$の~signatureを与える。
◎
The identifier on the left of the equals sign gives the name of the callback function and the return type and argument list (matching ReturnType and ArgumentList) on the right side of the equals sign gives the signature of the callback function type.
</p>

<p>
`~callback関数$は
`定数$の型に利用されてはナラナイ。
◎
Callback functions must not be used as the type of a constant.
</p>

<p>
`~callback関数$に適用-可能な拡張属性は
⇒＃
`TreatNonObjectAsNull$x
◎
The following extended attribute is applicable to callback functions: [TreatNonObjectAsNull].
</p>

<data class="grammar" value="
CallbackOrInterfaceOrMixin
CallbackRest
"></data>

<div class="example">
<p>
次の`~IDL片$は、演算の完了-時に利用者により定義される関数を呼出す~API用に利用される，`~callback関数$を定義する。
◎
The following IDL fragment defines a callback function used for an API that invokes a user-defined function when an operation is complete.
</p>

<pre class="webidl">
callback AsyncOperationCallback = void (DOMString %status);

[Exposed=Window]
interface AsyncOperations {
  void performOperation(AsyncOperationCallback %whenFinished);
};
</pre>

<p>
~ES言語束縛においては、`関数~obj$は演算~引数として渡される。
◎
In the ECMAScript language binding, a function object is passed as the operation argument.
</p>

<pre class="es-code">
var %ops = getAsyncOperations();  /* <span class="comment">
`AsyncOperations^T の~instanceを取得する。
◎
Get an instance of AsyncOperations.
</span> */

%ops.performOperation(function(%status) {
  window.alert("Operation finished, status is " + %status + ".");
});
</pre>
</div>
		</section>
		<section id="idl-typedefs">
<h3 title="Typedefs">2.11. ~typedef</h3>

<p>
`~typedef@
は、ある型に対し 新たな名前を宣言するために利用される，`定義$（ `Typedef$g に合致-）である。
この新たな名前は、言語束縛からは公開されない。
これはもっぱら，~IDLにおいて型を参照するための略記として利用される。
◎
A typedef is a definition (matching Typedef) used to declare a new name for a type. This new name is not exposed by language bindings; it is purely used as a shorthand for referencing the type in the IDL.
</p>

<pre class="syntax">
typedef `type^i `identifier^i;
</pre>

<p>
`新たな名前が与えられる型@
（ `TypeWithExtendedAttributes$g に合致-）は， `typedef^sym ~keywordの後に指定され、型に後続する `identifier$g ~tokenが，その新たな名前を与える。
◎
The type being given a new name is specified after the typedef keyword (matching TypeWithExtendedAttributes), and the identifier token following the type gives the name.
</p>

<p>
`Type$g は、同じまたは別の`~typedef$の識別子にされてはナラナイ。
◎
The Type must not be the identifier of the same or another typedef.
</p>

<p>
`~typedef$に適用-可能な`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to typedefs.
</p>

<data class="grammar" value="
Typedef
"></data>

<div class="example">
<p>
次の`~IDL片$は、`~typedef$を利用して，長い`連列~型$の代わりに短い`識別子$を使えるようしている。
◎
The following IDL fragment demonstrates the use of typedefs to allow the use of a short identifier instead of a long sequence type.
</p>

<pre class="webidl">
[Exposed=Window]
interface Point {
  attribute double x;
  attribute double y;
};

typedef sequence&lt;Point&gt; Points;

[Exposed=Window]
interface Widget {
  boolean pointWithinBounds(Point %p);
  boolean allPointsWithinBounds(Points %ps);
};
</pre>

</div>
		</section>
		<section id="idl-objects">
<h3 title="Objects implementing interfaces">2.12. ~ifcを実装している~obj</h3>

<p>
一連の`~IDL片$が成す集合の実装においては、~objは，`~platform~obj$であるものとして述べれる。
◎
In a given implementation of a set of IDL fragments, an object can be described as being a platform object.
</p>

<p>
`~platform~obj@
は、ある`~ifc$を実装する~objである。
◎
Platform objects are objects that implement an interface.
</p>

<p>
`旧来の~platform~obj@
は、`~platform~obj$のうち，次を満たすものである
⇒［
`Global$x `拡張属性$を伴わない`~ifc$を実装する
］~AND［［
`有index~propを~support$する
］~OR［
`有名~propを~support$する
］］
◎
Legacy platform objects are platform objects that implement an interface which does not have a [Global] extended attribute, and which supports indexed properties, named properties, or both.
</p>

<p>
~browserにおいては、例えば，［
~page内で走らせている~ESに対し，~page内容への~accessを供する
］ために，~browserに実装されている（ `Node^T や `Document^T などの~ifcを実装している）~DOM~objが、`~platform~obj$になる。
これらの~objは、
C++ などの言語で実装される~exotic~objになるか,
または~native~ES~objになるであろう。
いずれにせよ，所与の~IDL片の集合に対する実装は、自身が作成したすべての`~platform~obj$を認識できる必要がある。
これは、所与の~objに［
その~objが実装における~platform~objであるかどうかを記録するような，何らかの内部~状態
］を~~実際に持たせるか、あるいは, たぶん［
~objが一定の内部 C++ ~classを実装しているかどうか
］を見ることにより、~~実現できるであろう。
~platform~objが，正確に どう実装から認識されるかについては、実装に特有になる。
◎
In a browser, for example, the browser-implemented DOM objects (implementing interfaces such as Node and Document) that provide access to a web page’s contents to ECMAScript running in the page would be platform objects. These objects might be exotic objects, implemented in a language like C++, or they might be native ECMAScript objects. Regardless, an implementation of a given set of IDL fragments needs to be able to recognize all platform objects that are created by the implementation. This might be done by having some internal state that records whether a given object is indeed a platform object for that implementation, or perhaps by observing that the object is implemented by a given internal C++ class. How exactly platform objects are recognized by a given implementation of a set of IDL fragments is implementation specific.
</p>

<p>
~system内の他のすべての~objは、~platform~objとしては扱われないことになる。
例えば、~browserが開いた~Web~pageが， DOM Core を実装する~ES~libraryを読込んだとする。
この~libraryは、~browserが供する実装とは異なる実装と見なされることになる。
~ES~libraryにより作成された［
`Node^T ~ifcを実装する~obj
］は、~browser実装による［
`Node^T を実装する~platform~obj
］としては扱われないことになる。
◎
All other objects in the system would not be treated as platform objects. For example, assume that a web page opened in a browser loads an ECMAScript library that implements DOM Core. This library would be considered to be a different implementation from the browser provided implementation. The objects created by the ECMAScript library that implement the Node interface will not be treated as platform objects that implement Node by the browser implementation.
</p>

<p>
他方，`~callback~ifc$は、どの~ES~objも実装できる。
これは、作者が定義する演算を~Web~APIから呼出せるようにする。
例えば， DOM Events 実装は、［
`EventListener$T ~ifcを実装する~objを供することにより，~callbackを登録する
］ことを，作者に許容する。
◎
Callback interfaces, on the other hand, can be implemented by any ECMAScript object. This allows Web APIs to invoke author-defined operations. For example, the DOM Events implementation allows authors to register callbacks by providing objects that implement the EventListener interface.
</p>

		</section>
		<section id="idl-types">
<h3 title="Types">2.13. 型</h3>

<p>
この節では、~Web~IDLで~supportされる型,
各 型に対応する値の集合,
その型の`定数$が どう表現されるか,
について挙げていく。
◎
This section lists the types supported by Web IDL, the set of values corresponding to each type, and how constants of that type are represented.
</p>

<p>
互いに類似する型の集合には、次のような総称が付与されている：
</p>

<dl >
	<dt>`整数~型@</dt>
	<dd>
`byte$T ,
`octet$T ,
`short$T ,
`unsigned short$T ,
`long$T ,
`unsigned long$T ,
`long long$T ,
`unsigned long long$T
◎
The following types are known as integer types: byte, octet, short, unsigned short, long, unsigned long, long long and unsigned long long.
</dd>

	<dt>`数量-型@</dt>
	<dd>
すべての`整数~型$ ,
`float$T ,
`unrestricted float$T ,
`double$T ,
`unrestricted double$T
◎
The following types are known as numeric types: the integer types, float, unrestricted float, double and unrestricted double.
</dd>

	<dt>`~primitive型@</dt>
	<dd>
`boolean$T ,
すべての`数量-型$
◎
The primitive types are boolean and the numeric types.
</dd>

	<dt>`文字列~型@</dt>
	<dd>
`DOMString$T, すべての`列挙~型$ , `ByteString$T, `USVString$T
◎
The string types are DOMString, all enumeration types, ByteString and USVString.
</dd>

	<dt>`有型~配列~型@</dt>
	<dd>
`Int8Array$T,
`Int16Array$T,
`Int32Array$T,
`Uint8Array$T,
`Uint16Array$T,
`Uint32Array$T,
`Uint8ClampedArray$T,
`Float32Array$T,
`Float64Array$T
◎
The typed array types are Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array and Float64Array.
</dd>

	<dt>`~buffer~source型@</dt>
	<dd>
`ArrayBuffer$T,
`DataView$T,
すべての`有型~配列~型$
◎
The buffer source types are ArrayBuffer, DataView, and the typed array types.
</dd>

	<dt>`~obj型@</dt>
	<dd>
`object$T 型,
すべての`~ifc型$,
すべての`~callback~ifc型$
◎
The object type, all interface types, and all callback interface types are known as object types.
</dd>
</dl>

<p>
どの型も，
`型~名@
を持つ
— それは、型を識別する文字列であり，一意になるとは限らない。
以下の各~節では、各~型にあてがわれる型~名も定義する。
◎
Every type has a type name, which is a string, not necessarily unique, that identifies the type. Each sub-section below defines what the type name is for each type.
</p>

<p id="type-conversion-exceptions">
`演算$を呼出すとき／`属性$に値を代入するときに必要とされる，言語束縛に特有な型から~IDL型への変換はすべて、［
演算に指定された機能性や 属性~代入
］が~~実行に移される前に遂行される。
変換が遂行できない場合、演算は走らされず, 属性は更新されないことになる。
一部の言語束縛では、この型~変換により，例外が投出され得る。
そのような場合、これらの例外は，演算を呼出そうと／属性に代入しようと試みた~codeまで，伝播することになる。
◎
When conversions are made from language binding specific types to IDL types in order to invoke an operation or assign a value to an attribute, all conversions necessary will be performed before the specified functionality of the operation or attribute assignment is carried out. If the conversion cannot be performed, then the operation will not run or the attribute will not be updated. In some language bindings, type conversions could result in an exception being thrown. In such cases, these exceptions will be propagated to the code that made the attempt to invoke the operation or assign to the attribute.
</p>

<data class="grammar" value="
Type
TypeWithExtendedAttributes
SingleType
UnionType
UnionMemberType
UnionMemberTypes
DistinguishableType
ConstType
PrimitiveType
UnrestrictedFloatType
FloatType
UnsignedIntegerType
IntegerType
OptionalLong
StringType
PromiseType
RecordType
Null
"></data>

			<section id="idl-any">
<h4 title="any">2.13.1. `any^T</h4>

<p>
`any$T 型は、 `共用体~型$ 以外の，アリなすべての型の和集合である。
その`型~名$は、 `Any^l である。
◎
The any type is the union of all other possible non-union types. Its type name is "Any".
</p>

<p>
`any$T 型は、その各 値ごとに特有な非 `any$T 型が結付けられる~~点で，~~特別な共用体~型のようなものである。
例えば，
`any$T 型のある値は `unsigned long$T 150 をとり得る一方、別の値は `long$T 150 をとり得る。
これらは別個の型の値になる。
◎
The any type is like a discriminated union type, in that each of its values has a specific non-any type associated with it. For example, one value of the any type is the unsigned long 150, while another is the long 150. These are distinct values.
</p>

<p>
`any$T 型のある値を成す特定0の型は、その値の
`特有~型@
と呼ばれる。
（ `共用体~型$の値も`特有~型$を持つ。）
◎
The particular type of an any value is known as its specific type. (Values of union types also have specific types.)
</p>

<p class="trans-note">【
`any^T 型は、
`es-any$sec
にも見られるように `null^V 値もとり得るようだが，
“`~nullable$型である”
ものと定義されてはいない。
<!-- 
おそらく、非~nullableの `any^T 型も在った方が，いくつかの定義はより簡潔に記せるように思われる。
 -->
】</p>

			</section>
			<section id="idl-void">
<h4 title="void">2.13.2. `void^T</h4>

<p>
`void$T 型は、一意な値をとる。
◎
The void type has a unique value.
</p>

<p>
それを利用できるのは、［
`演算$の`返り値~型$／`~promise型$の~parameter
］に限られる。
◎
It can only be used as the return type of an operation or the parameter of a promise type.
</p>

<p>
`void$T 型の`型~名$は、 `Void^l である。
◎
The type name of the void type is "Void".
</p>

			</section>
			<section id="idl-boolean">
<h4 title="boolean">2.13.3. `boolean^T</h4>

<p>
`boolean$T 型は 2 つの値：
`true^V と `false^V をとり得る。
◎
The boolean type has two values: true and false.
</p>

<p>
~IDLにおいては、 `boolean$T 定数~値は［
`true^sym ／ `false^sym
］~tokenで表現される。
◎
boolean constant values in IDL are represented with the true and false tokens.
</p>

<p>
`boolean$T 型の`型~名$は、 `Boolean^l である。
◎
The type name of the boolean type is "Boolean".
</p>
			</section>
			<section id="idl-integers">
<h4>2.13.4〜11. 整数~型</h4>

<p class="trans-note">【
この訳では、原文の 2.12.3 〜 2.12.10 節の内容
— 各種~IDL整数~型の定義を集約して，一括して与える。
】</p>

<p>
各種 有符号／無符号 `整数~型$の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
◎
The xxx ~LET (byte|short|long|long long／octet|unsigned short|unsigned long|unsigned long long) type is a (signed／unsigned) integer type that has values in the range ([−P÷2, P÷2 − 1]／[0, P − 1]); P ~LET 2^(8|16|32|64).
◎
xxx constant values in IDL are represented with integer tokens.
◎
The type name of the xxx type is "Xxx".
</p>

<table id="matrix-idl-integers">

<thead><tr><th>~IDL型
<th>最小~値
<th>最大~値
<th>型~名
</thead><tbody>

<tr><th>`byte@T
<td title="−128">−2`7^sup
<td title="127">2`7^sup ~MINUS 1
<td>`Byte^l

<tr><th>`octet@T
<td>0
<td title="255">2`8^sup ~MINUS 1
<td>`Octet^l

<tr><th>`short@T
<td title="−32768">−2`15^sup
<td title="32767">2`15^sup ~MINUS 1
<td>`Short^l

<tr><th>`unsigned short@T
<td>0
<td title="65535">2`16^sup ~MINUS 1
<td>`UnsignedShort^l

<tr><th>`long@T
<td title="−2147483648">−2`31^sup
<td title="2147483647">2`31^sup ~MINUS 1
<td>`Long^l

<tr><th>`unsigned long@T
<td>0
<td title="4294967295">2`32^sup ~MINUS 1
<td>`UnsignedLong^l

<tr><th>`long long@T
<td title="−9223372036854775808">−2`63^sup
<td title="9223372036854775807">2`63^sup ~MINUS 1
<td>`LongLong^l

<tr><th>`unsigned long long@T
<td>0
<td title="18446744073709551615">2`64^sup ~MINUS 1
<td>`UnsignedLongLong^l

</tbody></table>

<p>
~IDLにおいては、どの`整数~型$の定数~値も， `integer$g ~tokenで表現される。
</p>

			</section>
			<section id="idl-floats">
<h4>2.13.12〜15. 浮動小数点数~型</h4>

<p class="trans-note">【
この訳では、原文の 2.12.11 〜 2.12.14 節の内容
— 各種~IDL浮動小数点数~型の定義を集約して，一括して与える。
】</p>

<p>
各種
“浮動小数点数 型”
— `整数~型$でない`数量-型$ —
に対応する値の範囲, および 各 `型~名$は、次の表で与えられる：
</p>

<table id="matrix-idl-floats">

<thead><tr><th>~IDL型
<th>値の範囲 `IEEE-754$r
<th>型~名
</thead><tbody>

<tr><th>`float@T
<td>
すべての有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The float type is a floating point numeric type that corresponds to the set of finite single-precision 32 bit IEEE 754 floating point numbers. [IEEE-754]
<td>`Float^l

<tr><th>`unrestricted float@T
<td>
アリなすべての有限, 非~有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合に “非数（ `not a number^en ）” （ 各種 NaN ）を加えた集合
◎
The unrestricted float type is a floating point numeric type that corresponds to the set of all possible single-precision 32 bit IEEE 754 floating point numbers, finite, non-finite, and special "not a number" values (NaNs). [IEEE-754]
<td>`UnrestrictedFloat^l

<tr><th>`double@T
<td>
すべての有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The double type is a floating point numeric type that corresponds to the set of finite double-precision 64 bit IEEE 754 floating point numbers. [IEEE-754]
<td>`Double^l

<tr><th>`unrestricted double@T
<td>
アリなすべての有限, 非~有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合に “非数（ `not a number^en ）” （ 各種 NaN ）を加えた集合
◎
The unrestricted double type is a floating point numeric type that corresponds to the set of all possible double-precision 64 bit IEEE 754 floating point numbers, finite, non-finite, and special "not a number" values (NaNs). [IEEE-754]
<td>`UnrestrictedDouble^l

</tbody></table>

<p>
~IDLにおいては、どの浮動小数点数 型の定数~値も，
`decimal$g ~tokenで表現される。
◎
(unrestricted )?(float|double) constant values in IDL are represented with decimal tokens.
◎
The type name of the (unrestricted )?(float|double) type is “(Unrestricted)?(Float|Double)”.
</p>

<p class="advisement">
特に 32 ~bit浮動小数点~型を利用する理由が無い限り，仕様は
`float$T でなく，`double$T を利用するべきである。
`double$T が表現できる値~集合は，より近く~ES `Number^jt に合致するので。
◎
Unless there are specific reasons to use a 32 bit floating point type, specifications should use double rather than float, since the set of values that a double can represent more closely matches an ECMAScript Number.
</p>

			</section>
			<section id="idl-DOMString">
<h4 title="DOMString">2.13.16. `DOMString^T</h4>

<p>
`DOMString$T 型は、アリなすべての［
`符号単位$の並び
］の集合に対応する。
そのような並びは、共通的に，~UTF-16に符号化された文字列 `RFC2781$r
として解釈されるが、要求されてはいない。
`DOMString$T は，
`<cite>DOM Level 3 Core</cite> §The DOMString Type＠~TR/DOM-Level-3-Core/core#ID-C74D1578$href
において
`OMG IDL boxed sequence&lt;unsigned short&gt; valuetype^en
として定義されているが、この文書は，［
文字列が要求される様々な状況における，その連列~型に対する特別な場合分け
］を避けるため， `DOMString$T を内在的な型として定義する。
◎
The DOMString type corresponds to the set of all possible sequences of code units. Such sequences are commonly interpreted as UTF-16 encoded strings [RFC2781] although this is not required. While DOMString is defined to be an OMG IDL boxed sequence&lt;unsigned short&gt; valuetype in DOM Level 3 Core §The DOMString Type, this document defines DOMString to be an intrinsic type so as to avoid special casing that sequence type in various situations where a string is required.
</p>

<p class="note">注記：
`null^V は `DOMString$T 型の値ではないことにも注意。
~IDLにおいて `null^V を許容するためには、［
`DOMString?^sym と記される`~nullable$ `DOMString$T
］を利用する必要がある。
◎
Note: Note also that null is not a value of type DOMString. To allow null, a nullable DOMString, written as DOMString? in IDL, needs to be used.
</p>

<p>
この仕様においては、
`DOMString$T 値が妥当な~UTF-16文字列であることは要求されない
— 例えば、対を成さない~surrogate（代用対（ `surrogate pair^en ）を成し得る符号単位）も含み得る。
しかしながら，~Web~IDLを利用する仕様の策定者は、所与の［
特定0の`符号単位$列
］から `~Unicode~scalar値$列を得たいと求めることもあろう。
◎
Nothing in this specification requires a DOMString value to be a valid UTF-16 string. For example, a DOMString value might include unmatched surrogate pair characters. However, authors of specifications using Web IDL might want to obtain a sequence of Unicode scalar values given a particular sequence of code units.
</p>

<div class="algorithm">
<p>
次の~algoが、所与の
( `DOMString$T 値 %S )
を
`~Unicode~scalar値~列に変換-@
する仕方を定義する：
◎
The following algorithm defines a way to convert a DOMString to a sequence of Unicode scalar values:
</p>

<ol>
	<li>
%n ~LET %S の長さ
◎
Let S be the DOMString value.
◎
Let n be the length of S.
</li>
	<li>
%i ~LET 0
◎
Initialize i to 0.
</li>
	<li>
%U ~LET ~Unicode文字の空~連列
◎
Initialize U to be an empty sequence of Unicode characters.
</li>
	<li>
%置換~文字 ~LET `FFFD^U <span class="charname">REPLACEMENT CHARACTER</span>
◎
↓</li>
	<li>
<p>
~WHILE［
%i ~LT %n
］：
◎
While i &lt; n:
</p>
		<ol>
			<li>
%c ~LET %S 内で~index %i に位置する`符号単位$
◎
Let c be the code unit in S at index i.
</li>
			<li>
<p>
%c の値に応じて：
◎
Depending on the value of c:
</p>
				<dl class="switch">
					<dt>%c ~LT `D800^X</dt>
					<dt>%c ~GT `DFFF^X</dt>
					<dd>

<p>
%U に符号位置 %c の~Unicode文字を付加する
◎
Append to U the Unicode character with code point c.
</p>
					</dd>
					<dt>`DC00^X ~LTE %c ~LTE `DFFF^X</dt>
					<dd>
<p>
%U に %置換~文字 を付加する
◎
Append to U a U+FFFD REPLACEMENT CHARACTER.
</p>
					</dd>
					<dt>`D800^X ~LTE %c ~LTE `DBFF^X</dt>
					<dd>
						<ol class="only">
							<li>
~IF［
%i ~PLUS 1 ~GTE %n
］
⇒
%U に %置換~文字 を付加する
◎
If i = n−1, then append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
							<li>
<p>
~ELSE
：
◎
Otherwise, i &lt; n−1:
</p>
								<ol>
									<li>
%d ~LET %S 内の~index %i ~PLUS 1 に位置する`符号単位$
◎
Let d be the code unit in S at index i+1.
</li>
									<li>
<p>
~IF［
`DC00^X ~LTE %d ~LTE `DFFF^X
］：
◎
If 0xDC00 ≤ d ≤ 0xDFFF, then:
</p>
										<ol>
											<li>
%U に符号位置［
2`16^sup ~PLUS 2`10^sup ~MUL ( %c &amp; `3FF^X ) ~PLUS ( %d &amp; `3FF^X )
］の~Unicode文字を付加する
◎
Let a be c &amp; 0x3FF.
◎
Let b be d &amp; 0x3FF.
◎
Append to U the Unicode character with code point 2^16 + 2^10 a+b.
</li>
											<li>
%i ~INCBY 1
◎
Set i to i+1.
</li>
										</ol>
									</li>
									<li>
~ELSE
⇒
%U に %置換~文字 を付加する
◎
Otherwise, d &lt; 0xDC00 or d &gt; 0xDFFF. Append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
								</ol>
							</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%i ~INCBY 1
◎
Set i to i+1.
</li>
		</ol>
	</li>
	<li>
~RET %U
◎
Return U.
</li>
</ol>
</div>

<p>
~IDLにおいて，定数 `DOMString$T 値を表現する仕方は、ない。
`DOMString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］の［
`既定~値$diC ／ `既定~値$
］を［
`string$g ~literalによる`値$stR
］に設定することはできるが。
◎
There is no way to represent a constant DOMString value in IDL, although DOMString dictionary member default values and operation optional argument default values can be set to the value of a string literal.
</p>

<p>
`DOMString$T 型の`型~名$は、 `String^l である。
◎
The type name of the DOMString type is "String".
</p>

			</section>
			<section id="idl-ByteString">
<h4 title="ByteString">2.13.17. `ByteString^T</h4>

<p>
`ByteString$T 型は、アリなすべての［
byte の並び
］の集合に対応する。
その種の並びは、要求されてはいないが，［
~UTF-8に符号化された文字列 `RFC3629$r, あるいは［
他の何らかの［ 1 符号単位あたり 8 ~bit ］になる符号化法
］により符号化された文字列
］に解釈し得る。
◎
The ByteString type corresponds to the set of all possible sequences of bytes. Such sequences might be interpreted as UTF-8 encoded strings [RFC3629] or strings in some other 8-bit-per-code-unit encoding, although this is not required.
</p>

<p>
~IDLにおいて，定数 `ByteString$T 値を表現する仕方は、ない。
`ByteString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］の［
`既定~値$diC ／ `既定~値$
］を［
`string$g ~literalによる`値$stR
］に設定することはできるが。
◎
There is no way to represent a constant ByteString value in IDL, although ByteString dictionary member default values and operation optional argument default values can be set to the value of a string literal.
</p>

<p>
`ByteString$T 型の`型~名$は、 `ByteString^l である。
◎
The type name of the ByteString type is "ByteString".
</p>

<p class="advisement">
仕様は、［
HTTP などの，~byteや文字列を交換-可能に利用する~protocol
］を~ifc化するときに限り，
`ByteString$T を利用するべきである。
一般に，文字列は、その値が［
常に ASCII または 何らかの 8 ~bit文字~符号化法
］になることが期待されているとしても，
`DOMString$T 値により表現されるべきである。
8 ~bit~dataを保持するためには、 `ByteString$T ではなく，［
`octet$T または `byte$T
］を要素とする［
`連列~型$ ／ `凍結d配列~型$ ／ `Uint8Array$T ／ `Int8Array$T
］が利用されるべきである。
◎
Specifications should only use ByteString for interfacing with protocols that use bytes and strings interchangeably, such as HTTP. In general, strings should be represented with DOMString values, even if it is expected that values of the string will always be in ASCII or some 8 bit character encoding. Sequences or frozen arrays with octet or byte elements, Uint8Array, or Int8Array should be used for holding 8 bit data rather than ByteString.
</p>

			</section>
			<section id="idl-USVString">
<h4 title="USVString">2.13.18. `USVString^T</h4>

<p>
`USVString$T 型は、アリなすべての［［
`~Unicode~scalar値$
— ~surrogate符号位置でない~Unicode符号位置
］の並び
］の集合に対応する。
◎
The USVString type corresponds to the set of all possible sequences of Unicode scalar values, which are all of the Unicode code points apart from the surrogate code points.
</p>

<p>
~IDLにおいて，定数 `USVString$T 値を表現する仕方は、ない。
`USVString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］の［
`既定~値$diC ／ `既定~値$
］を［
`string$g ~literalによる`値$stR
］に設定することはできるが。
◎
There is no way to represent a constant USVString value in IDL, although USVString dictionary member default values and operation optional argument default values can be set to the value of a string literal.
</p>

<p>
`USVString$T 型の`型~名$は、 `USVString^l である。
◎
The type name of the USVString type is "USVString".
</p>

<p class="advisement">
仕様は、［
~text処理を遂行する際に `~Unicode~scalar値$による文字列~演算が必要になる
］ときに限り， `USVString$T を~APIに利用するべきである。
文字列を利用する ほとんどの~APIは、文字列~内の`符号単位$に いかなる解釈も行わない `DOMString$T を利用するべきである。
疑わしい場合は `DOMString$T を利用すること。
◎
Specifications should only use USVString for APIs that perform text processing and need a string of Unicode scalar values to operate on. Most APIs that use strings should instead be using DOMString, which does not make any interpretations of the code units in the string. When in doubt, use DOMString.
</p>

			</section>
			<section id="idl-object">
<h4 title="object">2.13.19. `object^T</h4>

<p>
`object$T 型は、アリなすべての［
非 `null^V ~obj参照
］の集合に対応する。
◎
The object type corresponds to the set of all possible non-null object references.
</p>

<p>
~IDLにおいて，定数 `object$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant object value in IDL.
</p>

<p>
アリなすべての~obj参照に加えて，
`null^V 値も内包する型を表すためには、
`~nullable型$ `object?^T を利用する。
◎
To denote a type that includes all possible object references plus the null value, use the nullable type object?.
</p>

<p>
`object$T 型の`型~名$は、 `Object^l である。
◎
The type name of the object type is "Object".
</p>
			</section>
			<section id="idl-symbol">
<h4 title="symbol">2.13.20. `symbol^T</h4>

<p>
`symbol$T 型は、アリなすべての~symbol値の集合に対応する。
~symbol値は、不透明かつ `object$T でない値であるが，同一性（ `identity^en ）は備える（すなわち、自身のみに等しい）。
◎
The symbol type corresponds to the set of all possible symbol values. Symbol values are opaque, non-object values which nevertheless have identity (i.e., are only equal to themselves).
</p>

<p>
~IDLにおいて，定数 `symbol$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant symbol value in IDL.
</p>

<p>
`symbol$T 型の`型~名$は、 `Symbol^l である。
◎
The type name of the symbol type is "Symbol".
</p>
			</section>
			<section id="idl-interface">
<h4 title="Interface types">2.13.21. ~ifc型</h4>

<p>
`~ifc$を識別する`識別子$は、その~ifcを実装する，アリなすべての［
非 `null^V ~obj参照の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies an interface is used to refer to a type that corresponds to the set of all possible non-null references to objects that implement that interface.
</p>

<p>
~ifc型の~IDL値は，単に~obj参照により表現される。
◎
An IDL value of the interface type is represented just by an object reference.
</p>

<p>
~IDLにおいて，特定0の~ifc型の定数~obj参照~値を表現する仕方は、ない。
◎
There is no way to represent a constant object reference value for a particular interface type in IDL.
</p>

<p>
［
所与の~ifcを実装する アリなすべての~obj参照に加え， `null^V 値も内包する
］ような型を表すためには、`~nullable型$を利用する。
◎
To denote a type that includes all possible references to objects implementing the given interface plus the null value, use a nullable type.
</p>

<p>
~ifc型の`型~名$は、その~ifcの`識別子$である。
◎
The type name of an interface type is the identifier of the interface.
</p>
			</section>
			<section id="idl-callback-interface">
<h4 title="Callback interface types">2.13.22. ~callback~ifc型</h4>

<p>
`~callback~ifc$を識別する`識別子$は、アリなすべての［
非 `null^V ~obj参照の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies a callback interface is used to refer to a type that corresponds to the set of all possible non-null references to objects.
</p>

<p>
この~ifc型の~IDL値は［
~obj参照, `~callback文脈$
］の組により表現される。
`~callback文脈@
とは、言語束縛に特有な値であり，［
言語束縛に特有な~obj参照が~IDL値に変換される時点における，実行~文脈についての情報
］を格納するために利用される。
◎
An IDL value of the interface type is represented by a tuple of an object reference and a callback context. The callback context is a language binding specific value, and is used to store information about the execution context at the time the language binding specific object reference is converted to an IDL value.
</p>

<p class="note">注記：
~ES~objに対しては、`~callback文脈$は，［
`Object^jt 値が~IDL~callback~ifc型の値に変換される時点の，`現任の設定群~obj$
］への参照を保持するために利用される。
`es-callback-interface$sec
を見よ。
◎
Note: For ECMAScript objects, the callback context is used to hold a reference to the incumbent settings object at the time the Object value is converted to an IDL callback interface type value. See § 3.2.15 Callback interface types.
</p>

<p>
~IDLにおいて，特定0の`~callback~ifc型$の定数~obj参照~値を表現する仕方は、ない。
◎
There is no way to represent a constant object reference value for a particular callback interface type in IDL.
</p>

<p>
［
アリなすべての~obj参照に加え， `null^V 値も内包する
］ような型を表すためには、`~nullable型$を利用する。
◎
To denote a type that includes all possible references to objects plus the null value, use a nullable type.
</p>

<p>
`~callback~ifc型$の`型~名$は、その`~callback~ifc$の`識別子$である。
◎
The type name of a callback interface type is the identifier of the callback interface.
</p>

			</section>
			<section id="idl-dictionary">
<h4 title="Dictionary types">2.13.23. 辞書~型</h4>

<p>
`辞書$を識別する`識別子$は、［
辞書~定義を固守する，すべての辞書の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies a dictionary is used to refer to a type that corresponds to the set of all dictionaries that adhere to the dictionary definition.
</p>

<p>
`有順序~map$用の~literal構文も，辞書を表現するために利用できる
— その文脈から、暗黙的に［
当の~mapが，特定の辞書~型の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~辞書~値を表現する仕方は、ない。
◎
The literal syntax for ordered maps may also be used to represent dictionaries, when it is implicitly understood from context that the map is being treated as an instance of a specific dictionary type. However, there is no way to represent a constant dictionary value inside IDL fragments.
</p>

<p>
辞書~型の`型~名$は、その辞書の`識別子$である。
◎
The type name of a dictionary type is the identifier of the dictionary.
</p>
			</section>
			<section id="idl-enumeration">
<h4 title="Enumeration types">2.13.24. 列挙~型</h4>

<p>
`列挙$を識別する`識別子$は、［
その`列挙~値$に属する文字列（ `DOMString$T と同様の，`符号単位$の並び）の集合
］を値にとる型を指すために利用される。
◎
An identifier that identifies an enumeration is used to refer to a type whose values are the set of strings (sequences of code units, as with DOMString) that are the enumeration’s values.
</p>

<p>
`DOMString$T と同様に、
~IDLにおいて，定数`列挙$値を表現する仕方は、ない。
列挙~型の［
`辞書~mb$ ／ 演算の`随意~引数$
］の［
`既定~値$diC ／ `既定~値$
］を［
`string$g ~literalによる`値$stR
］に設定することはできるが。
◎
Like DOMString, there is no way to represent a constant enumeration value in IDL, although enumeration-typed dictionary member default values and operation optional argument default values can be set to the value of a string literal.
</p>

<p>
列挙~型の`型~名$は、その列挙の`識別子$である。
◎
The type name of an enumeration type is the identifier of the enumeration.
</p>
			</section>
			<section id="idl-callback-function">
<h4 title="Callback function types">2.13.25. ~callback関数~型</h4>

<p>
`~callback関数$を識別する`識別子$は、［
所与の~signatureを伴う関数~objへの参照
］を値にとる型を指すために利用される。
◎
An identifier that identifies a callback function is used to refer to a type whose values are references to objects that are functions with the given signature.
</p>

<p>
~callback関数~型の~IDL値は，［
~obj参照, `~callback文脈$
］の組により表現される。
◎
An IDL value of the callback function type is represented by a tuple of an object reference and a callback context.
</p>

<p class="note">注記：
`~callback~ifc型$のときと同じく，`~callback文脈$は、［
~ES `Object^jt 値が~IDL~callback~ifc型の値に変換される時点の，`現任の設定群~obj$への参照
］を保持するために利用される。
`es-callback-function$sec
を見よ。
◎
Note: As with callback interface types, the callback context is used to hold a reference to the incumbent settings object at the time an ECMAScript Object value is converted to an IDL callback function type value. See § 3.2.18 Callback function types.
</p>

<p>
~IDLにおいて，定数 `~callback関数$値を表現する仕方は、ない。
◎
There is no way to represent a constant callback function value in IDL.
</p>

<p>
~callback関数~型の`型~名$は、その~callback関数の`識別子$である。
◎
The type name of a callback function type is the identifier of the callback function.
</p>
			</section>
			<section id="idl-nullable-type">
<h4 title="Nullable types — T?">2.13.26. ~nullable型 — `~varT?^T</h4>

<p>
`~nullable型@
は、（その
`内縁~型@
と呼ばれる）既存の型から構築される~IDL型であり、とり得る値の集合は，内縁~型がとり得る値に値 `null^V のみを~~追加したものになる。
~IDLにおいては、`~nullable型$は，既存の型の後に文字 `003F^U1 を置いて表現される。
`内縁~型$は次のいずれであってもナラナイ：
◎
A nullable type is an IDL type constructed from an existing type (called the inner type), which just allows the additional value null to be a member of its set of values. Nullable types are represented in IDL by placing a U+003F QUESTION MARK ("?") character after an existing type. The inner type must not be:
</p>

<div class="p">

<ul ><li>`any$T 型
</li><li>`~promise型$
</li><li>別の~nullable型
</li><li>`共用体~型$であって［
それ自身が`~nullable型を内包する$, または
その`平坦~化~mb型$は`辞書~型$を含む
］もの。
</li></ul>

◎
• any,
• a Promise type,
• another nullable type, or
• a union type that itself includes a nullable type or has a dictionary type as one of its flattened member types.
</div>

<p class="note">注記：
辞書~型は，一般には~nullableになれるが、その場合，演算~引数や辞書~mbの型には利用できない。
◎
Note: Although dictionary types can in general be nullable, they cannot when used as the type of an operation argument or a dictionary member.
</p>

<p>
~IDLにおいては、~nullable型の定数~値は，その`内縁~型$の定数~値と同じ仕方で表現されるか, または `null^sym ~tokenで表現される。
◎
Nullable type constant values in IDL are represented in the same way that constant values of their inner type would be represented, or with the null token.
</p>

<p>
~nullable型の`型~名$は、次の連結とする
⇒＃
その`内縁~型$ %T の型~名,
文字列 `OrNull^l
◎
The type name of a nullable type is the concatenation of the type name of the inner type T and the string "OrNull".
</p>

<div class="example">
<p>
例えば、値
`true^V, `false^V, `null^V
をとり得る型は， `boolean?^T と記される：
◎
For example, a type that allows the values true, false and null is written as boolean?:
</p>

<pre class="webidl">
[Exposed=Window]
interface NetworkFetcher {
  void get(optional boolean? areWeThereYet = false);
};
</pre>

<p>
次の`~ifc$は 2 個の`属性$を持つ。
一方は `DOMString$T または `null^V 値を値にとり得る。
他方は `Node^T ~objへの参照または `null^V 値を値にとり得る：
◎
The following interface has two attributes: one whose value can be a DOMString or the null value, and another whose value can be a reference to a Node object or the null value:
</p>

<pre class="webidl">
[Exposed=Window]
interface Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute Node? parentNode;
  /* <!--cp-some-code--> */
};
</pre>
</div>
			</section>
			<section id="idl-sequence">
<h4 title="Sequence types — sequence&lt;T&gt;">2.13.27. 連列~型 — ~sequence_T</h4>

<p>
`連列~型@
— ~sequence_T —
は、［
一連の［
型 %T の値
］からなる`~list$（長さ 0 にもなり得る）
］を値にとり得るような，~parameter化された型である。
◎
The sequence&lt;T&gt; type is a parameterized type whose values are (possibly zero-length) lists of values of type T.
</p>

<p>
連列は常に値渡しである。
連列が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に連列が渡された際に，その連列への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの連列も複製であり、それに対する改変は~platform~objからは可視にならないことになる。
◎
Sequences are always passed by value. In language bindings where a sequence is represented by an object of some kind, passing a sequence to a platform object will not result in a reference to the sequence being kept by that object. Similarly, any sequence returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>

<p>
`~list$用の~literal構文も，連列を表現するために利用できる
— その文脈から、暗黙的に［
当の~listが，ある連列の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~連列~値を表現する仕方は、ない。
◎
The literal syntax for lists may also be used to represent sequences, when it is implicitly understood from context that the list is being treated as a sequences. However, there is no way to represent a constant sequence value inside IDL fragments.
</p>

<p>
連列は［
`属性$／`定数$
］の型に利用されてはナラナイ。
◎
Sequences must not be used as the type of an attribute or constant.
</p>

<p class="note">注記：
この制約は、［
`連列~型$は、その参照が渡し回されるものではなく，複製されるものである
］ことを，仕様の［
策定者／利用者
］から見て明らかにするためにある。
連列~型の~writableな`属性$には、代わりに，連列を［
取得する／設定する
］`演算$~pairの利用が示唆される。
◎
Note: This restriction exists so that it is clear to specification writers and API users that sequences are copied rather than having references to them passed around. Instead of a writable attribute of a sequence type, it is suggested that a pair of operations to get and set the sequence is used.
</p>

<p>
連列~型の`型~名$は、次の連結とする
⇒＃
%T の型~名,
文字列 `Sequence^l
◎
The type name of a sequence type is the concatenation of the type name for T and the string "Sequence".
</p>

<p>
`~list$は、次を満たすならば，暗黙的に ~sequence_T 型の値として扱える
⇒
~listを成すどの`~item$も %T 型である
◎
Any list can be implicitly treated as a sequence&lt;T&gt;, as long as it contains only items that are of type T.
</p>

			</section>
			<section id="idl-record">
<h4 title="Record types — record&lt;K, V&gt;">2.13.28. ~record型 — ~record_KV</h4>

<p>
`~record型@
— ~record_KV —
は、`有順序~map$であって，その各`~entry$の［
`~key$は型 %K の ある~instance,
`値$は型 %V の ある~instance
］であるような，~parameter化された型である。
%K は［
`DOMString$T ／ `USVString$T ／ `ByteString$T
］でなければなければナラナイ。
◎
A record type is a parameterized type whose values are ordered maps with keys that are instances of K and values that are instances of V. K must be one of DOMString, USVString, or ByteString.
</p>

<p>
`有順序~map$用の~literal構文も，~recordを表現するために利用できる
— その文脈から、暗黙的に［
当の~mapが，~record型の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~record値を表現する仕方は、ない。
◎
The literal syntax for ordered maps may also be used to represent records, when it is implicitly understood from context that the map is being treated as a record. However, there is no way to represent a constant record value inside IDL fragments.
</p>

<p>
~recordは常に値渡しである。
~recordが何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に~recordが渡された際に，その~recordへの参照が~objに保有されることはない。
同様に，~platform~objから返されるどの~recordも複製であり、それに対する改変は~platform~objからは可視にならないことになる。
◎
Records are always passed by value. In language bindings where a record is represented by an object of some kind, passing a record to a platform object will not result in a reference to the record being kept by that object. Similarly, any record returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>

<p>
~recordは［
`属性$／`定数$
］の型に利用されてはナラナイ。
◎
Records must not be used as the type of an attribute or constant.
</p>

<p>
~record型の`型~名$は、次の連結とする
⇒＃
%K の型~名,
%V の型~名,
文字列 `Record^l
◎
The type name of a record type is the concatenation of the type name for K, the type name for V and the string "Record".
</p>

<p>
`有順序~map$は、次を満たすならば，暗黙的に ~record_KV 型の値として扱える
⇒
~mapを成すどの`~entry$も，その［
`~key$は %K 型,
`値$は %V 型
］である
◎
Any ordered map can be implicitly treated as a record&lt;K, V&gt;, as long as it contains only entries whose keys are all of of type K and whose values are all of type V.
</p>

			</section>
			<section id="idl-promise">
<h4 title="Promise types — Promise&lt;T&gt;">2.13.29. ~promise型 — ~promise_T</h4>

<p>
`~promise型@
— ~promise_T —
は、［［［［
“［［
非同期な演算において，先送りされ得る（非同期にもなり得る）計算
］の最終的な結果†
］の置き場（ `place holder^en ）”
`ECMA-262$r
］として利用される~obj
］への参照
］を値にとる
］ような，~parameter化された型である。
【† %T が，充足-時における結果の値の型を与える。】
~promise~objの意味論についての詳細は~ES仕様
`25.4 節＠~TC39#sec-promise-objects$href
を見よ。
◎
A promise type is a parameterized type whose values are references to objects that “is used as a place holder for the eventual results of a deferred (and possibly asynchronous) computation result of an asynchronous operation”. See section 25.4 of the ECMAScript specification for details on the semantics of promise objects.
</p>

<p>
~promise型は~nullableでないが、 %T は~nullableにもなり得る。
◎
Promise types are non-nullable, but T may be nullable.
</p>

<p>
~IDLにおいて，~promise値を表現する仕方は、ない。
◎
There is no way to represent a promise value in IDL.
</p>

<p>
~promise型の`型~名$は、次の連結とする
⇒＃
%T の型~名,
文字列 `Promise^l
◎
The type name of a promise type is the concatenation of the type name for T and the string "Promise".
</p>

			</section>
			<section id="idl-union">
<h4 title="Union types">2.13.30. 共用体~型</h4>

<p>
`共用体~型@
（ `union^en ）は、とり得る値の集合が［
複数の型の，それぞれがとり得る値の集合
］の和集合であるような，型である。
共用体~型（ `UnionType$g に合致-）は、
`or^sym ~keywordで区切られた型の並びを丸括弧で括って記される。
共用体~型を構成する型は、共用体の
`~mb型@
と呼ばれる。
◎
A union type is a type whose set of values is the union of those in two or more other types. Union types (matching UnionType) are written as a series of types separated by the or keyword with a set of surrounding parentheses. The types which comprise the union type are known as the union’s member types.
</p>

<div class="note">
<p>
例えば，
`(Node or DOMString)^c や `(double or sequence&lt;double&gt;)^c
などのように記す。
`共用体~型$に全体として `?^sym 接尾辞を適用するときは，
`(Node or DOMString)?^c
のように，右~丸括弧の後に置く。
◎
For example, you might write (Node or DOMString) or (double or sequence&lt;double&gt;). When applying a ? suffix to a union type as a whole, it is placed after the closing parenthesis, as in (Node or DOMString)?.
</p>

<p>
共用体~型の`~mb型$は、入子にされた共用体~型にまでは掘り下げられないことに注意。
したがって，
`(double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?)^T
の~mb型は、
`double^T ,
`(sequence&lt;long&gt; or Event)^T ,
`(Node or DOMString)?^T
になる。
◎
Note that the member types of a union type do not descend into nested union types. So for (double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?) the member types are double, (sequence&lt;long&gt; or Event) and (Node or DOMString)?.
</p>
</div>

<p>
`any$T 型と同様、共用体~型の値は，その値に合致する特定0の`~mb型$を`特有~型$として持つ。
◎
Like the any type, values of union types have a specific type, which is the particular member type that matches the value.
</p>

<div class="algorithm">
<p>
`共用体~型$ %T
— `注釈付きの型$にもなり得る —
の
`平坦~化~mb型@
とは、次の手続きで決定される型の集合である：
◎
The flattened member types of a union type, possibly annotated, is a set of types determined as follows:
</p>

<ol>
	<li>
%S ~LET 空~集合
◎
Let T be the union type.
◎
Initialize S to ∅.
</li>
	<li>
<p id="cp-foreach-union-mb">
%T 内の
~EACH( `~mb型$ %U )
に対し：
◎
For each member type U of T:
</p>
		<ol>
			<li>
%U ~SET %U の`最内縁の型$
◎
If U is an annotated type, then set U to be the inner type of U.
◎
If U is a nullable type, then set U to be the inner type of U.
</li>
			<li>
~IF［
%U は `共用体~型$である
］
⇒
%U の`平坦~化~mb型$に属するすべての型を %S に追加する
◎
If U is a union type, then add to S the flattened member types of U.
</li>
			<li>
~ELSE
⇒
%U を %S に追加する
◎
Otherwise, U is not a union type. Add U to S.
</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>
</div>

<p class="note">注記：
例えば，`共用体~型$
`(Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;)^T
の`平坦~化~mb型$は、 6 つの型［
`Node^T ,
`sequence&lt;long&gt;^T ,
`Event^T ,
`XMLHttpRequest^T ,
`DOMString^T ,
`sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;^T
］からなる。
◎
Note: For example, the flattened member types of the union type (Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;) are the six types Node, sequence&lt;long&gt;, Event, XMLHttpRequest, DOMString and sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;.
</p>

<div class="algorithm">
<p>
`共用体~型$ %T の
`~nullable~mb型の個数@
とは、次の手続きで決定される整数である：
◎
The number of nullable member types of a union type is an integer determined as follows:
</p>

<ol>
	<li>
%n ~LET 0
◎
Let T be the union type.
◎
Initialize n to 0.
</li>
	<li>
<!--cp-foreach-union-mb-->
		<ol>
			<li>
<p>
~IF［
%U は `~nullable型$である
］：
◎
If U is a nullable type, then:
</p>
				<ol>
					<li>
%n ~INCBY 1
◎
Set n to n + 1.
</li>
					<li>
%U ~SET %U の`内縁~型$
◎
Set U to be the inner type of U.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%U は `共用体~型$である
］：
◎
If U is a union type, then:
</p>
				<ol>
					<li>
%m ~LET %U の`~nullable~mb型の個数$
◎
Let m be the number of nullable member types of U.
</li>
					<li>
%n ~INCBY %m
◎
Set n to n + m.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %n
◎
Return n.
</li>
</ol>
</div>

<p>
`~mb型$に `any$T 型が利用されてはナラナイ。
◎
The any type must not be used as a union member type.
</p>

<p>
`共用体~型$の`~nullable~mb型の個数$は 0 か 1 でなければナラナイ。
1 の場合、その共用体~型は`平坦~化~mb型$に`辞書~型$を含んではナラナイ。
◎
The number of nullable member types of a union type must be 0 or 1, and if it is 1 then the union type must also not have a dictionary type in its flattened member types.
</p>

<p>
次のいずれかを満たす型は
`~nullable型を内包する@
とされる。
◎
A type includes a nullable type if:
</p>

<ul>
	<li>
`~nullable型$である
◎
the type is a nullable type, or
</li>
	<li>
［
`注釈付きの型$である
］~AND［
その`内縁~型$anOは`~nullable型$である
］
◎
the type is an annotated type and its inner type is a nullable type, or
</li>
	<li>
［
`共用体~型$である
］~AND［
その `~nullable~mb型の個数$は 0 でない（ 1 である）
］
◎
the type is a union type and its number of nullable member types is 1.
	</li>
</ul>

<p class="trans-note">【
概念的には， `null^V を値にとり得る型と考えられる。
ただし、この定義では `any$T 型は含まれないことになる。
】</p>

<p>
`共用体~型$の`平坦~化~mb型$に属する
どの 2 つの型も`判別-可能$でなければナラナイ。
◎
Each pair of flattened member types in a union type, T and U, must be distinguishable.
</p>

<p>
~IDLにおいては、`共用体~型$の定数~値は，それらの`~mb型$の定数~値と同じ仕方で表現される。
◎
Union type constant values in IDL are represented in the same way that constant values of their member types would be represented.
</p>

<p>
共用体~型の`型~名$は、その各~mb型の型~名を 文字列 `Or^l で区切って順に連結した結果とする。
◎
The type name of a union type is formed by taking the type names of each member type, in order, and joining them with the string "Or".
</p>

<data class="grammar" value="
UnionType
UnionMemberType
UnionMemberTypes
DistinguishableType
"></data>

			</section>
			<section id="idl-annotated-types">
<h4 title="Annotated types">2.13.31. 注釈付きの型</h4>

<p>
既存の型に ある種の`拡張属性$を指定することにより，追加的な型を作成できる。
そのような型は
`注釈付きの型@
と呼ばれ、注釈された~~元の型は その
`内縁~型@anO
と呼ばれる。
◎
Additional types can be created from existing ones by specifying certain extended attributes on the existing types. Such types are called annotated types, and the types they annotate are called inner types.
</p>

<p class="example">
`[Clamp] long^c
は、新たな`注釈付きの型$を定義する
— その挙動は `内縁~型$anO `long$T に基づくが，
`Clamp$x 拡張属性に指定されるように改変される。
◎
[Clamp] long defines a new annotated type, whose behavior is based on that of the inner type long, but modified as specified by the [Clamp] extended attribute.
</p>

<p>
次のものが
`型に適用-可能@
な拡張属性とされる
⇒
`AllowShared$x,
`Clamp$x,
`EnforceRange$x,
`TreatNullAs$x
◎
The following extended attributes are applicable to types: [AllowShared], [Clamp], [EnforceRange], and [TreatNullAs].
</p>

<div class="algorithm">
<p>
所与の~IDL型 %型 に
`結付けられている拡張属性@
は、次に従って決定される：
◎
The extended attributes associated with an IDL type type are determined as follows:
</p>

<ol>
	<li>
%拡張属性~集合 ~LET 新たな空`集合$
◎
Let extended attributes be a new empty set.
</li>
	<li>
<p>
~IF［
%型 は `TypeWithExtendedAttributes$g 生成規則 %P の一部として現れている
］
⇒
%P の中の `ExtendedAttributeList$g 内に在する
~EACH( `拡張属性$ %X )
に対し
⇒ 
%拡張属性~集合 に %X を`付加する$set
◎
If type appears as part of a TypeWithExtendedAttributes production, append each of the extended attributes present in the production’s ExtendedAttributeList to extended attributes.
</p>

<div class="example">
<pre class="webidl">
[Exposed=Window]
interface I {
    attribute [XAttr] long attrib;
    void f1(sequence&lt;[XAttr] long&gt; %arg);
    void f2(optional [XAttr] long %arg);

    maplike&lt;[XAttr2] DOMString, [XAttr3] long&gt;;
};

dictionary D {
    required [XAttr] long member;
};
</pre>

【 `XAttr*^x が該当する拡張属性を表す。以下の例も同様。】
</div>
	</li>
	<li>
<p>
~IF［
%型 は`共用体~型$ %U の`~mb型$である
］
⇒
~EACH( %U に`結付けられている拡張属性$ %X )
に対し
⇒
%拡張属性~集合 に %X を`付加する$set
◎
If type is a member type of a union type U, append each of the extended attributes associated with U to extended attributes.
</p>

<div class="example">
<pre class="webidl">
[Exposed=Window]
interface I {
    attribute [XAttr] (long or Node) attrib;
};
</pre>
</div>

	</li>
	<li>
<p>
~IF［
%型 は［
`Argument$g 生成規則 %P の中に直に現れる `Type$g 生成規則
］の一部として現れている
］
⇒
%P の中の `ExtendedAttributeList$g 内に在する
~EACH( `拡張属性$ %X )
に対し
⇒
~IF［
%X は`型に適用-可能$である
］
⇒
%拡張属性~集合 に %X を`付加する$set
◎
If type appears as part of a Type production directly within an Argument production, append to extended attributes all of the extended attributes present in the production’s ExtendedAttributeList that are applicable to types.
</p>

<div class="example">
<pre class="webidl">
[Exposed=Window]
interface I {
    void f([XAttr] long %attrib);
};
</pre>

<p>
この例の `XAttr^x は、`型に適用-可能$な場合に限り，引数の型に結付けられる（他の場合、 `XAttr^x は，引数に適用される）。
◎
Note that this is an example of this step only if [XAttr] is applicable to types; otherwise [XAttr] applies to the argument, and not the argument’s type.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%型 は［
`DictionaryMember$g 生成規則 %P の中に直に現れる `Type$g 生成規則
］の一部として現れている
］
⇒
%P の中の `ExtendedAttributeList$g 内に在する
~EACH( `拡張属性$ %X )
に対し
⇒
~IF［
%X は`型に適用-可能$である
］
⇒
%拡張属性~集合 に %X を`付加する$set
◎
If type appears as part of a Type production directly within an DictionaryMember production, append to extended attributes all of the extended attributes present in the production’s ExtendedAttributeList that are applicable to types.
</p>

<div class="example">
<pre class="webidl">
dictionary D {
    [XAttr] long member;
};
</pre>

<p>
この例の `XAttr^x は、`型に適用-可能$な場合に限り，辞書~mbの型に結付けられる（他の場合、 `XAttr^x は，辞書~mbに適用される）。
◎
Note that this is an example of this step only if [XAttr] is applicable to types; otherwise [XAttr] applies to the dictionary member, and not the member’s type.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%型 は`~typedef$である
］
⇒
~EACH( %型 により`新たな名前が与えられる型$に`結付けられている拡張属性$ %X )
に対し
⇒
%拡張属性~集合 に %X を`付加する$set
◎
If type is a typedef, append the extended attributes associated with the type being given a new name to extended attributes.
</p>

<div class="example">
<pre class="webidl">
typedef [XAttr] long xlong;
</pre>
</div>
	</li>
	<li>
~RET %拡張属性~集合
◎
Return extended attributes.
</li>
</ol>
</div>

<p>
どの型に対しても，それに`結付けられている拡張属性$は、`型に適用-可能$でなければナラナイ。
◎
For any type, the extended attributes associated with it must only contain extended attributes that are applicable to types.
</p>

<div class="p">
<p>
`拡張属性が結付けられ$ている型の`型~名$は、次の連結とする：
</p>

<ol ><li>元の型の`型~名$
</li><li>各［
型に`結付けられている拡張属性$
］の`識別子$に対応する文字列すべてを辞書式~順序で連結した結果
</li></ol>

◎
The type name of a type associated with extended attributes is the concatenation of the type name of the original type with the set of strings corresponding to the identifiers of each extended attribute associated with the type, sorted in lexicographic order.
</div>

<p class="example">
`[B, A] long?^c の形による型の`型~名$は、 `LongOrNullAB^l になる。
◎
The type name for a type of the form [B, A] long? is "LongOrNullAB".
</p>

			</section>
			<section id="idl-buffer-source-types">
<h4 title="Buffer source types">2.13.32. ~buffer~source型</h4>

<p>
アリなすべての［［［
~dataの~buffer, または［
~dataの~buffer上の~view
］］を表現する~obj
］への 非 `null^V 参照
］の集合に対応する，いくつかの型がある。
下の一覧に、それらの型, および それらが表現する［
~bufferまたは その~view
］の種類を挙げる。
◎
There are a number of types that correspond to sets of all possible non-null references to objects that represent a buffer of data or a view on to a buffer of data. The table below lists these types and the kind of buffer or view they represent.
</p>

<table id="matrix-buffer-sources">

<thead><tr><th>型
◎
Type
<th>~bufferの種類
◎
Kind of buffer
</thead><tbody>

<tr><td>`ArrayBuffer@T
<td>
固定的な個数の~byteからなる~bufferへの~pointer（ `null^V もとり得る）を保持する~obj。
◎
An object that holds a pointer (which may be null) to a buffer of a fixed number of bytes

<tr><td>`DataView@T
<td>
`ArrayBuffer$T への~viewであって、~bufferの中の，任意の~offsetに格納されている 整数／浮動小数点 値への~accessを可能にするもの。
◎
A view on to an ArrayBuffer that allows typed access to integers and floating point values stored at arbitrary offsets into the buffer

<tr><td>`Int8Array@T,
`Int16Array@T,
`Int32Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 2 の補数による有符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of two’s complement signed integers of the given size in bits

<tr><td>`Uint8Array@T,
`Uint16Array@T,
`Uint32Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned integers of the given size in bits

<tr><td>`Uint8ClampedArray@T
<td>
`ArrayBuffer$T への~viewであって、値を切詰める変換も伴われるような，［
8~bit無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned 8 bit integers with clamped conversions

<tr><td>`Float32Array@T,
`Float64Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの IEEE 754 浮動小数点数
］からなる配列を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of IEEE 754 floating point numbers of the given size in bits

</tbody></table>

<p class="note">注記：
これらの型はすべて、~ESにて定義される~classに対応する。
◎
Note: These types all correspond to classes defined in ECMAScript.
</p>

<p>
これらのどの型についても：
◎
↓</p>

<ul>
	<li>
~IDLにおいて，その型の定数~値を表現する仕方は、ない。
◎
There is no way to represent a constant value of any of these types in IDL.
</li>
	<li>
その`型~名$は、その型~自身の名前である。
◎
The type name of all of these types is the name of the type itself.
</li>
</ul>

<p>
仕様の中の注釈文~levelにおいては、~IDL`~buffer~source型$は，単純に~objへの参照である。
仕様の注釈文にて，~buffer内の~byte列を 検分したり操作するときは、最初に，~buffer~sourceに保持されている~byte列の
<a id="dfn-get-buffer-source-copy">`参照／複製を取得-@</a>
する手続きを介さなければナラナイ。
仕様の注釈文では、その結果の~byte列への参照／複製を利用して，個々の~byte値を取得したり設定できる。
◎
At the specification prose level, IDL buffer source types are simply references to objects. To inspect or manipulate the bytes inside the buffer, specification prose must first either get a reference to the bytes held by the buffer source or get a copy of the bytes held by the buffer source. With a reference to the buffer source’s bytes, specification prose can get or set individual byte values using that reference.
</p>

<div class="advisement">
<p>
仕様において、［
~buffer~sourceに保持されている~byteへの参照を取得する
］ような ~textを書くときには、細心の注意を払う必要がある
— 下層の~dataは、作者や他の~APIにより，予測-不能なときに容易に変更され得るので。
改変されないような ~binary~dataの~chunkを得るために，演算~引数として~buffer~source型を利用する場合は、その演算を定義する注釈文の始めの方で，~buffer~sourceの~byte列の複製を取得することが、強く推奨される。
◎
Extreme care must be taken when writing specification text that gets a reference to the bytes held by a buffer source, as the underlying data can easily be changed by the script author or other APIs at unpredictable times. If you are using a buffer source type as an operation argument to obtain a chunk of binary data that will not be modified, it is strongly recommended to get a copy of the buffer source’s bytes at the beginning of the prose defining the operation.
</p>

<p>
~byte列の 参照／複製 を取得する明示的な注釈文を要することの意図は、仕様の査読者が，これらの~buffer~source型の問題ある利用を見つけ易くするためである。
◎
Requiring prose to explicitly get a reference to or copy of the bytes is intended to help specification reviewers look for problematic uses of these buffer source types.
</p></div>

<div class="note">
<p>注記：
~bufferを~~入力にとる~APIを設計するときは、 `ArrayBuffer$T や他の~view~型よりも `BufferSource^T ~typedefの利用が推奨される。
◎
When designing APIs that take a buffer, it is recommended to use the BufferSource typedef rather than ArrayBuffer or any of the view types.
</p>

<p>
~bufferを作成したり返す~APIを設計するときは、
`Uint8Array$T よりも `ArrayBuffer$T 型の利用が推奨される。
◎
When designing APIs that create and return a buffer, it is recommended to use the ArrayBuffer type rather than Uint8Array.
</p>
</div>

<p>
`切離された$ `ArrayBuffer$T ~objに対し，~buffer~sourceに保持されている~byte列の`参照／複製を取得-$しようと試みたときは、言語束縛に特有な方式で失敗することになる。
◎
Attempting to get a reference to or get a copy of the bytes held by a buffer source when the ArrayBuffer has been detached will fail in a language binding-specific manner.
</p>

<p class="note">注記：
~ES言語束縛において ~buffer~source型とどうヤリトリするかについては、
`es-buffer-source-types$sec
を見よ。
◎
Note: See § 3.2.24 Buffer source types below for how interacting with buffer source types works in the ECMAScript language binding.
</p>

<p class="issue">
これらの型や用語を利用する仕様~textの例を含ませる必要がある。
◎
We should include an example of specification text that uses these types and terms.
</p>

<data class="grammar" value="
BufferRelatedType
"></data>

			</section>
			<section id="idl-frozen-array">
<h4 title="Frozen array types — FrozenArray&lt;T&gt;">2.13.33. 凍結d配列~型 — ~FrozenArray_T</h4>

<p>
`凍結d配列~型@
— ~FrozenArray_T —
は、［［［
一連の［
改変できない，型 %T の値
］からなる，固定的~長さの配列
］を保持する~obj
］への参照
］を値にとり得るような，~parameter化された型である。
◎
A frozen array type is a parameterized type whose values are references to objects that hold a fixed length array of unmodifiable values. The values in the array are of type T.
</p>

<p>
`~FrozenArray_T$ 値は参照である
— 値の~listであり，値渡しである`連列~型$と違って。
◎
Since FrozenArray&lt;T&gt; values are references, they are unlike sequence types, which are lists of values that are passed by value.
</p>

<p>
~IDLにおいて，定数~凍結d配列~値を表現する仕方は、ない。
◎
There is no way to represent a constant frozen array value in IDL.
</p>

<p>
凍結d配列~型の`型~名$は、次の連結とする
⇒＃
%T の型~名,
文字列 `Array^l
◎
The type name of a frozen array type is the concatenation of the type name for T and the string "Array".
</p>

			</section>
		</section>
		<section id="idl-extended-attributes">
<h3 title="Extended attributes">2.14. 拡張属性</h3>

<p>
`拡張属性@
は、［
`定義$／
`注釈付きの型$としての型／
`~ifc~mb$／
`~ifc~mixin~mb$／
`~callback~ifc~mb$／
`~ns~mb$／
`辞書~mb$／
`演算$引数
］上に現れ得る `注釈^em （ `annotation^en ）であり，［
言語束縛がこれらの構成子をどう取扱うことになるか
］を制御するために利用される。
拡張属性は `ExtendedAttributeList$g により指定される。
それは、全体が角括弧で括られた，いくつかの `ExtendedAttribute$g からなる~comma区切りの~listである。
◎
An extended attribute is an annotation that can appear on definitions, types as annotated types, interface members, interface mixin members, callback interface members, namespace members, dictionary members, and operation arguments, and is used to control how language bindings will handle those constructs. Extended attributes are specified with an ExtendedAttributeList, which is a square bracket enclosed, comma separated list of ExtendedAttributes.
</p>

<p>
文法~記号 `ExtendedAttribute$g は，ほぼ任意の~token並びに合致するが、この文書で定義される`拡張属性$は，より制約された構文のみを受容する。
`~IDL片$に~~現れるどの拡張属性も、次の表に示す文法~記号のいずれかへの合致-により、それが属する（ 1 個~以上の）形が決定される：
◎
The ExtendedAttribute grammar symbol matches nearly any sequence of tokens, however the extended attributes defined in this document only accept a more restricted syntax. Any extended attribute encountered in an IDL fragment is matched against the following five grammar symbols to determine which form (or forms) it is in:
</p>

<table><thead>
<tr><th>文法~記号
◎
Grammar symbol
<th>形
◎
Form
<th>例
◎
Example
</thead><tbody>

<tr><td>`ExtendedAttributeNoArgs$g
<td>`引数をとらない@
◎
takes no arguments
<td>`[Replaceable]^c

<tr><td>`ExtendedAttributeArgList$g
<td>`引数~listを引数にとる@
◎
takes an argument list
<td>
現在は【 `NamedConstructor$x 以外には】利用されない。
以前は
`[Constructor(double x, double y)]^c
のように利用されていた。
◎
Not currently used; previously used by [Constructor(double x, double y)]

<tr><td>`ExtendedAttributeNamedArgList$g
<td>`有名~引数~listを引数にとる@
◎
takes a named argument list
<td>`[NamedConstructor=Image(DOMString src)]^c

<tr><td>`ExtendedAttributeIdent$g
<td>`識別子を引数にとる@
◎
takes an identifier
<td>`[PutForwards=name]^c

<tr><td>`ExtendedAttributeIdentList$g
<td>`識別子~listを引数にとる@
◎
takes an identifier list
<td>`[Exposed=(Window,Worker)]^c

</tbody></table>

<p>
この仕様は、~ES言語束縛に適用-可能な，各種~拡張属性を定義する。
それらについては
`es-extended-attributes$sec
にて述べる。
各~拡張属性~定義において、上に挙げたどの形が許容されるかについて言明される。
◎
This specification defines a number of extended attributes that are applicable to the ECMAScript language binding, which are described in § 3.3 ECMAScript-specific extended attributes. Each extended attribute definition will state which of the above five forms are allowed.
</p>

<data class="grammar" value="
ExtendedAttributeList
ExtendedAttributes
ExtendedAttribute
ExtendedAttributeRest
ExtendedAttributeInner
Other
OtherOrComma
IdentifierList
Identifiers
ExtendedAttributeNoArgs
ExtendedAttributeArgList
ExtendedAttributeIdent
ExtendedAttributeIdentList
ExtendedAttributeNamedArgList
"></data>

		</section>
	</section>
	<section id="ecmascript-binding">
<h2 title="ECMAScript binding">3. ~ES言語束縛</h2>

<p>
この節では、
`idl$sec
にて定義された~IDLで記される`定義$が，
`~ES言語~仕様^cite `ECMA-262$r
により定義される~ESの中の特定0の構成子にどう対応するかを述べる。
◎
This section describes how definitions written with the IDL defined in § 2 Interface definition language correspond to particular constructs in ECMAScript, as defined by the ECMAScript Language Specification [ECMA-262].
</p>

<p>
他が指定されない限り，この節に定義される~objは、
`ECMA-262$r の［
`普通の~objの内部~methと内部~slot$ ／ `関数~obj$である場合は`組込みの関数~obj$
］節に述べられる，普通の~objであるとする。
◎
Unless otherwise specified, objects defined in this section are ordinary objects as described in ECMA-262 Ordinary object internal methods and internal slots, and if the object is a function object, ECMA-262 Built-in function objects.
</p>

<p>
この節では、一部の~objに対し，一定の［
内部~meth ／ 内部~slot
］を定義し直す。
他の仕様も、［
`~ifc$の~instanceである`~platform~obj$
］の［
内部~meth ／ 内部~slot
］の定義を上書きしてヨイ。
これらの，意味論が変更された~objは、~exotic~obj用の規則に則って扱われるものとする。
◎
This section may redefine certain internal methods and/or internal slots of objects. Other specifications may also override the definitions of any internal method and/or internal slots of a platform object that is an instance of an interface. These objects with changed semantics shall be treated in accordance with the rules for exotic objects.
</p>

<p class="advisement">
内部~ES~obj~methを上書きすることは、低~levelの演算であり，~objの挙動を普通の~objから違えさせ得るので、この便宜性は，~security／互換性のために必要とされない限り，利用されるべきでない。
これは現在、
`HTMLAllCollection$T, `Location$T
~ifcを定義するために利用されている。
`HTML$r
◎
As overriding internal ECMAScript object methods is a low level operation and can result in objects that behave differently from ordinary objects, this facility should not be used unless necessary for security or compatibility. This is currently used to define the HTMLAllCollection and Location interfaces. [HTML] 
</p>

<p>
他が指定されない限り，［
この節 ／ 他の仕様
］に定義される~exotic~objは、普通の~objと同じ`内部~slot$たちを持ち，その内部~methのうち代替の定義が与えられなかったものすべては，`普通の~objの内部~methと内部~slot$と同じとする。
◎
Unless otherwise specified, exotic objects defined in this section and other specifications have the same internal slots as ordinary objects, and all of the internal methods for which alternative definitions are not given are the same as those of ordinary objects.
</p>

<p>
他が指定されない限り，この節に定義される~objの `Extensible^sl 内部~slotの値は `true^jv とする。
◎
Unless otherwise specified, the [[Extensible]] internal slot of objects defined in this section has the value true.
</p>

<p>
他が指定されない限り，この節に定義される~objの `Prototype^sl 内部~slotは `ObjectPrototype$jI になるとする。
◎
Unless otherwise specified, the [[Prototype]] internal slot of objects defined in this section is %ObjectPrototype%.
</p>

<p>
この節にて述べる一部の~objは、
`~class文字列@
を持つものと定義される。
この文字列は、 `Object.prototype.toString^c が返す文字列に内包されることになる。
◎
Some objects described in this section are defined to have a class string, which is the string to include in the string returned from Object.prototype.toString.
</p>

<div class="p">
<p>
`~class文字列$ %~class文字列 を持つ~objは、その作成-時に，次の特徴を有する~propを持つモノトスル：
</p>

<ul>
	<li>
名前：
`toStringTag$jS ~symbol
</li>
	<li>
属性 `FFT-~class文字列^desc を持つ。
</li>
</ul>

◎
If an object has a class string classString, then the object must, at the time it is created, have a property whose name is the @@toStringTag symbol with PropertyDescriptor{[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true, [[Value]]: classString}.
</div>

<p id="ecmascript-abstractop">
この節の中の~algoは、手続きとその下位手続き, 数学的~演算, 等々の利用に関し，
`ECMA-262$r の`~algo規約$節に記述されている表記規約を利用する。
この節は、 ECMA-262 の他所で定義される［
抽象-演算 ／ 記法
］も参照する。
◎
Algorithms in this section use the conventions described in ECMA-262 Algorithm conventions, such as the use of steps and substeps, the use of mathematical operations, and so on. This section may also reference abstract operations and notations defined in other parts of ECMA-262.
</p>

<p>
~algoにおいて
“`~THROW@ `SomethingError^E”
と記される所では、`現在の~Realm$に属する新たな~ES `SomethingError^E ~objを構築して，
ECMA-262 の~algoとちょうど同じ様に投出することを意味する。
◎
When an algorithm says to throw a SomethingError then this means to construct a new ECMAScript SomethingError object in the current Realm and to throw it, just as the algorithms in ECMA-262 do.
</p>

<p>
~algoを成す各~段は，他の~algoや抽象-演算の中へ~callし得るが、それらから投出される例外は，明示的には取扱われていないことに注意。
~algoまたは抽象-演算により例外が投出され，それが~call元により明示的に取扱われない所では、~algoは終端され，その~call元~の更に外へ伝播する，等々となる。
◎
Note that algorithm steps can call in to other algorithms and abstract operations and not explicitly handle exceptions that are thrown from them. When an exception is thrown by an algorithm or abstract operation and it is not explicitly handled by the caller, then it is taken to end the algorithm and propagate out to its caller, and so on.
</p>

<div class="example">

<p>
次の~algoを考える：
◎
Consider the following algorithm:
</p>

<div class="algorithm">
<ol>
	<li>
%x ~LET この~algoに渡された~ES値
◎
Let x be the ECMAScript value passed in to this algorithm.
</li>
	<li>
%y ~LET `ToString$A( %x )
◎
Let y be the result of calling ToString(x).
</li>
	<li>
~RET %y
◎
Return y.
</li>
</ol>
</div>

<p>
`ToString$A は例外を投出し得るが（例えば~obj
`({ toString: function() { throw 1 } })^c
が渡されたとき），例外は上の~algoでは取扱われないので、もし投出された場合、この~algoは終端され，その例外は ~call元が在るならばその~call元に伝播する。
◎
Since ToString can throw an exception (for example if passed the object ({ toString: function() { throw 1 } })), and the exception is not handled in the above algorithm, if one is thrown then it causes this algorithm to end and for the exception to propagate out to its caller, if there is one.
</p>
</div>

		<section id="es-environment">
<h3 title="ECMAScript environment">3.1. ~ES環境</h3>

<p>
所与の［
`~IDL片$の集合
］に対する~ES実装においては、それらの`~IDL片$の中の各 定義に対応する，~ES~objが存在することになる。
これらの~objは
`初期~obj@
と呼ばれ、次のものからなる：
◎
In an ECMAScript implementation of a given set of IDL fragments, there will exist a number of ECMAScript objects that correspond to definitions in those IDL fragments. These objects are termed the initial objects, and comprise the following:
</p>
<ul>
	<li>
`~ifc~obj$
◎
interface objects
</li>
	<li>
`旧来の~callback~ifc~obj$
◎
legacy callback interface objects
</li>
	<li>
`有名~構築子$
◎
named constructors
</li>
	<li>
`~ifc原型~obj$
◎
interface prototype objects
</li>
	<li>
`有名~prop~obj$
◎
named properties objects
</li>
	<li>
`反復子~原型~obj$
◎
iterator prototype objects
</li>
	<li>
`属性~取得子$
◎
attribute getters
</li>
	<li>
`属性~設定子$
◎
attribute setters
</li>
	<li>
`演算に対応する関数~obj＠#es-operations$href
◎
the function objects that correspond to operations
</li>
	<li>
`文字列化子に対応する関数~obj＠#es-stringifier$href
◎
the function objects that correspond to stringifiers
</li>
	<li>
`反復子に対応する関数~obj＠#es-iterator$href
◎
the function objects that correspond to iterators
</li>
	<li>
`~map~size取得子$
◎
map size getters
</li>
</ul>

<p>
どの`~Realm$ %R も、それぞれに一意な自前の［
各種`初期~obj$からなる集合 %S
］を持つモノトスル。
%S が作成されるのは、［
%R 用の`大域~obj$が作成された後, かつ
%R に結付けられている~ES実行~文脈に制御が移る前
］になるモノトスル。
%R に属する どの初期~objも，その `Prototype^sl は %R に属するモノトスル。
◎
Each Realm must have its own unique set of each of the initial objects, created before control enters any ECMAScript execution context associated with the Realm, but after the global object for that Realm is created. The [[Prototype]]s of all initial objects in a given Realm must come from that same Realm.
</p>

<p class="trans-note">【
上の “~Realm %R に属する” という句は、所与の~objが同時に複数の`~Realm$に `属する^em ことは，決してないことを含意する。
】</p>

<div class="example">
<p>
~HTML~UAにおいては、複数の~frameや~windowが作成されるときに，複数の`~Realm$が存在し得る。
各［
~frame／~window
］は、自前の`初期~obj$の集合を持つことになる。
次の~HTML文書の例のように：
◎
In an HTML user agent, multiple Realms can exist when multiple frames or windows are created. Each frame or window will have its own set of initial objects, which the following HTML document demonstrates:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
相異なる~Realm
◎
Different Realms
</span>&lt;/title&gt;
&lt;iframe id=a&gt;&lt;/iframe&gt;
&lt;script&gt;
var %iframe = document.getElementById("a");
var %w = %iframe.contentWindow;     /* <span class="comment">
~frame内の大域~obj
◎
The global object in the frame
</span> */

Object == %w.Object;       /* <span class="comment">
ECMA-262 に則り， `false^jv に評価される
◎
Evaluates to false, per ECMA-262
</span> */
Node == %w.Node;                            /* <span class="comment" id="cp-eval-false">
`false^jv に評価される。
◎
Evaluates to false.
</span> */
%iframe instanceof %w.Node;                  /* <!--cp-eval-false--> */
%iframe instanceof %w.Object;                /* <!--cp-eval-false--> */
%iframe.appendChild instanceof Function;    /* <!--cp-eval-true--> */
%iframe.appendChild instanceof %w.Function;  /* <!--cp-eval-false--> */
&lt;/script&gt;
</pre>
</div>

<p class="note">注記：
すべての`~ifc$は、どの`~Realm$内に`公開され$るかを定義する。
これにより，例えば、［
Web Workers 用の`~Realm$が~supportするものとして`公開され$る，~ifcの集合
］を［
~Web~page用に公開されるそれら
］と異ならせることも許容される。
◎
Note: All interfaces define which Realms they are exposed in. This allows, for example, Realms for Web Workers to expose different sets of supported interfaces from those exposed in Realms for Web pages.
</p>

<p>
これを書いている時点では，~ES仕様は それを反映していないが、どの~ES~objにも ある`~Realm$が結付けられるモノトスル
— この~Realmを指して， ~objが
`属する~Realm@
という。
◎
Although at the time of this writing the ECMAScript specification does not reflect this, every ECMAScript object must have an associated Realm.＼
</p>

<p>
各~objに~Realmを結付ける仕組みは、今の所，策定中にあるが：
◎
The mechanisms for associating objects with Realms are, for now, underspecified. However, we note that＼
</p>

<ul>
	<li>
`~platform~obj$については、それが`属する~Realm$は，その~objに`関連な~Realm$に等しい。
◎
in the case of platform objects, the associated Realm is equal to the object’s relevant Realm, and＼
</li>
	<li>
~exoticでない`関数~obj$（すなわち，`~callable$~proxyでも~bindされた関数でもない）についても、それが`属する~Realm$は，その`関数~obj$の `Realm^sl 内部~slotの値に等しい。
◎
for non-exotic function objects (i.e. not callable proxies, and not bound functions) the associated Realm is equal to the value of the function object's [[Realm]] internal slot.
</li>
</ul>

		</section>
		<section id="es-type-mapping">
<h3 title="ECMAScript type mapping">3.2. ~ES型との対応関係</h3>

<p>
この節では、~IDLにおける各~型が，~ESにおける型に どう対応付けられるかについて述べる。
◎
This section describes how types in the IDL map to types in ECMAScript.
</p>

<p>
以下の各~下位~節では、所与の［
~IDL型の値
］が，~ESの中では どう表現されるかを述べる。
各種~IDL型に対し、その型を期待する`~platform~obj$に~ES値が渡された際に
`~IDL値に変換-@
する方法, および
その型の~IDL値が~platform~objから返される際に
`~ES値に変換-@
する方法が述べられる。
◎
Each sub-section below describes how values of a given IDL type are represented in ECMAScript. For each IDL type, it is described how ECMAScript values are converted to an IDL value when passed to a platform object expecting that type, and how IDL values of that type are converted to ECMAScript values when returned from a platform object.
</p>

<p>
以下の各 下位~節と~algoは、［［
その見出しに挙げられる名前の型
］に拡張属性を適用して作成される，`注釈付きの型$
］にも適用されることに注意。
◎
Note that the sub-sections and algorithms below also apply to annotated types created by applying extended attributes to the types named in their headers.
</p>

			<section id="es-any">
<h4 title="any">3.2.1. `any^T</h4>

<p>
~IDL `any$T 型は、他のすべての~IDL型の和集合なので，どの~ES値~型にも対応し得る。
◎
Since the IDL any type is the union of all other IDL types, it can correspond to any ECMAScript value type.
</p>

<div class="algorithm">
<p id="es-to-any">
次の~algoにより，~ES値 %V は `any$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL any value by running the following algorithm:
</p>
<ol>
	<li>
~IF［
%V ~EQ `undefined^jv
］
⇒
~RET ~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
◎
If V is undefined, then return an object reference to a special object that represents the ECMAScript undefined value.
</li>
	<li>
~IF［
%V ~EQ `null^jv
］
⇒
~RET `null^V `object$T​? 参照
◎
If V is null, then return the null object? reference.
</li>
	<li>
<p>
~RET `Type$A( %V ) に応じて，次で与えられる値：
◎
↓</p>

		<dl class="switch">
			<dt>`Boolean^jt</dt>
			<dd>
同じ真偽~値を表現する `boolean$T 値
◎
If Type(V) is Boolean, then return the boolean value that represents the same truth value.
</dd>

			<dt>`Number^jt</dt>
			<dd>
`es-unrestricted-double$secに従って，
%V を `unrestricted double$T 値に変換した結果
◎
If Type(V) is Number, then return the result of converting V to an unrestricted double.
</dd>

			<dt>`String^jt</dt>
			<dd>
`es-DOMString$secに従って，
%V を `DOMString$T 値に変換した結果
◎
If Type(V) is String, then return the result of converting V to a DOMString.
</dd>

			<dt>`Symbol^jt</dt>
			<dd>
`es-symbol$secに従って，
%V を `symbol$T 値に変換した結果
◎
If Type(V) is Symbol, then return the result of converting V to a symbol.
</dd>

			<dt>`Object^jt</dt>
			<dd>
%V を参照する~IDL `object$T 値
◎
If Type(V) is Object, then return an IDL object value that references V.
</dd>
		</dl>
	</li>
</ol>
</div>

<p id="any-to-es">
~IDL `any$T 値 %V は，次のように`~ES値に変換-$される：
◎
An IDL any value is converted to an ECMAScript value as follows.＼
</p>

<ul>
	<li>
%V が［
~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
］ならば、~ES `undefined^jv 値に変換される。
◎
If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value.＼
</li>
	<li>
他の場合、この節の残りで述べられる， %V の`特有~型$を変換するための規則に従う。
◎
Otherwise, the rules for converting the specific type of the IDL any value as described in the remainder of this section are performed.
</li>
</ul>

			</section>
			<section id="es-void">
<h4 title="void">3.2.2. `void^T</h4>

<div class="algorithm">
<p id="es-to-void">
次の~algoにより，~ES値 %V は `void$T 型の`~IDL値に変換-$される
⇒
~RET 一意な `void$T 値（ %V は無視する）
◎
An ECMAScript value V is converted to an IDL void value by returning the unique void value, ignoring V.
</p>
</div>

<div class="algorithm">
<p id="void-to-es">
次の~algoにより，~IDL `void$T 値は`~ES値に変換-$される
⇒
~RET ~ES `undefined^jv 値
◎
The unique IDL void value is converted to the ECMAScript undefined value.
</p>
</div>

			</section>
			<section id="es-boolean">
<h4 title="boolean">3.2.3. `boolean^T</h4>

<div class="algorithm">
<p id="es-to-boolean">
次の~algoにより，~ES値 %V は `boolean$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL boolean value by running the following algorithm:
</p>

<ol>
	<li>
%x ~LET `ToBoolean$A( %V ) の算出-結果
◎
Let x be the result of computing ToBoolean(V).
</li>
	<li>
~RET ［
~ES `Boolean^jt 値 %x
］と同じ真偽~値を表現する~IDL `boolean$T 値
◎
Return the IDL boolean value that is the one that represents the same truth value as the ECMAScript Boolean value x.
</li>
</ol>
</div>

<p id="boolean-to-es">
~IDL `boolean$T 値［
`true^V／`false^V
］を`~ES値に変換-$した結果は、~ES［
`true^jv／`false^jv
］値になる。
◎
The IDL boolean value true is converted to the ECMAScript true value and the IDL boolean value false is converted to the ECMAScript false value.
</p>

			</section>
			<section id="es-integer-types">
<h4>3.2.4. 整数~型</h4>

<p>
この節に利用される数学的~演算は、
`ECMA-262$r の`~algo規約$節に定義されるものも含め，数学的~実数による数学的に正確な結果を算出していると解されるとする。
◎
Mathematical operations used in this section, including those defined in ECMA-262 Algorithm conventions, are to be understood as computing exact mathematical results on mathematical real numbers.
</p>

<p>
`Number^jt 値 %x に対し，
“%x に演算する”
ことは、実質的に
“%x と同じ数量-値を表現する数学的~実数に演算する”
ことの略記である。
◎
In effect, where x is a Number value, “operating on x” is shorthand for “operating on the mathematical real number that represents the same numeric value as x”.
</p>

<dl>
	<dt id="es-byte">3.2.4.1. `byte^T</dt>
	<dt id="es-octet">3.2.4.2. `octet^T</dt>
	<dt id="es-short">3.2.4.3. `short^T</dt>
	<dt id="es-unsigned-short">3.2.4.4. `unsigned short^T</dt>
	<dt id="es-long">3.2.4.5. `long^T</dt>
	<dt id="es-unsigned-long">3.2.4.6. `unsigned long^T</dt>
	<dt id="es-long-long">3.2.4.7. `long long^T</dt>
	<dt id="es-unsigned-long-long">3.2.4.8. `unsigned long long^T</dt>
	<dd class="trans-note">【
この訳では、原文のこれら各~下位~節の内容
— ~ES値 から各種~IDL整数~型 値への変換, およびその逆の変換の定義 —
を集約して，一括して与える。
】</dd>
</dl>

<div class="algorithm">
<p>
<a id="es-to-byte"></a
><a id="es-to-octet"></a
><a id="es-to-short"></a
><a id="es-to-unsigned-short"></a
><a id="es-to-long"></a
><a id="es-to-unsigned-long"></a
><a id="es-to-long-long"></a
><a id="es-to-unsigned-long-long"></a>
次の~algoにより，~ES値 %V は `整数~型$ %T の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL _T_ value by running the following algorithm:
</p>

<ol>
	<li>
%x ~LET
~ABRUPT `ConvertToInt$A( %V, %T )
◎
Let x be ? ConvertToInt(V, _N_, "signed|unsigned").
</li>
	<li>
~RET %x と同じ数量-値を表現する，型 %T の~IDL値
◎
Return the IDL _T_ value that represents the same numeric value as x.
</li>
</ol>
</div>

<p>
<a id="byte-to-es"></a
><a id="octet-to-es"></a
><a id="short-to-es"></a
><a id="unsigned-short-to-es"></a
><a id="long-to-es"></a
><a id="unsigned-long-to-es"></a
><a id="long-long-to-es"></a
><a id="unsigned-long-long-to-es"></a>
~IDL`整数~型$ %T の値 %V を`~ES値に変換-$した結果は， %T に応じて次で与えられる：
◎
The result of converting an IDL _T_ value to an ECMAScript value is a ...
</p>

<div class="p">
<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd id="_int-toES_">
%V に最も近い数量-値を表現する `Number^jt 値
⇒
2 数が等距離にある場合は，`仮数が偶数になる方^emを選ぶとする
</dd>
	<dd>
%V が範囲 [%MIN, %MAX] に入るならば、その値 は %V と正確に同じ値を表現できることになる。†
</dd>

	<dt>他の整数~型</dt>
	<dd>
%V と同じ数量-値を表現する `Number^jt 値。
</dd>
	<dd>
その値は 範囲 [%MIN, %MAX] の整数になる。†
</dd>
</dl>

<p>†
上の %MIN, %MAX は、次節の `ConvertToInt$A にて与えられる。
</p>

◎
The result of converting an IDL _T_ value to an ECMAScript value is a Number value that represents the closest numeric value to the _T_, choosing the numeric value with an even significand if there are two equally close values. If the _T_ is in the range [_MIN_, _MAX_], then the Number will be able to represent exactly the same value as the _T_.
◎
Number that represents the same numeric value as the IDL _T_ value. The Number value will be an integer in the range [_MIN_, _MAX_].
</div>

				<section id="es-integer-types-abstract-ops">
<h5 title="Abstract operations">3.2.4.9. 抽象-演算</h5>

<div class="algorithm">
<p>
`IntegerPart@A( %n )：
◎
IntegerPart(n):
</p>

<ol>
	<li>
%r ~LET `floor$op( `abs$op( %n ) )
◎
Let r be floor(abs(n)).
</li>
	<li>
~IF［
%n ~LT 0
］
⇒
~RET −1 ~MUL %r
◎
If n &lt; 0, then return -1 × r.
</li>
	<li>
~RET %r
◎
Otherwise, return r.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`ConvertToInt@A( %V, %T )
◎
ConvertToInt(V, bitLength, signedness):
</p>

<ol>
	<li>
<p>
( %MIN, %MAX, %N, %signed ) ~LET
%T に応じて，次の表で与えられる値：
</p>

<table id="matrix-integers">

<thead><tr><th>%T
<th>%N
<th>%MIN
<th>%MAX
<th>%signed
</thead><tbody>

<tr><th>`byte$T
<td>8
<td>−2`7^sup
<td>2`7^sup ~MINUS 1
<td>~T

<tr><th>`octet$T
<td>8
<td>0
<td>2`8^sup ~MINUS 1
<td>~F

<tr><th>`short$T
<td>16
<td>−2`15^sup
<td>2`15^sup ~MINUS 1
<td>~T

<tr><th>`unsigned short$T
<td>16
<td>0
<td>2`16^sup ~MINUS 1
<td>~F

<tr><th>`long$T
<td>32
<td>−2`31^sup
<td>2`31^sup ~MINUS 1
<td>~T

<tr><th>`unsigned long$T
<td>32
<td>0
<td>2`32^sup ~MINUS 1
<td>~F

<tr><th>`long long$T
<td>64
<td>−2`53^sup ~PLUS 1
<td>2`53^sup ~MINUS 1
<td>~T

<tr><th>`unsigned long long$T
<td>64
<td>0
<td>2`53^sup ~MINUS 1
<td>~F

</tbody></table>

<p class="note">注記：
`long long^T, `unsigned long long^T の
%MIN, %MAX
を 2 の 53 乗で~~制限しているのは、［
`EnforceRange$x ／ `Clamp$x
］`拡張属性が結付けられ$ている `long long$T 型を，~ES `Number$jt 型の整数として一義的に表現できることを確保するためである。
</p>
◎
If bitLength is 64, then:
• Let upperBound be 253 − 1.
• If signedness is "unsigned", then let lowerBound be 0.
• Otherwise let lowerBound be −253 + 1.
◎
Note: this ensures long long types associated with [EnforceRange] or [Clamp] extended attributes are representable in ECMAScript’s Number type as unambiguous integers.
◎
Otherwise, if signedness is "unsigned", then:
• Let lowerBound be 0.
• Let upperBound be 2bitLength − 1.
◎
Otherwise:
• Let lowerBound be -2bitLength − 1.
• Let upperBound be 2bitLength − 1 − 1.
</li>
	<li>
%x ~LET
~ABRUPT `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<li>
~IF［
%x ~EQ −0
］
⇒
%x ~SET +0
◎
If x is −0, then set x to +0.
</li>
	<li>
<p>
~IF［
`EnforceRange$x `拡張属性が結付けられ$ている~IDL型への変換である
］：
◎
If the conversion is to an IDL type associated with the [EnforceRange] extended attribute, then:
</p>
		<ol>
			<li id="cp-x-isNonFinite">
~IF［
%x ~IN { `NaN^jv, +∞, −∞ }
］
⇒
~throwTypeError
◎
If x is NaN, +∞, or −∞, then throw a TypeError.
</li>
			<li id="cp-floor_x">
%x ~SET
~NOABRUPT `IntegerPart$A( %x )
◎
Set x to ! IntegerPart(x).
</li>
			<li>
~IF［
%x ~LT %MIN
］~OR［
%x ~GT %MAX
］
⇒
~throwTypeError
◎
If x &lt; lowerBound or x &gt; upperBound, then throw a TypeError.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%x ~NEQ `NaN^jv
］~AND［
`Clamp$x `拡張属性が結付けられ$ている~IDL型への変換である
］：
◎
If x is not NaN and the conversion is to an IDL type associated with the [Clamp] extended attribute, then:
</p>
		<ol>
			<li>
%x ~SET `min$op( `max$op( %x, %MIN ), %MAX )
◎
Set x to min(max(x, lowerBound), upperBound).
</li>
			<li>
~RET %x を最も近い整数に丸めた結果
⇒
2 つの整数と等距離にある場合は偶数を選び，−0 より +0 の方を選ぶとする
◎
Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.
◎
Return x.
</li>
		</ol>
	</li>
	<li>
~IF［
%x ~IN { `NaN^jv, +0, +∞, −∞ }
］
⇒
~RET 0
◎
If x is NaN, +0, +∞, or −∞, then return +0.
</li>
	<!--cp-floor_x-->
	<li>
%x ~SET %x `modulo$op 2<sup>%N</sup>
◎
Set x to x modulo 2bitLength.
</li>
	<li>
~IF［
%signed ~EQ ~T
］~AND［
%x  ~GTE 2<sup>%N ~MINUS 1</sup>
］
⇒
~RET %x ~MINUS 2<sup>%N</sup>
◎
If signedness is "signed" and x ≥ 2bitLength − 1, then return x − 2bitLength.
</li>
	<li>
~RET %x
◎
Otherwise, return x.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="es-float">
<h4 title="float">3.2.5. `float^T</h4>

<div class="algorithm">
<p id="es-to-float">
次の~algoにより，~ES値 %V は `float$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL float value by running the following algorithm:
</p>

<ol>
	<li id="cp-ToNumber">
%x ~LET
~ABRUPT `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<!--cp-x-isNonFinite-->
	<li id="cp-let-S-to754">
%S ~LET ［
−0 を除く有限 IEEE 754 単精度 浮動小数点~値の集合に， 2 つの特別な値{ 2`128^sup, −2`128^sup }
を追加した集合
］
◎
Let S be the set of finite IEEE 754 single-precision floating point values except −0, but with two special values added: 2^128 and −2^128.
</li>
	<li id="cp-round-x-to-y">
%y ~LET 
%S の中で %x に最も近い数量-値
⇒
2 数が等距離にある場合は，`仮数が偶数になる方^emを選ぶとする
⇒
この目的においては， 2 つの特別な値 2`128^sup, −2`128^sup の仮数は偶数と見なされる。
◎
Let y be the number in S that is closest to x, selecting the number with an even significand if there are two equally close values. (The two special values 2^128 and −2^128 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%y ~IN { 2`128^sup, −2`128^sup }
］
⇒
~throwTypeError
◎
If y is 2^128 or −2^128, then throw a TypeError.
</li>
	<li id="cp-if-y-0-x-lt0">
~IF［
%y ~EQ +0
］~AND［
%x ~LT 0
］
⇒
~RET −0
◎
If y is +0 and x is negative, return −0.
</li>
	<li id="cp-ret-y">
~RET %y
◎
Return y.
</li>
</ol>
</div>

<p id="float-to-es">
~IDL `float$T 値 %V を`~ES値に変換-$した結果は、
%V と同じ数量-値を表現する `Number^jt 値になる。
◎
The result of converting an IDL float value to an ECMAScript value is the Number value that represents the same numeric value as the IDL float value.
</p>
			</section>
			<section id="es-unrestricted-float">
<h4 title="unrestricted float">3.2.6. `unrestricted float^T</h4>

<div class="algorithm">
<p id="es-to-unrestricted-float">
次の~algoにより，~ES値 %V は `unrestricted float$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL unrestricted float value by running the following algorithm:
</p>

<ol>
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ［
~bit~pattern `7fc00000^X の IEEE 754 NaN 値 `IEEE-754$r
］を表現する~IDL `unrestricted float$T 値
◎
If x is NaN, then return the IDL unrestricted float value that represents the IEEE 754 NaN value with the bit pattern 0x7fc00000 [IEEE-754].
</li>
	<!--cp-let-S-to754-->
	<!--cp-round-x-to-y-->
	<li>
~IF［
%y ~EQ 2`128^sup
］
⇒
~RET +∞
◎
If y is 2^128, return +∞.
</li>
	<li>
~IF［
%y ~EQ −2`128^sup 
］
⇒
~RET −∞
◎
If y is −2^128, return −∞.
</li>
	<!--cp-if-y-0-x-lt0-->
	<!--cp-ret-y-->
</ol>
</div>

<p class="note">注記：
~ES `NaN^jv 値は唯 1 個しかないので，特定0の単精度 IEEE 754 NaN 値に正準化されなければならない。
上で言及した NaN 値は、単純に，その~bit~patternが無符号 32 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular single precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 32 bit integer.
</p>

<div class="algorithm">
<p id="unrestricted-float-to-es">
~IDL `unrestricted float$T 値 %V を`~ES値に変換-$した結果は、次の `Number^jt になる：
◎
The result of converting an IDL unrestricted float value to an ECMAScript value is a Number:
</p>
<ol>
	<li>
~IF［
%V ~EQ NaN
］
⇒
~RET `NaN^jv
◎
If the IDL unrestricted float value is a NaN, then the Number value is NaN.
</li>
	<li>
~RET %V と同じ数量-値を表現する（~~唯一の） `Number^jt 値
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted float value.
</li>
</ol>
</div>
			</section>
			<section id="es-double">
<h4 title="double">3.2.7. `double^T</h4>

<div class="algorithm">
<p id="es-to-double">
次の~algoにより，~ES値 %V は `double$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL double value by running the following algorithm:
</p>

<ol>
	<!--cp-ToNumber-->
	<!--cp-x-isNonFinite-->
	<li>
~RET ［
%x と同じ数量-値
］を表現する~IDL `double$T 値
◎
Return the IDL double value that represents the same numeric value as x.
</li>
</ol>
</div>

<p id="double-to-es">
~IDL `double$T 値 %V を`~ES値に変換-$した結果は、
%V と同じ数量-値を表現する `Number^jt 値になる。
◎
The result of converting an IDL double value to an ECMAScript value is the Number value that represents the same numeric value as the IDL double value.
</p>
			</section>
			<section id="es-unrestricted-double">
<h4 title="unrestricted double">3.2.8. `unrestricted double^T</h4>

<div class="algorithm">
<p id="es-to-unrestricted-double">
次の~algoにより，~ES値 %V は `unrestricted double$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL unrestricted double value by running the following algorithm:
</p>

<ol>
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ［
~bit~pattern `7ff8000000000000^X の IEEE 754 NaN 値 `IEEE-754$r
］を表現する~IDL `unrestricted double$T 値
◎
If x is NaN, then return the IDL unrestricted double value that represents the IEEE 754 NaN value with the bit pattern 0x7ff8000000000000 [IEEE-754].
</li>
	<li>
~RET ［
%x と同じ数量-値
］を表現する~IDL `unrestricted double$T 値
◎
Return the IDL unrestricted double value that represents the same numeric value as x.
</li>
</ol>
</div>

<p class="note">注記：
~ES `NaN^jv 値は唯 1 個しかないので，特定0の倍精度 IEEE 754 NaN 値に正準化されなければならない。
上で言及した NaN 値は、単純に，その~bit~patternが無符号 64 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular double precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 64 bit integer.
</p>

<div class="algorithm">
<p id="unrestricted-double-to-es">
~IDL `unrestricted double$T 値 %V を`~ES値に変換-$した結果は、次の `Number^jt になる：
◎
The result of converting an IDL unrestricted double value to an ECMAScript value is a Number:
</p>

<ol>
	<li>
~IF［
%V ~EQ NaN
］
⇒
~RET `NaN^jv
◎
If the IDL unrestricted double value is a NaN, then the Number value is NaN.
</li>
	<li>
~RET %V と同じ数量-値を表現する（~~唯一の） `Number^jt 値
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted double value.
</li>
</ol>
</div>
			</section>
			<section id="es-DOMString">
<h4 title="DOMString">3.2.9. `DOMString^T</h4>

<div class="algorithm">
<p id="es-to-DOMString">
次の~algoにより，~ES値 %V は `DOMString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL DOMString value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
%V ~EQ `null^jv
］~AND［
`TreatNullAs$x `拡張属性が結付けられ$ている~IDL型への変換である
］
⇒
~RET 空~文字列を表現する `DOMString$T 値
◎
If V is null and the conversion is to an IDL type associated with the [TreatNullAs] extended attribute, then return the DOMString value that represents the empty string.
</li>
	<li>
%x ~LET `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~RET ［
その~ES `String^jt 値 %x が表現するものと同じ，符号単位の並び
］を表現する~IDL `DOMString$T 値
◎
Return the IDL DOMString value that represents the same sequence of code units as the one the ECMAScript String value x represents.
</li>
</ol>
</div>

<p id="DOMString-to-es">
~IDL `DOMString$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ`符号単位$の並びを表現する `String^jt 値になる。
◎
The result of converting an IDL DOMString value to an ECMAScript value is the String value that represents the same sequence of code units that the IDL DOMString represents.
</p>
			</section>
			<section id="es-ByteString">
<h4 title="ByteString">3.2.10. `ByteString^T</h4>

<div class="algorithm">
<p id="es-to-ByteString">
次の~algoにより，~ES値 %V は `ByteString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL ByteString value by running the following algorithm:
</p>

<ol>
	<li>
%x ~LET `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~IF［
%x の中に 値 ~GT 255 なる`要素$eSがある
］
⇒
~throwTypeError
◎
If the value of any element of x is greater than 255, then throw a TypeError.
</li>
	<li>
~RET ［［
各~要素の値 ~SET %x の対応する要素の値
］にされた，
長さ ~EQ %x の長さ
］の~IDL `ByteString$T 値
◎
Return an IDL ByteString value whose length is the length of x, and where the value of each element is the value of the corresponding element of x.
</li>
</ol>
</div>

<p id="ByteString-to-es">
~IDL `ByteString$T 値 %V を`~ES値に変換-$した結果は、次を満たすようにされた
`String^jt 値になる
⇒
［
長さ ~EQ %V の長さ
］~AND［
各 `要素$eSに対し，その値 ~EQ %V の対応する要素の値
］
◎
The result of converting an IDL ByteString value to an ECMAScript value is a String value whose length is the length of the ByteString, and the value of each element of which is the value of the corresponding element of the ByteString.
</p>

			</section>
			<section id="es-USVString">
<h4 title="USVString">3.2.11. `USVString^T</h4>

<div class="algorithm">
<p id="es-to-USVString">
次の~algoにより，~ES値 %V は `USVString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL USVString value by running the following algorithm:
</p>

<ol>
	<li>
%文字列 ~LET %V を `DOMString$T 型の`~IDL値に変換-$した結果
◎
Let string be the result of converting V to a DOMString.
</li>
	<li>
~RET
%文字列 を `~Unicode~scalar値~列に変換-$した結果の~IDL `USVString$T 値
◎
Return an IDL USVString value that is the result of converting string to a sequence of Unicode scalar values.
</li>
</ol>
</div>

<div class="algorithm">
<p id="USVString-to-es">
次の~algoにより，~IDL `USVString$T 値 %V は`~ES値に変換-$される：
◎
An IDL USVString value is converted to an ECMAScript value by running the following algorithm:
</p>

<ol>
	<li>
%~scalar値~列 ~LET %V が表現する`~Unicode~scalar値$の並び
◎
Let scalarValues be the sequence of Unicode scalar values the USVString represents.
</li>
	<li>
%文字列 ~LET %~scalar値~列 を~UTF-16に符号化した結果の`符号単位$の並び
◎
Let string be the sequence of code units that results from encoding scalarValues in UTF-16.
</li>
	<li>
~RET
%文字列 と同じ`符号単位$の並びを表現する `String^jt 値
◎
Return the String value that represents the same sequence of code units as string.
</li>
</ol>
</div>

			</section>
			<section id="es-object">
<h4 title="object">3.2.12. `object^T</h4>

<p>
~IDL `object$T 値は、~ES `Object^jt 値により表現される。
◎
IDL object values are represented by ECMAScript Object values.
</p>

<div class="algorithm">
<p id="es-to-object">
次の~algoにより，~ES値 %V は `object$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL object value by running the following algorithm:
</p>

<ol>
	<li id="cp-type-not-object">
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Object, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objを参照する~IDL `object$T 値
◎
Return the IDL object value that is a reference to the same object as V.
</li>
</ol>
</div>

<p id="object-to-es">
~IDL `object$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL object value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL object represents.
</p>
			</section>
			<section id="es-symbol">
<h4 title="symbol">3.2.13. `symbol^T</h4>

<p>
~IDL `symbol$T 値は、~ES `Symbol^jt 値により表現される。
◎
IDL symbol values are represented by ECMAScript Symbol values.
</p>

<div class="algorithm">
<p id="es-to-symbol">
次の~algoにより，~ES値 %V は `symbol$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL symbol value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Symbol^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Symbol, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~symbolを参照する~IDL `symbol$T 値
◎
Return the IDL symbol value that is a reference to the same symbol as V.
</li>
</ol>
</div>

<p id="symbol-to-es">
~IDL `symbol$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~symbolへの参照を表現する `Symbol^jt 値になる。
◎
The result of converting an IDL symbol value to an ECMAScript value is the Symbol value that represents a reference to the same symbol that the IDL symbol represents.
</p>

			</section>
			<section id="es-interface">
<h4 title="Interface types">3.2.14. ~ifc型</h4>

<p>
~IDL`~ifc型$の値は、~ES `Object^jt 値（`関数~obj$も含む）により表現される。
◎
IDL interface type values are represented by ECMAScript Object values (including function objects).
</p>

<div class="algorithm">
<p id="es-to-interface">
次の~algoにより，~ES値 %V は `~ifc型$ %I の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL interface type value by running the following algorithm (where I is the interface):
</p>

<ol>
	<li>
~IF［
%V は %I を`実装-$する
］
⇒
~RET その~platform~objへの参照を表現する，~IDL`~ifc型$の値
◎
If V implements I, then return the IDL interface type value that represents a reference to that platform object.
</li>
	<li id="cp-throw-typeerror">
~throwTypeError
◎
Throw a TypeError.
</li>
</ol>
</div>

<p id="interface-to-es">
~IDL`~ifc型$の値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL interface type value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL interface type value represents.
</p>

			</section>
			<section id="es-callback-interface">
<h4 title="Callback interface types">3.2.15. ~callback~ifc型</h4>

<p>
~IDL`~callback~ifc型$の値は、~ES `Object^jt 値（`関数~obj$も含む）により表現される。
◎
IDL callback interface type values are represented by ECMAScript Object values (including function objects).
</p>

<div class="algorithm">
<p id="es-to-callback-interface">
次の~algoにより，~ES値 %V は `~callback~ifc型$の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL callback interface type value by running the following algorithm:
</p>

<ol>
	<!--cp-type-not-object-->
	<li>
~RET %V への参照を表現し, `~callback文脈$として`現任の設定群~obj$を伴う，~IDL`~callback~ifc型$の値
◎
Return the IDL callback interface type value that represents a reference to V, with the incumbent settings object as the callback context.
</li>
</ol>

</div>

<p id="callback-interface-to-es">
~IDL`~callback~ifc型$の値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL callback interface type value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL callback interface type value represents.
</p>

			</section>
			<section id="es-dictionary">
<h4 title="Dictionary types">3.2.16. 辞書~型</h4>

<p>
~IDL`辞書~型$の値は、~ES `Object^jt 値により表現される。
その~obj（またはその原型鎖）上の~propが`辞書~mb$に対応する。
◎
IDL dictionary type values are represented by ECMAScript Object values. Properties on the object (or its prototype chain) correspond to dictionary members.
</p>

<div class="algorithm">
<p id="es-to-dictionary">
次の~algoにより，~ES値 %~es辞書 は `辞書~型$ %D の`~IDL値に変換-$される：
◎
An ECMAScript value esDict is converted to an IDL dictionary type value by running the following algorithm (where D is the dictionary type):
</p>

<ol>
	<li>
~IF［
`Type$A( %~es辞書 ) ~NIN { `Undefined^jt, `Null^jt, `Object^jt }
］
⇒
~throwTypeError
◎
If Type(esDict) is not Undefined, Null or Object, then throw a TypeError.
</li>
	<li>
%~IDL辞書 ~LET 型 %D の空の辞書~値（初期~時にはどの`辞書~mb$も`在さない$ものと見なされる）
◎
Let idlDict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
</li>
	<li>
<p id="cp-for-each-inherited-dictionaries">
［
%D, %D が`継承した辞書たち$
］を成す
~EACH( %辞書 )
に対し，先祖から継承-順に：
◎
Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
◎
For each dictionary dictionary in dictionaries, in order:
</p>
		<ol>
			<li>
<p id="cp-foreach-mb">
%辞書 上に宣言されている
~EACH( 辞書~mb %member )
に対し，~mbの`識別子$の辞書式~順序で：
◎
For each dictionary member member declared on dictionary, in lexicographical order:
</p>
				<ol>
					<li>
<p>
%~es~mb値 ~LET
`Type$A( %~es辞書 ) に応じて，次で与えられる~ES値：
◎
Let key be the identifier of member.
◎
Let esMemberValue be an ECMAScript value, depending on Type(esDict):
</p>

						<dl class="switch">
							<dt>`Undefined^jt</dt>
							<dt>`Null^jt</dt>
							<dd>
`undefined^jv
◎
undefined
</dd>

							<dt>その他</dt>
							<dd>
~ABRUPT `Get$A( %~es辞書, %member の`識別子$ )
◎
? Get(esDict, key)
</dd>
						</dl>
					</li>
					<li>
~IF［
%~es~mb値 ~NEQ `undefined^jv
］
⇒
%~idl値 ~LET %~es~mb値 を %member に宣言されている型の`~IDL値に変換-$した結果
◎
If esMemberValue is not undefined, then:
• Let idlMemberValue be the result of converting esMemberValue to an IDL value whose type is the type member is declared to be of.
• Set the dictionary member on idlDict with key name key to the value idlMemberValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF［
%member は`既定~値$diC %d を持つ
］
⇒
%~idl値 ~LET %d
◎
Otherwise, if esMemberValue is undefined but member has a default value, then:
• Let idlMemberValue be member’s default value.
• Set the dictionary member on idlDict with key name key to the value idlMemberValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF［
%member は `必須~辞書~mb$である
］
⇒
~throwTypeError
◎
Otherwise, if esMemberValue is undefined and member is a required dictionary member, then throw a TypeError.
</li>
					<li>
~ELSE
⇒
~CONTINUE
◎
↑</li>
					<li>
%~IDL辞書 上の %member の値 ~SET %~idl値
（この辞書~mb %member は`在する$ものと見なされるようになる）
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~IDL辞書
◎
Return idlDict.
</li>
</ol>
</div>

<p class="note">注記：
~ES~obj上で`辞書~mb$を検索する順序は、~objの~prop列挙~順序と同じになるとは限らない。
◎
Note: The order that dictionary members are looked up on the ECMAScript object are not necessarily the same as the object’s property enumeration order.
</p>

<div class="algorithm">
<p id="dictionary-to-es">
次の~algoにより，~IDL辞書 %D 型の値 %V は `Object^jt 型の`~ES値に変換-$される：
◎
An IDL dictionary value V is converted to an ECMAScript Object value by running the following algorithm (where D is the dictionary):
</p>

<ol>
	<li>
%O ~LET
~NOABRUPT `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let O be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<!--cp-for-each-inherited-dictionaries-->
		<ol>
			<li>
<!--cp-foreach-mb-->
				<ol>
					<li>
~IF［
%member は %V 上に`在さない$
］
⇒
~CONTINUE
◎
Let key be the identifier of member.
◎
If the dictionary member named key is present in V, then:
</li>
					<li>
%~idl値 ~LET %V 上の %member の値
◎
Let idlValue be the value of member on V.
</li>
					<li>
%~es値 ~LET %~idl値 を`~ES値に変換-$した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
					<li>
~NOABRUPT `CreateDataProperty$A( %O, %member の`識別子$, %~es値 )
◎
Perform ! CreateDataProperty(O, key, value).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>
</div>
			</section>
			<section id="es-enumeration">
<h4 title="Enumeration types">3.2.17. 列挙~型</h4>

<p>
~IDL`列挙~型$の値は、~ES `String^jt 値により表現される。
◎
IDL enumeration types are represented by ECMAScript String values.
</p>

<div class="algorithm">
<p id="es-to-enumeration">
次の~algoにより，~ES値 %V は `列挙$型 %E の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL enumeration type value as follows (where E is the enumeration):
</p>

<ol>
	<li>
%S ~LET `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
	<li>
~IF［
%S は %E の`列挙~値$のいずれでもない
］
⇒
~throwTypeError
◎
If S is not one of E’s enumeration values, then throw a TypeError.
</li>
	<li>
~RET 型 %E の， %S に等しい列挙~値
◎
Return the enumeration value of type E that is equal to S.
</li>
</ol>
</div>

<p id="enumeration-to-es">
~IDL`列挙$型の値 %V を`~ES値に変換-$した結果は、
%V と同じ`符号単位$の並びを表現する `String^jt 値になる。
◎
The result of converting an IDL enumeration type value to an ECMAScript value is the String value that represents the same sequence of code units as the enumeration value.
</p>
			</section>
			<section id="es-callback-function">
<h4 title="Callback function types">3.2.18. ~callback関数~型</h4>

<p>
~IDL`~callback関数~型$の値は、~ES`関数~obj$により表現される。
ただし， `TreatNonObjectAsNull$x の場合は、任意の~objをとり得る。
◎
IDL callback function types are represented by ECMAScript function objects, except in the [TreatNonObjectAsNull] case, when they can be any object.
</p>

<div class="algorithm">
<p id="es-to-callback-function">
次の~algoにより，~ES値 %V は `~callback関数~型$の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL callback function type value by running the following algorithm:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
`IsCallable$A( %V ) ~EQ ~T
</li>
			<li>
この~algoは、次を満たす`属性$へ代入することに因り遂行されている
⇒
［
`~nullable$ `~callback関数$型である
］~AND［
`TreatNonObjectAsNull$x 注釈付きである
］
</li>
		</ul>
<p>
…ならば
⇒
~RET
%V が表現するものと同じ~objを表現し,
`~callback文脈$として`現任の設定群~obj$を伴う，~IDL`~callback関数~型$の値
</p>
◎
If the result of calling IsCallable(V) is false and the conversion to an IDL value is not being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then throw a TypeError.
◎
Return the IDL callback function type value that represents a reference to the same object that V represents, with the incumbent settings object as the callback context.
</li>
	<li>
~throwTypeError
◎
↑</li>
</ol>
</div>

<p id="callback-function-to-es">
~IDL`~callback関数~型$の値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照になる。
◎
The result of converting an IDL callback function type value to an ECMAScript value is a reference to the same object that the IDL callback function type value represents.
</p>
			</section>
			<section id="es-nullable-type">
<h4 title="Nullable types — T?">3.2.19. ~nullable型 — `~varT?^T</h4>

<p>
~IDL`~nullable型$の値は、その`内縁~型$に対応する~ES型の値か, または
~ES `null^jv 値により表現される。
◎
IDL nullable type values are represented by values of either the ECMAScript type corresponding to the inner IDL type, or the ECMAScript null value.
</p>

<p>
この節を通して、
`~varT?^T は，`内縁~型$が %T である~IDL`~nullable型$を表す。
</p>

<div class="algorithm">
<p id="es-to-nullable">
次の~algoにより，~ES値 %V は 型 `~varT?^T の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL nullable type T? value (where T is the inner type) as follows:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
［
`Type$A( %V ) ~NEQ `Object^jt
］~AND［
この~algoは、次を満たす`属性$へ代入することに因り遂行されている
］
⇒
［
`~nullable$`~callback関数$型である【！missing id="dfn-nullable"】
］~AND［
`TreatNonObjectAsNull$x 注釈付きである
］
</li>
			<li>
%V ~IN { `null^jv, `undefined^jv }
</li>
		</ul>
<p>
…ならば
⇒
~RET 型 `~varT?^T の値 `null^V
</p>

◎
If Type(V) is not Object, and the conversion to an IDL value is being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then return the IDL nullable type T? value null.
◎
Otherwise, if V is null or undefined, then return the IDL nullable type T? value null.
</li>
	<li>
~RET %V を`内縁~型$ %T 用の規則に従って`~IDL値に変換-$した結果
◎
Otherwise, return the result of converting V using the rules for the inner IDL type T.
</li>
</ol>
</div>

<p id="nullable-to-es">
型 `~varT?^T の~IDL値 %V を`~ES値に変換-$した結果は、［
%V ~EQ `null^V ならば `null^jv ／
~ELSE_ %V を型 %T の値として`~ES値に変換-$した結果
］になる。
◎
The result of converting an IDL nullable type value to an ECMAScript value is:
• If the IDL nullable type T? value is null, then the ECMAScript value is null.
• Otherwise, the ECMAScript value is the result of converting the IDL nullable type value to the inner IDL type T.
</p>

			</section>
			<section id="es-sequence">
<h4 title="Sequences — sequence&lt;T&gt;">3.2.20. 連列 — ~sequence_T</h4>

<p>
~IDL `~sequence_T$ 値は、~ES `Array^jt 値により表現される。
◎
IDL sequence&lt;T&gt; values are represented by ECMAScript Array values.
</p>

<div class="algorithm">
<p id="es-to-sequence">
次の~algoにより，~ES値 %V は `~sequence_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL sequence&lt;T&gt; value as follows:
</p>

<ol>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Object, throw a TypeError.
</li>
	<li id="cp-checkiter-V">
%method ~LET
~ABRUPT `GetMethod$A( %V, `iterator$jS )
◎
Let method be ? GetMethod(V, @@iterator).
</li>
	<li>
~IF［
%method ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If method is undefined, throw a TypeError.
</li>
	<li>
( %V, %method )
から
`~sequence_T$ 型の`連列~値を作成-$した結果
◎
Return the result of creating a sequence from V and method.
</li>
</ol>
</div>

<div class="algorithm">
<p id="sequence-to-es">
次の~algoにより，型 `~sequence_T$ の~IDL連列~値 %S は
`Array^jt 型の`~ES値に変換-$される：
◎
An IDL sequence value S of type sequence&lt;T&gt; is converted to an ECMAScript Array object as follows:
</p>

<ol>
	<li>
%n ~LET %S の長さ
◎
Let n be the length of S.
</li>
	<li>
%A ~LET 式 `[]^c で作成されるものと同じ，新たな `Array^jt ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
	<li>
%i ~LET 0
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE［
%i ~LT %n
］：
◎
While i &lt; n:
</p>
		<ol>
			<li>
%V ~LET %S 内の~index %i に位置する値
◎
Let V be the value in S at index i.
</li>
			<li>
%E ~LET %V を`~ES値に変換-$した結果
◎
Let E be the result of converting V to an ECMAScript value.
</li>
			<li>
%P ~LET `ToString$A( %i )
◎
Let P be the result of calling ToString(i).
</li>
			<li>
`CreateDataProperty$A( %A, %P, %E ) を~callする
◎
Call CreateDataProperty(A, P, E).
</li>
			<li>
%i ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
~RET %A
◎
Return A.
</li>
</ol>
</div>

				<section id="create-sequence-from-iterable">
<h5 title="Creating a sequence from an iterable">3.2.20.1. 可反復から連列を作成する</h5>

<div class="algorithm">
<p>
所与の
( 可反復 %可反復, 反復子~取得子 %method )
から
型 `~sequence_T$ の~IDL値を作成するときは、次の手続きを遂行する：
◎
To create an IDL value of type sequence&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol>
	<li>
%反復子 ~LET
~ABRUPT `GetIterator$A( %可反復, `sync^i, %method )
◎
Let iter be ? GetIterator(iterable, sync, method).
</li>
	<li>
%結果 ~LET 新たな`~list$
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Repeat
</p>
		<ol>
			<li>
%next ~LET
~ABRUPT `IteratorStep$A( %反復子 )
◎
Let next be ? IteratorStep(iter).
</li>
			<li>
~IF［
%next ~EQ `false^jv
］
⇒
~RET ~IDL `~sequence_T$ 型~値としての %結果
◎
If next is false, then return an IDL sequence value of type sequence&lt;T&gt; of length i, where the value of the element at index j is Sj.
</li>
			<li>
%nextItem ~LET
~ABRUPT `IteratorValue$A( %next )
◎
Let nextItem be ? IteratorValue(next).
</li>
			<li>
%結果 に［
%nextItem を型 %T の`~IDL値に変換-$した結果
］を`付加する$
◎
Initialize Si to the result of converting nextItem to an IDL value of type T.
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>
</div>
				</section>

<div class="example">
<p>
次の`~ifc$は
連列~型の引数を伴う`演算$と伴に
連列~型の`属性$を定義する。
◎
The following interface defines an attribute of a sequence type as well as an operation with an argument of a sequence type.
</p>

<pre class="webidl">
[Exposed=Window]
interface Canvas {

  sequence&lt;DOMString&gt; getSupportedImageCodecs();

  void drawPolygon(sequence&lt;double&gt; %coordinates);
  sequence&lt;double&gt; getLastDrawnPolygon();

  /* <!--cp-some-code--> */
};
</pre>

<p>
この~ifcの~ES実装においては、型［
`String^jt ／ `Number^jt
］の要素からなる `Array^jt ~objが，それぞれ［
`sequence&lt;DOMString&gt;^T ／
`sequence&lt;double&gt;^T
］の表現-に利用される。
この `Array^jt ~objは実質的には値渡しであり、
`getSupportedImageCodecs()^M
関数が~callされる度に，新たな `Array^jt が返され、
`Array^jt が `drawPolygon^M に渡されたときは常に，その参照は~call完了-後には保有されないことになる。
◎
In an ECMAScript implementation of this interface, an Array object with elements of type String is used to represent a sequence&lt;DOMString&gt;, while an Array with elements of type Number represents a sequence&lt;double&gt;. The Array objects are effectively passed by value; every time the getSupportedImageCodecs() function is called a new Array is returned, and whenever an Array is passed to drawPolygon no reference will be kept after the call completes.
</p>

<pre class="es-code">
/* <span class="comment">
`Canvas^T の~instanceを得る。
その `getSupportedImageCodecs()^M は、 2 個の `DOMString^T 値
`image/png^l, `image/svg+xml^l
からなる連列を返すものとする。
◎
Obtain an instance of Canvas. Assume that getSupportedImageCodecs() returns a sequence with two DOMString values: "image/png" and "image/svg+xml".
</span> */
var %canvas = getCanvas();

/* <span class="comment">
長さ 2 の `Array^jt ~obj：
◎
An Array object of length 2.
</span> */
var %supportedImageCodecs = %canvas.getSupportedImageCodecs();

/* <span class="comment" id="cp-eval-img-png">
`image/png^l に評価される：
◎
Evaluates to "image/png".
</span> */
%supportedImageCodecs[0];

/* <span class="comment">
%canvas`.getSupportedImageCodecs()^c が~callされる度に，新たな `Array^jt object が返される。
したがって，返された `Array^jt を改変しても，後続の関数~callで返される値には影響しないことになる：
◎
Each time canvas.getSupportedImageCodecs() is called, it returns a new Array object.  Thus modifying the returned Array will not affect the value returned from a subsequent call to the function.
</span> */
%supportedImageCodecs[0] = `image/jpeg^l;

/* <!--cp-eval-img-png--> */
%canvas.getSupportedImageCodecs()[0];

/* <span class="comment">
各~callで新たな `Array^jt ~objが返されるので、これは `false^jv に評価される：
◎
This evaluates to false, since a new Array object is returned each call.
</span> */
%canvas.getSupportedImageCodecs() == %canvas.getSupportedImageCodecs();

/* <span class="comment">
数量-値の `Array^jt は...
◎
An Array of Numbers...
</span> */
var %a = [0, 0, 100, 0, 50, 62.5];

/* <span class="comment">
...は `sequence&lt;double&gt;^T を期待する~platform~objに渡すことができる：
◎
...can be passed to a platform object expecting a sequence&lt;double&gt;.
</span> */
%canvas.drawPolygon(%a);

/* <span class="comment">
各~要素は最初に `ToNumber$A() の~callにより， `double^T に変換される。
したがって，次の~callは `drawPolygon()^M が返る前に `hi^l が alert されることを除き，前のものと等価になる：
◎
Each element will be converted to a double by first calling ToNumber(). So the following call is equivalent to the previous one, except that "hi" will be alerted before drawPolygon() returns.
</span> */
%a = [
    false,
    '',
    { valueOf: function() { alert('hi'); return 100; } },
    0,
    '50',
    new Number(62.5)
];
%canvas.drawPolygon(%a);

/* <span class="comment">
`Array^jt は実質的に値渡しなので，`drawPolygon()^M に渡された `Array^jt を改変しても， `Canvas^T には効果を及ぼさないことが保証される：
◎
Modifying an Array that was passed to drawPolygon() is guaranteed not to have an effect on the Canvas, since the Array is effectively passed by value.
</span> */
%a[4] = 20;
var %b = %canvas.getLastDrawnPolygon();

alert(%b[4]);    /* <span class="comment">
これは `50^l を alert することになる。
◎
This would alert "50".
</span> */
</pre>
</div>

			</section>
			<section id="es-record">
<h4 title="Records — record&lt;K, V&gt;">3.2.21. ~record — ~record_KV</h4>

<p>
~IDL `record$T 値は、~ES `Object^jt 値により表現される。
◎
IDL record&lt;K, V&gt; values are represented by ECMAScript Object values.
</p>

<div class="algorithm">
<p id="es-to-record">
次の~algoにより，~ES値 %O は `~record_KV$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value O is converted to an IDL record&lt;K, V&gt; value as follows:
</p>

<ol>
	<li>
~IF［
`Type$A( %O ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(O) is not Object, throw a TypeError.
</li>
	<li>
%結果 ~LET 新たな空の`~record_KV$ 値
◎
Let result be a new empty instance of record&lt;K, V&gt;.
</li>
	<li>
%~key~list ~LET
~ABRUPT %O.`OwnPropertyKeys^sl()
◎
Let keys be ? O.[[OwnPropertyKeys]]().
</li>
	<li>
<p>
%~key~list 内の
~EACH( %~key )
に対し：
◎
For each key of keys:
</p>
		<ol>
			<li>
%記述子 ~LET
~ABRUPT %O.`GetOwnProperty^sl( %~key )
◎
Let desc be ? O.[[GetOwnProperty]](key).
</li>
			<li>
<p>
~IF［
%記述子 ~NEQ `undefined^jv
］~AND［
%記述子.`Enumerable^sl ~EQ `true^jv
］：
◎
If desc is not undefined and desc.[[Enumerable]] is true:
</p>
				<ol>
					<li>
%有型~key ~LET %~key を %K 型の`~IDL値に変換-$した結果
◎
Let typedKey be key converted to an IDL value of type K.
</li>
					<li>
%値 ~LET
~ABRUPT `Get$A( %O, %~key )
◎
Let value be ? Get(O, key).
</li>
					<li>
%有型~値 ~LET %値 を %V 型の`~IDL値に変換-$した結果
◎
Let typedValue be value converted to an IDL value of type V.
</li>
					<li>
<p>
%結果[ %有型~key ] ~SET %有型~値
◎
Set result[typedKey] to typedValue.
</p>

<p class="note">注記：
%O が~proxy~objである場合、
%有型~key は，すでに %結果 内にあり得る。
◎
Note: it’s possible that typedKey is already in result, if O is a proxy object.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algorithm">
<p id="record-to-es">
次の~algoにより，~IDL `record$T 値 %D は`~ES値に変換-$される：
◎
An IDL record&lt;…&gt; value D is converted to an ECMAScript value as follows:
</p>

<ol>
	<li>
%結果 ~LET
~NOABRUPT `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let result be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<p>
%D 内の
~EACH( %~key → %値 )
に対し：
◎
For each key → value of D:
</p>
		<ol>
			<li>
%~es~key ~LET %~key を`~ES値に変換-$した結果
◎
Let esKey be key converted to an ECMAScript value.
</li>
			<li>
%~es値 ~LET %値 を`~ES値に変換-$した結果
◎
Let esValue be value converted to an ECMAScript value.
</li>
			<li>
%作成した ~LET
~NOABRUPT `CreateDataProperty$A( %結果, %~es~key, %~es値 )
◎
Let created be ! CreateDataProperty(result, esKey, esValue).
</li>
			<li>
~Assert：
%作成した ~EQ `true^jv
◎
Assert: created is true.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="example">

<p>
`record&lt;DOMString, double&gt;^T 型の引数として~ES値 `{b: 3, a: 4}^jv を渡した結果は、~IDL値 «[ `b^l → 3, `a^l → 4 ]» になる。
◎
Passing the ECMAScript value {b: 3, a: 4} as a record&lt;DOMString, double&gt; argument would result in the IDL value «[ "b" → 3, "a" → 4 ]».
</p>

<p>
~recordが考慮するのは，自前の列挙-可能な~prop
—
`own＠~TC39#sec-own-property$href
`enumerable＠~TC39#sec-property-attributes$href
~prop —
に限られるので、引数を返すだけの~IDL演算
<span class="block">
<samp>`record&lt;DOMString, double&gt;^T identity(`record&lt;DOMString, double&gt;^T %arg)</samp>
</span>
が与えられたとき、次の~codeは 各~表明（ `assert^c ）に合格する：
◎
Records only consider own enumerable properties, so given an IDL operation record&lt;DOMString, double&gt; identity(record&lt;DOMString, double&gt; arg) which returns its argument, the following code passes its assertions:
</p>

<pre class="es-code">
let %proto = {a: 3, b: 4};
let %obj = {__proto__: proto, d: 5, c: 6}
Object.defineProperty(%obj, "e", {value: 7, enumerable: false});
let %result = identity(%obj);
console.assert(%result.a === undefined);
console.assert(%result.b === undefined);
console.assert(%result.e === undefined);
let %entries = Object.entries(%result);
console.assert(%entries[0][0] === "d");
console.assert(%entries[0][1] === 5);
console.assert(%entries[1][0] === "c");
console.assert(%entries[1][1] === 6);
</pre>

<p>
~recordの［
~key, 値
］は、他から拘束され得る
— ~keyは、 3 種の文字列~型に拘束されるに過ぎないが。
例えば：
◎
Record keys and values can be constrained, although keys can only be constrained among the three string types. The following conversions have the described results:
</p>

<table><thead><tr><th>渡された値
◎
Value
<th>値が渡された型
◎
Passed to type
<th>結果
◎
Result
</thead><tbody>

<tr><td>`{"😞": 1}^jv
<td>`record&lt;ByteString, double&gt;^T
<td>`TypeError^jE

<tr><td>`{"\uD83D": 1}^jv
<td>`record&lt;USVString, double&gt;^T
<td>«[ `\uFFFD^l → 1 ]»

<tr><td>`{"\uD83D": {hello: "world"}}^jv
<td>`record&lt;DOMString, double&gt;^T
<td>«[ `\uD83D^l → 0 ]»
</tbody></table>

</div>

			</section>
			<section id="es-promise">
<h4 title="Promise types — Promise&lt;T&gt;">3.2.22. ~promise型 — ~promise_T</h4>

<p>
~IDL`~promise型$値は、~ES `~PromiseCapability$~recordにより表現される。
◎
IDL promise type values are represented by ECMAScript PromiseCapability records.
</p>

<div class="algorithm">
<p id="es-to-promise">
次の~algoにより，~ES値 %V は `~promise_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL Promise&lt;T&gt; value as follows:
</p>

<ol>
	<li>
%~promise能力 ~LET
~ABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let promiseCapability be ? NewPromiseCapability(%Promise%).
</li>
	<li>
~ABRUPT `Call$A( %~promise能力.`Resolve^sl, `undefined^jv , « %V » )
◎
Perform ? Call(promiseCapability.[[Resolve]], undefined, « V »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>
</div>

<p id="promise-to-es">
~IDL`~promise型$の値 %V を`~ES値に変換-$した結果は、
%V が表現する `Promise^sl ~fieldの値と同じになる。
◎
The result of converting an IDL promise type value to an ECMAScript value is the value of the [[Promise]] field of the record that IDL promise type represents.
</p>

				<section id="es-promise-manipulation">
<h5 title="Creating and manipulating Promises">3.2.22.1. ~promiseの作成-法と操作-法</h5>

<div class="algorithm">

<p>
`新たな~promise@
（ `a new promise^en ）を`~Realm$ %~realm 内に作成するときは、次の手続きを遂行する：
◎
To create a new Promise&lt;T&gt; in a Realm realm, perform the following steps:
</p>

<ol>
	<li>
%構築子 ~LET %~realm.`Promise$jIsl
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
</li>
	<li>
~RET
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Return ? NewPromiseCapability(constructor).
</li>
</ol>
</div>

<p class="trans-note">【
%~realm は、文脈から一義的に定まる所では，省略して，単に
“新たな~promise”
とも記される。
以下の~algoでも同様。
】</p>

<div class="algorithm">

<p>
型 %T の値 %x で
`解決される~promise@
（ `resolved promise^en ）を，`~Realm$ %~realm 内に
`~promise_T$ 型の値として作成するときは、次の手続きを遂行する：
◎
To create a resolved promise of type Promise&lt;T&gt;, with x (a value of type T) in a Realm realm, perform the following steps:
</p>

<ol>
	<li>
%値 ~LET %x を`~ES値に変換-$した結果
◎
Let value be the result of converting x to an ECMAScript value.
</li>
	<li>
%構築子 ~LET %~realm.`Promise$jIsl
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
</li>
	<li>
%~promise能力 ~LET
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Let promiseCapability be ? NewPromiseCapability(constructor).
</li>
	<li>
~NOABRUPT
`Call$A( %~promise能力.`Resolve^sl, `undefined^jv, « %値 » )
◎
Perform ! Call(promiseCapability.[[Resolve]], undefined, « value »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>
</div>

<p class="trans-note">【
%~realm 同様に，型 `~promise_T$ は、［
文脈から一義的に定まる所／指定する必要がない所（
“何らかの特定の~promise型”／ “%T は［
%x の型 ／ `any$T 型
］”
で足る所）
］では，省略して単に
“%x で解決される~promise”
とも記される。
以下の~algoでも同様。
】</p>


<div class="algorithm">

<p>
事由を与える~ES値 %r で
`却下される~promise@
（ `rejected promise^en ）を，`~Realm$ %~realm 内に
`~promise_T$ 型の値として作成するときは、次の手続きを遂行する：
◎
To create a rejected promise of type Promise&lt;T&gt;, with reason r (an ECMAScript value) in a Realm realm, perform the following steps:
</p>

<ol>
	<li>
%構築子 ~LET %~realm.`Promise$jIsl
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
</li>
	<li>
%~promise能力 ~LET 
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Let promiseCapability be ? NewPromiseCapability(constructor).
</li>
	<li>
~NOABRUPT `Call$A( %~promise能力.`Reject^sl, `undefined^jv, « %r » )
◎
Perform ! Call(promiseCapability.[[Reject]], undefined, « r »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>
</div>

<div class="algorithm">

<p>
型 %T の値 %x （省略時は `void$T 値）で`~promise_T$ %p を
`解決する@
（ `resolve^en する）ときは、次の手続きを遂行する：
◎
To resolve a Promise&lt;T&gt; p with x (a value of type T), perform the following steps:
• If x is not given, then let it be the void value.
</p>

<ol>
	<li>
%値 ~LET %x を`~ES値に変換-$した結果
◎
Let value be the result of converting x to an ECMAScript value.
</li>
	<li>
~NOABRUPT `Call$A( %p.`Resolve^sl, `undefined^jv, « %値 » )
◎
Perform ! Call(p.[[Resolve]], undefined, « value »).
</li>
</ol>

<p>
%T は `void$T である場合、 %x 引数は随意であり，より単純な
“%p を`解決する$”
用法も許容される。
◎
If T is void, then the x argument is optional, allowing a simpler "resolve p" usage.
</p>
</div>

<div class="algorithm">

<p>
事由を与える~ES値 %r で`~promise_T$ %p を
`却下する@
（ `reject^en する）ときは、次の手続きを遂行する：
◎
To reject a Promise&lt;T&gt; p with reason r (an ECMAScript value), perform the following steps:
</p>

<ol>
	<li>
~NOABRUPT `Call$A( %p.`Reject^sl, `undefined^jv, « %r » )
◎
Perform ! Call(p.[[Reject]], undefined, « r »).
</li>
</ol>
</div>

<div class="algorithm">

<p>
`~promise_T$ %~promise に
`反応する@
（ `react^en する）ときは、所与の
( %充足~手続き（省略時は ε ）, %却下~手続き（省略時は ε ）)
に対し，次の手続きを遂行する（ 2 つの手続きは、順に， %~promise が［
充足された, 却下された
］ときを受持つ）：
◎
To react to a Promise&lt;T&gt; promise, given one or two sets of steps to perform, covering when the promise is fulfilled, rejected, or both, perform the following steps:
</p>

<ol>
	<li>
<p>
%充足-時の手続き ~LET 所与の引数 ( %V ) に対し次を走らす手続き：
◎
Let onFulfilledSteps be the following steps given argument V:
</p>
		<ol>
			<li>
%値 ~LET %V を型 %T の`~IDL値に変換-$した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
			<li>
~IF［
%充足~手続き ~EQ ε
］
⇒
~RET `undefined^jv
◎
If there are no steps that are required to be run if the promise was fulfilled, then return undefined.
</li>
			<li>
%結果 ~LET %T に応じて
⇒＃
`void$T ならば %充足~手続き() ／
~ELSE_ %充足~手続き( %値 )
◎
Let result be the result of performing any steps that were required to be run if the promise was fulfilled, given value if T is not void.
</li>
			<li>
~RET %結果 を`~ES値に変換-$した結果
◎
Return result, converted to an ECMAScript value.
</li>
		</ol>
	</li>
	<li>
%onFulfilled ~LET
~NOABRUPT `CreateBuiltinFunction$A( %充足-時の手続き, « » )
◎
Let onFulfilled be ! CreateBuiltinFunction(onFulfilledSteps, « »):
</li>
	<li>
<p>
%却下-時の手続き ~LET 所与の引数 ( %R ) に対し，次を走らす手続き：
◎
Let onRejectedSteps be the following steps given argument R:
</p>
		<ol>
			<li>
%事由 ~LET %R を `any$T 型の`~IDL値に変換-$した結果
◎
Let reason be the result of converting R to an IDL value of type any.
</li>
			<li>
~IF［
%却下~手続き ~EQ ε
］
⇒
~RET `undefined^jv
◎
If there are no steps that are required to be run if the promise was rejected, then return undefined.
</li>
			<li>
%結果 ~LET %却下~手続き( %事由 )
◎
Let result be the result of performing any steps that were required to be run if the promise was rejected, given reason.
</li>
			<li>
~RET %結果 を`~ES値に変換-$した結果
◎
Return result, converted to an ECMAScript value.
</li>
		</ol>
	</li>
	<li>
%onRejected ~LET
~NOABRUPT `CreateBuiltinFunction$A( %却下-時の手続き, « » )
◎
Let onRejected be ! CreateBuiltinFunction(onRejectedSteps, « »):
</li>
	<li>
%構築子 ~LET %~promise.`Promise^sl.`Realm^sl.`Promise$jIsl
◎
Let constructor be promise.[[Promise]].[[Realm]].[[Intrinsics]].[[%Promise%]].
</li>
	<li>
<p>
%新たな能力 ~LET 
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Let newCapability be ? NewPromiseCapability(constructor).
</p>

<p class="note">注記：
返される `~promise_T$ を利用しない~call元もある。
そのような事例では、実装は
%新たな能力 を作成するのを避けたいと望むこともあろう。
◎
Note: Not all callers will use the returned Promise. Implementations might wish to avoid creating newCapability in those cases.
</p>
	</li>
	<li>
~RET
~NOABRUPT `PerformPromiseThen$A( %~promise.`Promise^sl, %onFulfilled, %onRejected, %新たな能力 )
◎
Return ! PerformPromiseThen(promise.[[Promise]], onFulfilled, onRejected, newCapability).
</li>
</ol>

<p class="note">注記：
この~algoは、 `Promise.then()$c ~methによく似た仕方で挙動することになる。
特に,
［
手続きが返す値の型が［
%T ／ `~promise_T$
］である場合、
この~algoも `~promise_T$ を返す。
◎
Note: This algorithm will behave in a very similar way to the Promise.then() method. In particular, if the steps return a value of type U or Promise&lt;U&gt;, this algorithm returns a Promise&lt;U&gt; as well.
</p>
</div>

<div class="algorithm">

<p>
`~promise_T$ %~promise の
`充足-時@
に，所与の
( 型 %T の値を引数にとる何らかの手続き %手続き )
を遂行する所では、次を遂行するように %~promise に`反応する$†：
◎
To perform some steps upon fulfillment of a Promise&lt;T&gt; promise given some steps steps taking a value of type T, perform the following steps:
• React to promise:
</p>

<ol>
	<li>
~IF［
%~promise は値 %v で充足された
］
⇒
%手続き( %v )
◎
If promise was fulfilled with value v, then:
• Perform steps with v.
</li>
</ol>

<p>
`~promise_T$ %~promise の
`却下-時@
に，所与の
( ~ES値を引数にとる何らかの手続き %手続き )
を遂行する所では、次を遂行するように %~promise に`反応する$†：
◎
To perform some steps upon rejection of a Promise&lt;T&gt; promise given some steps steps taking an ECMAScript value, perform the following steps:
• React to promise:
</p>

<ol>
	<li>
~IF［
%~promise は事由 %r で却下された
］
⇒
%手続き( %r )
◎
If promise was rejected with reason r, then:
• Perform steps with r.
</li>
</ol>

<p class="trans-note">【†
すなわち，`反応する$ときの［
%充足~手続き ／ %却下~手続き
］として，指定された %手続き を渡す。
】【
同じ箇所に［
`充足-時$の手続き, `却下-時$の手続き
］両者が与えられている所では、`反応する$ときに両~手続きとも渡すことになる。
】</p>

</div>

<div class="algorithm">

<p>
`すべての~promiseを待機する@
ときは、所与の
( %~promiseたち, %成功~手続き, %失敗~手続き )
— 順に
⇒＃
`~promise_T$ 値たちが成す`~list$,
%T 値たちが成す`~list$を引数にとる手続き,
却下~事由を与える `any$T 値を引数にとる手続き
◎終
に対し，次の手続きを遂行する：
◎
To wait for all with a list of Promise&lt;T&gt; values promises, with success steps successSteps that take a list of T values and failure steps failureSteps that take a rejection reason any value, perform the following steps:
</p>

<ol>
	<li>
%充足-回数 ~LET 0
◎
Let fullfilledCount be 0.
</li>
	<li>
%却下された ~LET ~F
◎
Let rejected be false.
</li>
	<li>
<p>
%却下~handler手続き ~LET 所与の引数 ( %arg ) に対し次を走らす手続き：
◎
Let rejectionHandlerSteps be the following steps given arg:
</p>
		<ol>
			<li>
~IF［
%却下された ~EQ ~T
］
⇒
~RET
◎
If rejected is true, abort these steps.
</li>
			<li>
%却下された ~SET ~T
◎
Set rejected to true.
</li>
			<li>
%失敗~手続き( %arg )
◎
Perform failureSteps given arg.
</li>
		</ol>
	</li>
	<li>
%却下~handler ~LET
~NOABRUPT `CreateBuiltinFunction$A( %却下~handler手続き, « » )
◎
Let rejectionHandler be ! CreateBuiltinFunction(rejectionHandlerSteps, « »):
</li>
	<li>
%合計 ~LET %~promiseたち の`~size$
◎
Let total be promises’s size.
</li>
	<li>
<p>
~IF［
%合計 ~EQ 0
］：
◎
If total is 0, then:
</p>
		<ol>
			<li>
次を遂行する`小taskを~queueする$
⇒
%成功~手続き( « » )
◎
Queue a microtask to perform successSteps given « ».
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
%結果 ~LET %合計 個の `null^V 値たちからなる`~list$
◎
Let result be a list containing total null values.
</li>
	<li>
<p>
%~promiseたち を成す
~EACH( %~promise )
に対し：
◎
For each promise of promises:
</p>
		<ol>
			<li>
%~promise~index ~LET %~index
◎
Let promiseIndex be index.
</li>
			<li>
<p>
%充足~handler ~LET 所与の引数 ( %arg ) に対し次を走らす手続き：
◎
Let fulfillmentHandler be the following steps given arg:
</p>
				<ol>
					<li>
%結果[ %~promise~index ] ~SET %arg
◎
Set result[promiseIndex] to arg.
</li>
					<li>
%充足-回数 ~INCBY 1
◎
Set fullfilledCount to fullfilledCount + 1.
</li>
					<li>
~IF［
%充足-回数 ~EQ %合計
］
⇒
%成功~手続き( %結果 )
◎
If fullfilledCount equals total, then perform successSteps given result.
</li>
				</ol>
			</li>
			<li>
%充足~handler ~LET
~NOABRUPT `CreateBuiltinFunction$A( %充足~handler, « » )
◎
Let fulfillmentHandler be ! CreateBuiltinFunction(fulfillmentHandler, « »):
</li>
			<li>
`PerformPromiseThen$A( %~promise, %充足~handler, %却下~handler )
◎
Perform PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler).
</li>
			<li>
%~index ~INCBY 1
◎
Set index to index + 1.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">

<p>
`すべてを待機する~promiseを取得する@
ときは、所与の
( `~promise_T$ 値たちが成す`~list$ %~promiseたち, `~Realm$ %~realm )
に対し，次の手続きを遂行する：
◎
To get a promise for waiting for all with a list of Promise&lt;T&gt; values promises and a Realm realm, perform the following steps:
</p>

<ol>
	<li>
%~promise ~LET 
型 <code>`Promise$T&lt;`~sequence_T$&gt;</code>
の`新たな~promise$を %~realm 内に作成する
◎
Let promise be a new promise of type Promise&lt;sequence&lt;T&gt;&gt; in realm.
</li>
	<li>
%成功~手続き ~LET 所与の引数 ( %結果たち ) に対し次を走らす手続き
⇒
%結果たち で %~promise を`解決する$
◎
Let successSteps be the following steps, given results:
• Resolve promise with results.
</li>
	<li>
%失敗~手続き ~LET 所与の引数 ( %事由 ) に対し次を走らす手続き
⇒
%事由 で %~promise を`却下する$
◎
Let failureSteps be the following steps, given reason:
• Reject promise with reason.
</li>
	<li>
`すべての~promiseを待機する$( %~promiseたち, %成功~手続き, %失敗~手続き )
◎
Wait for all with promises, given successSteps and failureSteps.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<p>
この句は、複数個の~promiseの結果を集成して，それらから別の~promiseを生産したいと望むときに有用になる
— ~JS~code用の `Promise.all()$c 関数と同じ仕方で。
◎
This phrase is useful when you wish to aggregate the results of multiple promises, and then produce another promise from them, in the same way that Promise.all() functions for JavaScript code.
</p>

				</section>
				<section id="es-promise-examples">
<h5 title="Examples">3.2.22.2. 例</h5>

<div class="example" id="promise-example-delay">

<p>
`delay^c は、ある~ms数後に充足される~promiseを返す`演算$である。
それは、~promiseの解決は，単純に 1 行lの注釈文で記せることを~illustrateする：
◎
delay is an operation that returns a promise that will be fulfilled in a number of milliseconds. It illustrates how simply you can resolve a promise, with one line of prose.
</p>

<pre class="webidl">
interface I {
  Promise&lt;void&gt; delay(unrestricted double ms);
};
</pre>

<div class="algorithm">

<p>
<code>delay(%ms)</code>
~meth手続きは：
◎
The delay(ms) method steps are:
</p>

<ol>
	<li>
%~realm ~LET `this^V に`関連な~Realm$
◎
Let realm be this’s relevant Realm.
</li>
	<li>
%ms ~SET ［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ %ms ~LT `+0^jv ならば `+0^jv ／
~ELSE_ %ms
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET `新たな~promise$を %~realm 内に作成する
◎
Let p be a new promise in realm.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
			<li>
%p を`解決する$
◎
Resolve p.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol></div>
</div>

<div class="example" id="promise-example-validatedDelay">

<p>
`validatedDelay()^c `演算$は、引数を検証することを除いて，
<a href="#promise-example-delay">`delay^c 関数</a>
とほぼ同様になる。
これは、［
非同期な演算を開始する前であっても，即時な失敗を通達する
］ために，却下される~promiseを利用する方法を示す。
◎
The validatedDelay operation is much like the delay function, except it will validate its arguments. This shows how to use rejected promises to signal immediate failure before even starting any asynchronous operations.
</p>

<pre class="webidl">
interface I {
  Promise&lt;void&gt; validatedDelay(unrestricted double ms);
};
</pre>

<div class="algorithm">

<p>
<code>validatedDelay(%ms)</code>
~meth手続きは：
◎
The validatedDelay(ms) method steps are:
</p>

<ol>
	<li>
%~realm ~LET `this^V に`関連な~Realm$
◎
Let realm be this’s relevant Realm.
</li>
	<li>
~IF［
%ms ~EQ `NaN^jv
］
⇒
~RET `TypeError$jE で`却下される~promise$を %~realm 内に作成する
◎
If ms is NaN, return a promise rejected with a TypeError in realm.
</li>
	<li>
~IF［
%ms ~LT 0
］
⇒
~RET `RangeError$jE で`却下される~promise$を %~realm 内に作成する
◎
If ms &lt; 0, return a promise rejected with a RangeError in realm.
</li>
	<li>
%p ~LET `新たな~promise$を %~realm 内に作成する
◎
Let p be a new promise in realm.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
			<li>
%p を`解決する$
◎
Resolve p.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>

</div>

<div class="example" id="promise-example-addDelay">

<p>
`addDelay^c は、［
引数 %~promise が決着してから，返される~promiseが決着するまでの間
］に余分な %ms ~msの遅延を追加する`演算$である。
◎
addDelay is an operation that adds an extra number of milliseconds of delay between promise settling and the returned promise settling.
</p>

<pre class="webidl">
interface I {
  Promise&lt;any&gt; addDelay(Promise&lt;any&gt; promise, unrestricted double ms);
};
</pre>

<div class="algorithm">

<p>
<code>addDelay(%ms, %promise)</code>
~meth手続きは：
◎
The addDelay(ms, promise) method steps are:
</p>

<ol>
	<li>
%~realm ~LET `this^V に`関連な~Realm$
◎
Let realm be this’s relevant Realm.
</li>
	<li>
%~task源 ~LET 何らかの適切な`~task源$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
%ms ~SET ［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ %ms ~LT `+0^jv ならば `+0^jv ／
~ELSE_ %ms
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET `新たな~promise$を %~realm 内に作成する
◎
Let p be a new promise in realm.
</li>
	<li>
<p>
%promise に`反応する$：
◎
React to promise:
</p>
		<ul class="switch">
			<li>
<p>
~IF［
%promise は値 %v で充足された
］：
◎
If promise was fulfilled with value v, then:
</p>
				<ol>
					<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
						<ol>
							<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
							<li>
%~task源 から次を走らす`~taskを~queueする$
⇒
%v で %promise を`解決する$
◎
Queue a task to run the following steps on taskSource:
• Resolve promise with v.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%promise は事由 %r で却下された
］：
◎
If promise was rejected with reason r, then:
</p>
				<ol>
					<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
						<ol>
							<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
							<li>
%~task源 から次を走らす`~taskを~queueする$
⇒
%r で %promise を`却下する$
◎
Queue a task to run the following steps on taskSource:
• Reject promise with r.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>
</div>

<div class="example" id="promise-example-environment-ready">

<p>
%環境.`ready^c は、［
ある環境（例：~DOM文書）を成す何らかの部分が “準備済み” になるとき
］を通達する`属性$である。
それは、その環境による非同期性を~~定式化する方法を~illustrateする：
◎
environment.ready is an attribute that signals when some part of some environment, e.g. a DOM document, becomes "ready". It illustrates how to encode environmental asynchronicity.
</p>

<pre class="webidl">
interface Environment {
  readonly attribute Promise&lt;void&gt; ready;
};
</pre>

<p>
どの `Environment^T ~objも
<code>`Promise$T&lt;`void$T&gt;</code>
型の
`準備済み~promise@
を持つモノトスル。
◎
Every Environment object must have a ready promise, which is a Promise&lt;void&gt;.
</p>

<div class="algorithm">

<p>
`ready^c 属性~取得子の手続きは：
◎
The ready attribute getter steps are:
</p>

<ol>
	<li>
~RET `this^V の`準備済み~promise$
◎
Return this’s ready promise.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`~Realm$ %~realm 内で `Environment^T ~objを作成するときは、次の手続きを遂行する：
◎
To create an Environment object in a Realm realm, perform the following steps:
</p>

<ol>
	<li>
%環境 ~LET 
`~ifcを実装する新たな~objを作成する$( `Environment^T, %~realm )
◎
Let environment be new Environment object in realm.
</li>
	<li>
%環境 の`準備済み~promise$ ~SET `新たな~promise$を %~realm 内に作成する
◎
Set environment’s ready promise to a new promise in realm.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
何らかの非同期な作業を行う【加えて，それが完了するまで待機する】
◎
Do some asynchronous work.
</li>
			<li>
~IF［
%環境 は成功裡に準備済みになった
］
⇒
%環境 の`準備済み~promise$を`解決する$
◎
If environment becomes ready successfully, resolve environment’s ready promise.
</li>
			<li>
~ELSE（準備済みにならずに失敗した）
⇒
`NetworkError$E 例外で
%環境 の`準備済み~promise$を`却下する$
◎
If environment fails to become ready, reject environment’s ready promise with a "NetworkError" DOMException.
</li>
		</ol>
	</li>
	<li>
~RET %環境
◎
Return environment.
</li>
</ol>
</div>

</div>

<div class="example" id="promise-example-addBookmark">

<p>
`addBookmark^c は、［
現在の~web~pageを~bookmarkとして追加する
］よう利用者に要請する，`演算$である。
これは、
<a href="https://github.com/domenic/promises-unwrapping/issues/85">何度も行われる設計~作業</a>
から取り出されたものであり、環境による非同時性を，現実にありそうな局面として訴えかけると伴に、即時な却下についても~illustrateするものである。
◎
addBookmark is an operation that requests that the user add the current web page as a bookmark. It’s drawn from some iterative design work and illustrates a more real-world scenario of appealing to environmental asynchrony, as well as immediate rejections.
</p>

<pre class="webidl">
interface I {
  Promise&lt;void&gt; addBookmark();
};
</pre>

<div class="algorithm">

<p>
`addBookmark()^c
~meth手続きは：
◎
The addBookmark() method steps are:
</p>
<ol>
	<li>
~IF［
この~methは明示的な利用者~動作の結果として呼出されていない
］
⇒
~RET `SecurityError$E 例外で`却下される~promise$
◎
If this method was not invoked as a result of explicit user action, return a promise rejected with a "SecurityError" DOMException.
</li>
	<li>
~IF［
文書の “演算~mode” は “自立的” である
］
⇒
~RET `NotSupportedError$E 例外で`却下される~promise$
◎
If the document’s mode of operation is standalone, return a promise rejected with a "NotSupportedError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~metadata ~LET ~web~appの~metadataを取得した結果
◎
Let info be the result of getting a web application’s metadata.
</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
%~metadata を利用して，~UAに特有な［
~bookmarkを追加したいと求めるかどうか選ぶことを，末端利用者に許容する方式
］で：
◎
Using info, and in a manner that is user-agent specific, allow the end user to make a choice as to whether they want to add the bookmark.
</p>
				<ol>
					<li>
~IF［
末端利用者は~bookmarkを追加する要請する中止した（例：~escapeを叩いたか “取消-” ~buttonを押した）
］
⇒
`AbortError$E" 例外で
%~promise を`却下する$
◎
If the end-user aborts the request to add the bookmark (e.g., they hit escape, or press a "cancel" button), reject promise with an "AbortError" DOMException.
</li>
					<li>
~ELSE
⇒
%~promise を`解決する$
◎
Otherwise, resolve promise.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

</div>

<div class="example" id="promise-example-batchRequest">

<p>
`SERVICE-WORKERS$r は、何箇所かで，`すべてを待機する~promiseを取得する$を利用している。
`batchRequest^c は、その種のある利用を単純~化した~versionを~illustrateする。
それは、一連の~URLが成す `~sequence_T$ を入力にとり，［
各~URLを~fetchして作成された `Response$T ~objたちが成す `~sequence_T$
］用の~promiseを返す。
いずれかの~fetchが失敗した場合、その失敗で`却下される~promise$を返すことになる。
◎
Several places in [SERVICE-WORKERS] use get a promise to wait for all. batchRequest illustrates a simplified version of one of their uses. It takes as input a sequence of URLs, and returns a promise for a sequence of Response objects created by fetching the corresponding URL. If any of the fetches fail, it will return a promise rejected with that failure.
</p>

<pre class="webidl">
interface I {
  Promise&lt;sequence&lt;Response&gt;&gt; batchRequest(sequence&lt;USVString&gt; urls);
};
</pre>

<div class="algorithm">

<p>
<code>batchRequest(%urls)</code>
~meth手続きは：
◎
The batchRequest(urls) method steps are:
</p>

<ol>
	<li>
%応答~promiseたち ~LET  « »
◎
Let responsePromises be « ».
</li>
	<li>
<p>
%urls を成す
~EACH( %url )
に対し：
◎
For each url of urls:
</p>
		<ol>
			<li>
%p ~LET 
%url で `fetch()$M ~callした結果
◎
Let p be the result of calling fetch() with url.
</li>
			<li>
%応答~promiseたち に %p を`付加する$
◎
Append p to responsePromises.
</li>
		</ol>
	</li>
	<li>
%p ~LET `すべてを待機する~promiseを取得する$( %応答~promiseたち )
◎
Let p be the result of getting a promise to wait for all with responsePromises.
</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>

</div>

				</section>
			</section>
			<section id="es-union">
<h4 title="Union types">3.2.23. 共用体~型</h4>

<p>
~IDL`共用体~型$の値は、共用体の`~mb型$に対応する~ES値により表現される。
◎
IDL union type values are represented by ECMAScript values that correspond to the union’s member types.
</p>

<div class="algorithm">
<p id="es-to-union">
次の~algoにより，~ES値 %V は `共用体~型$ %U の`~IDL値に変換-$される：
◎
To convert an ECMAScript value V to an IDL union type value is done as follows:
</p>

<ol>
	<li>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%U は`~nullable型を内包する$
］
⇒
~RET ~IDL値 `null^V
◎
If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
</li>
	<li>
%型たち ~LET %U の`平坦~化~mb型$
◎
Let types be the flattened member types of the union type.
</li>
	<li>
<p>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］：
◎
If V is null or undefined, then:
</p>
		<ol>
			<li>
~IF［
%型たち に`辞書~型$が含まれている
］
⇒
~RET %V をその辞書~型の`~IDL値に変換-$した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `~platform~objである$
］：
◎
If V is a platform object, then:
</p>
		<ol>
			<li>
~IF［
%型たち に %V が`実装-$する`~ifc型$が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</li>
			<li id="cp-object-in-types">
~IF［
%型たち に `object$T が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes object, then return the IDL value that is a reference to the object V.
</li>
		</ol>
	</li>
	<li>
%型 ~LET `Type$A( %V )
◎
↓</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
］~AND［
%V は `ArrayBufferData^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に `ArrayBuffer$T が含まれている
］
⇒
~RET %V を `ArrayBuffer$T 型の`~IDL値に変換-$した結果
◎
If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
］~AND［
%V は `DataView^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has a [[DataView]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に `DataView$T が含まれている
］
⇒
~RET %V を `DataView$T 型の`~IDL値に変換-$した結果
◎
If types includes DataView, then return the result of converting V to DataView.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
］~AND［
%V は `TypedArrayName^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に［
`有型~配列~型$であって，［
その型~名【！＊名前】 ~EQ %V の `TypedArrayName^sl `内部~slot$の値
］なるもの
］が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
`IsCallable$A( %V ) ~EQ ~T
］：
◎
If IsCallable(V) is true, then:
</p>
		<ol>
			<li>
~IF［
%型たち に`~callback関数$型が含まれている
］
⇒
~RET %V をその~callback関数~型の`~IDL値に変換-$した結果
◎
If types includes a callback function type, then return the result of converting V to that callback function type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
］：
◎
If Type(V) is Object, then:
</p>
		<ol>
			<li>
<p>
~IF［
%型たち に`連列~型$が含まれている
］：
◎
If types includes a sequence type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%method ~NEQ `undefined^jv
］
⇒
~RET
( %V, %method )
から
その型の`連列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a sequence of that type from V and method.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%型たち に`凍結d配列~型$が含まれている
］：
◎
If types includes a frozen array type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%method ~NEQ `undefined^jv
］
⇒
~RET
( %V, %method )
から
その型の`凍結d配列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a frozen array of that type from V and method.
</li>
				</ol>
			</li>
			<li>
~IF［
%型たち に`辞書~型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
			<li>
~IF［
%型たち に`~record型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a record type, then return the result of converting V to that record type.
</li>
			<li>
~IF［
%型たち に`~callback~ifc型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a callback interface type, then return the result of converting V to that callback interface type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Boolean^jt
］：
◎
If Type(V) is Boolean, then:
</p>
		<ol>
			<li id="cp-boolean-in-types">
~IF［
%型たち に `boolean$T が含まれている
］
⇒
~RET %V を `boolean$T 型の`~IDL値に変換-$した結果
◎
If types includes a boolean, then return the result of converting V to boolean.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Number^jt
］：
◎
If Type(V) is Number, then:
</p>
		<ol>
			<li id="cp-numeric-in-types">
~IF［
%型たち に`数量-型$が含まれている
］
⇒
~RET %V をその`数量-型$の`~IDL値に変換-$した結果
◎
If types includes a numeric type, then return the result of converting V to that numeric type.
</li>
		</ol>
	</li>
	<li>
~IF［
%型たち に`文字列~型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a string type, then return the result of converting V to that type.
</li>
	<!--cp-numeric-in-types-->
	<!--cp-boolean-in-types-->
	<!--cp-throw-typeerror-->
</ol>
</div>

<p id="union-to-es">
~IDL共用体~型の値 %U は，次に従って`~ES値に変換-$される：
◎
An IDL union type value is converted to an ECMAScript value as follows.＼
</p>

<ul>
	<li>
%U が［
~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
］ならば、~ES `undefined^jv 値に変換される。
◎
If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value.＼
</li>
	<li>
他の場合、この`es-type-mapping$secにて述べている， %U の`特有~型$を変換するための規則に従う。
◎
Otherwise, the rules for converting the specific type of the IDL union type value as described in this section (§ 3.2 ECMAScript type mapping).
</li>
</ul>

			</section>
			<section id="es-buffer-source-types">
<h4 title="Buffer source types">3.2.24. ~buffer~source型</h4>

<p>
~IDL`~buffer~source型$の値は、対応する~ES~classの~objにより表現され，~ES［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt
］~objに~backされ得るが、後者に~backできるのは，当の型に `AllowShared$x `拡張属性が結付けられ$ている場合に限られる。
◎
Values of the IDL buffer source types are represented by objects of the corresponding ECMAScript class, with the additional restriction that unless the type is associated with the [AllowShared] extended attribute, they can only be backed by ECMAScript ArrayBuffer objects, and not SharedArrayBuffer objects.
</p>

<div class="algorithm">
<p id="es-to-buffer-source">
次の~algoにより，~ES値 %V は `ArrayBuffer$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL ArrayBuffer value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `ArrayBufferData^sl `内部~slot$を持たない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have an [[ArrayBufferData]] internal slot, then throw a TypeError.
</li>
	<li>
~IF［
`AllowShared$x `拡張属性が結付けられ$ている~IDL型への変換でない
］~AND［
`IsSharedArrayBuffer$A( %V ) ~EQ `true^jv
］
⇒
~throwTypeError
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `ArrayBuffer$T 値
◎
Return the IDL ArrayBuffer value that is a reference to the same object as V.
</li>
</ol>
</div>

<div class="algorithm">
<p id="buffer-source-to-es">
次の~algoにより，~ES値 %V は `DataView$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL DataView value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `DataView^sl `内部~slot$を持たない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have a [[DataView]] internal slot, then throw a TypeError.
</li>
	<li id="cp-is-conv-not-AllowShared">
~IF［
`AllowShared$x `拡張属性が結付けられ$ている~IDL型への変換でない
］~AND［
`IsSharedArrayBuffer$A( %V.`ViewedArrayBuffer^sl ) ~EQ `true^jv
］
⇒
~throwTypeError
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DataView$T 値
◎
Return the IDL DataView value that is a reference to the same object as V.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%T をいずれかの`有型~配列~型$とするとき、次の~algoにより，~ES値 %V は %T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array or Float64Array value by running the following algorithm:
</p>

<ol>
	<li>
%有型~配列~名 ~LET ［
%T は`注釈付きの型$であるならば %T の`内縁~型$anOの`型~名$ ／
~ELSE_ %T の`型~名$
］
◎
Let T be the IDL type V is being converted to.
◎
Let typedArrayName be the name of T’s inner type if T is an annotated type, or the name of T otherwise.
</li>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `TypedArrayName^sl `内部~slot$を持たない
］~OR［
%V の `TypedArrayName^sl `内部~slot$の値 ~NEQ %有型~配列~名
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have a [[TypedArrayName]] internal slot with a value equal to typedArrayName, then throw a TypeError.
</li>
	<!--cp-is-conv-not-AllowShared-->
	<li>
~RET %V と同じ~objへの参照である~IDL %T 型~値
◎
Return the IDL value of type T that is a reference to the same object as V.
</li>
</ol>
</div>

<p>
いずれの`~buffer~source型$に対しても、その型の~IDL値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL value of any buffer source type to an ECMAScript value is the Object value that represents a reference to the same object that the IDL value represents.
</p>

<div class="algorithm">
<p>
~buffer~source %O は［
~ES［
`ArrayBuffer$jt ／ `DataView$jt
］ ／
`有型~配列~型$
］~objであるとする。
%O に保持されている~byte列の`参照／複製を取得-$するときは、次の手続きに従うモノトスル：
◎
When getting a reference to or getting a copy of the bytes held by a buffer source that is an ECMAScript ArrayBuffer, DataView or typed array object, these steps must be followed:
</p>

<ol>
	<li>
%arrayBuffer ~LET %O
◎
Let O be the ECMAScript object that is the buffer source.
◎
Initialize arrayBuffer to O.
</li>
	<li>
%offset ~LET 0
◎
Initialize offset to 0.
</li>
	<li>
%長さ ~LET 0
◎
Initialize length to 0.
</li>
	<li>

<p>
~IF［
%O は `ViewedArrayBuffer^sl `内部~slot$を持つ
］：
◎
If O has a [[ViewedArrayBuffer]] internal slot, then:
</p>
		<ol>
			<li>
%arrayBuffer ~SET
%O の `ViewedArrayBuffer^sl `内部~slot$の値
◎
Set arrayBuffer to the value of O’s [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
%offset ~SET
%O の `ByteOffset^sl `内部~slot$の値
◎
Set offset to the value of O’s [[ByteOffset]] internal slot.
</li>
			<li>
%長さ ~SET
%O の `ByteLength^sl `内部~slot$の値
◎
Set length to the value of O’s [[ByteLength]] internal slot.
</li>
		</ol>
	</li>
	<li>
~ELSE
%長さ ~SET
%O の `ArrayBufferByteLength^sl `内部~slot$の値
◎
Otherwise, set length to the value of O’s [[ArrayBufferByteLength]] internal slot.
</li>
	<li>
~IF［
`IsDetachedBuffer$A( %arrayBuffer )
］
⇒
~RET 空の~byte列
◎
If IsDetachedBuffer(arrayBuffer) is true, then return the empty byte sequence.
</li>
	<li>
%data ~LET
%O の `ArrayBufferData^sl `内部~slot$の値
◎
Let data be the value of O’s [[ArrayBufferData]] internal slot.
</li>
	<li>
~RET ［
%data 内の~byte~offset %offset の所から， %長さ 個の~byte
］［
への参照, または の複製
］（いずれか要求された方）
◎
Return a reference to or copy of (as required) the length bytes in data starting at byte offset offset.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`ArrayBuffer$T ~objを
`切離す@
ときは、次の手続きに従うモノトスル：
◎
To detach an ArrayBuffer, these steps must be followed:
</p>

<ol>
	<li>
%O ~LET その `ArrayBuffer$T である~ES~obj
◎
Let O be the ECMAScript object that is the ArrayBuffer.
</li>
	<li>
~NOABRUPT `DetachArrayBuffer$A( %O )
◎
Perform ! DetachArrayBuffer(O).
</li>
</ol>
</div>

			</section>
			<section id="es-frozen-array">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">3.2.25. 凍結d配列 — ~FrozenArray_T</h4>

<p>
`凍結d配列~型$の値は、~~凍結された（ `frozen^en ）~ES `Array^jt ~obj参照により表現される。
◎
Values of frozen array types are represented by frozen ECMAScript Array object references.
</p>

<div class="algorithm">
<p>
次の~algoにより，~ES値 %V は `~FrozenArray_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL FrozenArray&lt;T&gt; value by running the following algorithm:
</p>

<ol>
	<li>
%値~list ~LET %V を ~sequence_T 型の`~IDL値に変換-$した結果
◎
Let values be the result of converting V to IDL type sequence&lt;T&gt;.
</li>
	<li>
~RET `凍結d配列を作成する$( %値~list )
◎
Return the result of creating a frozen array from values.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`凍結d配列を作成する@
ときは、所与の
( 型 %T の値の連列 %S )
に対し，次の手続きに従う：
◎
To create a frozen array from a sequence of values of type T, follow these steps:
</p>

<ol>
	<li>
%array ~LET %S を`~ES値に変換-$した結果
◎
Let array be the result of converting the sequence of values of type T to an ECMAScript value.
</li>
	<li>
`SetIntegrityLevel$A( %array, `frozen^l )
◎
Perform SetIntegrityLevel(array, "frozen").
</li>
	<li>
~RET %array
◎
Return array.
</li>
</ol>
</div>

<p>
~IDL `~FrozenArray_T$ 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL FrozenArray&lt;T&gt; value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL FrozenArray&lt;T&gt; represents.
</p>

				<section id="create-frozen-array-from-iterable">
<h5 title="Creating a frozen array from an iterable">3.2.25.1. 可反復から凍結d配列を作成する</h5>

<div class="algorithm">
<p>
所与の
( 可反復 %可反復, 反復子~取得子 %method )
から
型 `~FrozenArray_T$ の~IDL値を作成するときは、次の手続きを遂行する：
◎
To create an IDL value of type FrozenArray&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol>
	<li>
%値~list ~LET
( %可反復, %method )
から
型 %T の`連列~値を作成-$した結果
◎
Let values be the result of creating a sequence of type sequence&lt;T&gt; from iterable and method.
</li>
	<li>
~RET `凍結d配列を作成する$( %値~list )
◎
Return the result of creating a frozen array from values.
</li>
</ol>
</div>

				</section>
			</section>
		</section>
		<section id="es-extended-attributes">
<h3 title="ECMAScript-specific extended attributes">3.3. ~ESに特有な拡張属性</h3>

<p>
この節では、その存在pが~ES言語束縛にのみ影響する，いくつかの`拡張属性$を定義する。
◎
This section defines a number of extended attributes whose presence affects only the ECMAScript binding.
</p>

			<section id="AllowShared">
<h4>3.3.1. `AllowShared^x</h4>

<p>
`AllowShared$x `拡張属性$が`~buffer~source型$に現れた場合、その型の値は
— 共有されない `ArrayBuffer$jt のみならず —
~ES `SharedArrayBuffer$jt にも~backできるような，新たな~IDL型を作成する。
【~back — 下層の~dataを保持しておく】
◎
If the [AllowShared] extended attribute appears on one of the buffer source types, it creates a new IDL type that allows the buffer source type to be backed by an ECMAScript SharedArrayBuffer, instead of only by a non-shared ArrayBuffer.
</p>

<p>
`AllowShared$x 拡張属性は、`引数をとらない$ことが要求される。
◎
The [AllowShared] extended attribute must take no arguments.
</p>

<p>
`~buffer~source型$でない型に `AllowShared$x `拡張属性が結付けられ$てはナラナイ。
◎
A type that is not a buffer source type must not be associated with the [AllowShared] extended attribute.
</p>

<p>
`AllowShared$x の利用に課される特有な要件については、
`es-buffer-source-types$secの［
~ES値から~IDL`~buffer~source型$へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to IDL buffer source types in § 3.2.24 Buffer source types for the specific requirements that the use of [AllowShared] entails.
</p>

<div class="example">

<p>
次の`~IDL片$においては、一方の演算は 引数 %pixels に `AllowShared$x 拡張属性を利用し，他方はそうでない：
◎
In the following IDL fragment, one operation’s argument uses the [AllowShared] extended attribute, while the other does not:
</p>

<pre class="webidl">
[Exposed=Window]
interface RenderingContext {
  void readPixels(long %width, long %height, BufferSource %pixels);
  void readPixelsShared(long %width, long %height, [AllowShared] BufferSource %pixels);
};
</pre>

<p>
この定義の下で `readPixels^M に対し［
`SharedArrayBuffer$jt ~instance ／
何らかに~backされた ［
有型~配列 ／ `DataView$jt
］］を伴わせて~callした場合、 `TypeError$jt 例外が投出されることになる。
対照的に， `readPixelsShared^M は、そのような~objを入力として許容する。
◎
With this definition, a call to readPixels with an SharedArrayBuffer instance, or any typed array or DataView backed by one, will throw a TypeError exception. In contrast, a call to readPixelsShared will allow such objects as input.
</p>
</div>

			</section>
			<section id="Clamp">
<h4>3.3.2. `Clamp^x</h4>

<p>
`Clamp$x `拡張属性$が`整数~型$に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `Number^jt 値がこの~IDL型へ変換される際には、範囲~外の値に対しては，範囲~内の最も近い妥当な値に切詰める
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [Clamp] extended attribute appears on one of the integer types, it creates a new IDL type such that that when an ECMAScript Number is converted to the IDL type, out-of-range values will be clamped to the range of valid values, rather than using the operators that use a modulo operation (ToInt32, ToUint32, etc.).
</p>

<p>
`Clamp$x 拡張属性には、`引数をとらない$ことが要求される。
◎
The [Clamp] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `Clamp$x `拡張属性が結付けられ$るときは、次のすべてを満たさなければナラナイ：
</p>

<ul ><li>%T は、`読専$な属性に現れていない。
</li><li>%T には `EnforceRange$x `拡張属性が結付けられ$てはいない。
</li><li>%T は`整数~型$である。
</li></ul>

◎
A type annotated with the [Clamp] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [Clamp] extended attribute.
</div>

<p>
`Clamp$x の利用に課される特有な要件については、
`es-integer-types$secの［
~ES値から各種~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to the various IDL integer types in § 3.2.4 Integer types for the specific requirements that the use of [Clamp] entails.
</p>

<div class="example">
<p>
次の`~IDL片$では，それぞれが 3 個の `octet$T 引数をとる， 2 個の`演算$が宣言される。
一方には 3 個すべての引数に `Clamp$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [Clamp] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
[Exposed=Window]
interface GraphicsContext {
  void setColor(octet %red, octet %green, octet %blue);
  void setColorClamped([Clamp] octet %red, [Clamp] octet %green, [Clamp] octet %blue);
};
</pre>

<p>
`setColorClamped^M の~callに渡された，
`octet$T の範囲~外の `Number^jt 値は、範囲 [0, 255] に切詰められる。
◎
A call to setColorClamped with Number values that are out of range for an octet are clamped to the range [0, 255].
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する：
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment">
非 `Clamp^x 版の~callは、数量-値を~octetに強制する ToUint8 を利用する：
◎
Calling the non-[Clamp] version uses ToUint8 to coerce the Numbers to octets
</span> */
/* <span class="comment">
次は `setColor(255, 255, 1)^c の~callと等価：
◎
This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
範囲~外の値を渡して `setColorClamped^M を~callする：
◎
Call setColorClamped with some out of range values.
</span> */
/* <span class="comment">
次は `setColorClamped(0, 255, 255)^c の~callと等価：
◎
This is equivalent to calling setColorClamped(0, 255, 255).
</span> */
%context.setColorClamped(-1, 255, 257);
</pre>
</div>
			</section>
			<section id="Default">
<h4>3.3.3. `Default^x</h4>

<p>
`Default$x `拡張属性$が`正則~演算$上に現れた場合、［
その演算が呼出されたときは、`対応する既定の演算$に述べられる手続きを行うモノトスル
］ことを指示する。
◎
If the [Default] extended attribute appears on a regular operation, then it indicates that steps described in the corresponding default operation must be carried out when the operation is invoked.
</p>

<p>
`Default$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Default] extended attribute must take no arguments.
</li>
	<li>
次のもの以外に利用されてはナラナイ
⇒
`正則~演算$であって，`対応する既定の演算$が定義されているもの
◎
The [Default] extended attribute must not be used on anything other than a regular operation for which a corresponding default operation has been defined.
</li>
</ul>

<div class="example">

<p>
例として、 `Default$x 拡張属性は，~toJSON`正則~演算$の利用に相応しくなる：
◎
As an example, the [Default] extended attribute is suitable for use on toJSON regular operations:
</p>

<pre class="webidl">
[Exposed=Window]
interface Animal {
  attribute DOMString name;
  attribute unsigned short age;
  [Default] object toJSON();
};

[Exposed=Window]
interface Human : Animal {
  attribute Dog? pet;
  [Default] object toJSON();
};

[Exposed=Window]
interface Dog : Animal {
  attribute DOMString? breed;
};
</pre>

<p>
~ES言語束縛においては、
`toJSON()^M ~methは，
`Animal^T, `Human^T
~obj上に, および
継承を介して `Dog^T ~obj上にも存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON() method on Animal, Human, and (via inheritance) Dog objects:
</p>

<pre class="es-code">
/* <span class="comment">
`Human^T の~instanceを取得する：
◎
Get an instance of Human.
</span> */
var %alice = getHuman();

/* <span class="comment">
次の様な~objに評価される（この時点で， `Dog^T の~instanceは依然として `pet^l を保持することに注意）：
◎
Evaluates to an object like this (notice how "pet" still holds an instance of Dog at this point):
</span>
   {
     name: "Alice",
     age: 59,
     pet: Dog
   }
*/
%alice.toJSON();

/* <span class="comment">
次の様な~objに評価される（ `Dog^T ~ifcは既定の~toJSON演算を宣言していないので， `breed^l は~~不在になることに注意）：
◎
Evaluates to an object like this (notice how "breed" is absent, as the Dog interface doesn’t declare a default toJSON operation):
</span>
   {
     name: "Tramp",
     age: 6
   }
*/
%alice.pet.toJSON();

/* <span class="comment">
次の様な文字列に評価される：
◎
Evaluates to a string like this:
</span>
   '{"name":"Alice","age":59,"pet":{"name":"Tramp","age":6}}'
*/
JSON.stringify(%alice);
</pre>

</div>

			</section>
			<section id="EnforceRange">
<h4>3.3.4. `EnforceRange^x</h4>

<p>
`EnforceRange$x `拡張属性$が`整数~型$に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `Number^jt 値をこの~IDL型へ変換する際には、
0 側に丸めた結果が範囲~外になる値に対しては，例外を投出する
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [EnforceRange] extended attribute appears on one of the integer types, it creates a new IDL type such that that when an ECMAScript Number is converted to the IDL type, out-of-range values will cause an exception to be thrown, rather than being converted to a valid value using using the operators that use a modulo operation (ToInt32, ToUint32, etc.). The Number will be rounded toward zero before being checked against its range.
</p>

<p>
`EnforceRange$x 拡張属性には、`引数をとらない$ことが要求される。
◎
The [EnforceRange] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `EnforceRange$x `拡張属性が結付けられ$るときは、次のすべてが満たされなければナラナイ：
</p>

<ul ><li>%T は、`読専$な属性に現れていない。
</li><li>%T には `Clamp$x `拡張属性が結付けられ$ていない。
</li><li>%T は`整数~型$である。
</li></ul>

◎
A type annotated with the [EnforceRange] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [EnforceRange] extended attribute.
</div>

<p>
`EnforceRange$x の利用に課される特有な要件については、
`es-type-mapping$secの［
~ES値から各種~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to the various IDL integer types in § 3.2 ECMAScript type mapping for the specific requirements that the use of [EnforceRange] entails.
</p>

<div class="example">
<p>
次の`~IDL片$では，それぞれが 3 個の `octet$T 引数をとる， 2 個の`演算$が宣言される。
一方には 3 個すべての引数に `EnforceRange$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [EnforceRange] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
[Exposed=Window]
interface GraphicsContext {
  void setColor(octet %red, octet %green, octet %blue);
  void setColorEnforcedRange([EnforceRange] octet %red, [EnforceRange] octet %green, [EnforceRange] octet %blue);
};
</pre>

<p>
この~IDLの~ES実装においては、
`octet$T の範囲~外の `Number^jt 値を渡して
`setColorEnforcedRange^M を~callしたときの結果は、例外の投出になる。
◎
In an ECMAScript implementation of the IDL, a call to setColorEnforcedRange with Number values that are out of range for an octet will result in an exception being thrown.
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する：
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment">
非 `EnforceRange^x 版の~callは、数量-値を~octetに強制する ToUint8 を利用する。
次は、
`setColor(255, 255, 1)^c
の~callと等価になる：
◎
Calling the non-[EnforceRange] version uses ToUint8 to coerce the Numbers to octets. This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
数量-値は `setColorEnforcedRange^M が~callされる際に 0 側に丸められる。
次は、
`setColor(0, 255, 255)^c
の~callと等価になる：
◎
When setColorEnforcedRange is called, Numbers are rounded towards zero. This is equivalent to calling setColor(0, 255, 255).
</span> */
%context.setColorEnforcedRange(-0.9, 255, 255.2);

/* <span class="comment">
次は、 `TypeError^jE を投出させる
— 丸められた後でも， 1 個目, 3 個目の引数は範囲~外になるので：
◎
The following will cause a TypeError to be thrown, since even after rounding the first and third argument values are out of range.
</span> */
%context.setColorEnforcedRange(-1, 255, 256);
</pre>
</div>

			</section>
			<section id="Exposed">
<h4>3.3.5. `Exposed^x</h4>

<p>
`Exposed$x `拡張属性$が，次に挙げる構成子に現れたときは、［
その構成子を［
拡張属性の引数により指定される，大域~ifc【 `Global$x が指定された~ifc】の集合
］上に公開される
］ことを指示する
⇒＃
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`~callback~ifc$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$ ／
個々の`~ifc~mb$ ／
個々の`~ifc~mixin~mb$ ／
個々の`~ns~mb$
◎
When the [Exposed] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, callback interface, namespace, partial namespace, or an individual interface member, interface mixin member, or namespace member, it indicates that the construct is exposed on that particular set of global interfaces.
</p>

<p>
`Exposed$x `拡張属性$には、［
`識別子を引数にとる$か, または
`識別子~listを引数にとる$
］ことが要求される。
挙げられた各~識別子は、引数~内で一意, かつ`大域~名$でなければナラナイ。
これらの識別子が成す~listは、当の構成子の
`自前の公開~集合@
と呼ばれる。
◎
The [Exposed] extended attribute must either take an identifier or take an identifier list. Each of the identifiers mentioned must be a global name and be unique. This list of identifiers is known as the construct’s own exposure set.
</p>

<div class="algorithm">
<p>
所与の構成子 %C の
`公開~集合@
を取得するときは、次の手続きを走らす：
◎
To get the exposure set of a construct C, run the following steps:
</p>

<ol>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$ ／ `~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である。
◎
Assert: C is an interface, callback interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%C は`~ifc~mixin~mb$ならば %C の`~host~ifc$ ／
~ELSE_ ε
］
◎
Let H be C’s host interface if C is an interface mixin member, or null otherwise.
</li>
	<li>
%E ~LET ［
%H ~NEQ ε ならば %H の`公開~集合$ ／
~ELSE_ すべての大域~ifcからなる集合
］
◎
↓</li>
	<li>
<p>
~IF［
%C は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If C is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
◎
If the [Exposed] extended attribute is specified on C, then:
• If H is set, return the intersection of C’s own exposure set and H’s exposure set.
• Otherwise, return C’s own exposure set.
</li>
			<li>
%C ~SET
%C を宣言している［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$
］
◎
Otherwise, set C to be the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace C is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］である
］：
◎
If C is a partial interface, partial interface mixin, or partial namespace, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
］
◎
If the [Exposed] extended attribute is specified on C, then:
• If H is set, return the intersection of C’s own exposure set and H’s exposure set.
• Otherwise, return C’s own exposure set.
</li>
			<li>
%C ~SET %C の元の［
`~ifc$ ／ `~ifc~mixin$ ／ `~ns$
］定義
◎
Otherwise, set C to be the original interface, interface mixin, or namespace definition of C.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は`~ifc~mixin$である
］：
◎
If C is an interface mixin, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
◎
If the [Exposed] extended attribute is specified on C, then return the intersection of C’s own exposure set and H’s exposure set.
</li>
			<li>
%C ~SET %H
◎
Otherwise, set C to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$
］である
◎
Assert: C is an interface, callback interface or namespace.
</li>
	<li>
~Assert：
%C 上に `Exposed$x `拡張属性$は指定されている
◎
Assert: The [Exposed] extended attribute is specified on C.
</li>
	<li>
~RET %C の`自前の公開~集合$
◎
Return C’s own exposure set.
</li>
</ol>
</div>

<p>
`Exposed$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`多重定義$された ある`演算$に現れた場合、その多重定義を成す他のすべての演算にも現れなければナラナイ。
◎
If [Exposed] appears on an overloaded operation, then it must appear identically on all overloads.
</li>
	<li>
<p>
［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］, および それを宣言している［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］定義の両者に指定されてはナラナイ。
◎
The [Exposed] extended attribute must not be specified both on an interface member, interface mixin member, or namespace member, and on the partial interface, partial interface mixin, or partial namespace definition the member is declared on.
</p>

<p class="note">注記：
そのわけは、［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］上に `Exposed$x `拡張属性$を追加することは，その各`~mb$を注釈することの略記だからである。
◎
Note: This is because adding an [Exposed] extended attribute on a partial interface, partial interface mixin, or partial namespace is shorthand for annotating each of its members.
</p>
	</li>
	<li>
［
`部分的~ifc$ ／ `部分的~ns$
］ %A に現れた場合、
%A の`自前の公開~集合$は， %A の元の［
`~ifc$ ／ `~ns$
］の`公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears on a partial interface or partial namespace, then the partial’s own exposure set must be a subset of the exposure set of the partial’s original interface or namespace.
</li>
	<li>
［
`~ifc$ ／ `~ns$
］ %A 上の［
`~ifc~mb$ ／ `~ns~mb$
］ %m に現れた場合、
%m の`公開~集合$は %A の`公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears on an interface or namespace member, then the member's exposure set must be a subset of the exposure set of the interface or namespace it is a member of.
</li>
	<li>
［
`部分的~ifc~mixin$ %A,
%A の元の`~ifc~mixin$ %B
］の両者に現れた場合、
%A の`自前の公開~集合$は %B の`自前の公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears both on a partial interface mixin and its original interface mixin, then the partial interface mixin's own exposure set must be a subset of the interface mixin's own exposure set.
</li>
	<li>
`~ifc~mixin$ %A, 
%A の`~ifc~mixin~mb$ %m
の両者に現れた場合、
%m の`自前の公開~集合$は
%A の`自前の公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears both on an interface mixin member and the interface mixin it is a member of, then the interface mixin members's own exposure set must be a subset of the interface mixin's own exposure set.
</li>
</ul>

<p>
%A が別の~ifc %B を`継承-$しているならば、
%A の`公開~集合$は %B の`公開~集合$の`下位集合$でなければナラナイ。
◎
If an interface X inherits from another interface Y then the exposure set of X must be a subset of the exposure set of Y.
</p>

<p class="note">注記：
`~ifc~mixin$ %M は，互いに異なる`~ifc$に`内包-$され得るので、
%M の`~ifc~mixin~mb$ %m の`公開~集合$は，
%M を`内包-$している`~ifc$
— すなわち， %m の`~host~ifc$ %I —
の関数になり、
%F を %I の`公開~集合$とするならば，次で与えられる
⇒
%m は `Exposed$x `拡張属性$で注釈されているならば  `交差集合$( %m の`自前の公開~集合$, %F ) ／
~ELSE_ %M は `Exposed$x `拡張属性$で注釈されているならば `交差集合$( %M の`自前の公開~集合$, %F ) ／
~ELSE_ %F
◎
Note: As an interface mixin can be included by different interfaces, the exposure set of its members is a function of the interface that includes them. If the interface mixin member, partial interface mixin, or interface mixin is annotated with an [Exposed] extended attribute, then the interface mixin member's exposure set is the intersection of the relevant construct’s own exposure set with the the host interface's exposure set. Otherwise, it is the host interface's exposure set.
</p>

【！ class="algorithm"】
<p>
所与の［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$ ／ `~mb$
］ %構成子 が`~Realm$ %~realm に
`公開されて@
いるとは、次の両者が満たされることを~~意味する：
◎
An interface, callback interface, namespace, or member construct is exposed in a given Realm realm if the following steps return true:
</p>

<ul>
	<li>
ある［
~ifc %I ~IN %構成子 の`公開~集合$
］が在って，
%~realm.`GlobalObject^sl は %I を実装している
</li>
	<li>
<p>
次のいずれかが満たされる：
</p>
		<ul>
			<li>
%構成子 は`~secure文脈~下でなくとも可用$である
</li>
			<li>
%~realm.`GlobalObject^sl に`関連な設定群~obj$は`~secure文脈$である
</li>
		</ul>
◎
If construct is available in both secure and non-secure contexts, then return true.
◎
If the relevant settings object of realm.[[GlobalObject]] is a secure context, then return true.
◎
Otherwise, return false.
</li>
</ul>

<p class="note">注記：
~ES大域~objに`関連な設定群~obj$が`~secure文脈$であるかどうかは，変化し得ないので、実装が %構成子 用の~propを作成するかどうか裁定するのは、`初期~obj$を作成する時点の一度限りになる。
◎
Note: Since it is not possible for the relevant settings object for an ECMAScript global object to change whether it is a secure context or not over time, an implementation’s decision to create properties for an interface or interface member can be made once, at the time the initial objects are created.
</p>

<p>
`Exposed$x の利用に課される特有な要件については、
`es-interfaces$sec,
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec,
`es-iterators$sec
を見よ。
◎
See § 3.6 Interfaces, § 3.6.5 Constants, § 3.6.6 Attributes, § 3.6.7 Operations, and § 3.6.8 Common iterator behavior for the specific requirements that the use of [Exposed] entails.
</p>

<div class="example">
<p>
`Exposed$x に意図されている用途は、［
`~ifc$ ／
`~callback~ifc$ ／
`~ns$ ／
個々の［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］］が可用になるのは［
`~worker＠~WORKERS$href, `Worklet$T, `Window$T
］のうち［
どれ, あるいは どの組合n
］の中に限るかを，制御することである。
◎
[Exposed] is intended to be used to control whether interfaces, callback interfaces, namespaces, or individual interface, mixin or namespace members are available for use in workers, Worklet, Window, or any combination of the above.
</p>

<p>
それが どうやって得られるかを，次の~IDL片に示す：
◎
The following IDL fragment shows how that might be achieved:
</p>

<pre class="webidl">
[Exposed=Window, Global=Window]
interface Window {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`SharedWorkerGlobalScope^T と `DedicatedWorkerGlobalScope^T
の両者に同じ識別子 `Worker^l を利用する
— 両者は `Exposed^x 拡張属性からまとめて指せるようになる：
◎
By using the same identifier Worker for both SharedWorkerGlobalScope and DedicatedWorkerGlobalScope, both can be addressed in an [Exposed] extended attribute at once.
</span> */
[Exposed=Worker, Global=Worker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  /* <!--cp-some-code--> */
};

[Exposed=Worker, Global=Worker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`Dimensions^T は、~main~thread上でも, ~workerの中でも可用になる：
◎
Dimensions is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker)]
interface Dimensions {
  constructor(double %width, double %height)
  readonly attribute double %width;
  readonly attribute double %height;
};

/* <span class="comment">
`WorkerNavigator^T は、~workerの中に限り可用になる
— ~workerの大域~scopeの中で `WorkerNavigator^T を評価したときは~ifc~objを得られる一方で、~main~thread上でそうしたときは `ReferenceError^jE になる：
◎
WorkerNavigator is only available in workers.  Evaluating WorkerNavigator in the global scope of a worker would give you its interface object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
interface WorkerNavigator {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`Node^T は、~main~thread上に限り可用になる
— ~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる：
◎
Node is only available on the main thread.  Evaluating Node in the global scope of a worker would give you a ReferenceError.
</span> */
[Exposed=Window]
interface Node {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`MathUtils^T は、~main~thread上でも, ~workerの中でも可用になる：
◎
MathUtils is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker)]
namespace MathUtils {
  double someComplicatedFunction(double %x, double %y);
};

/* <span class="comment">
`WorkerUtils^T は、~workerの中に限り可用になる
— ~workerの大域~scopeの中で `WorkerUtils^T を評価したときは その~ns~objを得られる一方で、~main~thread上でそうしたときは `ReferenceError^jE になる：
◎
WorkerUtils is only available in workers.  Evaluating WorkerUtils in the global scope of a worker would give you its namespace object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
namespace WorkerUtils {
  void setPriority(double %x);
};

/* <span class="comment">
`NodeUtils^T は、~main~thread上に限り可用になる
— ~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる：
◎
NodeUtils is only available in the main thread.  Evaluating NodeUtils in the global scope of a worker would give you a ReferenceError.
</span> */
[Exposed=Window]
namespace NodeUtils {
  DOMString getAllText(Node %node);
};

</pre>

</div>

			</section>
			<section id="Global">
<h4>3.3.6. `Global^x</h4>

<p>
`Global$x `拡張属性$が `~ifc$上に現れた場合、［
その~ifcを実装している~objは、ある`~Realm$に属する大域~objとして利用できる
］ことを指示する。
また、原型鎖の構造, および［
`~ifc~mb$に対応する~propが原型~obj上に どう反映されるか
］についても、他の~ifcと異なるものになることを指示する。
特定的には：
◎
If the [Global] extended attribute appears on an interface, it indicates that objects implementing this interface can be used as the global object in a Realm, and that the structure of the prototype chain and how properties corresponding to interface members will be reflected on the prototype objects will be different from other interfaces. Specifically:
</p>

<ol>
	<li>
どの`有名~prop$も，~obj自身ではなく,
原型鎖の中の~obj
— `有名~prop~obj$ —
上に公開されることになる。
◎
Any named properties will be exposed on an object in the prototype chain – the named properties object – rather than on the object itself.
</li>
	<li>
`~ifc$からの`~ifc~mb$は、`~ifc原型~obj$上ではなく, ~obj自身の~propに対応することになる。
◎
Interface members from the interface will correspond to properties on the object itself rather than on interface prototype objects.
</li>
</ol>

<div class="note">
<p>
原型鎖の中の~obj上に置かれる有名~propは、変数~宣言とそのままの名前の代入を通して，大域~obj自身の~propにより隠蔽される。
◎
Placing named properties on an object in the prototype chain is done so that variable declarations and bareword assignments will shadow the named property with a property on the global object itself.
</p>

<p>
~ifc~mbに対応する~propを~obj自身の上に置くことは、次の様な，特能を検出するためによく利用される手法が働くことになることを意味する：
【！機能しない？】
◎
Placing properties corresponding to interface members on the object itself will mean that common feature detection methods like the following will work:
</p>

<pre class="es-code">
var %indexedDB = window.indexedDB || window.webkitIndexedDB ||
                window.mozIndexedDB || window.msIndexedDB;

var %requestAnimationFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame || ...;
</pre>

<p>
~ESにおける変数~宣言が取扱われる仕方から，代入が評価される前に隠蔽する変数~propが作成されることになるので、上の~codeでは，
`window.indexedDB^c
と
`window.requestAnimationFrame^c
が `undefined^jv に評価されることになる。
◎
Because of the way variable declarations are handled in ECMAScript, the code above would result in the window.indexedDB and window.requestAnimationFrame evaluating to undefined, as the shadowing variable property would already have been created before the assignment is evaluated.
</p>
</div>

<p>
`Global$x `拡張属性$を利用する`~ifc$ %I に対しては：
◎
If the [Global] extended attribute is used on an interface, then:
</p>

<ul>
	<li>
`有名~prop設定子$は 定義されてはナラナイ。
◎
The interface must not define a named property setter.
</li>
	<li>
［
`有index~prop取得子$／`有index~prop設定子$
］は 定義されてはナラナイ。
◎
The interface must not define indexed property getters or setters.
</li>
	<li>
`構築子~演算$は 定義されてはナラナイ。
◎
The interface must not define a constructor operation.
</li>
	<li>
［
%I, および %I が`継承した~ifcたち$
］は
`OverrideBuiltins$x 拡張属性を伴って宣言されてはナラナイ。
◎
The interface must not also be declared with the [OverrideBuiltins] extended attribute.
◎
The interface must not inherit from another interface with the [OverrideBuiltins] extended attribute.
</li>
	<li>
%I は 他の~ifcは`継承-$してはナラナイ。
◎
Any other interface must not inherit from it.
</li>
	<li>
%I の`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，
%I を成す~ifc定義の中で`有名~prop取得子$を定義する部分を成していなければナラナイ。
◎
If [Global] is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</li>
	<li>
<p>
%I は、同じ`~Realm$内で，複数の~objから実装され得るものであってはナラナイ。
◎
The [Global] extended attribute must not be used on an interface that can have more than one object implementing it in the same Realm.
</p>

<p class="note">注記：
そのわけは、有名~propを公開する`有名~prop~obj$が 原型鎖の中にあるものであり、複数の［
~objの有名~prop
］を，それらの~objを継承する 1 個の~obj上で公開してもイミを成さないからである。
◎
Note: This is because the named properties object, which exposes the named properties, is in the prototype chain, and it would not make sense for more than one object’s named properties to be exposed on an object that all of those objects inherit from.
</p>
	</li>
	<li>
<p>
%I には複数の［
`識別子$が互いに同じ`~mb$
］が在ってはナラナイ。
%I には複数の`文字列化子$が在ってはナラナイ。
%I には複数の［
`可反復~宣言$／`非同期c可反復~宣言$／`~maplike 宣言$／`~setlike 宣言$
］【混在も含む】が在ってはナラナイ。
◎
If an interface is declared with the [Global] extended attribute, then there must not be more than one member across the interface with the same identifier. There also must not be more than one stringifier or more than one iterable declaration, asynchronously iterable declaration, maplike declaration or setlike declaration across those interfaces.
</p>

<p class="note">注記：
そのわけは、~ifcを成す`~mb$すべてが、~ifcを`実装-$する~objに平坦~化されるからである。
◎
Note: This is because all of the members of the interface get flattened down on to the object that implements the interface.
</p>
	</li>
</ul>

<p>
`Global$x 拡張属性は、
1 個~以上の大域~ifcに同じ名前を与えて，
`Exposed$x 拡張属性から参照できるようにするときにも利用できる。
◎
The [Global] extended attribute can also be used to give a name to one or more global interfaces, which can then be referenced by the [Exposed] extended attribute.
</p>

<p>
`Global$x 拡張属性には、［
`識別子を引数にとる$か, または
`識別子~listを引数にとる$
］ことが要求される。
◎
The [Global] extended attribute must either take an identifier or take an identifier list.
</p>

<p>
`Global$x `拡張属性$の宣言に伴われた［
識別子~引数／識別子~list~引数
］は、一連の［
~ifcの
`大域~名@
］を定義する。
◎
The identifier argument or identifier list argument the [Global] extended attribute is declared with define the interface’s global names.
</p>

<p class="note">注記：
識別子~list引数は、 `Exposed$x `拡張属性$の中の単独の名前で，複数の大域~ifcを指せるようにするためにある。
◎
Note: The identifier argument list exists so that more than one global interface can be addressed with a single name in an [Exposed] extended attribute.
</p>

<p>
`有名~prop$における `Global$x の利用に課される特有な要件については、
`named-properties-object$sec
を見よ。
`~ifc~mb$に対応する~propの所在に関する要件については、
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec
を見よ。
◎
See § 3.6.4 Named properties object for the specific requirements that the use of [Global] entails for named properties, and § 3.6.5 Constants, § 3.6.6 Attributes and § 3.6.7 Operations for the requirements relating to the location of properties corresponding to interface members.
</p>

<div class="example">
<p>
`Window^T ~ifcは~frameを `Window^T ~obj上の~propとして公開する。
`Window^T ~objは~ES大域~objとしても~serveするので、有名~propに対する代入や変数~宣言は，新たな値への置換-になる。
属性に対する変数~宣言は、既存の~propを置換する~propを作成しない。
◎
The Window interface exposes frames as properties on the Window object. Since the Window object also serves as the ECMAScript global object, variable declarations or assignments to the named properties will result in them being replaced by the new value. Variable declarations for attributes will not create a property that replaces the existing one.
</p>

<pre class="webidl">
[Exposed=Window, Global]
interface Window {
  getter any (DOMString %name);
  attribute DOMString name; 
   /* <!--cp-some-code--> */
};
</pre>

<p>
次の~HTML文書では、
`Window^T ~obj上の有名~propが隠蔽され，属性に対する~propは同じ名前の変数が宣言されても置換されない：
◎
The following HTML document illustrates how the named properties on the Window object can be shadowed, and how the property for an attribute will not be replaced when declaring a variable of the same name:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
Window 上の変数~宣言と代入
◎
Variable declarations and assignments on Window
</span>&lt;/title&gt;
&lt;iframe name=abc&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
有名~propを隠蔽する
◎
Shadowing named properties
</span> --&gt;
&lt;script&gt;
  window.abc;    /* <span class="comment">
`iframe^c の `Window^T ~objに評価される。
◎
Evaluates to the iframe’s Window object.
</span> */
  %abc = 1;       /* <span class="comment">
有名~propを隠蔽する。
◎
Shadows the named property.
</span> */
  window.abc;    /* <span class="comment" id="cp-eval-1">
`1^jv に評価される。
◎
Evaluates to 1.
</span> */
&lt;/script&gt;

&lt;!-- <span class="comment">
~IDL属性~用の~propは保全される
◎
Preserving properties for IDL attributes
</span> --&gt;
&lt;script&gt;
  Window.prototype.def = 2;         /* <span class="comment">
原型~上に~propを置く。
◎
Places a property on the prototype.
</span> */
  window.hasOwnProperty("length");  /* <!--cp-eval-true--> */

  %length;        /* <!--cp-eval-1--> */
  %def;           /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */
&lt;/script&gt;

&lt;script&gt;
  var %length;    /* <span class="comment">
この変数~宣言は既存の~propに触らない。
◎
Variable declaration leaves existing property.
</span> */
  %length;        /* <!--cp-eval-1--> */
  var %def;       /* <span class="comment">
この変数~宣言は隠蔽する~propを作成する。
◎
Variable declaration creates shadowing property.
</span> */
  %def;           /* <!--cp-eval-undefined--> */
&lt;/script&gt;
</pre>

</div>

			</section>
			<section id="LegacyNamespace">
<h4>3.3.7. `LegacyNamespace^x</h4>

<p class="advisement">
`LegacyNamespace$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
~ifc名は、~nsを利用する代わりに，［
一連の~ifcの識別子を，特定0の接頭辞から開始させるような命名~規約
］により形成できる。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [LegacyNamespace]$fI
した上で論交することを，強く勧める。
◎
The [LegacyNamespace] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Instead, interface names can be formed with a naming convention of starting with a particular prefix for a set of interfaces, as part of the identifier, rather than using a namespace. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p>
`LegacyNamespace$x `拡張属性$が`~ifc$上に現れた場合、［
その~ifc用の`~ifc~obj$は、大域~objの~propとしてではなく，この拡張属性の引数により識別される`~ns$の~propとして作成される
］ことを指示する。
◎
If the [LegacyNamespace] extended attribute appears on an interface, it indicates that the interface object for this interface will not be created as a property of the global object, but rather as a property of the namespace identified by the argument to the extended attribute.
</p>

<p>
`LegacyNamespace$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
ある`~ns$の`識別子を引数にとる$ことが要求される。
◎
The [LegacyNamespace] extended attribute take an identifier. This identifier must be the identifier of a namespace.
</li>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性とともに指定されてはナラナイ。
◎
The [LegacyNamespace] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
</ul>

<p>
~ifcが~ns上にどう公開されるかの詳細は
`namespace-object$sec
を見よ。
◎
See § 3.11.1 Namespace object for details on how an interface is exposed on a namespace.
</p>

<div class="example">
<p>
次の`~IDL片$は、`~ns$, および
その内側に定義されることになる［
`LegacyNamespace$x を利用する`~ifc$
］を定義する：
◎
The following IDL fragment defines a namespace and an interface which uses [LegacyNamespace] to be defined inside of it.
</p>

<pre class="webidl">
[Exposed=Window]【！＊原文抜け】
namespace Foo { };

[LegacyNamespace=Foo]
interface Bar {
  constructor();
};
</pre>

<p>
上の~nsと~ifcの~ES実装においては、構築子 `Bar^M は、次のように~accessできる：
◎
In an ECMAScript implementation of the above namespace and interface, the constructor Bar can be accessed as follows:
</p>

<pre class="es-code">
var %instance = new Foo.Bar();
</pre>

</div>

			</section>
			<section id="LegacyUnenumerableNamedProperties">
<h4>3.3.8. `LegacyUnenumerableNamedProperties^x</h4>

<div class="advisement">
<p>
`LegacyUnenumerableNamedProperties$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [LegacyUnenumerableNamedProperties]$fI
した上で論交することを，強く勧める。
◎
The [LegacyUnenumerableNamedProperties] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LegacyUnenumerableNamedProperties$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`HTMLCollection$T,
`NamedNodeMap$T,
`HTMLAllCollection$T,
`HTMLFormElement$T,
`PluginArray$T,
`MimeTypeArray$T,
`Plugin$T,
`Window$T
◎終
`DOM$r `HTML$r
◎
The [LegacyUnenumerableNamedProperties] extended attribute appears on the following interfaces: HTMLCollection, NamedNodeMap, HTMLAllCollection, HTMLFormElement, PluginArray, MimeTypeArray, Plugin, and Window. [DOM] [HTML]
</small></p>
</div>

<p id="dfn-unenumerable">
`LegacyUnenumerableNamedProperties$x `拡張属性$が［
`有名~propを~support$する`~ifc$
］に現れた場合、［
その~ifc上の すべての有名~propは、列挙-不能である
］ことを指示する。
◎
If the [LegacyUnenumerableNamedProperties] extended attribute appears on a interface that supports named properties, it indicates that all the interface’s named properties are unenumerable.
</p>

<div class="p">
<p>
`LegacyUnenumerableNamedProperties$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れてはナラナイ。
</li><li>当の~ifcのすべての派生~ifcにも適用され、それらには，この拡張属性は指定されてはナラナイ。
</li></ul>

◎
The [LegacyUnenumerableNamedProperties] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter.
◎
If the [LegacyUnenumerableNamedProperties] extended attribute is specified on an interface, then it applies to all its derived interfaces and must not be specified on any of them.
</div>

<p>
`LegacyUnenumerableNamedProperties$x の利用に課される特有な要件については、
`legacy-platform-object-getownproperty$sec
を見よ。
◎
See § 3.8.1 [[GetOwnProperty]] for the specific requirements that the use of [LegacyUnenumerableNamedProperties] entails.
</p>

			</section>
			<section id="LegacyWindowAlias">
<h4>3.3.9. `LegacyWindowAlias^x</h4>

<div class="advisement">
<p>
`LegacyWindowAlias$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [LegacyWindowAlias]$fI
した上で論交することを，強く勧める。
◎
The [LegacyWindowAlias] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LegacyWindowAlias$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`DOMPoint$T,
`DOMRect$T,
`DOMMatrix$T,
`URL$T
◎終
`GEOMETRY$r `URL$r
◎
The [LegacyWindowAlias] extended attribute appears on the following interfaces: DOMPoint, DOMRect, DOMMatrix, and URL. [GEOMETRY] [URL]
</small></p>
</div>

<p>
`LegacyWindowAlias$x `拡張属性$が `~ifc$ %I 上に現れた場合、［
`Window$T `~ifc$は、その拡張属性~内に挙げられた各 `識別子$に対し，
%I 用の`~ifc~obj$を値にとるような~propを持つことになる
］ことを指示する。
◎
If the [LegacyWindowAlias] extended attribute appears on an interface, it indicates that the Window interface will have a property for each identifier mentioned in the extended attribute, whose value is the interface object for the interface.
</p>

<p>
`LegacyWindowAlias$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`識別子を引数にとる$か, または
`識別子~listを引数にとる$ことが要求される。
`=^sym の直後に~~現れる `identifier$g が，各 `LegacyWindowAlias$x の
`識別子@wA
を与える。
◎
The [LegacyWindowAlias] extended attribute must either take an identifier or take an identifier list. The identifiers that occur after the “=” are the [LegacyWindowAlias]'s identifiers.
</li>
	<li>
<p>
次に挙げる識別子は、
`LegacyWindowAlias$x の`識別子$wAとして利用されてはナラナイ：
</p>

<ul ><li>当のまたは別の~ifc上の `LegacyWindowAlias$x 拡張属性に利用されている他の`識別子$wA
</li><li>当のまたは別の~ifc上の `NamedConstructor$x 拡張属性に利用されている`識別子$nC
</li><li>`~ifc~obj$を持つ~ifcの`識別子$
</li><li>`予約-済み識別子$
</li></ul>
◎
Each of the identifiers of [LegacyWindowAlias] must not be the same as one used by a [LegacyWindowAlias] extended attribute on this interface or another interface, must not be the same as the identifier used by a [NamedConstructor] extended attribute on this interface or another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性とともに指定されてはナラナイ。
◎
The [LegacyWindowAlias] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
同じ~ifc上で， `LegacyNamespace$x 拡張属性とともに指定されてはナラナイ。
◎
The [LegacyWindowAlias] and [LegacyNamespace] extended attributes must not be specified on the same interface.
</li>
	<li>
自身の`公開~集合$内に `Window$T `~ifc$を含んでいない~ifcには、指定されてはナラナイ。
◎
The [LegacyWindowAlias] extended attribute must not be specified on an interface that does not include the Window interface in its exposure set.
</li>
	<li>
同じ~ifc上に複数~個 指定されてはナラナイ。
◎
An interface must not have more than one [LegacyWindowAlias] extended attributes specified.
</li>
</ul>

<p>
`LegacyWindowAlias^x がどう実装されるかの詳細は
`es-interfaces$sec
を見よ。
◎
See § 3.6 Interfaces for details on how legacy window aliases are to be implemented.
</p>

<div class="example">

<p>
次の~IDLは
`LegacyWindowAlias$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [LegacyWindowAlias] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window【！, Constructor】
 LegacyWindowAlias=WebKitCSSMatrix]
interface DOMMatrix : DOMMatrixReadOnly {
  constructor();
  /* <!--cp-some-code--> */
};
</pre>

<p>
この~ifcを~supportする~ES実装は、
`Window$T ~obj上に，同じ値, 同じ特徴を備える 2 個の~propを公開することになる
— 1 つは`~ifc~obj$を通常に公開するためのもの，もう 1 つは それを旧来の名前で公開するためのもの。
◎
An ECMAScript implementation that supports this interface will expose two properties on the Window object with the same value and the same characteristics; one for exposing the interface object normally, and one for exposing it with a legacy name.
</p>

<pre class="es-code">
WebKitCSSMatrix === DOMMatrix;     /* <!--cp-eval-true--> */

var %m = new WebKitCSSMatrix();     /* <span class="comment">
`DOMMatrix^T を実装する新たな~objを作成する。
◎
Creates a new object that implements DOMMatrix.
</span> */

%m.constructor === DOMMatrix;       /* <!--cp-eval-true--> */
%m.constructor === WebKitCSSMatrix; /* <!--cp-eval-true--> */
{}.toString.call(%m);               /* <span class="comment">
`[object DOMMatrix]^l に評価される。
◎
Evaluates to '[object DOMMatrix]'.
</span> */
</pre>

</div>
			</section>
			<section id="LenientSetter">
<h4>3.3.10. `LenientSetter^x</h4>

<div class="advisement">
<p>
互換性の理由から要求されない限り、仕様は `LenientSetter$x を利用するべきでない。
~pageにて、作者が当の~propへ代入することで~IDL属性を~polyfillしようと試みていて、~propが存在するときでも不用意にそうしたとする。
~strict-mode下では、これは例外を投出させ，~pageを壊しかねない。
`LenientSetter$x が無いと、このことから~browserは，将来に出荷できなくなる。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [LenientSetter]$fI
した上で論交することを，強く勧める。
◎
Specifications should not use [LenientSetter] unless required for compatibility reasons. Pages have been observed where authors have attempted to polyfill an IDL attribute by assigning to the property, but have accidentally done so even if the property exists. In strict mode, this would cause an exception to be thrown, potentially breaking page. Without [LenientSetter], this could prevent a browser from shipping the feature. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LenientSetter$x `拡張属性$は、次の`属性$に現れる：
`Document$T ~ifcの［
【！＊原文誤】`fullscreen$M,
`fullscreenEnabled$M
］属性,
`DocumentOrShadowRoot$T `~ifc~mixin$の `fullscreenElement$M
`FULLSCREEN$r
◎
The [LenientSetter] extended attribute appears on the fullscreenEnabled and fullscreenEnabled attributes of the Document interface, and on the fullscreenElement attribute of the DocumentOrShadowRoot interface mixin. [FULLSCREEN] 
</small></p>
</div>

<p>
`LenientSetter$x `拡張属性$が［
`読専$な`正則~属性$
］に現れた場合、［
属性の~accessor~propとして，何もしない設定子を生成する
］ことを指示する。
その結果，~strict-mode下では、~propに対する誤った代入に対しては，例外は投出されずに無視されるようになる。
◎
If the [LenientSetter] extended attribute appears on a read only regular attribute, it indicates that a no-op setter will be generated for the attribute’s accessor property. This results in erroneous assignments to the property in strict mode to be ignored rather than causing an exception to be thrown.
</p>

<div class="p">
<p>
`LenientSetter$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`読専$な`正則~属性$以外に利用されてはナラナイ。
</li><li>同じ属性~上で，
`PutForwards$x ／ `Replaceable$x
拡張属性とともに宣言されてはナラナイ。
</li><li>`~ns$上で宣言される属性~上に利用されてはナラナイ。
</li></ul>

◎
The [LenientSetter] extended attribute must take no arguments. It must not be used on anything other than a read only regular attribute.
◎
An attribute with the [LenientSetter] extended attribute must not also be declared with the [PutForwards] or [Replaceable] extended attributes.
◎
The [LenientSetter] extended attribute must not be used on an attribute declared on a namespace.
</div>

<p>
`LenientSetter$x がどう実装されるかの詳細は、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [LenientSetter] is to be implemented.
</p>

<div class="example">

<p>
次の~IDL片は `LenientSetter$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientSetter] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface Example {
  [LenientSetter] readonly attribute DOMString x;
  readonly attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~ES実装は， `x^M に対応する~accessor~prop上に設定子を持つことになり、~strict-mode下では，どのような代入も無視されるようになる。
◎
An ECMAScript implementation that supports this interface will have a setter on the accessor property that correspond to x, which allows any assignment to be ignored in strict mode.
</p>

<pre class="es-code">
"use strict";

var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */

/* <span class="comment">
~~問題ない。~strict-mode下では，何もしない設定子がある：
◎
Fine; while we are in strict mode, there is a setter that is a no-op.
</span> */
%example.x = 1;

/* <span class="comment">
`TypeError^jE が投出される。~strict-mode下にあり，設定子がないので：
◎
Throws a TypeError, since we are in strict mode and there is no setter.
</span> */
%example.y = 1;
</pre>

</div>

			</section>
			<section id="LenientThis">
<h4>3.3.11. `LenientThis^x</h4>

<div class="advisement">
<p>
互換性の理由から要求されない限り、仕様は `LenientThis$x を利用するべきでない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [LenientThis]$fI
した上で論交することを，強く勧める。
◎
Specifications should not use [LenientThis] unless required for compatibility reasons. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LenientThis$x `拡張属性$は、
`Document$T ~ifcの次の`属性$に現れる
⇒＃
`onreadystatechange$M,
`onmouseenter$M,
`onmouseleave$M
◎終
`HTML$r
◎
The [LenientThis] extended attribute appears on the onreadystatechange, onmouseenter, and onmouseleave attributes of the Document interface. [HTML]
</small></p>
</div>

<p>
`LenientThis$x `拡張属性$が `正則~属性$上に現れた場合、その属性が現れる`~ifc$を`実装-$する~objとは異なる `this^jv 値を伴うような，その属性の取得子や設定子の呼出nは、無視されることになる。
◎
If the [LenientThis] extended attribute appears on a regular attribute, it indicates that invocations of the attribute’s getter or setter with a this value that is not an object that implements the interface on which the attribute appears will be ignored.
</p>

<div class="p">
<p>
`LenientThis$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`静的~属性$上に利用されてはナラナイ。
</li><li>`~ns$上で宣言される属性~上に利用されてはナラナイ。
</li></ul>
◎
The [LenientThis] extended attribute must take no arguments. It must not be used on a static attribute.
◎
The [LenientThis] extended attribute must not be used on an attribute declared on a namespace.
</div>

<p>
`LenientThis$x がどう実装されるかについては、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [LenientThis] is to be implemented.
</p>

<div class="example">
<p>
次の~IDL片は
`LenientThis$x 拡張属性を利用する
~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientThis] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface Example {
  [LenientThis] attribute DOMString x;
  attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~ES実装では、 `x^M に対応する~accessor~propの取得子／設定子では，
`Example^T ~obj以外の何かを伴う呼出ngも許容されることになる。
◎
An ECMAScript implementation that supports this interface will allow the getter and setter of the accessor property that corresponds to x to be invoked with something other than an Example object.
</p>

<pre class="es-code">
var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */
var %obj = { };

/* <span class="comment">
~~通常：
◎
Fine.
</span> */
%example.x;

/* <span class="comment">
`this^jv 値は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、無視される：
◎
Ignored, since the this value is not an Example object and [LenientThis] is used.
</span> */
Object.getOwnPropertyDescriptor(Example.prototype, "x").get.call(%obj);

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、これも無視される：
◎
Also ignored, since Example.prototype is not an Example object and [LenientThis] is used.
</span> */
Example.prototype.x;

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでないので `TypeError^jE が投出される：
◎
Throws a TypeError, since Example.prototype is not an Example object.
</span> */
Example.prototype.y;
</pre>
</div>
			</section>
			<section id="NamedConstructor">
<h4>3.3.12. `NamedConstructor^x</h4>

<div class="advisement">
<p>
[
`NamedConstructor$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [NamedConstructor]$fI
した上で論交することを，強く勧める。
◎
[NamedConstructor] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`NamedConstructor$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`HTMLAudioElement$T,
`HTMLOptionElement$T,
`HTMLImageElement$T
◎終
`HTML$r
◎
The [NamedConstructor] extended attribute appears on the following interfaces: HTMLAudioElement, HTMLOptionElement, and HTMLImageElement. [HTML]
</small></p>
</div>

<div class="p">

<p>
`NamedConstructor$x `拡張属性$が `~ifc$上に現れた場合、~ES大域~objは，次を伴う~propを持つことになる：
</p>

<ul><li>その名前は、拡張属性の引数に指定された名前。
</li><li>値は、その~ifcを実装する~objを作成できる`構築子$。
</li></ul>
◎
If the [NamedConstructor] extended attribute appears on an interface, it indicates that the ECMAScript global object will have a property with the specified name whose value is a constructor that can create objects that implement the interface.＼
</div>

<p>
所与の~ifc上に，複数の `NamedConstructor$x 拡張属性が現れてもよい。
◎
Multiple [NamedConstructor] extended attributes may appear on a given interface.
</p>

<p>
`NamedConstructor$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`識別子を引数にとる$か, または`有名~引数~listを引数にとる$ことが要求される。
`=^sym の直後に現れる `identifier$g が，各 `NamedConstructor$x の
`識別子@nC
になる。
前者の形
<code>[NamedConstructor=`identifier$g]</code>
は、空の引数~list
<code>[NamedConstructor=`identifier$g()]</code>
を利用するのと同じ意味になる。
~ifc上の各 `NamedConstructor$x 拡張属性が、［［
前述の~propの値である`構築子$
］に，指定された引数を渡して、その~ifcを`実装-$する~objを構築する仕方
］を~~供することになる。
◎
The [NamedConstructor] extended attribute must either take an identifier or take a named argument list. The identifier that occurs directly after the “=” is the [NamedConstructor]'s identifier. The first form, [NamedConstructor=identifier], has the same meaning as using an empty argument list, [NamedConstructor=identifier()]. For each [NamedConstructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments to the constructor that is the value of the aforementioned property.
</li>
	<li>
<p>
次に挙げる識別子は、有名~構築子の識別子として利用されてはナラナイ：
</p>

<ul ><li>別の~ifc上の `NamedConstructor$x 拡張属性に利用されている`識別子$nC
</li><li>当のまたは別の~ifc上の `LegacyWindowAlias$x 拡張属性に利用されている`識別子$wA
</li><li>`~ifc~obj$を持つ~ifcの`識別子$
</li><li>`予約-済み識別子$
</li></ul>

◎
The identifier used for the named constructor must not be the same as that used by a [NamedConstructor] extended attribute on another interface, must not be the same as an identifier used by a [LegacyWindowAlias] extended attribute on this interface or another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
同じ`~ifc$上で， `Global$x 拡張属性とともに指定されてはナラナイ。
◎
The [NamedConstructor] and [Global] extended attributes must not be specified on the same interface.
</li>
</ul>

<p>
有名~構築子がどう実装されるかの詳細は
`named-constructors$sec
を見よ。
◎
See § 3.6.2 Named constructors for details on how named constructors are to be implemented.
</p>

<div class="example">
<p>
次の~IDLは
`NamedConstructor$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [NamedConstructor] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window,
 NamedConstructor=Audio,
 NamedConstructor=Audio(DOMString %src)]
interface HTMLAudioElement : HTMLMediaElement {
  /* <!--cp-some-code--> */
};
</pre>

<p>
この~ifcを~supportする~ES実装は、
`Audio^T `構築子$を利用する `HTMLAudioElement^T ~objの構築を許容することになる。
◎
An ECMAScript implementation that supports this interface will allow the construction of HTMLAudioElement objects using the Audio constructor.
</p>

<pre class="es-code">
typeof Audio;           /* <!--cp-eval-function--> */

var %a1 = new Audio();   /* <span class="comment">
引数なしの構築子を利用して， `HTMLAudioElement^T を実装する ~objを作成する。
◎
Creates a new object that implements HTMLAudioElement, using the zero-argument constructor.
</span> */

var %a2 = new Audio('a.flac');   /* <span class="comment">
1 個の引数をとる構築子を利用して， `HTMLAudioElement^T を作成する。
◎
Creates an HTMLAudioElement using the one-argument constructor.
</span> */
</pre>
</div>

			</section>
			<section id="NewObject">
<h4>3.3.13. `NewObject^x</h4>

<p>
`NewObject$x `拡張属性$が［
`正則~演算$／`静的~演算$
］上に現れた場合、［
その演算が~callされたときは、常に，新たに作成された~objへの参照を返すモノトスル
］ことを指示する。
◎
If the [NewObject] extended attribute appears on a regular or static operation, then it indicates that when calling the operation, a reference to a newly created object must always be returned.
</p>

<p>
`NewObject$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NewObject] extended attribute must take no arguments.
</li>
	<li>
`返り値~型$が［
`~ifc型$, または `~promise型$
］である［
`正則~演算$／`静的~演算$
］以外の所に利用されてはナラナイ。
◎
The [NewObject] extended attribute must not be used on anything other than a regular or static operation whose return type is an interface type or a promise type.
</li>
</ul>

<div class="example">
<p>
この拡張属性の利用が適する一例には、
`Document$T ~ifc上の `createElement()$M 演算 `DOM$r がある
— これは、~callされる度に新たな~objが返すべきなので。
`DOM$r
◎
As an example, this extended attribute is suitable for use on the createElement() operation on the Document interface, since a new object should always be returned when it is called. [DOM]
</p>

<pre class="webidl">
[Exposed=Window]
interface Document : Node {
  [NewObject] Element createElement(DOMString %localName);
  /* <!--cp-some-code--> */
};
</pre>

</div>

			</section>
			<section id="NoInterfaceObject">
<h4>3.3.14. `NoInterfaceObject^x</h4>

<div class="advisement">
<p>
`NoInterfaceObject$x 拡張属性は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [NoInterfaceObject]$fI
することにより，論交することを強く勧める。
◎
The [NoInterfaceObject] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`NamedConstructor$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`Geolocation$T,
`Coordinates$T,
`Position$T,
`PositionError$T,
`DeviceAcceleration$T【！廃】,
`DeviceRotationRate$T【！廃】,
`ConstrainablePattern$T,
`WEBGL_compressed_texture_astc$T,
`WEBGL_compressed_texture_s3tc_srgb$T,
`WEBGL_draw_buffers$T,
`WEBGL_lose_context$T,
`ANGLE_instanced_arrays$T,
`EXT_blend_minmax$T,
`EXT_color_buffer_float$T,
`EXT_disjoint_timer_query$T,
`OES_standard_derivatives$T,
`OES_vertex_array_object$T
◎終
`GEOLOCATION-API$r
`ORIENTATION-EVENT$r
`MEDIACAPTURE-STREAMS$r
各種 `WEBGL$r 拡張~仕様
◎
The [NoInterfaceObject] extended attribute appears on the following interfaces:
• Geolocation, Coordinates, Position, PositionError, DeviceAcceleration, DeviceRotationRate, ConstrainablePattern, WEBGL_compressed_texture_astc, WEBGL_compressed_texture_s3tc_srgb, WEBGL_draw_buffers, WEBGL_lose_context, ANGLE_instanced_arrays, EXT_blend_minmax, EXT_color_buffer_float, EXT_disjoint_timer_query, OES_standard_derivatives, and OES_vertex_array_object. [GEOLOCATION-API] [ORIENTATION-EVENT] [MEDIACAPTURE-STREAMS] (various [WEBGL] extension specifications)
</small></p>

<p class="note">注記：
`NoInterfaceObject$x `拡張属性$は、以前は，［［
（今は無き “`implements^sym 文” を利用して、）
`~ifc$を，それが~mixinであったかのように他の`~ifc$が実装できる
］ようにする
］ために注釈する用途があった。
今や、この利用事例をまかなうための，専用の構文
— `~ifc~mixin$／`~includes文$ —
がある。
この目的に `NoInterfaceObject$x `拡張属性$を利用することは、もはや~supportされない。
依然としてそうしている仕様は、アリな限りすみやかに`~ifc~mixin$に移行することが，強く奨励される。
◎
Note: Previously, the [NoInterfaceObject] extended attribute could also be used to annotate interfaces, which other interfaces could then implement (using the defunct "implements statement") as if they were mixins. There is now dedicated syntax to cater for this use case in the form of interface mixins and includes statements. Using the [NoInterfaceObject] extended attribute for this purpose is no longer supported. Specifications which still do are strongly encouraged to migrate to interface mixins as soon as possible.
</p>

</div>

<p>
`NoInterfaceObject$x `拡張属性$が `~ifc$上に現れた場合、その~ifc用の`~ifc~obj$は，~ES言語束縛には存在しないことになる。
◎
If the [NoInterfaceObject] extended attribute appears on an interface, it indicates that an interface object will not exist for the interface in the ECMAScript binding.
</p>

<p>
`NoInterfaceObject$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NoInterfaceObject] extended attribute must take no arguments.
</li>
	<li>
<p>
［
`構築子$／`静的~演算$
］が定義されている~ifc上に指定されてはナラナイ。
◎
The [NoInterfaceObject] extended attribute must not be specified on an interface that has any constructors or static operations defined on it.
</p>

<p class="note">注記：
一方で， `NamedConstructor$x 拡張属性との併用は禁止されない。
◎
Note: Combining the [NoInterfaceObject] and [NamedConstructor] extended attribute is not forbidden, however.
</p>
	</li>
	<li>
この拡張属性が指定されていない~ifcが，この拡張属性が指定されている~ifcを継承してはナラナイ
◎
An interface that does not have the [NoInterfaceObject] extended attribute specified must not inherit from an interface that has the [NoInterfaceObject] extended attribute specified.
</li>
</ul>

<p>
`NoInterfaceObject$x の利用に課される特有な要件については、
`es-interfaces$sec
を見よ。
◎
See § 3.6 Interfaces for the specific requirements that the use of [NoInterfaceObject] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの~ifcを定義する。
一方はその~ifc~objが~ES大域~obj上に公開され，他方はそうでない：
◎
The following IDL fragment defines two interfaces, one whose interface object is exposed on the ECMAScript global object, and one whose isn’t:
</p>

<pre class="webidl">
[Exposed=Window]
interface Storage {
  void addEntry(unsigned long %key, any %value);
};

[Exposed=Window,
 NoInterfaceObject]
interface Query {
  any lookupEntry(unsigned long %key);
};
</pre>

<p>
上の~IDLの~ES実装においては、
`Storage^T の原型に対する操作は許容される一方，
`Query^T に対してはそうならない。
◎
An ECMAScript implementation of the above IDL would allow manipulation of Storage’s prototype, but not Query’s.
</p>

<pre class="es-code">
typeof Storage;                        /* <span class="comment">
`object^l に評価される。
◎
evaluates to "object"
</span> */

/* <span class="comment">
`Storage.addEntry^c に~trace用の `alert()^c ~callを追加する：
◎
Add some tracing alert() call to Storage.addEntry.
</span> */
var %fn = Storage.prototype.addEntry;
Storage.prototype.addEntry = function(%key, %value) {
  alert('Calling addEntry()');
  return %fn.call(this, %key, %value);
};

typeof Query;                          /* <span class="comment">
`undefined^l に評価される。
◎
evaluates to "undefined"
</span> */
var %fn = Query.prototype.lookupEntry;  /* <span class="comment">
例外が投出される。 `Query^T は定義されていないので。
◎
exception, Query isn’t defined
</span> */
</pre>
</div>
			</section>
			<section id="OverrideBuiltins">
<h4>3.3.15. `OverrideBuiltins^x</h4>

<div class="advisement">
<p>
`OverrideBuiltins$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [OverrideBuiltins]$fI
した上で論交することを，強く勧める。
◎
The [OverrideBuiltins] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`OverrideBuiltins$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`DOMStringMap$T,
`Document$T,
`HTMLFormElement$T
◎終
`HTML$r
◎
The [OverrideBuiltins] extended attribute appears on the DOMStringMap, Document, and HTMLFormElement interfaces. [HTML]
</small></p>
</div>

<p>
`OverrideBuiltins$x `拡張属性$が `~ifc$上に現れた場合，その~ifcを実装する`旧来の~platform~obj$ %O においては、［
%O や %O の原型鎖
］上に存在する他の~propに関わらず，各［
%O が`~supportする~prop名$
］に対し，対応する~propが %O 上に現れることになる。
このことは、（通例の挙動では、有名~propは［
%O 自身やその原型鎖
］上のどこにも同じ名前の~propが存在しないときに限り，公開されるのに対し、）有名~propが、［
さもなければ %O 上に現れることになる，同じ名前のどの~prop
］も，常に隠蔽することを意味する。
◎
If the [OverrideBuiltins] extended attribute appears on an interface, it indicates that for a legacy platform object implementing the interface, properties corresponding to all of the object’s supported property names will appear to be on the object, regardless of what other properties exist on the object or its prototype chain. This means that named properties will always shadow any properties that would otherwise appear on the object. This is in contrast to the usual behavior, which is for named properties to be exposed only if there is no property with the same name on the object itself or somewhere on its prototype chain.
</p>

<div class="p">
<p>
`OverrideBuiltins$x `拡張属性$は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れてはナラナイ。
</li><li>`Global$x `拡張属性$とともに宣言されてはナラナイ。
</li><li>`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分を成していなければナラナイ。
</li></ul>

◎
The [OverrideBuiltins] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter or that also is declared with the [Global] extended attribute. If the extended attribute is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</div>

<p>
`OverrideBuiltins$x 拡張属性が`部分的~ifc定義$上に指定された場合、~ifc自身に現れるものと見なされる。
◎
If the [OverrideBuiltins] extended attribute is specified on a partial interface definition, it is considered to appear on the interface itself.
</p>

<p>
`OverrideBuiltins$x の利用に課される特有な要件については、
`es-legacy-platform-objects$sec,
`legacy-platform-object-defineownproperty$sec
を見よ。
◎
See § 3.8 Legacy platform objects and § 3.8.3 [[DefineOwnProperty]] for the specific requirements that the use of [OverrideBuiltins] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの`~ifc$を定義する。
一方は`有名~prop取得子$を持ち, 他方はそうでない：
◎
The following IDL fragment defines two interfaces, one that has a named property getter and one that does not.
</p>

<pre class="webidl">
[Exposed=Window]
interface StringMap {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};

[Exposed=Window,
 OverrideBuiltins]
interface StringMap2 {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};
</pre>

<p>
これら 2 つの~ifcの~ES実装においては、各~ifcを実装する~obj上の一部の~propについて，それを取得した結果が異なってくることになる：
◎
In an ECMAScript implementation of these two interfaces, getting certain properties on objects implementing the interfaces will result in different values:
</p>

<pre class="es-code">
/* <span class="comment">
`StringMap^T の~instanceを得る。
~supportする~prop名として， `abc^l, `length^l, `toString^l を持つとする：
◎
Obtain an instance of StringMap.  Assume that it has "abc", "length" and "toString" as supported property names.
</span> */
var %map1 = getStringMap();

/* <span class="comment">
有名~prop取得子を呼出す：
◎
This invokes the named property getter.
</span> */
%map1.abc;

/* <span class="comment">
`length^M 属性に対応する~obj上の `length^jp ~propを取りに行く：
◎
This fetches the "length" property on the object that corresponds to the length attribute.
</span> */
%map1.length;

/* <span class="comment">
~objの原型鎖~上の `toString^jp ~propを取りに行く：
◎
This fetches the "toString" property from the object’s prototype chain.
</span> */
%map1.toString;

/* <span class="comment">
`StringMap2^T の~instanceを得る
— これも、~supportする~prop名として， `abc^l, `length^l, `toString^l を持つとする：
◎
Obtain an instance of StringMap2.  Assume that it also has "abc", "length" and "toString" as supported property names.
</span> */
var %map2 = getStringMap2();

/* <span class="comment">
これは、有名~prop取得子を呼出す：
◎
This invokes the named property getter.
</span> */
%map2.abc;

/* <span class="comment">
これも、有名~prop取得子を呼出す
— ~obj上の `length^jp ~propが length 属性に対応しているにも関わらず：
◎
This also invokes the named property getter, despite the fact that the "length" property on the object corresponds to the length attribute.
</span> */
%map2.length;

/* <span class="comment">
これもまた、有名~prop取得子を呼出す
— `toString^l が %map2 の prototype chain 内にある~propであるにも関わらず：
◎
This too invokes the named property getter, despite the fact that "toString" is a property in map2’s prototype chain.
</span> */
%map2.toString;
</pre>
</div>
			</section>
			<section id="PutForwards">
<h4>3.3.16. `PutForwards^x</h4>

<p>
`PutForwards$x `拡張属性$が［
`~ifc型$の`読専$な`正則~属性$宣言
］上に現れた場合、その属性への代入-時に特有に挙動することになる。
すなわち，その代入は、代入しようと試みられた属性から，現在~参照されている~objの属性（その拡張属性の引数で指定される）に “回送-” される。
◎
If the [PutForwards] extended attribute appears on a read only regular attribute declaration whose type is an interface type, it indicates that assigning to the attribute will have specific behavior. Namely, the assignment is “forwarded” to the attribute (specified by the extended attribute argument) on the object that is currently referenced by the attribute being assigned to.
</p>

<p>
`PutForwards$x 拡張属性には、`識別子を引数にとる$ことが要求される。
次が与えられたとするとき：
◎
The [PutForwards] extended attribute must take an identifier. Assuming that:
</p>

<ul>
	<li>
%A は
`PutForwards$x 拡張属性が現れる`属性$,
◎
A is the attribute on which the [PutForwards] extended attribute appears,
</li>
	<li>
%I は
%A が宣言されている`~ifc$,
◎
I is the interface on which A is declared,
</li>
	<li>
%J は
%A の型として宣言されている `~ifc型$, 【！＊】
◎
J is the interface type that A is declared to be of, and
</li>
	<li>
%N は
その拡張属性の`識別子$引数,
◎
N is the identifier argument of the extended attribute,
</li>
</ul>

<p>
このとき，`識別子$ %N を持つ別の`属性$ %B が
%J 上に宣言されていなければナラナイ。
%I を実装している~obj上の属性 %A への値の代入では、代わりに，
%A が参照する~objの属性 %B にその値が代入されることになる。
◎
then there must be another attribute B declared on J whose identifier is N. Assignment of a value to the attribute A on an object implementing I will result in that value being assigned to attribute B of the object that A references, instead.
</p>

<p>
`PutForwards$x 注釈付きの`属性$は連鎖し得ることに注意。
すなわち、
`PutForwards$x `拡張属性$を伴う属性は，この拡張属性を持つ他の属性を指すことができる。
ただし、この代入の連鎖が循環してはナラナイ。
代入の連鎖が辿られる際に，同じ`~ifc$上の特定0の属性に複数~回 遭遇するならば、循環が存在する。
◎
Note that [PutForwards]-annotated attributes can be chained. That is, an attribute with the [PutForwards] extended attribute can refer to an attribute that itself has that extended attribute. There must not exist a cycle in a chain of forwarded assignments. A cycle exists if, when following the chain of forwarded assignments, a particular attribute on an interface is encountered more than once.
</p>

<p>
`PutForwards$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性とともに宣言されてはナラナイ。
◎
An attribute with the [PutForwards] extended attribute must not also be declared with the [LenientSetter] or [Replaceable] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されてはナラナイ。
◎
The [PutForwards] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されてはナラナイ。
◎
The [PutForwards] extended attribute must not be used on a static attribute.
</li>
	<li>
`~ns$上で宣言される属性~上に利用されてはナラナイ。
◎
The [PutForwards] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`PutForwards$x がどう実装されるかについては、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [PutForwards] is to be implemented.
</p>

<div class="example">
<p>
次の`~IDL片$は、姓名と人を表す~ifcを定義する。
`Person^T ~ifcの `name^M 属性~上に利用される `PutForwards$x 拡張属性は、［
その属性への代入による結果は、 `Person^T ~objの
【 `name^M 属性が指す `Name^T ~objの】
`full^M 属性への代入になる
］ことを指示する：
◎
The following IDL fragment defines interfaces for names and people. The [PutForwards] extended attribute is used on the name attribute of the Person interface to indicate that assignments to that attribute result in assignments to the full attribute of the Person object:
</p>

<pre class="webidl">
[Exposed=Window]
interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

[Exposed=Window]
interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};
</pre>

<p>
~ES言語束縛においては、
`name^jp ~propへの代入が許容されることになる：
◎
In the ECMAScript binding, this would allow assignments to the name property:
</p>

<pre class="es-code">
var %p = getPerson();           /* <span class="comment">
`Person^T の~instanceを得る。
◎
Obtain an instance of Person.
</span> */

%p.name = 'John Citizen';       /* <span class="comment">
この文は...
◎
This statement...
</span> */
%p.name.full = 'John Citizen';  /* <span class="comment">
...これと同じ挙動になる。
◎
...has the same behavior as this one.
</span> */
</pre>
</div>
			</section>
			<section id="Replaceable">
<h4>3.3.17. `Replaceable^x</h4>

<p>
`Replaceable$x `拡張属性$が `読専$な`正則~属性$上に現れた場合、`~platform~obj$上の対応する~propが設定される際に、その~obj上に，代入される値をとる同じ名前の自前の~propが作成されることになる。
この~propは、
`~ifc原型~obj$上に存在する，その属性に対応する~accessor~propを隠蔽する。
◎
If the [Replaceable] extended attribute appears on a read only regular attribute, it indicates that setting the corresponding property on the platform object will result in an own property with the same name being created on the object which has the value being assigned. This property will shadow the accessor property corresponding to the attribute, which exists on the interface prototype object.
</p>

<p>
`Replaceable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Replaceable] extended attribute must take no arguments.
</li>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性とともに宣言されてはナラナイ。
◎
An attribute with the [Replaceable] extended attribute must not also be declared with the [LenientSetter] or [PutForwards] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されてはナラナイ。
◎
The [Replaceable] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されてはナラナイ。
◎
The [Replaceable] extended attribute must not be used on a static attribute.
</li>
	<li>
`~ns$上で宣言される属性に利用されてはナラナイ。
◎
The [Replaceable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`Replaceable$x の利用に課される特有な要件については、
`es-attributes$sec
を見よ。
◎
See § 3.6.6 Attributes for the specific requirements that the use of [Replaceable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、計数を増やす`演算$と，計数~値を公開する初期~値 0 の`属性$を持つ`~ifc$を定義する：
◎
The following IDL fragment defines an interface with an operation that increments a counter, and an attribute that exposes the counter’s value, which is initially 0:
</p>

<pre class="webidl">
[Exposed=Window]
interface Counter {
  [Replaceable] readonly attribute unsigned long value;
  void increment();
};
</pre>

<p>
`Counter^T を実装する `~platform~obj$上の
`value^jp ~propに代入することにより，その`属性$に対応する~propは隠蔽されることになる：
◎
Assigning to the value property on a platform object implementing Counter will shadow the property that corresponds to the attribute:
</p>

<pre class="es-code">
var %counter = getCounter();         /* <span class="comment">
`Counter^T の~instanceを得る。
◎
Obtain an instance of Counter.
</span> */
%counter.value;                      /* <span class="comment">
`0^jv に評価される。
◎
Evaluates to 0.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-false--> */
Object.getPrototypeOf(%counter).hasOwnProperty("value");
                                    /* <!--cp-eval-true--> */

%counter.increment();
%counter.increment();
%counter.value;                      /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */

%counter.value = 'a';                
       /* <span class="comment">
`Counter::value^V に無関係なもので~propを隠蔽する。
◎
Shadows the property with one that is unrelated to Counter::value.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-true--> */

%counter.increment();
%counter.value;                      /* <span class="comment">
`a^l に評価される。
◎
Evaluates to 'a'.
</span> */

delete %counter.value;               /* <span class="comment">
元の~propを露にする。
◎
Reveals the original property.
</span> */
%counter.value;                      /* <span class="comment">
`3^jv に評価される。
◎
Evaluates to 3.
</span> */
</pre>
</div>

			</section>
			<section id="SameObject">
<h4>3.3.18. `SameObject^x</h4>

<p>
`SameObject$x `拡張属性$が `読専$な`属性$に現れた場合、［
所与の~obj上でその属性の値が取得される度に，常に同じ値を返すモノトスル
］ことを指示する。
◎
If the [SameObject] extended attribute appears on a read only attribute, then it indicates that when getting the value of the attribute on a given object, the same value must always be returned.
</p>

<p>
`SameObject$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [SameObject] extended attribute must take no arguments.
</li>
	<li>
［［
`~ifc型$／`~obj型$
］である`読専$な`属性$
］以外の所に利用されてはナラナイ。
◎
The [SameObject] extended attribute must not be used on anything other than a read only attribute whose type is an interface type or object.
</li>
</ul>

<div class="example">
<p>
この拡張属性の利用が適する一例には，
`Document$T ~ifc上の `implementation$M 属性がある。
— 所与の `Document^T ~objに対しては、常に同じ~objを返すので。
`DOM$r
◎
As an example, this extended attribute is suitable for use on the implementation attribute on the Document interface since the same object is always returned for a given Document object. [DOM]
</p>

<pre class="webidl">
[Exposed=Window]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  /* <!--cp-some-code--> */
};
</pre>
</div>

			</section>
			<section id="SecureContext">
<h4>3.3.19. `SecureContext^x</h4>

<p>
`SecureContext$x `拡張属性$が［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`~callback~ifc$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$ ／
個々の［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］］ %X 上に現れた場合、［
%X が`公開され$るのは `~secure文脈$の中に限られる
］ことを指示する。
◎
If the [SecureContext] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, callback interface, namespace, partial namespace, interface member, interface mixin member, or namespace member, it indicates that the construct is exposed only within a secure context.＼
</p>

<p>
`SecureContext$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
上に挙げたもの以外の構成子に利用されてはナラナイ。
◎
The [SecureContext] extended attribute must not be used on any other construct.
</li>
	<li>
`引数をとらない$ことが要求される。
◎
The [SecureContext] extended attribute must take no arguments.
</li>
</ul>

<p>
構成子は、次を満たすならば
`~secure文脈~下でなくとも可用@
とされる
⇒
`~secure文脈~下に限り可用$ではない（すなわち，適用される `SecureContext$x 拡張属性は無い）
◎
A construct is available in both secure and non-secure contexts if it is not available only in secure contexts (i.e., if no [SecureContext] extended attribute applies to it).
</p>

<div class="algorithm">
<p>
所与の構成子 %C が
`~secure文脈~下に限り可用@
かどうか検査するときは、次の手続きを走らす
【結果が ~T ならば、~secure文脈~下に限り可用 “である” ／`~secure文脈~下でなくとも可用$ “ではない” 】：
◎
To check if a construct C is available only in secure contexts, run the following steps:
</p>

<ol>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$ ／ `~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
◎
Assert: C is an interface, callback interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%C は`~ifc~mixin~mb$であるならば %C の`~host~ifc$ ／
~ELSE_ ~NULL
］
◎
Let H be C’s host interface if C is an interface mixin member, or null otherwise.
</li>
	<li>
<p>
~IF［
%C は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If C is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
%C ~SET %C を宣言している［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$
］
◎
Otherwise, set C to be the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace C is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］である
］：
◎
If C is a partial interface, partial interface mixin, or partial namespace, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
%C ~SET %C の元の［
`~ifc$ ／
`~ifc~mixin$ ／
`~ns$
］定義
◎
Otherwise, set C to be the original interface, interface mixin, or namespace definition of C.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は`~ifc~mixin$である
］：
◎
If C is an interface mixin, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
%C ~SET %H
◎
Otherwise, set C to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$
］である
◎
Assert: C is an interface, callback interface or namespace.
</li>
	<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
	<li>
~RET ~F
◎
Otherwise, return false.
</li>
</ol>
</div>

<p class="note">注記：
所与の構成子が`~secure文脈~下に限り可用$かどうかは、所与の`~Realm$内に`公開され$るかどうかに波及する。
◎
Note: Whether a construct is available only in secure contexts influences whether it is exposed in a given Realm.
</p>

<p>
`SecureContext$x `拡張属性$は：
</p>
<ul>
	<li>
`多重定義$された ある`演算$に現れるならば、その多重定義を成す他のすべての演算にも現れなければナラナイ。
◎
If [SecureContext] appears on an overloaded operation, then it must appear on all overloads.
</li>
	<li>
<p>
次の各項に挙げる両者に指定されてはナラナイ：
◎
The [SecureContext] extended attribute must not be specified both on
</p>
		<ul>
			<li>
`~ifc~mb$, および それを宣言している［
`~ifc$／`部分的~ifc$
］
◎
an interface member and its interface or partial interface;
</li>
			<li>
`~ifc~mixin~mb$, および それを宣言している［
`~ifc~mixin$／`部分的~ifc~mixin$
］
◎
an interface mixin member and its interface mixin or partial interface mixin;
</li>
			<li>
`~ns~mb$, および それを宣言している［
`~ns$／`部分的~ns$
］
◎
a namespace member and its namespace or partial namespace.
</li>
		</ul>

<p class="note">注記：
そのわけは、ある定義に `SecureContext$x `拡張属性$が注釈されている下で，それが包含している`~mb$に `SecureContext$x `拡張属性$を追加しても、~mbの公開をさらに制約することはないからである。
◎
Note: This is because adding the [SecureContext] extended attribute on a member when its containing definition is also annotated with the [SecureContext] extended attribute does not further restrict the exposure of the member.
</p>
	</li>
</ul>

<p>
`SecureContext$x`拡張属性$を伴わない`~ifc$は、
`SecureContext$x を指定する別の~ifcを`継承-$してはナラナイ。
◎
An interface without the [SecureContext] extended attribute must not inherit from another interface that does specify [SecureContext].
</p>

<div class="example">

<p>
次の`~IDL片$が定義する~ifcには、 3 個の~mbがある
— うち 1 個は どの文脈からも実行-可能な`演算$であり，他は ~secure文脈に限り実行-可能になる：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from secure contexts.
</p>

<pre class="webidl">
[Exposed=Window]
interface PowerfulFeature {
  /* <span class="comment">
次の演算の~callはどの文脈~下でも成功する：
◎
This call will succeed in all contexts.
</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

  /* <span class="comment">
次の演算は、~secureでない文脈には公開されない
— `PowerfulFeature.prototype^c 上に `calculateSecretResult^jp ~propはない：
◎
This operation will not be exposed to a non-secure context. In such a context, there will be no "calculateSecretResult" property on PowerfulFeature.prototype.
</span> */
  [SecureContext] Promise&lt;Result&gt; calculateSecretResult();

  /* <span class="comment">
次の属性にも同じことが言え、~secureでない文脈には公開されない
— `PowerfulFeature.prototype^c 上に 
`secretBoolean^jp ~propはない：
◎
The same applies here: the attribute will not be exposed to a non-secure context, and in a non-secure context there will be no "secretBoolean" property on PowerfulFeature.prototype.
</span> */
  [SecureContext] readonly attribute boolean secretBoolean;
};

/* <span class="comment">
`HeartbeatSensor^T は、~secureでない文脈にも その~mbにも公開されない
— `Window^T 上に `HeartbeatSensor^jp ~propはない：
◎
HeartbeatSensor will not be exposed in a non-secure context, nor will its members. In such a context, there will be no "HeartbeatSensor" property on Window.
</span> */
[SecureContext]
interface HeartbeatSensor {
  Promise&lt;float&gt; getHeartbeatsPerMinute();
};

/* <span class="comment">
次に定義される~ifc~mixin~mbは、それを内包する~ifcが~secureかどうかに関わらず，~secureでない文脈には決して公開されない
— `PowerfulFeature.prototype^c 上に `snap^jp ~propはない：
◎
The interface mixin members defined below will never be exposed in a non-secure context, regardless of whether the interface that includes them is. In a non-secure context, there will be no "snap" property on PowerfulFeature.prototype.
</span> */
[SecureContext]
interface mixin Snapshotable {
  Promise&lt;boolean&gt; snap();
};
PowerfulFeature includes Snapshotable;

/* <span class="comment">
他方，次の各 ~ifc~mixin~mbは、
`SecureContext$x 拡張属性を伴わない~host~ifcに内包された場合には，~secureでない文脈にも公開されることになる
— そのような文脈においても，
`PowerfulFeature.prototype^c 上に `log^jp ~propはある：
◎
On the other hand, the following interface mixin members will be exposed to a non-secure context when included by a host interface that doesn’t have the [SecureContext] extended attribute. In a non-secure context, there will be a "log" property on PowerfulFeatures.prototype.
</span> */
interface mixin Loggable {
  Promise&lt;boolean&gt; log();
};
PowerfulFeatures includes Loggable;
</pre>
</div>

			</section>
			<section id="TreatNonObjectAsNull">
<h4>3.3.20. `TreatNonObjectAsNull^x</h4>

<div class="advisement">
<p>
`TreatNonObjectAsNull$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [TreatNonObjectAsNull]$fI
した上で論交することを，強く勧める。
◎
The [TreatNonObjectAsNull] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`TreatNonObjectAsNull$x `拡張属性$は、
`onclick^M や `onerror^M
などの`~event~handler~IDL属性$の型として利用される，次のものに現れる
⇒＃
`~callback関数$,
`EventHandlerNonNull$T,
`OnBeforeUnloadEventHandlerNonNull$T,
`OnErrorEventHandlerNonNull$T
◎終
`HTML$r
◎
The [TreatNonObjectAsNull] extended attribute appears on the callback functions EventHandlerNonNull, OnBeforeUnloadEventHandlerNonNull, and OnErrorEventHandlerNonNull used as the type of event handler IDL attributes such as onclick and onerror. [HTML]
</small></p>
</div>

<p>
`TreatNonObjectAsNull$x `拡張属性$が `~callback関数$上に現れた場合、［
`属性$に代入される［
`~nullable$`~callback関数$型であって, ~objではない
］どの値も， `null^V 値に変換するようにする
］ことを指示する。
◎
If the [TreatNonObjectAsNull] extended attribute appears on a callback function, then it indicates that any value assigned to an attribute whose type is a nullable callback function that is not an object will be converted to the null value.
</p>

<p>
`TreatNonObjectAsNull$x の利用に課される特有な要件については、
`es-nullable-type$sec
を見よ。
◎
See § 3.2.19 Nullable types — T? for the specific requirements that the use of [TreatNonObjectAsNull] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`TreatNonObjectAsNull$x 注釈付きの`~callback関数$型の属性と,
この`拡張属性$を伴わない`~callback関数$を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute whose type is a [TreatNonObjectAsNull]-annotated callback function and another whose type is a callback function without the extended attribute:
</p>

<pre class="webidl">
callback OccurrenceHandler = void (DOMString %details);

[TreatNonObjectAsNull]
callback ErrorHandler = void (DOMString %details);

[Exposed=Window]
interface Manager {
  attribute OccurrenceHandler? handler1;
  attribute ErrorHandler? handler2;
};
</pre>

<p>
~ES実装においては、~objでない値（ `Number^jt 値など）を
`handler1^M に代入したときと,
`handler2^M に代入したときとの挙動と異なる：
◎
In an ECMAScript implementation, assigning a value that is not an object (such as a Number value) to handler1 will have different behavior from that when assigning to handler2:
</p>

<pre class="es-code">
var %manager = getManager();  /* <span class="comment">
`Manager^T の~instanceを取得する。
◎
Get an instance of Manager.
</span> */

%manager.handler1 = function() { };
%manager.handler1;            /* <span class="comment" id="cp-eval-the-function">
当の function に評価される。
◎
Evaluates to the function.
</span> */

try {
  %manager.handler1 = 123;    /* <span class="comment">
`TypeError^jE が投出される。
◎
Throws a TypeError.
</span> */
} catch (%e) {
}

%manager.handler2 = function() { };
%manager.handler2;            /* <!--cp-eval-the-function--> */

%manager.handler2 = 123;
%manager.handler2;            /* <span class="comment">
`null^jv に評価される。
◎
Evaluates to null.
</span> */
</pre>

</div>

			</section>
			<section id="TreatNullAs">
<h4>3.3.21. `TreatNullAs^x</h4>

<p class="advisement">
`TreatNullAs$x `拡張属性$は、望ましくない特能である。
旧来の~Web~platform特能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use [TreatNullAs]$fI
した上で論交することを，強く勧める。
◎
The [TreatNullAs] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p>
`TreatNullAs$x `拡張属性$が `DOMString$T 型に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `null^jv 値がこの~IDL型に変換される際には、既定による `null^l に文字列~化される代わりに，空~文字列に変換される。
◎
If the [TreatNullAs] extended attribute appears on the DOMString type, it creates a new IDL type such that that when an ECMAScript null is converted to the IDL type, it will be handled differently from its default handling. Instead of being stringified to "null", which is the default, it will be converted to the empty string.
</p>

<p>
`TreatNullAs$x 拡張属性には、次の`識別子を引数にとる$ことが要求される：
`EmptyString^c
◎
The [TreatNullAs] extended attribute must take the identifier EmptyString.
</p>

<p>
`TreatNullAs$x `拡張属性が結付けられ$ている型は、 `DOMString$T でなければナラナイ。
◎
The [TreatNullAs] extended attribute must not be associated with a type that is not DOMString.
</p>

<p class="note">注記：
すなわち、
`DOMString?^T 型であっても，
`TreatNullAs$x を利用してはならない
— `null^V はその型の妥当な値なので。
◎
Note: This means that even DOMString? must not use [TreatNullAs], since null is a valid value of that type.
</p>

<p>
`TreatNullAs$x の利用に課される特有な要件については、
`es-DOMString$sec
を見よ。
◎
See § 3.2.9 DOMString for the specific requirements that the use of [TreatNullAs] entails.
</p>

<div class="example">
<p>
次の`~IDL片$が定義する［
属性 ／ 演算がとる引数
］の型は、 `TreatNullAs$x 拡張属性を有している：
◎
The following IDL fragment defines an interface that has one attribute whose type has the extended attribute, and one operation whose argument’s type has the extended attribute:
</p>

<pre class="webidl">
[Exposed=Window]
interface Dog {
  attribute DOMString name;
  attribute [TreatNullAs=EmptyString] DOMString owner;

  boolean isMemberOfBreed([TreatNullAs=EmptyString] DOMString %breedName);
};
</pre>

<p>
`Dog^T ~ifcを実装する~ES実装においては、
`owner^jp ~propに代入される, あるいは
`isMemberOfBreed^M 関数の引数に渡される `null^jv 値は、
`null^l ではなく，空~文字列に変換されることになる：
◎
An ECMAScript implementation implementing the Dog interface would convert a null value assigned to the owner property or passed as the argument to the isMemberOfBreed function to the empty string rather than "null":
</p>

<pre class="es-code">
var %d = getDog();
       /* <span class="comment">
%d は `Dog^T ~ifcを実装する~platform~objとする。
◎
Assume d is a platform object implementing the Dog interface.
</span> */

%d.name = null;
       /* <span class="comment">
文字列 `null^l を `.name^jp ~propに代入する。
◎
This assigns the string "null" to the .name property.
</span> */

%d.owner = null;
       /* <span class="comment">
文字列 "" を `.owner^jp ~propに代入する。
◎
This assigns the string "" to the .owner property.
</span> */

%d.isMemberOfBreed(null);
       /* <span class="comment">
文字列 "" を `isMemberOfBreed^M 関数に渡す。
◎
This passes the string "" to the isMemberOfBreed function.
</span> */
</pre>
</div>
			</section>
			<section id="Unforgeable">
<h4>3.3.22. `Unforgeable^x</h4>

<div class="p">
<p>
`Unforgeable$x `拡張属性$が［
`正則~属性$／`静的$oPでない`演算$
］上に現れた場合、その属性／演算は，次のような仕方で~ES~propとして反映されることになる：
</p>

<ul>
	<li>
その挙動は改変できない。
</li>
	<li>
~obj上で~prop検索が遂行された際には，常にその属性の~prop値が返される。
</li>
</ul>

<p>
特に，そのような~propは、~configure不能になり，かつ［
~objの原型~上ではなく, ~obj上の自前の~prop
］として存在することになる。
</p>
◎
If the [Unforgeable] extended attribute appears on regular attributes or non-static operations, it indicates that the attribute or operation will be reflected as an ECMAScript property in a way that means its behavior cannot be modified and that performing a property lookup on the object will always result in the attribute’s property value being returned. In particular, the property will be non-configurable and will exist as an own property on the object itself rather than on its prototype.
</div>

<p>
所与の~ifc %A 上にて
`Unforgeable$x `拡張属性$ 注釈付きで宣言されている［
属性／演算
］は、
%A 上において
`偽造-不能@
であるとされる。
<!-- “偽造-不能” という対訳は概念的な意味で汎用性には欠くが，元々は~security上の要求に端を発するものと見られる -->
◎
An attribute or operation is said to be unforgeable on a given interface A if the attribute or operation is declared on A, and is annotated with the [Unforgeable] extended attribute.
</p>

<p>
`Unforgeable$x `拡張属性$は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unforgeable] extended attribute must take no arguments.
</li>
	<li>
［
`正則~属性$, `静的$oPでない`演算$
］以外の所に現れてはナラナイ。
◎
The [Unforgeable] extended attribute must not appear on anything other than a regular attribute or a non-static operation.＼
</li>
	<li>
ある演算~上に現れるならば、その~ifc上で同じ識別子を持つ他のすべての演算~上にも現れなければナラナイ。
◎
If it does appear on an operation, then it must appear on all operations with the same identifier on that interface.
</li>
	<li>
`~ns$上で宣言される属性~上に利用されてはナラナイ。
◎
The [Unforgeable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
~ifc %A 上の［
属性／演算
］ %m が`偽造-不能$である場合、
%A を自身が`継承した~ifcたち$に含むような別の~ifc %B は，`識別子$が %m と同じである［
`正則~属性$, `静的$oPでない`演算$
］のいずれも持ってはナラナイ。
◎
If an attribute or operation X is unforgeable on an interface A, and A is one of the inherited interfaces of another interface B, then B must not have a regular attribute or non-static operation with the same identifier as X.
</p>

<div class="note">

<p>
例えば，次は許容されない：
◎
For example, the following is disallowed:
</p>

<pre class="webidl">
[Exposed=Window]
interface A1 {
[Unforgeable] readonly attribute DOMString x;
};
[Exposed=Window]
interface B1 : A1 {
  void x();  /* <span class="comment">
妥当でない
— `A1^T の `x^M で隠蔽されるので。
◎
Invalid; would be shadowed by A1’s x.
</span> */
};

[Exposed=Window]
interface B2 : A1 { };
B2 includes M1;
interface mixin M1 {
  void x();  /* <span class="comment">
妥当でない
— `B2^T における `x^M の複製は `A1^T の `x^M で隠蔽されるので。
◎
Invalid; B2’s copy of x would be shadowed by A1’s x.
</span> */
};
</pre>

</div>

<p>
`Unforgeable$x の利用に課される特有な要件については、
`es-attributes$sec,
`es-operations$sec,
`es-platform-objects$sec,
`es-legacy-platform-objects$sec,
`legacy-platform-object-defineownproperty$sec
を見よ。
◎
See § 3.6.6 Attributes, § 3.6.7 Operations, § 3.7 Platform objects implementing interfaces, § 3.8 Legacy platform objects and § 3.8.3 [[DefineOwnProperty]] for the specific requirements that the use of [Unforgeable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は
片方に `Unforgeable$x が指定された 2 個の`属性$を持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two attributes, one of which is designated as [Unforgeable]:
</p>

<pre class="webidl">
[Exposed=Window]
interface System {
  [Unforgeable] readonly attribute DOMString username;
  readonly attribute long long loginTime;
};
</pre>

<p>
この~ifcの~ES実装においては、
`username^M 属性は，~obj自身において~configure不能な~propとして公開されることになる：
◎
In an ECMAScript implementation of the interface, the username attribute will be exposed as a non-configurable property on the object itself:
</p>

<pre class="es-code">
var %system = getSystem();         /* <span class="comment">
`System^T の~instanceを取得する。
◎
Get an instance of System.
</span> */

%system.hasOwnProperty("username");             /* <!--cp-eval-true--> */
%system.hasOwnProperty("loginTime");            /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("username");   /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("loginTime");  /* <!--cp-eval-true--> */

try {
  /* <span class="comment">
次の~callは失敗することになる — ~propは~configure不能なので：
◎
This call would fail, since the property is non-configurable.
</span> */
  Object.defineProperty(system, "username", { value: "administrator" });
} catch (%e) { }

/* <span class="comment">
次の `defineProperty^jp ~callは成功する
— `System.prototype.loginTime^c が~configure可能なので：
◎
This defineProperty call would succeed, because System.prototype.loginTime is configurable.
</span> */
var %forgedLoginTime = 5;
Object.defineProperty(System.prototype, "loginTime", { value: %forgedLoginTime });

%system.loginTime;  /* <span class="comment">
よって，これは今や %forgedLoginTime に評価される。
◎
So this now evaluates to forgedLoginTime.
</span> */
</pre>
</div>
			</section>
			<section id="Unscopable">
<h4>3.3.23. `Unscopable^x</h4>

<p>
`Unscopable$x `拡張属性$が［
`正則~属性$／`正則~演算$
］ %m 上に現れた場合、［［
%m を伴う~ifcを`実装-$する~obj %O
］は、
%O に伴われるどの~obj環境~record内にも［
その基底~objとして， %m の~prop名 %N を内包しない
］］ことを指示する。
その~~結果、 `with^c 文の中では，［
%N に合致する “素の” 識別子
］は，その~propには解決されないことになる。
このふるまいは、 %N を［
`~ifc原型~obj$上の
`unscopables$jS ~propの値
］に含ませることで，得られる。
◎
If the [Unscopable] extended attribute appears on a regular attribute or regular operation, it indicates that an object that implements an interface with the given interface member will not include its property name in any object environment record with it as its base object. The result of this is that bare identifiers matching the property name will not resolve to the property in a with statement. This is achieved by including the property name on the interface prototype object’s @@unscopables property’s value.
</p>

<p>
`Unscopable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unscopable] extended attribute must take no arguments.
</li>
	<li>
［
`正則~属性$, `正則~演算$
］以外の所に現れてはナラナイ。
◎
The [Unscopable] extended attribute must not appear on anything other than a regular attribute or regular operation.
</li>
	<li>
`~ns$上で宣言される属性~上に利用されてはナラナイ。
◎
The [Unscopable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`Unscopable$x の利用に課される特有な要件については、
`interface-prototype-object$sec
を見よ。
◎
See § 3.6.3 Interface prototype object for the specific requirements that the use of [Unscopable] entails.
</p>

<div class="note">

<p>
例えば、次の~IDLが与えられたとき：
◎
For example, with the following IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface Thing {
  void f();
  [Unscopable] g();
};
</pre>

<p>
`f^jp ~propは、 `with^c 文の中で “素の” 識別子により参照できるが，
`g^jp ~propはできない：
◎
the f property can be referenced with a bare identifier in a with statement but the g property cannot:
</p>

<pre class="es-code">
var %thing = getThing();  /* <span class="comment">
`Thing^T の~instance
◎
An instance of Thing
</span> */
with (%thing) {
  f;                     /* <span class="comment">
`Function^jt ~objに評価される。
◎
Evaluates to a Function object.
</span> */
  g;                     /* <span class="comment">
`ReferenceError^jE が投出される。
◎
Throws a ReferenceError.
</span> */
}
</pre>

</div>

			</section>
		</section>
		<section id="es-security">
<h3 title="Security">3.4. ~security検査</h3>

<p>
以下の節の一部の~algoでは、所与の~objに対し
`~security検査を遂行する@
ものがある。
この検査は、所与の［
`演算$／`属性$
］ %m に対する［
呼出n／~access
］が許容されるべきかどうかを決定するために利用される。
~security検査は、次の 3 つを入力にとる：
◎
Certain algorithms in the sections below are defined to perform a security check on a given object. This check is used to determine whether a given operation invocation or attribute access should be allowed. The security check takes the following three inputs:
</p>

<ol>
	<li>
［
%m の呼出n ／ %m への~access
］が行われている当の`~platform~obj$
◎
the platform object on which the operation invocation or attribute access is being done,
</li>
	<li>
%m の`識別子$
◎
the identifier of the operation or attribute, and
</li>
	<li>
<p>
%m を実装する`関数~obj$の種別
— 次のいずれかとして与えられる：
</p>
		<ul>
			<li>
`~meth^C
（ %m が演算に対応するとき）
</li>
			<li>
`取得子^C
（ %m が “取得子” 関数に対応するとき）
</li>
			<li>
`設定子^C
（ %m が “設定子” 関数に対応するとき）
</li>
		</ul>
◎
the type of the function object – "method" (when it corresponds to an IDL operation), or "getter" or "setter" (when it corresponds to the getter or setter function of an IDL attribute).
</li>
</ol>

<p class="note">注記：
~security検査がどう遂行されるかは、~HTML仕様が定義する。
`HTML$r
【`参照＠~HTMLWPROXY#integration-with-idl$href】
◎
Note: The HTML Standard defines how a security check is performed. [HTML]
</p>

		</section>
		<section id="es-overloads">
<h3 title="Overload resolution algorithm">3.5. 多重定義~解決~algo</h3>

<div class="algorithm">
<p>
`関数類$の呼出nを解決するために，
`多重定義~解決~algo@
が定義される
【その名に反し、この~algoは，多重定義されていなくとも呼出される】
：
◎
In order to define how function invocations are resolved, the overload resolution algorithm is defined.＼
</p>

<ul>
	<li>
<p>
その入力は：
</p>

<ul><li>%S
— `有効~多重定義~集合$
</li><li>%args
— 一連の~ES値からなる`~list$
</li></ul>

◎
Its input is an effective overload set, S, and a list of ECMAScript values, args.＼
</li>
	<li>
<p>
その出力は，次の組である：
</p>

<ul><li>%S を成すいずれかの~entryの［
`演算$／`拡張属性$（構築子）
］
</li><li>`~Web~IDL引数~list$
</li></ul>

◎
Its output is a pair consisting of the operation or extended attribute of one of S’s entries and a list of IDL values or the special value “missing”.＼
</li>
</ul>

<p>
~algoは次に従って挙動する：
◎
The algorithm behaves as follows:
</p>

<ol>
	<li>
%maxarg ~LET
%S 内の各~entryの`型~list$oLの`~size$のうち，最大
◎
Let maxarg be the length of the longest type list of the entries in S.
</li>
	<li id="cp-let-n-args-size">
%n ~LET %args の`~size$
◎
Let n be the size of args.
</li>
	<li>
%argcount ~LET `min^op( %maxarg, %n )
◎
Initialize argcount to be min(maxarg, n).
</li>
	<li>
%S から，次を満たす~entryはすべて除去する
⇒
`型~list$oL の長さ ~NEQ %argcount
◎
Remove from S all entries whose type list is not of length argcount.
</li>
	<li>
~IF［
%S は空である
］
⇒
~throwTypeError
◎
If S is empty, then throw a TypeError.
</li>
	<li>
%d ~LET 0
◎
Initialize d to −1.
</li>
	<li>
%method ~LET `undefined^jv
◎
Initialize method to undefined.
</li>
	<li>
~IF［
%S を成す~entryは複数個ある
］
⇒
%d ~SET それらの~entryの`判別~引数~index$
◎
If there is more than one entry in S, then set d to be the distinguishing argument index for the entries of S.
</li>
	<li>
%値~list ~LET 空~list（`~Web~IDL引数~list$）
◎
Initialize values to be an empty list, where each entry will be either an IDL value or the special value “missing”.
</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %d ~MINUS 1 } )
に対し，昇順に：
◎
Initialize i to 0.
◎
While i &lt; d:
</p>
		<ol>
			<li>
%V ~LET %args[ %i ]
◎
Let V be args[i].
</li>
			<li>
<p>
%型 ~LET ［
%S から~~任意に選んだ~entry
］の`型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of any entry in S.
</p>

<p class="note">注記：
この時点では、
%S 内のすべての~entryにわたり，
`型~list$oL[ %i ] は互いに同じ, かつ
`省略可否~list$oL[ %i ] は互いに同じである。
◎
Note: All entries in S at this point have the same type and optionality value at index i.
</p>
			</li>
			<li>
%省略可否 ~LET ［
%S から~~任意に選んだ~entry
］の`省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of any entry in S.
</li>
			<li id="cp-if-optional">
~IF［
%省略可否 ~EQ “`省略可^C”
］~AND［
%V ~EQ `undefined^jv
］
⇒
%値~list に `既定~値？^C を付加する
◎
If optionality is “optional” and V is undefined, then:
• If the argument at index i is declared with a default value, then append to values that default value.
• Otherwise, append to values the special value “missing”.
</li>
			<li id="cp-append-convert1">
~ELSE
⇒
%値~list に［
%V を型 %型 の`~IDL値に変換-$した結果
］を付加する
◎
Otherwise, append to values the result of converting V to IDL type type.
◎
Set i to i + 1.
</li>
		</ol>

<p class="trans-note">【
`既定~値？^C
— 原文のこの段では、~index %i に位置する引数の`既定~値$について取扱っているが、その引数が
%S 内のどの~entryの`~callable$oLに属するのかは，この時点では決定できない。
既定~値の有無，その値は、~entryごとに異なるかもしれない。
そのため、ここでは暫定的な値 `既定~値？^C を導入し，その取扱いを後の段に先送りしている。
】</p>

	</li>
	<li>
<div>

<p>
%entry ~LET 次の下位手続きを走らせた結果：
</p>
		<ol>
			<li>
~IF［
%S は 1 個の~entryのみからなる
］
⇒
~RET その~entry
◎
If i = d, then:
</li>
			<li>
<p>
%V ~LET %args[ %d ]
◎
Let V be args[i].
</p>
<p class="note">注記：
この引数が、多重定義を解決するために利用される。
◎
Note: This is the argument that will be used to resolve which overload is selected.
</p>
			</li>
			<li>
~IF［
%V ~EQ `undefined^jv
］~AND［
%S 内の~entryに［
`省略可否~list$oL[ %d ] ~EQ “`省略可^C”
］なるものが在る
］
⇒
~RET 該当する~entry†
◎
If V is undefined, and there is an entry in S whose list of optionality values has “optional” at index i, then remove from S all other entries.
</li>
			<li>
~ELIF［［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%S 内の~entryに［
その `型~list$oL[ %d ] は `~nullable型を内包する$
］ものは在る
］
⇒
~RET 該当する~entry†
◎
↓↓</li>
			<li>
<p>
下に示す “多重定義~選別表” の
~EACH( %行 )
に対し，挙げられた順に：
</p>
				<ol>
					<li>
~IF［
%V は %行 の 1 列目の条件を満たさない
］
⇒
~CONTINUE
</li>
					<li>
%型~集合 ~LET %行 の 2 列目に挙げられる型の集合
</li>
					<li>
<p>
~IF［
%S 内の~entryに［
その `型~list$oL[ %d ] の`最内縁の型$ %T は、次のいずれかを満たす
］ものは在る
］…：
</p>

<ul ><li>%T は %型~集合 に属する
</li><li>
［
%T は`共用体~型$である
］~AND［
%T の`平坦~化~mb型$の中に %型~集合 に属するものが在る
］
</li></ul>

<p>
…ならば：
</p>
						<ol>
							<li>
<p>
~IF［
%行 は表内の `(A)^i が付与された行である
］：
</p>
								<ol>
									<li>
%method ~SET
~ABRUPT `GetMethod$A( %V, `iterator$jS )
</li>
									<li>
~IF［
%method ~EQ `undefined^jv
］
⇒
~CONTINUE
</li>
								</ol>
							</li>
							<li>
~RET 該当する~entry††
</li>
						</ol>
					</li>
				</ol>

◎
↓</li>
			<li>
~throwTypeError
◎
↓</li>
		</ol>

<p class="trans-note">【†
いずれの場合も、 %S （`有効~多重定義~集合$）に課される拘束,
%d （`判別~引数~index$）の定義により，該当する~entryは 1 個に限られる。
】【††
下の表のどの行についても、 2 列目に挙げられた型たちは，どの 2 つも互いに`判別-可能$でない。
したがってこれも † と同様に、どの行についても， %S 内で条件を満たす~entryは高々 1 個になる。
】【
簡潔するため，この段では、原文の記述を再構成して，上の下位手続きと下の “多重定義~選別表” に集約している。
】</p>

</div>

<table>
<caption>多重定義~選別表</caption>
<col span="1" style="width:50%;"><col>
<thead><tr><th>%V が満たす条件
<th>%型~集合
</thead><tbody>

<tr><td>
%V ~IN { `null^jv, `undefined^jv }
◎
Otherwise: if V is null or undefined, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`辞書~型$
◎
• a nullable type
• a dictionary type
• an annotated type whose inner type is one of the above types
• a union type or annotated union type that includes a nullable type or that has a dictionary type in its flattened members
◎
then remove from S all other entries.

<tr><td>
`~platform~objである$
◎
Otherwise: if V is a platform object, and there is an entry in S that has one of the following types at position i of its type list,
<td>
%V が`実装-$する`~ifc型$, `object$T
◎
• an interface type that V implements
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Type$A( %V ) ~EQ `Object^jt
］~AND［
%V は `ArrayBufferData^sl `内部~slot$を持つ
］
◎
Otherwise: if Type(V) is Object, V has an [[ArrayBufferData]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`ArrayBuffer$T, `object$T
◎
• ArrayBuffer
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Type$A( %V ) ~EQ `Object^jt
］~AND［
%V は `DataView^sl `内部~slot$を持つ
］
◎
Otherwise: if Type(V) is Object, V has a [[DataView]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`DataView$T, `object$T
◎
• DataView
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Type$A( %V ) ~EQ `Object^jt
］~AND［
%V は `TypedArrayName^sl `内部~slot$を持つ
］
◎
Otherwise: if Type(V) is Object, V has a [[TypedArrayName]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
［
型~名が %V の `TypedArrayName^sl `内部~slot$に等しい `有型~配列~型$
］, `object$T
◎
• a typed array type whose name is equal to the value of V’s [[TypedArrayName]] internal slot
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`IsCallable$A( %V ) ~EQ ~T
◎
Otherwise: if IsCallable(V) is true, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`~callback関数~型$, `object$T
◎
• a callback function type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>`(A)^i：
`Type$A( %V ) ~EQ `Object^jt
◎
Otherwise: if Type(V) is Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`連列~型$, `凍結d配列~型$
◎
• a sequence type
• a frozen array type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
and after performing the following steps,
• Let method be ? GetMethod(V, @@iterator).
◎
method is not undefined, then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
◎
Otherwise: if Type(V) is Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`~callback~ifc$型, `辞書~型$, `~record型$, `object$T
◎
• a callback interface type
• a dictionary type
• a record type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Boolean^jt
◎
Otherwise: if Type(V) is Boolean and there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Number^jt
◎
Otherwise: if Type(V) is Number and there is an entry in S that has one of the following types at position i of its type list,
<td>
`数量-型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`文字列~型$
◎
• a string type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`数量-型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
<td>
`any$T
◎
Otherwise: if there is an entry in S that has any at position i of its type list, then remove from S all other entries.
◎
↑↑Otherwise: throw a TypeError.

</tbody></table>

	</li>
	<li>
%callable ~LET %entry の`~callable$oL （ `演算$／`拡張属性$ ）
◎
Let callable be the operation or extended attribute of the single entry in S.
</li>
	<li>
<p>
~IF［
%method ~NEQ `undefined^jv
］：
【！ GOTO により “If i = d” は不要】
◎
If i = d and method is not undefined, then
</p>
		<ol>
			<li>
%V ~LET %args[ %d ]
◎
Let V be args[i].
</li>
			<li>
%T ~LET %entry の `型~list$oL[ %d ]
◎
Let T be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%値~list に %T に応じて，次の結果を付加する
⇒＃
`連列~型$であるならば， ( %V, %method ) から 型 %T の`連列~値を作成-$した結果／
`凍結d配列~型$であるならば， ( %V, %method ) から型 %T の`凍結d配列~値を作成-$した結果
◎
If T is a sequence type, then append to values the result of creating a sequence of type T from V and method.
◎
Otherwise, T is a frozen array type. Append to values the result of creating a frozen array of type T from V and method.
</li>
			<li>
%d ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
<p>
~EACH( %i ~IN { %d 〜 %argcount ~MINUS 1 } )
に対し，昇順に：
◎
While i &lt; argcount:
</p>
		<ol>
			<li>
%V ~LET %args[ %i ]
◎
Let V be args[i].
</li>
			<li>
%型 ~LET %entry の `型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%省略可否 ~LET %entry の `省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of the remaining entry in S.
</li>
			<!--cp-if-optional-->
			<!--cp-append-convert1-->
		</ol>
	</li>
	<li>
%引数~宣言~list ~LET %callable の各~引数~宣言からなる同順の`~list$
◎
↓</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %引数~宣言~list の`~size$ ~MINUS 1 } )
に対し，昇順に：
</p>

<p class="trans-note">【
上で言及した `既定~値？^C を取扱うため、この段は［
%i を %argcount からではなく 0 から反復する
］などの手を加えている。
】</p>

		<ol>
			<li>
%値 ~LET ［
%引数~宣言~list[ %i ] は`既定~値$を伴うならば その既定~値 ／
~ELSE_ `missing$C
］
</li>
			<li>
~IF［
%i ~LT %argcount
］
⇒
~IF［
%値~list[ %i ] ~EQ `既定~値？^C
］
⇒
%値~list[ %i ] ~SET %値
</li>
			<li>
~ELIF［
%引数~宣言~list[ %i ] は`可変個~引数$でない
］
⇒
%値~list に %値 を付加する
</li>
		</ol>

◎
While i is less than the number of arguments callable is declared to take:
• If callable’s argument at index i is declared with a default value, then append to values that default value.
• Otherwise, if callable’s argument at index i is not variadic, then append to values the special value “missing”.
• Set i to i + 1.
</li>
	<li>
~RET ~pair &lt;%callable, %値~list&gt;
◎
Return the pair &lt;callable, values&gt;.
</li>
</ol>
</div>

<div class="note">

<p>
多重定義~解決~algoは、~callされている［
多重定義された`関数類$
］の識別に加えて、
~ES引数~値から，それぞれに対応する~IDL値への変換を遂行する。
非正式には次のように演算する。
◎
The overload resolution algorithm performs both the identification of which overloaded operation, constructor, etc. is being called, and the conversion of the ECMAScript argument values to their corresponding IDL values. Informally, it operates as follows.
</p>

<p>
まず、関数に渡された~ES引数の個数を考慮しつつ，妥当な多重定義の選定が行われる：
◎
First, the selection of valid overloads is done by considering the number of ECMAScript arguments that were passed in to the function:
</p>
	<ul>
		<li>
最長の多重定義~引数~listより多い引数が渡された場合、余分な引数は無視する。
◎
If there are more arguments passed in than the longest overload argument list, then they are ignored.
</li>
		<li>
考慮する必要があるのは、余分な引数を無視した後の引数の個数, および同じ個数の引数をとれる多重定義に限られる。
もし無ければ， `TypeError^jE が投出される。
◎
After ignoring these trailing arguments, only overloads that can take this exact number of arguments are considered. If there are none, then a TypeError is thrown.
</li>
	</ul>

<p>
~~正しい個数の引数をとる，アリな多重定義の集合が得られたなら、
~ES値は左から右の順に変換される。
多重定義に対する制約の定義から、この時点でアリな多重定義が複数ある場合、引数~listの中で，最終的に選定される多重定義を判別する際の~~基準となる位置がある。
これが`判別~引数~index$である。
◎
Once we have a set of possible overloads with the right number of arguments, the ECMAScript values are converted from left to right. The nature of the restrictions on overloading means that if we have multiple possible overloads at this point, then there will be one position in the argument list that will be used to distinguish which overload we will finally select; this is the distinguishing argument index.
</p>

<p>
まず最初に，判別~引数より左に位置する引数を変換する（これらの引数については、同じ~indexに位置する他の多重定義の引数と同じ型であることが要件にされている）。
【！判別~引数~indexまで到達したなら、】
次に，対応し得る~IDL型を決定するため、判別~引数~indexの位置に渡された~ES値の型を検分する。
これにより、呼出されることになる多重定義の最終的な選定が可能になる。
渡された値が `undefined^jv で，この位置に随意~引数を伴う多重定義がある場合、その多重定義が選定される。
このとき，渡された値の型に対する妥当な多重定義が無ければ、 `TypeError^jE が投出される。
判別~引数~indexに位置する値の検分は副作用を持たない。
多重定義~解決~algoを走らすことに因る唯一の副作用は、
~ES値から~IDL値への変換-に因るものに限られる。
◎
We first convert the arguments to the left of the distinguishing argument. (There is a requirement that an argument to the left of the distinguishing argument index has the same type as in the other overloads, at the same index.) Then we inspect the type of the ECMAScript value that is passed in at the distinguishing argument index to determine which IDL type it may correspond to. This allows us to select the final overload that will be invoked. If the value passed in is undefined and there is an overload with an optional argument at this position, then we will choose that overload. If there is no valid overload for the type of value passed in here, then we throw a TypeError. The inspection of the value at the distinguishing argument index does not have any side effects; the only side effects that come from running the overload resolution algorithm are those that come from converting the ECMAScript values to IDL values.
</p>

<p>
この時点で，利用する多重定義が決定されたことになる。
しかる後、判別~引数に後続する残りの引数~値も左から右の順に変換する。
ここでも，前述の余分な引数は、無視される。
◎
At this point, we have determined which overload to use. We now convert the remaining arguments, from the distinguishing argument onwards, again ignoring any additional arguments that were ignored due to being passed after the last possible argument.
</p>

<p>
随意~引数の~ES値からそれに等価な~IDL値へ変換する際には、
`undefined^jv は，［
随意~引数に`既定~値$が在ればそれに／
無ければ `missing$C に
］変換されることになる。
◎
When converting an optional argument’s ECMAScript value to its equivalent IDL value, undefined will be converted into the optional argument’s default value, if it has one, or a special value “missing” otherwise.
</p>

<p>
しかしながら、`可変個~引数$に対応する【暗黙的な】随意~引数に対する `undefined^jv は， `missing$C とは見なされない。
この場合の `undefined^jv 値は、必須の引数と同様に，`可変個~引数$の型に変換されることになる。
◎
Optional arguments corresponding to a final, variadic argument do not treat undefined as a special “missing” value, however. The undefined value is converted to the type of variadic argument as would be done for a non-optional argument.
</p>
</div>

		</section>
		<section id="es-interfaces">
<h3 title="Interfaces">3.6. ~ifc</h3>

<p>
所与の`~Realm$ %R 内に`公開されて$いる，どの`~ifc$ %I に対しても：
◎
↓</p>

<ul>
	<li>
<p>
%I が［
`NoInterfaceObject$x, `LegacyNamespace$x
］いずれの`拡張属性$も伴わずに宣言されているならば、
%I に対応して，次の特徴を有する~propが %R の`大域~obj$上に存在する：
◎
For every interface that is exposed in a given Realm and that is not declared with the [NoInterfaceObject] or [LegacyNamespace] extended attributes, a corresponding property exists on the Realm's global object.＼
</p>
		<ul>
			<li>
名前：
%I の`識別子$
◎
The name of the property is the identifier of the interface, and＼
</li>
			<li>
値：
`~ifc~obj@
と呼ばれる~obj
— この~objの特徴については、下の
`interface-object$sec
にて述べる。
◎
its value is an object called the interface object. The characteristics of an interface object are described in § 3.6.1 Interface object.
</li>
		</ul>
	</li>
	<li>
<p id="_legacy-window-alias">
%I に `LegacyWindowAlias$x 拡張属性が指定されている場合、その拡張属性~内の各`識別子$wAに対し， 
`Window$T 大域~obj上に［
次の特徴を有する，対応する~prop
］が存在する：
◎
If the [LegacyWindowAlias] extended attribute was specified on an exposed interface, then for each identifier in [LegacyWindowAlias]'s identifiers there exists a corresponding property on the Window global object.＼
</p>
		<ul>
			<li>
名前：
その`識別子$wA
◎
The name of the property is the given identifier, and＼
</li>
			<li>
値：
%I 用の`~ifc~obj$への参照
◎
its value is a reference to the interface object for the interface.
</li>
		</ul>
	</li>
	<li>
<p>
加えて，
%I に `NamedConstructor$x 拡張属性たちが伴われるならば、そのそれぞれに対し，次の特徴を有する~propが %R の大域~obj上に存在する：
◎
In addition, for every [NamedConstructor] extended attribute on an exposed interface, a corresponding property exists on the ECMAScript global object.＼
</p>
		<ul>
			<li>
名前：
`NamedConstructor$x 拡張属性の`識別子$nC
◎
The name of the property is the [NamedConstructor]'s identifier, and＼
</li>
			<li>
値：
`有名~構築子@
と呼ばれる~obj
— それは、 %I を実装する~objの構築を可能にする。
この構築子の特徴については、下の
`named-constructors$sec
にて述べる。
◎
its value is an object called a named constructor, which allows construction of objects that implement the interface. The characteristics of a named constructor are described in § 3.6.2 Named constructors.
</li>
		</ul>
	</li>
</ul>

			<section id="interface-object">
<h4 title="Interface object">3.6.1. ~ifc~obj</h4>

<p>
所与の`~ifc$ %I 用の`~ifc~obj$ %O は、`組込みの関数~obj$である：
◎
The interface object for a given interface is a built-in function object.＼
</p>

<ul>
	<li>
%O は、
%I 上に定義される各［
`定数$／`静的~演算$
］ごとに対応する~propを持つ
— 詳細は
`es-constants$sec,
`es-operations$sec
にて述べる。
◎
It has properties that correspond to the constants and static operations defined on that interface, as described in sections § 3.6.5 Constants and § 3.6.7 Operations.
</li>
	<li>
%I は`構築子~演算$を伴って宣言されている場合、
%O を`構築子$として~callして， %I を`実装-$する~objを作成できる。
%I を関数として~callした場合、例外が投出される。
◎
If the interface is declared with a constructor operation, then the interface object can be called as a constructor to create an object that implements that interface. Calling that interface as a function will throw an exception.
</li>
	<li>
%I は`構築子~演算$を伴わずに宣言されている場合、`構築子$として~callしようが関数として~callしようが，例外が投出される。
◎
Interface objects whose interfaces are not declared with a constructor operation will throw when called, both as a function and as a constructor.
</li>
	<li>
%O には`~ifc原型~obj$と呼ばれる~objが結付けられる
— それは、 %I 上に定義される各［
`正則~属性$ ／ `正則~演算$
］ごとに対応する~propを持つ
— 詳細は
`interface-prototype-object$sec
にて述べる。
◎
An interface object for an interface has an associated object called the interface prototype object. This object has properties that correspond to the regular attributes and regular operations defined on the interface, and is described in more detail in § 3.6.3 Interface prototype object.
</li>
</ul>

<p class="note">注記：
`~ifc~obj$は `関数~obj$なので、
`typeof^op 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since an interface object is a function object the typeof operator will return "function" when applied to an interface object.
</p>

<p>
~ifcは、対応する`~ifc~obj$が［
~callされる／構築される
］ときの挙動を変更できる
`構築子を上書きする手続き@
を備えてもヨイ。
既定では、~ifcは，そのような手続きを備えない。
◎
An interface may have overridden constructor steps, which can change the behavior of the interface object when called or constructed. By default interfaces do not have such steps.
</p>

<p class="advisement">
一般に，構築子は、`構築子~演算$, その挙動を定義することにより述べられる。
`構築子を上書きする手続き$は、もっと複雑な状況に限り利用される。
この特能を利用したいと望む編集者には、先に進む前に
`Intent to use constructor steps$fI
した上で論交することを，強く勧める。
◎
In general, constructors are described by defining a constructor operation and its behavior. The overridden constructor steps are used only for more complicated situations. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<div class="algorithm">
<p>
`~ifc$用の`~ifc~obj$は、以下に従って作成される
—
`~ifc~objを作成する@
ときは、所与の
( `~ifc$ %I, `識別子$ %識別子, `~Realm$ %~realm )
に対し，次を走らす：
◎
The interface object for a given interface I with identifier id and in Realm realm is created as follows:
</p>

<ol>
	<li>
<p>
%手続き ~LET ［
%I は`構築子を上書きする手続き$を備えるならば それ／
~ELSE_ 次に与える手続き
］
◎
Let steps be I’s overridden constructor steps if they exist, or the following steps otherwise:
</p>
		<ol>
			<li>
~IF［
%I は`構築子~演算$を伴って宣言されていない
］
⇒
~throwTypeError
◎
If I was not declared with a constructor operation, then throw a TypeError.
</li>
			<li id="cp-throw-undef-NewTarget">
~IF［
`NewTarget$ ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If NewTarget is undefined, then throw a TypeError.
</li>
			<li id="cp-let-args-0-n-1">
%args ~LET 渡された引数たちからなる~list
◎
Let args be the passed arguments.
</li>
			<!--cp-let-n-args-size-->
			<li>
%S ~LET %I 上の構築子~用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Let id be the identifier of interface I. 原文削除漏れ
◎
Compute the effective overload set for constructors with identifier id on interface I and with argument count n, and let S be the result.
</li>
			<li id="cp-resolve-overload">
&lt;%構築子, %値~list&gt; ~LET
( %S, %args )
を`多重定義~解決~algo$に渡した結果
◎
Let &lt;constructor, values&gt; be the result of passing S and args to the overload resolution algorithm.
</li>
			<li id="cp-internally-creating-new">
%~obj ~LET `~ifcを実装する新たな~objを作成する$( %I, %~realm, `NewTarget$ )
◎
Let object be the result of internally creating a new object implementing I, with realm and NewTarget.
</li>
			<li id="cp-perform-constructor-actions">
［
%構築子 の記述に挙げられている動作
］を［
`this$V として %~obj
］, ［
引数~list %値~list
］を与える下で遂行する
◎
Perform the actions listed in the description of constructor with values as the argument values and object as this.
</li>
			<li id="cp-O-toES-I">
%O ~LET %~obj を`~ES値に変換-$した結果
◎
Let O be object, converted to an ECMAScript value.
</li>
			<li id="cp-assert-O-implements-I">
~Assert：
%O は %I を`実装-$する~objである
◎
Assert: O is an object that implements I.
</li>
			<li id="cp-assert-O-realm-is-I">
~Assert：
%O.`Realm^sl ~EQ %~realm
◎
Assert: O.[[Realm]] is realm.
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
	<li>
%構築子~原型 ~LET %~realm.`FunctionPrototype$jIsl
◎
Let constructorProto be realm.[[Intrinsics]].[[%FunctionPrototype%]].
</li>
	<li>
~IF［
%I は他の~ifc %P を継承する
］
⇒
%構築子~原型 ~SET %~realm に属する %P 用の`~ifc~obj$
◎
If I inherits from some other interface P, then set constructorProto to the interface object of P in realm.
</li>
	<li>
%F ~LET
~NOABRUPT `CreateBuiltinFunction$A( %手続き, « `Unforgeables^sl », %~realm, %構築子~原型 )
◎
Let F be ! CreateBuiltinFunction(steps, « [[Unforgeables]] », realm, constructorProto).
</li>
	<li>
%偽造-不能~obj ~LET `ObjectCreate$A( `null^jv )
◎
Let unforgeables be ObjectCreate(null).
</li>
	<li>
`偽造-不能な正則~演算を定義する$( %I, %偽造-不能~obj, %~realm )
◎
Define the unforgeable regular operations of I on unforgeables, given realm.
</li>
	<li>
`偽造-不能な正則~属性を定義する$( %I, %偽造-不能~obj, %~realm )
◎
Define the unforgeable regular attributes of I on unforgeables, given realm.
</li>
	<li>
<p>
%F.`Unforgeables^sl ~SET %偽造-不能~obj
◎
Set F.[[Unforgeables]] to unforgeables.
</p>

<p class="note">注記：
この~objは、利用者~codeには決して公開されず，次を確保するために限り存在する
⇒
偽造-不能な~mbを伴う~ifcのすべて~instanceは、［
`属性~取得子を作成する$／`属性~設定子を作成する$／`演算~関数を作成する$
］のそれぞれに対し，同じ~JS関数~objを利用する
◎
Note: this object is never exposed to user code. It exists only to ensure all instances of an interface with an unforgeable member use the same JavaScript function objects for attribute getters, attribute setters and operation functions.
</p>
	</li>
	<li id="cp-SetFunctionName-F-id">
~NOABRUPT `SetFunctionName$A( %F, %識別子 )
◎
Perform ! SetFunctionName(F, id).
</li>
	<li>
%長さ ~LET 0
◎
Let length be 0.
</li>
	<li>
<p>
~IF［
%I は`構築子~演算$を伴って宣言されている
］：
◎
If I was declared with a constructor operation, then
</p>
		<ol>
			<li>
%S ~LET %I 上の構築子~用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for constructors with identifier id on interface I and with argument count 0, and let S be the result.
</li>
			<li>
%長さ ~SET %S 内の各~entryの引数~listの長さのうち，最小
◎
Set length to the length of the shortest argument list of the entries in S.
</li>
		</ol>
	</li>
	<li id="cp-SetFunctionLength-F-length">
~NOABRUPT `SetFunctionLength$A( %F, %長さ )
◎
Perform ! SetFunctionLength(F, length).
</li>
	<li>
%proto ~LET `~ifc原型~objを作成する$( %I, %~realm )
◎
Let proto be the result of creating an interface prototype object of interface I in realm.
</li>
	<li id="cp-DefinePropertyOrThrow-F-proto">
~NOABRUPT `DefinePropertyOrThrow$A( %F, `prototype^l, `FFF-proto^desc )
◎
Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: proto, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).
</li>
	<li>
`定数を定義する$( %I, %F, %~realm )
◎
Define the constants of interface I on F given realm.
</li>
	<li>
`静的~属性を定義する$( %I, %F, %~realm )
◎
Define the static attributes of interface I on F given realm.
</li>
	<li>
`静的~演算を定義する$( %I, %F, %~realm )
◎
Define the static operations of interface I on F given realm.
</li>
	<li id="cp-ret-F">
~RET %F
◎
Return F.
</li>
</ol>
</div>

			</section>
			<section id="named-constructors">
<h4 title="Named constructors">3.6.2. 有名~構築子</h4>

<p>
`有名~構築子$は、`識別子$nCを伴う 1 個~以上の
`NamedConstructor$x `拡張属性$に因り存在することになる，`組込みの関数~obj$である。
それは、その拡張属性が現れる`~ifc$（以下 %I とする）を実装する~objの構築を可能にする。
◎
A named constructor that exists due to one or more [NamedConstructor] extended attributes with a given identifier is a built-in function object. It allows constructing objects that implement the interface on which the [NamedConstructor] extended attributes appear.
</p>

<div class="algorithm">
<p>
`~ifc$用の`有名~構築子$は、以下に従って作成される
—
`有名~構築子を作成する@
ときは、所与の
( `~ifc$ %I, `識別子$ %識別子, `~Realm$ %~realm )
に対し，次を走らす：
◎
The named constructor with identifier id for a given interface I in Realm realm is created as follows:
</p>

<ol>
	<li>
%識別子 ~LET `有名~構築子$の`識別子$nC
◎
↑</li>
	<li>
<p id="cp-let-steps">
%手続き ~LET 次に与える手続き：
◎
Let steps be the following steps:
</p>
		<ol>
			<!--cp-throw-undef-NewTarget-->
			<!--cp-let-args-0-n-1-->
			<!--cp-let-n-args-size-->
			<li>
%S ~LET %I 上の有名~構築子~用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Compute the effective overload set for named constructors with identifier id on interface I and with argument count n, and let S be the result.
</li>
			<!--cp-resolve-overload-->
			<!--cp-internally-creating-new-->
			<!--cp-perform-constructor-actions-->
			<!--cp-O-toES-I-->
			<!--cp-assert-O-implements-I-->
			<!--cp-assert-O-realm-is-I-->
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
	<li id="cp-CreateBuiltinFunction">
%F ~LET
~NOABRUPT `CreateBuiltinFunction$A( %手続き, « », %~realm )
◎
Let F be ! CreateBuiltinFunction(steps, « », realm).
</li>
	<!--cp-SetFunctionName-F-id-->
	<li>
%S ~LET %I 上の有名~構築子~用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for named constructors with identifier id on interface I and with argument count 0, and let S be the result.
</li>
	<li>
%長さ ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list of the entries in S.
</li>
	<!--cp-SetFunctionLength-F-length-->
	<li>
%proto ~LET %~realm 内で %I を成す`~ifc原型~obj$
◎
Let proto be the interface prototype object of interface I in realm.
</li>
	<!--cp-DefinePropertyOrThrow-F-proto-->
	<!--cp-ret-F-->
</ol>
</div>

			</section>
			<section id="interface-prototype-object">
<h4 title="Interface prototype object">3.6.3. ~ifc原型~obj</h4>

<p>
定義されたどの`~ifc$に対しても、その~ifcが `NoInterfaceObject$x `拡張属性$を伴って宣言されたかどうかに関わらず，対応する
`~ifc原型~obj@
が存在することになる。
◎
There will exist an interface prototype object for every interface defined, regardless of whether the interface was declared with the [NoInterfaceObject] extended attribute.
</p>

<div class="algorithm">
<p>
`~ifc原型~objを作成する@
ときは、所与の
( `~ifc$ %~ifc, `~Realm$ %~realm )
に対し，次を走らす
— これは、`~ifc原型~obj$を作成して返す：
◎
The interface prototype object for a given interface interface and Realm realm is created as follows:
</p>

<ol>
	<li>
%原型 ~LET ~NULL
◎
Let proto be null.
</li>
	<li>
~IF［
%~ifc は `Global$x `拡張属性$を伴って宣言されている
］~AND［
%~ifc は`有名~propを~support$する
］
⇒
%原型 ~SET `有名~prop~objを作成する$( %~ifc, %~realm )
◎
If interface is declared with the [Global] extended attribute, and interface supports named properties, then set proto to the result of creating a named properties object for interface and realm.
</li>
	<li>
~ELIF［
%~ifc は別の~ifc %B を`継承-$するように宣言されている
］
⇒
%原型 ~SET %~realm 内の %B 用の`~ifc原型~obj$
◎
Otherwise, if interface is declared to inherit from another interface, then set proto to the interface prototype object in realm of that inherited interface.
</li>
	<li>
~ELIF［
%~ifc は `DOMException$T `~ifc$である
］
⇒
%原型 ~SET %~realm.`ErrorPrototype$jIsl
◎
Otherwise, if interface is the DOMException interface, then set proto to realm.[[Intrinsics]].[[%ErrorPrototype%]].
</li>
	<li id="cp-else-set-proto-realm">
~ELSE
⇒
%原型 ~SET %~realm.`ObjectPrototype$jIsl
◎
Otherwise, set proto to realm.[[Intrinsics]].[[%ObjectPrototype%]].
</li>
	<li>
~Assert：
`Type$A( %原型 ) ~EQ `Object^jt
◎
Assert: Type(proto) is Object.
</li>
	<li>
%~ifc原型~obj ~LET
~NOABRUPT `ObjectCreate$A( %原型 )
◎
Let interfaceProtoObj be ! ObjectCreate(proto).
</li>
	<li>
<p>
~IF［
%~ifc のある`~mb$は `Unscopable$x `拡張属性$を伴って宣言されている
］：
◎
If interface has any member declared with the [Unscopable] extended attribute, then:
</p>

<p class="issue">
%~ifc は `Global$x `拡張属性$を伴って宣言されている場合、
`toStringTag$jS ~propも定義されるべきか？
これは
`issue #544＠https://github.com/heycam/webidl/issues/544$href
にて論じられている。
◎
Should an @@unscopables property also be defined if interface is declared with the [Global] extended attribute? This is discussed in issue #544.
</p>
		<ol>
			<li>
%~scope不能~obj ~LET
~NOABRUPT `ObjectCreate$A( `null^jv )
◎
Let unscopableObject be the result of performing ! ObjectCreate(null).
</li>
			<li>
<p>
%~ifc に`公開されて$いる, かつ
`Unscopable$x `拡張属性$を伴って宣言されている
~EACH( `~mb$ %~mb )
に対し：
◎
For each exposed member member of interface that is declared with the [Unscopable] extended attribute:
</p>
				<ol>
					<li>
%識別子 ~LET %~mb の`識別子$
◎
Let id be member’s identifier.
</li>
					<li>
~NOABRUPT `CreateDataProperty$A( %~scope不能~obj, %識別子, `true^jv )
◎
Perform ! CreateDataProperty(unscopableObject, id, true).
</li>
				</ol>
			</li>
			<li>
%記述子 ~LET `FFT-~scope不能~obj^desc
◎
Let desc be the PropertyDescriptor{[[Value]]: unscopableObject, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~ifc原型~obj, `toStringTag$jS, %記述子 )
◎
Perform ! DefinePropertyOrThrow(interfaceProtoObj, @@unscopables, desc).
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~ifc は `Global$x `拡張属性$を伴って宣言されている
］~OR［
%~ifc は ある［
`Global$x `拡張属性$を伴って宣言されている~ifc
］が`継承した~ifcたち$である
］：
◎
If interface is declared with the [Global] extended attribute, or interface is in the set of inherited interfaces of an interface that is declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
%~ifc原型~obj を成す［
`変異-不能な原型~exotic~obj$に特有な内部~methたち
］を［
`変異-不能な原型~exotic~obj$節に指定される定義たち
］に設定する
◎
Set the internal methods of interfaceProtoObj which are specific to immutable prototype exotic objects to the definitions specified in ECMA-262 Immutable prototype exotic objects.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~ifc は `Global$x `拡張属性$を伴って宣言されていない
］：
◎
If interface is not declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
`正則~属性を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the regular attributes of interface on interfaceProtoObj given realm.
</li>
			<li>
`正則~演算を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the regular operations of interface on interfaceProtoObj given realm.
</li>
		</ol>
	</li>
	<li>
`定数を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the constants of interface on interfaceProtoObj given realm.
</li>
	<li>
<p>
~IF［
%~ifc には `NoInterfaceObject$x `拡張属性$は指定されていない
］：
◎
If the [NoInterfaceObject] extended attribute was not specified on interface, then:
</p>
		<ol>
			<li>
%構築子 ~LET %~realm 内で %~ifc を成す`~ifc~obj$
◎
Let constructor be the interface object of interface in realm.
</li>
			<li>
%記述子 ~LET `TFT-構築子^desc
◎
Let desc be the PropertyDescriptor{[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true, [[Value]]: constructor}.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~ifc原型~obj, `constructor^l, %記述子 )
◎
Perform ! DefinePropertyOrThrow(interfaceProtoObj, "constructor", desc).
</li>
		</ol>
	</li>
	<li>
~RET %~ifc原型~obj
◎
Return interfaceProtoObj.
</li>
</ol>

</div>

<p>
加えて，`~ifc原型~obj$は、次に挙げるものから宣言的に~propを取得する
⇒＃
`es-stringifier$sec,
`es-iterators$sec,
`es-iterable$sec,
`es-maplike$sec,
`es-setlike$sec
◎
Additionally, interface prototype objects get properties declaratively from:
• § 3.6.7.2 Stringifiers,
• § 3.6.8 Common iterator behavior,
• § 3.6.9 Iterable declarations,
• § 3.6.10 Maplike declarations, and
• § 3.6.11 Setlike declarations.
</p>

<p class="issue" id="cp-issue-imperatively">
これらの~propを，代わりに命令的に定義する。
◎
Define those properties imperatively instead.
</p>

<div class="note">
<p>
`NoInterfaceObject$x `拡張属性$を伴って定義された`~ifc$用の`~ifc原型~obj$は、~access可能になる。
例えば、次の~IDLでは：
◎
The interface prototype object of an interface that is defined with the [NoInterfaceObject] extended attribute will be accessible. For example, with the following IDL:
</p>

<pre class="webidl">
[Exposed=Window,
 NoInterfaceObject]
interface Foo {
};

partial interface Window {
  attribute Foo foo;
};
</pre>

<p>
`~ifc~obj$を通して ~ifc原型~objに~accessすることはアリでない（ `window.Foo^c として存在しないので）。
しかしながら， `Foo^T の~instanceは、その `GetPrototypeOf^sl `内部~meth$を~callすること
— この例では， `Object.getPrototypeOf(window.foo)^c —
により，~ifc原型~objを公開できる。
◎
it is not possible to access the interface prototype object through the interface object (since it does not exist as window.Foo). However, an instance of Foo can expose the interface prototype object by calling its [[GetPrototypeOf]] internal method – Object.getPrototypeOf(window.foo) in this example.
</p>

</div>

<p>
`~ifc原型~obj$の`~class文字列$は、次の連結とする
⇒＃
`~ifc$の`有修飾~名$,
文字列 `Prototype^l
◎
The class string of an interface prototype object is the concatenation of the interface’s qualified name and the string "Prototype".
</p>

			</section>
			<section id="named-properties-object">
<h4 title="Named properties object">3.6.4. 有名~prop~obj</h4>

<p>
`Global$x `拡張属性$を伴って宣言されていて, かつ
`有名~propを~support$する
どの`~ifc$に対しても、その~ifcに対応する
`有名~prop~obj@
と呼ばれる~objが，当の有名~propが公開される~ifc上に存在することになる。
◎
For every interface declared with the [Global] extended attribute that supports named properties, there will exist an object known as the named properties object for that interface on which named properties are exposed.
</p>

<div class="algorithm">
<p>
`有名~prop~objを作成する@
ときは、所与の
( `~ifc$ %~ifc, `~Realm$ %~realm )
に対し，次を走らす
— これは、`有名~prop~obj$を作成して返す：
◎
The named properties object for a given interface interface and Realm realm, is created as follows:
</p>

<ol>
	<li>
%原型 ~LET ~NULL
◎
Let proto be null.
</li>
	<li>
~IF［
%~ifc は別の~ifc %B を`継承-$するように宣言されている
］
⇒
%原型 ~SET %~realm 内の %B 用の`~ifc原型~obj$
◎
If interface is declared to inherit from another interface, then set proto to the interface prototype object in realm for the inherited interface.
</li>
	<!--cp-else-set-proto-realm-->
	<li>
%~obj ~LET 新たな~obj
◎
Let obj be a newly created object.
</li>
	<li>
<p>
%~obj を成す各 内部~methを［
`ECMA-262$r の`普通の~objの内部~methと内部~slot$節
］に指定される定義に設定する
— 次に指定するものは別として
⇒＃
%~obj.`Prototype^sl ~SET %原型；
%~obj.`Extensible^sl ~SET `true^jv
◎
Set obj’s internal methods to the definitions specified in ECMA-262 Ordinary object internal methods and internal slots, unless they are specified in the the rest of § 3.6.4 Named properties object.
◎
Set obj’s remaining internal methods to the definitions specified below.
• Set obj.[[Prototype]] to proto.
• Set obj.[[Extensible]] to true.
</li>
	<li>
~RET %~obj
◎
Return obj.
</li>
</ol>

</div>

<p>
`有名~prop~obj$の`~class文字列$は、次の連結とする
⇒＃
`~ifc$の`識別子$,
文字列 `Properties^l
◎
The class string of a named properties object is the concatenation of the interface’s identifier and the string "Properties".
</p>

				<section id="named-properties-object-getownproperty">
<h5>3.6.4.1. `GetOwnProperty^sl</h5>

<div class="algorithm">
<p>
`有名~prop~obj$ %O の `GetOwnProperty^sl 内部~methが ~prop名 %P を伴って~callされたときは、次を走らす：
◎
When the [[GetOwnProperty]] internal method of a named properties object O is called with property key P, the following steps are taken:
</p>

<ol>
	<li>
%A ~LET %O 用の`~ifc$
◎
Let A be the interface for the named properties object O.
</li>
	<li>
%object ~LET %O.`Realm^sl の`大域~obj$
◎
Let object be O.[[Realm]]'s global object.
</li>
	<li>
~Assert：
%object は %A を`実装-$する
◎
Assert: object implements A.
</li>
	<li>
<p>
~IF［
`有名~propは可視か？$( %P, %object ) ~EQ ~T
］：
◎
If the result of running the named property visibility algorithm with property name P and object object is true, then:
</p>
		<ol>
			<li>
%演算 ~LET `有名~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<li id="cp-let-uninitialized">
%値 ~LET ε
◎
Let value be an uninitialized variable.
</li>
			<li id="cp-determine-ifndef">
~IF［
%演算 は `識別子$なしに定義されている
］
⇒
%値 ~SET ［
~ifcの記述に挙げられている`有名~propの値を決定する$手続き
］を
( 名前 %P )
を与える下で遂行した結果
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of a named property with P as the name.
</li>
			<li id="cp-set-as-desc1">
~ELSE
⇒
%値 ~SET ［
%演算 の記述に挙げられている手続き
］を［
引数~list « %P »
］を与える下で遂行した結果
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with P as the only argument value.
</li>
			<li>
<p>
~RET 次のようにされた新たな`~pdesc$
⇒
`TET-V^desc
— ここで：
</p>
				<ul>
					<li id="cp-let-convert2">
%V は %値 を`~ES値に変換-$した結果
</li>
					<li>
%E は ［
%A が`実装-$する ある~ifcは `LegacyUnenumerableNamedProperties$x `拡張属性$を伴うならば `false^jv ／
~ELSE_ `true^jv
］
</li>
				</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If A implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Writable]] to true and desc.[[Configurable]] to true.
◎
Return desc.
</li>
		</ol>
	</li>
	<li id="cp-return-OrdinaryGetOwnProperty">
~RET
`OrdinaryGetOwnProperty$A( %O, %P )
◎
Return OrdinaryGetOwnProperty(O, P).
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-defineownproperty">
<h5>3.6.4.2. `DefineOwnProperty^sl</h5>

<div class="algorithm">
<p>
`有名~prop~obj$の `DefineOwnProperty^sl 内部~methが~callされたときは、次を走らす：
◎
When the [[DefineOwnProperty]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol>
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-delete">
<h5>3.6.4.3. `Delete^sl</h5>

<div class="algorithm">
<p>
`有名~prop~obj$の `Delete^sl 内部~methが~callされたときには，次を走らす：
◎
When the [[Delete]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol>
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-setprototypeof">
<h5>3.6.4.4. `SetPrototypeOf^sl</h5>

<div class="algorithm">
<p>
`有名~prop~obj$ %O の `SetPrototypeOf^sl 内部~methが，~ES言語~値 %V で~callされたときは、次を走らす：
◎
When the [[SetPrototypeOf]] internal method of a named properties object O is called with ECMAScript language value V, the following step is taken:
</p>

<ol id="cp-SetImmutablePrototype">
	<li>
~RET
~ABRUPT `SetImmutablePrototype$A( %O, %V )
◎
Return ? SetImmutablePrototype(O, V).
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-preventextensions">
<h5>3.6.4.5. `PreventExtensions^sl</h5>

<div class="algorithm">
<p>
`有名~prop~obj$の `PreventExtensions^sl 内部~methが~callされたときは、次を走らす：
◎
When the [[PreventExtensions]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol>
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>
</div>

<p class="note">注記:
これにより、`有名~prop~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps named properties object extensible by making [[PreventExtensions]] fail.
</p>
				</section>
			</section>
			<section id="es-constants">
<h4 title="Constants">3.6.5. 定数</h4>

<p>
`定数$は［
`~ifc~obj$ ／ `旧来の~callback~ifc~obj$ ／ `~ifc原型~obj$
］上に
— 当の~ifcは `Global$x `拡張属性$を伴って宣言されているときには，~ifcを`実装-$する単独の~obj上に —
公開される。
◎
Constants are exposed on interface objects, legacy callback interface objects, interface prototype objects, and on the single object that implements the interface, when an interface is declared with the [Global] extended attribute.
</p>

<div class="algorithm">
<p>
`定数を定義する@
ときは、所与の
( `~ifc$または`~callback~ifc$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the constants of interface or callback interface definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
<p>
%定義 を成す`~mb$のうち，`定数$である
~EACH( %定数 )
に対し：
◎
For each constant const that is a member of definition:
</p>
		<ol>
			<li>
~IF［
%定数 は%~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If const is not exposed in realm, then continue.
</li>
			<li>
%値 ~LET %定数 の~IDL値を`~ES値に変換-$した結果
◎
Let value be the result of converting const’s IDL value to an ECMAScript value.
</li>
			<li>
%記述子 ~LET `FTF-値^desc
◎
Let desc be the PropertyDescriptor{[[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false, [[Value]]: value}.
</li>
			<li>
%識別子 ~LET %定数 の`識別子$
◎
Let id be const’s identifier.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
		</ol>
	</li>
</ol>

</div>

			</section>
			<section id="es-attributes">
<h4 title="Attributes">3.6.6. 属性</h4>

<p>
`静的~属性$は、`~ifc~obj$上に公開される。
`正則~属性$は、`~ifc原型~obj$上に公開される
— ただし，［
属性は`偽造-不能$である／
当の~ifcは `Global$x `拡張属性$を伴って宣言されている
］事例では、その~ifcを`実装-$する どの~objにも公開される。
◎
Static attributes are exposed on the interface object. Regular attributes are exposed on the interface prototype object, unless the attribute is unforgeable or if the interface was declared with the [Global] extended attribute, in which case they are exposed on every object that implements the interface.
</p>

<div class="algorithm">
<p>
`正則~属性を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the regular attributes of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%属性たち ~LET ［
%定義 を成す`~mb$のうち，`正則~属性$である, かつ
`偽造-不能$でないもの
］からなる`~list$
◎
Let attributes be the list of regular attributes that are members of definition.
◎
Remove from attributes all the attributes that are unforgeable.
</li>
	<li id="cp-define-attr">
`属性を定義する$( %属性たち, %定義, %~target, %~realm )
◎
Define the attributes attributes of definition on target given realm.
</li>
</ol>

</div>

<div class="algorithm">
<p>
`静的~属性を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the static attributes of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%属性たち ~LET ［
%定義 を成す`~mb$のうち，`静的~属性$であるもの
］からなる`~list$
◎
Let attributes be the list of static attributes that are members of definition.
</li>
	<!--cp-define-attr-->
</ol>

</div>

<div class="algorithm">
<p>
`偽造-不能な正則~属性を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the unforgeable regular attributes of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%属性たち ~LET ［
%定義 を成す`~mb$のうち，`正則~属性$である, かつ
`偽造-不能$であるもの
］からなる`~list$
◎
Let attributes be the list of unforgeable regular attributes that are members of definition.
</li>
	<!--cp-define-attr-->
</ol>

</div>

<div class="algorithm">
<p>
`属性を定義する@
ときは、所与の
( %属性たち, `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the attributes attributes of interface or namespace definition on target given Realm realm, run the following steps:
</p>

<ol>
	<li>
<p>
%属性たち を成す
~EACH( `属性$ %属性 )
に対し：
◎
For each attribute attr of attributes:
</p>
		<ol>
			<li>
~IF［
%属性 は %~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If attr is not exposed in realm, then continue.
</li>
			<li>
%取得子 ~LET `属性~取得子を作成する$( %属性, %定義, %~realm )
◎
Let getter be the result of creating an attribute getter given attr, definition, and realm.
</li>
	<li>
<p>
%設定子 ~LET `属性~設定子を作成する$( %属性, %定義, %~realm )
◎
Let setter be the result of creating an attribute setter given attr, definition, and realm.
</p>

<p class="note">注記：
`属性~設定子を作成する$~algoは、
%属性 は`読専$である場合には `undefined^jv を返す。
◎
Note: the algorithm to create an attribute setter returns undefined if attr is read only.
</p>
	</li>
	<li>
%~configure可能 ~LET ［
%属性 は`偽造-不能$であるならば `false^jv ／
~ELSE_ `true^jv
］
◎
Let configurable be false if attr is unforgeable and true otherwise.
</li>
	<li>
%記述子 ~LET {
[[Get]]: %取得子,
[[Set]]: %設定子,
[[Enumerable]]: `true^jv,
[[Configurable]]: %~configure可能
}
◎
Let desc be the PropertyDescriptor{[[Get]]: getter, [[Set]]: setter, [[Enumerable]]: true, [[Configurable]]: configurable}.
</li>
	<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be attr’s identifier.
</li>
	<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">
<p>
`属性~取得子を作成する@
ときは、所与の
( `属性$ %属性, ［`~ifc$／`~ns$］ %target, `~Realm$ %~realm )
に対し，次を走らす：
◎
The attribute getter is created as follows, given an attribute attribute, a namespace or interface target, and a Realm realm:
</p>

<ol>
	<li>
<p>
%手続き ~LET 以下を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps:
◎
Try running the following steps:
</p>
		<ol>
			<li id="cp-let-idlObject-null">
%~idl~obj ~LET `null^V
◎
Let idlObject be null.
</li>
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%属性 は`正則~属性$である
］：
◎
If target is an interface, and attribute is a regular attribute:
</p>
				<ol>
					<li id="cp-let-esValue-this-or-global">
<p>
%~es値 ~LET ［
`this^jv 値 ~NIN { `null^jv, `undefined^jv } ならば `this^jv 値 ／
~ELSE_ %~realm の`大域~obj$
］
</p>

<p>
（この大域~objが %target を実装しない, かつ
`LenientThis$x は指定されていない場合、数~段~先で `TypeError^jE が生じることになる。）
</p>
◎
Let esValue be the this value, if it is not null or undefined, or realm’s global object otherwise. (This will subsequently cause a TypeError in a few steps, if the global object does not implement target and [LenientThis] is not specified.)
</li>
					<li>
~IF［
%~es値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~es値, %属性 の`識別子$, `取得子^C )
◎
If esValue is a platform object, then perform a security check, passing esValue, attribute’s identifier, and "getter".
</li>
					<li>
<p>
~IF［
%~es値 は %target を`実装-$しない
］：
◎
If esValue does not implement target, then:
</p>
						<ol>
							<li>
~IF［
%属性
`LenientThis$x `拡張属性$が指定されている
］
⇒
~RET `undefined^jv
◎
If attribute was specified with the [LenientThis] extended attribute, then return undefined.
</li>
							<li>
~ELSE
⇒
~throwTypeError
◎
Otherwise, throw a TypeError.
</li>
							<li id="cp-set-idlObject-ifc">
%~idl~obj ~SET %~es値 への参照を表現する，~IDL`~ifc型$の値
◎
Set idlObject to the IDL interface type value that represents a reference to esValue.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%R ~LET `属性の下層~値を取得する$( %~idl~obj, %属性 )
◎
Let R be the result of getting the underlying value of attribute given idlObject.
</li>
			<li>
~RET %R を
%属性 に宣言されている型から`~ES値に変換-$した結果
◎
Return the result of converting R to an ECMAScript value of the type attribute is declared as.
</li>
		</ol>

<p id="cp-if-E-thrown">
上で`例外が投出された$ときは、その例外 %E に対し：
◎
And then, if an exception E was thrown:
</p>
		<ol>
			<li>
~IF［
%属性 の型は`~promise型$である
］
⇒
~RET
~NOABRUPT `Call$A( `Promise_reject$jI, `Promise$jI, « %E » )
◎
If attribute’s type is a promise type, then return ! Call(%Promise_reject%, %Promise%, «E»).
</li>
			<li id="cp-throw-E">
~ELSE
⇒
`~THROW$ %E
◎
Otherwise, end these steps and allow the exception to propagate.
</li>
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<li>
%name ~LET 次の連結
⇒＃
文字列 `get^l,
`0020^U ~SPACE,
%属性 の`識別子$
◎
Let name be the string "get " prepended to attribute’s identifier.
</li>
	<li id="cp-SetFunctionName-name-F">
~NOABRUPT `SetFunctionName$A( %F, %name )
◎
Perform ! SetFunctionName(F, name).
</li>
	<li id="cp-SetFunctionLength-F-0">
~NOABRUPT `SetFunctionLength$A( %F, 0 )
◎
Perform ! SetFunctionLength(F, 0).
</li>
	<!--cp-ret-F-->
</ol>
</div>

<div class="algorithm">
<p>
`属性~設定子を作成する@
ときは、所与の
( `属性$ %属性, `~ns$または`~ifc$ %target, `~Realm$ %~realm )
に対し，次を走らす：
◎
The attribute setter is created as follows, given an attribute attribute, a namespace or interface target, and a Realm realm:
</p>

<ol>
	<li>
<p>
~IF［
%target は`~ns$である
］：
◎
If target is a namespace:
</p>
		<ol>
			<li>
~Assert：
%属性 は`読専$である
◎
Assert: attribute is read only.
</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
	<li>
~IF［
%属性 は`読専$である
］~AND［
%属性 は［
`LenientSetter$x, `PutForwards$x, `Replaceable$x
］いずれの`拡張属性$も伴わない
］
⇒
~RET `undefined^jv
— `属性~設定子$ 関数はない。
◎
If attribute is read only and does not have a [LenientSetter], [PutForwards] or [Replaceable] extended attribute, return undefined; there is no attribute setter function.
</li>
	<li>
~Assert：
%属性 の型は`~promise型$でない
◎
Assert: attribute’s type is not a promise type.
</li>
	<li>
<p>
%手続き ~LET 以下を走らす手続き：
◎
Let steps be the following series of steps:
</p>
		<ol>
			<li>
~IF［
渡された引数の個数 ~EQ 0
］
⇒
~throwTypeError
◎
If no arguments were passed, then throw a TypeError.
</li>
			<li>
%V ~LET 渡された最初の引数の値
◎
Let V be the value of the first argument passed.
</li>
			<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be attribute’s identifier.
</li>
			<!--cp-let-idlObject-null-->
			<li>
<p>
~IF［
%属性 は`正則~属性$である
］：
◎
If attribute is a regular attribute:
</p>
				<ol>
					<!--cp-let-esValue-this-or-global-->
					<li>
~IF［
%~es値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~es値, %識別子, `設定子^C )
◎
If esValue is a platform object, then perform a security check, passing esValue, id, and "setter".
</li>
					<li>
%validThis ~LET ［
%~es値 は %target を`実装-$するならば ~T ／
~ELSE_ ~F
］
◎
Let validThis be true if esValue implements target, or false otherwise.
</li>
					<li>
~IF［
%validThis ~EQ ~F
］~AND［
%属性 には `LenientThis$x `拡張属性$は指定されていない
］
⇒
~throwTypeError
◎
If validThis is false and attribute was not specified with the [LenientThis] extended attribute, then throw a TypeError.
</li>
					<li>
<p>
~IF［
%属性 は `Replaceable$x 拡張属性を伴って宣言されている
］：
◎
If attribute is declared with the [Replaceable] extended attribute, then:
</p>
						<ol>
							<li>
~ABRUPT `CreateDataProperty$A( %~es値, %識別子, %V )
◎
Perform ? CreateDataProperty(esValue, id, V).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
					<li>
~IF［
%validThis ~EQ ~F
］
⇒
~RET `undefined^jv
◎
If validThis is false, then return undefined.
</li>
					<li>
~IF［
%属性 は `LenientSetter$x 拡張属性を伴って宣言されている
］
⇒
~RET `undefined^jv
◎
If attribute is declared with a [LenientSetter] extended attribute, then return undefined.
</li>
					<li>
<p>
~IF［
%属性 は `PutForwards$x 拡張属性を伴って宣言されている
］：
◎
If attribute is declared with a [PutForwards] extended attribute, then:
</p>
						<ol>
							<li>
%Q ~LET
~ABRUPT `Get$A( %~es値, %識別子 )
◎
Let Q be ? Get(esValue, id).
</li>
							<li>
~IF［
`Type$A( %Q ）~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(Q) is not Object, then throw a TypeError.
</li>
							<li>
%forwardId ~LET `PutForwards$x 拡張属性の識別子~引数
◎
Let forwardId be the identifier argument of the [PutForwards] extended attribute.
</li>
							<li>
~ABRUPT `Set$A( %Q, %forwardId, %V, `true^jv )
◎
Perform ? Set(Q, forwardId, V, true).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
					<!--cp-set-idlObject-ifc-->
				</ol>
			</li>
			<li>
%~idl値 ~LET ε
◎
Let idlValue be determined as follows:
</li>
			<li>
<p>
~IF［
%属性 の型 は`列挙$である
］：
◎
attribute’s type is an enumeration
</p>
				<ol>
					<li>
%S ~LET
~ABRUPT `ToString$A( %V )
◎
Let S be ? ToString(V).
</li>
					<li>
~IF［
%S は `列挙~値$のいずれでもない
］
⇒
~RET `undefined^jv
◎
If S is not one of the enumeration’s values, then return undefined.
</li>
					<li>
%~idl値 ~SET %S に等しい列挙~値
◎
Otherwise, idlValue is the enumeration value equal to S.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~idl値 ~SET %V を%属性 の型の`~IDL値に変換-$した結果
◎
Otherwise
• idlValue is the result of converting V to an IDL value of attribute’s type.
</li>
			<li>
［
%属性 の記述に挙げられている設定-時に生じる動作
］を［
`所与の値$として %~idl値
］, ［
%~idl~obj ~NEQ `null^V ならば `this$V として %~idl~obj
］を与える下で遂行する
◎
Perform the actions listed in the description of attribute that occur on setting, with idlValue as the given value and idlObject as this if it is not null.
</li>
			<li>
~RET `undefined^jv
◎
Return undefined
</li>
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<li>
%name ~LET 次の連結
⇒＃
文字列 `set^l,
`0020^U ~SPACE,
%識別子
◎
Let name be the string "set " prepended to id.
</li>
	<!--cp-SetFunctionName-name-F-->
	<li>
~NOABRUPT `SetFunctionLength$A( %F, 1 )
◎
Perform ! SetFunctionLength(F, 1).
</li>
	<!--cp-ret-F-->
</ol>
</div>

<p class="note">注記：
ある~IDL属性に対応する~propは 1 個に限られるが、~accessor~propの［
取得子／設定子
］には［
当の~propが~accessされた~obj
］を指す `this$V 値が渡されるので、それらの［
取得子／設定子
］は，~instanceに特有な~dataを公開できる。
◎
Note: Although there is only a single property for an IDL attribute, since accessor property getters and setters are passed a this value for the object on which property corresponding to the IDL attribute is accessed, they are able to expose instance-specific data.
</p>

<p class="note">注記：
`読専$な`属性$に対応する~propへ代入しようと試みた結果の挙動は、それを行う~scriptが~strict-modeであるかどうかに依存して異なる。
~strict-modeならば， `TypeError^jE が投出され、そうでないならば，代入の試みは無視されることになる。
◎
Note: Attempting to assign to a property corresponding to a read only attribute results in different behavior depending on whether the script doing so is in strict mode. When in strict mode, such an assignment will result in a TypeError being thrown. When not in strict mode, the assignment attempt will be ignored.
</p>

			</section>
			<section id="es-operations">
<h4 title="Operations">3.6.7. 演算</h4>

<p>
［
`~ifc$上に定義され, `公開されて$いる`演算$
］の各 一意な`識別子$ごとに，対応する~propが存在する。
`静的~演算$は、`~ifc~obj$上に公開される。
`正則~演算$は、`~ifc原型~obj$上に公開される
— ただし，［
演算は`偽造-不能$である ／
当の~ifcは `Global$x `拡張属性$を伴って宣言されている
］事例では、~ifcを`実装-$する どの~obj上にも公開される。
◎
For each unique identifier of an exposed operation defined on the interface, there exist a corresponding property. Static operations are exposed of the interface object. Regular operations are exposed on the interface prototype object, unless the operation is unforgeable or the interface was declared with the [Global] extended attribute, in which case they are exposed on every object that implements the interface.
</p>

<div class="algorithm">
<p>
`正則~演算を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the regular operations of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%演算たち ~LET ［
%定義 を成す`~mb$のうち，`正則~演算$である, かつ
`偽造-不能$でないもの
］からなる`~list$
◎
Let operations be the list of regular operations that are members of definition.
◎
Remove from operations all the operations that are unforgeable.
</li>
	<li id="cp-define-op">
`演算を定義する$( %演算たち, %定義, %~target, %~realm )
◎
Define the operations operations of definition on target given realm.
</li>
</ol>

</div>

<div class="algorithm">
<p>
`静的~演算を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the static operations of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%演算たち ~LET ［
%定義 を成す`~mb$のうち，`静的~演算$であるもの
］からなる`~list$
◎
Let operations be the list of static operations that are members of definition.
</li>
	<!--cp-define-op-->
</ol>

</div>

<div class="algorithm">
<p>
`偽造-不能な正則~演算を定義する@
ときは、所与の
( `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the unforgeable regular operations of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
%演算たち ~LET ［
%定義 を成す`~mb$のうち，`正則~演算$である, かつ
`偽造-不能$であるもの
］からなる`~list$
◎
Let operations be the list of unforgeable regular operations that are members of definition.
</li>
	<!--cp-define-op-->
</ol>

</div>

<div class="algorithm">
<p>
`演算を定義する@
ときは、所与の
( %演算たち, `~ifc$／`~ns$ %定義, %~target, `~Realm$ %~realm )
に対し，次を走らす：
◎
To define the operations operations of interface or namespace definition on target, given Realm realm, run the following steps:
</p>

<ol>
	<li>
<p>
%演算たち を成す
~EACH( `演算$ %演算 )
に対し：
◎
For each operation op of operations:
</p>

		<ol>
			<li>
~IF［
%演算 は %~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If op is not exposed in realm, then continue.
</li>
			<li>
%~meth ~LET `演算~関数を作成する$( %演算, %定義, %~realm )
◎
Let method be the result of creating an operation function given op, definition, and realm.
</li>
			<li>
%M ~LET ［
%演算 は`偽造-不能$であるならば `false^jv ／
~ELSE_ `true^jv
］
◎
Let modifiable be false if op is unforgeable and true otherwise.
</li>
			<li>
%記述子 ~LET `MTM-method^desc
◎
Let desc be the PropertyDescriptor{[[Value]]: method, [[Writable]]: modifiable, [[Enumerable]]: true, [[Configurable]]: modifiable}.
</li>
			<li>
%識別子 ~LET %演算 の`識別子$
◎
Let id be op’s identifier.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">
<p>
`演算~関数を作成する@
ときは、所与の
( `演算$ %op, `~ns$または`~ifc$ %target, `~Realm$ %~realm )
に対し：
◎
To create an operation function, given an operation op, a namespace or interface target, and a Realm realm:
</p>

<ol>
	<li>
%識別子 ~LET %op の`識別子$
◎
Let id be op’s identifier.
</li>
	<li>
<p>
%手続き ~LET 所与の
( 関数~引数~list %args )
に対し，次を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps, given function argument values args:
◎
Try running the following steps:
</p>
		<ol>
			<!--cp-let-idlObject-null-->
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%op は`静的~演算$でない
］：
◎
If target is an interface, and op is not a static operation:
</p>
				<ol>
					<!--cp-let-esValue-this-or-global-->
					<li>
~IF［
%~es値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~es値, %識別子, `~meth^C )
◎
If esValue is a platform object, then perform a security check, passing esValue, id, and "method".
</li>
					<li>
~IF［
%~es値 は ~ifc %target を`実装-$しない
］
⇒
~throwTypeError
◎
If esValue does not implement the interface target, throw a TypeError.
</li>
					<!--cp-set-idlObject-ifc-->
				</ol>
			</li>
			<!--cp-let-n-args-size-->
			<li>
<p>
%S ~LET %target 上の［
%op が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Compute the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count n, and let S be the result.
</li>
			<li>
&lt;%演算, %値~list&gt; ~LET
( %S, %args )
を`多重定義~解決~algo$に渡した結果
◎
Let &lt;operation, values&gt; be the result of passing S and args to the overload resolution algorithm.
</li>
			<li>
%R ~LET ~NULL
◎
Let R be null.
</li>
			<li>
~IF［
%演算 は `Default$x 拡張属性を伴って宣言されている
］
⇒
%R ~SET ［
%演算 に`対応する既定の演算$に挙げられている動作
］を［
`this$V として %~idl~obj
］, ［
引数~list %値~list
］を与える下で遂行した結果
◎
If operation is declared with a [Default] extended attribute, then:
• Set R be the result of performing the actions listed in operation’s corresponding default operation, with values as the argument values and idlObject as this if it is not null.
</li>
			<li>
<p>
~ELSE
⇒
%R ~SET［
%演算 の記述に挙げられている動作
］を［
%~idl~obj ~NEQ `null^V ならば `this$V として %~idl~obj
］, ［
引数~list %値~list
］を与える下で遂行した結果
◎
Otherwise:
• Set R be the result of performing the actions listed in the description of operation, with values as the argument values and idlObject as this if it is not null.
</li>
			<li>
<p>
~RET %R を`~ES値に変換-$した結果
◎
Return R, converted to an ECMAScript value.
</p>

<p class="issue">
%R は %op の返り値に宣言された型の~IDL値と見做される。
`issue #674＠https://github.com/heycam/webidl/issues/674$href
◎
R is assumed to be an IDL value of the type op is declared to return. &lt;https://github.com/heycam/webidl/issues/674&gt;
</p>
			</li>
		</ol>

<!--cp-if-E-thrown-->
		<ol>
			<li>
~IF［
%op の`返り値~型$は `~promise型$である
］
⇒
~RET 
~NOABRUPT `Call$A( `Promise_reject$jI, `Promise$jI, « %E » )
◎
If op has a return type that is a promise type, then return ! Call(%Promise_reject%, %Promise%, «E»).
</li>
			<!--cp-throw-E-->
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<li>
%S ~LET %target 上の［
%op が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］用の`有効~多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count 0, and let S be the result.
</li>
	<li>
%長さ ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list in the entries in S.
</li>
	<!--cp-SetFunctionLength-F-length-->
	<!--cp-ret-F-->
</ol>
</div>

				<section id="es-default-operations">
<h5 title="Default operations">3.6.7.1. 既定の演算</h5>

<p>
`Default$x `拡張属性$を宣言してよい`正則~演算$は、下に定義される
`対応する既定の演算@
持つものに限られる。
【現時点では、~toJSONしかない。】
◎
Only regular operations which have a corresponding default operation defined below may be declared with a [Default] extended attribute.
</p>

					<section id="es-default-tojson">
<h6 title="Default toJSON operation">3.6.7.1.1. 既定の~toJSON演算</h6>

<p>
~toJSON演算に`対応する既定の演算$は、`既定の~toJSON演算$で与えられる。
◎
The corresponding default operation of the toJSON operation is the default toJSON operation.
</p>

<p>
`既定の~toJSON演算$の`返り値~型$は、
`object$T でなければナラナイ。
◎
The return type of the default toJSON operation must be object.
</p>

<div class="algorithm">
<p>
`~ifc$ %I の
`既定の~toJSON演算@
を呼出すときは、次の手続きを走らす：
◎
To invoke the default toJSON operation of interface I, run the the following steps:
</p>

<ol>
	<li>
%~map ~LET 新たな`有順序~map$
◎
Let map be a new ordered map.
</li>
	<li>
%~stack ~LET `継承~stackを作成する$( %I )
◎
Let stack be the result of creating an inheritance stack for interface I.
</li>
	<li>
`継承~stackの属性~値を収集する$( `this$V, %~stack, %~map )
◎
Invoke collect attribute values of an inheritance stack on this, passing it stack and map as arguments.
</li>
	<li>
%結果 ~LET
~NOABRUPT `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let result be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<p>
%~map 内の
~EACH( %~key → %値 )
に対し：
◎
For each key → value of map,
</p>
		<ol>
			<li>
%k ~LET %~key を`~ES値に変換-$した結果
◎
Let k be key converted to an ECMAScript value.
</li>
			<li>
%v ~LET %値 を`~ES値に変換-$した結果
◎
Let v be value converted to an ECMAScript value.
</li>
			<li>
~NOABRUPT `CreateDataProperty$A( %結果, %k, %v )
◎
Perform ! CreateDataProperty(result, k, v).
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`継承~stackの属性~値を収集する@
抽象-演算は、所与の
( %this, `~stack$ %~stack, `有順序~map$ %~map )
に対し，次を走らす：
◎
To invoke the collect attribute values of an inheritance stack abstract operation with stack stack and ordered map map as arguments, run the the following steps:
</p>

<ol>
	<li>
%I ~LET %~stack から`~popする$
◎
Let I be the result of popping from stack.
</li>
	<li>
`属性~値を収集する$( %this, %I, %~map )
◎
Invoke collect attribute values on this, passing it I and map as arguments.
</li>
	<li>
~IF［
%~stack は`空$でない
］
⇒
`継承~stackの属性~値を収集する$( %this, %~stack, %~map )
◎
If stack is not empty, then invoke collect attribute values of an inheritance stack on this, passing it stack and map as arguments.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`属性~値を収集する@
抽象-演算は、所与の
( %this, `~ifc$ %I, `有順序~map$ %~map )
に対し，次を走らす：
◎
To invoke the collect attribute values abstract operation with interface I and ordered map map as arguments, run the the following steps:
</p>

<ol>
	<li>
<p>
~IF［
%I 上に［
`Default$x `拡張属性$を伴う~toJSON演算
］は宣言されている
］
⇒
%I を成す`~ifc~mb$のうち，`公開されて$いる, かつ`正則~属性$である
~EACH( %属性 )
に対し：
◎
If a toJSON operation with a [Default] extended attribute is declared on I, then for each exposed regular attribute attr that is an interface member of I, in order:
</p>
		<ol>
			<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be the identifier of attr.
</li>
			<li>
%値 ~LET `属性の下層~値を取得する$( %this, %属性 )
◎
Let value be the result of getting the underlying value of attr given this.
</li>
			<li>
~IF［
%値 は`~JSON型$である
］
⇒
%~map[ %識別子 ] ~SET %値
◎
If value is a JSON type, then set map[id] to value.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">

<p>
`継承~stackを作成する@
ときは、所与の
( `~ifc$ %I )
に対し，次を走らす
⇒
~RET `~cloneする$( `~stack$としての［
%I の`自身も含む継承した~ifcの~list$
］ )
◎
To create an inheritance stack for interface I, run the the following steps:
• Let stack be a new stack.
• Push I onto stack.
• While I inherits from an interface,
•• Let I be that interface.
•• Push I onto stack.
• Return stack.
</p>

</div>

<div class="example">

<p>
下に与える`~IDL片$は、`~ifc$ `A^T が`継承した~ifcたち$, および［
`A^T, または `A^T が`継承した~ifcたち$
］に`内包-$されている`~ifc~mixin$たちを成す，いくつかの`~ifc$を定義する
— 次の継承~treeに示されるような：
◎
The following IDL fragment defines a number of interfaces, which are inherited interfaces of A, and interface mixins, which are included by A or by A’s inherited interfaces, as show in the below inheritance tree.
</p>

<pre>
     C* - M4
     |
     B - M3
     |
M1 - A - M2*
</pre>

<p>
`*^c が付与されている［
`~ifc$／`~ifc~mixin$
］は、
`Default$x `拡張属性$を伴う~toJSON`演算$を宣言する。
◎
Interfaces and interface mixins marked with an asterisk ("*") declare a toJSON operation with a [Default] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface A : B {
  attribute DOMString a;
};

[Exposed=Window]
interface B : C {
  attribute DOMString b;
};

[Exposed=Window]
interface C {
  [Default] object toJSON();
  attribute DOMString c;
};

interface mixin M1 {
  attribute DOMString m1;
};

interface mixin M2 {
  [Default] object toJSON();
  attribute DOMString m2;
};

interface mixin M3 {
  attribute DOMString m3;
};

interface mixin M4 {
  attribute DOMString m4;
};

A includes M1;
A includes M2;
B includes M3;
C includes M4;
</pre>

<p>
上に定義した~ifc `A^T を実装している~obj上で `toJSON()^M を~methを~callした場合、次のような~JSON~objを返すことになる：
◎
Calling the toJSON() method of an object implementing interface A defined above would return the following JSON object:
</p>

<pre class="es-code">
{
    "a": "...",
    "m1": "...",
    "m2": "...",
    "c": "...",
    "m4": "..."
}
</pre>

<p>
~ifc `B^T を実装している~objでは、次のような~JSON~objを返すことになる：
◎
An object implementing interface B would return:
</p>

<pre class="es-code">
{
    "c": "...",
    "m4": "..."
}
</pre>

</div>

					</section>
				</section>
				<section id="es-stringifier">
<h5 title="Stringifiers">3.6.7.2. 文字列化子</h5>

<div class="p">

<p>
`~ifc$に`公開されて$いる`文字列化子$ %文字列化子 がある場合、次の特徴を有する~propが存在するモノトスル：
</p>

<ul>
	<li>
名前：
`toString^l
</li>
	<li>
値：
下に与える`組込みの関数~obj$ %F
</li>
	<li>
属性 `BTB^desc を持つ。
ここで %B は［
%文字列化子 が~ifc上で`偽造-不能$である場合は `false^jv ／
~ELSE_ `true^jv
］とする。
</li>
</ul>

<p>
~propの所在は：
</p>

<ul>
	<li>
%文字列化子 が~ifc上で`偽造-不能$であるか, または
~ifcが `Global$x 拡張属性を伴って宣言されているならば、~ifcを`実装-$するどの~obj上にも存在する。
</li>
	<li>
他の場合、~ifc用の`~ifc原型~obj$上に存在する。
</li>
</ul>

◎
If the interface has an exposed stringifier, then there must exist a property with the following characteristics:
• The name of the property is "toString".
• If the stringifier is unforgeable on the interface or if the interface was declared with the [Global] extended attribute, then the property exists on every object that implements the interface. Otherwise, the property exists on the interface prototype object.
• The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the stringifier is unforgeable on the interface, and true otherwise.
• The value of the property is a built-in function object,＼
</div>

<div class="algorithm">
<p>
~prop値 %F は、被呼出時には次に従って挙動するモノトスル：
◎
which behaves as follows:
</p>

<ol>
	<li>
%O ~LET `this^jv 値~上で `ToObject$A を~callした結果
◎
Let O be the result of calling ToObject on the this value.
</li>
	<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, %文字列化子 の`識別子$, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the stringifier, and
• the type "method".
</li>
	<li>
~IF［
%O は %文字列化子 を宣言する~ifcを`実装-$しない
］
⇒
~throwTypeError
◎
If O does not implement the interface on which the stringifier was declared, then throw a TypeError.
</li>
	<li>
%V ~LET ε
◎
Let V be an uninitialized variable.
</li>
	<li>
<p>
`stringifier^sym がどこに指定されているかに応じて：
◎
Depending on where stringifier was specified:
</p>
		<dl class="switch">
			<dt>
`属性$上
◎
on an attribute
</dt>
			<dd>
%V ~SET ［［
その属性が`取得子を継承する$ものと宣言されている場合は 継承されている属性 ／
~ELSE_ その属性
］の記述に挙げられている，取得-時に生じる動作
］を［
`this$V として %O
］を与える下で遂行した結果
◎
Set V to the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</dd>

			<dt>
識別子を伴う`演算$上
◎
on an operation with an identifier
</dt>
			<dd>
%V ~SET［
その演算の記述に挙げられている動作
］を［
`this$V 値として %O,
引数~list « »
］を与える下で遂行した結果
◎
Set V to the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</dd>
			<dt>
識別子を伴わない`演算$上
◎
on an operation with no identifier
</dt>
			<dd>
%V ~SET ~ifcの`文字列~化の挙動$を遂行した結果
◎
Set V to the result of performing the stringification behavior of the interface.
</dd>
		</dl>
	</li>
	<li>
~RET
%V を `String^jt 型の`~ES値に変換-$した結果
◎
Return the result of converting V to a String value.
</li>
</ol>
</div>

<p id="cp-length-is-0">
この`関数~obj$の `length^jp ~propの値は、
`Number^jt 値 `0^jv とする。
◎
The value of the function object’s length property is the Number value 0.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `toString^l とする。
◎
The value of the function object’s name property is the String value "toString".
</p>

				</section>
			</section>
			<section id="es-iterators">
<h4 title="Common iterator behavior">3.6.8. 反復子に共通な挙動</h4>

				<section id="es-iterator">
<h5 title="@@iterator">3.6.8.1. `iterator^jS</h5>

<p>
所与の`~ifc$が，次のいずれかを持つならば…
⇒＃
`可反復~宣言$／
`有index~prop取得子$／
`~maplike 宣言$／
`~setlike 宣言$
◎
If the interface has any of the following:
• an iterable declaration
• an indexed property getter
• a maplike declaration
• a setlike declaration
</p>

<div class="p">
<p>
…次の特徴を有する~propが存在するモノトスル：
</p>

<ul>
	<li>
名前：
`iterator^jS ~symbol
</li>
	<li id="cp-value-is-a-func-F">
値：
下に与える`関数~obj$ %F
</li>
	<li id="cp-has-attr-TFT">
属性 `TFT^desc を持つ。
</li>
</ul>

◎
then a property must exist whose name is the @@iterator symbol, with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is a function object.
</div>

<div id="cp-proploc">
<p>
~propの所在は、次に従って決定される：
◎
The location of the property is determined as follows:
</p>

<ul>
	<li>
当の~ifcは `Global$x `拡張属性$を伴って宣言されているならば、~ifcを`実装-$する単独の~obj上に存在する。
◎
If the interface was declared with the [Global] extended attribute, then the property exists on the single object that implements the interface.
</li>
	<li>
他の場合、もっぱら~ifc用の`~ifc原型~obj$上に存在する。
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</li>
</ul>
</div>

<p id="cp-F-is-given-as-follows">
~prop値 %F は、次で与えられる：
◎
↓</p>

<dl class="switch">
	<dt>
~ifcに `有index~prop取得子$が定義されている場合：
◎
If the interface defines an indexed property getter, then＼
</dt>
	<dd>
`ArrayProto_values$jI 。
◎
the function object is %ArrayProto_values%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd class="algorithm">
<p id="cp-built-in-F-must-behave-as">
%F は`組込みの関数~obj$であり、被呼出時には次に従って挙動するモノトスル：
◎
the function object is a built-in function object that, when invoked, must behave as follows:
</p>
		<ol>
			<li id="cp-let-ToObject-this">
%object ~LET `this^jv 値~上の `ToObject$A を~callした結果
◎
Let object be the result of calling ToObject on the this value.
</li>
			<li id="cp-iterator-security-check">
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, "`iterator^jS", `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "@@iterator", and
• the type "method".
</li>
			<li>
%~ifc ~LET `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface the iterable declaration is on.
</li>
			<li id="cp-throw-if-not-impl">
~IF［
%object は %~ifc を`実装-$しない
］
⇒
~throwTypeError
◎
If object does not implement interface, then throw a TypeError.
</li>
			<li>
~RET ［
%~ifc,
~target %object,
反復子の種類 `key+value^l
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind "key+value".
◎
Return iterator.
</li>
		</ol>
	</dd>

	<dt>
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration, then＼
</dt>
	<dd class="algorithm">
<!--cp-built-in-F-must-behave-as-->
		<ol>
			<!--cp-let-ToObject-this-->
			<!--cp-iterator-security-check-->
			<li>
~IF［
%object は［
`~maplike 宣言$ ／ `~setlike 宣言$
］を定義する`~ifc$を`実装-$しない
］
⇒
~throwTypeError
◎
If object does not implement the interface on which the maplike declaration or setlike declaration is defined, then throw a TypeError.
</li>
			<li>
<p>
~IF［
~ifcは`~maplike 宣言$を持つ
］：
◎
If the interface has a maplike declaration, then:
</p>
				<ol>
					<li>
%backing ~LET %object の `BackingMap^sl `内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object.
</li>
					<li>
~RET `CreateMapIterator$A( %backing, `key+value^l )
◎
Return CreateMapIterator(backing, "key+value").
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE ：
◎
Otherwise:
</p>
				<ol>
					<li>
%backing ~LET %object の `BackingSet^sl `内部~slot$の値
◎
Let backing be the value of the [[BackingSet]] internal slot of object.
</li>
					<li>
~RET `CreateSetIterator$A( %backing, `value^l )
◎
Return CreateSetIterator(backing, "value").
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

<p>
%F の `length^jp ~propの値は、
`Number^jt 値 `0^jv とする。
◎
The value of the @@iterator function object’s length property is the Number value 0.
</p>

<p>
%F の `name^jp ~propの値は、当の~ifcが［［
`~pair反復子$ ／ `~maplike 宣言$
］を持つならば `String^jt 値 `entries^l ／
`~setlike 宣言$を持つならば `String^jt 値 `values^l
］とする。
◎
The value of the @@iterator function object’s name property is the String value "entries" if the interface has a pair iterator or a maplike declaration and the String "values" if the interface has a setlike declaration.
</p>

				</section>
				<section id="es-async-iterator">
<h5 title="@@asyncIterator">3.6.8.2. `asyncIterator^jS</h5>

<div class="p">
<p>
`非同期c可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在するモノトスル：
</p>

<ul>
	<li>
名前：
`asyncIterator$jS ~symbol
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TFT-->
</ul>

◎
If the interface has an asynchronously iterable declaration, then a property must exist whose name is the @@asyncIterator symbol, with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc-->

<div class="algorithm">
<p>
~propの値 %F は、`組込みの関数~obj$であり，被呼出時には次に従って挙動するモノトスル
◎
The function object is a built-in function object that, when invoked, must behave as follows:
</p>

<ol>
	<!--cp-let-ToObject-this-->
	<li>
~IF［
%object は`~platform~objである$
］
⇒
`~security検査を遂行する$( %object, "`asyncIterator^jS", `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "keys", and
• the type "method".
</li>
	<!--cp-let-ifc-async-iterable-declared-->
	<!--cp-throw-if-not-impl-->
	<li>
%反復子 ~LET 次のようにされた %~ifc 用の新たな`既定の非同期~反復子~obj$
⇒＃
`~target$aI ~SET %object,
`種類$aI ~SET `key+value^l
◎
Let iterator be a newly created default asynchronous iterator object for interface with object as its target and "key+value" as its kind.
</li>
	<li id="cp-async-iterator-init">
~IF［
%~ifc 用の`非同期~反復子~初期化~手続き$ %手続き は定義されている
］
⇒
%手続き を走らす( %反復子 )
◎
Run the asynchronous iterator initialization steps for interface with iterator, if any.
</li>
	<li>
~RET %反復子
◎
Return iterator.
</li>
</ol>

</div>

<p>
`asyncIterator$jS `関数~obj$の `length^jp ~propの値は、
`Number^jt 値 `0^jv とする。
◎
The value of the @@asyncIterator function object’s length property is the Number value 0.
</p>

<p>
`asyncIterator$jS `関数~obj$の `name^jp ~propの値は、
`String^jt 値 `entries^l とする。
◎
The value of the @@asyncIterator function object’s name property is the String value "entries".
</p>

				</section>
				<section id="es-forEach">
<h5 title="forEach">3.6.8.3. `forEach^jp</h5>

<p>
［
`可反復~宣言$／`~maplike 宣言$／`~setlike 宣言$
］を持つ`~ifc$には、次の特徴を有する `forEach^jp ~data~propが存在するモノトスル：
◎
If the interface has any of the following:
• an iterable declaration
• a maplike declaration
• a setlike declaration
◎
then a forEach data property must exist＼
</p>

<div class="p">
<ul>
	<!--cp-value-is-a-func-F-->
	<li id="cp-has-attr-TTT">
属性 `TTT^desc を持つ
</li>
</ul>

◎
with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcに `有index~prop取得子$が定義されている場合：
◎
If the interface defines an indexed property getter, then＼
</dt>
	<dd>
`ArrayProto_forEach$jI
◎
the function object is %ArrayProto_forEach%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
<p>
［［
当の~ifcが，その`~pair反復子$の代わりに 次に与える［
`演算$, および注釈文による定義
］を持つ
］と見做したときに，存在することになるもの
］と同じに挙動する：
◎
the method must have the same behavior, when invoked with argument callback and optional argument thisArg, as one that would exist assuming the interface had this operation instead of the iterable declaration:
</p>

<pre class="webidl">
[Exposed=Window]
interface Iterable {
  void forEach(Function %callback, optional any %thisArg);
};
</pre>

<div class="algorithm">
<p>
注釈文による定義は、
( 引数 %callback, 随意~引数 %thisArg )
で呼出されたとき：
◎
with the following prose definition:
</p>
		<ol>
			<li>
~IF［
%thisArg は給されていない
］
⇒
%thisArg ~SET `undefined^jv
◎
↓↓</li>
			<li>
%~pair~list ~LET `反復される値~pair$が成す~list
◎
Let pairs be the list of value pairs to iterate over.
</li>
			<li>
%i ~LET 0
◎
Let i be 0.
</li>
			<li>
<p>
~WHILE［
%i ~LT %~pair~list の長さ
］：
◎
While i is less than the length of pairs:
</p>
				<ol>
					<li>
%~pair ~LET %~pair~list 内で~index %i に位置する~entry
◎
Let pair be the entry in pairs at index i.
</li>
					<li>
`~callback関数を呼出す$( %callback, 次に与える~list, %thisArg )
⇒
« %~pair の`値$vP, %~pair の`~key$vP, `this^jv »
◎
Let key be pair’s key.
◎
Let value be pair’s value.
◎
Invoke callback with thisArg (or undefined, if the argument was not supplied) as the callback this value and value, key and this as its arguments.
</li>
					<li>
%~pair~list を［
現在の`反復される値~pair$の~list
］に更新する
◎
Update pairs to the current list of value pairs to iterate over.
</li>
					<li>
%i ~INCBY 1
◎
Set i to i + 1.
</li>
				</ol>
			</li>
		</ol>
</div>
	</dd>

	<dt>
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration then＼
</dt>
	<dd class="algorithm">
<p id="cp-must-behave-as-follows">
~methの被呼出時には、次に従って挙動するモノトスル：
◎
the method, when invoked, must behave as follows:
</p>
		<ol>
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `forEach^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "forEach", and
• the type "method".
</li>
			<li>
%~ifc ~LET `~maplike 宣言$／`~setlike 宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the maplike declaration or setlike declaration is declared.
</li>
			<!--cp-throw-if-not-impl-->
			<li>
%callbackFn ~LET ［
関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let callbackFn be the value of the first argument passed to the function, or undefined if the argument was not supplied.
</li>
			<li>
~IF［
`IsCallable$A( %callbackFn ) ~EQ ~F
］
⇒
~throwTypeError
◎
If IsCallable(callbackFn) is false, throw a TypeError.
</li>
			<li>
%thisArg ~LET ［
関数に 2 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let thisArg be the value of the second argument passed to the function, or undefined if the argument was not supplied.
</li>
			<li>
%backing ~LET %~ifc が［
`~maplike 宣言$ ／ `~setlike 宣言$
］のいずれを持つかに応じて， %object の［
`BackingMap^sl ／ `BackingSet^sl
］`内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object, if the interface has a maplike declaration, or the [[BackingSet]] internal slot of object otherwise.
</li>
			<li>
<p>
%callbackWrapper ~LET 被呼出時には次に従って挙動する`組込みの関数~obj$：
◎
Let callbackWrapper be a built-in function object that, when invoked, behaves as follows:
</p>
				<ol>
					<li>
( %v, %k ) ~LET 関数に渡された ( 1 個目の引数, 2 個目の引数 )
◎
Let v and k be the first two arguments passed to the function.
</li>
					<li>
%thisArg ~LET `this^jv 値
◎
Let thisArg be the this value.
</li>
					<li>
~ABRUPT `Call$A( %callbackFn, %thisArg, « %v, %k, %object » )
◎
Perform ? Call(callbackFn, thisArg, «v, k, object»).
</li>
				</ol>

<p class="note">注記：
%callbackWrapper 関数は、単純に， 3 個目の引数に %object を渡して ~~入力の %callbackFn を~callする
— その内部［
`BackingMap^sl ／ `BackingSet^sl
］~objではなく。
◎
Note: The callbackWrapper function simply calls the incoming callbackFn with object as the third argument rather than its internal [[BackingMap]] or [[BackingSet]] object.
</p>

<p class="issue">
~script作者は、［
forEach が~callされる度に， %callbackWrapper が新たな関数になる
］かどうか，観測し得るだろうか？
［
環境を capture 【！＊】した唯一の関数が在ること
］を指定する仕方として，何が最良になるだろうか？
◎
Can the script author observe that callbackWrapper might be a new function every time forEach is called? What’s the best way of specifying that there’s only one function that has captured an environment?
</p>

			</li>
			<li>
%forEach ~LET `GetMethod$A( %backing, `forEach^l )
◎
Let forEach be ? GetMethod(backing, "forEach").
</li>
			<li>
~IF［
%forEach ~EQ `undefined^jv
］
⇒
~throwTypeError

◎
If forEach is undefined, then throw a TypeError.
</li>
			<li>
~ABRUPT `Call$A( %forEach, %backing, « %callbackWrapper, %thisArg » )
◎
Perform ? Call(forEach, backing, «callbackWrapper, thisArg»).
</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</dd>
</dl>

<p id="cp-length-is-1">
この`関数~obj$の `length^jp ~propの値は、 `Number^jt 値 `1^jv とする。
◎
The value of the function object’s length property is the Number value 1.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `forEach^l とする。
◎
The value of the function object’s name property is the String value "forEach".
</p>

				</section>
			</section>
			<section id="es-iterable">
<h4 title="Iterable declarations">3.6.9. 可反復~宣言</h4>

				<section id="es-iterable-entries">
<h5 title="entries">3.6.9.1. `entries^jp</h5>

<div class="p">
<p>
［
`可反復~宣言$／`非同期c可反復~宣言$
］を持つ`~ifc$には、次の特徴を有する `entries^jp ~data~propが存在するモノトスル：
</p>

<ul>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration or an asynchronously iterable declaration, then an entries data property must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator, then＼
</dt>
	<dd>
`ArrayProto_entries$jI 。
◎
the function object is %ArrayProto_entries%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
`iterator$jS ~propの値で与えられる`関数~obj$。
◎
the function object is the value of the @@iterator property.
</dd>

	<dt>
~ifcは`非同期c可反復~宣言$を持つ場合：
◎
If the interface has an asynchronously iterable declaration, then＼
</dt>
	<dd>
`asyncIterator$jS ~propの値で与えられる`関数~obj$。
◎
the function object is the value of the @@asyncIterator property.
</dd>
</dl>

				</section>
				<section id="es-iterable-keys">
<h5 title="keys">3.6.9.2. `keys^jp</h5>

<div class="p">
<p>
［
`可反復~宣言$／`非同期c可反復~宣言$
］を持つ`~ifc$には、次の特徴を有する `keys^jp ~data~propが存在するモノトスル：
</p>

<ul>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration or an asynchronously iterable declaration, then a keys data property must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator,＼
</dt>
	<dd>
`ArrayProto_keys$jI 。
◎
then the function object is %ArrayProto_keys%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd class="algorithm">
<!--cp-must-behave-as-follows-->
		<ol>
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `keys^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "keys", and
• the type "method".
</li>
			<li id="cp-let-ifc-iterable-declared">
%~ifc ~LET `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the iterable declaration is declared.
</li>
			<!--cp-throw-if-not-impl-->
			<li>
~RET ［
%~ifc,
~target %object,
反復子の種類 `key^l
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind "key".
◎
Return iterator.
</li>
		</ol>
	</dd>

	<dt>
~ifcは`非同期c可反復~宣言$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd class="algorithm">
<!--cp-must-behave-as-follows-->
		<ol>
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `keys^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "keys", and
• the type "method".
</li>
			<li id="cp-let-ifc-async-iterable-declared">
%~ifc ~LET `非同期c可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the asynchronously iterable declaration is declared.
</li>
			<!--cp-throw-if-not-impl-->
			<li>
%反復子 ~LET 次のようにされた %~ifc 用の新たな`既定の非同期~反復子~obj$
⇒＃
`~target$aI ~SET %object,
`種類$aI ~SET `key^l
◎
Let iterator be a newly created default asynchronous iterator object for interface with object as its target and "key" as its kind.
</li>
			<!--cp-async-iterator-init-->
			<li>
~RET %反復子
◎
Return iterator.
</li>
		</ol>
	</dd>
</dl>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `keys^l とする。
◎
The value of the function object’s name property is the String value "keys".
</p>

				</section>
				<section id="es-iterable-values">
<h5 title="values">3.6.9.3. `values^jp</h5>

<div class="p">
<p>
［
`可反復~宣言$／`非同期c可反復~宣言$
］を持つ`~ifc$には、次の特徴を有する `values^jp ~data~propが存在するモノトスル：
</p>

<ul>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration or an asynchronously iterable declaration, then a values data property must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator,＼
</dt>
	<dd>
`iterator$jS ~propの値で与えられる`関数~obj$。
◎
then the function object is the value of the @@iterator property.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd class="algorithm">
<!--cp-must-behave-as-follows-->
		<ol>
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `entries^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "entries", and
• the type "method".
</li>
			<!--cp-let-ifc-iterable-declared-->
			<!--cp-throw-if-not-impl-->
			<li>
~RET ［
%~ifc,
~target %object,
反復子の種類 `value^l
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind "value".
◎
Return iterator.
</li>
		</ol>
	</dd>

	<dt>
~ifcは`非同期c可反復~宣言$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd class="algorithm">
<!--cp-must-behave-as-follows-->
		<ol>
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `entries^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "entries", and
• the type "method".
</li>
			<!--cp-let-ifc-async-iterable-declared-->
			<!--cp-throw-if-not-impl-->
			<li>
%反復子 ~LET 次のようにされた %~ifc 用の新たな`既定の非同期~反復子~obj$
⇒＃
`~target$aI ~SET %object,
`種類$aI ~SET `value^l
◎
Let iterator be a newly created default asynchronous iterator object for interface with object as its target and "value" as its kind.
</li>
			<!--cp-async-iterator-init-->
			<li>
~RET %反復子
◎
Return iterator.
</li>
		</ol>
	</dd>
</dl>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `values^l とする。
◎
The value of the function object’s name property is the String value "values".
</p>

				</section>
				<section id="es-default-iterator-object">
<h5 title="Default iterator objects">3.6.9.4. 既定の反復子~obj</h5>

<p>
所与の［
`~ifc$, ~target, 反復の種類
］用の
`既定の反復子~obj@
は、次を満たす~objである
⇒
その `Prototype^sl `内部~slot$は、~ifc用の`反復子~原型~obj$である
◎
A default iterator object for a given interface, target and iteration kind is an object whose [[Prototype]] internal slot is the iterator prototype object for the interface.
</p>

<p>
`既定の反復子~obj$は、次に挙げる値を内部に持つ：
◎
A default iterator object has three internal values:
</p>

<dl class="def-list">
	<dt>~target</dt>
	<dd>
反復される値を~~給する~obj
◎
its target, which is an object whose values are to be iterated,
</dd>

	<dt>種類</dt>
	<dd>
反復の種類 
【 ~IN { `key^l, `value^l, `key+value^l } 】
◎
its kind, which is the iteration kind,
</dd>

	<dt>~index</dt>
	<dd>
一連の値のうち，反復されることになる値を指す、現在の~index。
◎
its index, which is the current index into the values value to be iterated.
</dd>
</dl>

<p class="note">注記：
既定の反復子~objは、`~pair反復子$のみに利用される
—
`値~反復子$は、現在は，~objが`~supportする~prop~index$上を反復するように制約されており、標準な~ES `Array^jt 反復子~objを利用する。
◎
Note: Default iterator objects are only used for pair iterators; value iterators, as they are currently restricted to iterating over an object’s supported indexed properties, use standard ECMAScript Array iterator objects.
</p>

<p>
`既定の反復子~obj$が最初に作成されたときの~indexは、 0 とする。
◎
When a default iterator object is first created, its index is set to 0.
</p>

<p>
`既定の反復子~obj$には`~class文字列$は無い。
所与の`~ifc$の`既定の反復子~obj$上で
`Object.prototype.toString()^c が~callされたときは、その~ifcの`~class文字列$が利用されるとする。
◎
Default iterator objects do not have class strings; when Object.prototype.toString() is called on a default iterator object of a given interface, the class string of the iterator prototype object of that interface is used.
</p>

				</section>
				<section id="es-iterator-prototype-object">
<h5 title="Iterator prototype object">3.6.9.5. 反復子~原型~obj</h5>

<p>
`~pair反復子$を持つどの`~ifc$に対しても、
`反復子~原型~obj@
と呼ばれる~objが存在する。
それは、その~ifc用の`既定の反復子~obj$の原型として~serveする。
◎
The iterator prototype object for a given interface is an object that exists for every interface that has a pair iterator. It serves as the prototype for default iterator objects for the interface.
</p>

<p>
`反復子~原型~obj$の `Prototype^sl `内部~slot$は、
`IteratorPrototype$jI でなければナラナイ。
◎
The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
</p>

<div class="algorithm">

<p>
`反復子~結果@
は、所与の
( `値~pair$ %pair, 種類 %種類 )
に対し，次の手続きで与えられる：
◎
The iterator result for a value pair pair and a kind kind is given by the following steps:
</p>

<ol>
	<li>
<p>
%結果 ~LET %種類 に応じて，次で決定される値：
◎
Let result be a value determined by the value of kind:
</p>
		<dl class="switch">
			<dt>`key^l</dt>
			<dd>
				<ol>
					<li id="cp-let-idlkey-of-pair">
%~idl~key ~LET %~pair の~key
◎
Let idlKey be pair’s key.
</li>
					<li id="cp-idlKey-toES">
%~key ~LET %~idl~key を`~ES値に変換-$した結果
◎
Let key be the result of converting idlKey to an ECMAScript value.
</li>
					<li>
%結果 ~SET %~key
◎
result is key.
</li>
				</ol>
			</dd>

			<dt>`value^l</dt>
			<dd>
				<ol>
					<li id="cp-let-idlValue-of-pair">
%~idl値 ~LET %~pair の~key
◎
Let idlValue be pair’s value.
</li>
					<li id="cp-idlValue-toES">
%値 ~LET %~idl値 を`~ES値に変換-$した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
					<li>
%結果 ~SET %値
◎
result is value.
</li>
				</ol>
			</dd>

			<dt>`key+value^l</dt>
			<dd>
				<ol>
					<!--cp-let-idlkey-of-pair-->
					<!--cp-let-idlValue-of-pair-->
					<!--cp-idlKey-toES-->
					<!--cp-idlValue-toES-->
					<li>
%array ~LET `ArrayCreate$A( 2 ) を遂行した結果
◎
Let array be the result of performing ArrayCreate(2).
</li>
					<li>
`CreateDataProperty$A( %array, `0^l, %~key ) を~callする
◎
Call CreateDataProperty(array, "0", key).
</li>
					<li>
`CreateDataProperty$A( %array, `1^l, %値 ) を~callする
◎
Call CreateDataProperty(array, "1", value).
</li>
					<li>
%結果 ~SET %array
◎
result is array.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET
`CreateIterResultObject$A( %結果, `false^jv )
◎
Return CreateIterResultObject(result, false).
</li>
</ol>
</div>

<div class="p">
<p>
`反復子~原型~obj$は、次の特徴を有する `next^jp ~data~propを持つモノトスル：
</p>

<ul>
	<li>
値は 下に与えるように挙動する`組込みの関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
An iterator prototype object must have a next data property with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object that behaves as follows:
</div>

<div class="algorithm">
<ol>
	<li>
%~ifc ~LET その`反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the iterator prototype object exists.
</li>
	<!--cp-let-ToObject-this-->
	<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `next^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "next", and
• the type "method".
</li>
	<li>
~IF［
%object は %~ifc 用の`既定の反復子~obj$でない
］
⇒
~throwTypeError
◎
If object is not a default iterator object for interface, then throw a TypeError.
</li>
	<li>
%index ~LET %object の~index
◎
Let index be object’s index.
</li>
	<li>
%種類 ~LET %object の種類
◎
Let kind be object’s kind.
</li>
	<li>
%値~list ~LET `反復される値~pair$の~list
◎
Let values be the list of value pairs to iterate over.
</li>
	<li>
%len ~LET %値~list の長さ
◎
Let len be the length of values.
</li>
	<li>
~IF［
%index ~GTE %len
］
⇒
~RET
`CreateIterResultObject$A(`undefined^jv, `true^jv)
◎
If index is greater than or equal to len, then return CreateIterResultObject(undefined, true).
</li>
	<li>
%~pair ~LET %値~list 内の %index に位置する~entry
◎
Let pair be the entry in values at index index.
</li>
	<li>
%object の~index ~SET %index ~PLUS 1
◎
Set object’s index to index + 1.
</li>
	<li>
~RET `反復子~結果$( %pair, %種類 )
◎
Return the iterator result for pair and kind.
</li>
</ol>
</div>

<p>
所与の`~ifc$用の`反復子~原型~obj$の`~class文字列$は、次の連結とする
⇒＃
その~ifcの`識別子$,
`0020^U ~SPACE,
文字列 `Iterator^l
◎
The class string of an iterator prototype object for a given interface is the result of concatenating the identifier of the interface and the string " Iterator".
</p>

				</section>
				<section id="es-default-asynchronous-iterator-object">
<h5 title="Default asynchronous iterator objects">3.6.9.6. 既定の非同期~反復子~obj</h5>

<p>
所与の
( `~ifc$, ~target, 反復~種類 )
用の
`既定の非同期~反復子~obj@
は、次を満たす~objである
⇒
その `Prototype^sl `内部~slot$は、`~ifc$用の`非同期~反復子~原型~obj$である
◎
A default asynchronous iterator object for a given interface, target and iteration kind is an object whose [[Prototype]] internal slot is the asynchronous iterator prototype object for the interface.
</p>

<p>
`既定の非同期~反復子~obj$は、次に挙げる値を内部に持つ：
◎
A default asynchronous iterator object has internal values:
</p>

<dl class="def-list">
	<dt>`~target@aI</dt>
	<dd>
反復される値を~~給する~obj
◎
its target, which is an object whose values are to be iterated,
</dd>

	<dt>`種類@aI</dt>
	<dd>
反復の種類 
【 ~IN { `key^l, `value^l, `key+value^l } 】
◎
its kind, which is the iteration kind,
</dd>

	<dt>`進行中の~promise@aI</dt>
	<dd>
`~promise_T$ ／ `undefined^jv
◎
its ongoing promise, which is a Promise or undefined,
</dd>

	<dt>`状態@aI</dt>
	<dd>
<p>
`まだ開始されてない^C ／ `完遂d^C ／［
`次回の反復~結果を取得する$~algoに対し，反復子の位置を格納するために利用される不透明な値†
］
◎
its state, which is one of "not yet started" and "finished", or an opaque value used to store the position of the iterator by the algorithm to get the next iteration result.
</p>

<p class="note">注記†：
この値には、`~ifc$~instanceではなく，反復子~instanceが結付けられる。
それは、ここで明示的に取扱われる
— 反復子~instanceは，`次回の反復~結果を取得する$注釈文には公開されないので。
◎
Note: This value is associated with the iterator instance, rather than the interface instance. It is explicitly handled here because the iterator instance is not exposed to the prose that gets the next iteration result.
</p>
	</dd>
</dl>

<p>
`既定の非同期~反復子~obj$が最初に作成されたときの`状態$aIは、
`まだ開始されてない^C
とする。
◎
When a default asynchronous iterator object is first created, its state is "not yet started".
</p>

<p class="note">注記：
`既定の非同期~反復子~obj$には、`~class文字列$は無い。
所与の`~ifc$の`既定の非同期~反復子~obj$上で，
`Object.prototype.toString()^c
が~callされたときは、その`~ifc$の`非同期~反復子~原型~obj$の`~class文字列$が利用される。
◎
Note: Default asynchronous iterator objects do not have class strings; when Object.prototype.toString() is called on a default asynchronous iterator object of a given interface, the class string of the asynchronous iterator prototype object of that interface is used.
</p>

				</section>
				<section id="es-asynchronous-iterator-prototype-object">
<h5 title="Asynchronous iterator prototype object">3.6.9.7. 非同期~反復子~原型 ~obj</h5>

<p>
所与の`~ifc$用の
`非同期~反復子~原型~obj@
は、
`非同期c可反復~宣言$を有するどの~ifc用にも存在する~objである。
それは、当の~ifc用の`既定の非同期~反復子~obj$用の原型として~serveする。
◎
The asynchronous iterator prototype object for a given interface is an object that exists for every interface that has an asynchronously iterable declaration. It serves as the prototype for default asynchronous iterator objects for the interface.
</p>

<p>
`非同期~反復子~原型~obj$の `Prototype^sl `内部~slot$は、
`AsyncIteratorPrototype$jI でなければナラナイ。
◎
The [[Prototype]] internal slot of an asynchronous iterator prototype object must be %AsyncIteratorPrototype%.
</p>

<div class="p">
<p>
`非同期~反復子~原型~obj$は、次の特徴を有する `next^jp ~data~propを持つモノトスル：
</p>

<ul>
	<li>
値は 下に与えるように挙動する`組込みの関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
An asynchronous iterator prototype object must have a next data property with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object that behaves as follows:
</div>

<div class="algorithm">

<ol>
	<li>
%~ifc ~LET 当の`非同期~反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the asynchronous iterator prototype object exists.
</li>
	<li>
%この検証~promise能力 ~LET
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let thisValidationPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
	<!--cp-let-ToObject-this-->
	<li>
`IfAbruptRejectPromise$A( %object, %この検証~promise能力 )
◎
IfAbruptRejectPromise(object, thisValidationPromiseCapability).
</li>
	<li>
<p>
~IF［
%object は`~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `next^l, `~meth^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "keys", and
• the type "method".
</p>

<p>
この段にて例外 %e が投出されたときは：
◎
If this threw an exception e, then:
</p>
		<ol>
			<li>
~NOABRUPT `Call$A( %この検証~promise能力.`Reject^sl, `undefined^jv, « %e » )
◎
Perform ! Call(thisValidationPromiseCapability.[[Reject]], undefined, « e »).
</li>
			<li>
~RET %この検証~promise能力 .`Promise^sl
◎
Return thisValidationPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%object は %~ifc 用の`既定の非同期~反復子~obj$でない
］：
◎
If object is not a default asynchronous iterator object for interface, then:
</p>
		<ol>
			<li class="issue">
`~Realm$の検査？
◎
Realm check?
</li>
			<li>
%error ~LET 新たな `TypeError$jt
◎
Let error be a new TypeError.
</li>
			<li>
~NOABRUPT `Call$A( %この検証~promise能力.`Reject^sl, `undefined^jv, « %error » )
◎
Perform ! Call(thisValidationPromiseCapability.[[Reject]], undefined, « error »).
</li>
			<li>
~RET %この検証~promise能力.`Promise^sl
◎
Return thisValidationPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
<p>
%次回の手続き ~LET 次を走らす手続き：
◎
Let nextSteps be the following steps:
</p>
		<ol>
			<li>
%次回の~promise能力 ~LET 
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let nextPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
			<li>
%旧-状態 ~LET %object の`状態$aI
◎
Let oldState be object’s state.
</li>
			<li>
<p>
~IF［
%旧-状態 ~EQ  `完遂d^C
］：
◎
If oldState is "finished", then:
</p>
				<ol>
					<li>
%結果 ~LET
`CreateIterResultObject$A( `undefined^jv, `true^jv )
◎
Let result be CreateIterResultObject(undefined, true).
</li>
					<li>
~NOABRUPT `Call$A( %次回の~promise能力.`Resolve^sl, `undefined^jv, « %結果 » )
◎
Perform ! Call(nextPromiseCapability.[[Resolve]], undefined, « result »).
</li>
					<li>
~RET %次回の~promise能力.`Promise^sl
◎
Return nextPromiseCapability.[[Promise]].
</li>
				</ol>
			</li>
			<li>
%種類 ~LET %object の`種類$aI
◎
Let kind be object’s kind.
</li>
			<li>
%次回の~promise ~LET `次回の反復~結果を取得する$( %object の`~target$aI, %旧-状態 )
◎
Let nextPromise be the result of getting the next iteration result with object’s target as this and oldState as the current state.
</li>
			<li>
<p>
%解決-手続き ~LET 所与の
( %next )
に対し，次を走らす手続き：
◎
Let resolveSteps be the following steps, given next:
</p>
				<ol>
					<li>
%object の`進行中の~promise$aI ~SET `undefined^jv
◎
Set object’s ongoing promise to undefined.
</li>
					<li>
<p>
~IF［
%next ~EQ `undefined^jv
］：
◎
If next is undefined, then:
</p>
						<ol>
							<li>
%object の`状態$aI ~SET ~NULL
◎
Set object’s state to null.
</li>
							<li>
%結果 ~LET 
`CreateIterResultObject$A( `undefined^jv, `true^jv )
◎
Let result be CreateIterResultObject(undefined, true).
</li>
							<li>
~NOABRUPT `Call$A( %次回の~promise能力.`Resolve^sl, `undefined^jv, « %結果 » )
◎
Perform ! Call(nextPromiseCapability.[[Resolve]], undefined, « result »).
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
( %key, %value, %新-状態 ) ~LET %next
◎
Let (key, value, newState) be next.
</li>
							<li>
%object の`状態$aI ~SET %新-状態
◎
Set object’s state to newState.
</li>
							<li>
%結果 ~LET `反復子~結果$( ( %key, %value ), %種類 )
◎
Let result be the iterator result for (key, value) and kind.
</li>
							<li>
~NOABRUPT `Call$A( %次回の~promise能力.`Resolve^sl, `undefined^jv, « %結果 » )
◎
Perform ! Call(nextPromiseCapability.[[Resolve]], undefined, « result »).
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%onFulfilled ~LET 
~NOABRUPT `CreateBuiltinFunction$A( %解決-手続き, « » )
◎
Let onFulfilled be ! CreateBuiltinFunction(resolveSteps, « »).
</li>
			<li>
~NOABRUPT `PerformPromiseThen$A( %次回の~promise, %onFulfilled, `undefined^jv, %次回の~promise能力 )
◎
Perform ! PerformPromiseThen(nextPromise, onFulfilled, undefined, nextPromiseCapability).
</li>
			<li>
~RET %次回の~promise能力.`Promise^sl
◎
Return nextPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
%promise ~LET %object の`進行中の~promise$aI
◎
Let promise be object’s ongoing promise.
</li>
	<li>
<p>
~IF［
%promise ~NEQ `undefined^jv
］：
◎
If promise is not undefined, then:
</p>
		<ol>
			<li>
%後の進行中の~promise能力 ~LET 
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let afterOngoingPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
			<li>
%onFulfilled ~LET 
~NOABRUPT `CreateBuiltinFunction$A( %次回の手続き, « » )
◎
Let onFulfilled be ! CreateBuiltinFunction(nextSteps, « »).
</li>
			<li>
~NOABRUPT `PerformPromiseThen$A( %promise, %onFulfilled, `undefined^jv, %後の進行中の~promise能力 )
◎
Perform ! PerformPromiseThen(promise, onFulfilled, undefined, afterOngoingPromiseCapability).
</li>
			<li>
%object の`進行中の~promise$aI ~SET %後の進行中の~promise能力.`Promise^sl
◎
Set object’s ongoing promise to afterOngoingPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%object の`進行中の~promise$aI ~SET %次回の手続き を走らせた結果
◎
Otherwise:
• Run nextSteps and set object’s ongoing promise to the result.
</li>
	<li>
~RET %object の`進行中の~promise$aI
◎
Return object’s ongoing promise.
</li>
</ol>

</div>

<p class="issue">
`return; throw methods?^en【？】
</p>

<p>
所与の［
`~ifc$用の`非同期~反復子~原型~obj$
］の`~class文字列$は、次の連結とする
⇒＃
`~ifc$の`識別子$
文字列 ` AsyncIterator^l
◎
The class string of an asynchronous iterator prototype object for a given interface is the result of concatenating the identifier of the interface and the string " AsyncIterator".
</p>

				</section>
			</section>
			<section id="es-maplike">
<h4 title="Maplike declarations">3.6.10. ~maplike 宣言</h4>

<p>
`~maplike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を`実装-$する どの~objも，
`BackingMap^sl `内部~slot$を持つモノトスル。
— それは、初期~時には，新たに作成された `Map$jt ~objに設定される。
この `Map$jt ~objの `MapData^sl 内部~slotが，~objの一連の`~map~entry$になる。
◎
Any object that implements an interface that has a maplike declaration must have a [[BackingMap]] internal slot, which is initially set to a newly created Map object. This Map object’s [[MapData]] internal slot is the object’s map entries.
</p>

<p>
%A 用の`~ifc原型~obj$上には、いくつかの追加的な~propが存在する。
これらの追加的な~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a maplike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<div class="algorithm">
<p>
それらの~propのうち一部のものは、以下において［
所与の関数~名に対し，
`内部~map~objへ回送する@
ような`組込みの関数~obj$ 値を持つ
］ように定義される。
その種の関数は、被呼出時には次に従って挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal map object for a given function name. Such functions behave as follows when invoked:
</p>

<ol>
	<li id="cp-let-O-this-value">
%O ~LET `this^jv 値
◎
Let O be the this value.
</li>
	<li id="cp-let-arguments-passed">
%arguments ~LET 関数に渡された引数の~list
◎
Let arguments be the list of arguments passed to this function.
</li>
	<li id="cp-let-name-function-name">
%name ~LET 関数~名
◎
Let name be the function name.
</li>
	<li id="cp-security-check-name">
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, %name, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type "method".
</li>
	<li id="cp-throw-if-O-not-obj">
~IF［
%O は %A を`実装-$する~objでない
］
⇒
~throwTypeError
◎
If O does not implement A, then throw a TypeError.
</li>
	<li id="cp-let-map-BackingMap">
%map ~LET
%O の `BackingMap^sl `内部~slot$の値である `Map$jt ~obj
◎
Let map be the Map object that is the value of O’s [[BackingMap]] internal slot.
</li>
	<li>
%function ~LET
~ABRUPT `GetMethod$A( %map, %name )
◎
Let function be ? GetMethod(map, name).
</li>
	<li id="cp-throw-if-function-undefined">
~IF［
%function ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If function is undefined, then throw a TypeError.
</li>
	<li>
~RET
~ABRUPT `Call$A( %function, %map, %arguments )
◎
Return ? Call(function, map, arguments).
</li>
</ol>
</div>

				<section id="es-map-size">
<h5 title="size">3.6.10.1. `size^jp</h5>
<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する `size^jp ~propが存在するモノトスル：
◎
There must exist a size property on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
属性
{ [[Get]]: %G, [[Enumerable]]: `false^jv, [[Configurable]]: `true^jv }
を持つ
— ここで %G は、下に定義する`~map~size取得子$である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s map size getter, defined below.
</li>
</ul>

<div class="algorithm">
<p>
`~map~size取得子@
は、被呼出時の挙動が次で与えられる，`組込みの関数~obj$である：
◎
The map size getter is a built-in function object whose behavior when invoked is as follows:
</p>
		<ol>
			<!--cp-let-O-this-value-->
			<li id="cp-security-check-size">
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, `size^l, `取得子^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier "size", and
• the type "getter".
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
~RET `Get$A( %map, `size^l )
◎
Return Get(map, "size").
</li>
		</ol>
<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `size^l とする。
◎
The value of the function object’s name property is the String value "size".
</p>

</div>

				</section>
				<section id="es-map-entries">
<h5 title="entries">3.6.10.2. `entries^jp</h5>

<div class="p">
<p>
%A 用の`~ifc原型~obj$上には、次の特徴を有する `entries^jp ~data~propが存在するモノトスル：
</p>

<ul>
	<li>
値は `iterator$jS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
An entries data property must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>

				</section>
				<section id="es-map-keys-values">
<h5 title="keys and values">3.6.10.3. `keys^jp, `values^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する［
`keys^jp, `values^jp
］~data~propが存在するモノトスル。
◎
For both of keys and values, there must exist a data property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li id="cp-has-TFT">
属性 `TFT^desc を持つ。
◎
The property has attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
値は `内部~map~objへ回送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards that name to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値による~propの名前（ `keys^l ／ `values^l ）とする。
◎
The value of the function object’s name property is the String value "keys" or "values", correspondingly.
</p>

				</section>
				<section id="es-map-get-has">
<h5 title="get and has">3.6.10.4. `get^jp, `has^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する［
`get^jp, `has^jp
］~data~propが存在するモノトスル。
◎
For both of get and has, there must exist a data property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<div class="algorithm">
<p id="cp-value-is-built-in-func">
値は`組込みの関数~obj$であり、被呼出時には次に従って挙動する：
◎
The value of the property is a built-in function object that behaves as follows when invoked:
</p>
		<ol>
			<!--cp-let-O-this-value-->
			<li>
%name ~LET ~propの名前（ `get^l ／ `has^l ）
◎
Let name be the name of the property – "get" or "has".
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li id="cp-let-keyType">
%~key型 ~LET `~maplike 宣言$にて指定された~key型
◎
Let keyType be the key type specified in the maplike declaration.
</li>
	<li>
%function ~LET
~NOABRUPT `Get$A( %map, %name )
◎
Let function be ! Get(map, name).
</li>
			<li id="cp-let-keyArg-1st-arg">
%~key引数 ~LET ［
この関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let keyArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-keyArg-toIDL-keyIDL">
%~key~IDL ~LET %~key引数 を型 %~key型 の`~IDL値に変換-$した結果
◎
Let keyIDL be the result of converting keyArg to an IDL value of type keyType.
</li>
			<li id="cp-keyIDL-toES-key">
%~key ~LET %~key~IDL を`~ES値に変換-$した結果
◎
Let key be the result of converting keyIDL to an ECMAScript value.
</li>
			<li id="cp-Call-fmk">
~RET
~ABRUPT `Call$A( %function, %map, « %~key » )
◎
Return ? Call(function, map, «key»).
</li>
		</ol>
</div>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値による~propの名前（ `get^l ／ `has^l ）とする。
◎
The value of the function object’s name property is the String value "get" or "has", correspondingly.
</p>

	</li>
</ul>


				</section>
				<section id="es-map-clear">
<h5 title="clear">3.6.10.5. `clear^jp</h5>

<p>
［
%A には 識別子 `clear^l の`~mb$は宣言されていない
］~AND［
%A は 可書~maplike 宣言を伴って宣言されている
］場合、
%A 用の`~ifc原型~obj$上には，次の特徴を有する `clear^jp ~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "clear", and A was declared with a read–write maplike declaration, then a clear data property with the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li id="cp-value-is-forwards-clear">
値は `内部~map~objへ回送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards clear to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `clear^l とする。
◎
The value of the function object’s name property is the String value "clear".
</p>

				</section>
				<section id="es-map-delete">
<h5 title="delete">3.6.10.6. `delete^jp</h5>

<p>
［
%A には 識別子 `delete^l の`~mb$は宣言されていない
］~AND［
%A は 可書~maplike 宣言を伴って宣言されている
］場合、
%A 用の`~ifc原型~obj$上には，次の特徴を有する `delete^jp ~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "delete", and A was declared with a read–write maplike declaration, then a delete data property with the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<div class="algorithm">
<!--cp-value-is-built-in-func-->
		<ol>
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, `delete^l, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier "delete", and
• the type "method".
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<!--cp-let-keyType-->
			<li>
%function ~LET `Get$A( %map, `delete^l )
◎
Let function be ! Get(map, "delete").
</li>
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-keyArg-toIDL-keyIDL-->
			<!--cp-keyIDL-toES-key-->
			<!--cp-Call-fmk-->
		</ol>
</div>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `delete^l とする。
◎
The value of the function object’s name property is the String value "delete".
</p>

	</li>
</ul>

				</section>
				<section id="es-map-set">
<h5 title="set">3.6.10.7. `set^jp</h5>

<p>
［
%A には 識別子 `set^l を伴う`~ifc~mb$は宣言されていない
］~AND［
%A は 可書~maplike 宣言を伴って宣言されている
］場合、
%A 用の`~ifc原型~obj$上には，次の特徴を有する `set^jp ~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "set", and A was declared with a read–write maplike declaration, then a set data property with the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<div class="algorithm">
<!--cp-value-is-built-in-func-->
		<ol>
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, `set^l, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier "set", and
• the type "method".
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
( %~key型, %値~型 ) ~LET `~maplike 宣言$にて指定された ( ~key型, ~value型 )
◎
Let keyType and valueType be the key and value types specified in the maplike declaration.
</li>
			<li>
%function ~LET `Get$A( %map, `set^l )
◎
Let function be ! Get(map, "set").
</li>
	<!--cp-let-keyArg-1st-arg-->

			<li>
%値~引数 ~LET［
この関数に 2 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let valueArg be the second argument passed to this function, or undefined if not supplied.
</li>
			<!--cp-keyArg-toIDL-keyIDL-->
			<li>
%値~IDL ~LET %値~引数 を型 %値~型 の`~IDL値に変換-$した結果
◎
Let valueIDL be the result of converting valueArg to an IDL value of type valueType.
</li>
			<!--cp-keyIDL-toES-key-->
			<li>
%値 ~LET %値~IDL を`~ES値に変換-$した結果
◎
Let value be the result of converting valueIDL to an ECMAScript value.
</li>
			<li>
~ABRUPT `Call$A( %function, %map, « %~key, %値 » )
◎
Perform ? Call(function, map, «key, value»).
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
</div>

<p>
この`関数~obj$の `length^jp ~propの値は、 `Number^jt 値 `2^jv とする。
◎
The value of the function object’s length property is the Number value 2.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `set^l とする。
◎
The value of the function object’s name property is the String value "set".
</p>

	</li>
</ul>

				</section>
			</section>
			<section id="es-setlike">
<h4 title="Setlike declarations">3.6.11. ~setlike 宣言</h4>

<p>
`~setlike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を`実装-$するどの~objも，
`BackingSet^sl `内部~slot$を持つモノトスル
— それは、初期~時には，新たに作成された `Set$jt ~objに設定される。
この `Map$jt ~objの `SetData^sl 内部~slotが，~objの一連の`~set~entry$になる。
◎
Any object that implements an interface that has a setlike declaration must have a [[BackingSet]] internal slot, which is initially set to a newly created Set object. This Set object’s [[SetData]] internal slot is the object’s set entries.
</p>

<p>
%A 用の`~ifc原型~obj$上には、いくつかの追加的な~propが存在する。
これらの追加的な~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a setlike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<div class="algorithm">
<p>
それらの~propのうち一部のものは、以下にて
所与の関数~名に対し，
`内部~set~objへ回送する@
ような`組込みの関数~obj$ 値を持つように定義される。
その種の関数は、被呼出時には次に従って挙動する：
◎
Some of the properties below are defined to have a built-in function object value that forwards to the internal set object for a given function name. Such functions behave as follows when invoked:
</p>

<ol>
	<!--cp-let-O-this-value-->
	<!--cp-let-arguments-passed-->
	<!--cp-let-name-function-name-->
	<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, %name, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type "method".
</li>
	<!--cp-throw-if-O-not-obj-->
	<li id="cp-let-set-BackingSet">
%set ~LET
%O の `BackingSet^sl `内部~slot$の値である `Set$jt ~obj
◎
Let set be the Set object that is the value of O’s [[BackingSet]] internal slot.
</li>
	<li>
%function ~LET
~ABRUPT `GetMethod$A( %set, %name )
◎
Let function be ? GetMethod(set, name).
</li>
	<!--cp-throw-if-function-undefined-->
	<li>
~RET
~ABRUPT `Call$A( %function, %set, %arguments )
◎
Return ? Call(function, set, arguments).
</li>
</ol>
</div>

				<section id="es-set-size">
<h5 title="size">3.6.11.1. `size^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する `size^jp ~propが存在するモノトスル：
◎
A size property must exist on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
属性
{ [[Get]]: %G, [[Enumerable]]: `false^jv, [[Configurable]]: `true^jv }
を持つ
— ここで %G は、下に定義する`~set~size取得子$とする。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s set size getter, defined below.
</li>
</ul>

<div class="algorithm">
<p>
`~set~size取得子@
は、被呼出時の挙動が次で与えられる，`組込みの関数~obj$である：
◎
The set size getter is a built-in function object whose behavior when invoked is as follows:
</p>

<ol>
	<!--cp-let-O-this-value-->
	<!--cp-security-check-size-->
	<!--cp-throw-if-O-not-obj-->
	<!--cp-let-set-BackingSet-->
	<li>
~RET `Get$A( %set, `size^l )
◎
Return the result of calling the [[Get]] internal method of set passing "size" and set as arguments.
</li>
</ol>
</div>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `size^l とする。
◎
The value of the function object’s name property is the String value "size".
</p>

				</section>
				<section id="es-set-values">
<h5 title="values">3.6.11.2. `values^jp</h5>

<div class="p">
<p>
%A 用の`~ifc原型~obj$上には、次の特徴を有する `values^jp ~data~propが存在するモノトスル：
</p>

<ul>
	<li>
値は `iterator$jS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A values data property must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>

				</section>
				<section id="es-set-entries-keys">
<h5 title="entries and keys">3.6.11.3. `entries^jp, `keys^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する［
`entries^jp, `keys^jp
］~data~propが存在するモノトスル。
◎
For both of entries and keys, there must exist a data property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
値は `内部~set~objへ回送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards that name to the internal set object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値による~propの名前（ `entries^l ／ `keys^l ）とする。
◎
The value of the function object’s name property is the String value "entries" or "keys", correspondingly.
</p>

				</section>
				<section id="es-set-has">
<h5 title="has">3.6.11.4. `has^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，次の特徴を有する `has^jp ~data~propが存在するモノトスル。
◎
There must exist a has data property on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<div class="algorithm">
<!--cp-value-is-built-in-func-->
		<ol>
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, `has^l, `~meth^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier "has", and
• the type "method".
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li id="cp-let-type-value-type">
%型 ~LET `~setlike 宣言$にて指定された~value型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<li>
%function ~LET
~NOABRUPT `Get$A( %set, `has^l )
◎
Let function be ! Get(set, "has").
</li>
			<li id="cp-let-arg-1st-arg">
%arg ~LET ［
この関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let arg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-arg-toIDL-type">
%~idl値 ~LET %arg を型 %型 の`~IDL値に変換-$した結果
◎
Let idlValue be the result of converting arg to an IDL value of type type.
</li>
			<!--cp-idlValue-toES-->
			<li>
~RET
~ABRUPT `Call$A( %function, %set, « %値 » )
◎
Return ? Call(function, set, «value»).
</li>
		</ol>
</div>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `has^l とする。
◎
The value of the function object’s name property is the String value "has".
</p>

	</li>
</ul>

				</section>
【！id=es-set-add-delete？】
				<section id="es-add-delete">
<h5 title="add and delete">3.6.11.5. `add^jp, `delete^jp</h5>

<p>
［
%A には 識別子［
`add^l ／ `delete^l
］を伴う`~mb$は宣言されていない
］~AND［
%A は 可書`~maplike 宣言$を伴って宣言されている
］ならば、
%A 用の`~ifc原型~obj$上には，次の特徴を有する［
`add^jp ／ `delete^jp
］~data~propが存在するモノトスル：
◎
For both of add and delete, if:
• A does not declare an member with a matching identifier, and
• A was declared with a read–write setlike declaration,
◎
then a data property with that name and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<div class="algorithm">
<!--cp-value-is-built-in-func-->
		<ol>
			<!--cp-let-O-this-value-->
			<li>
%name ~LET ~propの名前（ `add^l ／ `delete^l ）
◎
Let name be the name of the property – "add" or "delete".
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<!--cp-let-type-value-type-->
			<li>
%function ~LET
~ABRUPT `Get$A( %set, %name )
◎
Let function be ? Get(set, name).
</li>
			<!--cp-let-arg-1st-arg-->
			<!--cp-arg-toIDL-type-->
			<!--cp-idlValue-toES-->
			<li>
%結果 ~LET
~ABRUPT `Call$A( %function, %set, « %値 » )
◎
Let result be ? Call(function, set, «value»).
</li>
			<li>
~RET ［
%name ~EQ `delete^l ならば %結果 ／
~ELSE_ %O
］
◎
If name is "delete", then return result.
◎
Otherwise, return O.
</li>
		</ol>
</div>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値による~propの名前（ `add^l ／ `delete^l ）とする。
◎
The value of the function object’s name property is the String value "add" or "delete", correspondingly.
</p>

	</li>
</ul>

				</section>
				<section id="es-set-clear">
<h5 title="clear">3.6.11.6. `clear^jp</h5>

<p>
［
%A には 識別子 `clear^l を伴う`~ifc~mb$は宣言されていない
］~AND［
%A は 可書~setlike 宣言を伴って宣言されている
］場合、
%A 用の`~ifc原型~obj$上には，次の特徴を有する `clear^jp ~data~propが存在するモノトスル：
◎
If A does not declare a member with a matching identifier, and A was declared with a read–write setlike declaration, then a clear data property with the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<!--cp-value-is-forwards-clear-->
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `clear^l とする。
◎
The value of the function object’s name property is the String value "clear".
</p>

				</section>
			</section>
		</section>
		<section id="es-platform-objects">
<h3 title="Platform objects implementing interfaces">3.7. ~ifcを実装している~platform~obj</h3>


<div class="algorithm">

<p>
次を満たす~ES値 %値 は
`~platform~objである@
とされる
⇒
［
`Type$A( %値 ) ~EQ `Object^jt
］~AND［
%値 は `PrimaryInterface^sl 内部~slotを持つ
］
◎
An ECMAScript value value is a platform object if Type(value) is Object and if value has a [[PrimaryInterface]] internal slot.
</p>

</div>

<div class="algorithm">

<p>
~ES値 %値 は、次を満たすならば`~ifc$ %~ifc を
`実装-@
するとされる
⇒
［
%値 は `~platform~objである$
］~AND［
%~ifc ~IN ［
%値.`PrimaryInterface^sl の`自身も含む継承した~ifcの~list$
］］
◎
An ECMAScript value value implements an interface interface if value is a platform object and the inclusive inherited interfaces of value.[[PrimaryInterface]] contains interface.
</p>

<p>
各種 仕様は、
“%~obj は %~ifc を実装する”
概念を様々な仕方で参照することもある
— 例： “%~obj は %~ifc ~objである” などの~~句で。
◎
Specifications may reference the concept "object implements interface" in various ways, including "object is an interface object".
</p>
</div>

<p>
各`~platform~obj$には、`~Realm$が結付けられる
— `初期~obj$とちょうど同じく。
【和訳では、このことを “~objは~Realmに属する” ともいう。】
この~Realmは、当の`~platform~obj$の `Realm^sl ~slot内に格納される。
各~platform~objに，どの~Realmが（または、それを代理する，どの大域~objが）結付けられるか言明するのは、~Web~IDLを利用している仕様が責を負う。
特に，下に与える各種~algoは、新たな`~platform~obj$に，引数に与えた~Realmを結付ける。
◎
Every platform object is associated with a Realm, just as the initial objects are. This Realm is stored in the platform object's [[Realm]] slot. It is the responsibility of specifications using Web IDL to state which Realm (or, by proxy, which global object) each platform object is associated with. In particular, the algorithms below associate the new platform object with the Realm given as an argument.
</p>

<div class="algorithm">

<p>
`~ifcを実装する新たな~objを作成する@
ときは、所与の
( %~ifc, ~Realm %~realm, ~JS値 %新-~target （省略時は `undefined^jv ） )
に対し，次の手続きを遂行する：
◎
To create a new object implementing the interface interface, with a Realm realm, perform the following steps:
• Return the result of internally creating a new object implementing interface, with realm and undefined.
◎
To internally create a new object implementing the interface interface, with a Realm realm and a JavaScript value newTarget, perform the following steps:
</p>

<p class="trans-note">【
この手続きは、原文では，
`~ifcを実装する新たな~objを内部的に作成する@
手続きと分けて定義されているが、この訳では，
%新-~target に省略時の値を与えることにより一つに統合する。
】</p>

<ol>
	<li>
~Assert：
%~ifc は %~realm 内に`公開されて$いる
◎
Assert: interface is exposed in realm.
</li>
	<li>
<p>
~IF［
%新-~target ~EQ `undefined^jv
］：
◎
If newTarget is undefined, then:
</p>
		<ol>
			<li>
%原型 ~LET %~realm に属する %~ifc 用の`~ifc原型~obj$
◎
Let prototype be the interface prototype object for interface in realm.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
`~callable$( %新-~target ) ~EQ ~T
◎
Assert: IsCallable(newTarget) is true.
</li>
			<li>
%原型 ~LET
~ABRUPT `Get$A( %新-~target, `prototype^l )
◎
Let prototype be ? Get(newTarget, "prototype").
</li>
			<li>
<p>
~IF［
`Type$A( %原型 ) ~NEQ `Object^jt
］：
◎
If Type(prototype) is not Object, then:
</p>
				<ol>
					<li>
%~target~realm ~LET `GetFunctionRealm$A( %新-~target )
◎
Let targetRealm be GetFunctionRealm(newTarget).
</li>
					<li>
%原型 ~SET %~target~realm に属する %~ifc 用の`~ifc原型~obj$
◎
Set prototype to the interface prototype object for interface in targetRealm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~instance ~LET %~realm に属する新たな `object$jt
◎
Let slots be « [[Realm]], [[PrimaryInterface]] ».
◎
Let instance be a newly created object in realm with an internal slot for each name in slots.
</li>
	<li>
%~instance の
⇒＃
.`Realm^sl ~SET %~realm；
.`PrimaryInterface^sl ~SET %~ifc；
.`Prototype^sl ~SET %原型；
◎
Set instance.[[Realm]] to realm.
◎
Set instance.[[PrimaryInterface]] to interface.
◎
Set instance.[[Prototype]] to prototype.
</li>
	<li>
%~instance の各種~essential内部~methを，`普通の~objの内部~methと内部~slot$に指定される定義に従って設定する
◎
Set instance’s essential internal methods to the definitions specified in ECMA-262 Ordinary object internal methods and internal slots.
</li>
	<li>
%~ifc~list ~LET %~ifc の`自身も含む継承した~ifcの~list$
◎
Let interfaces be the inclusive inherited interfaces of interface.
</li>
	<li>
<p>
%~ifc~list 内の
~EACH( `~ifc$ %先祖~ifc )
に対し：
◎
For every interface ancestor interface in interfaces:
</p>
		<ol>
			<li>
%偽造-不能~obj ~LET %~realm に属する［
%先祖~ifc の`~ifc~obj$
］の `Unforgeables^sl ~slotの値
◎
Let unforgeables be the value of the [[Unforgeables]] slot of the interface object of ancestor interface in realm.
</li>
			<li>
%~key~list ~LET
~NOABRUPT %偽造-不能~obj.`OwnPropertyKeys^sl()
◎
Let keys be ! unforgeables.[[OwnPropertyKeys]]().
</li>
			<li>
<p>
%~key~list を成す
~EACH( %~key )
に対し：
◎
For each element key of keys:
</p>
				<ol>
					<li>
%記述子 ~LET
~NOABRUPT %偽造-不能~obj.`GetOwnProperty^sl( %~key )
◎
Let descriptor be ! unforgeables.[[GetOwnProperty]](key).
</li>
					<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~instance, %~key, %記述子 )
◎
Perform ! DefinePropertyOrThrow(instance, key, descriptor).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~ifc は `Global$x `拡張属性$を伴って宣言されている
］：
◎
If interface is declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
`正則~演算を定義する$( %~ifc, %~instance, %~realm )
◎
Define the regular operations of interface on instance, given realm.
</li>
			<li>
`正則~属性を定義する$( %~ifc, %~instance, %~realm )
◎
Define the regular attributes of interface on instance, given realm.
</li>
			<li>
`大域~prop参照を定義する$( %~instance, %~realm )
◎
Define the global property references on instance, given realm.
</li>
			<li>
%~instance.`SetPrototypeOf^sl を
`platform-object-setprototypeof$sec
に定義されるように設定する
◎
Set instance.[[SetPrototypeOf]] as defined in § 3.7.1 [[SetPrototypeOf]].
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%~ifc~list 内に［
`有index~propを~support$する／`有名~propを~support$する
］`~ifc$は在る
］：
◎
Otherwise, if interfaces contains an interface which supports indexed properties, named properties, or both:
</p>
		<ol>
			<li>
%~instance.`GetOwnProperty^sl を
`legacy-platform-object-getownproperty$sec
に定義されるように設定する
◎
Set instance.[[GetOwnProperty]] as defined in § 3.8.1 [[GetOwnProperty]].
</li>
			<li>
%~instance.`Set^sl を
`legacy-platform-object-set$sec
に定義されるように設定する
◎
Set instance.[[Set]] as defined in § 3.8.2 [[Set]].
</li>
			<li>
%~instance.`DefineOwnProperty^sl を
`legacy-platform-object-defineownproperty$sec
に定義されるように設定する
◎
Set instance.[[DefineOwnProperty]] as defined in § 3.8.3 [[DefineOwnProperty]].
</li>
			<li>
%~instance.`Delete^sl を
`legacy-platform-object-delete$sec
に定義されるように設定する
◎
Set instance.[[Delete]] as defined in § 3.8.4 [[Delete]].
</li>
			<li>
%~instance.`PreventExtensions^sl を
`legacy-platform-object-preventextensions$sec
に定義されるように設定する
◎
Set instance.[[PreventExtensions]] as defined in § 3.8.5 [[PreventExtensions]].
</li>
			<li>
%~instance.`OwnPropertyKeys^sl を
`legacy-platform-object-ownpropertykeys$sec
に定義されるように設定する
◎
Set instance.[[OwnPropertyKeys]] as defined in § 3.8.6 [[OwnPropertyKeys]].
</li>
		</ol>
	</li>
	<li>
~RET %~instance
◎
Return instance.
</li>
</ol>
</div>


<div class="algorithm">

<p>
`大域~prop参照を定義する@
ときは、所与の
( %~target, `~Realm$ %~realm )
に対し、次の手続きを遂行する：
◎
To define the global property references on target, given Realm realm, perform the following steps:
</p>

<ol>
	<li>
%~ifc~list ~LET ［
%~realm 内に`公開されて$いる すべての`~ifc$
］を，次に従うように~sortした結果
⇒
任意の~ifc %A, %B に対し、
%A は %B を`継承-$するならば， %A は %B より後に~listされる
◎
Let interfaces be a list that contains every interface that is exposed in realm.
◎
Sort interfaces in such a way that if A and B are items of interfaces, and A inherits from B, A has a higher index in interfaces than B.
</li>
	<li>
<p>
%~ifc~list を成す
~EACH( %~ifc )
に対し：
◎
For every interface of interfaces:
</p>
		<ol>
			<li>
<p>
~IF［
%~ifc は［
`NoInterfaceObject$x ／ `LegacyNamespace$x 
］`拡張属性$を伴って宣言されていない
］：
◎
If interface is not declared with the [NoInterfaceObject] or [LegacyNamespace] extended attributes, then:
</p>
				<ol>
					<li id="cp-id-be-identifier">
%id ~LET %~ifc の`識別子$
◎
Let id be interface’s identifier.
</li>
					<li id="cp-create-interface-obj">
%~ifc~obj ~LET `~ifc~objを作成する$( %~ifc, %id, %~realm )
◎
Let interfaceObject be the result of creating an interface object for interface with id in realm.
</li>
					<li id="cp-CreateMethodProperty-target">
~NOABRUPT `CreateMethodProperty$A( %~target, %id, %~ifc~obj )
◎
Perform ! CreateMethodProperty(target, id, interfaceObject).
</li>
					<li>
<p>
~IF［
%~ifc は `LegacyWindowAlias$x `拡張属性$を伴って宣言されている
］~AND［
%~target は `Window$T `~ifc$を実装する
］：
◎
If the interface is declared with a [LegacyWindowAlias] extended attribute, and target implements the Window interface, then:
</p>
						<ol>
							<li>
<p>
`LegacyWindowAlias$x の`識別子$wAたちを成す
~EACH( `識別子$wA %id )
に対し
◎
For every identifier id in [LegacyWindowAlias]'s identifiers:
</p>
								<ol>
									<!--cp-CreateMethodProperty-target-->
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~ifc は `NamedConstructor$x `拡張属性$を伴って宣言されている
］：
◎
If the interface is declared with a [NamedConstructor] extended attribute, then:
</p>
				<ol>
					<li>
<p>
`NamedConstructor$x の`識別子$nCたちを成す
~EACH( `識別子$nC %id )
に対し：
◎
For every identifier id in [NamedConstructor]'s identifiers:
</p>
						<ol>
							<li>
%有名~構築子 ~LET `有名~構築子を作成する$( %id, %~ifc, %~realm )
◎
Let namedConstructor be the result of creating a named constructor with id for interface in realm.
</li>
							<li>
~NOABRUPT `CreateMethodProperty$A( %~target, %id, %有名~構築子 )
◎
Perform ! CreateMethodProperty(target, id, namedConstructor).
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%~realm 内に`公開されて$いる
~EACH( `~callback~ifc$ %~ifc )
に対し：
◎
For every callback interface interface that is exposed in realm＼
</p>
		<ol>
			<li>
~IF［
%~ifc には`定数$は定義されていない
］
⇒
~CONTINUE
◎
and on which constants are defined:
</li>
			<!--cp-id-be-identifier-->
			<li>
%~ifc~obj ~LET `旧来の~callback~ifc~objを作成する$( %~ifc, %id, %~realm )
◎
Let interfaceObject be the result of creating a legacy callback interface object for interface with id in realm.
</li>
			<!--cp-CreateMethodProperty-target-->
		</ol>
	</li>
	<li>
<p>
%~realm 内に`公開されて$いる
~EACH( `~ns$ %~ns )
に対し：
◎
For every namespace namespace that is exposed in realm:
</p>
		<ol>
			<li>
%id ~LET %~ns の`識別子$
◎
Let id be namespace’s identifier.
</li>
			<li>
%~ns~obj ~LET `~ns~objを作成する$( %~ns, %~realm )
◎
Let namespaceObject be the result of creating a namespace object for namespace in realm.
</li>
			<li>
~NOABRUPT `CreateMethodProperty$A( %~target, %id, %~ns~obj )
◎
Perform ! CreateMethodProperty(target, id, namespaceObject).
</li>
		</ol>
	</li>
</ol>

</div>

<div class="note">

<p>注記：
`~platform~obj$が`実装-$する~ifcの集合は、~objが存続する限り変化しない。
◎
The set of interfaces that a platform object implements does not change over the lifetime of the object.
</p>

<p>
互いに異なる`大域~obj$を伴う複数の`~platform~obj$は、それらの `PrimaryInterface^sl 内部~slotにて同じ`~ifc$への参照を共有することになる。
例えば~pageは、同一-生成元に属する~iframeを包含し得る
— ［
~main~pageの同じ種類の要素
］上で［
その~iframeの~meth
］が~callされても例外は投出されないような【？】。
◎
Multiple platform objects with different global objects will share a reference to the same interface in their [[PrimaryInterface]] internal slots. For example, a page may contain a same-origin iframe, with the iframe’s method being called on the main page’s element of the same kind, with no exception thrown.
</p>

<p>
`~ifc~mixin$ %~mixin は、`実装-$する~algoの評価に直に関与することはない。
代わりに， %~mixin を`内包-$する各`~ifc$は、自前の［
%~mixin を成す各`~mb$の “複製”
］を持ち、対応する`演算~関数を作成する$ときに，
`the receiver^en 【？】が［
%~mixin を`内包-$する特定0の`~ifc$を`実装-$する
］かどうかを検査する。
◎
Interface mixins do not participate directly in the evaluation of the implements algorithm. Instead, each interface that the interface mixin is included in has its own "copy" of each member of the interface mixin, and the corresponding operation function checks that the receiver implements the particular interface which includes the interface mixin.
</p>

</div>

<div class="algorithm">
<p>
`~platform~obj$ %O の
`首~ifc@
は、 %O の `PrimaryInterface^sl 内部~slotの値を返す
— それは、 %O が`実装-$する`~ifc$のうち，継承~階層において最も末端の~ifcである。
◎
The primary interface of a platform object is the value of the object’s [[PrimaryInterface]] internal slot, which is is the most-derived interface that it implements.
</p>
</div>

<p>
所与の`~platform~obj$ %O に対し，
%O が`属する~Realm$は、 %O の作成-後に
`変化-@
し得る。
%O が`属する~Realm$が変化したときは、即時に，
%O の `Prototype^sl `内部~slot$を［
その新たな`~Realm$に属する `首~ifc$用の`~ifc原型~obj$
］に更新するモノトスル。
◎
The Realm that a given platform object is associated with can change after it has been created. When the Realm associated with a platform object is changed, its [[Prototype]] internal slot must be immediately updated to be the interface prototype object of the primary interface from the platform object’s newly associated Realm.
</p>

<p>
1 個~以上の~ifcを実装する`~platform~obj$ %O の`~class文字列$は、
%O の`首~ifc$の`有修飾~名$になるモノトスル。
◎
The class string of a platform object that implements one or more interfaces must be the qualified name of the primary interface of the platform object.
</p>

<p>
加えて，`~platform~obj$は［
`Global$x `拡張属性$を伴って宣言されている~ifc
］を実装するならば、次に挙げるものから宣言的に~propを取得する
⇒＃
`es-stringifier$sec,
`es-iterators$sec,
`es-iterable$sec,
`es-maplike$sec,
`es-setlike$sec
◎
Additionally, platform objects which implement an interface which has a [Global] extended attribute get properties declaratively from:
• § 3.6.7.2 Stringifiers,
• § 3.6.8 Common iterator behavior,
• § 3.6.9 Iterable declarations,
• § 3.6.10 Maplike declarations, and
• § 3.6.11 Setlike declarations.
</p>

<!--cp-issue-imperatively-->

			<section id="platform-object-setprototypeof">
<h4>3.7.1. `SetPrototypeOf^sl</h4>

<div class="algorithm">
<p>
`Global$x `拡張属性$を伴う`~ifc$を実装する`~platform~obj$ %O の `SetPrototypeOf^sl 内部~methが，~ES言語~値 %V で~callされたときは、次を走らす：
◎
When the [[SetPrototypeOf]] internal method of a platform object O that implements an interface with the [Global] extended attribute is called with ECMAScript language value V, the following step is taken:
</p>

<!--cp-SetImmutablePrototype-->
</div>

<p class="note">注記：
`Window$T ~objに対しては、これが実装されているかどうかは観測し得ない
— `WindowProxy$T ~objの存在pにより、 `Window^T ~obj上では， `SetPrototypeOf^sl が直に~callされることは決してないことが確保されるので。
しかしながら，他の~大域~objに対しては、このことは必要とされない。
◎
Note: For Window objects, it is unobservable whether this is implemented, since the presence of the WindowProxy object ensures that [[SetPrototypeOf]] is never called on a Window object directly. For other global objects, however, this is necessary.
</p>

			</section>
		</section>
		<section id="es-legacy-platform-objects">
<h3 title="Legacy platform objects">3.8. 旧来の~platform~obj</h3>

<p>
`旧来の~platform~obj$は、［
自身の［
`有index~prop$, `有名~prop$
］に対応するような 追加的な~prop
］を持つように現れることになる。
これらの~propは，~obj上の “真の” 自前の~propではないが、
`GetOwnProperty^sl 内部~methにより公開されて見えるようにされる。
◎
Legacy platform objects will appear to have additional properties that correspond to their indexed and named properties. These properties are not “real” own properties on the object, but are made to look like they are by being exposed by the [[GetOwnProperty]] internal method .
</p>

<p>
~objが複数の［
`有index~propを~support$する~ifc
］を実装することも許可-可能である。
しかしながら，そうであって各~ifcによる［
~objが`~supportする~prop~index$の定義
］が競合している場合に、［
~objが持つように現れることになる追加的な~prop
］がどれになるか, あるいは［
その有index~propに関する正確な挙動
］がどうなるか，については、未定義である。
同じことは、有名~propについても該当する。
◎
It is permissible for an object to implement multiple interfaces that support indexed properties. However, if so, and there are conflicting definitions as to the object’s supported property indices, then it is undefined what additional properties the object will appear to have, or what its exact behavior will be with regard to its indexed properties. The same applies for named properties.
</p>

<p>
［
旧来の~platform~objが実装する，継承~階層において最も末端の~ifc
］上で定義される`有index~prop取得子$が、［
~objに対し，`配列~index$で~index-したときの挙動
］を定義する。
`有index~prop設定子$に対しても同様になる。
先祖の~ifcによる，これらの特殊~演算の定義は、この仕方で上書きできる。
◎
The indexed property getter that is defined on the derived-most interface that the legacy platform object implements is the one that defines the behavior when indexing the object with an array index. Similarly for indexed property setters. This way, the definitions of these special operations from ancestor interfaces can be overridden.
</p>

<div class="p">
<p>
所与の~platform~obj %O 上の~prop名は、
%O が次を満たす`~ifc$ %I を実装するならば，
`偽造-不能な~prop名@
とされる：
</p>

<ul><li>%I はその~prop名を識別子とする`~ifc~mb$を持つ, かつ
</li><li>その~mbは［
%O が実装するいずれかの~ifc
］上で`偽造-不能$である。
</li></ul>

◎
A property name is an unforgeable property name on a given platform object O if the object implements an interface that has an interface member with that identifier and that interface member is unforgeable on any of the interfaces that O implements.
</div>

<p>
`取得子$の~supportは
`legacy-platform-object-getownproperty$sec
にて取扱われ、`設定子$については
`legacy-platform-object-defineownproperty$sec,
`legacy-platform-object-set$sec
にて取扱われる。
◎
Support for getters is handled in § 3.8.1 [[GetOwnProperty]], and for setters in § 3.8.3 [[DefineOwnProperty]] and § 3.8.2 [[Set]].
</p>

<p>
加えて，`旧来の~platform~obj$には、次に挙げる内部~methが定義される
⇒
`legacy-platform-object-delete$sec,
`legacy-platform-object-preventextensions$sec,
`legacy-platform-object-ownpropertykeys$sec
◎
Additionally, legacy platform objects have internal methods as defined in:
• § 3.8.4 [[Delete]],
• § 3.8.5 [[PreventExtensions]], and
• § 3.8.6 [[OwnPropertyKeys]].
</p>

			<section id="legacy-platform-object-getownproperty">
<h4>3.8.1. `GetOwnProperty^sl</h4>

<div class="algorithm">
<p>
どの`旧来の~platform~obj$ %O に対しても，その `GetOwnProperty^sl 内部~methは、
( ~prop名 %P )
を引数に~callされたときには，次に従って挙動するモノトスル：
◎
The [[GetOwnProperty]] internal method of every legacy platform object O must behave as follows when called with property name P:
</p>

<ol>
	<li>
~RET
`LegacyPlatformObjectGetOwnProperty$A( %O, %P, `false^jv )
◎
Return LegacyPlatformObjectGetOwnProperty(O, P, false).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-set">
<h4>3.8.2. `Set^sl</h4>

<div class="algorithm">
<p>
どの`旧来の~platform~obj$ %O に対しても，その `Set^sl 内部~methは、
( ~prop名 %P, 値 %V, ~ES言語~値 %Receiver )
を引数に~callされたときには，次に従って挙動するモノトスル：
◎
The [[Set]] internal method of every legacy platform object O must behave as follows when called with property name P, value V, and ECMAScript language value Receiver:
</p>

<ol>
	<li>
<p>
~IF［
%O ~EQ %Receiver
］：
◎
If O and Receiver are the same object, then:
</p>
		<ol>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有index~prop設定子$を伴う
］~AND［
%P は`配列~indexで$ある
］：
◎
If O implements an interface with an indexed property setter and P is an array index, then:
</p>
				<ol>
					<li>
`有index~prop設定子を呼出す$( %P, %V )
◎
Invoke the indexed property setter with P and V.
</li>
					<li>
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴う
］~AND［
`Type$A( %P ) ~EQ `String^jt
］：
◎
If O implements an interface with a named property setter and Type(P) is String, then:
</p>
				<ol>
					<li>
`有名~prop設定子を呼出す$( %P, %V )
◎
Invoke the named property setter with P and V.
</li>
					<li>
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%ownDesc ~LET
`LegacyPlatformObjectGetOwnProperty$A( %O, %P, `true^jv )
◎
Let ownDesc be LegacyPlatformObjectGetOwnProperty(O, P, true).
</li>
	<li>
~ABRUPT `OrdinarySetWithOwnDescriptor$A( %O, %P, %V, %Receiver, %ownDesc )
◎
Perform ? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-defineownproperty">
<h4>3.8.3. `DefineOwnProperty^sl</h4>

<div class="algorithm">
<p>
`旧来の~platform~obj$ %O
］の `DefineOwnProperty^sl 内部~methは，［
~prop~key %P, `~pdesc$ %Desc
］を伴って~callされたときは、次の手続きに従うモノトスル：
◎
When the [[DefineOwnProperty]] internal method of a legacy platform object O is called with property key P and Property Descriptor Desc, the following steps must be taken:
</p>

<ol>
	<li>
<p id="cp-if-support-and-index">
~IF［
%O は `有index~propを~support$する
］~AND［
%P は `配列~indexで$ある
］：
◎
If O supports indexed properties and P is an array index, then:
</p>
		<ol>
			<li id="cp-ret-false-ifnot-IsDataDescriptor">
~IF［
`IsDataDescriptor$A( %Desc ) を~callした結果 ~EQ `false^jv
］
⇒
~RET `false^jv
◎
If the result of calling IsDataDescriptor(Desc) is false, then return false.
</li>
			<li>
~IF［
%O が`実装-$する どの~ifcにも，`有index~prop設定子$は伴われていない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with an indexed property setter, then return false.
</li>
			<li>
`有index~prop設定子を呼出す$( %P, %Desc.`Value^sl )
◎
Invoke the indexed property setter with P and Desc.[[Value]].
</li>
			<li>
~RET `true^jv
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は `有名~propを~support$する
］~AND［
%O は `Global$x `拡張属性$を伴う`~ifc$を`実装-$しない
］~AND［
`Type$A( %P ) ~EQ `String^jt
］~AND［
%P は %O の `Unforgeable$x ~prop名でない
］：
◎
If O supports named properties, O does not implement an interface with the [Global] extended attribute, Type(P) is String, and P is not an unforgeable property name of O, then:
</p>
		<ol>
			<li>
%作成する ~LET ［
%P は %O が`~supportする~prop名$であるならば ~T ／
~ELSE_ ~F
］
◎
Let creating be true if P is not a supported property name, and false otherwise.
</li>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは `OverrideBuiltins$x `拡張属性$を伴う
］~OR［
%O は 名前 %P の自前の~propを持たない
］：
◎
If O implements an interface with the [OverrideBuiltins] extended attribute or O does not have an own property named P, then:
</p>
				<ol>
					<li>
~IF［
%作成する ~EQ ~F
］~AND［
%O が`実装-$する どの~ifcにも，`有名~prop設定子$は伴われていない
］
⇒
~RET `false^jv
◎
If creating is false and O does not implement an interface with a named property setter, then return false.
</li>
					<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴う
］：
◎
If O implements an interface with a named property setter, then:
</p>
						<ol>
							<!--cp-ret-false-ifnot-IsDataDescriptor-->
							<li>
`有名~prop設定子を呼出す$( %P, %Desc.`Value^sl )
◎
Invoke the named property setter with P and Desc.[[Value]].
</li>
							<li>
~RET `true^jv
◎
Return true.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%O は `Global$x `拡張属性$を伴う`~ifc$を`実装-$しない
］
⇒
%Desc.`Configurable^sl ~SET `true^jv
◎
If O does not implement an interface with the [Global] extended attribute, then set Desc.[[Configurable]] to true.
</li>
	<li>
~RET `OrdinaryDefineOwnProperty$A( %O, %P, %Desc )
◎
Return OrdinaryDefineOwnProperty(O, P, Desc).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-delete">
<h4>3.8.4. `Delete^sl</h4>

<div class="algorithm">
<p>
どの`旧来の~platform~obj$ %O においても，その `Delete^sl 内部~methは、~prop名 %P を伴って~callされたときには，次に従って挙動するモノトスル。
◎
The [[Delete]] internal method of every legacy platform object O must behave as follows when called with property name P.
</p>

<ol>
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<li id="cp-ToUint32-2">
%index ~LET `ToUint32$A( %P )
◎
Let index be the result of calling ToUint32(P).
</li>
			<li>
~IF［
%index は %O が`~supportする~prop~index$でない
］
⇒
~RET `true^jv
◎
If index is not a supported property index, then return true.
</li>
			<li>
~RET `false^jv
◎
Return false.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は `有名~propを~support$する
］~AND［
%O は `Global$x `拡張属性$を伴う`~ifc$を`実装-$しない
］~AND［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］：
◎
If O supports named properties, O does not implement an interface with the [Global] extended attribute and the result of calling the named property visibility algorithm with property name P and object O is true, then:
</p>
		<ol>
			<li>
~IF［
%O が`実装-$する どの~ifcにも，`有名~prop削除子$は伴われていない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with a named property deleter, then return false.
</li>
			<li>
%演算 ~LET `有名~prop削除子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property deleter.
</li>
			<li>
<p id="cp-ifdef-no-id">
~IF［
%演算 は `識別子$を伴わずに定義されている
］：
◎
If operation was defined without an identifier, then:
</p>
				<ol>
					<li>
［
~ifcの記述に挙げられている`既存の有名~propを削除する$手続き
］を
( 名前 %P )
を与える下で遂行することにより、既存の有名~propを削除する
◎
Perform the steps listed in the interface description to delete an existing named property with P as the name.
</li>
					<li>
~IF［
手続きから削除の失敗-が指示された
］
⇒
~RET `false^jv
◎
If the steps indicated that the deletion failed, then return false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise, operation was defined with an identifier:
</p>
				<ol>
					<li>
［
%演算 の記述に挙げられている手続き
］を［
引数~list « %P »
］を与える下で遂行する
◎
Perform the steps listed in the description of operation with P as the only argument value.
</li>
					<li>
~IF［
%演算 は `返り値~型$ `boolean$T を伴って宣言されている
］~AND［
その手続きから `false^V が返された
］
⇒
~RET `false^jv
◎
If operation was declared with a return type of boolean and the steps returned false, then return false.
</li>
				</ol>
			</li>
			<li id="cp-return-true">
~RET `true^jv
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は 名前 %P の自前の~propを持つ
］：
◎
If O has an own property with name P, then:
</p>
		<ol>
			<li>
~IF［
その~propは~configure可能でない
］
⇒
~RET `false^jv
◎
If the property is not configurable, then return false.
</li>
			<li>
~ELSE
⇒
その~propを %O から除去する
◎
Otherwise, remove the property from O.
</li>
		</ol>
	</li>
	<!--cp-return-true-->
</ol>
</div>
			</section>
			<section id="legacy-platform-object-preventextensions">
<h4>3.8.5. `PreventExtensions^sl</h4>

<div class="algorithm">
<p>
`旧来の~platform~obj$の `PreventExtensions^sl 内部~methが~callされたときは、次を走らす：
◎
When the [[PreventExtensions]] internal method of a legacy platform object is called, the following steps are taken:
</p>

<ol>
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>
</div>

<p class="note">注記:
これにより、`旧来の~platform~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps legacy platform objects extensible by making [[PreventExtensions]] fail for them.
</p>
			</section>
			<section id="legacy-platform-object-ownpropertykeys">
<h4>3.8.6. `OwnPropertyKeys^sl</h4>

<p>
この文書は、`~ifc$を実装している`~platform~obj$（あるいは
`例外を表現する~platform~obj＠#es-exception-objects$href
）に対しては，完全な~prop列挙~順序は定義しない。
が、`旧来の~platform~obj$に対しては，定義する
— 次に与える `OwnPropertyKeys^sl 内部~methを定義することにより。
◎
This document does not define a complete property enumeration order for platform objects implementing interfaces (or for platform objects representing exceptions). However, it does for legacy platform objects by defining the [[OwnPropertyKeys]] internal method as follows.
</p>

<div class="algorithm">
<p>
`旧来の~platform~obj$ %O の `OwnPropertyKeys^sl 内部~methの~call時には、次を走らす：
◎
When the [[OwnPropertyKeys]] internal method of a legacy platform object O is called, the following steps are taken:
</p>

<ol>
	<li>
%~key~list ~LET 新たな空`~list$
— これは、いくつかの~ES［
`String^jt ／ `Symbol^jt
］値からなる。
◎
Let keys be a new empty list of ECMAScript String and Symbol values.
</li>
	<li>
~IF［
%O は`有index~propを~support$する
］
⇒
~EACH( %O が`~supportする~prop~index$ %~index )
に対し，昇順に
⇒
%~key~list に
~NOABRUPT `ToString$A( %~index ) を`付加する$
◎
If O supports indexed properties, then for each index of O’s supported property indices, in ascending numerical order, append ! ToString(index) to keys.
</li>
	<li>
~IF［
%O は`有名~propを~support$する
］
⇒
~EACH( %O が`~supportする~prop名$ %P )
に対し
【~prop名の集合を定義する仕様により定義される順序で】
⇒
~IF［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］
⇒
%~key~list に %P を`付加する$
◎
If O supports named properties, then for each P of O’s supported property names that is visible according to the named property visibility algorithm, append P to keys.
</li>
	<li>
%O の
~EACH( 自前の~prop~key %P )
に対し，~propを作成した順に
⇒
~IF［
%P は `String^jt である
］
⇒
%~key~list に %P を`付加する$
◎
For each P of O’s own property keys that is a String, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
%O の
~EACH( 自前の~prop~key %P )
に対し，~propを作成した順に
⇒
~IF［
%P は `Symbol^jt である
］
⇒
%~key~list に %P を`付加する$
◎
For each P of O’s own property keys that is a Symbol, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
~Assert:
%~key~list 内には重複する~itemは無い
◎
Assert: keys has no duplicate items.
</li>
	<li>
~RET %~key~list
◎
Return keys.
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-abstract-ops">
<h4 title="Abstract operations">3.8.7. 各種 抽象-演算</h4>

<div class="algorithm">
<p>
所与の~prop名 %P が
`配列~indexで@
あるかどうか決定するときは、次の~algoを適用する：
◎
To determine if a property name P is an array index, the following algorithm is applied:
</p>

<ol>
	<li>
~IF［
`Type$A( %P ) ~NEQ `String^jt
］
⇒
~RET ~F
◎
If Type(P) is not String, then return false.
</li>
	<li>
%index ~LET
~NOABRUPT `CanonicalNumericIndexString$A( %P )
◎
Let index be ! CanonicalNumericIndexString(P).
</li>
	<li>
~IF［
%index ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If index is undefined, then return false.
</li>
	<li>
~IF［
`IsInteger$A(%index) ~EQ `false^jv
］
⇒
~RET ~F
◎
If IsInteger(index) is false, then return false.
</li>
	<li>
<p>
~IF［
%index ~EQ −0
］~OR［
%index ~LT 0
］~OR［
%index ~GTE 2`32^sup ~MINUS 1
］
⇒
~RET ~F
◎
If index is −0, then return false.
◎
If index &lt; 0, then return false.
◎
If index ≥ 232 − 1, then return false.
</p>

<p class="note">注記：
2`32^sup ~MINUS 1 は、~ESに許容される最大の配列~長さである。
◎
Note: 232 − 1 is the maximum array length allowed by ECMAScript.
</p>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algorithm">
<p>
所与の有名~propを~obj上に公開するかどうかは、
`有名~propの可視性判定~algo@
を利用して決定される。
一部の有名~propは、［
`OverrideBuiltins$x `拡張属性$が利用されたかどうか
］に依存して，~obj上に公開されなくなる。
この~algoは、所与の
( ~prop名 %P, ~obj %O )
に対し，次に従って演算する：
◎
The named property visibility algorithm is used to determine if a given named property is exposed on an object. Some named properties are not exposed on an object depending on whether the [OverrideBuiltins] extended attribute was used. The algorithm operates as follows, with property name P and object O:
</p>

<ol>
	<li>
~IF［
%P は %O が`~supportする~prop名$でない
］
⇒
~RET ~F
◎
If P is not a supported property name of O, then return false.
</li>
	<li>
<p>
~IF［
%O は名前 %P の自前の~propを持つ
］
⇒
~RET ~F
◎
If O has an own property named P, then return false.
</p>

<p class="note">注記：
これには %O が偽造-不能な~propを持つ事例も含まれる
— 実施においては、それらは常に %O が~supportする~prop名を持つ前に設定しておかれ，対応する有名~propを不可視にするので。
◎
Note: This will include cases in which O has unforgeable properties, because in practice those are always set up before objects have any supported property names, and once set up will make the corresponding named properties invisible.
</p>

	</li>
	<li>
~IF［
%O が`実装-$する ある~ifcは， `OverrideBuiltins$x `拡張属性$を持つ
］
⇒
~RET ~T
◎
If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
</li>
	<li>
%prototype ~LET %O . `GetPrototypeOf^sl()
◎
Let prototype be O.[[GetPrototypeOf]]().
</li>
	<li>
<p>
~WHILE［
%prototype ~NEQ `null^jv
］：
◎
While prototype is not null:
</p>
		<ol>
			<li>
~IF［
%prototype は `有名~prop~obj$でない
］~AND［
%prototype は 名前 %P の自前の~propを持つ
］
⇒
~RET ~F
◎
If prototype is not a named properties object, and prototype has an own property named P, then return false.
</li>
			<li>
%prototype ~SET %prototype . `GetPrototypeOf^sl()
◎
Set prototype to prototype.[[GetPrototypeOf]]().
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="note">

<p>注記：
これにより、有名~propを伴う~objに対する~prop解決は，次の順序で行えるようになる：
◎
This should ensure that for objects with named properties, property resolution is done in the following order:
</p>
<ol>
	<li>
有index~prop
◎
Indexed properties.
</li>
	<li>
自前の~prop
— 偽造-不能な属性／演算も含め。
◎
Own properties, including unforgeable attributes and operations.
</li>
	<li>
<p>
`OverrideBuiltins$x である場合：
◎
Then, if [OverrideBuiltins]:
</p>
		<ol>
			<li>
有名~prop
◎
Named properties.
</li>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
		</ol>
	</li>
	<li>
<p>
他の場合：
◎
Otherwise, if not [OverrideBuiltins]:
</p>
		<ol>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
			<li>
有名~prop
◎
Named properties.
</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">
<p>
`有index~prop設定子を呼出す@
ときは、所与の
( ~prop~名 %P, ~ES値 %V )
に対し，次の手続きを遂行するモノトスル：
◎
To invoke an indexed property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol>
	<!--cp-ToUint32-2-->
	<li>
%作成する ~LET ［
%index は 当の~objが`~supportする~prop~index$でないならば ~T ／
~ELSE_ ~F
］
◎
Let creating be true if index is not a supported property index, and false otherwise.
</li>
	<li>
%演算 ~LET `有index~prop設定子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the indexed property setter.
</li>
	<li id="cp-2nd-arg">
%T ~LET %演算 の 2 個目の引数の型
◎
Let T be the type of the second argument of operation.
</li>
	<li id="cp-V-toIDL-T">
%値 ~LET %V を型 %T の`~IDL値に変換-$した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%作成する ~EQ ~T
］
⇒
［
~ifcの記述に挙げられている，`新たな有index~propを設定する$手続き
］を
( ~index %index, 値 %値 )
を与える下で遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new indexed property with index as the index and value as the value.
</li>
			<li>
~ELSE
⇒
［
~ifcの記述に挙げられている，`既存の有index~propを設定する$手続き
］を
( ~index %index, 値 %値 )
を与える下で遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing indexed property with index as the index and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
［
%演算 の記述に挙げられている手続き
］を［
引数~list « %index, %値 »
］を与える下で遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with index and value as the two argument values.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`有名~prop設定子を呼出す@
ときは、所与の
( ~prop~名 %P, ~ES値 %V )
に対し，次の手続きを遂行するモノトスル：
◎
To invoke a named property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol>
	<li>
%作成する ~LET ［
%P は 当の~objが`~supportする~prop名$であるならば ~T ／
~ELSE_ ~F
］
◎
Let creating be true if P is not a supported property name, and false otherwise.
</li>
	<li>
%演算 ~LET `有名~prop設定子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property setter.
</li>
	<!--cp-2nd-arg-->
	<!--cp-V-toIDL-T-->
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%作成する ~EQ ~T
］
⇒
［
~ifcの記述に挙げられている，`新たな有名~propを設定する$手続き
］を
( 名前 %P, 値 %値 )
を与える下で遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new named property with P as the name and value as the value.
</li>
			<li>
~ELSE
⇒
［
~ifcの記述に挙げられている，`既存の有名~propを設定する$手続き
］を
( 名前 %P, 値 %値 )
を与える下で遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing named property with P as the name and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
［
%演算 の記述に挙げられている手続き
］を［
引数~list « %P, %値 »
］を与える下で遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with P and value as the two argument values.
</li>
</ol>
</div>

<div class="algorithm">
<p>
抽象-演算
`LegacyPlatformObjectGetOwnProperty@A
は、所与の
( ~obj %O, ~prop名 %P, 真偽~値 %有名~propは無視する )
で~callされたとき，次の手続きを遂行する：
◎
The LegacyPlatformObjectGetOwnProperty abstract operation performs the following steps when called with an object O, a property name P, and a boolean ignoreNamedProps value:
</p>

<ol>
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<!--cp-ToUint32-2-->
			<li>
<p>
~IF［
%index は %O が`~supportする~prop~index$である
］：
◎
If index is a supported property index, then:
</p>
				<ol>
					<li>
%演算 ~LET `有index~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the indexed property getter.
</li>
					<!--cp-let-uninitialized-->
					<li>
~IF［
%演算 は `識別子$を伴わずに定義されている
］
⇒
%値 ~SET［
~ifcの記述に挙げられている，`有index~propの値を決定する$手続き
］を
( ~index %index )
を与える下で遂行した結果
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of an indexed property with index as the index.
</li>
					<li>
~ELSE
⇒
%値 ~SET［
%演算 の記述に挙げられている手続き
］を［
引数~list « %index »
］を与える下で遂行した結果
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with index as the only argument value.
</li>
					<li>
<p>
~RET 次のようにされた新たな`~pdesc$
⇒
`BTT-V^desc
— ここで：
</p>
						<ul>
							<!--cp-let-convert2-->
							<li>
%B は ［
%O が`実装-$する ある~ifcは`有index~prop設定子$を伴うならば `true^jv ／
~ELSE_ `false^jv
］
</li>
						</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with an indexed property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
Set desc.[[Enumerable]] and desc.[[Configurable]] to true.
◎
Return desc.
</li>
				</ol>
			</li>
			<li>
%有名~propは無視する ~SET ~T
◎
Set ignoreNamedProps to true.
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は `有名~propを~support$する
］~AND［
%有名~propは無視する ~EQ ~F
］：
◎
If O supports named properties and ignoreNamedProps is false, then:
</p>
		<ol>
			<li>
<p>
~IF［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］：
◎
If the result of running the named property visibility algorithm with property name P and object O is true, then:
</p>
				<ol>
					<li>
%演算 ~LET `有名~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
					<!--cp-let-uninitialized-->
					<!--cp-determine-ifndef-->
					<!--cp-set-as-desc1-->
					<li>
<p>
~RET 次のようにされた新たな`~pdesc$
⇒
`BET-V^desc
— ここで：
</p>
						<ul>
							<!--cp-let-convert2-->
							<li>
%B は［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴うならば `true^jv ／
~ELSE_ `false^jv
］
</li>
							<li>
%E は［
%O が`実装-$する ある~ifcは `LegacyUnenumerableNamedProperties$x `拡張属性$を伴うならば `false^jv ／
~ELSE_ `true^jv
］
</li>
						</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with a named property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
If O implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Configurable]] to true.
◎
Return desc.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<!--cp-return-OrdinaryGetOwnProperty-->
</ol>
</div>

			</section>
		</section>
		<section id="es-user-objects">
<h3 title="Callback interfaces">3.9. ~callback~ifc</h3>

<p>
上の`idl-objects$secに述べたように、`~callback~ifc$は，~script内の どの~ES~objも実装できる。
所与の~obj上で`~callback~ifc$の`演算$がどう呼出されるかを，以下の場合分けで説明する：
◎
As described in § 2.12 Objects implementing interfaces, callback interfaces can be implemented in script by any ECMAScript object. The following cases explain how a callback interface's operation is invoked on a given object:
</p>

<ul>
	<li>
%O は`~callable$である場合、その演算の実装は， %O 自身になる。
◎
If the object is callable, then the implementation of the operation is the callable object itself.
</li>
	<li>
他の場合，その演算の実装は、［
その演算の`識別子$を~prop名として， %O 上の `Get^sl 内部~methを呼出した結果
］を~callすることである。
◎
Otherwise, the implementation of the operation is calling the result of invoking the internal [[Get]] method on the object with a property name that is the identifier of the operation.
</li>
</ul>

<p>
`~callback~ifc$に`定数$が宣言されていようが、［
~ES~objが それを実装していると見なされるためには、そのような定数に対応する~propを持つ必要がある
］わけではないことに注意。
◎
Note that ECMAScript objects need not have properties corresponding to constants on them to be considered as implementing callback interfaces that happen to have constants declared on them.
</p>

<p class="trans-note">【
共通の記述を集約するため、この訳では，以下に定義される各種 手続きの中から一部分を抽出して，次の 2 つの手続き
"PrepareSettings",
"CleanupSettings"
に~~分離する：
】</p>

<div class="algorithm">
<p>
`PrepareSettings@A( %~realm, %値 )
は、次を遂行する：
</p>

<ol>
<li>%関連な設定群 ~LET %~realm の`設定群~obj$
</li><li>%格納-済み設定群 ~LET %値 の`~callback文脈$
</li><li>`~scriptを走らすために準備する$( %関連な設定群 )
</li><li>`~callbackを走らすために準備する$( %格納-済み設定群 )
</li><li>~RET 組 ( %関連な設定群, %格納-済み設定群 )
</li></ol>
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be XXX’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</div>

<div class="algorithm">
<p>
`CleanupSettings@A( %設定群~組, %completion, %T )
は、次を遂行する
— ここで：
</p>
<ul><li>%設定群~組 は `PrepareSettings$A で得られた 2 つの設定群の組
</li><li>%completion は`完了record$
</li><li>%T はある~IDL型
</li></ul>

<ol>
	<li>
( %関連な設定群, %格納-済み設定群 ) ~LET %設定群~組
</li>
	<li>
`走らせた~callbackを片付ける$( %格納-済み設定群 )
</li>
	<li>
`走らせた~scriptを片付ける$( %関連な設定群 )
</li>
	<li>
~IF［
%completion は正常完了である【`中途完了$でない】
］~OR［
%T は`~promise型$でない
］
⇒
~RET %completion
</li>
	<li>
%却下される~promise ~LET
~NOABRUPT `Call$A( `Promise_reject$jI, `Promise$jI, « %completion.`Value^sl » )
</li>
	<li>
~RET %却下される~promise を %T 型の`~IDL値に変換-$した結果
</li>
</ol>

◎
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and T is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»).
• Return the result of converting rejectedPromise to T.
</div>

<p>
`~Web~IDL引数~list@
は`~list$であり、その各~itemは，~IDL値または［
与えられなかった随意~引数~用の特別な値
`missing@C
］を与える。
◎
A Web IDL arguments list is a list of values each of which is either an IDL value or the special value “missing”, which represents a missing optional argument.
</p>

<div class="algorithm">
<p>
`~ES引数~listに変換する@
ときは、所与の
( `~Web~IDL引数~list$ %args )
に対し，次の手続きを遂行する：
◎
To convert a Web IDL arguments list to an ECMAScript arguments list, given a Web IDL arguments list args, perform the following steps:
</p>

<ol>
	<li>
%esArgs ~LET 空`~list$
◎
Let esArgs be an empty list.
</li>
	<li>
%i ~LET 0
◎
Let i be 0.
</li>
	<li>
%count ~LET 0
◎
Let count be 0.
</li>
	<li>
<p>
~WHILE［
%i ~LT %args の`~size$
］：
◎
While i &lt; args’s size:
</p>
		<ol>
			<li>
~IF［
%arg[ %i ] ~EQ `missing$C
］
⇒
%esArgs に `undefined^jv を`付加する$
◎
If args[i] is the special value “missing”, then append undefined to esArgs.
</li>
			<li>
<p>
~ELSE（ %arg[ %i ] は~IDL値である）：
◎
Otherwise, args[i] is an IDL value:
</p>
				<ol>
					<li>
%変換-結果 ~LET
%arg[ %i ] を`~ES値に変換-$した結果
— 例外は投出し直す
◎
Let convertResult be the result of converting args[i] to an ECMAScript value. Rethrow any exceptions.
</li>
					<li>
%esArgs に %変換-結果 を付加する
◎
Append convertResult to esArgs.
</li>
					<li>
%count ~SET %i ~PLUS 1
◎
Set count to i + 1.
</li>
				</ol>
			</li>
			<li>
%i ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
%esArgs を %count 個の~itemまでに切落す
◎
Truncate esArgs to contain count items.
</li>
	<li>
~RET %esArgs
◎
Return esArgs.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`利用元~objの演算を~callする@
ときは、所与の
⇒＃
`~callback~ifc型$の値 %値,
演算~名 %演算~名,
`~Web~IDL引数~list$ %args,
`~callback this 値@ %thisArg （随意）
◎終
に対し、次の手続きを遂行する
— この手続きは、~IDL値を返すか，例外を投出する。
◎
To call a user object’s operation, given a callback interface type value value, operation name opName, Web IDL arguments list args, and optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>

<ol>
	<li id="cp-let-completion">
%completion ~LET ε
◎
Let completion be an uninitialized variable.
</li>
	<li id="cp-let-default-thisArg">
~IF［
%thisArg は与えられていない
］
⇒
%thisArg ~LET `undefined^jv
◎
If thisArg was not given, let thisArg be undefined.
</li>
	<li>
%O ~LET %値 に対応している~ES~obj
◎
Let O be the ECMAScript object corresponding to value.
</li>
	<li>
%~realm ~LET %O が`属する~Realm$
◎
Let realm be O’s associated Realm.
</li>
	<li>
%設定群~組 ~LET `PrepareSettings$A( %~realm, %値 )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be value’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%T ~LET 当の演算の返り値~型
◎
↓</li>
	<li>
%X ~LET %O
◎
Let X be O.
</li>
	<li>
<p>
~IF［
~NOABRUPT `IsCallable$A( %O ) ~EQ ~F
］：
◎
If ! IsCallable(O) is false, then:
</p>
		<ol>
			<li>
%getResult ~LET `Get$A( %O, %演算~名 )
◎
Let getResult be Get(O, opName).
</li>
			<li>
~IF［
%getResult は`中途完了$である：
］
⇒
~RET `CleanupSettings$A( %設定群~組, %getResult, %T )
◎
If getResult is an abrupt completion, set completion to getResult and jump to the step labeled return.
</li>
			<li>
%X ~SET %getResult.`Value^sl
◎
Set X to getResult.[[Value]].
</li>
			<li>
<p>
~IF［
~NOABRUPT `IsCallable$A( %X ) ~EQ ~F
］：
◎
If ! IsCallable(X) is false, then＼
</p>
				<ol>
					<li>
%completion ~SET 新たな `Completion$A{
`Type^sl: `throw^i,
`Value^sl: 新たな `TypeError^jE ~obj,
`Target^sl: 空
}
◎
set completion to a new Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}, and＼
</li>
					<li>
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
jump to the step labeled return.
</li>
				</ol>
			</li>
			<li>
%thisArg ~SET %O
（供された値を上書きする）
◎
Set thisArg to O (overriding the provided value).
</li>
		</ol>
	</li>
	<li id="cp-convert-to-es-args">
<p>
%esArgs ~LET `~ES引数~listに変換する$( %args )
◎
Let esArgs be the result of converting args to an ECMAScript arguments list.＼
</p>

<p>
~IF［
変換-時に例外 %E が投出された
］
⇒
~RET `CleanupSettings$A( %設定群~組, %E, %T )
◎
If this throws an exception, set completion to the completion value representing the thrown exception and jump to the step labeled return.
</p>
	</li>
	<li>
%~call結果 ~LET `Call$A( %X, %thisArg, %esArgs )
◎
Let callResult be Call(X, thisArg, esArgs).
</li>
	<li id="cp-callResult-is-abrupt">
~IF［
%~call結果 は`中途完了$である
］
⇒
~RET `CleanupSettings$A( %設定群~組, %~call結果, %T )
◎
If callResult is an abrupt completion, set completion to callResult and jump to the step labeled return.
</li>
	<li id="cp-set-completion-callResult">
%completion ~SET
%~call結果.`Value^sl を %T 型の`~IDL値に変換-$した結果
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as the operation’s return type.
</li>
	<li id="call-user-object-operation-return">
<p>
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
</p>
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the operation has a return type that is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»).
• Return the result of converting rejectedPromise to the operation’s return type.
</li>
</ol>
</div>

			<section id="legacy-callback-interface-object">
<h4 title="Legacy callback interface object">3.9.1. 旧来の~callback~ifc~obj</h4>

<p>
所与の`~Realm$ %R 内に`公開されて$いる どの`~callback~ifc$ %I に対しても、
%I 上に`定数$が定義されているならば，
%R の`大域~obj$上に，対応する 次の特徴を有する~propが存在する：
◎
For every callback interface that is exposed in a given Realm and on which constants are defined, a corresponding property exists on the Realm's global object.＼
</p>

<ul>
	<li>
名前：
%I の`識別子$
◎
The name of the property is the identifier of the callback interface, and＼
</li>
	<li>
値：
`旧来の~callback~ifc~obj@
と呼ばれる~obj
— これは，`組込みの関数~obj$であり、下の
`es-constants$sec
にて述べるように， %I 上に定義される`定数$のそれぞれに対応する~propを持つ。
◎
its value is an object called the legacy callback interface object.
◎
The legacy callback interface object for a given callback interface is a built-in function object. It has properties that correspond to the constants defined on that interface, as described in sections § 3.6.5 Constants.
</li>
</ul>

<p class="note">注記：
`旧来の~callback~ifc~obj$は `関数~obj$なので、
`typeof^op 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since a legacy callback interface object is a function object the typeof operator will return "function" when applied to a legacy callback interface object.
</p>

<div class="algorithm">
<p>
`~callback~ifc$用の`旧来の~callback~ifc~obj$は、以下に従って作成される
—
`旧来の~callback~ifc~objを作成する@
ときは、所与の
( `~callback~ifc$ %I, `識別子$ %識別子, `~Realm$ %~realm )
に対し，次を走らす：
◎
The legacy callback interface object for a given callback interface interface with identifier id and in Realm realm is created as follows:
</p>

<ol>
	<li>
<!--cp-let-steps-->
		<ol>
			<!--cp-throw-typeerror-->
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<!--cp-SetFunctionLength-F-0-->
	<li>
`定数を定義する$( %I, %F, %~realm )
◎
Define the constants of interface on F given realm.
</li>
	<!--cp-ret-F-->
</ol>
</div>


			</section>
		</section>
		<section id="es-invoking-callback-functions">
<h3 title="Invoking callback functions">3.10. ~callback関数の呼出ng</h3>

<p>
`~callback関数$値として利用されている~ES`~callable$~objは、（前~節に述べたように）`~callback~ifc$上の`演算$と同様な方式で~callされる。
◎
An ECMAScript callable object that is being used as a callback function value is called in a manner similar to how operations on callback interface values are called (as described in the previous section).
</p>

<div class="algorithm">
<p>
`~callback関数を呼出す@
ときは、所与の
⇒＃
`~callback関数~型$の値 %callable,
`~Web~IDL引数~list$ %args,
`~callback this 値$ %thisArg（随意）
◎終
に対し，次の手続きを遂行する
— この手続きは、~IDL値を返すか，例外を投出する。
◎
To invoke a callback function type value callable with a Web IDL arguments list args and an optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>

<ol>
	<!--cp-let-completion-->
	<!--cp-let-default-thisArg-->
	<li id="cp-let-F-callable">
%F ~LET %callable に対応している~ES~obj
◎
Let F be the ECMAScript object corresponding to callable.
</li>
	<li>
%T ~LET 当の~callback関数の返り値~型
◎
↓</li>
	<li>
<p>
~IF［
~NOABRUPT `IsCallable$A( %F ) ~EQ ~F
］：
◎
If ! IsCallable(F) is false:
</p>
		<ol>
			<li>
<p>
~IF［
%T ~EQ `void$T
］
⇒
~RET
◎
If the callback function’s return type is void, return.
</p>

<p class="note">注記：
これがアリなのは、
`TreatNonObjectAsNull$x が付与された属性による~callback関数に限られる。
◎
Note: This is only possible when the callback function came from an attribute marked with [TreatNonObjectAsNull].
</p>
			</li>
			<li>
~RET `undefined^jv を %T 型の`~IDL値に変換-$した結果
◎
Return the result of converting undefined to the callback function’s return type.
</li>
		</ol>
	</li>
	<li id="cp-let-realm-F-Realm">
%~realm ~LET %F が`属する~Realm$
◎
Let realm be F’s associated Realm.
</li>
	<li id="cp-PrepareSettings1">
%設定群~組 ~LET `PrepareSettings$A( %~realm, %callable )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be callable’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<!--cp-convert-to-es-args-->
	<li>
%~call結果 ~LET `Call$A( %F, %thisArg, %esArgs )
◎
Let callResult be Call(F, thisArg, esArgs).
</li>
	<!--cp-callResult-is-abrupt-->
	<!--cp-set-completion-callResult-->
	<li id="invoke-return">
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the callback function has a return type that is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»).
• Return the result of converting rejectedPromise to the callback function’s return type.
</li>
</ol>
</div>

<p>
~callback関数には、`構築子$として利用できるものもある。
そのような~callback関数の返り値~型は`~promise型$になってはナラナイ。
◎
Some callback functions are instead used as constructors. Such callback functions must not have a return type that is a promise type.
</p>

<div class="algorithm">
<p>
`~callback関数で構築する@
ときは、所与の
⇒＃
`~callback関数~型$の値 %callable,
`~Web~IDL引数~list$ %args
◎終
に対し，次の手続きを遂行する
— この手続きは、~IDL値を返すか，例外を投出する：
◎
To construct a callback function type value callable with a Web IDL arguments list args, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>

<ol>
	<!--cp-let-completion-->
	<!--cp-let-F-callable-->
	<li>
~IF［
~NOABRUPT `IsConstructor$A( %F ) ~EQ `false^jv
］
⇒
~throwTypeError
◎
If ! IsConstructor(F) is false, throw a TypeError exception.
</li>
	<!--cp-let-realm-F-Realm-->
	<li>
%T ~LET 当の~callback関数の返り値~型
◎
↓</li>
	<!--cp-PrepareSettings1-->
	<!--cp-convert-to-es-args-->
	<li>
%~call結果 ~LET `Construct$A( %F, %esArgs )
◎
Let callResult be Construct(F, esArgs).
</li>
	<!--cp-callResult-is-abrupt-->
	<!--cp-set-completion-callResult-->
	<li>
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• Return completion.
</li>
</ol>
</div>

		</section>
		<section id="es-namespaces">
<h3 title="Namespaces">3.11. ~ns</h3>

<p>
所与の`~Realm$ %R 内に`公開されて$いる どの`~ns$ %~ns に対しても、
%R の`大域~obj$上に，対応する 次の特徴を有する~propが存在する：
◎
For every namespace that is exposed in a given Realm, a corresponding property exists on the Realm's global object.＼
</p>

<ul>
	<li>
名前：
%~ns の`識別子$
◎
The name of the property is the identifier of the namespace, and＼
</li>
	<li>
値：
`~ns~obj@
と呼ばれる~obj
— 詳細は、`namespace-object$secに述べる。
◎
its value is an object called the namespace object.
◎
The characteristics of a namespace object are described in § 3.11.1 Namespace object.
</li>
</ul>

			<section id="namespace-object">
<h4 title="Namespace object">3.11.1. ~ns~obj</h4>

<div class="algorithm">
<p>
`~ns~objを作成する@
ときは、所与の
( `~ns$ %~ns, `~Realm$ %~realm )
に対し，以下に従う：
◎
The namespace object for a given namespace namespace and Realm realm is created as follows:
</p>

<ol>
 	<li>
%~ns~obj ~LET
~NOABRUPT `ObjectCreate$A( %~realm.`ObjectPrototype$jIsl )
◎
Let namespaceObject be ! ObjectCreate(realm.[[Intrinsics]].[[%ObjectPrototype%]]).
</li>
	<li>
`正則~属性を定義する$( %~ns, %~ns~obj, %~realm )
◎
Define the regular attributes of namespace on namespaceObject given realm.
</li>
	<li>
`正則~演算を定義する$( %~ns, %~ns~obj, %~realm )
◎
Define the regular operations of namespace on namespaceObject given realm.
</li>
	<li>
%~ifcたち ~LET 次を満たす`~ifc$たちの集合
⇒
［
`公開されて$いる
］~AND［
%~ns の識別子を引数にとる `LegacyNamespace$x 拡張属性を伴う
］
◎
For each exposed interface interface which has the [LegacyNamespace] extended attribute with the identifier of namespace as its argument,
</li>
	<li>
<p>
%~ifcたち 内の
~EACH( %~ifc )
に対し：
◎
↑</p>
		<ol>
			<!--cp-id-be-identifier-->
			<!--cp-create-interface-obj-->
			<li>
~NOABRUPT `CreateMethodProperty$A( %~ns~obj, %id, %~ifc~obj )
◎
Perform ! CreateMethodProperty(namespaceObject, id, interfaceObject).
</li>
		</ol>
	</li>
	<li>
~RET %~ns~obj
◎
Return namespaceObject.
</li>

</ol>
</div>

			</section>
		</section>
		<section id="es-exceptions">
<h3 title="Exceptions">3.12. 例外</h3>

			<section id="es-DOMException-specialness">
<h4 title="DOMException custom bindings">3.12.1. ~DOMException~custom言語束縛</h4>

<p>
~ES言語束縛における `DOMException$T 用の`~ifc原型~obj$の `Prototype^sl `内部~slot$は、`~ifc原型~objを作成する$抽象-演算に定義されるように，内在的~obj `ErrorPrototype$jI に設定されるモノトスル。
◎
In the ECMAScript binding, the interface prototype object for DOMException has its [[Prototype]] internal slot set to the intrinsic object %ErrorPrototype%, as defined in the create an interface prototype object abstract operation.
</p>

<p>
加えて，実装は、~native `Error$jt ~objに［
特別な力／標準でない~prop
］を与える場合（ `stack^jp ~propなど），それらも `DOMException$T の各~instanceに公開するべきである。
◎
Additionally, if an implementation gives native Error objects special powers or nonstandard properties (such as a stack property), it should also expose those on DOMException instances.
</p>

			</section>
			<section id="es-exception-objects">
<h4 title="Exception objects">3.12.2. 例外~obj</h4>

<p>
`単純~例外$は、対応する型の~native~ES~objにより表現される。
◎
Simple exceptions are represented by native ECMAScript objects of the corresponding type.
</p>

<p>
`DOMException$T は、`DOMException$T ~ifcを実装する`~platform~obj$により表現される。
◎
A DOMException is represented by a platform object that implements the DOMException interface.
</p>

			</section>
			<section id="es-creating-throwing-exceptions">
<h4 title="Creating and throwing exceptions">3.12.3. 例外の作成-法と投出-法</h4>

<div class="algorithm">
<p>
`例外を作成する$ときは、所与の：
</p>

<ul>
	<li>
例外~型 %E
— `単純~例外$, `DOMException$T のいずれか
</li>
	<li>
文字列 %N
— `~error名$を与える／
%E は `DOMException$T の場合に限り与えられる
</li>
	<li>
文字列 %M
— ~UAにより定義される~messageを与える／
省略時は `undefined^jv
</li>
</ul>

<p>
に対し， %E に応じて 次を走らす：
</p>

<ul class="switch">
	<li>
<p>
`DOMException$T：
</p>
		<ol>
			<li>
%X ~LET `現在の~Realm$に属する `DOMException$T `~ifc~obj$
</li>
			<li>
~RET
~NOABRUPT `Construct$A( %X, « %M, %N » )
</li>
		</ol>
	</li>
	<li>
<p>
`単純~例外$：
</p>
		<ol>
			<li>
%X ~LET `現在の~Realm$に属する［［
%E に対応している~ES~error
］用の`構築子$
］
</li>
			<li>
~RET
~NOABRUPT `Construct$A( %X, « %M » )
</li>
		</ol>
	</li>
</ul>

◎
To create a simple exception or DOMException E, with a string giving the error name N for the DOMException case and optionally a string giving a user agent-defined message M:
◎
If M was not specified, let M be undefined.
◎
Let args be a list of ECMAScript values determined based on the type of E:
• E is DOMException
•• args is «M, N».
• E is a simple exception
•• args is «M».
◎
Let X be an object determined based on the type of E:
• E is DOMException
•• X is the DOMException interface object from the current Realm.
• E is a simple exception
•• X is the constructor for the corresponding ECMAScript error from the current Realm.
◎
Return ! Construct(X, args).
</div>

<div class="algorithm">

<p>
`例外を投出する$ときは、所与の［
`例外を作成する$ときに与えるものと同じ %引数たち
］に対し，次を走らす：
◎
To throw a simple exception or DOMException, with a string giving the error name for the DOMException case and optionally a string giving a user agent-defined message:
</p>

<ol>
	<li>
`~THROW$ `例外を作成する$( %引数たち )
◎
Let O be the result of creating an exception with the same arguments.
◎
Throw O.
</li>
</ol>

</div>

<div class="note">
<p>
上の~algoは、`関数~obj$ %F から外へ伝播する
`例外を表現する~obj＠#es-exception-objects$hrefを，
%F の`~Realm$（すなわち， %F の実行-時における`現在の~Realm$）に属するものに制約する。
例えば、次の~IDLを考える：
◎
The above algorithms restrict objects representing exceptions propagating out of a function object to be ones that are associated with the Realm of that function object (i.e., the current Realm at the time the function executes). For example, consider the IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface MathUtils {
  /* <span class="comment">
%x が負ならば `NotSupportedError$E `DOMException$T を投出する。
◎
If x is negative, throws a "NotSupportedError" DOMException.
</span> */
  double computeSquareRoot(double %x);
};
</pre>

<p>
`computeSquareRoot()^M ~methを異なる`~Realm$に属する `MathUtils^T ~objに適用した場合に投出される例外は、~objではなく，~methの`~Realm$に属する：
◎
If we apply computeSquareRoot to a MathUtils object from a different Realm, then the exception thrown will be from the Realm of the method, not the object it is applied to:
</p>

<pre class="es-code">
const %myMU = window.getMathUtils();          /* <span class="comment">
この~Realmに属する `MathUtils^T
◎
A MathUtils object from this Realm
</span> */
const %otherMU = otherWindow.getMathUtils();  /* <span class="comment">
異なる~Realmに属する `MathUtils^T
◎
A MathUtils object from a different Realm
</span> */

%myMU instanceof Object;                      /* <!--cp-eval-true--> */
%otherMU instanceof Object;                   /* <!--cp-eval-false--> */
%otherMU instanceof otherWindow.Object;       /* <!--cp-eval-true--> */

try {
  %otherMU.doComputation.call(%myMU, -1);
} catch (%e) {
  console.assert(!(%e instanceof DOMException));
  console.assert(%e instanceof otherWindow.DOMException);
}
</pre>

</div>

			</section>
			<section id="es-handling-exceptions">
<h4 title="Handling exceptions">3.12.4. 例外の取扱い</h4>

<p>
他が指定されない限り、この文書の要件に因り~ES~runtime意味論が呼出され，例外が投出されて終端したときは、その例外は~call元まで（そこで~catchされない場合は更にその~call元まで，等々）伝播するモノトスル。
◎
Unless specified otherwise, whenever ECMAScript runtime semantics are invoked due to requirements in this document and end due to an exception being thrown, that exception must propagate to the caller, and if not caught there, to its caller, and so on.
</p>

<p>
`文書~規約＠#conventions$hrefにより，この文書に指定される~algoは、［
`例外が投出された@
ときにとる正確な手続きを指定するか, または
`中途完了$を明示的に取扱う
］ことにより，投出された例外を~~捕えることもある。
◎
Per Document conventions, an algorithm specified in this document may intercept thrown exceptions, either by specifying the exact steps to take if an exception was thrown, or by explicitly handling abrupt completions.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの`~ifc$と 1 つの`例外$を定義する。
`ExceptionThrower^T 上の `valueOf^M 属性は、その値を取得しようと試みられたときは，常に例外を投出するように定義されている。
◎
The following IDL fragment defines two interfaces and an exception. The valueOf attribute on ExceptionThrower is defined to throw an exception whenever an attempt is made to get its value.
</p>

<pre class="webidl">
[Exposed=Window]
interface Dahut {
  attribute DOMString type;
};

[Exposed=Window]
interface ExceptionThrower {
  /* <span class="comment">
この属性は常に `NotSupportedError$E を投出し，決して値を返さない。
◎
This attribute always throws a NotSupportedError and never returns a value.
</span> */
  attribute long valueOf;
};
</pre>

<p>
~ES実装がこの~ifcを~supportしていると見做すとき、例外をどう取扱うかを次の~codeに示す：
◎
Assuming an ECMAScript implementation supporting this interface, the following code demonstrates how exceptions are handled:
</p>

<pre class="es-code">
var %d = getDahut();              /* <span class="comment">
`Dahut^T の~instanceを得る。
◎
Obtain an instance of Dahut.
</span> */
var %et = getExceptionThrower();  /* <span class="comment">
`ExceptionThrower^T の~instanceを得る。
◎
Obtain an instance of ExceptionThrower.
</span> */

try {
  %d.type = { toString: function() { throw "abc"; } };
} catch (%e) {
  /* <span class="comment">
文字列 `abc^l はここで~catchされる。
何故なら、~native~objから文字列への変換の一環として匿名~関数が呼出され，
`DefaultValue^sl, ToPrimitive, ToString のいずれの~algoも，例外を~catchするように定義されていないので。
◎
The string "abc" is caught here, since as part of the conversion from the native object to a string, the anonymous function was invoked, and none of the [[DefaultValue]], ToPrimitive or ToString algorithms are defined to catch the exception.
</span> */
}

try {
  %d.type = { toString: { } };
} catch (%e) {
  /* <span class="comment">
例外はここで~catchされる。
toString ~propの値である~native~obj上で `Call^sl を呼出そうと試みられたので。
◎
An exception is caught here, since an attempt is made to invoke [[Call]] on the native object that is the value of toString property.
</span> */
}

try {
  %d.type = Symbol();
} catch (%e) {
  /* <span class="comment">
例外はここで~catchされる。
`Symbol^jt 値~上で~ES `ToString$A 抽象-演算を呼出そうと試みられたので。
◎
An exception is caught here, since an attempt is made to invoke the ECMAScript ToString abstract operation on a Symbol value.
</span> */
}

%d.type = %et;
  /* <span class="comment">
~catchされなかった `NotSupportedError$E は ここで投出される。
`DefaultValue^sl ~algoは， `ExceptionThrower^T ~obj上の `valueOf^jp ~propの値を取得しようと試みるので。
例外はこの~code~blockの外へ伝播する。
◎
An uncaught "NotSupportedError" DOMException is thrown here, since the [[DefaultValue]] algorithm attempts to get the value of the "valueOf" property on the ExceptionThrower object. The exception propagates out of this block of code.
</span> */
</pre>

</div>

			</section>
		</section>
		<section id="synthetic-module-records">
<h3 title="Synthetic module records">3.13. 合成な~module~record</h3>

<p>
`合成な~Module-Record@
は、各 仕様により定義される~moduleについての情報を表現するために利用される。
~exportされる名前の集合は静的であり、作成~時に決定される（ `CreateSyntheticModule$A への引数として）。
一方で，~exportされる値の集合は、
`SetSyntheticModuleExport$A を利用して，時間とともに変化し得る。
それには、~importするもの, 依存関係は無い。
◎
A Synthetic Module Record is used to represent information about a module that is defined by specifications. The set of exported names is static, and determined at creation time (as an argument to CreateSyntheticModule), while the set of exported values can be changed over time using SetSyntheticModuleExport. It has no imports or dependencies.
</p>

<p class="note">注記：
`合成な~Module-Record$は、種々の~module型を定義するためにも利用できる
— 例えば：
組込みの~module,
~JSON~module,
~CSS~module
◎
Note: A Synthetic Module Record could be used for defining a variety of module types: for example, built-in modules, or JSON modules, or CSS modules.
</p>

<p class="note">注記：
`合成な~Module-Record$は、
`JavaScript Standard Library^cite
提案の策定者たちと~~協同で開発されており，最終的には~ES仕様へ移動されるであろう。
`JSSTDLIB$r
`ECMA-262$r
◎
Note: Synthetic Module Records are being developed in concert with the authors of the JavaScript Standard Library proposal, and might eventually move to the ECMAScript specification. [JSSTDLIB] [ECMA-262].
</p>

<p>
各種
<a href="~TC39#table-36">~Module-Record~field</a>
に加えて、合成な~Module-Recordには，以下に挙げる追加的な~fieldもある。
これら各~fieldは、初期~時には `CreateSyntheticModule$A() 内で設定される。
◎
In addition to the Module Record Fields, Synthetic Module Records have the additional fields listed below. Each of these fields is initially set in CreateSyntheticModule.
</p>

<table class="data" id="table-synthetic-module-record-fields">
<caption>
合成な~Module-Recordを成す追加的な~field
◎
Additional Fields of Synthetic Module Records
</caption>

<thead><tr><th>~field名
</th><th>値~型
</th><th>意味
</th></tr></thead>

<tbody>
<tr><td>`ExportNames^sl
</td><td>
`String^jt からなる~List
◎
List of String
</td><td>
~exportされるすべて名前からなる~List。
◎
A List of all names that are exported.
</td></tr>

<tr><td>`EvaluationSteps^sl
</td><td>
抽象-演算
◎
An abstract operation
</td><td>
~moduleの評価~時に遂行されることになる抽象-演算であり、`合成な~Module-Record$のみを引数にとる。
これは、通例的に `SetSyntheticModuleExport$A を利用して，~exportされる値に設定しておかれることになる。
`ExportNames^sl を改変してはナラナイ。
中途完了を返すこともある／してもヨイ。
◎
An abstract operation that will be performed upon evaluation of the module, taking the Synthetic Module Record as its sole argument. These will usually set up the exported values, by using SetSyntheticModuleExport. They must not modify [[ExportNames]]. They may return an abrupt completion.
</td></tr></tbody></table>

			<section id="createsyntheticmodule">
<h4 title="CreateSyntheticModule">3.13.1. `CreateSyntheticModule^A</h4>

<div class="algorithm">

<p>
抽象-演算
`CreateSyntheticModule@A( %~export名~list, %評価~手続き, %~realm, %~hostが定義するもの )
は、所与の［
~exportされる名前たち, 評価~手続き
］に基づいて，`合成な~Module-Record$を作成する。
それは、次の手続きを遂行する：
◎
The abstract operation CreateSyntheticModule(exportNames, evaluationSteps, realm, hostDefined) creates a Synthetic Module Record based upon the given exported names and evaluation steps. It performs the following steps:
</p>

<ol>
	<li>
~RET `合成な~Module-Record${ 次に挙げる~field }
⇒＃
`Realm^sl: %~realm,
`Environment^sl: `undefined^jv,
`Namespace^sl: `undefined^jv,
`HostDefined^sl: %~hostが定義するもの,
`ExportNames^sl: %~export名~list,
`EvaluationSteps^sl: %評価~手続き
◎
Return Synthetic Module Record { [[Realm]]: realm, [[Environment]]: undefined, [[Namespace]]: undefined, [[HostDefined]]: hostDefined, [[ExportNames]]: exportNames, [[EvaluationSteps]]: evaluationSteps }.
</li>
</ol>
</div>

<p class="note">注記：
`Environment^sl は，ここで設定しておくこともできるが、`~source~text~Module-Record$と対称にするため `Link$A() 内で設定される
— どちらであれ、観測-可能な相違はない。
◎
Note: we could set up [[Environment]] either here or in Link(). It is done in Link() for symmetry with Source Text Module Records, but there is no observable difference.
</p>

			</section>
			<section id="setsyntheticmoduleexport">
<h4 title="SetSyntheticModuleExport">3.13.2. `SetSyntheticModuleExport^A</h4>

<div class="algorithm">

<p>
抽象-演算
`SetSyntheticModuleExport@A( %~module, %~export名, %~export値 )
は、`合成な~Module-Record$を成す予め確立された~export用に~exportされた値を［
設定する／変更する
］ために利用できる。
それは、次の手続きを遂行する：
◎
The abstract operation SetSyntheticModuleExport(module, exportName, exportValue) can be used to set or change the exported value for a pre-established export of a Synthetic Module Record. It performs the following steps:
</p>

<ol>
	<li>
%環境~record ~LET %~module.`Environment^sl の`~EnvironmentRecord$

◎
Let envRec be module.[[Environment]]'s EnvironmentRecord.
</li>
	<li>
%環境~record.<a href="~TC39#table-15">`SetMutableBinding^A</a>( %~export名, %~export値, `true^jv )
を遂行する
◎
Perform envRec.SetMutableBinding(exportName, exportValue, true).
</li>
</ol>
</div>

			</section>
			<section id="smr-concrete-methods">
<h4 title="Concrete Methods">3.13.3. 各種~具体~meth</h4>

<p>
以下のものは、`合成な~Module-Record$用の具体~methであり、対応する`~Module-Record$抽象-~methを実装する。
◎
The following are the concrete methods for Synthetic Module Record that implement the corresponding Module Record abstract methods.
</p>

				<section id="smr-getexportednames">
<h5 title="GetExportedNames">3.13.3.1. `GetExportedNames^A</h5>

<div class="algorithm">

<p>
`GetExportedNames@A( %exportStarSet )
は、`合成な~Module-Record$ %~module を成す具体~methであり，対応する`~Module-Record$抽象-~methを実装する。
それは、次の手続きを遂行する：
◎
The GetExportedNames(exportStarSet) concrete method of a Synthetic Module Record implements the corresponding Module Record abstract method.
◎
It performs the following steps:
◎
Let module be this Synthetic Module Record.
</p>

<ol>
	<li>
~RET %~module.`ExportNames^sl
◎
Return module.[[ExportNames]].
</li>
</ol>
</div>

				</section>
				<section id="smr-resolveexport">
<h5 title="ResolveExport">3.13.3.2. `ResolveExport^A</h5>

<div class="algorithm">

<p>
`ResolveExport@A( %~export名, %解決-集合 )
は、`合成な~Module-Record$ %~module を成す具体~methであり，対応する`~Module-Record$抽象-~methを実装する。
それは、次の手続きを遂行する：
◎
The ResolveExport(exportName, resolveSet) concrete method of a Synthetic Module Record implements the corresponding Module Record abstract method.
◎
It performs the following steps:
◎
Let module be this Synthetic Module Record.
</p>

<ol>
	<li>
~IF［
%~export名 ~NIN %~module.`ExportNames^sl
］
⇒
~RET `null^jv
◎
If module.[[ExportNames]] does not contain exportName, return null.
</li>
	<li>
~RET <a href="~TC39#resolvedbinding-record">ResolvedBinding Record</a>{ 次に挙げる~field }
⇒＃
`Module^sl : %~module,
`BindingName^sl : %~export名
◎
Return ResolvedBinding Record { [[Module]]: module, [[BindingName]]: exportName }.
</li>
</ol>
</div>

				</section>
				<section id="smr-link">
<h5 title="Links">3.13.3.3. `Link^A</h5>

<div class="algorithm">

<p>
`Link@A()
は、`合成な~Module-Record$ %~module を成す具体~methであり，対応する`~Module-Record$抽象-~methを実装する。
それは、次の手続きを遂行する：
◎
The Instantiate() concrete method of a Synthetic Module Record implements the corresponding Module Record abstract method.
◎
It performs the following steps:
◎
Let module be this Synthetic Module Record.
</p>

<ol>
	<li>
%~realm ~LET %~module.`Realm^sl
◎
Let realm be module.[[Realm]].
</li>
	<li>
~Assert：
%~realm ~NEQ `undefined^jv
◎
Assert: realm is not undefined.
</li>
	<li>
%環境 ~LET `NewModuleEnvironment$A( %~realm.`GlobalEnv^sl )
◎
Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).
</li>
	<li>
%~module.`Environment^sl ~SET %環境
◎
Set module.[[Environment]] to env.
</li>
	<li>
%環境~record ~LET %環境 の`~EnvironmentRecord$
◎
Let envRec be env’s EnvironmentRecord.
</li>
	<li>
<p>
%~module.`ExportNames^sl 内の
~EACH( %~export名 )
に対し：
◎
For each exportName in module.[[ExportNames]],
</p>
		<ol>
			<li>
~NOABRUPT %環境~record . <a href="~TC39#table-15">`CreateMutableBinding^A</a>( %~export名, `false^jv )
◎
Perform ! envRec.CreateMutableBinding(exportName, false).
</li>
			<li>
~NOABRUPT %環境~record . <a href="~TC39#table-15">`InitializeBinding^A</a>( %~export名, `undefined^jv )
◎
Perform ! envRec.InitializeBinding(exportName, undefined).
</li>
		</ol>
	</li>
	<li>
~RET `undefined^jv
◎
Return undefined.
</li>
</ol>
</div>

				</section>
				<section id="smr-evaluate">
<h5 title="Evaluate">3.13.3.4. `Evaluate^A</h5>

<div class="algorithm">

<p>
`Evaluate@A()
は、`合成な~Module-Record$ %~module を成す具体~methであり，対応する`~Module-Record$抽象-~methを実装する。
それは、次の手続きを遂行する：
◎
The Evaluate() concrete method of a Synthetic Module Record implements the corresponding Module Record abstract method.
◎
It performs the following steps:
◎
Let module be this Synthetic Module Record.
</p>

<ol>
	<li>
%~module文脈 ~LET 新たな`~ES~code実行~文脈$
◎
Let moduleCxt be a new ECMAScript code execution context.
</li>
	<li>
~Assert：
%~module.`Realm^sl ~NEQ `undefined^jv
◎
↓</li>
	<li>
%~module文脈 の
⇒＃
<a href="~TC39#table-22">Function</a> ~SET `null^jv,
<a href="~TC39#table-22">Realm</a> ~SET %~module.`Realm^sl,
<a href="~TC39#table-22">ScriptOrModule</a> ~SET %~module,
<a href="~TC39#table-23">VariableEnvironment</a> ~SET %~module.`Environment^sl,
<a href="~TC39#table-23">LexicalEnvironment</a> ~SET %~module.`Environment^sl
◎
Set the Function of moduleCxt to null.
◎
↑Assert: module.[[Realm]] is not undefined.
◎
Set the Realm of moduleCxt to module.[[Realm]].
◎
Set the ScriptOrModule of moduleCxt to module.
◎
Set the VariableEnvironment of moduleCxt to module.[[Environment]].
◎
Set the LexicalEnvironment of moduleCxt to module.[[Environment]].
</li>
	<li>
現在`走っている実行~文脈$を休止する
◎
Suspend the currently running execution context.
</li>
	<li>
`実行~文脈~stack$に %~module文脈 を~pushする
⇒
この時点で、 %~module文脈 は`走っている実行~文脈$になる。
◎
Push moduleCxt on to the execution context stack; moduleCxt is now the running execution context.
</li>
	<li>
%completion ~LET %~module.`EvaluationSteps^sl( %~module )
◎
Let completion be the result of performing module.[[EvaluationSteps]](module).
</li>
	<li>
%~module文脈 を休止する
◎
Suspend moduleCxt and＼
</li>
	<li>
`実行~文脈~stack$から %~module文脈 を除去する
◎
remove it from the execution context stack.
</li>
	<li>
今や`実行~文脈~stack$の上端を成す文脈を，`走っている実行~文脈$として再開する
◎
Resume the context that is now on the top of the execution context stack as the running execution context.
</li>
	<li>
~RET <a href="~TC39#sec-completion">`Completion^A</a>( %completion )
◎
Return Completion(completion).
</li>
</ol>
</div>

				</section>
			</section>
		</section>
	</section>
	<section id="common">
<h2 title="Common definitions">4. 共通の定義</h2>

<p>
この節では、すべての`適合~実装$が~supportするモノトスル，いくつかの共通の定義を指定する。
◎
This section specifies some common definitions that all conforming implementations must support.
</p>

		<section id="ArrayBufferView">
<h3>4.1. `ArrayBufferView^T</h3>

<pre class="idl">
typedef (`Int8Array$T or `Int16Array$T or `Int32Array$T or
         `Uint8Array$T or `Uint16Array$T or `Uint32Array$T or `Uint8ClampedArray$T or
         `Float32Array$T or `Float64Array$T or `DataView$T) `ArrayBufferView$;
</pre>

<p>
`ArrayBufferView^T ~typedefは、
`ArrayBuffer$T 上の~viewを供する~objを表現するために利用される。
◎
The ArrayBufferView typedef is used to represent objects that provide a view on to an ArrayBuffer.
</p>

		</section>
		<section id="BufferSource">
<h3>4.2. `BufferSource^T</h3>

<pre class="idl">
typedef (`ArrayBufferView$T or `ArrayBuffer$T) `BufferSource$;
</pre>

<p>
`BufferSource^T ~typedefは、
`ArrayBuffer$T ~obj自身, または
`ArrayBuffer$T 上の~viewを供する~objを表現するために利用される。
◎
The BufferSource typedef is used to represent objects that are either themselves an ArrayBuffer or which provide a view on to an ArrayBuffer.
</p>

		</section>
		<section id="idl-DOMException">
<h3>4.3. `DOMException^T</h3>

<p>
`DOMException$T 型は、次の~IDL片により定義される`~ifc型$である：
◎
The DOMException type is an interface type defined by the following IDL fragment:
</p>

<!-- 
id="dom-domexception-domexception-message-name-message"
id="dom-domexception-domexception-message-name-name
-->
<pre class="webidl">
[Exposed=(Window,Worker), `Serializable$]
interface `DOMException$T {
  /* <span class="comment">
~ES言語束縛についての下の注記も見よ。
◎
but see below note about ECMAScript binding
</span> */
  `constructor＠#dom-domexception-domexception$href(optional `DOMString$T %message = "", optional `DOMString$T %name = "Error"),

  readonly attribute `DOMString$T `name$M;
  readonly attribute `DOMString$T `message$M;
  readonly attribute `unsigned short$T `code$M;

  const `unsigned short$T `INDEX_SIZE_ERR$Ec = 1;
  const `unsigned short$T `DOMSTRING_SIZE_ERR$Ec = 2;
  const `unsigned short$T `HIERARCHY_REQUEST_ERR$Ec = 3;
  const `unsigned short$T `WRONG_DOCUMENT_ERR$Ec = 4;
  const `unsigned short$T `INVALID_CHARACTER_ERR$Ec = 5;
  const `unsigned short$T `NO_DATA_ALLOWED_ERR$Ec = 6;
  const `unsigned short$T `NO_MODIFICATION_ALLOWED_ERR$Ec = 7;
  const `unsigned short$T `NOT_FOUND_ERR$Ec = 8;
  const `unsigned short$T `NOT_SUPPORTED_ERR$Ec = 9;
  const `unsigned short$T `INUSE_ATTRIBUTE_ERR$Ec = 10;
  const `unsigned short$T `INVALID_STATE_ERR$Ec = 11;
  const `unsigned short$T `SYNTAX_ERR$Ec = 12;
  const `unsigned short$T `INVALID_MODIFICATION_ERR$Ec = 13;
  const `unsigned short$T `NAMESPACE_ERR$Ec = 14;
  const `unsigned short$T `INVALID_ACCESS_ERR$Ec = 15;
  const `unsigned short$T `VALIDATION_ERR$Ec = 16;
  const `unsigned short$T `TYPE_MISMATCH_ERR$Ec = 17;
  const `unsigned short$T `SECURITY_ERR$Ec = 18;
  const `unsigned short$T `NETWORK_ERR$Ec = 19;
  const `unsigned short$T `ABORT_ERR$Ec = 20;
  const `unsigned short$T `URL_MISMATCH_ERR$Ec = 21;
  const `unsigned short$T `QUOTA_EXCEEDED_ERR$Ec = 22;
  const `unsigned short$T `TIMEOUT_ERR$Ec = 23;
  const `unsigned short$T `INVALID_NODE_TYPE_ERR$Ec = 24;
  const `unsigned short$T `DATA_CLONE_ERR$Ec = 25;
};
</pre>

<p class="note">注記：
`es-DOMException-specialness$secにて論じたように，~ES言語束縛は
`~ifc型$に対する通常のものを超える追加的な要件を課す。
◎
Note: as discussed in § 3.12.1 DOMException custom bindings, the ECMAScript binding imposes additional requirements beyond the normal ones for interface types.
</p>

<p>
各 `DOMException$T ~objには、
`名前@eX,
`~message@eX
が結付けられる。
いずれも`~JS文字列$とする。
◎
Each DOMException object has an associated name and message, both JavaScript strings.
</p>

<dl class="idl-def">
	<dt id="dom-domexception-domexception"><code class="idlmember">DOMException(%message, %name)</code></dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らすモノトスル：
◎
The DOMException(message, name) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
`this$V の`名前$eX ~SET %name
◎
Set this's name to name.
</li>
			<li>
`this$V の`~message$eX ~SET %message
◎
Set this's message to message.
</li>
		</ol>
	</dd>

	<dt>`name@M</dt>
	<dd>
取得子は、 `this$V の`名前$eXを返すモノトスル。
◎
The name attribute’s getter must return this DOMException object’s name.
</dd>

	<dt>`message@M</dt>
	<dd>
取得子は、 `this$V の`~message$eXを返すモノトスル。
◎
The message attribute’s getter must return this DOMException object’s message.
</dd>

	<dt>`code@M</dt>
	<dd>
取得子は、`~error名~一覧$内に［
`this$V の`名前$eXに対応する旧来の~code
］が［
在るならば それ ／
無いならば 0
］を返すモノトスル。
◎
The code attribute’s getter must return the legacy code indicated in the error names table for this DOMException object’s name, or 0 if no such entry exists in the table.
</dd>
</dl>

<p>
`DOMException$T ~objは`直列化-可能$である：
◎
DOMException objects are serializable objects.
</p>

<ul>
	<li>
<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し：
◎
Their serialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
%直列形.`Name^sl ~SET %値 の`名前$eX
◎
Set serialized.[[Name]] to value’s name.
</li>
			<li>
%直列形.`Message^sl ~SET %値 の`~message$eX
◎
Set serialized.[[Message]] to value’s message.
</li>
			<li>
~UAは、まだ仕様~化されていないが関心ng~data
— 特に， `stack^jp ~propが挙げられる —
が付帯しているならば、それを直列化した表現も %直列形 に添付するベキである
◎
User agents should attach a serialized representation of any interesting accompanying data which are not yet specified, notably the stack property, to serialized.
</li>
		</ol>
	</li>
	<li>
<p>
その`逆直列化~手続き$は、所与の
( %直列形, %値 )
に対し：
◎
Their deserialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
%値 の`名前$eX ~SET %直列形.`Name^sl
◎
Set value’s name to serialized.[[Name]].
</li>
			<li>
%値 の`~message$eX ~SET %直列形.`Message^sl
◎
Set value’s message to serialized.[[Message]].
</li>
			<li>
他にも %直列形 に添付された~dataがあるならば、それも逆直列化して %値 に添付する
◎
If any other data is attached to serialized, then deserialize and attach it to value.
</li>
		</ol>
	</li>
</ul>

		</section>
		<section id="DOMTimeStamp">
<h3>4.4. `DOMTimeStamp^T</h3>

<pre class="idl">
typedef `unsigned long long$T `DOMTimeStamp$;
</pre>

<p>
`DOMTimeStamp^T 型は、~ms数を表現するために利用される。
（何らかの起点に相対的な）絶対的な時間として，または相対的な時間差として。
この型を利用する仕様は、~ms数の解釈-法も定義する必要がある。
◎
The DOMTimeStamp type is used for representing a number of milliseconds, either as an absolute time (relative to some epoch) or as a relative amount of time. Specifications that use this type will need to define how the number of milliseconds is to be interpreted.
</p>
		</section>
		<section id="Function">
<h3>4.5. `Function^T</h3>

<pre class="idl">
callback `Function$ = any (any... %arguments);
</pre>

<p>
`Function^T `~callback関数$型は、渡される引数や返り値の種類に制約のない関数~値を表現するために利用される。
◎
The Function callback function type is used for representing function values with no restriction on what arguments are passed to it or what kind of value is returned from it.
</p>
		</section>
		<section id="VoidFunction">
<h3>4.6. `VoidFunction^T</h3>

<pre class="idl">
callback `VoidFunction$ = void ();
</pre>

<p>
`VoidFunction^T `~callback関数$型は
引数をとらず, 値を返さない関数~値を表現するために利用される。
◎
The VoidFunction callback function type is used for representing function values that take no arguments and do not return any value.
</p>
		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">5. 拡張能</h2>

~INFORMATIVE

<p>
言語束縛の要件に対する拡張は、この文書~内で定義される拡張属性と競合しない`拡張属性$を利用して指定できる。
［
私的な~projectに特有な利用
］のための拡張は、他の仕様に現れる`~IDL片$に含められるべきではない。
他の仕様の用途に要求される拡張は、この文書の将来~versionに取り込まれるためには，
`Web IDL^cite の担当グループ（この文書が書かれた時点では
`W3C Web Platform Working Group＠http://www.w3.org/WebPlatform/WG/$href
）による~~調整を通すことが推奨される。
◎
Extensions to language binding requirements can be specified using extended attributes that do not conflict with those defined in this document. Extensions for private, project-specific use should not be included in IDL fragments appearing in other specifications. It is recommended that extensions that are required for use in other specifications be coordinated with the group responsible for work on Web IDL, which at the time of writing is the W3C Web Platform Working Group, for possible inclusion in a future version of this document.
</p>

<p>
この~IDL言語の他の側面は、拡張しないことが強く奨励される。
◎
Extensions to any other aspect of the IDL language are strongly discouraged.
</p>
	</section>
	<section id="legacy-constructs">
<h2 title="Legacy constructs">6. 旧来の構成子</h2>

~INFORMATIVE

<p>
旧来の~WebIDL構成子が存在するのは、旧来の~Web~platform特能を指定できるようにするために限られる。
一般に，それらには、文字列 `Legacy^l が接頭される。
［
旧来の~Web~platform特能の挙動を指定する／
そのような特能との整合性を得る
］ことが要求されない限り、旧来の~WebIDL構成子は仕様~内に利用しないことが強く奨励される。
旧来の~WebIDL構成子を利用したいと望む編集者には、先に進む前に
`Intent to use a legacy WebIDL construct$fI
した上で論交することを，強く勧める。
◎
Legacy WebIDL constructs exist only so that legacy Web platform features can be specified. They are generally prefixed with the "Legacy" string. It is strongly discouraged to use legacy WebIDL constructs in specifications unless required to specify the behavior of legacy Web platform features, or for consistency with such features. Editors who wish to use legacy WebIDL constructs are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p>
旧来の構成子とすること自体は、この仕様から除去されつつあることは含意しない。
しかしながら，そのような構成子は、［
様々な経験則から，その指定-対象である~Web~platform特能を［
まるごと除去できる／
代わりに旧来のものでない~WebIDL構成子に依拠するよう改変できる
］ことが指示される
］なら，将来にこの仕様から除去する良い候補であることを示唆する。
◎
Marking a construct as legacy does not, in itself, imply that it is about to be removed from this specification. It does suggest however, that it is a good candidate for future removal from this specification, whenever various heuristics indicate that the Web platform features it helps specify can be removed altogether or can be modified to rely on non-legacy WebIDL constructs instead.
</p>
	</section>
	<section id="referencing">
<h2 title="Referencing this specification">7. この仕様を参照するとき</h2>

~INFORMATIVE

<p>
一つ以上の`~IDL片$を利用して~Web~platform~ifcを定義する他の仕様は、この仕様を参照することになるものと期待されている。
それらの仕様には、［
この仕様の記述に従って，~IDLを解釈する
］ことを指示する，次の様な~~文を含めることが示唆される：
◎
It is expected that other specifications that define Web platform interfaces using one or more IDL fragments will reference this specification. It is suggested that those specifications include a sentence such as the following, to indicate that the IDL is to be interpreted as described in this specification:
</p>

<blockquote>
この仕様における各~IDL片は、この仕様が規範とする参照文献にて定義される~IDL片とともに，［
“~Web~IDL” 仕様に述べられる， <em>`適合~IDL片の集合$</em> に課される要件
］に従って解釈するモノトスル。<!--  -->
<a class="placeholder">[WEBIDL]</a>
◎
The IDL fragment in Appendix A of this specification must, in conjunction with the IDL fragments defined in this specification’s normative references, be interpreted as required for conforming sets of IDL fragments, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

<p>
加えて、この仕様を参照する仕様における，~UA用の適合性クラスは、この仕様の`適合~実装$クラスを参照することが示唆される：
◎
In addition, it is suggested that the conformance class for user agents in referencing specifications be linked to the conforming implementation class from this specification:
</p>

<blockquote>
適合 FooML ~UAは、 “~Web~IDL” 仕様の記述に則り，この仕様に示されている各~IDL片に対しても <em>`適合~実装$</em> になるモノトスル。
<a class="placeholder">[WEBIDL]</a>
◎
A conforming FooML user agent must also be a conforming implementation of the IDL fragment in Appendix A of this specification, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">8. ~privacyと~security上の考慮点</h2>

<p>
この仕様は、~JS値と~IDL値との間に変換~層を定義する。
この層の不正な実装は、~security上の課題を導き得る。
◎
This specification defines a conversion layer between JavaScript and IDL values. An incorrect implementation of this layer can lead to security issues.
</p>

<p>
この仕様は、［
`any$T, `object$T
］~IDL型を通して，~JS値を直に利用する能も供する。
~security上の課題を避けるため、これらの値は，注意深く取扱われる必要がある。
特に，利用者~scriptは、これらの値に対する ほぼ どの操作にも呼応して走り得る
— その結果、それらを利用している［
仕様／実装
］の期待を無効化する。
◎
This specification also provides the ability to use JavaScript values directly, through the any and object IDL types. These values need to be handled carefully to avoid security issues. In particular, user script can run in response to nearly any manipulation of these values, and invalidate the expectations of specifications or implementations using them.
</p>

<p>
この仕様は、 `SharedArrayBuffer$jt ~objとヤリトリすることをアリにする
— それは、計時~攻撃を築くことにも利用できる。
これらの~objを利用する仕様は、そのような攻撃を考慮する必要がある。
◎
This specification makes it possible to interact with SharedArrayBuffer objects, which can be used to build timing attacks. Specifications that use these objects need to consider such attacks.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">9. 謝辞</h2>

~INFORMATIVE

<p>
編集者は、この仕様に貢献された，次の方々に感謝する：
</p>

<p lang="en-x-a0">
The editor would like to thank the following people for contributing
to this specification:

Glenn Adams,
David Andersson,
Jake Archibald,
L.&nbsp;David Baron,
Art Barstow,
Nils Barth,
Robin Berjon,
David Bruant,
Jan-Ivar Bruaroey,
Marcos Cáceres,
Giovanni Campagna,
Domenic Denicola,
Chris Dumez,
Michael Dyck,
Brendan Eich,
João Eiras,
Gorm Haug Eriksen,
Sigbjorn Finne,
David Flanagan,
Aryeh Gregor,
Tiancheng “Timothy” Gu,
Dimitry Golubovsky,
James Graham,
Aryeh Gregor,
Kartikaya Gupta,
Marcin Hanclik,
Jed Hartman,
Stefan Haustein,
Dominique Hazaël-Massieux,
Ian Hickson,
Björn Höhrmann,
Kyle Huey,
Lachlan Hunt,
Oliver Hunt,
Jim Jewett,
Wolfgang Keller,
Anne van Kesteren,
Olav Junker Kjær,
Takayoshi Kochi,
Magnus Kristiansen,
Takeshi Kurosawa,
Yves Lafon,
Travis Leithead,
Jim Ley,
Kevin Lindsey,
Jens Lindström,
Peter Linss,
<span lang="zh">呂康豪</span> (Kang-Hao Lu),
Kyle Machulis,
Darien Maillet Valentine,
Mark Miller,
Ms2ger,
Andrew Oakley,
<span lang="ja">岡坂&nbsp;史紀</span> (Shiki Okasaka),
Jason Orendorff,
Olli Pettay,
Simon Pieters,
Andrei Popescu,
François Remy,
Tim Renouf,
Tim Ruffles,
Alex Russell,
Takashi Sakamoto,
Doug Schepers,
Jonas Sicking,
Garrett Smith,
Sam Sneddon,
Jungkee Song,
Josh Soref,
Maciej Stachowiak,
Anton Tayanovskyy,
triple-underscore,
Peter Van der Beken,
Jeff Walden,
Allen Wirfs-Brock,
Jeffrey Yasskin and,
Collin Xu.
</p>

<p>
編集者が休みの間、この文書を保守されていた Sam Weinig に特別な謝意を。
◎
Special thanks also go to Sam Weinig for maintaining this document while the editor was unavailable to do so.
</p>
	</section>
	<section id="idl-grammar">
<h2 title="IDL grammar">~IDL文法</h2>

<p>
この節では、開始~記号 `Definitions$g が`~IDL片$全体に合致する，
LL(1) 文法を定義する。
◎
This section defines an LL(1) grammar whose start symbol, Definitions, matches an entire IDL fragment.
</p>

<div class="p">
<p>
文法~内の各~生成規則には、その右側に 1 個~以上の記号の並びが示される：
</p>

<ul ><li>ε は、何もなしを指示する。
</li><li>等幅~fontで示される記号は、~literalによる終端記号である。
</li><li>大文字から始まり, 斜体で示される記号は、非~終端記号である。
</li><li>小文字から始まり, 斜体で示される記号は、次に示す正規表現に合致する終端記号である（Perl 5 `PERLRE$r の正規表現~構文を利用）。
</li></ul>

◎
Each production in the grammar has on its right hand side either a non-zero sequence of terminal and non-terminal symbols, or an epsilon (ε) which indicates no symbols. Symbols that begin with an uppercase letter are non-terminal symbols. Symbols in monospaced fonts are terminal symbols. Symbols in sans-serif font that begin with a lowercase letter are terminal symbols that are matched by the regular expressions (using Perl 5 regular expression syntax [PERLRE]) as follows:
</div>

<dl class="grammar" id="terminals">
<dt id="prod-integer">`integer^g</dt>
<dd>~SLASH<code>-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)</code>~SLASH</dd>

<dt id="prod-decimal">`decimal^g</dt>
<dd>~SLASH<code>-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)</code>~SLASH</dd>

<dt id="prod-identifier">`identifier^g</dt>
<dd>~SLASH<code>[_-]?[A-Za-z][0-9A-Z_a-z-]*</code>~SLASH</dd>

<dt id="prod-string">`string^g</dt>
<dd>~SLASH<code>"[^"]*"</code>~SLASH</dd>

<dt id="prod-whitespace">`whitespace^g</dt>
<dd>~SLASH<code>[\t\n\r ]+</code>~SLASH</dd>

<dt id="prod-comment">`comment^g</dt>
<dd>~SLASH<code>\/\/.*|\/\*(.|\n)*?\*\/</code>~SLASH</dd>

<dt id="prod-other">`other^g</dt>
<dd>~SLASH<code>[^\t\n\r 0-9A-Za-z]</code>~SLASH</dd>
</dl>

<p>
~token化は~Unicode文字~並び `UNICODE$r に対し演算する。
~token化の際には、最長合致が利用されなければナラナイ。
例えば，入力~textが
“`a1^c”
であるなら、それは 1 個の `identifier$g に~token化され，
`identifier$g と `integer$g には分離されない。
最長合致が［
上に挙げた，名前を持つ終端記号の いずれか
］と［
文法~内の終端記号
］のいずれにも合致し得る場合、後者の終端記号に~token化されなければナラナイ。
したがって、入力~text
“`long^c”
は，
`identifier$g `long^l ではなく，引用符で括られた終端記号 `long^sym
として~token化され、
“`.^c”
は，
`other$g
ではなく，引用符で括られた終端記号
`.^sym
として~token化される。
◎
The tokenizer operates on a sequence of Unicode characters [UNICODE]. When tokenizing, the longest possible match must be used. For example, if the input text is “a1”, it is tokenized as a single identifier, and not as a separate identifier and integer. If the longest possible match could match one of the above named terminal symbols or one of the other terminal symbols from the grammar, it must be tokenized as the latter. Thus, the input text “long” is tokenized as the quoted terminal symbol long rather than an identifier called "long", and “.” is tokenized as the quoted terminal symbol . rather than an other.
</p>

<p>
~IDL構文においては、文字の大小は，文法~内で利用される引用符で括られた終端記号と
`identifier$g 終端記号に利用される値の，いずれにおいても~~区別される。
したがって、例えば入力~text
“`Const^c”
は，終端記号 `const^sym ではなく `identifier$g として~token化され、
`識別子$ `A^l を伴う`~ifc$は， `a^l を伴うそれとは別個になり、
また，`拡張属性$ `namedconstructor^x が `NamedConstructor$x 拡張属性に認識されることはない。
◎
The IDL syntax is case sensitive, both for the quoted terminal symbols used in the grammar and the values used for identifier terminals. Thus, for example, the input text “Const” is tokenized as an identifier rather than the terminal symbol const, an interface with identifier "A" is distinct from one named "a", and an extended attribute [namedconstructor] will not be recognized as the [NamedConstructor] extended attribute.
</p>

<p>
`whitespace$g や `comment$g からなる任意~個数の終端記号が、構文解析される入力~textにおける，他のどの終端記号の合間にも、暗黙的に許容される。
それらの `whitespace$g や `comment$g は、構文解析-時には無視される。
◎
Implicitly, any number of whitespace and comment terminals are allowed between every other terminal in the input text being parsed. Such whitespace and comment terminals are ignored while parsing.
</p>

<p>
次の LL(1) 文法の開始~記号 `Definitions$g が`~IDL片$に合致する：
◎
The following LL(1) grammar, starting with Definitions, matches an IDL fragment:
</p>

<p class="trans-note">【
見出しをクリックするとその文法~記号の~~参照元が示される（上の終端記号の表も同様）。
】</p>

【！place holder for the over all grammar table】
<div id="_p-grammar-table"></div>

<p class="note">注記：
非~終端記号 `Other$g は、
`(^sym, `)^sym,
`[^sym, `]^sym,
`{^sym, `}^sym,
`,^sym
を除く，任意の 1 個の終端記号に合致する。
◎
Note: The Other non-terminal matches any single terminal symbol except for (, ), [, ], {, } and ,.
</p>

<p>
非~終端記号 `ExtendedAttribute$g は，任意の空でない終端記号の並びに合致するが（丸括弧, 角括弧, 波括弧が対になっていて, かつ `,^sym ~tokenがそのような括弧対の間にのみ現れる限り）、それらが成すアリな並びのうち一部のみが，この仕様で定義される`拡張属性$に利用される
— これらの拡張属性に利用される構文については
`idl-extended-attributes$sec
を見よ。
◎
While the ExtendedAttribute non-terminal matches any non-empty sequence of terminal symbols (as long as any parentheses, square brackets or braces are balanced, and the , token appears only within those balanced brackets), only a subset of those possible sequences are used by the extended attributes defined in this specification — see § 2.14 Extended attributes for the syntaxes that are used by these extended attributes.
</p>
	</section>
	<section id="conventions">
<h2 title="Document conventions">表記規約</h2>

<p>
この文書では、次の表記規約／~styleが利用される：
◎
The following typographic conventions are used in this document:
</p>

<p class="trans-note">【
“†” が付与されているものは、この訳による追加的な~style。
】</p>

<ul>
	<li>
用語の定義：
`用語例@
◎
Defining instances of terms: example term
</li>
	<li>
この文書で定義される用語への~link：
`用語例$
◎
Links to terms defined in this document or elsewhere: example term
</li>
	<li>
他の文書で定義される用語への~link：
`example term＠https://example.com#dfn-example-term$href
◎
↑</li>
	<li>
文法の終端記号（~literal）：
`sometoken^sym
◎
Grammar terminals: sometoken
</li>
	<li>
文法の非~終端記号（先頭は大文字）：
`ExampleGrammarSymbol^g
◎
Grammar non-terminals: ExampleGrammarNonTerminal
</li>
	<li>
文法~記号（正規表現による生成規則, 先頭は小文字）：
`identifier^g
◎
Grammar symbols: identifier
</li>
	<li>
~IDL型：
`unsigned long^T
◎
IDL types: unsigned long
</li>
	<li>
~IDL~ifc~mb†：
`ExampleIDLMember^M,<br>
</li>
	<li>
~IDL値†：
`ExampleIDLValue^V
</li>
	<li>
~ES~class：
`Map^jt
◎
ECMAScript classes: Map
</li>
	<li>
~ES言語~型：
`Object^jt
◎
ECMAScript language types: Object
</li>
	<li>
~ES~obj~prop†：
`property^jp
</li>
	<li>
~ES値†：
`undefined^jv
【！emu-val】
</li>
	<li>
~ES内部［~prop／~meth／~slot］†：
`ExamplePropertyOrMethodOrSlot^sl
</li>
	<li>
~ES抽象-演算†：
<a class="abstract">ExampleAbstractOperation</a>
</li>
<!-- 
	<li>
~ES抽象-定数†：
`esConst^i 
【！emu-const】
</li>
 -->
	<li>
~code片：
`a = b + obj.f()^c
◎
Code snippets: a = b + obj.f()
</li>
	<li>
~Unicode文字：
`0030^U1
◎
Unicode characters: U+0030 DIGIT ZERO ("0")
</li>
	<li>
拡張属性：
`ExampleExtendedAttribute^x
◎
Extended attributes: [ExampleExtendedAttribute]
</li>
	<li>
注釈文や~algoにおける変数~名：
%exampleVariableName
◎
Variable names in prose and algorithms: exampleVariableName.
</li>
	<li>
文字列~literal†：
`example string literal^l
</li>
	<li>
~modelを定義するために利用される仮想の定数~値†：
`定数~例^C
</li>
	<li>
<p>
~IDL構文の非正式な例：
◎
IDL informal syntax examples:
</p>

<pre class="syntax">
[`extended_attributes^i]
interface `identifier^i {
  /* `interface_members...^mk */
};
</pre>

<p>
（周囲の注釈文の中で論じられている構文は， `&lt;mark&gt;^c 要素で`強調される^mk（~styleは~browserに依存する）。）
◎
(Specific parts of the syntax discussed in surrounding prose are highlighted.)
</p>
	</li>
	<li>
<p>
~IDL文法~片：
◎
IDL grammar snippets:
</p>

<dl class="grammar">
	<dt>`ExampleGrammarNonTerminal^g</dt>
	<dd>`OtherNonTerminal^g `sometoken^sym
`other$g `AnotherNonTerminal^g
ε  // <span title="nothing">nothing</span></dd>
</dl>

	</li>
	<li>
<p>
規範的でない注記：
◎
Non-normative notes:
</p>

<p class="note">注記：
これは注記。
◎
Note: This is a note.
</p>
	</li>
	<li>
<p>
規範的でない例：
◎
Non-normative examples:
</p>

<div class="example">
<p>
これは例。
◎
This is an example.
</p>
</div>
	</li>
	<li>
<p>
規範的な警告：
◎
Normative warnings:
</p>

<p class="advisement">
これは警告。
◎
This is a warning.
</p>

	</li>
	<li>
<p>
~code~block：
◎
Code blocks:
</p>

<pre class="webidl">
/* <span class="comment">
これは~IDL~code~block。
◎
This is an IDL code block.
</span> */
[Exposed=Window]
interface Example {
  attribute long something;
};
</pre>

<pre class="es-code">
/* <span class="comment">
これは~ES~code~block。
◎
This is an ECMAScript code block.
</span> */
window.onload = function() { window.alert("loaded"); };
</pre>

</li>
</ul>

<p>
この文書の~algoでは、次の規約が利用される：
◎
The following conventions are used in the algorithms in this document:
</p>

<ul>
	<li>
~ES`完了record$（ `Completion Record^en ）による包装を外す（ `unwrap^en する）ための
`"~NOABRUPT" や "~ABRUPT" を接頭する記法＠~TC39#sec-returnifabrupt-shorthands$href
も含め，
`ECMA-262$r による`~algo規約$を利用する。
【この訳では、その接頭-記法を利用している箇所では，原文の句 “`Perform^en（〜を遂行する）” は省略する。】
◎
Algorithms use the conventions of the ECMAScript specification, including the ! and ? notation for unwrapping Completion Records.
</li>
	<li>
~algoは、［
値を返す／例外を投出する
］ことと，`完了record$を返すことを交換-可能に扱うこともある。
すなわち、［
~RET／`~THROW$
を利用する~algo
］は［
`完了record$を返している
］ものと扱われることもあれば、`完了record$を返すものは［
値を返している／例外を投出している
］ものと扱われることもある。
同様に，例外を~catchする際に、［
投出された例外を受け入れる挙動を定義すること
］と, ［［
`完了record$の `Type^sl ~field ~EQ `throw^i
］かどうか検査すること
］とは、等価になる。
◎
Algorithms sometimes treat returning/throwing values and returning Completion Records interchangeably. That is, an algorithm that uses return/throw terminology may be treated as returning a Completion Record, while one that returns a Completion Record may be treated as returning a value or throwing an exception. Similarly, to catch exceptions, defining the behavior to adopt when an exception was thrown and checking if the Completion Record’s [[Type]] field is “throw” are equivalent.
</li>
	<li>
`完了record$は、~Web~IDL値などの~ES値でない値も包含できるよう，拡張された値である。
◎
Completion Records are extended by allowing them to contain values that are not ECMAScript values, such as Web IDL values.
</li>
</ul>

	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p>
明示的に規範的でないものと記された節に加え, この仕様におけるすべての図式, 例, 注記は規範的ではない。他のすべては規範的である。
◎
Everything in this specification is normative except for diagrams, examples, notes and sections marked as being informative.
</p>

<p>
この仕様は、 `Infra Standard^cite `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様への適合性の対象として、次に挙げる類別が定義される
— 以下に現れる “~~必須の判定基準” は、［
この仕様が与える［
“〜ナラナイ” ／ “モノトスル” ／ “要求される”
］~levelの判定基準
］の略記である：
◎
The following conformance classes are defined by this specification:
</p>

<dl>
	<dt>
`適合~IDL片の集合@
◎
conforming set of IDL fragments
</dt>
	<dd>
`~IDL片$の集合は、［
全体として，~IDL片に適用される~~必須の判定基準をすべて満たす
］ならば，`適合~IDL片の集合$であると見なされる。
◎
A set of IDL fragments is considered to be a conforming set of IDL fragments if, taken together, they satisfy all of the must-, required- and shall-level criteria in this specification that apply to IDL fragments.
</dd>

	<dt>
`適合~実装@
◎
conforming implementation
</dt>
	<dd>
~UAは、［
自身が~supportするすべての言語束縛~用の実装に適用される~~必須の判定基準をすべて満たす
］ならば，`適合~IDL片の集合$に対する`適合~実装$であると見なされる。
◎
A user agent is considered to be a conforming implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for all language bindings that the user agent supports.
</dd>
	<dt>
`適合~ES実装@
◎
conforming ECMAScript implementation
</dt>
	<dd>
~UAは、［
~ES言語束縛~用の実装に適用される~~必須の判定基準をすべて満たす
］ならば，`適合~IDL片の集合$に対する`適合~ES実装$であると見なされる。
◎
A user agent is considered to be a conforming ECMAScript implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for the ECMAScript language binding.
</dd>
</dl>

	</section>
</main></div>

