<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP — Digest Headers（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Digest Headers
spec_date:2021-06-11
trans_update:2021-06-15
source_checked:2021-06-11
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html
abbr_url:HTTPdigest
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2021-06-15

●●class_map
a:attr
e:element

●●tag_map
a:code
e:code

●●original_id_map

references:
normative:
informative:

●●mdn_urls

●●link_map

h.Digest:#digest
h.Want-Digest:#want-digest

h.Content-MD5:~RFCx/rfc2616#section-14.15

p.digest-algorithm:#p.digest-algorithm
p.representation-data-digest:#p.representation-data-digest
p.Digest:#p.Digest
p.Want-Digest:#p.Want-Digest
p.want-digest-value:#p.want-digest-value

c.sha-256:#digest-sha-256
i.SHA-256:#digest-sha-256
c.sha-512:#digest-sha-512
i.SHA-512:#digest-sha-512
c.md5:#digest-md5
i.MD5:#digest-md5
c.sha:#digest-sha
i.SHA:#digest-sha
i.SHA-1:#digest-sha
c.unixsum:#digest-unixsum
i.UNIXsum:#digest-unixsum
c.unixcksum:#digest-unixcksum
i.UNIXcksum:#digest-unixcksum
c.id-sha-512:#digest-id-sha-512
c.id-sha-256:#digest-id-sha-256
c.adler32:#digest-adler32
i.ADLER32:#digest-adler32
c.crc32c:#digest-crc32c
i.CRC32c:#digest-crc32c
c.contentMD5:#digest-contentMD5

a.integrity:~SRI1#the-integrity-attribute
e.script:~HEscripting#the-script-element
e.link:~HEmetadata#the-link-element

	表現~digest:#representation-digest

形式変換ng~proxy:~HTTPsem#transforming-proxy
有構造~field:~HEADER-STRUCTURE#structured~field

RFC7231/B:~RFC7231#appendix-B
RFC4960/B:~RFCx/rfc4960#appendix-B

cite.~HTTP~digest~algo値~registry:~IANA-a/http-dig-alg/http-dig-alg.xhtml


1:#introduction
1.1:#document-structure
1.2:#concept-overview
1.3:#notational-conventions
2:#representation-digest
3:#digest
4:#want-digest
5:#algorithms
6:#acting-on-resources
6.1:#digest-and-patch
6.2:#digest-and-content-location
7:#sri
7.1:#supporting-both-sri-and-representation-digest
8:#examples-unsolicited
8.1:#example-full-representation
8.2:#server-returns-no-representation-data
8.3:#server-returns-partial-representation-data
8.4:#client-and-server-provide-full-representation-data
8.5:#client-provides-full-representation-data-server-provides-no-representation-data
8.6:#client-and-server-provide-full-representation-data-client-uses-id-sha-256
8.7:#post-not-request-uri
8.8:#post-referencing-action
8.9:#digest-with-patch
8.10:#error-responses
8.11:#use-with-trailer-fields-and-transfer-coding
9:#examples-solicited
9.1:#server-selects-clients-least-preferred-algorithm
9.2:#server-selects-algorithm-unsupported-by-client
9.3:#server-does-not-support-client-algorithm-and-returns-an-error
10:#security-considerations
10.1:#digest-does-not-protect-the-full-http-message
10.2:#digest-for-end-to-end-integrity
10.3:#usage-in-signatures
10.4:#usage-in-trailer-fields
10.5:#usage-with-encryption
10.6:#algorithm-agility
	10.6.1:#duplicate-digest-algorithm-in-field-value
10.7:#duplicate-digest-algorithm-in-field-value
10.8:#resource-exhaustion
11:#iana-considerations
11.1:#iana-digest-algorithm-registry
11.2:#iana-digest-algorithm-status
11.3:#iana-md5
11.4:#iana-unixsum
11.5:#iana-unixcksum
11.6:#iana-crc32c
11.7:#iana-sha
11.8:#iana-adler-32
11.9:#iana-contentMD5
11.10:#iana-id-sha-256
11.11:#iana-id-sha-512
11.12:#changes-compared-to-rfc3230
11.13:#changes-compared-to-rfc5843
11.14:#want-digest-field-registration
11.15:#digest-field-registration
A:#resource-representation
B.1:#deprecate-contentMD5
B.2:#obsolete-parameters

	:#faq
	:#acknowledgements
	:#code-samples
	:#changes

	SEMANTICS/3.2:~HTTPinfra#representations
SEMANTICS/~field行と結合-済みな~field値:~HTTPinfra#field.lines
	SEMANTICS/5.2:~HTTPinfra#field.lines
SEMANTICS/~list~ABNF拡張:~HTTPinfra#abnf.extension
	SEMANTICS/6.4:~HTTPinfra#content
SEMANTICS/内容の識別-法:~HTTPinfra#identifying.content
SEMANTICS/~trailerの利用に対する制限:~HTTPinfra#trailers.limitations
SEMANTICS/~trailerの処理:~HTTPinfra#trailers.processing
SEMANTICS/~messageの形式変換:~HTTPsem#message.transformations
	SEMANTICS/8.4.1:~HTTPsem#content.codings
	SEMANTICS/8.1:~HTTPsem#representation.data
	SEMANTICS/8.7:~HTTPsem#field.content-location
	SEMANTICS/品質~値:~HTTPsem#quality.values → 品質~値
	SEMANTICS/14.2:~HTTPsem#field.range

●●words_table1
SRI1:webappsec-subresource-integrity-ja.html

●●words_table

	●略語
UNIX:
SRI:
iSCSI:
SCTP:
MICE:
python3:

	●digest
base64:
SHA:
CRC:
checksum::::チェックサム
digital::::デジタル

	^i:SHA-256
	^i:SHA-512
	^i:MD5
	^i:SHA-1
	^i:CRC32c
	^i:ADLER32
	^i:brotli
	^i:MICE
	^cite:ZLIB Compressed Data Format

	●構文
不正形な:malformedな:不正な形の
印字不能:non-printable:~
数字:digit:~
	数字~列:digit string
	数字~列:decimal-digit string
字下げ:indentation:~
単語:word:~
	digest-algorithm^p:Digest-algorithm

	文字大小-法:casing
	小文字:lower-case
	引用符で括られ:quote
	〜形式にされ:formatted
	形式~化:formatting
	頭部:leading
	quoted-string^p:quoted string
	字下げ:2 spaced of leading indentation
	重複な~tokenを除去する:de-duplication
	32 ~bit:32-bit
	16 ~bit:16-bit

	●処理
弄る:mangleする:~
剥がさ:stripさ:~
算出法:computation:~
条件付きに:conditionalに::条件付きで
診断:diagnosis:~

	通過する:pass across
	手渡す:handing off

	●保安
脅威:threat::~
暗号用:cryptographic::~
hamming::::ハミング
破損:corruption:~
当事者主体:first-party::~
衝突:collision:~
操る:steerする:~
改ざん:tampering:~
晒し:exposeし:~

	信用に価する:trustworthy
	暗号化されてない:unencrypted
	抗する:against:
	巡回冗長性:cyclic redundancy::~

	●仕様
仕事:job:~
順応-:adapt:~
刷新-:refresh:~
	能が無い:inability
直面-:face:~
動作者:actor:~
概略的:brief:~
単直:straightforward:簡単
類似性:similarity:~
	類似性がある:shares some similarities
協調:coordination:~
相補的:complementary:~
請求-:solicite:~
	請求されない:unsolicited
証明:proof:~
浪費-:waste:~
枯渇:exhaustion:~
包括的:comprehensive:~
簡潔:compact:~
発展-:evolve:~
	発展-度合いが様々な:population of 〜 with different evolving
相:phase:~
合法的:legitimate:~
偉業:great work:~
即応性:agility::~
廃用d:obsoleted:廃用
移行:transition:~
	から移行-:transitioning away
鑑定:appraisal:~
特質:properties:~
束ねら:tieさ:~
合格-:pass:~
欠陥:fault:~
倣う:alignする:~
不合致:mismatch:~
尊重-:respect:~
発生-:arise:~
構成:structure:~
	構成:structured
助け:help:~
関心事:interesting:~
	興味深い:interesting
固定的:fixed:~
委譲-:delegate:~

	取って代わられ:supersede
	至らす:cause
	したくなる:be tempted to
	好ましい:preferable
	併せて:in conjunction with
	望ましくない:undesirable
	他の場面でも:Other places
	〜ないと見込まれる:less likely
	~~並行して:alongside
	主要な:major
	基づくこと:basing
	一方では:on one hand
	十分:enough
	謝意:thank
	書き直す:rewrite
	委ねられ:left as
	予め除外する:preclude
	大部分:vast majority
	欲されない:undesired
	問わない:agnostic
	選ぶ:choose
	類の:sort of
	発生-:arose
	はず:should
	対照:contrast
	十分~過ぎ:more than enough
	いずれにせよ:anyway
	最終的:eventual
	とても:very
	であったとしても:would have been 〜 too
	~~説明する:help illustrate
	価値はある:valuable
	良好に:nicely
	できなくする:prevent
	してもかまわない:free to
	はい:yes
	考えて:think
	考え:thought
	試験的^i:"experimental"
	廃用d^i:"obsoleted"
	~~能性:potential
	高い:high
	勧める:advise
	とは言え、:Endpoints are advised that
	交わり:intersection
	より低:lower
	選ぶ:chooseする
	偶然:accidentally

	●未分類
帯域:band:~
	帯域外:out-of-band
	帯域内:in-band
消費:consumption::~
返信-:reply:~
再生器:player::~::プレイヤー
patch::::パッチ
増分的:incremental:~
	~stream途中の:mid-stream
計算l:computational:計算
差分:delta:~

	改行:-
	継ぎ合わせる:piecing together
	~~伝送の途上:in flight
	この:the present
	添える:attach
	切り離す:decouple

	●語形
	^r:Single UNIX Specification, version 2
	^en:Internet Assigned Numbers Authority
	^i:identity
	digest-algorithm^p:Digest-algorithm
	`~digest認証^cite:Digest Authentication
	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"
	下位資源の完全性^cite:Subresource Integrity
	表現~digest:Representation Digest
	表現~data:representation-data
	範囲~要請:Range Request
	~field値:field-value
	~digest値:digest-value
	~MIME型:media-type

	●言い換え
中継点:hop::~
	いくつかの中継点を経る:across multiple hops
	~target~URI:effective request URI
	最も選好しない:Least Preferred
	場合に備える:should
	立場:positioned
	能力はない:not capable of
	その動機を成す:motivating
	ある種の:certain kinds of
	〜からの変更点:Changes Compared to
	~transport層:transport-layer
	~message法:messaging
	予め処理する:pre-process
	内容~符号法:content-coding
	内容:payload
	内容:body
	有構造~field:Structured Fields
	~parameter化:parameterized
	参照-先の:referenced
	~secureでない:insecure
	~base64に符号化された:base64-encoded
	符号化されていない:unencoded
	〜を含めて:inclusive
	それらに:in this set
	とは異なる:different compared to
	よくある質問:FAQ
	〜で呈示される場合もある:For presentation purposes, ...
	行l長さの~~都合により...:fit completely within the line-length limits...
	〜形式にされ:formatted
	受信者:receiver
	識別するもの:identification of
	~~分類され:group
	もっと弱い:weaker
	~trailer節:trailers
	段階:stage
	-:finally
	この事例では:accidentally

	●指示
	一体として:in whole
	全体:the whole
	だけ:alone
	他所における:at rest
	各部:parts
	各部ごと:in part
	何も:anything
	回数:number of
	全体を通して:throughout
	最高:highest
	0 でない:non-zero
	一部が:partly

●●ref_normative

[CMU-836068]
    Carnagie Mellon University, Software Engineering Institute, "MD5 Vulnerable to collision attacks", 31 December 2008
    URL: https://www.kb.cert.org/vuls/id/836068/
[IACR-2020-014]
    Leurent, G. and T. Peyrin, "SHA-1 is a Shambles", 5 January 2020
    URL: https://eprint.iacr.org/2020/014.pdf
[NIST800-32]
    National Institute of Standards and Technology, U.S. Department of Commerce, "Introduction to Public Key Technology and the Federal PKI Infrastructure", February 2001
    URL: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-32.pdf
[RFC1321]
    Rivest, R., "The MD5 Message-Digest Algorithm", ~RFC1321, April 1992
[RFC1950]
    Deutsch, P. and J-L. Gailly, "ZLIB Compressed Data Format Specification version 3.3", ~RFC1950, May 1996
[RFC2119]
    Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, ~RFC2119, March 1997
[RFC3174]
    Eastlake 3rd, D. and P. Jones, "US Secure Hash Algorithm 1 (SHA1)", ~RFC3174, September 2001
[RFC3230]
    Mogul, J. and A. Van Hoff, "Instance Digests in HTTP", ~RFC3230, January 2002
[RFC4648]
    Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", ~RFC4648, October 2006
[RFC4960]
    Stewart, R., Ed., "Stream Control Transmission Protocol", ~RFC4960, September 2007
[RFC5234]
    Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax Specifications: ABNF", STD 68, ~RFC5234, January 2008
[RFC5843]
    Bryan, A., "Additional Hash Algorithms for HTTP Instance Digests", ~RFC5843, April 2010
[RFC6234]
    Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)", ~RFC6234, May 2011
[RFC7405]
    Kyzivat, P., "Case-Sensitive String Support in ABNF", ~RFC7405, December 2014
[RFC8174]
    Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, ~RFC8174, May 2017
[SEMANTICS]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP Semantics", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics
[UNIX]
    The Open Group, "The Single UNIX Specification, Version 2 - 6 Vol Set for UNIX 98", February 1997.

●●ref_informative

[HTTP11]
    Fielding, R. T., Nottingham, M., and J. Reschke, "HTTP/1.1", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-messaging
[I-D.ietf-httpbis-header-structure]
    Nottingham, M. and P. Kamp, "Structured Field Values for HTTP", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-structure
[I-D.thomson-http-mice]
    Thomson, M. and J. Yasskin, "Merkle Integrity Content Encoding", Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-thomson-http-mice
[NO-MD5]
    Turner, S. and L. Chen, "Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms", ~RFC6151, March 2011
[NO-SHA1]
    Polk, T., Chen, L., Turner, S., and P. Hoffman, "Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms", ~RFC6194, March 2011
[PATCH]
    Dusseault, L. and J. Snell, "PATCH Method for HTTP", ~RFC5789, March 2010
[RFC2818]
    Rescorla, E., "HTTP Over TLS", ~RFC2818, May 2000
[RFC7231]
    Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content", ~RFC7231, June 2014
[RFC7396]
    Hoffman, P. and J. Snell, "JSON Merge Patch", ~RFC7396, October 2014
[RFC7696]
    Housley, R., "Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms", BCP 201, ~RFC7696, November 2015
[RFC7807]
    Nottingham, M. and E. Wilde, "Problem Details for HTTP APIs", ~RFC7807, March 2016
[RFC8188]
    Thomson, M., "Encrypted Content-Encoding for HTTP", ~RFC8188, June 2017
[SRI]
    Akhawe, D., Braun, F., Marier, F., and J. Weinberger, "Subresource Integrity", W3C Recommendation REC-SRI-20160623, 23 June 2016
    URL: https://www.w3.org/TR/2016/REC-SRI-20160623/


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として発行された，
<a href="~SPEC_URL">Digest Headers</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	<a href="https://datatracker.ietf.org/doc/html/rfc3230">3230</a> （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Roberto Polli, Team Digitale, Italian Government, Italy, Email: <a href="mailto:robipolli@gmail.com">robipolli@gmail.com</a>
	Lucas Pardue, Cloudflare, Email: <a href="mailto:lucaspardue.24.7@gmail.com">lucaspardue.24.7@gmail.com</a>

課題追跡
	https://github.com/httpwg/http-extensions/labels/digest-headers
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-digest-headers.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
HTTP WG メーリングリスト
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
現在の Internet-Drafts のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>


<header>
	<hgroup>
<h1 title="Digest Headers">HTTP — Digest ヘッダ</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT
<p>
この文書は、~HTTP［
`Digest$h, `Want-Digest$h
］~fieldを定義する
— それらは、`~client$と`~server$が［
交換される`資源$の`表現~data$の完全性~checksum
］を折衝することを許容する。
◎
This document defines the HTTP Digest and Want-Digest fields, which allows client and server to negotiate an integrity checksum of the exchanged resource representation data.
</p>

<p>
この文書は、~RFC 3230 を廃用にする。
◎
This document obsoletes RFC 3230.
</p>

	</section>
	<section>
<h2 title="Note to Readers">読者~向け注記</h2>

<p class="trans-note">【
この節の内容は、冒頭の仕様~metadataに移譲。
】</p>

<!-- 
RFC EDITOR: please remove this section before publication

Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at https://lists.w3.org/Archives/Public/ietf-http-wg/.

The source code and issues list for this draft can be found at https://github.com/httpwg/http-extensions.
-->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>／冒頭の仕様~metadata
に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTPは、`表現$の完全性を保護するための手段は定義しない。
~HTTP~messageが端点~間で転送されるとき、当の~protocolは，何らかの完全性~保護を供するために，より低~層を成す特能
— 一例として，~TCP~checksumや~TLS~record —
を用立てることを選ぶかもしれない
`RFC2818$r 。
◎
HTTP does not define a means to protect the integrity of representations. When HTTP messages are transferred between endpoints, the protocol might choose to make use of features of the lower layer in order to provide some integrity protection; for instance TCP checksums or TLS records [RFC2818].
</p>

<p>
この文書は、［
`表現~data$に対し動作する，~HTTP用の完全性の仕組み
］として， `Digest^h† を定義する。
それは：
◎
This document defines the Digest HTTP integrity mechanism that acts on representation data.＼
</p>
<ul>
	<li>
~transport完全性とは独立に運用して，［
~programming~error／
~~伝送の途上や他所における~dataの破損
］を検出する~~能性（ `potential^en ）を提供する。
◎
It operates independent of transport integrity, offering the potential to detect programming errors and corruption of data in flight or at rest.＼
</li>
	<li>
いくつかの中継点（ `hop^en ）を経るときでも，端点間における完全性の保証を供するために利用できる
— それは、`資源$が いくつかの［
中継点／~system境界
］を経て転送されるとき，欠陥~診断を援助し得るものになる。
◎
It can be used across multiple hops in order to provide end-to-end integrity guarantees, which can aid fault diagnosis when resources are transferred across hops and system boundaries.＼
</li>
	<li>
異なる~HTTP接続を利用して~fetchされている`資源$を構築し直すとき，その完全性を検証するために利用できる。
◎
Finally, it can be used to validate integrity when reconstructing a resource fetched using different HTTP connections.
</li>
</ul>

<p class="trans-note">【†
原文にて大文字で記された “`Digest^en” は、
`Digest$h ~fieldを指すことも，
“この仕様が定義する~digestの仕組み”
を意味する所もある。
この 2 つを両義的に表す（明確に線引きできない）所も多々あるので（加えて，原文の~markupも一貫でない）、この訳では一律に`~field$用の~styleで呈示している。
】</p>
【！（英文の慣習により、節の~title内や文の先頭にある `Digest^en は大文字で記されるが，中には小文字による `digest^en を表すものもあるかもしれない。）】

<p>
この文書は `RFC3230$r を廃用にする。
◎
This document obsoletes [RFC3230].
</p>

		<section id="document-structure">
<h3 title="Document Structure">1.1. この文書の構成</h3>

<p>
この文書は、~HTTP用の `Digest^h 完全性を述べる
— この文書の構成は：
◎
This document describes Digest integrity for HTTP and is structured as follows:
</p>
<ul>
	<li>
`2$sec では、表現~digestに関係する概念を述べる。
◎
Section 2 describes concepts related to representation digests,
</li>
	<li>
`3$sec では、
`Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 3 defines the Digest request and response header and trailer field,
</li>
	<li>
`4$sec では、
`Want-Digest$h 【！［要請／応答］［~header／~trailer］】~fieldを定義する。
◎
Section 4 defines the Want-Digest request and response header and trailer field,
</li>
	<li>
`5$sec, `B.1$sec では、
各種~algo, および それらの `Digest^h との関係を述べる。
◎
Section 5 and Appendix B.1 describe algorithms and their relation to Digest,
</li>
	<li>
`6$sec では、
表現~digestの算出-法を詳細に与える。
◎
Section 6 details computing representation digests,
</li>
	<li>
`B.2$sec では、~digest~field~parameterを廃用にする。
◎
Appendix B.2 obsoletes Digest field parameters,
</li>
	<li>
`7$sec では、
`Digest^h と `下位資源の完全性^cite との関係性を述べる。
◎
Section 7 describes the relationship between Digest and Subresource Integrity, and
</li>
	<li>
［
`8$sec ／ `9$sec
］では、［
`Digest$h ／ `Want-Digest$h
］を利用する例を供する。
◎
Section 8 and Section 9 provide examples of using Digest and Want-Digest.
</li>
</ul>

		</section>
		<section id="concept-overview">
<h3 title="Concept Overview">1.2. 概念の概観</h3>

<p>
この文書は `Digest$h ~fieldを定義する。
それは、［
要請, 応答
］どちらにも, ［
`~header節$, `~trailer節$
］どちらにも内包し得る。
高い~levelからは、その値は，
`選定された表現$の`表現~data$【！選定された表現~data】から算出された~checksumを包含する
— それは、`受信者$が完全性を検証するために利用できる。
`Digest$h は、~algo即応性【 `10.6$sec 】を~supportする。
`Want-Digest$h ~fieldは、［
`Digest$h への関心と~algoの選好
］を表出することを端点に許容する。
◎
This document defines the Digest request and response header and trailer field. At a high level the value contains a checksum, computed over selected representation data (Section 3.2; [SEMANTICS]), that the recipient can use to validate integrity. Digest supports algorithm agility. The Want-Digest field allows endpoints to express interest in Digest and preference of algorithms.
</p>

<p>
`Digest$h を`選定された表現$に基づくようにすることは、次に挙げる利用事例に それを適用することを単直にする：
◎
Basing Digest on the selected representation makes it straightforward to apply it to use-cases where＼
</p>
<ul>
	<li>
転送される~dataが、表現と見なされるものに何らかの類の操作を要求する所
◎
the transferred data requires some sort of manipulation to be considered a representation,＼
</li>
	<li>
`資源$の部分的な表現を伝達する所（例：`範囲~要請$ `SEMANTICS$r【！§ 14.2】）
◎
or conveys a partial representation of a resource, for example Range Requests (see Section 14.2 of [SEMANTICS]).
</li>
</ul>

<p>
歴史的に， `Content-MD5$h ~headerは ~HTTP完全性の仕組みを供していたが、
`部分的な応答$に対する取扱いが一貫でないことに因り，
~HTTP11は それを廃用にした（ `RFC7231/B$sec ）。
`RFC3230$r は、
`Content-MD5$h に伴われる課題に取組む助けとして，
“~instance~digest” の概念および，もっと柔軟な完全性~schemeを定義した
— そのためとして、まず［
`Digest$h, `Want-Digest$h
］~fieldを導入した。
`RFC3230$r が発行されて以来、~HTTPの各種用語は発展した。
“~instance” の概念は、`選定される表現$に取って代わられた。
◎
Historically, the Content-MD5 header field provided an HTTP integrity mechanism but HTTP/1.1 ([RFC7231], Appendix B) obsoleted it due to inconsistent handling of partial responses. [RFC3230] defined the concept of "instance" digests and a more flexible integrity scheme to help address issues with Content-MD5. It first introduced the Digest and Want-Digest fields. HTTP terminology has evolved since [RFC3230] was published. The concept of "instance" has been superseded by selected representation.
</p>

<p>
この文書は、 `RFC3230$r を置換する。
［
`Digest$h ／ `Want-Digest$h
］~fieldの定義は、
`SEMANTICS$r による［
用語, 表記規約
］に倣うよう更新された。
変更点は、既存の実装と意味論的に互換になることが意図されるが、次に注意
⇒＃
`Content-MD5$h の折衝は非推奨にされた（ `B.1$sec ）／
`Digest$h ~field用の~parameterは廃用にされた（ `B.2$sec ）／
`digest-algorithm$p のうち "`md5$c", "`sha$c" は廃用にされた／
"`adler32$c" ~algoは非推奨にされた
◎
This document replaces [RFC3230]. The Digest and Want-Digest field definitions are updated to align with the terms and notational conventions in [SEMANTICS]. Changes are intended to be semantically compatible with existing implementations but note that＼
negotiation of Content-MD5 is deprecated Appendix B.1,＼
Digest field parameters are obsoleted Appendix B.2,＼
"md5" and "sha" digest-algorithms are obsoleted,＼
and the "adler32" algorithm is deprecated.
</p>

<p>
`選定された表現$を利用して `Digest$h の値を計算することは、それが［
`Content-Encoding$h, `Content-Type$h
］~headerに束ねられることを意味する。
したがって、所与の`資源$には，異なる複数個の~digest値があり得る。
`内容~符号法$ `SEMANTICS$r を伴わない`表現$の `Digest^h を交換することを両~端点【！主体】に許容するため、
`digest-algorithm$p には
2 つの値（ "`id-sha-256$c", "`id-sha-512$c" ）が追加された。
◎
Calculating the value of Digest using selected representation means it is tied to the Content-Encoding and Content-Type header fields. Therefore, a given resource may have multiple different digest values. To allow both parties to exchange a Digest of a representation with no content codings (see Section 8.4.1 of [SEMANTICS]) two more digest-algorithms are added ("id-sha-256" and "id-sha-512").
</p>

<p>
`Digest$h は、表現の完全性~用に利用される。
それは、［
`~message$【全体】／`~field$たち
］の完全性は供さない。
しかしながら，それは、~HTTP交換に欲される各部を［
一体として／各部ごとに
］保護するためとして，［
`表現~metadata$を保護する他の仕組み
］を成す各~相
— ~digital署名など —
と組合できる。
◎
Digest is used for representation integrity. It does not provide integrity for HTTP messages or fields. However, it can be combined with other mechanisms that protect representation metadata, such as digital signatures, in order to protect the phases of an HTTP exchange in whole or in part.
</p>

<p>
`Digest$h は［
認証／権限付与／~privacy
］用の手段は定義しない。
◎
Digest does not define means for authentication, authorization or privacy.
</p>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.3. 表記規約</h3>

<p>
~keyword "MUST" …
【以下、この段落の内容（ `RFC2119$r ）は<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`RFC5234$r に定義され，
`RFC7405$r にて更新された~ABNFを
— `SEMANTICS/~list~ABNF拡張$sec にて定義される，その拡張 “#規則” とともに —
利用する。
◎
This document uses the Augmented BNF defined in [RFC5234] and updated by [RFC7405] along with the "#rule" extension defined in Section 5.6.1 of [SEMANTICS].
</p>

<p>
この文書における次に挙げる用語は、
`SEMANTICS$r に述べられるとおりに解釈すること
⇒＃
`表現$,
`選定される表現$,
`表現~data$,
`表現~metadata$,
`内容$
◎
The definitions "representation", "selected representation", "representation data", "representation metadata", and "content" in this document are to be interpreted as described in [SEMANTICS].
</p>

<p>
~algo名は、それらを定義する文書に利用される文字大小-法を尊重する（例： `SHA-1$i, `CRC32c$i  ）。
一方で，
`digest-algorithm$p を成す~tokenは、引用符で括られる（例： "`sha$c", "`crc32c$c" ）。
◎
Algorithm names respect the casing used in their definition document (eg. SHA-1, CRC32c) whereas digest-algorithm tokens are quoted (eg. "sha", "crc32c").
</p>

		</section>
	</section>
	<section id="representation-digest">
<h2 title="Representation Digest">2. 表現~digest</h2>

<p>
表現~digestは、~HTTP`資源$用の，ある完全性の仕組みを成す
— それは、【~messageの】`内容$とは独立に計算される~checksumを利用する。
それは、`表現~data$を利用する
— `表現~data$は、`内容$内に［
全部的／部分的
］に包含されることも，まったく包含されないこともある。
◎
The representation digest is an integrity mechanism for HTTP resources which uses a checksum that is calculated independently of the content (see Section 6.4 of [SEMANTICS]). It uses the representation data (see Section 8.1 of [SEMANTICS]), that can be fully or partially contained in the content, or not contained at all.
</p>

<p>
これは、~messageが有する~HTTP意味論による効果を織り込む。
例えば、`内容$は［
`範囲~要請$や `HEAD$m などの~methodにより影響され得る
］ことに加え、
`内容$が “伝送路~上” に転送される仕方は，他の形式変換に依存する（例：
~HTTP11用の`転送~符号法$
— `HTTP11$r § `Transfer-Encoding$h を見よ）。
そのようなものが `Digest$h にどう影響するか~~説明するため、
`A$sec にて，いくつかの例が供される。
◎
This takes into account the effect of the HTTP semantics on the messages; for example, the content can be affected by Range Requests or methods such as HEAD, while the way the content is transferred "on the wire" is dependent on other transformations (e.g. transfer codings for HTTP/1.1 - see Section 6.1 of [HTTP11]). To help illustrate how such things affect Digest, several examples are provided in Appendix A.
</p>

<p>
表現~digest（ `representation-data-digest$p ）は、次の 2 つからなる：
◎
A representation digest consists of＼
</p>
<ul>
	<li>
次に対し算出された~checksumを成す値
⇒
`SEMANTICS/内容の識別-法$secに則って識別される`資源$に対し`選定された表現$の`表現~data$【！選定された表現~data】全体
◎
the value of a checksum computed on the entire selected representation data (see Section 8.1 of [SEMANTICS]) of a resource identified according to Section 6.4.2 of [SEMANTICS]＼
</li>
	<li>
前項の算出に利用された~algoを指示するもの
◎
together with an indication of the algorithm used:
</li>
</ul>

<pre class="bnf">
`representation-data-digest@p
	= `digest-algorithm$p "=" &lt;<span class="comment" title="encoded digest output">符号化された~digest出力</span>&gt;
</pre>

<p>
~messageに`表現~data$が無いときでも、次はアリである
⇒
空~文字列から表現~digestを算出して，送信された表現~dataは無いことを表明する
（ `10.3$sec を見よ）
◎
When a message has no representation data it is still possible to assert that no representation data was sent computing the representation digest on an empty string (see Section 10.3).
</p>

<p>
~checksumは、
`5$sec にて挙げる各 `digest-algorithm$p のうち 1 つを利用して算出され，それに結付けられる形式に符号化される。
◎
The checksum is computed using one of the digest-algorithms listed in Section 5 and then encoded in the associated format.
</p>

	</section>
	<section id="digest">
<h2 title="The Digest Field">3. `Digest^h ~field</h2>

<p>
`Digest$h ~fieldは、
`2$sec にて定義されるとおり，
~commaで分離された 1 個以上の表現~digest値からなる~listを包含する。
それは、要請, 応答どちらにも利用され得る。
◎
The Digest field contains a comma-separated list of one or more representation digest values as defined in Section 2. It can be used in both requests and responses.
</p>

<pre class="bnf">
`Digest@p = 1#`representation-data-digest$p
</pre>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm
                   AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew==
</pre>
</div>

<p>
`Content-Location$h と `Digest$h の関係性は、
`8.7$sec にてデモられる。
［
`表現~metadata$／`内容$の`形式変換$／~HTTP~method
］による `Digest^h への影響iを示す，包括的な一連の例は、
`8$sec, `9$sec
にて供される。
◎
The relationship between Content-Location (see Section 8.7 of [SEMANTICS]) and Digest is demonstrated in Section 8.7. A comprehensive set of examples showing the impacts of representation metadata, payload transformations and HTTP methods on Digest is provided in Section 8 and Section 9.
</p>

<p>
`Digest$h ~fieldは、複数個の `representation-data-digest$p 値を包含してもヨイ。
例えば`~server$は、能力の発展-度合いが様々な`~client$を~supportするために，複数の異なる~algoを利用して `representation-data-digest$p 値を供することもある。
これは特に、弱い~algoから移行する必要が発生した場合に備えるための~supportにおいて有用になる。
（ `10.6$sec を見よ）。
◎
A Digest field MAY contain multiple representation-data-digest values. For example, a server may provide representation-data-digest values using different algorithms, allowing it to support a population of clients with different evolving capabilities; this is particularly useful in support of transitioning away from weaker algorithms should the need arise (see Section 10.6).
</p>

<div class="example">

<pre class="lang-http">
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=,
        id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>
</div>

<p>
`受信者$は、
`Digest^h の`~field値$を成す各 `representation-data-digest$p に対し，どれを無視してもヨイ。
すなわち，`受信者$には、受信した `representation-data-digest$p すべてを検証yせずに，一部の `digest-algorithm$p に限って検証~用に利用することも許容される。
◎
A recipient MAY ignore any or all of the representation-data-digests in a Digest field. This allows the recipient to choose which digest-algorithm(s) to use for validation instead of verifying every received representation-data-digest.
</p>

<p>
`送信者$は、`受信者$が所与の `digest-algorithm$p を［
~supportする／無視することになる
］かどうか知ることなく，それを利用している `representation-data-digest$p を送信してもヨイ。
◎
A sender MAY send a representation-data-digest using a digest-algorithm without knowing whether the recipient supports the digest-algorithm, or even knowing that the recipient will ignore it.
</p>

<p>
`Digest$h は`~trailer節$にも送信できる。
この事例では、
`Digest$h は`~header節$に併合されてもヨイ
（ `SEMANTICS/~trailerの利用に対する制限$secを見よ）。
◎
Digest can be sent in a trailer section. In this case, Digest MAY be merged in to the header section (See Section 6.5.1 of [SEMANTICS]).
</p>

<p>
増分的な `digest-algorithm$p が利用されるときは，［
`送信者$／`受信者$【！receiver】
］は、`内容$が~streamされている間に~digest値を動的に算出できる。
◎
When an incremental digest-algorithm is used, the sender and the receiver can dynamically compute the digest value while streaming the content.
</p>

	</section>
	<section id="want-digest">
<h2 title="The Want-Digest Field">4. `Want-Digest^h ~field</h2>

<p>
`Want-Digest^h ~fieldは、要請, 応答どちらにも利用でき，次を指示する
⇒
`送信者$は、［
要請の`~target~URI$【！要請~URI】, `表現~metadata$
］に結付けられた~messageに対し，表現~digestを受信するよう欲する。
◎
The Want-Digest field indicates the sender's desire to receive a representation digest on messages associated with the request URI and representation metadata. It can be used in both requests and responses.
</p>

<pre class="bnf">
`Want-Digest@p = 1#`want-digest-value$p
`want-digest-value@p = `digest-algorithm$p [ ";" "q" "=" `qvalue$p]
`qvalue@p = ( "0" [ "." 0*1DIGIT ] ) /
        ( "1" [ "." 0*1( "0" ) ] )
</pre>

<p>
`digest-algorithm$p に `qvalue$p （`品質~値$）が付随していない場合、その値は 1.0 であったかのように扱われる。
◎
If a digest-algorithm is not accompanied by a "qvalue" (see Section 12.4.2 of[SEMANTICS]), it is treated as if its associated "qvalue" were 1.0.
</p>

<p>
`Want-Digest^h `~field値$は次を指示する
⇒
`送信者$は、［
~listされた `digest-algorithm$p のうち，
0 以外の `qvalue^p を伴うもの
］に限り，受容する用意がある。
該当するものが複数個ある場合、`送信者$は，
それらのうち最高な `qvalue^p を伴うもの（たち）を選好する。
◎
The sender is willing to accept a digest-algorithm if and only if it is listed in a Want-Digest field of a message, and its "qvalue" is non-zero.
◎
If multiple acceptable digest-algorithm values are given, the sender's preferred digest-algorithm is the one (or ones) with the highest "qvalue".
</p>

<div class="example">
<p>
その利用を成す 2 つの例：
◎
Two examples of its use are:
</p>

<pre class="lang-http">
Want-Digest: sha-256
</pre>

<pre class="lang-http">
Want-Digest: sha-512;q=0.3, sha-256;q=1, unixsum;q=0
</pre>
</div>

	</section>
	<section id="algorithms">
<h2 title="Digest Algorithm Values">5. 各種~digest~algo値</h2>

<p>
`digest-algorithm$p 値は、特定の~digest算出法を指示するために利用される。
◎
Digest-algorithm values are used to indicate a specific digest computation.
</p>

<pre class="bnf">
`digest-algorithm@p = `token$p
</pre>

<p>
`digest-algorithm$p を成す~tokenは、どれも文字大小無視で比較されなければナラナイが，小文字が選好される。
◎
All digest-algorithm token values are case-insensitive but lower case is preferred; digest-algorithm token values MUST be compared in a case-insensitive fashion.
</p>

<p>
~IANA（ `Internet Assigned Numbers Authority^en ）は、
`digest-algorithm$p 値~用の~registryを保守する。
この~registryは、以下に挙げる~tokenで初期化される。
◎
The Internet Assigned Numbers Authority (IANA) maintains a registry for digest-algorithm values. The registry is initialized with the tokens listed below.
</p>

<p>
非推奨にされた `digest-algorithm$p は、利用してはナラナイ。
更なる情報は、次を参照されたし
⇒＃
"`md5$c" に対しては `CMU-836068$r, `NO-MD5$r ／
"`sha$c" に対しては `IACR-2020-014$r, `NO-SHA1$r
◎
Deprecated digest algorithms MUST NOT be used:
• "md5", see [CMU-836068] and [NO-MD5];
• "sha", see [IACR-2020-014] and [NO-SHA1].
◎
See the references above for further information.
</p>

<dl>
	<dt>`sha-256@c</dt>
	<dd>
記述：
`SHA-256^i ~algo `RFC6234$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
◎
Description: The SHA-256 algorithm [RFC6234]. The output of this algorithm is encoded using the base64 encoding [RFC4648].
</dd>
	<dd>
参照：
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>

	<dt>`sha-512@c</dt>
	<dd>
記述：
`SHA-512^i ~algo `RFC6234$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
◎
Description: The SHA-512 algorithm [RFC6234]. The output of this algorithm is encoded using the base64 encoding [RFC4648].
</dd>
	<dd>
参照：
`RFC6234$r,
`RFC4648$r,
この文書。
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>

	<dt>`md5@c</dt>
	<dd>
記述：
`RFC1321$r にて指定される `MD5^i ~algo。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
この `digest-algorithm$p は、今や，衝突~攻撃に脆弱である
— `NO-MD5$r, `CMU-836068$r を見よ。
◎
Description: The MD5 algorithm, as specified in [RFC1321]. The output of this algorithm is encoded using the base64 encoding [RFC4648]. This digest-algorithm is now vulnerable to collision attacks. See [NO-MD5] and [CMU-836068].
</dd>
	<dd>
参照：
`RFC1321$r,
`RFC4648$r,
この文書
◎
Reference: [RFC1321], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`非推奨d^i
◎
Status: deprecated
</dd>

	<dt>`sha@c</dt>
	<dd>
記述：
`SHA-1^i ~algo `RFC3174$r 。
この~algoの出力は、
~base64符号化法 `RFC4648$r
を利用して符号化される。
この `digest-algorithm$p は、今や，衝突~攻撃に脆弱である
— `NO-SHA1$r, `IACR-2020-014$r を見よ。
◎
Description: The SHA-1 algorithm [RFC3174]. The output of this algorithm is encoded using the base64 encoding [RFC4648]. This digest-algorithm is now vulnerable to collision attacks. See [NO-SHA1] and [IACR-2020-014].
</dd>
	<dd>
参照：
`RFC3174$r,
`RFC6234$r,
`RFC4648$r,
この文書。
◎
Reference: [RFC3174], [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`非推奨d^i
◎
Status: deprecated
</dd>

	<dt>`unixsum@c</dt>
	<dd>
記述：
この~algoは、
`UNIX$r により定義される~UNIX "sum" ~commandにより算出される。
この~algoの出力は、
16 ~bit~checksumを表現している~ASCII数字~列であり，
~UNIX "sum" ~commandの出力を成す最初の単語である。
◎
Description: The algorithm computed by the UNIX "sum" command, as defined by the Single UNIX Specification, Version 2 [UNIX]. The output of this algorithm is an ASCII decimal-digit string representing the 16-bit checksum, which is the first word of the output of the UNIX "sum" command.
</dd>
	<dd>
参照：
`UNIX$r,
この文書。
◎
Reference: [UNIX], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>

	<dt>`unixcksum@c</dt>
	<dd>
記述：
この~algoは、
`UNIX$r により定義される~UNIX "cksum" ~commandにより算出される。
この~algoの出力は、
32 ~bit ~CRCを表現している~ASCII数字~列であり，
~UNIX "cksum" ~commandの出力を成す最初の単語である。
◎
Description: The algorithm computed by the UNIX "cksum" command, as defined by the Single UNIX Specification, Version 2 [UNIX]. The output of this algorithm is an ASCII digit string representing the 32-bit CRC, which is the first word of the output of the UNIX "cksum" command.
</dd>
	<dd>
参照：
`UNIX$r,
この文書
◎
Reference: [UNIX], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>
</dl>

<p>
`Content-Encoding$h とは独立に~checksumを供することを［
`送信者$／`受信者$
］に許容するため、
次に挙げる追加的な `digest-algorithm$p が定義される：
◎
To allow sender and recipient to provide a checksum which is independent from Content-Encoding, the following additional digest-algorithms are defined:
</p>

<dl>
	<dt>`id-sha-512@c</dt>
	<dd>
記述：
`内容~符号法$が適用されない【または復号された】ときの，
`資源$の`表現~data$の `sha-512$c ~digest。
◎
Description: The sha-512 digest of the representation-data of the resource when no content coding is applied
</dd>
	<dd>
参照：
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>

	<dt>`id-sha-256@c</dt>
	<dd>
記述：
`内容~符号法$が適用されない【または復号された】ときの，
`資源$の`表現~data$の `sha-256$c ~digest。
◎
Description: The sha-256 digest of the representation-data of the resource when no content coding is applied
</dd>
	<dd>
参照：
`RFC6234$r,
`RFC4648$r,
この文書
◎
Reference: [RFC6234], [RFC4648], this document.
</dd>
	<dd>
位置付け：
`標準^i
◎
Status: standard
</dd>
</dl>

<p>
他の `digest-algorithm$p 値が定義される場合、それに結付けられる符号化法が［
符号化するときに利用する文字~集合
］が［
"`;^c" ／ "`,^c"
］を含む場合には，
【符号化した結果を】
`quoted-string$p として表現しなければナラナイ。
◎
If other digest-algorithm values are defined, the associated encoding MUST either be represented as a quoted string or MUST NOT include ";" or "," in the character sets used for the encoding.
</p>

	</section>
	<section id="acting-on-resources">
<h2 title="Use of Digest when acting on resources">6. 資源に動作するときの `Digest^h の利用</h2>

<p>
［
`POST$m ／ `PATCH$m
］要請は、［
部分的な`表現$を伝達しつつ，意味論的には`資源$に対し動作している
］ように出現し得る。
要請に同封された`表現$（その`表現~metadata$も含む）は、その動作を指す。
◎
POST and PATCH requests can appear to convey partial representations but are semantically acting on resources. The enclosed representation, including its metadata, refers to that action.
</p>

<p>
これらの要請においては、表現~digestは，その動作の`表現~data$から算出されなければナラナイ。
これは、唯一アリな選択になる
— 表現~digestは、完全な`表現~metadata$を要求するので（ `2$sec を見よ）。
◎
In these requests the representation digest MUST be computed on the representation-data of that action. This is the only possible choice because representation digest requires complete representation metadata (see Section 2).
</p>

<p>
応答においては：
◎
In responses,
</p>
<ul>
	<li>
当の`表現$が要請の状態sを述べる場合、
`Digest$h は，同封された`表現$から算出されなければナラナイ
（ `8.8$sec を見よ）
◎
if the representation describes the status of the request, Digest MUST be computed on the enclosed representation (see Section 8.8 );
</li>
	<li>
参照-先の`資源$が在る場合、
`Digest$h は，その資源に`選定される表現$から算出されなければナラナイ
— それが当の`~target資源$と異なっていようが。
`Digest$h は、同封された`表現$から算出された結果であることも，そうでないこともある。
◎
if there is a referenced resource Digest MUST be computed on the selected representation of the referenced resource even if that is different from the target resource. That might or might not result in computing Digest on the enclosed representation.
</li>
</ul>

<p>
後者の事例は、所与の`~method$の意味論に則って行われるかもしれない
— 例えば， `Content-Location$h ~headerを利用して。
対照的に，
`Location$h ~headerは、`表現~metadata$ではないので，
`Digest$h には影響しない。
◎
The latter case might be done according to the HTTP semantics of the given method, for example using the Content-Location header field. In contrast, the Location header field does not affect Digest because it is not representation metadata.
</p>

		<section id="digest-and-patch">
<h3 title="Digest and PATCH">6.1. `Digest^h と `PATCH^m</h3>

<p>
`PATCH$m 要請においては、表現~digestは，~patch文書から算出されなければナラナイ
— `表現~metadata$は、`~target資源$ではなく，~patch文書を指すので（
`PATCH$r § `PATCH$m
を見よ）。
◎
In PATCH requests, the representation digest MUST be computed on the patch document because the representation metadata refers to the patch document and not to the target resource (see Section 2 of [PATCH]).
</p>

<p>
`PATCH$m 要請に対する応答においては、表現~digestは，~patchされた資源の`選定された表現$から算出されなければナラナイ。
◎
In PATCH responses, the representation digest MUST be computed on the selected representation of the patched resource.
</p>

<p>
したがって，
`PATCH$m における `Digest$h の用法は、
`資源$の自前の意味論【！semantic】の一部が［
~method／~patch文書
］により含意されることを除けば，
`POST$m に とても類似する。
◎
Digest usage with PATCH is thus very similar to POST, but with the resource's own semantic partly implied by the method and by the patch document.
</p>

		</section>
		<section id="digest-and-content-location">
<h3 title="Digest and Content-Location in Responses">6.2. 応答~内の `Digest^h と `Content-Location^h</h3>

<p>
ある状態変更~methodに対する応答が `Content-Location$h ~headerを返すとき、応答に同封された表現は，その`~field値$により識別される`資源$を指す
— `Digest$h はそれに則って算出される。
◎
When a state-changing method returns the Content-Location header field, the enclosed representation refers to the resource identified by its value and Digest is computed accordingly.
</p>

		</section>
	</section>
	<section id="sri">
<h2 title="Relationship to Subresource Integrity (SRI)">7. `下位資源の完全性^cite（~SRI）との関係性</h2>

<p>
`下位資源の完全性^cite（ `Subresource Integrity^en, 略称~SRI ） `SRI$r
による完全性の仕組みは、この文書によるそれと類似性がある。
しかしながら，［
その動機を成す要因／
脅威~modelと完全性~digest生成の仕様／
通達-法と検証
］において相違点がある。
◎
Subresource Integrity [SRI] is an integrity mechanism that shares some similarities to the present document's mechanism. However, there are differences in motivating factors, threat model and specification of integrity digest generation, signalling and validation.
</p>

<p>
~SRIは、［［
当事者主体／第三者主体
］の権限により~serveされる`資源$に対し，完全性の表明を宣言すること
］を当事者主体の権限に許容する。
これは、~HTMLの［
`script$e ／ `link$e
］要素に追加できる `integrity$a 属性を介して行われる。
したがって，完全性の表明は、常に，当の資源の~fetchに対する帯域~外で為される。
対照的に， `Digest$h ~fieldは、`選定された表現$に~~並行して帯域~内に給される
— すなわち、権限が完全性の表明を宣言できるのは，自身のために限られる。
表現~digestの~security特質を改善するための手法は、
`10$sec にて呈示される。
この対照は、次のことから関心事になる
⇒
自己-表明は、一方では［
協調~問題
— 第三者主体についての非新鮮な情報を保持している当事者主体など —
により影響されないと見込まれる
］が，他方では［
それが信用に価するのは、それを供した権限までに限られる
］。
◎
SRI allows a first-party authority to declare an integrity assertion on a resource served by a first or third party authority. This is done via the integrity attribute that can be added to script or link HTML elements. Therefore, the integrity assertion is always made out-of-band to the resource fetch. In contrast, the Digest field is supplied in-band alongside the selected representation, meaning that an authority can only declare an integrity assertion for itself. Methods to improve the security properties of representation digests are presented in Section 10. This contrast is interesting because on one hand self-assertion is less likely to be affected by coordination problems such as the first-party holding stale information about the third party, but on the other hand the self-assertion is only as trustworthy as the authority that provided it.
</p>

<p>
~SRIの `integrity$a 属性は、
`representation-data-digest$p に類似な［
暗号用~hash~algo, ~digest値
］を包含する【！ see `2$sec 】。
主要な相違点は、直列化~形式にある。
◎
The SRI integrity attribute contains a cryptographic hash algorithm and digest value which is similar to representation-data-digest (see Section 2). The major differences are in serialization format.
</p>

<p>
~SRIは、部分的な`表現~data$（例：`範囲~要請$）の取扱いは指定しない。
対照的に，この文書は、中核~HTTP概念に全部的に互換な用語で取扱いを指定する（その例は `8.3$sec に供される）。
◎
SRI does not specify handling of partial representation data (e.g. Range requests). In contrast, this document specifies handling in terms that are fully compatible with core HTTP concepts (an example is provided in Section 8.3).
</p>

<p>
~SRIは、~digestの［
生成／検証
］用の~algoの選定に対し，強い要件を指定する。
対照的に，この文書における要件は、もっと弱い。
◎
SRI specifies strong requirements on the selection of algorithm for generation and validation of digests. In contrast, the requirements in this document are weaker.
</p>

<p>
~SRIは、`~client$用に［
`~server$へ転送する`資源$に対し，完全性の表明を宣言する
］ための手法は，定義しない。
対照的に，
`Digest$h ~fieldは、要請にも出現し得る。
◎
SRI defines no method for a client to declare an integrity assertion on resources it transfers to a server. In contrast, the Digest field can appear on requests.
</p>

		<section id="supporting-both-sri-and-representation-digest">
<h3 title="Supporting Both SRI and Representation Digest">7.1. ~SRI, 表現~digestの両者の~support法</h3>

<p>
~SRIと表現~digestは、互いに異なる相補的な仕組みであるが、一方が他方を置換する能力はない
— それらの［
脅威／~security／実装
］の特質は異なるので。
◎
The SRI and Representation Digest mechanisms are different and complementary but one is not capable of replacing the other because they have different threat, security and implementation properties.
</p>

<p>
どちらの仕組みも~supportする~UAには，それぞれに指定された規則を適用するものと期待されるが、
この 2 つの仕組みは独立なので，その順序付けは重要でない。
しかしながら，どちらも~supportしている~UAは、最初に表現~digest検証を遂行することから
便益を得ることもできる
— それは、
`identity^i 符号化法への変換
【`内容~符号法$を復号すること】
が常に要求されることはないので。
◎
A user agent that supports both mechanisms is expected to apply the rules specified for each but since the two mechanisms are independent, the ordering is not important. However, a user agent supporting both could benefit from performing representation digest validation first because it does not always require a conversion into identity encoding.
</p>

<p>
~SRIを利用しているときは `Digest$h を合法的に無視できる
— `3$sec は、
<q>
`Digest^h の`~field値$を成す各 `representation-data-digest$p に対し，どれを無視してもヨイ
</q>
ものと指定するので。
どちらの仕組みも~supportする~UAは、
`Digest$h, ~SRIどちらも施行する事例では、［
`Digest$h ／ ~SRI
］~levelで不合致が起きたかどうか識別するに十分な情報を供すると有用になり得る。
◎
A user agent supporting both mechanisms: - can legitimately ignore Digest when using SRI, because Section 3 specifies that "a recipient MAY ignore any or all of the representation-data-digests"; - enforce both Digest and SRI: in this case it can be useful to provide enough information to identify whether the mismatch happened at the Digest or the SRI level.
</p>

		</section>
	</section>
	<section id="examples-unsolicited">
<h2 title="Examples of Unsolicited Digest">8. 請求されない `Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が `Want-Digest$h を利用するよう請求しなかったときでも，
`~server$が `Digest$h ~fieldで応答するときのヤリトリをデモる。
◎
The following examples demonstrate interactions where a server responds with a Digest field even though the client did not solicit one using Want-Digest.
</p>

<p>
例のうちいくつかは、`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
`Digest$h は、`~MIME型$を問わないことに加え、特定の形式~用の正準-化~algoは供さない。
`Digest$h の例は、~spaceを含めて計算される。
◎
Digest is media-type agnostic and does not provide canonicalization algorithms for specific formats. Examples of Digest are calculated inclusive of any space.
</p>

		<section id="example-full-representation">
<h3 title="Server Returns Full Representation Data">8.1. ~serverは全部的な表現~dataを返す例</h3>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
</div>

		</section>
		<section id="server-returns-no-representation-data">
<h3 title="Server Returns No Representation Data">8.2. ~serverは表現~dataを返さない例</h3>

<p>
この例では、
`HEAD$m 要請を利用して`資源$の~checksumを検索取得する。
◎
In this example, a HEAD request is used to retrieve the checksum of a resource.
</p>

<p>
対する応答の `Digest$h `~field値$は，~JSON~obj
`{"hello": "world"}^c
から計算されるが、応答の`内容$は無いので，当の~JSONは そこには示されない。
◎
The response Digest field-value is calculated over the JSON object {"hello": "world"}, which is not shown because there is no payload data.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
HEAD /items/123 HTTP/1.1
Host: foo.example
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>
</div>

		</section>
		<section id="server-returns-partial-representation-data">
<h3 title="Server Returns Partial Representation Data">8.3. ~serverは部分的な表現~dataを返す例</h3>

<p>
この例では、`~client$は、`範囲~要請$を為す
— 対して`~server$は、部分的な内容で応答する。
応答の `Digest$h `~field値$は、~JSON~obj全体
`{"hello": "world"}^c
を表現する。
◎
In this example, the client makes a range request and the server responds with partial content. The Digest field-value represents the entire JSON object {"hello": "world"}.
</p>

<div class="example">
<p>
要請：
◎
Request:

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Range: bytes=1-7
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Type: application/json
Content-Range: bytes 1-7/18
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

"hello"
</pre>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data">
<h3 title="Client and Server Provide Full Representation Data">8.4. ~client, ~serverどちらも全部的な表現~dataを供する例</h3>

<p>
要請は、同封された表現から計算された `Digest$h `~field値$を包含する。
また，`~client$は、当の要請に
値 `br^c を伴う `Accept-Encoding$h ~headerを内包して，
`brotli^i 符号化法を~supportすることを広告する。
◎
The request contains a Digest field-value calculated on the enclosed representation. It also includes an Accept-Encoding: br header field that advertises the client supports brotli encoding.
</p>

<p>
対する応答は、値 `br^c を伴う `Content-Encoding$h ~headerを内包する
— それは、`選定された表現$は `brotli^i に符号化されたことを指示する。
したがって `Digest$h `~field値$は，要請のそれとは異なる。
◎
The response includes a Content-Encoding: br that indicates the selected representation is brotli encoded. The Digest field-value is therefore different compared to the request.
</p>

<p>
応答の`内容$は、印字不能な文字を包含するので，呈示~目的においては~base64に符号化された文字列として表示される。
◎
For presentation purposes, the response body is displayed as a base64-encoded string because it contains non-printable characters.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 Ok
Content-Type: application/json
Content-Location: /items/123
Content-Encoding: br
Content-Length: 22
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
</div>

		</section>
		<section id="client-provides-full-representation-data-server-provides-no-representation-data">
<h3 title="Client Provides Full Representation Data, Server Provides No Representation Data">8.5. ~clientは全部的な表現~dataを供する, ~serverは表現~dataを供さない例</h3>

<p>
要請の `Digest$h `~field値$は、同封された`内容$から計算される。
◎
The request Digest field-value is calculated on the enclosed payload.
</p>

<p>
対する応答の `Digest$h `~field値$は、
応答が`内容$を包含しないときでも，`表現~header$【！表現~metadata~header】に依存する
— この例では、［
値 `br^c を伴う `Content-Encoding$h ~header
］もそれに含まれる。
◎
The response Digest field-value depends on the representation metadata header fields, including Content-Encoding: br even when the response does not contain content.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Length: 18
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 204 No Content
Content-Type: application/json
Content-Encoding: br
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=
</pre>
</div>

		</section>
		<section id="client-and-server-provide-full-representation-data-client-uses-id-sha-256">
<h3 title="Client and Server Provide Full Representation Data, Client Uses id-sha-256.">8.6. ~client, ~serverどちらも全部的な表現~dataを供する，~clientは `id-sha-256^c を利用する例</h3>

<p>
応答は、 2 個の~digest値
— 適用された`内容~符号法$が［
無いときのもの, あるときのもの
］ —
を包含する：
◎
The response contains two digest values:
</p>
<ul>
	<li>
前者の~digest値（ `id-sha-256=...^c ）は、要請~内に送信された符号化されていない【符号化される前の`表現~data$から算出された】~digest値に
— この事例では【！accidentally】 —
合致する。
◎
one with no content coding applied, which in this case accidentally matches the unencoded digest-value sent in the request;
</li>
	<li>
後者の~digest値には、
`Content-Encoding$h に指示される`内容~符号法$が織り込まれる。
◎
one taking into account the Content-Encoding.
</li>
</ul>

<p>
応答の`内容$は、印字不能な文字を包含するので，ここでは~base64に符号化された文字列として表示されている。
◎
As the response body contains non-printable characters, it is displayed as a base64-encoded string.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /items/123 HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept-Encoding: br
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: br
Content-Location: /items/123
Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=,
        id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==
</pre>
</div>

		</section>
		<section id="post-not-request-uri">
<h3 title="POST Response does not Reference the Request URI">8.7. `POST^m に対する応答は要請~URIを参照しない例</h3>

<p>
要請 `Digest$h `~field値$は、同封された表現から算出される（ `6$sec を見よ）。
◎
The request Digest field-value is computed on the enclosed representation (see Section 6).
</p>

<p>
応答~内に同封された表現は
`Content-Location$h により識別される`資源$を指す（
`SEMANTICS/内容の識別-法$secを見よ）。
したがって， `Digest$h は、同封された表現から算出される。
◎
The representation enclosed in the response refers to the resource identified by Content-Location (see [SEMANTICS], Section 6.4.2). Digest is thus computed on the enclosed representation.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /books/123
Location: /books/123
Digest: id-sha-256=yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=

{
  "id": "123",
  "title": "New Title"
}
</pre>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、同じ `Digest$h `~field値$を伴うなら合法的になることに注意。
◎
Note that a 204 No Content response without content but with the same Digest field-value would have been legitimate too.
</p>

		</section>
		<section id="post-referencing-action">
<h3 title="POST Response Describes the Request Status">8.8. `POST^m に対する応答は要請の状態sを述べる例</h3>

<p>
要請の `Digest$h `~field値$は、同封された`表現$から算出される（ `6$sec を見よ）。
◎
The request Digest field-value is computed on the enclosed representation (see Section 6).
</p>

<p>
対する応答~内に同封された`表現$は、要請の状態sを述べるので、
`Digest$h は，その同封された表現から算出される。
◎
The representation enclosed in the response describes the status of the request, so Digest is computed on that enclosed representation.
</p>

<p>
応答の `Digest$h には `Location$h により参照された`資源$との明示的な関係は無い。
◎
Response Digest has no explicit relation with the resource referenced by Location.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
POST /books HTTP/1.1
Host: foo.example
Content-Type: application/json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=
Location: /books/123

{"title": "New Title"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Digest: id-sha-256=2LBp5RKZGpsSNf8BPXlXrX4Td4Tf5R5bZ9z7kdi5VvY=
Location: /books/123

{
  "status": "created",
  "id": "123",
  "ts": 1569327729,
  "instance": "/books/123"
}
</pre>
</div>

		</section>
		<section id="digest-with-patch">
<h3 title="Digest with PATCH">8.9. `PATCH^m を伴う~digest</h3>

<p>
この事例は、
`~target資源$が`~target~URI$を反映する所では，
`POST$m 要請に相似的である。
◎
This case is analogous to a POST request where the target resource reflects the effective request URI.
</p>

<p>
`PATCH$m 要請は、
`RFC7396$r にて定義される`~MIME型$
`application/merge-patch+json^c
を利用する。
◎
The PATCH request uses the application/merge-patch+json media type defined in [RFC7396].
</p>

<p>
`Digest$h は、要請に同封された`内容$から計算される
— それは、~patch文書に対応する。
◎
Digest is calculated on the enclosed payload, which corresponds to the patch document.
</p>

<p>
対する応答の `Digest$h `~field値$は、
~patchされた`資源$の完全な表現から算出される。
◎
The response Digest field-value is computed on the complete representation of the patched resource.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PATCH /books/123 HTTP/1.1
Host: foo.example
Content-Type: application/merge-patch+json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: id-sha-256=yxOAqEeoj+reqygSIsLpT0LhumrNkIds5uLKtmdLyYE=

{
  "id": "123",
  "title": "New Title"
}
</pre>
</div>

<p>
`内容$を伴わない `204$st 応答であったとしても、同じ `Digest$h `~field値$を伴うなら合法的になることに注意。
◎
Note that a 204 No Content response without content but with the same Digest field-value would have been legitimate too.
</p>

		</section>
		<section id="error-responses">
<h3 title="Error responses">8.10. ~error応答</h3>

<p>
~error応答†においては、
`表現~data$は`~target資源$を指すとは限らない。
代わりに，~errorの表現を指す。
【†この例では `4xx$st だが、 `5xx$st も含まれるかもしれない。】
◎
In error responses, the representation-data does not necessarily refer to the target resource. Instead, it refers to the representation of the error.
</p>

<p>
以下の例では、`~client$は
`/books/123^c
に所在する資源に~patchしようと試みる。
しかしながら，そこには資源は存在しなかったので、`~server$は
`RFC7807$r に則って，~errorを述べる`内容$を伴う `404$st0 応答を生成する。
◎
In the following example a client attempts to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with [RFC7807].
</p>

<p>
応答の `Digest$h `~field値$は、この同封された表現から算出される。
◎
The response Digest field-value is computed on this enclosed representation.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PATCH /books/123 HTTP/1.1
Host: foo.example
Content-Type: application/merge-patch+json
Accept: application/json
Accept-Encoding: identity
Digest: sha-256=bWopGGNiZtbVgHsG+I4knzfEJpmmmQHf7RHDXA3o1hQ=

{"title": "New Title"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 404 Not Found
Content-Type: application/problem+json
Digest: sha-256=KPqhVXAT25LLitV1w0O167unHmVQusu+fpxm65zAsvk=

{
  "title": "Not Found",
  "detail": "Cannot PATCH a non-existent resource",
  "status": 404
}
</pre>
</div>

		</section>
		<section id="use-with-trailer-fields-and-transfer-coding">
<h3 title="Use with Trailer Fields and Transfer Coding">8.11. ~trailerと転送~符号法との利用</h3>

<p>
ここでは，`生成元~server$は `Digest$h を`~trailer$として送信するので、内容を~streamしている間に~digest値を計算でき，したがって資源の消費を軽減する。
`Digest$h `~field値$は、
`8.1$sec と同じになる
— `Digest$h は、`転送~符号法$の利用とは独立に設計されるので（ `2$sec を見よ）。
◎
An origin server sends Digest as trailer field, so it can calculate digest-value while streaming content and thus mitigate resource consumption. The Digest field-value is the same as in Section 8.1 because Digest is designed to be independent from the use of one or more transfer codings (see Section 2).
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Trailer: Digest

8\r\n
{"hello"\r\n
8
: "world\r\n
2\r\n
"}\r\n
0\r\n
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
</pre>

<p class="trans-note">【
`\r\n^c は改行, 数字は~spaceの個数を表すように思われる（実際の`内容$を成す文字ではなく）。
】</p>

</div>

		</section>
	</section>
	<section id="examples-solicited">
<h2 title="Examples of Want-Digest Solicited Digest">9. `Want-Digest^h により請求される `Digest^h の例</h2>

<p>
以下に挙げる例は、
`~client$が `Want-Digest$h を利用して `Digest$h を請求するときのヤリトリをデモる。
◎
The following examples demonstrate interactions where a client solicits a Digest using Want-Digest.
</p>

<p>
例のうちいくつかは、`内容$に~JSON~objを内包する。
それらは、行l長さの~~都合により
— 改行と字下げを伴って —
複数~行lで呈示される場合もある。
【一方で，~digest自体は、そのように整形されていない~dataから算出される。】
◎
Some examples include JSON objects in the content. For presentation purposes, objects that fit completely within the line-length limits are presented on a single line using compact notation with no leading space. Objects that would exceed line-length limits are presented across multiple lines (one line per key-value pair) with 2 spaced of leading indentation.
</p>

<p>
`Digest$h は、`~MIME型$を問わないことに加え、特定の形式~用の正準-化~algoは供さない。
`Digest$h の例は、~spaceを含めて計算される。
◎
Digest is media-type agnostic and does not provide canonicalization algorithms for specific formats. Examples of Digest are calculated inclusive of any space.
</p>

		</section>
		<section id="server-selects-clients-least-preferred-algorithm">
<h3 title="Server Selects Client's Least Preferred Algorithm">9.1. ~serverは~clientが最も選好しない~algoを選定する例</h3>

<p>
`~client$は、
"`sha$c" を選好している~digestを要請する。
いずれにせよ、
`~server$は "`sha-256$c" で返信してもかまわない。
◎
The client requests a digest, preferring "sha". The server is free to reply with "sha-256" anyway.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha-256;q=0.3, sha;q=1
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

{"hello": "world"}
</pre>
</div>

		</section>
		<section id="server-selects-algorithm-unsupported-by-client">
<h3 title="Server Selects Algorithm Unsupported by Client">9.2. ~serverは~clientが~supportされない~algoを選定する例</h3>

<p>
`~client$は "`sha$c" ~digestのみを要請する。
`~server$は、現在~supportされない~algoを包含している `Digest^h で返信してもかまわない。
◎
The client requests a "sha" digest only. The server is currently free to reply with a Digest containing an unsupported algorithm.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha;q=1
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm
                   +AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew==

{"hello": "world"}
</pre>
</div>

		</section>
		<section id="server-does-not-support-client-algorithm-and-returns-an-error">
<h3 title="Server Does Not Support Client Algorithm and Returns an Error">9.3. ~serverは~client~algoを~supportしないので~errorを返す例</h3>

<p>
`~client$は、
"`sha$c" `Digest^h を要請する。
`~server$は、
"`sha-256$c", "`sha-512$c" を勧める
。
◎
The client requests a "sha" Digest, the server advises "sha-256" and "sha-512".
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /items/123 HTTP/1.1
Host: foo.example
Want-Digest: sha;q=1
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 400 Bad Request
Want-Digest: sha-256, sha-512
</pre>
</div>

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">10. ~securityの考慮点</h2>

		<section id="digest-does-not-protect-the-full-http-message">
<h3 title="Digest Does Not Protect the Full HTTP Message">10.1. `Digest^h は全部的な~HTTP~messageを保護するものではない</h3>

<p>
この文書は、ある ~data完全性の仕組みを指定する。
それは、~HTTP`表現~data$を保護するが、~HTTP［
~header／~trailer
］を ある種の偶発的な破損から保護するものではない。
◎
This document specifies a data integrity mechanism that protects HTTP representation data, but not HTTP header and trailer fields, from certain kinds of accidental corruption.
</p>

<p>
`Digest$h は、~HTTP~messageに対する悪意的な改ざんに抗する一般的な保護は意図されない。
これは、~transport層の~securityや~digital署名などの他の~approachと組合せることで達成できる。
◎
Digest is not intended to be a general protection against malicious tampering with HTTP messages. This can be achieved by combining it with other approaches such as transport-layer security or digital signatures.
</p>

		</section>
		<section id="digest-for-end-to-end-integrity">
<h3 title="Digest for End-to-End Integrity">10.2. 端点間の完全性~用の `Digest^h</h3>

<p>
`Digest$h は［
実装~error／
欲されない “`形式変換ng~proxy$” `SEMANTICS$r ／
~dataが いくつかの［
中継点／~system境界
］を通過するときに伴われる他の動作
］に因る`表現~metadata$の改変を検出する助けになり得る。
［
端点間における`表現~data$の完全性
］用の単純な仕組みであっても，価値はある
— ~UAは、［
~HTML構文解析器や動画~再生器, 等々
］に構文解析~用に手渡す前に，資源の検索取得に成功したことを検証できるので。
◎
Digest can help detect representation data modification due to implementation errors, undesired "transforming proxies" (see Section 7.7 of [SEMANTICS]) or other actions as the data passes across multiple hops or system boundaries. Even a simple mechanism for end-to-end representation data integrity is valuable because user-agent can validate that resource retrieval succeeded before handing off to a HTML parser, video player etc. for parsing.
</p>

<p>
特に，`identity^i 【`内容~符号法$を伴わない】 `digest-algorithm$p
（例： "`id-sha-256$c", "`id-sha-512$c" ）は、端点間の完全性~用に有用になる。
それらは、~HTTP~message法の特徴が異なる各~source
— 例えば，適用する`内容~符号法$が異なる各`~server$ —
からの資源を，一緒に継ぎ合わせることを許容するので。
◎
Identity digest-algorithms (e.g. "id-sha-256" and "id-sha-512") are particularly useful for end-to-end integrity because they allow piecing together a resource from different sources with different HTTP messaging characteristics. For example, different servers that apply different content codings.
</p>

<p>
`Digest$h だけを利用しても，端点間における~HTTP~message【全体】の完全性は
— 中継点を経ている場合には —
供さないことに注意
— その~metadataは、どの段階でも操作され得るので。
~metadataを保護する手法は、 `10.3$sec にて論じられる。
◎
Note that using Digest alone does not provide end-to-end integrity of HTTP messages over multiple hops, since metadata could be manipulated at any stage. Methods to protect metadata are discussed in Section 10.3.
</p>

		</section>
		<section id="usage-in-signatures">
<h3 title="Usage in Signatures">10.3. 署名における用法</h3>

<p>
~digital署名は、ある種の~messageの生成元を識別するものを供するためとして，~checksumと一緒に広範に利用される
`NIST800-32$r
。
そのような署名は、
1 個以上の~HTTP~fieldを保護し得る
— それらに `Digest$h も含まれるときには、追加的な考慮点がある。
◎
Digital signatures are widely used together with checksums to provide the certain identification of the origin of a message [NIST800-32]. Such signatures can protect one or more HTTP fields and there are additional considerations when Digest is included in this set.
</p>

<p>
`Digest$h ~fieldは、資源~表現の~hashを成すので，`表現~metadata$（例：`Content-Type$h, `Content-Encoding$h, 等々の値）に明示的に依存する。
`Digest$h は保護しつつ他の`表現~metadata$は保護しない署名は、当の通信を改ざんに晒し得る。
例えば，ある動作者は、
`Content-Type$h `~field値$を操作して，`受信者$における~digest検証を失敗に至らすこともでき、当の応用が`表現$へ~accessできなくする。
そのような攻撃は、両~端点の資源を消費する。
`6.2$sec も見よ。
◎
Since the Digest field is a hash of a resource representation, it explicitly depends on the representation metadata (eg. the values of Content-Type, Content-Encoding etc). A signature that protects Digest but not other representation metadata can expose the communication to tampering. For example, an actor could manipulate the Content-Type field-value and cause a digest validation failure at the recipient, preventing the application from accessing the representation. Such an attack consumes the resources of both endpoints. See also Section 6.2.
</p>

<p>
`Digest$h は、常に，［
~transport層において，~HTTP~fieldを保護する完全性
］を供する接続~越しに利用されるベキである。
◎
Digest SHOULD always be used over a connection that provides integrity at the transport layer that protects HTTP fields.
</p>

<p>
`Digest$h ~fieldに `推奨されない^2119 `digest-algorithm$p を利用しているものは、署名には利用するベキでない。
◎
A Digest field using NOT RECOMMENDED digest-algorithms SHOULD NOT be used in signatures.
</p>

<p>
署名を利用して，空な表現の `Digest$h を保護することは、最終的な`内容$において何かが剥がされたり追加されたかどうか検出することを，受信している端点に許容する。
◎
Using signatures to protect the Digest of an empty representation allows receiving endpoints to detect if an eventual payload has been stripped or added.
</p>

<p>
`Digest$h を弄ることは、署名の検証に影響するかもしれない
— 例：
`representation-data-digest$p 値から重複な~tokenを除去する ／
複数の`~field行l値$を`結合-$するなど（
`SEMANTICS/~field行と結合-済みな~field値$sec
を見よ）。
◎
Any mangling of Digest, including de-duplication of representation-data-digest values or combining different field values (see Section 5.2 of [SEMANTICS]) might affect signature validation.
</p>

		</section>
		<section id="usage-in-trailer-fields">
<h3 title="Usage in Trailer Fields">10.4. ~trailerにおける用法</h3>

<p>
`送信者$は、`~trailer節$内に `Digest$h を送信する前に，次について考慮するべきである
⇒
`中継者$には、どの`~trailer$も落とすことが明示的に許容されている（
`SEMANTICS/~trailerの処理$sec
を見よ）。
◎
Before sending Digest in a trailer section, the sender should consider that intermediaries are explicitly allowed to drop any trailer (see Section 6.5.2 of [SEMANTICS]).
</p>

<p>
`Digest$h が`~trailer$として利用された場合、`受信者$は，`内容$より後に~digest値を取得する
— したがって，受信者【！receiver】は、内容の~dataを，その~digest値を検証する前に処理したくなることもあろう。
それは、 `Digest^h を検証した後に限り処理する方が好ましい。
◎
When Digest is used in trailer fields, the receiver gets the digest value after the content and may thus be tempted to process the data before validating the digest value. It is preferable that data is only be processed after validating the Digest.
</p>

<p>
`digest-algorithm$p には，`~trailer節$内の利用には相応しくないものもある
— うち一部は、~messageを送信する前に，`内容$全体を予め処理することを要求することもある（例： `I-D.thomson-http-mice$r を見よ）。
◎
Not every digest-algorithm is suitable for use in the trailer section, some may require to pre-process the whole payload before sending a message (eg. see [I-D.thomson-http-mice]).
</p>

		</section>
		<section id="usage-with-encryption">
<h3 title="Usage with Encryption">10.5. 暗号化を伴う用法</h3>

<p>
`Digest$h は、暗号化されてない~dataに対し~checksumが算出されるときは，暗号化された`内容$の詳細を公開し得る。
例えば、
"`id-sha-256$c" `digest-algorithm$p を
`暗号化される内容~符号法^cite `RFC8188$r
と併せて利用するとき。
◎
Digest may expose details of encrypted payload when the checksum is computed on the unencrypted data. For example, the use of the "id-sha-256" digest-algorithm in conjunction with the encrypted content-coding [RFC8188].
</p>

<p>
暗号化された`内容$に対する `representation-data-digest$p は、利用される暗号化~algoに依存して，各~messageごとに変化し得る
— そのような事例では、その値は，
“残りの部分（ `at rest^en ）” 【？】における完全性の証明も供するために利用することはできない
— 当の`内容$（例：符号化されたそれ）が一体として持続されない限り。
◎
The representation-data-digest of an encrypted payload can change between different messages depending on the encryption algorithm used; in those cases its value could not be used to provide a proof of integrity "at rest" unless the whole (e.g. encoded) content is persisted.
</p>

		</section>
		<section id="algorithm-agility">
<h3 title="Algorithm Agility">10.6. ~algo即応性</h3>

<p>
`digest-algorithm$p の~securityの特質は、固定的でない【時を経れば変化し得る】。
`~algo即応性^cite（ `Algorithm Agility^en, `RFC7696$r ）は、［
`digest-algorithm$p を［
`11.1$secによる ~IANA`~HTTP~digest~algo値~registry$cite
］から選ぶ柔軟性
］を備える実装を供することにより達成される。
◎
The security properties of digest-algorithms are not fixed. Algorithm Agility (see [RFC7696]) is achieved by providing implementations with flexibility choose digest-algorithms from the IANA Digest Algorithm Values registry in Section 11.1.
</p>

<p>
この文書は、どの~algoが［
弱いのか, 強いのか
］端点が解する助けになるよう，
~IANA`~HTTP~digest~algo値~registry$cite
に新たな “位置付け（ `Status^en ）” ~fieldを追加する
— それは、最も近過去な `digest-algorithm$p に対する “鑑定” を包含する。
許容される値は、 `11.2$sec にて指定される。
◎
To help endpoints understand weaker algorithms from stronger ones, this document adds to the IANA Digest Algorithm Values registry a new "Status" field containing the most-recent appraisal of the digest-algorithm; the allowed values are specified in Section 11.2.
</p>

<p>
端点には、どの~algoにするか選好があるかもしれない
— “非推奨にされた” ものより “標準な” ~algoを選好するなど。
弱い~algoからの移行は、［
`Want-Digest$h を利用して `digest-algorithm$p を折衝する／
複数個の `representation-data-digest$p 値を送信して，その中から`受信者$【！receiver】に選んでもらう
］ことにより~supportされる。
とは言え，資源を消費して複数個の値を送信しても、`受信者$【！receiver】から無視された場合には，浪費されることになる（ `3$sec を見よ）。
◎
An endpoint might have a preference for algorithms, such as preferring "standard" algorithms over "deprecated" ones. Transition from weak algorithms is supported by negotiation of digest-algorithm using Want-Digest (see Section 4) or by sending multiple representation-data-digest values from which the receiver chooses. Endpoints are advised that sending multiple values consumes resources, which may be wasted if the receiver ignores them (see Section 3).
</p>

		</section>
		<section id="duplicate-digest-algorithm-in-field-value">
<h3 title="Duplicate digest-algorithm in field value">10.7. ~field値~内の重複な `digest-algorithm^p</h3>

<p>
端点は、複数個の `representation-data-digest$p 値を受信するかもしれない（ `3$sec を見よ）
— 同じ `digest-algorithm$p を利用しつつ，その~digest値は［
異なる／一致する
］ような。
例えば：
◎
An endpoint might receive multiple representation-data-digest values (see Section 3) that use the same digest-algorithm with different or identical digest-values. For example:
</p>
<div class="example">

<pre class="lang-example">
Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=,
        sha-256=47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=
</pre>
</div>

<p>
`受信者$【！receiver】には、どの `representation-data-digest$p 値も無視することが許可される
— 重複の検証は、実装の裁定に委ねられる。
各~値のうち いくつを~checksum比較~用に選定するかは，端点に委ねられるので、それらの結果の交わりに基づいて，~digest検証に条件付きに合格することも失敗することもある。
◎
A receiver is permitted to ignore any representation-data-digest value, so validation of duplicates is left as an implementation decision. Endpoints might select all, some or none of the values for checksum comparison and, based on the intersection of those results, conditionally pass or fail digest validation.
</p>

		</section>
		<section id="resource-exhaustion">
<h3 title="Resource exhaustion">10.8. 資源の枯渇</h3>

<p>
`Digest$h 検証は、計算l資源を消費する。
資源の枯渇を避けるためには、実装は、［
~algoの種別, 検証の回数, 内容の~size
］の検証を制約できる。
◎
Digest validation consumes computational resources. In order to avoid resource exhaustion, implementations can restrict validation of the algorithm types, number of validations, or the size of content.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">11. ~IANA考慮点</h2>

		<section id="iana-digest-algorithm-registry">
<h3 title="Establish the HTTP Digest Algorithm Values Registry">11.1. ~HTTP~digest~algo値~registryを確立する</h3>

<p>
このメモは、この仕様が
`~HTTP~digest~algo値~registry$cite用の文書を確立するものと設定する。
◎
This memo sets this specification to be the establishing document for the HTTP Digest Algorithm Values registry.
</p>

		</section>
		<section id="iana-digest-algorithm-status">
<h3 title="The 'status' Field in the HTTP Digest Algorithm Values Registry">11.2. ~HTTP~digest~algo値~registry内の `位置付け^i ~field</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$citeに
`位置付け^i（ `Status^en ）~fieldを追加する。
`位置付け^i ~field用に許容される値は：
◎
This memo adds the field "Status" to the HTTP Digest Algorithm Values registry. The allowed values for the "Status" fields are described below.
◎
Status
</p>
<ul>
	<li>
`標準^i （ `standard^en ）
— 標準~化された~algoのうち，既知な問題を伴わないもの。
◎
"standard" for standardized algorithms without known problems;
</li>
	<li>
`試験的^i（ `experimental^en ）／
`廃用d^i （ `obsoleted^en ）／
その他，何らかの適切な値
— 例：
当の~algoを定義した首な文書の種別と位置付けに則って。

◎
"experimental", "obsoleted" or some other appropriate value - e.g. according to the type and status of the primary document in which the algorithm is defined;
</li>
	<li>
`非推奨d^i （ `deprecated^en ）
— ~secureでなくなったか望ましくなくなった~algo。
◎
"deprecated" when the algorithm is insecure or otherwise undesirable.
</li>
</ul>

		</section>
		<section id="iana-md5">
<h3 title="Deprecate 'MD5' Digest Algorithm">11.3. ~digest~algo `MD5^i を非推奨にする</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内の
`MD5$i `digest-algorithm$p を更新する：
◎
This memo updates the "MD5" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`md5$c"
◎
Digest Algorithm: md5
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="iana-unixsum">
<h3 title="Update 'UNIXsum' Digest Algorithm">11.4. ~digest~algo `UNIXsum^i を更新する</h3>

<p>
このメモメモは、
`~HTTP~digest~algo値~registry$cite内の
`UNIXsum$i `digest-algorithm$p を更新する：
◎
This memo updates the "UNIXsum" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
`5$sec にて指定されるとおり。
◎
Digest Algorithm: As specified in Section 5.
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="iana-unixcksum">
<h3 title="Update 'UNIXcksum' Digest Algorithm">11.5. ~digest~algo `UNIXcksum^i を更新する</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内の
`UNIXcksum$i `digest-algorithm$p を更新する：
◎
This memo updates the "UNIXcksum" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
`5$sec にて指定されるとおり。
◎
Digest Algorithm: As specified in Section 5.
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="iana-crc32c">
<h3 title="Update 'CRC32c' Digest Algorithm">11.6. ~digest~algo `CRC32c^i を更新する</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内の
`CRC32c$i `digest-algorithm$p を更新する：
◎
This memo updates the "CRC32c" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`crc32c@c"
◎
Digest Algorithm: crc32c
</li>
	<li>
記述：
`CRC32c$i ~algoは、
32 ~bit巡回冗長性を検査する（ `cyclic redundancy check^en ）。
それは、他の多くの 32 ~bit~CRC関数より良い~hamming距離を達成する（~error検出~処理能が他より良い）。
それは、~iSCSIや~SCTPを含む他の場面でも利用される。
その出力は 32 ~bitであり、~hexadecimalに符号化される（
1 〜 8 個の~ASCII文字（ 0-9, A-F, a-f ）を利用して／
頭部に 0 も許容される）。
例えば，［
`crc32c=0a72a4df^c,
`crc32c=A72A4DF^c
］は、どちらも［
3 ~byteな~message "`dog^c"
］用の妥当な~checksumを与える。
◎
Description: The CRC32c algorithm is a 32-bit cyclic redundancy check. It achieves a better hamming distance (for better error-detection performance) than many other 32-bit CRC functions. Other places it is used include iSCSI and SCTP. The 32-bit output is encoded in hexadecimal (using between 1 and 8 ASCII characters from 0-9, A-F, and a-f; leading 0's are allowed). For example, crc32c=0a72a4df and crc32c=A72A4DF are both valid checksums for the 3-byte message "dog".
</li>
	<li>
参照：
`RFC4960/B$sec,
この文書
◎
Reference: [RFC4960] appendix B, this document.
</li>
	<li>
位置付け：
`標準^i
◎
Status: standard.
</li>
</ul>

		</section>
		<section id="iana-sha">
<h3 title="Deprecate 'SHA' Digest Algorithm">11.7. ~digest~algo `SHA^i を非推奨にする</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内の
`SHA$i `digest-algorithm$p を更新する：
◎
This memo updates the "SHA" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`sha$c"
◎
Digest Algorithm: sha
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="iana-adler-32">
<h3 title="Obsolete 'ADLER32' Digest Algorithm">11.8. ~digest~algo `ADLER32^i を廃用にする</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内の `ADLER32$i `digest-algorithm$p を更新する：
◎
This memo updates the "ADLER32" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`adler32@c"
◎
Digest Algorithm: adler32
</li>
	<li>
記述：
`ADLER32$i ~algoは
`RFC1950$r `ZLIB Compressed Data Format^cite
にて指定される~checksumである。
その出力は 32 ~bitであり、~hexadecimalに符号化される（
1 〜 8 個の~ASCII文字（ 0-9, A-F, a-f ）を利用して／
頭部に 0 も許容される）。
例えば［
`adler32=03da0195^c,
`adler32=3DA0195^c
］は、どちらも［
4 ~byteな~message "`Wiki^c"
］用の妥当な~checksumを与える。
この~algoは、廃用にされたので，利用されるベキでない。
◎
Description: The ADLER32 algorithm is a checksum specified in [RFC1950] "ZLIB Compressed Data Format". The 32-bit output is encoded in hexadecimal (using between 1 and 8 ASCII characters from 0-9, A-F, and a-f; leading 0's are allowed). For example, adler32=03da0195 and adler32=3DA0195 are both valid checksums for the 4-byte message "Wiki". This algorithm is obsoleted and SHOULD NOT be used.
</li>
	<li>
位置付け：
`廃用d^i
◎
Status: obsoleted
</li>
</ul>

		</section>
		<section id="iana-contentMD5">
<h3 title="Obsolete 'contentMD5' token in Digest Algorithm">11.9. ~digest~algoにおいて廃用にされた "`contentMD5^c" ~token</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$cite内に "`contentMD5$c" ~tokenを追加する：
◎
This memo adds the "contentMD5" token in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
`contentMD5@c
◎
Digest Algorithm: contentMD5
</li>
	<li>
記述：
`RFC3230/5$sec は、
"`contentMD5$c" ~tokenは
`Want-Digest$h 内に限り利用されるものと定義した。
この~tokenは、廃用にされた
— 利用してはナラナイ。
◎
Description: Section 5 of [RFC3230] defined the "contentMD5" token to be used only in Want-Digest. This token is obsoleted and MUST NOT be used.
</li>
	<li>
参照：
この文書の `11.9$sec,
`RFC3230/5$sec
◎
Reference: Section 11.9 of this document, Section 5 of [RFC3230].
</li>
	<li>
位置付け：
`廃用d^i
◎
Status: obsoleted
</li>
</ul>

		</section>
		<section id="iana-id-sha-256">
<h3 title="The 'id-sha-256' Digest Algorithm">11.10. "`id-sha-256^c" ~digest~algo</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$citeに
"`id-sha-256$c" `digest-algorithm$p を登録する
:
◎
This memo registers the "id-sha-256" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`id-sha-256$c"
◎
Digest Algorithm: id-sha-256
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="iana-id-sha-512">
<h3 title="The 'id-sha-512' Digest Algorithm">11.11. "`id-sha-512^c" ~digest~algo</h3>

<p>
このメモは、
`~HTTP~digest~algo値~registry$citeに
"`id-sha-512$c" `digest-algorithm$p を登録する：
◎
This memo registers the "id-sha-512" digest-algorithm in the HTTP Digest Algorithm Values registry:
</p>
<ul>
	<li>
~digest~algo：
"`id-sha-512$c"
◎
Digest Algorithm: id-sha-512
</li>
	<li>
記述：
`5$sec にて指定されるとおり。
◎
Description: As specified in Section 5.
</li>
	<li>
位置付け：
`5$sec にて指定されるとおり。
◎
Status: As specified in Section 5.
</li>
</ul>

		</section>
		<section id="changes-compared-to-rfc3230">
<h3 title="Changes Compared to RFC3230">11.12. ~RFC 3230 からの変更点</h3>

<p>
`RFC3230/5$r にて定義される
`contentMD5$c `digest-algorithm$p ~tokenは、
`~HTTP~digest~algo値~registry$citeから除去された。
◎
&amp;#65532; The contentMD5 digest-algorithm token defined in Section 5 of [RFC3230] is removed from the HTTP Digest Algorithm Values Registry.
</p>

		</section>
		<section id="changes-compared-to-rfc5843">
<h3 title="Changes Compared to RFC5843">11.13. ~RFC 5843 からの変更点</h3>

<p>
次に挙げる `digest-algorithm$p 値は、小文字に更新された
⇒＃
"`MD5^c",
"`SHA^c",
"`SHA-256^c",
"`SHA-512^c",
"`UNIXcksum^c",
"`UNIXsum^c",
"`ADLER32^c",
"`CRC32c^c"
◎
The digest-algorithm values for "MD5", "SHA", "SHA-256", "SHA-512", "UNIXcksum", "UNIXsum", "ADLER32" and "CRC32c" have been updated to lowercase.
</p>

<p>
"`MD5^c" の位置付けは，
`非推奨d^i に更新された
— その記述は
“この~algoは利用してはナラナイ”
ものと言明する。
◎
The status of "MD5" has been updated to "deprecated", and its description states that this algorithm MUST NOT be used.
</p>

<p>
"`SHA^c" の位置付けは，
`非推奨d^i に更新された
— その記述は
“この~algoは利用してはナラナイ”
ものと言明する。
◎
The status of "SHA" has been updated to "deprecated", and its description states that this algorithm MUST NOT be used.
</p>

<p>
［
"`CRC2c^c",
"`UNIXsum^c",
"`UNIXcksum^c"
］用の位置付けは、
`標準^i に更新された。
◎
The status for "CRC2c", "UNIXsum" and "UNIXcksum" has been updated to "standard".
</p>

<p>
この~registryには［
"`id-sha-256$c",
"`id-sha-512$c"
］~algoが追加された。
◎
The "id-sha-256" and "id-sha-512" algorithms have been added to the registry.
</p>

		</section>
		<section id="want-digest-field-registration">
<h3 title="Want-Digest Field Registration">11.14. `Want-Digest^h ~fieldの登録</h3>

<p>
この節は
`~HTTP~field名~registry^cite
`SEMANTICS$r
に `Want-Digest$h ~fieldを登録する。
◎
This section registers the Want-Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>

<p>
~field名：
`Want-Digest^h
◎
Field name: Want-Digest
</p>

<p>
位置付け：
`恒久的^i
◎
Status: permanent
</p>

<p>
仕様~文書：
この文書の `4$sec
◎
Specification document(s): Section 4 of this document
</p>

		</section>
		<section id="digest-field-registration">
<h3 title="Digest Field Registration">11.15. `Digest^h ~fieldの登録</h3>

<p>
この節では、
`~HTTP~field名~registry^cite `SEMANTICS$r
に `Digest$h ~fieldを登録する。
◎
This section registers the Digest field in the "Hypertext Transfer Protocol (HTTP) Field Name Registry" [SEMANTICS].
</p>

<p>
~field名：
`Digest$h
◎
Field name: Digest
</p>

<p>
位置付け：
`恒久的^i
◎
Status: permanent
</p>

<p>
仕様~文書：
この文書の `3$sec
◎
Specification document(s): Section 3 of this document
</p>

		</section>
	</section>
	<section id="resource-representation">
<h2 title="Appendix A. Resource Representation and Representation-Data">付録 A. 資源~表現と表現~data</h2>

<p>
以下に挙げる例は、［
`表現~metadata$, `内容$の`形式変換$, `~method$
］が~messageと`内容$にどう影響iするかを示す。
以下において，`内容$が印字不能な文字を包含するとき（例：圧縮されているとき）は、~base64に符号化された文字列として示される。
◎
The following examples show how representation metadata, payload transformations and method impacts on the message and content. When the content contains non-printable characters (eg. when it is compressed) it is shown as base64-encoded string.
</p>

<div class="example">
<p>
`内容~符号法$を伴わない~JSON~objを伴う要請。
◎
A request with a JSON object without any content coding.
</p>

<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

{"hello": "world"}
</pre>
</div>

<div class="example">
<p>
`gzip$c `内容~符号法$を利用して圧縮された~JSON~obj。
◎
Here is a gzip-compressed JSON object using a content coding.
</p>

<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json
Content-Encoding: gzip

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
</div>

<div class="example">
<p>
同じ`内容$は、今度は不正形な~JSON~objを伝達する。
◎
Now the same content conveys a malformed JSON object.
</p>

<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
PUT /entries/1234 HTTP/1.1
Host: foo.example
Content-Type: application/json

H4sIAItWyFwC/6tWSlSyUlAypANQqgUAREcqfG0AAAA=
</pre>
</div>

<div class="example">
<p>
`範囲~要請$は、`内容$を改めて，部分的な表現を伝達する。
◎
A Range-Request alters the content, conveying a partial representation.
</p>

<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
GET /entries/1234 HTTP/1.1
Host: foo.example
Range: bytes=1-7
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Content-Encoding: gzip
Content-Type: application/json
Content-Range: bytes 1-7/18

iwgAla3RXA==
</pre>
</div>

<div class="example">
<p>
今度は、~methodは`内容$も改める。
◎
Now the method too alters the content.
</p>

<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
HEAD /entries/1234 HTTP/1.1
Host: foo.example
Accept: application/json
Accept-Encoding: gzip
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Encoding: gzip
</pre>
</div>

<p>
~HTTP応答の意味論は、`~target~URI$を同封された表現から切り離すかもしれない。
下に与える応答の例では、
`Content-Location$h ~headerは、［
同封された表現は `/authors/123^c にて可用な資源を指す
］ことを指示する。
◎
Finally the semantics of an HTTP response might decouple the effective request URI from the enclosed representation. In the example response below, the Content-Location header field indicates that the enclosed representation refers to the resource available at /authors/123.
</p>

<div class="example">
<p>
要請：
◎
Request:
</p>

<pre class="lang-http">
POST /authors/ HTTP/1.1
Host: foo.example
Accept: application/json
Content-Type: application/json

{"author": "Camilleri"}
</pre>

<p>
応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 201 Created
Content-Type: application/json
Content-Location: /authors/123
Location: /authors/123

{"id": "123", "author": "Camilleri"}
</pre>
</div>

	</section>
	<section id="changes-from-rfc3230">
<h2 title="Appendix B. Changes from RFC3230">付録 B. ~RFC 3230 からの変更点</h2>

		<section id="deprecate-contentMD5">
<h3 title="B.1. Deprecate Negotiation of Content-MD5">B.1. `Content-MD5^h の折衝は非推奨にする</h3>

<p>
この~RFCは、
`Content-MD5$h の折衝を非推奨にする
— それは `RFC7231$r により廃用にされたので。
◎
This RFC deprecates the negotiation of Content-MD5 as it has been obsoleted by [RFC7231].
</p>

		</section>
		<section id="obsolete-parameters">
<h3 title="Obsolete Digest Field Parameters">B.2. ~digest~field用の廃用にされた~parameter</h3>

<p>
`RFC3230/4.1.1$sec,
`RFC3230/4.2$sec
は、~field~parameterを定義した。
この文書は、
`Digest$h における~parameterを伴う用法を廃用にする
— この特能は、広範に配備されてないことに加え，`~field値$の処理を複雑化するので。
◎
Section 4.1.1 and 4.2 of [RFC3230] defined field parameters. This document obsoletes the usage of parameters with Digest because this feature has not been widely deployed and complicates field-value processing.
</p>

<p>
`RFC3230$r は、~field~parameterを［
`representation-data-digest$p に追加的な情報を添えるための共通な仕方を供する
］ものと意図した。
しかしながら，~checksumを検証するための入力として~parameterが利用された場合、攻撃者は，それらを改めることで検証の挙動を操ることもできる。
◎
[RFC3230] intended field parameters to provide a common way to attach additional information to a representation-data-digest. However, if parameters are used as an input to validate the checksum, an attacker could alter them to steer the validation behavior.
</p>

<p>
それでも、
`digest-algorithm$p は~parameter化できる
— ［
`representation-data-digest$p の中に~parameterを符号化する
］ための自前の仕方を定義することにより，その算出に関係する~security~riskを軽減するような仕方で。
◎
A digest-algorithm can still be parameterized by defining its own way to encode parameters into the representation-data-digest, in such a way as to mitigate security risks related to its computation.
</p>

		</section>
	</section>

	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この文書の大部分は `RFC3230$r を継承している。
その偉業を成された
`J. Mogul^en, `A. Van Hoff^en
両氏に謝意を。
この文書を刷新する元の案は、
`MICE^i `内容~符号法$を考査したときに［
`M. Nottingham^en,
`J. Yasskin^en,
`M. Thomson^en
］各氏との興味深い論点から発生した。
◎
The vast majority of this document is inherited from [RFC3230], so thanks to J. Mogul and A. Van Hoff for their great work. The original idea of refreshing this document arose from an interesting discussion with M. Nottingham, J. Yasskin and M. Thomson when reviewing the MICE content coding.
</p>

	</section>
	<section id="faq">
<h2 title="FAQ">よくある質問</h2>

<p>
`この節は、発行~前に除去されることになる。^em
◎
RFC Editor: Please remove this section before publication.
</p>
<dl>
	<dt>
`content-md5^c 【 `contentMD5$c ／ `Content-MD5$h ？】への参照をすべて除去するのはなぜですか？
◎
Why remove all references to content-md5?
</dt>
	<dd>
それらは、この仕様を解して利用することには不必要だからです。
◎
Those were unnecessary to understanding and using this specification.
</dd>

	<dt>
なぜ~instance操作への参照を除去するのですか？
◎
Why remove references to instance manipulation?
</dt>
	<dd>
仕様を正しく利用して適用するためには，不必要だからです。
`範囲~要請$を伴う例で十分~過ぎます。
それらの事例は，すべて、この文書が利用する用語 “部分的な表現” に~~分類されるはずです。
◎
Those were unnecessary for correctly using and applying the specification. An example with Range Request is more than enough. This document uses the term "partial representation" which should group all those cases.
</dd>

	<dt>
`Digest$h を `PATCH$m ~methodと伴に利用する方法は？
◎
How to use Digest with PATCH method?
</dt>
	<dd>
`6$sec を見てください。
◎
See Section 6.
</dd>

	<dt>
差分~符号化法（ `delta encoding^en 【~RFC 3229】）への参照を除去するのはなぜですか？
◎
Why remove references to delta-encoding?
</dt>
	<dd>
この仕様の正しい実装には不必要だからです。
改訂された この仕様は， “差分~符号化法” に良好に順応できますが、
ここで差分~符号化法を参照しても，この~RFCには何も追加されません。
差分~符号化法を刷新するのは、別の仕事になるでしょう。
◎
Unnecessary for a correct implementation of this specification. The revised specification can be nicely adapted to "delta encoding", but all the references here to delta encoding don't add anything to this RFC. Another job would be to refresh delta encoding.
</dd>

	<dt>
`~digest認証^cite（ `Digest Authentication^en ）への参照を除去するのはなぜですか？
◎
Why remove references to Digest Authentication?
</dt>
	<dd>
この仕様と`~digest認証^citeは、単語 “`Digest^en” を除き，完全に無関係と見受けられます。
◎
This specification seems to me completely unrelated to Digest Authentication but for the word "Digest".
</dd>

	<dt>
`Want-Digest$h における変更点は何ですか？
◎
What changes in Want-Digest?
</dt>
	<dd>
`RFC3230/5$sec にて定義された `contentMD5$c ~tokenは、
`B.1$sec により非推奨にされました。
◎
The contentMD5 token defined in Section 5 of [RFC3230] is deprecated by Appendix B.1.
</dd>
	<dd>
`RFC3230$r は、`送信者$と`受信者$【！receiver】, それらの定義を注意深く利用します。
［
`Digest$h ／ `Want-Digest$h
］は［
要請, 応答
］どちらにも利用できることを明確化するため、［
次を広告するために，応答~内で `Want-Digest$h を利用する例
］を追加しました
⇒
~supportされる `digest-algorithm$p,
~supportされない `digest-algorithm$p を伴う要請を受容する能が無いこと
◎
To clarify that Digest and Want-Digest can be used in both requests and responses - [RFC3230] carefully uses sender and receiver in their definition - we added examples on using Want-Digest in responses to advertise the supported digest-algorithms and the inability to accept requests with unsupported digest-algorithms.
</dd>

	<dt>
この仕様は、~supportされる~algoを変更しますか？
◎
Does this specification change supported algorithms?
</dt>
	<dd>
はい。
この~RFCは、 `RFC5843$r を更新します。
— それでも、すべての~algo更新は，それに委譲されます【？】。
加えて、
2 つの~algo［
"`id-sha-256$c", "`id-sha-512$c"
］を追加します
— これらは、`資源$の［
適用される`内容~符号法$を伴わない`表現$
］の~checksumを送信することを許容します。
将来における`有構造~field$ `I-D.ietf-httpbis-header-structure$r への移行を単純~化するため、
`digest-algorithm$p 用には小文字を利用することを示唆します。
◎
Yes. This RFC updates [RFC5843] which is still delegated for all algorithms updates, and adds two more algorithms: "id-sha-256" and "id-sha-512" which allows to send a checksum of a resource representation with no content codings applied. To simplify a future transition to Structured Fields [I-D.ietf-httpbis-header-structure] we suggest to use lowercase for digest-algorithms.
</dd>

	<dt>
~stream途中の`~trailer$についてはどうですか？
◎
What about mid-stream trailer fields?
</dt>
	<dd>
<a href="https://github.com/httpwg/http-core/issues/313#issuecomment-584389706">~stream途中の~trailer</a>
は関心事ですが、
この仕様は `RFC3230$r を書き直すので，それに直面するべきとは考えていません。
最初の考えとして、~stream途中の~trailer用の利用
— 例えば増分的な `digest-algorithm$p —
を見出すような将来の作業を予め除外するものは，この文書~内にはありません。
そのような `digest-algorithm$p を定義している文書が，それが どう利用されるかを述べる最良な立場にあります。
◎
While mid-stream trailer fields are interesting, since this specification is a rewrite of [RFC3230] we do not think we should face that. As a first thought, nothing in this document precludes future work that would find a use for mid-stream trailers, for example an incremental digest-algorithm. A document defining such a digest-algorithm is best positioned to describe how it is used.
</dd>
</dl>

	</section>
	<section id="code-samples">
<h2 title="Code Samples">~code見本</h2>

<p>
`この節は、発行~前に除去されることになる^em。
◎
RFC Editor: Please remove this section before publication.
</p>

<p>
この節では、この文書~全体を通して各~例にて示される `Digest$h 値を，どう［
生成する／検証する
］かを与える。
◎
How can I generate and validate the Digest values shown in the examples throughout this document?
</p>

<p>
次の~python3~codeを利用すれば、ある範囲の符号化法に対し，各種~SHA~algoを利用して~JSON~obj用の~digestを生成できる。
これらは、~base64形式にされることに注意。
この関数は、他の~algoに順応することもできる
— その場合、それらに特有な形式~化~規則を織り込むべきである。
◎
The following python3 code can be used to generate digests for JSON objects using SHA algorithms for a range of encodings. Note that these are formatted as base64. This function could be adapted to other algorithms and should take into account their specific formatting rules.
</p>

<div>
<pre>
import base64, json, hashlib, brotli, logging
log = logging.getLogger()

def encode_item(item, encoding=lambda x: x):
    indent = 2 if isinstance(item, dict) and len(item) &gt; 1 else None
    json_bytes = json.dumps(item, indent=indent).encode()
    return encoding(json_bytes)

def digest_bytes(bytes_, algorithm=hashlib.sha256):
    checksum_bytes = algorithm(bytes_).digest()
    log.warning("Log bytes: \n[%r]", bytes_)
    return base64.encodebytes(checksum_bytes).strip()

def digest(item, encoding=lambda x: x, algorithm=hashlib.sha256):
    content_encoded = encode_item(item, encoding)
    return digest_bytes(content_encoded, algorithm)

item = {"hello": "world"}

print("Encoding | digest-algorithm | digest-value")
print("Identity | sha256 |", digest(item))
# Encoding | digest-algorithm | digest-value
# Identity | sha256 | X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=

print("Encoding | digest-algorithm | digest-value")
print("Brotli | sha256 |", digest(item, encoding=brotli.compress))
# Encoding | digest-algorithm | digest-value
# Brotli | sha256 | 4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=

print("Encoding | digest-algorithm | digest-value")
print("Identity | sha512 |", digest(item, algorithm=hashlib.sha512))
# Encoding | digest-algorithm | digest-value
# Identity | sha512 | b'WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm'
#                      '+AbwAgBWnrIiYllu7BNNyealdVLvRwE\nmTHWXvJwew=='
</pre>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
`この節は、発行~前に除去されることになる^em
【以下，この節の内容は、未訳。】
◎
RFC Editor: Please remove this section before publication.
</p>

	</section>
</main></div>
