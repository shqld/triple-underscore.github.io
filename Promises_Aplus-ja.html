<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Promises/A+ （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />

<style>

var {
	font-family: monospace0, monospace;
}

pre.language-js {
	background: #EEE;
	border: solid gray 1px;
	padding: 0.5em;
}

code, pre {
/*
	color: navy;
*/
}

code.es {
	color: black;
	font-weight: bold;
}


main > h1 {
	color: white;
	background: #222;
	font-size: 2em;
	padding: 0.5em;
	font-family: sans-serif0, sans-serif;
}

main > h1:before {
	content: 'then';
	color: #222;
	background: #FE2;
	font-size: 0.5em;
	display: inline-block;
	padding: 3em 0.5em 0em 1.5em;
	margin-right: 1em;
}

h2, h3 {
	color: black;
}

body {
	background: #f2f2f2;
}

footer {
	border-top: solid gray 1px;
	text-align: center;
}
footer > a {
	white-space: nowrap;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%\w+|`(.+?)([\^@$])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;
	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

trans_update:2016-04-10
	source_checked:vers.1.1.1, 140505 spec
	navs:a[href^='#note']
trans_1st_pub:2015-01-13


●●class_map
es:es

●●tag_map
es:code
c:code

●●link_map


~promise:#promise
~thenable:#thenable
値:#value
例外:#exception
事由:#rejection-reason
処理待ち:#pending
充足-済み:#fulfilled
却下-済み:#rejected
充足する:#fulfill
却下する:#reject
充足され:#fulfill
却下され:#reject
	~promiseの解決~手順:#promise-resolution-procedure

c.setTimeout:~HTMLGAPI#timers
c.setImmediate:https://dvcs.w3.org/hg/webperf/raw-file/tip/specs//Overview.html#processingmodel

c.MutationObserver:~DOM4#interface-mutationobserver
c.process.nextTick:http://nodejs.org/api/process.html#process_process_nexttick_callback

●●words_table

JS:JavaScript
object:
function:
method:::メソッド
promise::::プロミス
thenable:
property:::プロパティ
call:
callback::::コールバック
大域:global::~:グローバル
handler:::ハンドラ
stack:::スタック
strict:
sloppy:
macro-task:::マクロタスク
micro-task:::マイクロタスク
task:::タスク
schedule:::スケージュル
	~taskを~scheduleする:task-scheduling
trampoline:::トランポリン
queue::::キュー
	task-scheduling~queue
返した:returnした:~
返す:returnする:~

連鎖:chain::~:チェイン
投出:throw::~
状態:state::~
演算:operation::~
無視-:ignore::~
無限:infinite::~
非同期的:asynchronous::~
遷移:transition::~
値:value::~
処理待ち:pending::~
却下-:reject::~
	却下-済み:rejected
充足-:fulfill::~
	充足-済み:fulfilled
充足:fulfillment::~
引数:argument::~
解決-:resolve::~
解決:resolution::~
事由:reason::~
例外:exception::~

手順:procedure:手続き
手続き:steps:~
省略可:optional::~

	そのような:such
	上の:above::~
	この:this::~
	すべての:all::~
	それら:they::~

	3 個の:three
access:::アクセス
accessor:::アクセサ
algo:algorithm::アルゴリズム
基盤:base:~
	choosing:
循環的な:circular:~
循環:cycle:~
code:::コード
	come:come::~
	consideration:consideration::~
事例:case:~
取入れ:adopt:取り入れ
取入れる:adoptする:取り入れる
取入れさ:adoptさ:取り入れさ
	取り扱-:deal
表記-:denote:~
別個の:distinct:~
engine:::エンジン
event-loop:event loop::イベントループ
一面:face:~
新鮮:fresh:~
以降の:further:~
	限りにおいてas long as:
	満たす:meetする:
mode:::モード
性質:nature:~
出自の:originating:~
用心:precaution:~
	になるproduce:
適度:reasonable:~
	respective:
	~~取得:retrieval
	~~取得-:retrieve
turn::回

遭遇-:encounter:~
	~~最終的に:finally:~
なぞる:follow する
	含め:including:~
	やりとり:interact::~
既知:known:~
	known-conformant:known-conformant::~
小さな:minor:~
大きな:large:~
	もたらす:lead:~
	ことも:occasional::~
関与-:participate:~
	~~優先され: take a precedence::~

指す:referする:~
	あり続け:remain:~
一般:general:~
一貫性:consistency:~
	個目:first／second
	最初の／初回:first
仕方:way:~


仕様:spec:~
主な:primary:~
上限:limit:~
中核の:core:~
主題:subject:~
集中する:focusする:力点を置く
	に取り組む:を address する
変更点:changes:~
奨励-:encourage:~
姉妹:companion:~
安定的:stable:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
将来の:future:~
互換:compatible:~
後方-:backward:~
	互換でない:incompatible
指定中:underspecified:~
条項:clause:~
標準:standard::~
相互運用可能:interoperable:~
	相互運用可能:interoperate:~
改訂-:revise:~
文書化-:document 化:~
早期の:earlier:~
明確化-:clarify:~
歴史的:historical:~
注記:note:~
注:note:~
準拠する:compliantな:~
事実的標準:de facto:事実上の標準
提案:proposal:~
切落とし:omitし:切り落とし
	組織:organization:~
統合-:integrate:~
要件:requirements:~
要求-:require:~
適合-:conform:~
適合t:conformant:適合
	conformant
	適合tでない:nonconformant
test:::テスト
詳細:details:~
議論:discussion:~
注意深く:carefulに:~
考察-:consider:~
信頼でき:sound:信頼できる
際どい:corner:~
	新たに発見された:newly-discovered:~
発見-:discover:~
open:::オープン
platform:::プラットフォーム
cover:::カバー


仕組み:mechanism:~
他の:other:~
	代わりに:instead:~
何か:somewhat:~
作成-:create:~
依存-:depend:~
入力:input:~
公開-:expose:~
内側:inside:~
再び:again:~
再帰:recursion:~
無限再帰:recursing forever:~
再帰的:recursive:~
利用:use:~
前:before:~
前提:assumption:~
包含-:contain:~
参照:reference:~
受取る:receiveする:受け取る
受容-:accept:~
合法な:legal:~
同じ:same:~
同一性:identity:~
消化-:assimilate:~
含意-:imply:~
問題ある:problematicな:問題のある
変化-:change:~
変異-:mutate::~
	変異-不能:immutable
	変異-不能性:immutability
定義-:define:~
後:after:~

実行-:execute:~
遂行-:perform:~
恣意的:arbitrary:~
	:informative:~
意味-:mean:~
成果:work:~
手段:means:~
扱い:treatment:~

抽象-:abstract:~
拡張-:extend:~
指示-:indicate:~
挙動する:behaveする:ふるまう
挙動:behavior:ふるまい
挙動上の:behavioral:ふるまいについての
供-:provide:~
供さな:provideしな:~
文:statement:~
最終的な:eventual:~
最終的:eventual:~
条件:condition:~
格納-:store:~
検出-:detect:~
正しい:correctな:~
深い:deep:~
深さ:depth:~
固有の:specificな:~
現在の:current:~
環境:environment:~

序論:introduction:~
各種用語:terminology:~
登録-:register:~
省略-:omit:~
真の:true:~
	知られ:known:~
確保-:ensure:~
結果:result:~
	自身:itself:~
表現-:represent:~
複数の:multiple:~
見なさ:considerさ:~
見做す:assumeする:~
触れる:touchする:~
許容-:allow:~
試みる:attemptする:~
走らす:runする:~
	超えて:beyond:~
	通:through:~
	避けられる:avoidされる:~
部分:part:~
重要:important:~
順序:order:~
実行文脈:execution context:~
	ごく:very::~
	限りにおいてprovided
	来ている~come
設定-:set:~
member:::メンバ
	似た:like


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://github.com/promises-aplus">Promises/A+ organization</a>
による
<a href="https://promisesaplus.com/">Promises/A+ Promise Specification</a>
（バージョン 1.1.1, 2014-05-05）を日本語に翻訳したものです。
~PUB
</p>

</script>


<!-- 
:https://creativecommons.org/publicdomain/zero/1.0/
Changelog:/changelog
Compliance Tests:https://github.com/promises-aplus/promises-tests
Credits:/credits
Differences from Promises/A:/differences-from-promises-a
GitHub organization:https://github.com/promises-aplus
Implementations:/implementations
MutationObserver:https://dom.spec.whatwg.org/#interface-mutationobserver
Promises/A proposal:http://wiki.commonjs.org/wiki/Promises/A
Specification:/
execution context:https://es5.github.io/#x10.3
process.nextTick:http://nodejs.org/api/process.html#process_process_nexttick_callback
setImmediate:https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel
the Promises/A+ organization:https://github.com/promises-aplus
-->
</head>

<body>

<header>
<h1>Promises/A+</h1>
</header>

<hr>

<div id="MAIN" hidden>

<p><strong>
実装者による, 実装者のための，
信頼でき, 相互運用可能な，~JS~promiseのための~open標準。
</strong>
◎
An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.
</p>

<main id="MAIN0">

	<section id="introduction">
<h2>序論</h2>

<p>
`~promise$は、非同期的~演算の最終的な結果を表現する。
~promiseとのやりとりは、主に，その `then^es ~methodを通して~~行われる
— それは、［
~promiseの最終的な値を受取る~callback
］, または／および［
~promiseを充足できなかったときに その`事由$を受取る~callback
］を登録する。
◎
A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.
</p>

<p>
この仕様は、 `then^es ~methodの挙動の詳細を与える
— それは、［
すべての［
Promises/A+ に適合する~promise実装
］が，それを供することに依存できる
］ような，相互運用可能な基盤を供する。
そのようなわけで、この仕様は ごく安定的と見なされるべきである。
新たに際どい事例が発見されれば，それに取り組むため、この仕様は
Promises/A+ organization により［
小さな, かつ後方-互換な変更点
］で改訂されることもあり得るが、［
大きな, または後方-互換でない変更点
］が統合されるのは、［
注意深く考察され, 議論が積み重ねられ, ~testされた
］後に限られることになる。
◎
This specification details the behavior of the then method, providing an interoperable base which all Promises/A+ conformant promise implementations can be depended on to provide. As such, the specification should be considered very stable. Although the Promises/A+ organization may occasionally revise this specification with minor backward-compatible changes to address newly-discovered corner cases, we will integrate large or backward-incompatible changes only after careful consideration, discussion, and testing.
</p>

<p>
歴史的に， Promises/A+ は、早期の
<a href="http://wiki.commonjs.org/wiki/Promises/A">Promises/A 提案</a>
の挙動上の各~条項を明確化し、［
<em>事実的標準</em> とされている挙動を~coverする
］ために それを拡張し，また［
指定中にある／問題ある
］部分は切落としてきた。
◎
Historically, Promises/A+ clarifies the behavioral clauses of the earlier Promises/A proposal, extending it to cover de facto behaviors and omitting parts that are underspecified or problematic.
</p>

<p>
~~最終的に，中核の Promises/A+ 仕様は、どのように~promiseを
作成する／`充足する$／`却下する$
かについては 取り扱わず、代わりに，相互運用可能な `then^es ~methodを供することに集中する。
姉妹~仕様における将来の成果が，これらの主題に触れることになるであろう。
◎
Finally, the core Promises/A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable then method. Future work in companion specifications may touch on these subjects.
</p>



	</section>
	<section id="terminology">
<h2 title="Terminology">1. 各種用語</h2>

<dl>
	<dt>`~promise@</dt>
	<dd>
`then^es ~methodを備える
~object／~function
であって，その挙動がこの仕様に適合するもの。
◎
“promise” is an object or function with a then method whose behavior conforms to this specification.
</dd>

	<dt>`~thenable@</dt>
	<dd>
`then^es ~methodを定義するような，
~object／~function
。
◎
“thenable” is an object or function that defines a then method.
</dd>

	<dt>`値@</dt>
	<dd>
任意の合法な~JS値（ `undefined^es, `~thenable$, `~promise$も含む）。
◎
“value” is any legal JavaScript value (including undefined, a thenable, or a promise).
</dd>

	<dt>`例外@</dt>
	<dd>
`throw^c 文を利用して投出される`値$。
◎
“exception” is a value that is thrown using the throw statement.
</dd>

	<dt>`事由@</dt>
	<dd>
`~promise$がなぜ`却下され$たかを指示する`値$。
◎
“reason” is a value that indicates why a promise was rejected.
</dd>

</dl>

	</section>
	<section id="requirements">
<h2 title="Requirements">2. 要件</h2>



		<section id="promise-states">
<h3 title="Promise States">2.1 ~promiseの各種~状態</h3>

<p>
`~promise$は、［
`処理待ち@ ／
`充足-済み@ ／
`却下-済み@
］のいずれかの状態にあることが要求される。
~promiseは：
◎
A promise must be in one of three states: pending, fulfilled, or rejected.
</p>

<ul>
	<li>
<p>
`処理待ち$にあるときは：
◎
When pending, a promise:
</p>
		<ul>
			<li>
［
`充足-済み$, `却下-済み$
］いずれかの状態に遷移し得る。
◎
may transition to either the fulfilled or rejected state.
</li>
		</ul>
	</li>
	<li>
<p>
`充足-済み$にあるときは：
◎
When fulfilled, a promise:
</p>
		<ul>
			<li>
他の状態に遷移してはナラナイ。
◎
must not transition to any other state.
</li>
			<li>
`値$を持たなければナラナイ。
この値は変化してはナラナイ。
◎
must have a value, which must not change.
</li>
		</ul>
	</li>
	<li>
<p>
`却下-済み$にあるときは：
◎
When rejected, a promise:
</p>
		<ul>
			<li>
他の状態に遷移してはナラナイ。
◎
must not transition to any other state.
</li>
			<li>
`事由$を持たなければナラナイ。
この事由は変化してはナラナイ。
◎
must have a reason, which must not change.
</li>
		</ul>
	</li>
</ul>

<p>
ここで、
“変化してはナラナイ”
とは、同一性について変異-不能である（すなわち， <code>===</code> ）を意味する。
深い変異-不能性を含意するものではない
【 ~objectであれば その~memberの同一性が保たれる必要はない 】
。
◎
Here, “must not change” means immutable identity (i.e. ===), but does not imply deep immutability.
</p>


<div class="trans-note">
<p >【
定義~補足：
】</p>

<dl>
	<dt>`充足する@（ fulfill ）</dt>
	<dd>
“`値$ %v で`~promise$ %promise を充足する” という句は、
%promise を`充足-済み$状態に遷移させると同時に，
%promise の`値$を %v にすることを意味する。
</dd>

	<dt>`却下する@（ reject ）</dt>
	<dd>
“`事由$ %r で`~promise$ %promise を却下する” という句は、
%promise を`却下-済み$状態に遷移させると同時に，
%promise の`事由$を %r にすることを意味する。
</dd>
</dl>
</div>


		</section>
		<section id="then-method">
<h3 title="The then Method">2.2 `then^es ~method</h3>

<p>
`~promise$は、［
その［
現在の／最終的な
］［
`値$, あるいは`事由$
］に~accessするための， `then^es ~method
］を供さなければナラナイ。
◎
A promise must provide a then method to access its current or eventual value or reason.
</p>

<p>
`~promise$ %promise の `then^es ~methodは、二個の引数を受容する：
◎
A promise’s then method accepts two arguments:
</p>

<pre class="language-js">
%promise.then(%onFulfilled, %onRejected)
</pre>


<ul>
	<li>
<p>
引数 %onFulfilled, %onRejected は，いずれも省略可である：
◎
Both onFulfilled and onRejected are optional arguments:
</p>
		<ol>
			<li>
~functionでない %onFulfilled は無視されなければナラナイ。
◎
If onFulfilled is not a function, it must be ignored.
</li>
			<li>
~functionでない %onRejected は無視されなければナラナイ。
◎
If onRejected is not a function, it must be ignored.
</li>
		</ol>
	</li>
	<li>
<p>
%onFulfilled は、それが~functionであるならば：
◎
If onFulfilled is a function:
</p>
		<ol>
			<li>
%promise が`充足され$た後に，その 1 個目の引数に %promise の`値$を渡して ~callされなければナラナイ。
◎
it must be called after promise is fulfilled, with promise’s value as its first argument.
</li>
			<li>
%promise が`充足され$る前に~callされてはナラナイ。
◎
it must not be called before promise is fulfilled.
</li>
			<li>
複数回~callされてはナラナイ。
◎
it must not be called more than once.
</li>
		</ol>
	</li>
	<li>
<p>
%onRejected は、それが~functionであるならば：
◎
If onRejected is a function,
</p>
		<ol>
			<li>
%promise が`却下され$た後に、その 1 個目の引数に %promise の`事由$を渡して ~callされなければナラナイ。
◎
it must be called after promise is rejected, with promise’s reason as its first argument.
</li>
			<li>
%promise が`却下され$る前に~callされてはナラナイ。
◎
it must not be called before promise is rejected.
</li>
			<li>
複数回~callされてはナラナイ。
◎
it must not be called more than once.
</li>
		</ol>
	</li>
	<li>
%onFulfilled ／ %onRejected は、［
<a href="https://es5.github.io/#x10.3">実行文脈</a>
~stackが包含する~codeが，~platform~codeのみになる
］まで、~callされてはナラナイ。
<a href="#note-3.1">[注 3.1]</a>
◎
onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1].
</li>
	<li>
%onFulfilled ／ %onRejected は、
~functionとして（すなわち， `this^es 値を伴わずに）~callされなければナラナイ。
<a href="#note-3.2">[注 3.2]</a>
◎
onFulfilled and onRejected must be called as functions (i.e. with no this value). [3.2]
</li>
	<li>
<p>
同じ`~promise$上で， `then^es が複数回~callされることもあり得る
— その際には：
◎
then may be called multiple times on the same promise.
</p>
		<ol>
			<li>
%promise が［
`充足され$たとき／`充足-済み$にあるとき
］は
⇒
渡された一連の %onFulfilled ~callbackは、それぞれの出自の `then^es が~callされた順序で実行されなければナラナイ。
◎
If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.
</li>
			<li>
%promise が［
`却下され$たとき／`却下-済み$にあるとき
］は
⇒
渡された一連の %onRejected ~callbackは、それぞれの出自の `then^es が~callされた順序で実行されなければナラナイ。
◎
If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.
</li>
		</ol>
	</li>
	<li>
<p>
`then^es は`~promise$を返すモノトスル。
<a href="#note-3.3">[注 3.3]</a>
◎
then must return a promise [3.3].
</p>

<pre class="language-js">
%promise2 = %promise1.then(%onFulfilled, %onRejected);
</pre>

		<ol>
			<li>
%onFulfilled ／ %onRejected が`値$ %x を返したならば
⇒
<a href="#promise-resolution-procedure">~promiseの解決~手順</a>：
<code>[[Resolve]](%promise2, %x)</code>
を走らす。
◎
If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).
</li>
			<li>
%onFulfilled ／ %onRejected が
`例外$ %e を投出したならば
⇒
%promise2 は，`事由$ %e で`却下され$なければナラナイ。
◎
If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.
</li>
			<li>
%onFulfilled は~functionでない, かつ
%promise1 が`充足され$たならば
⇒
%promise2 は， %promise1 の値と同じ値で`充足され$なければナラナイ。
◎
If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.
</li>
			<li>
%onRejected は~functionでない, かつ
%promise1 が`却下され$たならば
⇒
%promise2 は，
%promise1 の`事由$と同じ値で`却下され$なければナラナイ。
◎
If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.
</li>
		</ol>
	</li>
</ul>



		</section>
		<section id="promise-resolution-procedure">
<h3 title="The Promise Resolution Procedure">2.3 ~promiseの解決~手順</h3>

<p>
<dfn>~promiseの解決~手順</dfn>
は、`~promise$, および`値$を入力にとる抽象-演算であり、
<span class="block"><code>[[Resolve]](%promise, %x)</code></span>
と表記される。
%x が`~thenable$であるならば、それは
%promise に %x の状態を取入れさせようと試みる
— %x が，少なくとも~promiseに似た何かであるかのように挙動する前提の下で。
~~他の場合、それは，値 %x で %promise を`充足する$。
◎
The promise resolution procedure is an abstract operation taking as input a promise and a value, which we denote as [[Resolve]](promise, x). If x is a thenable, it attempts to make promise adopt the state of x, under the assumption that x behaves at least somewhat like a promise. Otherwise, it fulfills promise with the value x.
</p>

<p>
この~thenableの扱いにより、~promise実装は，［
~thenableが Promises/A+ に準拠する `then^es ~methodを公開する
］限りにおいて，相互運用可能になる。
それはまた， Promises/A+ 実装が、適合tでない実装を，適度な `then^es ~methodで “消化-” できるようにする。
◎
This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant then method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable then methods.
</p>

<p>
<code>[[Resolve]](%promise, %x)</code>
を走らすときは、次の手続きを遂行する：
◎
To run [[Resolve]](promise, x), perform the following steps:
</p>

<p class="trans-note">【
以下に現れる記号［
~LET （初期化-）, ~SET （代入）, ~IF, ~ELSE, ~RET（実行制御）, 等々
］の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
】</p>

<ol>
	<li>
%promise と %x が同じ~objectを指すならば
⇒
`事由$ `TypeError^es で %promise を`却下する$
◎
If promise and x refer to the same object, reject promise with a TypeError as the reason.
</li>
	<li>
<p>
~IF
%x は`~promise$である
⇒
その状態を取入れる
<a href="#note-3.4">[注 3.4]</a>
— すなわち， %x の状態に応じて：
◎
If x is a promise, adopt its state [3.4]:
</p>

<dl class="switch">
	<dt>`処理待ち$</dt>
	<dd>
%promise は、［
%x が`充足され$る／`却下され$る
］まで，`処理待ち$であり続けなければナラナイ
— %x の状態が遷移したときは、遷移~~後の状態に応じて，下の対応する段を~~実行することになる。
◎
If x is pending, promise must remain pending until x is fulfilled or rejected.
</dd>

	<dt>`充足-済み$</dt>
	<dd>
%x の`値$で %promise を`充足する$
◎
If/when x is fulfilled, fulfill promise with the same value.
</dd>

	<dt>`却下-済み$</dt>
	<dd>
%x の`事由$で %promise を`却下する$
◎
If/when x is rejected, reject promise with the same reason.
</dd>
</dl>

	</li>
	<li>
<p>
~ELIF
%x は~object／~functionである：
◎
Otherwise, if x is an object or function,
</p>
		<ol>
			<li>
%then ~LET
<code>%x.`then^es</code>
<a href="#note-3.5">[注 3.5]</a>
◎
Let then be x.then. [3.5]
</li>
	<li>
~IF
前段で `then^es を~~取得するときに、`例外$ %e が投出された
⇒
`事由$ %e で %promise を`却下する$
◎
If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.
</li>
			<li>
<p>
~IF
%then は~functionである：
◎
↓</p>

				<ol>
					<li>
<p>
［
`this^es 値 ~SET %x
］の下で，次の二つの引数を渡して %then を~callする：
◎
If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
</p>
						<ul>
							<li>
1 個目の引数 %resolvePromise は、`値$ %y を伴って~callされたときに，
<code>[[Resolve]](%promise, %y)</code>
を走らす~functionである。
◎
If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).
</li>
							<li>
2 個目の引数 %rejectPromise は、`事由$ %r を伴って~callされたときに，
%r で %promise を`却下する$~functionである。
◎
If/when rejectPromise is called with a reason r, reject promise with r.
</li>
							<li>
ただし、［
%resolvePromise, %rejectPromise
の両者, または いずれか
］が（合計で）複数回 ~callされたときは、初回の~callが~~優先され、以降の~callは無視される【何もしない】。
◎
If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
</li>
						</ul>
					</li>
					<li>
<p>
~IF
%then の~callにより，`例外$ %e が投出された：
◎
If calling then throws an exception e,
</p>
						<ol>
							<li>
~IF
%resolvePromise, %rejectPromise いずれかは すでに~callされている
⇒
%e を無視する
◎
If resolvePromise or rejectPromise have been called, ignore it.
</li>
							<li>
~ELSE
⇒
`事由$ %e で %promise を`却下する$
◎
Otherwise, reject promise with e as the reason.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%x で %promise を`充足する$
◎
If then is not a function, fulfill promise with x.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%x で %promise を`充足する$
◎
If x is not an object or function, fulfill promise with x.
</li>
</ol>

<p>
`~promise$が，［［［
<code>[[Resolve]](%promise, thenable)</code>
の再帰的な性質により，最終的に
<code>[[Resolve]](%promise, thenable)</code>
が再び~callされることになる
］ような，循環的な`~thenable$の連鎖
］に関与するような`~thenable$
］で解決されたならば、上の~algoをなぞることは，無限~再帰をもたらすことになる。
実装には、要求されてはいないが，そのような再帰を検出して,
<!-- informative -->
`事由$ `TypeError^es で %promise を`却下する$ことが奨励される。
<a href="#note-3.6">[注 3.6]</a>
◎
If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of [[Resolve]](promise, thenable) eventually causes [[Resolve]](promise, thenable) to be called again, following the above algorithm will lead to infinite recursion. Implementations are encouraged, but not required, to detect such recursion and reject promise with an informative TypeError as the reason. [3.6]
</p>



		</section>
	</section>
	<section id="notes">
<h2 title="Notes" data-cycling="a[href^='#note']">3. 注記</h2>

<ol>
	<li id="note-3.1">
ここでの
“~platform~code”
は、［
~engine／環境／~promise
］の実装~codeを意味する。
実施においては、この要件により，［
%onFulfilled ／ %onRejected
が，［
`then^es が~callされた~event-loopの~turn
］の後に，新鮮な~stackの下で，非同期的に実行される
］ことが確保される。
これは、
`setTimeout$c や `setImmediate$c
などによる “~macro-task”
, あるいは
`MutationObserver$c や `process.nextTick$c＊
などによる “~micro-task” の仕組みにより，実装し得る。
~promise実装は，~platform~codeと見なされるので、それ自身も［
中で~handlerが~callされるような，［
~taskを~scheduleする~queueや “~trampoline”
【<a href="https://en.wikipedia.org/wiki/Trampoline_%28computing%29">trampoline</a>】
］］を包含することもある。
◎
Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.
</li>
	<li id="note-3.2">
すなわち `this^es は、~strict~modeの下では，それらの内側では `undefined^es になり、~sloppy~mode【非~strict~mode】の下では，大域~objectになる。
◎
That is, in strict mode this will be undefined inside of them; in sloppy mode, it will be the global object.
</li>
	<li id="note-3.3">
実装は、
<code>%promise2 === %promise1</code>
を許容してもヨイ
— 実装がすべての要件を満たす限りにおいて。
各~実装は、どの条件の下で
<code>%promise2 === %promise1</code>
になり得るかについて文書~化するべきである。
◎
Implementations may allow promise2 === promise1, provided the implementation meets all requirements. Each implementation should document whether it can produce promise2 === promise1 and under what conditions.
</li>
	<li id="note-3.4">
一般に、 %x が真の`~promise$であることは、現在の実装から来ているときにのみ，知り得る【？】。
この条項により、実装は，自身に固有の手段を利用して［
適合tが既知である~promise
］の状態を，取入れることが~~可能になる。
◎
Generally, it will only be known that x is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.
</li>
	<li id="note-3.5">
この，［
まず
<code>%x.`then^es</code>
への参照を格納した上で，その参照を~testしてから，その参照を~callする
］手順により、［
複数回にわたる
<code>%x.`then^es</code>
~propertyへの~access
］は避けられる。
そのような用心は、［
各~~取得の合間に値が変化し得るような，~accessor~propertyの一面
］における一貫性を確保するために，重要になる。
◎
This procedure of first storing a reference to x.then, then testing that reference, and then calling that reference, avoids multiple accesses to the x.then property. Such precautions are important for ensuring consistency in the face of an accessor property, whose value could change between retrievals.
</li>
	<li id="note-3.6">
実装は、`~thenable$が成す連鎖の深さに恣意的な上限を設定するべき<em>でない</em>
— 再帰は，その恣意的な上限を超えて無限になるものと見做すべきである。
`TypeError^es をもたらすのは、真の循環に限られるべきである
— 別個の~thenableからなる無限~連鎖に遭遇したときの無限再帰は、正しい挙動である。
◎
Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a TypeError; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior.
</li>
</ol>

	</section>

</main></div><!-- MAIN -->

<hr>

<small>
<a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>
To the extent possible under law,
<a href="https://github.com/promises-aplus">the Promises/A+ organization</a>
has waived all copyright and related or neighboring rights to
Promises/A+ Promise Specification.
This work is published from: United States.
</small>


<footer>
<a href="https://promisesaplus.com/"
	title="Specification"
>原文仕様</a>
　
<a href="https://promisesaplus.com/changelog"
	title="Changelog"
>変更ログ</a>
　
<a href="https://promisesaplus.com/credits"
	title="Credits"
>著作者一覧</a>
　
<a href="https://promisesaplus.com/differences-from-promises-a"
	title="Differences from Promises/A"
>Promises/A との差異</a>
　
<a href="https://promisesaplus.com/implementations"
	title="Implementations"
>各種 実装</a>
　
<a href="https://github.com/promises-aplus/promises-tests"
	title="Compliance Tests"
>準拠テスト</a>
<br />
<a href="https://github.com/promises-aplus"
>GitHub organization</a>
</footer>

</body></html>
