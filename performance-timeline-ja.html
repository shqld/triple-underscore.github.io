<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Performance Timeline Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`
	break;
case 'm': // IDL member
case 'mO':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	text = `<span lang="en-x-a1">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Performance Timeline Level 2
spec_date:2020-04-24
trans_update:2020-04-27
source_checked:190511
page_state_key:TIMING
original_url:https://w3c.github.io/performance-timeline/
	abbr_url:TIMELINE
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
copyright:2020,permissive
trans_1st_pub:2015-07-27


●●class_map
E:error

●●tag_map
I:code
m:code
mO:code
d:code
c:code
E:code
v:var
V:var
b:b
i:i

●●original_id_map

dom-performanceobserver-performanceobserver:

	dom-performanceentrylist:idl-def-performanceentrylist
	dom-performanceobservercallback:idl-def-performanceobservercallback
	dom-performanceobserverentrylist:idl-def-performanceobserverentrylist
	dom-performanceobserverinit:idl-def-performanceobserverinit

●●mdn_urls

dom-performanceentry:API/PerformanceEntry
dom-performanceobserver:API/PerformanceObserver
dom-performanceobserverentrylist:API/PerformanceObserverEntryList
	dom-performanceentrylist:API/PerformanceEntryList
	dom-performanceobservercallback:API/PerformanceObserverCallback
	dom-performanceobserverinit:API/PerformanceObserverInit
dom-performance-getentries:API/Performance/getEntries
dom-performance-getentriesbyname:API/Performance/getEntriesByName
dom-performance-getentriesbytype:API/Performance/getEntriesByType
dom-performanceentry-name:API/PerformanceEntry/name
dom-performanceentry-starttime:API/PerformanceEntry/startTime
dom-performanceentry-entrytype:API/PerformanceEntry/entryType
dom-performanceentry-duration:API/PerformanceEntry/duration
dom-performanceentry-tojson:API/PerformanceEntry/toJSON
dom-performanceobserver-performanceobserver:API/PerformanceObserver/PerformanceObserver
dom-performanceobserver-observe:API/PerformanceObserver/observe
dom-performanceobserver-disconnect:API/PerformanceObserver/disconnect
dom-performanceobserver-takerecords:API/PerformanceObserver/takeRecords
	dom-performanceobserver-supportedentrytypes:API/PerformanceObserver/supportedEntryTypes
dom-performanceobserverentrylist-getentries:API/PerformanceEntryList/getEntries
dom-performanceobserverentrylist-getentriesbyname:API/PerformanceEntryList/getEntriesByName
dom-performanceobserverentrylist-getentriesbytype:API/PerformanceEntryList/getEntriesByType

●●link_map

Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default
SameObject:~WEBIDLjs#SameObject

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.InvalidModificationError:~WEBIDL#invalidmodificationerror

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:#dom-performanceentry
I.PerformanceEntryList:#dom-performanceentrylist
I.PerformanceObserver:#dom-performanceobserver
I.PerformanceObserverCallback:#dom-performanceobservercallback
I.PerformanceObserverEntryList:#dom-performanceobserverentrylist
I.PerformanceObserverInit:#dom-performanceobserverinit

DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
sequence:~WEBIDL#idl-sequence
FrozenArray:~WEBIDL#idl-frozen-array
I.FrozenArray:~WEBIDL#idl-frozen-array

constructor:#dom-performanceobserver-performanceobserver
m.PerformanceObserver:#dom-performanceobserver-performanceobserver

m.name:#dom-performanceentry-name
m.startTime:#dom-performanceentry-starttime
m.entryType:#dom-performanceentry-entrytype
m.duration:#dom-performanceentry-duration
m.toJSON:#dom-performanceentry-tojson

m.getEntries:#dom-performance-getentries
m.getEntriesByName:#dom-performance-getentriesbyname
m.getEntriesByType:#dom-performance-getentriesbytype

mO.getEntries:#dom-performanceobserverentrylist-getentries
mO.getEntriesByName:#dom-performanceobserverentrylist-getentriesbyname
mO.getEntriesByType:#dom-performanceobserverentrylist-getentriesbytype

m.observe:#dom-performanceobserver-observe
m.disconnect:#dom-performanceobserver-disconnect
m.takeRecords:#dom-performanceobserver-takerecords
m.supportedEntryTypes:#dom-performanceobserver-supportedentrytypes

d.entryTypes:#dom-performanceobserverinit-entrytypes
d.type:#dom-performanceobserverinit-type
d.buffered:#dom-performanceobserverinit-buffered

	m.PerformanceObserverInit.entryTypes:#dom-performanceobserverinit-entrytypes

~buffer~mapを名前と型で絞込む:#dfn-filter-buffer-map-by-name-and-type
~bufferを名前と型で絞込む:#dfn-filter-buffer-by-name-and-type
処理能時列線:#dfn-performance-timeline
	Performance Timeline

pO.~buffer:#dfn-observer-buffer
pO.種別:#dfn-observer-type
pO.~callback:#_observer-callback
pO.~options~list:#dfn-options-list

処理能~entry~buffer~map:#dfn-performance-entry-buffer-map
処理能~entry~buffer:#dfn-performance-entry-buffer
最大~buffer~size:#dfn-maxbuffersize
時列線から可用？:#dfn-availablefromtimeline

処理能~entry~tupleを得る:#dfn-relevant-performance-entry-tuple

処理能~観測器~task~queue済み~flag:#dfn-performance-observer-task-queued-flag
処理能~entryを~queueする:#dfn-queue-a-performanceentry
処理能~観測器~taskを~queueする:#dfn-queue-the-performanceobserver-task
	登録する:#dfn-register-the-observer
登録-済み:#dfn-register-the-observer

処理能~観測器:#_performanceobserver-interface
処理能~観測器~list:#dfn-list-of-registered-performance-observer-objects
	（未利用）登録-済み処理能~観測器:#dfn-registered-performance-observer
処理能~時列線~task源:#_performance-timeline-task-source

~supportする~entry型たち:#dfn-frozen-array-of-supported-entry-types
処理能~entryを追加するに適格:#dfn-determine-eligibility-for-adding-a-performance-entry

~entry型:#_entry-type
~registry:~TETregistry#registry


	●用語（外部
~entryを追加するべきか？:~TETregistry#dfn-should-add-entry

~interface~obj:~WEBIDLjs#dfn-interface-object
辞書~member:~WEBIDL#dfn-dictionary-member
~callback this 値:~WEBIDLjs#dfn-callback-this-value
既定の~toJSON演算:~WEBIDLjs#default-tojson-operation
投出-:~WEBIDL#dfn-throw

例外を報告する:~WAPI#report-the-exception
~taskを~queueする:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
関連な大域~obj:~WAPI#concept-relevant-global
大域~obj:~WAPI#global-object
enV.大域~obj:~WAPI#concept-settings-object-global

~list:~INFRA#list
集合:~INFRA#ordered-set
付加する:~INFRA#list-append
~cloneする:~INFRA#list-clone
~map:~INFRA#ordered-map
値~listを取得する:~INFRA#map-getting-the-values
map.値:~INFRA#map-value
map.~key:~INFRA#map-key
	[]:~INFRA#map-get
構造体:~INFRA#struct
拡張する:~INFRA#list-extend

●●words_table1
TETregistry:timing-entrytypes-registry-ja.html
	https://w3c.github.io/timing-entrytypes-registry/

●●words_table

	●peroformance
時列線:timeline::~::タイムライン
処理能時列線:Performance Timeline::~::パフォーマンスタイムライン
観測器:observer::~::オブザーバ

時間:time::~
時系列順:chronological order::~
時刻:time::~

disconnect:
計時:timing::~
計測:measure::~
計量:metric::~

分解能:resolution::~
測定-:instrument::~
	interested:
一個:single:~
複数個:multiple:~

	●処理
toJSON:
overhead::::オーバーヘッド
	登録-済み:registered
遊休中:idle 中:~
	during idle periods
低優先度の:low priority:~
監視:monitoring:~
全存続期間:full lifecycle::~
絞込む:filterする::絞り込む
絞込み:filtering::絞り込み
	~filter:取り除いた

	●仕様
別法:alternative:~
特性:characteristics:~
適格:eligible:~
警告:warning:~
保つ:keepする:~
排せる:eliminateできる:~

	-:discouraged
	足りる:suffice
	polling
	調べる:poll する
	関心ある:interested in
	この仕様の~level 2:Performance Timeline Level 2
	選ぶ:choose
	に関する:regarding

	●未分類
	~NEQ:does not match
申込む:subscribeする:申し込む
申込んで:subscribeして:申し込んで
繰返して:repeatして:繰り返して
積重なる:stackされる:積み重なる
alphabet-:alphabetical:::アルファベット
消費器:consumer:~
解析:analytics:~
高-:high-:~
競争:race condition:~

	~queue済み:queued
	~member:parameter
	~clone:copy
	run
	subscription
	-:with respect to
	-:check
	-:instruct
	-:assert
	-:emit
	-:modified
	-:update
	挙げ:listing
	-:obs
	-:currentOption
	~costがかかる:costly
	^en:deduplication
	^en:critical path:
	no longer
	together
	より速く:faster
	大量に:significant volume の
	-:between
	初回:first
	その上限個数まで:not unbounded

	%大域~obj:relevantGlobal
	%大域~obj:globalObject
	%新たな~entry:newEntry
	%通知-~list:notifyList

●●ref_normative

[dom]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik. W3C. 21 November 2019. W3C Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://tools.ietf.org/html/rfc8174
[WebIDL]
    Web IDL. Boris Zbarsky. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/

●●ref_informative

[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 15 July 2019. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[PERFORMANCE-TIMELINE]
    Performance Timeline. Jatinder Mann; Zhiheng Wang. W3C. 12 December 2013. W3C Recommendation. URL: https://www.w3.org/TR/performance-timeline/
[RESOURCE-TIMING-2]
    Resource Timing Level 2. Todd Reifsteck; Ilya Grigorik; Yoav Weiss; Arvind Jain; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 28 November 2019. W3C Working Draft. URL: https://www.w3.org/TR/resource-timing-2/
[USER-TIMING-2]
    User Timing Level 2. Ilya Grigorik. W3C. 26 February 2019. W3C Recommendation. URL: https://www.w3.org/TR/user-timing-2/
[WORKERS]
    Web Workers. Ian Hickson. W3C. 24 September 2015. W3C Working Draft. URL: https://www.w3.org/TR/workers/


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Performance Timeline Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/performance-timeline-2/
編集者草案
	https://w3c.github.io/performance-timeline/
テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/performance-timeline
編集
	<a href="mailto:igrigorik@gmail.com">Ilya Grigorik</a> (Google)
前任編集者
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until November 2014)
	Zhiheng Wang (Google) (Until July 2013)
Participate
	<a href="https://github.com/w3c/performance-timeline/">GitHub w3c/performance-timeline</a>
	<a href="https://github.com/w3c/performance-timeline/issues/">File a bug</a>
	<a href="https://github.com/w3c/performance-timeline/commits/gh-pages">Commit history</a>
	<a href="https://github.com/w3c/performance-timeline/pulls/">Pull requests</a>
Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>
発行者
	<a href="https://www.w3.org/webperf/">Web Performance</a> Working Group

</script>


</head>

<body>

<header>

	<hgroup>
<h1 id="title">処理能 時列線 — Performance Timeline Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、
High Resolution Time 仕様 `HR-TIME-2$r
を拡張して、より高-分解能な処理能~計量~dataを［
検索取得する／格納する
］~methodを供する。
◎
This specification extends the High Resolution Time specification [HR-TIME-2] by providing methods to store and retrieve high resolution performance metric data.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status">W3C 日本語訳 共通ページ</a>／冒頭の仕様メタデータに委譲。】
</p>

<p>
Performance Timeline Level 2 は、その最初の~versionである
`PERFORMANCE-TIMELINE$r を置換し，次を含む：
◎
Performance Timeline Level 2 replaces the first version of [PERFORMANCE-TIMELINE] and includes:
</p>

<ul>
	<li>
`HR-TIME-2$r に定義される `Performance$I ~interfaceを拡張する。
◎
Extends the base definition of the Performance interface defined by [HR-TIME-2];
</li>
	<li>
Web Workers `WORKERS$r に
`PerformanceEntry$I を公開する。
◎
Exposes PerformanceEntry in Web Workers [WORKERS];
</li>
	<li>
`PerformanceObserver$I 用の~supportを追加する。
◎
Adds support for performance observers.
</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~appの処理能~特性を正確aに計測することは、~web~appを より速くするための重要な側面である。
この仕様は、~web開発者が，
~web~appの全存続期間にわたる様々な処理能~計量［
に~accessする ／ を測定する ／ を検索取得する
］ことを可能化するために必要とされる
`処理能時列線$の~primitiveを定義する。
◎
Accurately measuring performance characteristics of web applications is an important aspect of making web applications faster. This specification defines the necessary Performance Timeline primitives that enable web developers to access, instrument, and retrieve various performance metrics from the full lifecycle of a web application.
</p>

<p>
［
`NAVIGATION-TIMING-2$r ／ `RESOURCE-TIMING-2$r ／ `USER-TIMING-2$r
］は、順に［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する計時~情報を定義する仕様の例である。
これらは、他の処理能~interfaceと伴に，~web~appの`処理能時列線$を述べる処理能の計量を定義する。
例えば，次の~scriptは、開発者が［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する処理能~計量を得るために
`処理能時列線$に~accessする方法を示すものである：
◎
[NAVIGATION-TIMING-2], [RESOURCE-TIMING-2], and [USER-TIMING-2] are examples of specifications that define timing information related to the navigation of the document, resources on the page, and developer scripts, respectively. Together these and other performance interfaces define performance metrics that describe the Performance Timeline of a web application. For example, the following script shows how a developer can access the Performance Timeline to obtain performance metrics related to the navigation of the document, resources on the page, and developer scripts:
</p>

<div class="example">

<pre class="lang-html">
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body onload="init()"&gt;
&lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
&lt;script&gt;

function init()
{
  /* <span class="comment">
`USER-TIMING-2$r を見よ
◎
see [[USER-TIMING-2]]
</span> */
  performance.mark("startWork");
  doWork(); /* <span class="comment">
何らかの開発者~code
◎
Some developer code
</span> */
  performance.mark("endWork");
  measurePerf();
}

function measurePerf() {
  performance
    .getEntries()
    .map(%entry =&gt; JSON.stringify(%entry, null, 2))
    .forEach(%json =&gt; console.log(%json));
}

&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;
</pre>

</div>

<p>
別法として，開発者は、`処理能時列線$を観測して，新たな処理能~計量が記録される度に
`PerformanceObserver$I ~interfaceを介して通知させられる
— 加えて，任意選択で、指定した`~entry型$の，それまでに~bufferされた処理能~計量も通知させられる。
◎
Alternatively, the developer can observe the Performance Timeline and be notified of new performance metrics and, optionally, previously buffered performance metrics of specified type, via the PerformanceObserver interface:
</p>

<p>
`PerformanceObserver$I ~interfaceは、この仕様の~level 2 にて追加された。
それは、最初の例に示した~bufferに基づく~approachにおける制限に取組むように設計されている。
`PerformanceObserver$I ~interfaceを利用すれば、~appは：
◎
The PerformanceObserver interface was added in Performance Timeline Level 2 and is designed to address limitations of the buffer-based approach shown in the first example. By using the PerformanceObserver interface, the application can:
</p>

<ul>
	<li>
時列線を調べ続ける（ `polling^en ）ことなく，新たな計量を検出できる。
◎
Avoid polling the timeline to detect new metrics
</li>
	<li>
~costがかかる~~重複排除~logic（ `deduplication^en ）なしに，新たな計量を識別できる。
◎
Eliminate costly deduplication logic to identify new metrics
</li>
	<li>
~bufferを操作しようと求める他の消費器との競争を排せる。
◎
Eliminate race conditions with other consumers that may want to manipulate the buffer
</li>
</ul>

<p>
開発者には、アリな所では `PerformanceObserver$I を利用することが奨励される。
更には、新たな処理能~APIの計量は，
`PerformanceObserver$I ~interfaceを通す以外に可用にならないこともある。
観測器は、構築子に~callbackを指定して，関心のある処理能~entryを
`observe()$m ~methodを介して指定することにより働く。
~callbackをいつ実行するかは、~UAが選ぶ
— それは、~queueされた処理能~entryたちを受取る。
◎
The developer is encouraged to use PerformanceObserver where possible. Further, new performance API's and metrics may only be available through the PerformanceObserver interface. The observer works by specifying a callback in the constructor and specifying the performance entries it's interested in via the observe() method. The user agent chooses when to execute the callback, which receives performance entries that have been queued.
</p>

<p>
`PerformanceObserver$I ~interfaceの利用に際し、初期~page読込nに関する特別な考慮点がある：
登録が~eventを受取るためには，作動中でなければならないが、登録~scriptは［
その時点で可用でないか， `critical path^en 内には欲されない
］こともあろう。
これに取組むため、~UAは，~pageが構築されている間 ある個数までの~eventを~bufferする
— ~bufferされたこれらの~eventは、観測器を登録するときに `buffered$d ~flagを介して~accessできる。
この~flagが ~T にされた場合、~UAは，指定された`~entry型$用に~bufferされた~eventを検索取得して配送し、それらを `observe()$m ~callが生じた後の初回の~callbackに送達する。
◎
There are special considerations regarding initial page load when using the PerformanceObserver interface: a registration must be active to receive events but the registration script may not be available or may not be desired in the critical path. To address this, user agents buffer some number of events while the page is being constructed, and these buffered events can be accessed via the buffered flag when registering the observer. When this flag is set, the user agent retrieves and dispatches events that it has buffered, for the specified entry type, and delivers them in the first callback after the observe() call occurs.
</p>

<p class="note">注記：
~bufferされる~eventの個数の上限は、当の計量を定義する仕様により決定される。
~buffer法は、その上限個数までの~eventに限り利用されるものと意図され，継続的でもない。
◎
The number of buffered events is determined by the specification that defines the metric and buffering is intended to used for first-N events only; buffering is not unbounded or continuous.
</p>

<div class="example">

<pre class="lang-html">
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
&lt;script&gt;

/* <span class="comment">
利用したい`~entry型$は~supportされているかどうかを知る関数
◎
Know when the entry types we would like to use are not supported.
</span> */
function detectSupport(%entryTypes) {
  for (const %entryType of %entryTypes) {
    if (!PerformanceObserver.supportedEntryTypes.includes(%entryType)) {
      /* <span class="comment">
%entryType は~supportされていないことを~client側~解析に指示する。
◎
Indicate to client-side analytics that entryType is not supported.
</span> */
    }
  }
}
detectSupport(["resource", "mark", "measure"]);
const %userTimingObserver = new PerformanceObserver(%list => {
  %list
    .getEntries()
    /* <span class="comment">
挿入された値を取得する
◎
Get the values we are interested in
</span> */
    .map(({ %name, %entryType, %startTime, %duration }) => {
      const %obj = {
        "Duration": %duration,
        "Entry Type": %entryType,
        "Name": %name,
        "Start Time": %startTime,
      };
      return JSON.stringify(%obj, null, 2);
    })
    /* <span class="comment">
それらを~consoleに表示する
◎
Display them to the console.
</span> */
    .forEach(console.log);

    /* <span class="comment">
~eventを処理したなら~disconnectする
◎
Disconnect after processing the events.
</span> */
  %userTimingObserver.disconnect();
});
/* <span class="comment">
User-Timing 用に新たな~eventを申込む
◎
Subscribe to new events for User-Timing.
</span> */
%userTimingObserver.observe({entryTypes: ["mark", "measure"]});
const %resourceObserver = new PerformanceObserver(list =&gt; {
  list
    .getEntries()
    /* <span class="comment">
関心ある値を取得する
◎
Get the values we are interested in
</span> */
    .map(({ name, startTime, fetchStart, responseStart, responseEnd }) =&gt; {
      const %obj = {
        "Name": name,
        "Start Time": startTime,
        "Fetch Start": fetchStart,
        "Response Start": responseStart,
        "Response End": responseEnd,
      };
      return JSON.stringify(%obj, null, 2);
    })
    /* <span class="comment">
それらを~consoleに表示する
◎
Display them to the console.
</span> */
    .forEach(console.log);
  /* <span class="comment">
~eventを処理したなら~disconnectする
◎
Disconnect after processing the events.
</span> */
  %resourceObserver.disconnect();
});
/* <span class="comment">
Resource Timing 用に~buffer済みの~eventを検索取得するとともに，それ用に新たな~eventも申込む
◎
Retrieve buffered events and subscribe to newer events for Resource Timing.
</span> */
%resourceObserver.observe({type: "resource", buffered: true});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>
	<section id="performance-timeline">
<h2 title="Performance Timeline" id="dfn-performance-timeline">3. 処理能時列線</h2>

<p>
各 `大域~obj$には、次のものが結付けられる：
◎
Each global object has:
</p>

<dl class="def-list">
	<dt>`処理能~観測器~task~queue済み~flag@</dt>
	<dd>
真偽値。
【初期~時は ~F 】
◎
a performance observer task queued flag
</dd>

	<dt>`処理能~観測器~list@</dt>
	<dd>
`処理能~観測器$からなる~list【実質的には`集合$】。
初期~時は空とする。
◎
a list of registered performance observer objects that is initially empty
</dd>
	<dd>
`処理能~観測器$は、この~list内にあることを
`登録-済み@
であるともいう。
</dd>

	<dt>`処理能~entry~buffer~map@</dt>
	<dd>
<p>
`~map$。
この~mapを成す各~entryの`~key$mapは、~bufferが所属する`~entry型$を表現する文字列を与える。
各~entryの`値$mapは、次のものからなる~tupleを与える：
◎
a performance entry buffer map map, keyed on a DOMString, representing the entry type to which the buffer belongs. The map's value is the following tuple:
</p>
		<ul>
			<li>
`処理能~entry~buffer@
⇒
`PerformanceEntry$I ~objたちを格納する。
初期~時は空とする。
◎
A performance entry buffer to store PerformanceEntry objects, that is initially empty.
</li>
			<li>
`最大~buffer~size@
⇒
整数をとり，この`~entry型$用の`~registry$値に初期化される。
◎
An integer maxBufferSize, initialized to the registry value for this entry type.
</li>
			<li>
`時列線から可用？@
⇒
真偽値をとり，この`~entry型$用の`~registry$値に初期化される。
◎
A boolean availableFromTimeline, initialized to the registry value for this entry type.
</li>
		</ul>
	</dd>
</dl>

<div class="algorithm">
<p>
`処理能~entry~tupleを得る@
ときは、所与の
( %~entry型, %大域~obj )
に対し，次を返す
⇒
%大域~obj の`処理能~entry~buffer~map$[ %~entry型 ]
◎
In order to get the relevant performance entry tuple, given entryType and globalObject as input, run the following steps:
• Let map be the performance entry buffer map associated with globalObject.
• Return the result of getting the value of an entry from map, given entryType as the key.
</p>
</div>

		<section id="extensions-to-the-performance-interface">
<h3 title="Extensions to the Performance interface">3.1. `Performance^I ~interfaceに対する拡張</h3>

<p>
この節では、［
処理能に関係する各種~属性, および［
`処理能時列線$からの処理能~計量~dataを検索取得する
］ために利用される 各種~method
］を~hostするように，
`HR-TIME-2$r の `Performance$I ~interfaceを拡張する。
◎
This extends the Performance interface [HR-TIME-2] and hosts performance related attributes and methods used to retrieve the performance metric data from the Performance Timeline.
</p>

<pre class="idl">
partial interface `Performance$I {
    `PerformanceEntryList$I `getEntries$m();
    `PerformanceEntryList$I `getEntriesByType$m(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$m(`DOMString$ %name, optional `DOMString$ %type);
};

typedef `sequence$&lt;`PerformanceEntry$I&gt; `PerformanceEntryList$I;
</pre>

<p>
`PerformanceEntryList@I
は、 `PerformanceEntry$I の連列を表現する
— それは、開発者に~JS配列~用の便利~methodすべてを供する。
◎
The PerformanceEntryList represents a sequence of PerformanceEntry, providing developers with all the convenience methods found on JavaScript arrays.
</p>

<dl class="idl-def">
	<dt id="getentries-method">`getEntries()@m</dt>
	<dd>
被呼出時には、次の結果【を表現する新たな `PerformanceEntryList$I ~obj】を返すモノトスル
⇒
`~buffer~mapを名前と型で絞込む$( 此れ, ~NULL, ~NULL )
◎
3.1.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by the filter buffer map by name and type algorithm with name and type set to null.
</dd>

	<dt id="getentriesbytype-method">`getEntriesByType(type)@m</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~buffer~mapを名前と型で絞込む$( 此れ, ~NULL, %type )
◎
3.1.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by filter buffer map by name and type algorithm with name set to null, and type set to the method's input type parameter.
</dd>

	<dt id="getentriesbyname-method">`getEntriesByName(name, type)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
%type ~EQ ε
］
⇒
%type ~SET ~NULL
</li>
			<li>
~RET `~buffer~mapを名前と型で絞込む$( 此れ, %name, %type )
</li>
		</ol>
◎
3.1.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by filter buffer map by name and type algorithm with name set to the method input name parameter, and type set to null if optional entryType is omitted, or set to the method's input type parameter otherwise.
</dd>
</dl>

		</section>
	</section>
	<section id="the-performanceentry-interface">
<h2 title="The PerformanceEntry interface">4. `PerformanceEntry^I ~interface</h2>

<p>
`PerformanceEntry$I
~interfaceは、様々な計量による処理能~dataを~hostする。
◎
The PerformanceEntry interface hosts the performance data of various metrics.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceEntry@I {
    readonly attribute `DOMString$           `name$m;
    readonly attribute `DOMString$           `entryType$m;
    readonly attribute `DOMHighResTimeStamp$I `startTime$m;
    readonly attribute `DOMHighResTimeStamp$I `duration$m;
    [`Default$] `object$ `toJSON$m();
};
</pre>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、此れの識別子を返すモノトスル。
この識別子は、一意になる必要はない。
◎
This attribute MUST return an identifier for this PerformanceEntry object. This identifier does not have to be unique.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、此れが表現する~interfaceの型【に対応する`~entry型$を識別する文字列】を返すモノトスル。
◎
This attribute MUST return the type of the interface represented by this PerformanceEntry object.
</dd>
	<dd class="trans-note">【
`PerformanceEntry$I 自身は、他から継承される基底~interfaceとして~serveする（~instance化されない）。
継承している各~interfaceごとに，対応する
`~entry型@
が登録される（次の注記）。
】</dd>
	<dd class="note">注記：
すべての `entryType$m 値は、関連な`~registry$にて定義される。
例えば
⇒＃
`mark^l, `measure^l `USER-TIMING-2$r ／
`navigation^l `NAVIGATION-TIMING-2$r ／
`resource^l `RESOURCE-TIMING-2$r
…
◎
Note
◎
All entryType values are defined in the relevantregistry. Examples include: "mark" and "measure" [USER-TIMING-2], "navigation" [NAVIGATION-TIMING-2], "resource" [RESOURCE-TIMING-2], and "longtask".
</dd>

	<dt>`startTime@m</dt>
	<dd>
取得子は、［
此れの処理能~計量にて最初に記録された時刻印
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
◎
This attribute MUST return the time value of the first recorded timestamp of this performance metric.＼
</dd>
	<dd>
処理能~計量に開始-時刻の概念は適用されない場合、
0 を返すことにしてもヨイ。
◎
If the startTime concept doesn't apply, a performance metric may choose to return a startTime of 0.
</dd>

	<dt id="attributes">`duration@m</dt>
	<dd>
取得子は、［
此れに記録される~event全体の所要時間
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
◎
This attribute MUST return the time value of the duration of the entire event being recorded by this PerformanceEntry.＼
</dd>
	<dd>
これは概して，此れに［
最初に記録された時刻印
］から［
最後に記録された時刻印
］までの時間~差になる。
処理能~計量に所要時間の概念が適用されない場合、
0 を返すことにしてもヨイ。
◎
Typically, this would be the time difference between the last recorded timestamp and the first recorded timestamp of this PerformanceEntry. If the duration concept doesn't apply, a performance metric may choose to return a duration of 0.
</dd>

	<dt>`toJSON()@m</dt>
	<dd>
~call時には、 `WebIDL$r による`既定の~toJSON演算$を走らす。
◎
When toJSON is called, run [WebIDL]'s default toJSON operation.
</dd>
</dl>

	</section>
	<section id="the-performanceobserver-interface">
<h2 title="The PerformanceObserver interface">5. `PerformanceObserver^I ~interface</h2>

<p>
`PerformanceObserver$I ~interfaceを利用すれば、`処理能時列線$を観測して，新たな処理能~計量（ `PerformanceEntry$I ~obj）が記録される度に通知させられる
— 加えて、任意選択で，~bufferされた処理能~計量も通知させられる。
◎
The PerformanceObserver interface can be used to observe the Performance Timeline to be notified of new performance metrics as they are recorded, and optionally buffered performance metrics.
</p>

<p>
`PerformanceObserver$I ~objは、単に
`処理能~観測器@
とも称される。
各 `処理能~観測器$には、次のものが結付けられる：
◎
Each PerformanceObserver has these associated concepts:
</p>

<dl>
	<dt>`~callback@pO</dt>
	<dd>
作成-時に設定される，
`PerformanceObserverCallback$I ~callback。
◎
A PerformanceObserverCallback set on creation.
</dd>

	<dt>`~buffer@pO</dt>
	<dd>
`PerformanceEntryList$I ~obj。
この~objが表現する連列は、初期~時は空とする。
◎
A PerformanceEntryList object called the observer buffer that is initially empty.
</dd>

	<dt>`種別@pO</dt>
	<dd>
次のいずれか
⇒
`未定義^i ／ `一個^i ／ `複数個^i
◎
↓</dd>
	<dd>
初期~時は `未定義^i とする
【`登録-済み$になった時点で、他の値に更新される】
◎
A DOMString observer type which is initially "undefined".
</dd>

	<dt>`~options~list@pO</dt>
	<dd>
0 個以上の `PerformanceObserverInit$I 辞書からなる~list, または ε （なし）。
初期~時は ε とする。
`登録-済み$である間は非 ε になる。
◎
↓↓</dd>
	<dd class="trans-note">【
原文では、
“登録-済み処理能~観測器”
という別個の構造体を定義して，それに
— `処理能~観測器$への参照とともに —
`~options~list$pOを保たせているが、この構造体は，実質的に［
処理能~観測器は`処理能~観測器~list$内に含まれるかどうか
］の区別を表現するだけに過ぎず，無為に冗長なので、この訳では単純~化している。
】</dd>
</dl>

<div >

<p class="idl-def">
`PerformanceObserver(callback)@m
構築子の被呼出時には、次を走らすモノトスル：
</p>

<ol ><li>%観測器 ~LET 新たな `PerformanceObserver$I ~obj
</li><li>%観測器 の`~callback$pO ~SET %callback
</li><li>~RET %観測器
</li></ol>

◎
The PerformanceObserver(callback) constructor must create a new PerformanceObserver object with PerformanceObserverCallback set to callback and then return it.
◎
↑↑A registered performance observer is a struct consisting of an observer member (a PerformanceObserver object) and an options list member (a list of PerformanceObserverInit dictionaries).
</div>

<pre class="idl">
callback `PerformanceObserverCallback@I = void (
    `PerformanceObserverEntryList$I %entries,
    `PerformanceObserver$I %observer
);

[`Exposed$=(Window,Worker)]
interface `PerformanceObserver@I {
    `constructor$(`PerformanceObserverCallback$I %callback);
    void `observe$m(optional `PerformanceObserverInit$I %options = {});
    void `disconnect$m();
    `PerformanceEntryList$I `takeRecords$m();
    [`SameObject$] static readonly attribute `FrozenArray$&lt;`DOMString$&gt; `supportedEntryTypes$m;
};
</pre>

<p class="note">注記：
処理能~overheadを最小に保つためには、~appは，関心ある~event型【`~entry型$】のみを申込んで、処理能~dataを観測する必要がなくなったなら，観測器を
`disconnect()$m するべきである。
名前（ `name$m ）による絞込みは~supportされない
— それは，暗黙的にすべての~event型を申込むことになり、アリではあるが，大量の~eventを生成することになるので。
<!-- discouraged -->
◎
Note
◎
To keep the performance overhead to minimum the application ought to only subscribe to event types that it is interested in, and disconnect the observer once it no longer needs to observe the performance data. Filtering by name is not supported, as it would implicitly require a subscription for all event types — this is possible, but discouraged, as it will generate a significant volume of events.
</p>

		<section id="observe-method">
<h3 title="observe() method">5.1. `observe(options)@m ~method</h3>

<p id="dfn-register-the-observer">
この~methodは、此れが`登録-済み$であれば 此れを更新し，そうでなければ此れを`登録-済み$にする。
◎
The observe() method instructs the user agent to register the observer and＼
</p>

<p class="idl-def">
被呼出時には、次を走らすモノトスル：
◎
must run these steps:
• Let observer be the context object.
• Let relevantGlobal be observer's relevant global object.
</p>

<ol>
	<li>
%型たち ~LET %options[ "`entryTypes$d" ]
◎
↓</li>
	<li>
%型 ~LET %options[ "`type$d" ]
◎
↓</li>
	<li>
~IF［
%型たち ~EQ ε 
］~AND［
%型 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If options's entryTypes and type members are both omitted, then throw a TypeError.
</li>
	<li>
~IF［
%型たち ~NEQ ε
］~AND［
%options に `entryTypes$d 以外の~memberは在る
］
⇒
~THROW `TypeError$E
◎
If options's entryTypes is present and any other member is also present, then throw a TypeError.
</li>
	<li>
<p>
此れの`種別$pOに応じて：
◎
Update or check observer's observer type by running these steps:
</p>
		<dl class="switch">
			<dt>
`未定義^i
◎
If observer's observer type is "undefined":
</dt>
			<dd>
此れの`種別$pO ~SET ［
%型たち ~NEQ ε ならば `複数個^i ／
~ELSE_ `一個^i
］
◎
If options's entryTypes member is present, then set observer's observer type to "multiple".
◎
If options's type member is present, then set observer's observer type to "single".
</dd>

			<dt>`一個^i</dt>
			<dd>
~IF［
%型たち ~NEQ ε
］
⇒
~THROW `InvalidModificationError$E
◎
If observer's observer type is "single" and options's entryTypes member is present, then throw an InvalidModificationError.
</dd>

			<dt>`複数個^i</dt>
			<dd>
~IF［
%型 ~NEQ ε
］
⇒
~THROW `InvalidModificationError$E
◎
If observer's observer type is "multiple" and options's type member is present, then throw an InvalidModificationError.
</dd>
		</dl>
	</li>
	<li>
%大域~obj ~LET 此れに`関連な大域~obj$
◎
↑↑</li>
	<li>
%観測器~list ~LET %大域~obj の`処理能~観測器~list$
◎
↓</li>
	<li>
%~supportする~entry型たち ~LET %大域~obj が`~supportする~entry型たち$
◎
↓</li>
	<li>
<p>
~IF［
此れの`種別$pO ~EQ `複数個^i
］：
◎
If observer's observer type is "multiple", run the following steps:
• Let entry types be options's entryTypes sequence.
</p>
		<ol>
			<li>
%型たち から［
%~supportする~entry型たち に含まれない`~entry型$
］をすべて除去する
⇒
~UAは、除去された型があれば，開発者に通知するベキである
— 例えば、~console警告にそれらを挙げるのが適切になるであろう。
◎
Remove all types from entry types that are not contained in relevantGlobal's frozen array of supported entry types. The user agent SHOULD notify developers if entry types is modified. For example, a console warning listing removed types might be appropriate.
</li>
			<li>
~IF［
%型たち は空である
］
⇒
~RET
⇒
~UAは、登録は中止されたことを開発者に通知するベキである
— 例えば，~console警告が適切になるであろう。
◎
If the resulting entry types sequence is an empty sequence, abort these steps. The user agent SHOULD notify developers when the steps are aborted to notify that registration has been aborted. For example, a console warning might be appropriate.
</li>
			<li>
~IF［
此れ ~NIN %観測器~list
］
⇒
此れを %観測器~list に付加する
◎
↓</li>
			<li>
此れの`~options~list$pO ~SET %options のみからなる~list
◎
If the list of registered performance observer objects of relevantGlobal contains a registered performance observer whose observer is the context object, replace its options list with a list containing options as its only item.
◎
Otherwise, create and append a registered performance observer object to the list of registered performance observer objects of relevantGlobal, with observer set to the context object and options list set to a list containing options as its only item.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ 此れの`種別$pO ~EQ `一個^i ）：
◎
Otherwise, run the following steps:
• Assert that observer's observer type is "single".
</p>
		<ol>
			<li>
~IF［
%型 ~NIN %~supportする~entry型たち
］
⇒
~RET
⇒
~UAは、これが起きたことを開発者に通知するベキである
— 例えば，~console警告を介して。
◎
If options's type is not contained in the relevantGlobal's frozen array of supported entry types, abort these steps. The user agent SHOULD notify developers when this happens, for instance via a console warning.
</li>
			<li>
<p>
~IF［
此れ ~IN %観測器~list
］：
◎
If the list of registered performance observer objects of relevantGlobal contains a registered performance observer obs whose observer is the context object:
</p>
				<ol>
					<li>
~IF［
此れの`~options~list$pO内の ある~itemの `type$d ~EQ %型
］
⇒
此れの`~options~list$pO内の その~itemを %options に置換する
◎
If obs's options list contains a PerformanceObserverInit item currentOptions whose type is equal to options's type, replace currentOptions with options in obs's options list.
</li>
					<li>
~ELSE
⇒
%options を此れの`~options~list$pOに付加する
◎
Otherwise, append options to obs's options list.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
此れを %観測器~list に付加する；
此れの`~options~list$pO ~SET %options のみからなる~list
◎
Otherwise, create and append a registered performance observer object to the list of registered performance observer objects of relevantGlobal, with observer set to the context object and options list set to a list containing options as its only item.
</li>
			<li>
<p>
~IF［
%options の `buffered$d ~EQ ~T
］：
◎
If options's buffered flag is set:
</p>
				<ol>
					<li>
%~tuple ~LET `処理能~entry~tupleを得る$( %型, %大域~obj )
◎
Let tuple be the relevant performance entry tuple of options's type and relevantGlobal.
</li>
					<li>
%~tuple の`処理能~entry~buffer$を成す
~EACH( %~entry )
に対し
⇒
~IF［
`~entryを追加するべきか？$( %~entry, %options ) ~EQ ~T
］
⇒
此れの`~buffer$pOに %~entry を`付加する$
◎
For each entry in tuple's performance entry buffer:
• If should add entry with entry and options as parameters returns true, append entry to the observer buffer.
</li>
					<li>
`処理能~観測器~taskを~queueする$( %大域~obj )
◎
Queue the PerformanceObserver task with relevantGlobal as input.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>注記：
同じ `PerformanceObserver$I ~obj上で `observe(options)$m を~callするときは、
%options の［
`entryTypes$d, `type$d
］のうち，~~一貫して片方のみを利用する必要がある
— 例えば `observe()$m を `entryTypes$d を与えて~callしてから，
`type$d を与えて また~callした場合、例外が投出される。
これには、~callがどう積重なるかについて混同を避けることが意味されている：
◎
A PerformanceObserver object needs to always call observe() with options's entryTypes set OR always call observe() with options's type set. If one PerformanceObserver calls observe() with entryTypes and also calls observe with type, then an exception is thrown. This is meant to avoid confusion with how calls would stack.＼
</p>
<ul>
	<li>
`entryTypes$d を利用する下では【すなわち， `種別$pO ~EQ `複数個^i 】
⇒
`PerformanceObserverInit$I 内の他の~memberは利用できないことに加え、後方-互換性を得るため，複数回の `observe()$m ~callは 以前のそれを上書きすることになる
— この事例では一回の~callで足りるべきなので。
◎
When using entryTypes, no other parameters in PerformanceObserverInit can be used. In addition, multiple observe() calls will override for backwards compatibility and because a single call should suffice in this case.＼
</li>
	<li>
`type$d を利用する下では【すなわち， `種別$pO ~EQ `一個^i 】
⇒
1 回の~callは 1 個の`~entry型$のみ指定するので，各~callは積重なることになる。
この場合も、同じ `type$d を与えて `observe()$m を繰返して~callしたときは，上書きすることになる。
◎
On the other hand, when using type, calls will stack because a single call can only specify one type. Calling observe() with a repeated type will also override.
</li>
</ul>
</div>

			<section id="performanceobserverinit-dictionary">
<h4 title="PerformanceObserverInit dictionary">5.1.1. `PerformanceObserverInit^I 辞書</h4>

<pre class="idl">
dictionary `PerformanceObserverInit@I {
    `sequence$&lt;`DOMString$&gt; `entryTypes$d;
    DOMString `type$d;
    boolean `buffered$d;
};
</pre>

<dl class="idl-def">
	<dt>`entryTypes@d</dt>
	<dd>
観測されることになる一連の`~entry型$からなる~listを与える。
この~listが在る場合、空であってはナラナイ, かつ
他のすべての~memberも在ってはナラナイ。
~UAは、この~list内の型のうち，自身が認識しないものは無視するモノトスル。
◎
A list of entry types to be observed. If present, the list MUST NOT be empty and all other members MUST NOT be present. Types not recognized by the user agent MUST be ignored.
</dd>

	<dt>`type@d</dt>
	<dd>
観測されることになる単独の`~entry型$を与える。
~UAは、自身が認識しない型を無視するモノトスル。
◎
A single entry type to be observed. A type that is not recognized by the user agent MUST be ignored. Other members may be present.
</dd>

	<dt>`buffered@d</dt>
	<dd>
［
~bufferされた~entryは，観測器の~bufferに~queueされる
］べきかどうかを指示する~flag。
◎
A flag to indicate whether buffered entries should be queued into observer's buffer.
</dd>
</dl>

			</section>
			<section id="performanceobserverentrylist-interface">
<h4 title="PerformanceObserverEntryList interface">5.1.2. `PerformanceObserverEntryList^I ~interface</h4>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceObserverEntryList@I {
    `PerformanceEntryList$I `getEntries$mO();
    `PerformanceEntryList$I `getEntriesByType$mO(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$mO(`DOMString$ %name, optional `DOMString$ %type);
};
</pre>

<dl class="idl-def">
	<dt id="getentries-method-0">`getEntries()@mO</dt>
	<dd>
被呼出時には、次の結果【を表現する新たな `PerformanceEntryList$I ~obj】を返すモノトスル
⇒
`~bufferを名前と型で絞込む$( 此れが表現する`~buffer$pO, ~NULL, ~NULL )
◎
5.1.2.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by filter buffer by name and type algorithm with the context object's observer buffer, name and type set to null.
</dd>

	<dt id="getentriesbytype-method-0">`getEntriesByType(type)@mO</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを名前と型で絞込む$( 此れが表現する`~buffer$pO, ~NULL, %type )
◎
5.1.2.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by filter buffer by name and type algorithm with the context object's observer buffer, name set to null, and type set to the method's input type parameter.
</dd>

	<dt id="getentriesbyname-method-0">`getEntriesByName(name, type)@mO</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
</p>
		<ol>
			<li>
~IF［
%type ~EQ ε
］
⇒
%type ~SET ~NULL
</li>
			<li>
~RET `~bufferを名前と型で絞込む$( 此れが表現する`~buffer$pO, %name, %type )
</li>
		</ol>
◎
5.1.2.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by filter buffer by name and type algorithm with the context object's observer buffer, name set to the method input name parameter, and type set to null if optional entryType is omitted, or set to the method's input type parameter otherwise.
</dd>
</dl>

			</section>
		</section>
		<section id="takerecords-method">
<h3 title="takeRecords() method">5.2. `takeRecords()@m ~method</h3>

<div class="p">
<p class="idl-def">
被呼出時には、次を走らすモノトスル：
</p>

<ol>
	<li>
%複製 ~LET 此れの`~buffer$pOの複製
</li>
	<li>
此れの`~buffer$pOを空にする
</li>
	<li>
~RET %複製
</li>
</ol>

◎
The takeRecords() method must return a copy of the context object's observer buffer, and also empty context object's observer buffer.
</div>

		</section>
		<section id="disconnect-method">
<h3 title="disconnect() method">5.3. `disconnect()@m ~method</h3>

<p class="idl-def">
被呼出時には、次を走らすモノトスル：
◎
The disconnect() method must do the following:
</p>

<ol>
	<li>
此れに`関連な大域~obj$の`処理能~観測器~list$から，此れを除去する
◎
Remove the context object from the list of registered performance observer objects of relevant global object.
</li>
	<li>
此れの`~buffer$pOを空にする
◎
Empty the context object's observer buffer.
</li>
	<li>
此れの`~options~list$pO ~SET ε【！空にする】
◎
Empty the context object's options list.
</li>
</ol>

		</section>
		<section id="supportedentrytypes-attribute">
<h3>5.4. `supportedEntryTypes@m 属性</h3>

<p>
各 `大域~obj$には、
`~supportする~entry型たち@
が結付けられる。
それは、~alphabet-順序による一連の文字列からなるように初期化された `FrozenArray$I であり，［
当の大域~obj用に~supportするものとして`~registry$に含められた`~entry型$たち
］から作成される。
◎
Each global object has an associated frozen array of supported entry types, which is initialized to the FrozenArray created from the sequence of strings among the registry that are supported for the global object, in alphabetical order.
</p>

<p class="idl-def">
取得子は、次を返すモノトスル
⇒
【！`大域~obj$enV】
此れに`関連な大域~obj$が`~supportする~entry型たち$
◎
When supportedEntryTypes's attribute getter is called, run the following steps:
• Let globalObject be the environment settings object's global object.
• Return globalObject's frozen array of supported entry types.
</p>

<p class="note">注記：
この属性は、~UAがどの`~entry型$を~supportするか容易に知ることを，~web開発者に許容する。
◎
This attribute allows web developers to easily know which entry types are supported by the user agent.
</p>

		</section>
	</section>
	<section id="processing">
<h2 title="Processing">6. 処理</h2>

		<section id="queue-a-performanceentry">
<h3 title="Queue a PerformanceEntry">6.1. `PerformanceEntry^I を~queueする</h3>

<p>
`処理能~entryを~queueする@
ときは、所与の
( `PerformanceEntry$I ~obj %新たな~entry )
に対し，次を走らす：
◎
To queue a PerformanceEntry (newEntry), run these steps:
</p>

<ol>
	<li>
%~entry型 ~LET %新たな~entry の `entryType$m 値
◎
↓</li>
	<li>
%大域~obj ~LET %新たな~entry に`関連な大域~obj$
◎
↓</li>
	<li>
%大域~obj の`処理能~観測器~list$を成す
~EACH( `処理能~観測器$ %観測器 )
に対し
⇒
~IF［
%観測器 の`~options~list$pO内に ある `PerformanceObserverInit$I ~options %~options が在って，［
%~entry型 ~IN %~options の `entryTypes$d
］~OR［
%~entry型 ~EQ %~options の `type$d
］を満たす【該当する %~options は在っても 1 個に限られる（ `observe()$m を見よ）】
］
⇒
~IF［
`~entryを追加するべきか？$( %新たな~entry, %~options ) ~EQ ~T
］
⇒
%観測器 の`~buffer$pOに %新たな~entry を付加する
◎
Let interested observers be an initially empty set of PerformanceObserver objects.
◎
Let entryType be newEntry’s entryType value.
◎
For each registered performance observer (regObs):
• If regObs's options list contains a PerformanceObserverInit options whose entryTypes member includes entryType or whose type member equals to entryType:
•• If should add entry with newEntry and options returns true, append regObs's observer to interested observers.
◎
For each observer in interested observers:
• Append newEntry to observer's observer buffer.
</li>
	<li>
%~tuple ~LET `処理能~entry~tupleを得る$( %~entry型, %大域~obj )
◎
Let relevantGlobal be newEntry's relevant global object.
◎
Let tuple be the relevant performance entry tuple of entryType and relevantGlobal.
</li>
	<li>
~IF［
%~tuple は`処理能~entryを追加するに適格$である
］
⇒
%~tuple の`処理能~entry~buffer$に %新たな~entry を`付加する$
◎
Call the determine eligibility for adding a performance entry algorithm with tuple as input. If it returns true, append newEntry to tuple's performance entry buffer.
</li>
	<li>
`処理能~観測器~taskを~queueする$( %大域~obj )
◎
Queue the PerformanceObserver task with relevantGlobal as input.
</li>
</ol>

		</section>
		<section id="queue-the-performanceobserver-task">
<h3 title="Queue the PerformanceObserver task">6.2. 処理能~観測器~taskを~queueする</h3>

<p>
`処理能~観測器~taskを~queueする@
ときは、所与の
( %大域~obj )
に対し，次を走らす：
◎
When asked to queue the PerformanceObserver task, given relevantGlobal as input, run the following steps:
</p>

<ol>
	<li>
~IF［
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~EQ ~T
］
⇒
~RET
◎
If relevantGlobal's performance observer task queued flag is set, terminate these steps.
</li>
	<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~T
◎
Set relevantGlobal's performance observer task queued flag.
</li>
	<li>
<p>
`処理能~時列線~task源@
から，次の下位手続きを走らす`~taskを~queueする$：
◎
Queue a task that consists of running the following substeps. The task source for the queued task is the performance timeline task source.
</p>
		<ol>
			<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~F
◎
Unset performance observer task queued flag of relevantGlobal.
</li>
			<li>
%通知-~list ~LET %大域~obj の`処理能~観測器~list$を`~cloneする$
【~cloneするのは、後~段で~callされる~callbackによる~~影響を避けるため】
◎
Let notifyList be a copy of relevantGlobal's list of registered performance observer objects.
</li>
			<li>
<p>
%通知-~list を成す
~EACH( `処理能~観測器$ %観測器 )
に対し：
◎
For each PerformanceObserver object po in notifyList, run these steps:
</p>
				<ol>
					<li>
~IF［
%観測器 の`~buffer$pOは空である
］
⇒
~CONTINUE
◎
↓</li>
					<li>
%~entryたち ~LET %観測器 の`~buffer$pOの複製
◎
Let entries be a copy of po’s observer buffer.
</li>
					<li>
%観測器 の`~buffer$pOを空にする
◎
Empty po’s observer buffer.
</li>
					<li>
<p>
次を渡して %観測器 の`~callback$pOを~callする
⇒＃
引数~list « %~entryたち, %観測器 »,
`~callback this 値$ %観測器
</p>

<p>
この段にて例外が`投出-$された場合は、その`例外を報告する$。
</p>

◎
If entries is non-empty, call po’s callback with entries as first argument and po as the second argument and callback this value. If this throws an exception, report the exception.
</li>
				</ol>
			</li>
		</ol>

<p>
`処理能~時列線~task源$用の`~task~queue$は、低優先度の~queueである
— ~UAは、処理能~監視~codeの影響iを最小限にするため，アリなら遊休中に処理するべきである。
◎
The performance timeline task queue is a low priority queue that, if possible, should be processed by the user agent during idle periods to minimize impact of performance monitoring code.
</p>

	</li>
</ol>

		</section>
		<section id="filter-buffer-map-by-name-and-type">
<h3 title="Filter buffer map by name and type">6.3. ~buffer~mapを ( 名前, 型 ) で絞込む</h3>

<p>
`~buffer~mapを名前と型で絞込む@
ときは、所与の
( %~obj, %名前, %型 )
に対し，次を走らす：
◎
When asked to run the filter buffer map by name and type algorithm with optional name and type, run the following steps:
</p>

<ol>
	<li>
%結果 ~LET 新たな`~list$
◎
Let result be an initially empty list.
</li>
	<li>
%~map ~LET %~obj に`関連な大域~obj$の`処理能~entry~buffer~map$
◎
Let map be the performance entry buffer map associated with the relevant global object of context object.
</li>
	<li>
%~tuple~list ~LET %型 に応じて
⇒＃
~NULL ならば %~map の`値~listを取得する$ ／
~ELSE_ « %~map[ %型 ] »
◎
Let tuple list be an empty list.
◎
If type is not null, append the result of getting the value of entry on map given type as key to tuple list. Otherwise, assign the result of get the values on map to tuple list
</li>
	<li>
<p>
%~tuple~list を成す
~EACH( %~tuple )
に対し：
◎
For each tuple in tuple list, run the following steps:
</p>
		<ol>
			<li>
%~buffer ~LET %~tuple の`処理能~entry~buffer$
◎
Let buffer be tuple's performance entry buffer.
</li>
			<li>
~IF［
%~tuple の`時列線から可用？$ ~EQ ~F
］
⇒
~CONTINUE
◎
If tuple's availableFromTimeline is false, continue to the next tuple.
</li>
			<li>
%~entryたち ~LET `~bufferを名前と型で絞込む$( %~buffer, %名前, %型 )
◎
Let entries be the result of running filter buffer by name and type with buffer, name and type as inputs.
</li>
			<li>
%結果 を %~entryたち で`拡張する$
◎
For each entry in entries, append entry to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果 を各~entryの `startTime$m の時系列順に~sortした結果
【！＊~INFRA#list-sort-in-ascending-order】
◎
Sort results's entries in chronological order with respect to startTime
◎
Return result.
</li>
</ol>

		</section>
		<section id="filter-buffer-by-name-and-type">
<h3 title="Filter buffer by name and type">6.4. ~bufferを ( 名前, 型 ) で絞込む</h3>

<p>
`~bufferを名前と型で絞込む@
ときは、所与の
( %~buffer, %名前, %型 )
に対し，次を走らす：
◎
When asked to run the filter buffer by name and type algorithm, with buffer, name, and type as inputs, run the following steps:
</p>

<ol>
	<li>
%~list ~LET 新たな`~list$
◎
Let result be an initially empty list.
</li>
	<li>
<p>
%~buffer を成す
~EACH( `PerformanceEntry$I ~obj %~entry )
に対し：
◎
For each PerformanceEntry entry in buffer, run the following steps:
</p>
		<ol>
			<li>
~IF［
%型 ~NIN { ~NULL, %~entry の `entryType$m 属性~値 }
］
⇒
~CONTINUE
◎
If type is not null and if type does not match entry's entryType attribute in a case-sensitive manner, continue to next entry.
</li>
			<li>
~IF［
%名前 ~NIN { ~NULL, %~entry の `name$m 属性~値 )
］
⇒
~CONTINUE
◎
If name is not null and if name does not match entry's name attribute in a case-sensitive manner, continue to next entry.
</li>
			<li>
%~list に %~entry を`付加する$
◎
append entry to result.
</li>
		</ol>
	</li>
	<li>
~RET %~list を 各~entryの `startTime$m の時系列順に~sortした結果
【！＊~INFRA#list-sort-in-ascending-order】
◎
Sort results's entries in chronological order with respect to startTime
◎
Return result.
</li>
</ol>

		</section>
		<section id="eligibility-for-adding-a-performanceentry-to-a-buffer">
<h3 title="Eligibility for adding a PerformanceEntry to a buffer">6.5. ~bufferは `PerformanceEntry^I を追加するに適格か？</h3>

<p>
次を満たす %~tuple は、
`処理能~entryを追加するに適格@
であるとされる
⇒
%~tuple の`処理能~entry~buffer$の~size ~LT %~tuple の`最大~buffer~size$
◎
To determine eligibility for adding a performance entry, with required performance entry tuple, run the following steps:
• Let num current entries be the size of tuple's performance entry buffer.
• If num current entries is less than tuples's maxBufferSize, return true.
Return false.
</p>

		</section>
	</section>
	<section id="privacy-security">

<h3 title="Privacy and Security">7. ~privacyと~security</h3>

<p>
この仕様は、
`HR-TIME-2$r に定義された `Performance$I ~interfaceを拡張し，`処理能時列線$［
に~entryを~queueする／から~entryを検索取得する
］ための~methodを供する。
高-分解能な計時~情報を公開することによる［
~privacy／~security
］上の考慮点については、
`HR-TIME-2$r を~~参照されたし。
◎
This specification extends the Performance interface defined by [HR-TIME-2] and provides methods to queue and retrieve entries from the performance timeline. Please refer to [HR-TIME-2] for privacy and security considerations of exposing high-resoluting timing information.
</p>
	</section>
	<section id="dependencies">
<h2 title="Dependencies">8. 依存関係</h2>

<p class="trans-note">【
他の仕様に定義される用語（の一部）。
この節の和訳は、省略する。
】
◎
The [INFRA] specification defines the following: key, getting the value of an entry.
</p>

	</section>
	<section class="appendix">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に貢献された次の方々に：
</p>

<div lang="en-x-a0">
Thanks to Arvind Jain, Boris Zbarsky, Jatinder Mann, Nat Duca, Philippe Le Hegaret, Ryosuke Niwa, Shubhie Panicker, Todd Reifsteck, Yoav Weiss, and Zhiheng Wang, for their contributions to this work.
</div>

	</section>
</main></div>
