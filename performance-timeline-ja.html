<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Performance Timeline Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'm': // IDL member
case 'mO':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	text = '<span lang="en-x-a1">' + key + '</span>';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Performance Timeline Level 2
spec_date:2019-01-10
trans_update:2019-01-17
source_checked:170524
page_state_key:TIMING
original_url:https://w3c.github.io/performance-timeline/
spec_status:ED
ref_id_prefix:bib-
copyright:2019,permissive
trans_1st_pub:2015-07-27


●●class_map
E:error

●●tag_map
I:code
m:code
mO:code
d:code
c:code
E:code
v:var
V:var
b:b
i:i

●●original_id_map

dom-performanceobserver-performanceobserver:

	dom-performanceentrylist:idl-def-performanceentrylist
	dom-performanceobservercallback:idl-def-performanceobservercallback
	dom-performanceobserverentrylist:idl-def-performanceobserverentrylist
	dom-performanceobserverinit:idl-def-performanceobserverinit


●●link_map


Exposed:~WEBIDL#Exposed
Default:~WEBIDL#Default

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:#dom-performanceentry
I.PerformanceEntryList:#dom-performanceentrylist
I.PerformanceObserver:#dom-performanceobserver
I.PerformanceObserverCallback:#dom-performanceobservercallback
I.PerformanceObserverEntryList:#dom-performanceobserverentrylist
I.PerformanceObserverInit:#dom-performanceobserverinit

DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
sequence:~WEBIDL#idl-sequence
FrozenArray:~WEBIDL#idl-frozen-array
	Constructor:~WEBIDL#Constructor

Constructor:#dom-performanceobserver-performanceobserver
m.PerformanceObserver:#dom-performanceobserver-performanceobserver

m.name:#dom-performanceentry-name
m.startTime:#dom-performanceentry-starttime
m.entryType:#dom-performanceentry-entrytype
m.duration:#dom-performanceentry-duration
m.toJSON:#dom-performanceentry-tojson

m.getEntries:#dom-performance-getentries
m.getEntriesByName:#dom-performance-getentriesbyname
m.getEntriesByType:#dom-performance-getentriesbytype

mO.getEntries:#dom-performanceobserverentrylist-getentries
mO.getEntriesByName:#dom-performanceobserverentrylist-getentriesbyname
mO.getEntriesByType:#dom-performanceobserverentrylist-getentriesbytype

m.observe:#dom-performanceobserver-observe
m.disconnect:#dom-performanceobserver-disconnect
m.takeRecords:#dom-performanceobserver-takerecords
m.supportedEntryTypes:#dom-performanceobserver-supportedentrytypes



d.entryTypes:#dom-performanceobserverinit-entrytypes
d.type:#dom-performanceobserverinit-type
d.buffered:#dom-performanceobserverinit-buffered

	m.PerformanceObserverInit.entryTypes:#dom-performanceobserverinit-entrytypes

~bufferを絞込む:#filter-buffer-by-name-and-type
処理能時列線:#dfn-performance-timeline
	Performance Timeline
pO.~buffer:#dfn-observer-buffer
pO.種別:#dfn-observer-type
pO.~callback:#_observer-callback
pO.~options~list:#dfn-options-list

処理能~entry~buffer:#dfn-performance-entry-buffer
関連する処理能~entry~buffer:#dfn-relevant-performance-entry-buffer
処理能~観測器~task~queue済み~flag:#dfn-performance-observer-task-queued-flag
処理能~entryを~queueする:#dfn-queue-a-performanceentry
	登録する:#dfn-register-the-observer
登録-済み:#dfn-register-the-observer

処理能~観測器:#_performanceobserver-interface
処理能~観測器~list:#dfn-registered-performance-observer
	登録-済み処理能~観測器:#dfn-registered-performance-observer
処理能~時列線~task源:#_performance-timeline-task-source

~supportされる~entry種別たち:#dfn-supported-entry-types
処理能~entry種別を登録する:#dfn-register-a-performance-entry-type

~ES大域~環境:~WEBIDL#es-environment
~interface~obj:~WEBIDL#dfn-interface-object
辞書~member:~WEBIDL#dfn-dictionary-member
~callback this 値:~WEBIDL#dfn-callback-this-value
既定の~toJSON演算:~WEBIDL#default-tojson-operation
投出-:~WEBIDL#dfn-throw

例外を報告する:~WAPI#report-the-exception
~taskを~queueする:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
関連する大域~obj:~WAPI#concept-relevant-global
大域~obj:~WAPI#global-object

r.PAINT-TIMING:paint-timing-ja.html

●●words_table1


●●words_table



	●peroformance
時列線:timeline::~:タイムライン
処理能:performance::~:パフォーマンス
処理能時列線:Performance Timeline::~:パフォーマンスタイムライン
	処理能観測器:Performance Observer::~:パフォーマンスオブザーバ
観測器:observer::~:オブザーバ
観測-:observe::~:オブザーブ

時間:time::~
時刻印:timestamp::~
時系列順:chronological order::~
時刻:time::~
所要時間:duration::~

disconnect:
entry:::エントリ
host:::ホスト
event:::イベント
bottleneck:::ボトルネック
overhead:::オーバーヘッド
buffer:::バッファ
task:::タスク
flag:::フラグ
source:::ソース
源:source::~:ソース
options::option 集


登録-:register::~
	登録-済み:registered
登録:registration::~
直列化-:serialize::~:シリアル化
直列化子:serializer::~:シリアライザ
計時:timing::~
計測:measure::~
計量:metric::~
記録:record::~

正確0:accurate:正確
通知-:notify:~
延期-:delay:~
適時に:timely manner で::~
分解能:resolution::~
同期的:synchronous::~
報告-:report::~
報告:reporting::~
定期的:periodic::~
格納-:store:~
測定-:instrument::~
検索取得-:retrieve::~
全存続期間:full lifecycle::~
遊休中:idle 中:~
	during idle periods
低優先度の:low priority:~
監視:monitoring:~
	最小限に抑える-:minimize#1

絞込む:filter する::絞り込む
絞込み:filtering::絞り込み
	~filter:取り除いた

	interested:
queue::::キュー
	~queue済み:queued

高分解能の:high-resoluting:~

未定義:undefined:~
一個:single:~
複数個:multiple:~

	●IDL
callback:
call:
toJSON:
辞書:dictionary::~:デイクショナリ
連列:sequence::~:シーケンス
型:type:~
instance:::インスタンス
interface::::インタフェース
list:::リスト
map:
member:::メンバ
	~member:parameter
method:::メソッド
obj:object::オブジェクト
空:empty:~
在する:present する:在る
在して:present して:在って
大域:global::~:グローバル
環境:environment:~
属性:attribute::~
sort:::ソート
文書:document::~
新たな:new::~
文字列:string::~
名前:name::~
値:value::~
種別:type::~
	型:type:~
識別子:identifier::~
例外:exception::~
投出-:throw::~
構築子:constructor::~:コンストラクタ
被呼出時:被 invoke 時:~
呼出した:invoke した:呼び出した
取得-:get::~
取得子:getter::~
演算:operation::~
配列:array::~

	●
初期:initial:~
	initially
付加-:append::~
複製:copy::~
設定-:set::~
引数:argument::~
関数:function::~
積重なる:stack される:積み重なる
構造体:struct::~

	●仕様
	-:discouraged
UA:user agent:UA
algo:algorithm::アルゴリズム
access:::アクセス
	足並みを揃える:align with:
app:application::アプリ
support:::サポート
	~supportされない:unsupported:~
version:::バージョン
web::::ウェブ
approach:::アプローチ
仕様:spec:~
指定-:specify:~
保つ:keep する:~
妥当:valid:~
定義-:define:~
	予め定義された:predefined:::~
導入:introduce:~
手続き:steps:~
下位手続き:substeps:~
拡張-:extend:~
拡張:extension:~
供-:provide:~
暗黙的:implicit:~
最小限:minimum:~
概して:typical に:~
概念:concept:~
無視-:ignore:~
相違:difference:~
要求-:require:~
規則:rule:~
認識-:recognize:~
適用-:apply:~
避ける:avoid する:~
避けれ:avoid でき:~
重要:important:~
開発者:developer:~
関係-:relate:~
側面:aspect:~
別法:alternative:~
可用:available:~
アリ:possible:可能
可能化-:enable:~
	基づいて:based:~
情報:information:~
固守-:adhere:~
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
影響0:impact:影響
	なくす:eliminate
制限:limitations:~
取組む:address する:取り組む
設計:design:~
奨励-:encourage:~
考慮点:considerations:~
依存関係:dependencies:~
便利:convenience:~
警告:warning:~
適切:appropriate:~
保守-:maintain:~
拡充-:populate:~
容易:easy:~
	容易に:easily
許容-:allow:~
	知る:know
事例:case:~
後方互換性:backwards compatibility:~
混同:confusion:~
一意:unique:~
任意選択で:optional に:~
特性:characteristics:~
利用-:use:~
関連する:relevant な:~
意味され:mean され:意図され

	例えば:for example
	必要:need
	起:happen
	足りる:suffice
	加えて:in addition
	べき:should
	ベキ:SHOULD
	polling
	調べる:poll する
	述-:describe

	●未分類（動詞
作成-:create:~
処理-:process:~
処理:processing:~
包含-:contain:~
合致-:match:~
生成-:generate:~
省略-:omit:~
置換-:replace:~
表現-:represent:~
表面化-:surface:~
追加-:add:~
関与-:participate:~
除去-:remove:~
申込む:subscribe する:申し込む
申込んで:subscribe して:申し込んで
検出-:detect:~
操作-:manipulate:~
識別-:identify:~
公開-:expose:~
走らせ:run し:~
走らす:run する:~
開始-:start:~
中止-:abort:~
client:::クライアント
上書き:override:~
表示-:display:~

	所与の:given
	与:give
	得-:obtain
	示-:show
	返-:return
	関心のある:interested in
	run
	subscription
	~~競合:race condition
	例:example
	必要とされ:necessary
	-:with respect to
	-:check
	-:instruct
	-:assert
	-:emit
	繰り返し:repeated

	●未分類
ES:ECMAScript
JS:JavaScript
console:::コンソール
item:::アイテム
privacy:::プライバシー
保安:security::~:セキュリティ
interface:::インタフェース
data:::データ
navi:navigation::ナビ
option:::オプション
page:::ページ
pair:::ペア
primitive:
code:::コード
cost:::コスト
logic:::ロジック
property:::プロパティ
script:::スクリプト
alphabet-:alphabetical::アルファベット
既定の:default:~
内容:content:~
資源:resource::~:リソース
順序:order:~
消費器:consumer:~
解析:analytic:~

	-:modified
	-:update
	挙げ:listing
	-:obs
	-:currentOption
	deduplication
	no longer
	together
	この:this
	すべての:all
	より速く:faster
	代わり:instead
	全体:entire
	各:each
	同じ:same
	大量に:significant volume の
	最初の:first
	最後の:last
	様々な:various
	高:high
	介:via
	-:between
	他の:other
	1 個の:one
	その:that
	常に:always
	複数回:multiple
	単独の:single
	一回の:single
	他方:On the other hand


●●ref_normative

[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 1 March 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[PERFORMANCE-TIMELINE]
    Performance Timeline. Jatinder Mann; Zhiheng Wang. W3C. 12 December 2013. W3C Recommendation. URL: https://www.w3.org/TR/performance-timeline/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[WebIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/
[WHATWG-DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[WHATWG-INFRA]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[WORKERS]
    Web Workers. Ian Hickson. W3C. 24 September 2015. W3C Working Draft. URL: https://www.w3.org/TR/workers/

●●ref_informative

[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 5 November 2018. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[RESOURCE-TIMING-2]
    Resource Timing Level 2. Todd Reifsteck; Ilya Grigorik; Arvind Jain; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 5 November 2018. W3C Working Draft. URL: https://www.w3.org/TR/resource-timing-2/
[USER-TIMING-2]
    User Timing Level 2. Ilya Grigorik; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 9 July 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/user-timing-2/


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Performance Timeline Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/performance-timeline-2/

編集者草案
	https://w3c.github.io/performance-timeline/

テスト一式
	https://github.com/web-platform-tests/wpt/tree/master/performance-timeline

編集
	<a href="mailto:igrigorik@gmail.com">Ilya Grigorik</a> (Google)

前任編集者
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until November 2014)
	Zhiheng Wang (Google) (Until July 2013)

Participate
	<a href="https://github.com/w3c/performance-timeline/">GitHub w3c/performance-timeline</a>
	<a href="https://github.com/w3c/performance-timeline/issues/">File a bug</a>
	<a href="https://github.com/w3c/performance-timeline/commits/gh-pages">Commit history</a>
	<a href="https://github.com/w3c/performance-timeline/pulls/">Pull requests</a>

Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

</script>


</head>

<body>

<header>

	<hgroup>
<h1 id="title">処理能 時列線 — Performance Timeline Level 2</h1>
	</hgroup>
</header>


<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、
High Resolution Time 仕様 `HR-TIME-2$r
を拡張して、より高~分解能の処理能~計量~dataを［
検索取得する／格納する
］~methodを供する。
◎
This specification extends the High Resolution Time specification [HR-TIME-2] by providing methods to store and retrieve high resolution performance metric data.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
この節では、発行時点における…
<!-- 
これは編集者草案の公開の複製です…
-->
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>


<p>
Performance Timeline Level 2 は、その最初の~versionである
`PERFORMANCE-TIMELINE$r を置換し，次を含む：
◎
Performance Timeline Level 2 replaces the first version of [PERFORMANCE-TIMELINE] and includes:
</p>

<ul>
	<li>
`HR-TIME-2$r に定義される `Performance$I ~interfaceを拡張する。
◎
Extends the base definition of the Performance interface defined by [HR-TIME-2];
</li>
	<li>
Web Workers `WORKERS$r に
`PerformanceEntry$I を公開する。
◎
Exposes PerformanceEntry in Web Workers [WORKERS];
</li>
	<li>
`PerformanceObserver$I 用の~supportを追加する。
◎
Adds support for performance observers.
</li>
</ul>

<p>
この文書は
<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
により発行されました。
◎
This document was published by the Web Performance Working Group as an Editor's Draft. Comments regarding this document are welcome. Please send them to public-web-perf@w3.org (subscribe, archives) with [Performance Timeline] at the start of your email's subject.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~appの処理能~特性を正確0に計測することは、~web~appを より速くするための重要な側面である。
この仕様は、~web開発者が，
~web~appの全存続期間にわたる様々な処理能~計量［
に~accessする ／ を測定する ／ を検索取得する
］ことを可能化するために必要とされる
`処理能時列線$の~primitiveを定義する。
◎
Accurately measuring performance characteristics of web applications is an important aspect of making web applications faster. This specification defines the necessary Performance Timeline primitives that enable web developers to access, instrument, and retrieve various performance metrics from the full lifecycle of a web application.
</p>

<p>
［
`NAVIGATION-TIMING-2$r ／ `RESOURCE-TIMING-2$r ／ `USER-TIMING-2$r
］は、順に［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する計時~情報を定義する仕様の例である。
これらは、他の処理能~interfaceと伴に，~web~appの`処理能時列線$を述べる処理能の計量を定義する。
例えば，次の~scriptは、開発者が［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する処理能~計量を得るために
`処理能時列線$に~accessする方法を示すものである：
◎
[NAVIGATION-TIMING-2], [RESOURCE-TIMING-2], and [USER-TIMING-2] are examples of specifications that define timing information related to the navigation of the document, resources on the page, and developer scripts, respectively. Together these and other performance interfaces define performance metrics that describe the Performance Timeline of a web application. For example, the following script shows how a developer can access the Performance Timeline to obtain performance metrics related to the navigation of the document, resources on the page, and developer scripts:
</p>


<div class="example">

<pre>
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body onload="init()"&gt;
&lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
&lt;script&gt;

function init()
{
  /* <span class="comment">
`USER-TIMING-2$r を見よ
◎
see [[USER-TIMING-2]]
</span> */
  performance.mark("startWork");
  doWork(); /* <span class="comment">
何らかの開発者~code
◎
Some developer code
</span> */
  performance.mark("endWork");
  measurePerf();
}

function measurePerf() {
  performance
    .getEntries()
    .map(%entry =&gt; JSON.stringify(%entry, null, 2))
    .forEach(%json =&gt; console.log(%json));
}

&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;
</pre>

</div>

<p>
別法として，開発者は、`処理能時列線$を観測して，新たな処理能~計量が観測される度に `PerformanceObserver$I ~interfaceを介して通知させれる。
また，任意選択で、指定した種別の, すでに~buffer済みの処理能~計量も通知させれる。
◎
Alternatively, the developer can observe the Performance Timeline and be notified of new performance metrics and, optionally, previously buffered performance metrics of specified type, via the PerformanceObserver interface:
</p>

<div class="example">

<pre>
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
&lt;script&gt;

/* <span class="comment">
利用したい~entry種別は~supportされているかどうかを知る関数
◎
Know when the entry types we would like to use are not supported.
</span> */
function detectSupport(%entryTypes) {
  for (const %entryType of %entryTypes) {
    if (!PerformanceObserver.supportedEntryTypes.includes(%entryType)) {
      /* <span class="comment">
%entryType は~supportされていないことを~client側~解析に指示する。
◎
Indicate to client-side analytics that %entryType is not supported.
</span> */
    }
  }
}
detectSupport(["resource", "mark", "measure"]);
const %userTimingObserver = new PerformanceObserver(%list => {
  %list
    .getEntries()
    /* <span class="comment">
挿入された値を取得する
◎
Get the values we are interested in
</span> */
    .map(({ %name, %entryType, %startTime, %duration }) => {
      const %obj = {
        "Duration": %duration,
        "Entry Type": %entryType,
        "Name": %name,
        "Start Time": %startTime,
      };
      return JSON.stringify(%obj, null, 2);
    })
    /* <span class="comment">
それらを~consoleに表示する
◎
Display them to the console.
</span> */
    .forEach(console.log);

    /* <span class="comment">
~eventを処理したなら~disconnectする
◎
Disconnect after processing the events.
</span> */
  %userTimingObserver.disconnect();
});
/* <span class="comment">
User-Timing 用に新たな~eventを申込む
◎
Subscribe to new events for User-Timing.
</span> */
%userTimingObserver.observe({entryTypes: ["mark", "measure"]});
const %resourceObserver = new PerformanceObserver(list =&gt; {
  list
    .getEntries()
    /* <span class="comment">
関心のある値を取得する
◎
Get the values we are interested in
</span> */
    .map(({ name, startTime, fetchStart, responseStart, responseEnd }) =&gt; {
      const %obj = {
        "Name": name,
        "Start Time": startTime,
        "Fetch Start": fetchStart,
        "Response Start": responseStart,
        "Response End": responseEnd,
      };
      return JSON.stringify(%obj, null, 2);
    })
    /* <span class="comment">
それらを~consoleに表示する
◎
Display them to the console.
</span> */
    .forEach(console.log);
  /* <span class="comment">
~eventを処理したなら~disconnectする
◎
Disconnect after processing the events.
</span> */
  %resourceObserver.disconnect();
});
/* <span class="comment">
Resource Timing 用に ~bufferされた~eventを検索取得して より新たな~eventを申込む
◎
Retrieve buffered events and subscribe to newer events for Resource Timing.
</span> */
%resourceObserver.observe({type: "resource", buffered: true});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</div>


<p>
Performance Timeline Level 2 には、
`PerformanceObserver$I ~interfaceが追加された。
これは、最初の例に示された~bufferに基づく~approachにおける制限に取組むように設計されている。
`PerformanceObserver$I を利用すれば、~appは次が可能になる：
◎
The PerformanceObserver interface was added in Performance Timeline Level 2 and is designed to address limitations of the buffer-based approach shown in the first example. By using the PerformanceObserver interface, the application can:
</p>

<ul>
	<li>
時列線を調べ続ける（ `polling^en ）ことなく，新たな計量を検出できる。
◎
Avoid polling the timeline to detect new metrics
</li>
	<li>
~costのかかる~~重複排除~logic（ `deduplication^en ）なしに，新たな計量を識別できる。
◎
Eliminate costly deduplication logic to identify new metrics
</li>
	<li>
他の消費器と~~競合する（ `race condition^en ）ことなく，~bufferを操作できる。
◎
Eliminate race conditions with other consumers that may want to manipulate the buffer
</li>
</ul>

<p>
開発者には、アリな所では， `PerformanceObserver$I を利用することが奨励される。
加えて，新たな処理能 API や計量は、 `PerformanceObserver$I ~interfaceを通してのみ可用にされることになる。
◎
The developer is encouraged to use PerformanceObserver where possible. Further, new performance API's and metrics may only be available through the PerformanceObserver interface.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>

	<section id="performance-timeline">
<h2 title="Performance Timeline" id="dfn-performance-timeline">3. 処理能時列線</h2>


<div class="p">
<p>
各 `~ES大域~環境$【`大域~obj$】には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`処理能~観測器~task~queue済み~flag@</dt>
	<dd>
~flag値。
【初期~時は ~OFF 】
</dd>

	<dt>`処理能~観測器~list@</dt>
	<dd>
`処理能~観測器$からなる~list。
初期~時は空とする。
</dd>
	<dd>
`処理能~観測器$は、この~list内にあることを
`登録-済み@
であるともいう。
</dd>

	<dt>`処理能~entry~buffer@</dt>
	<dd>
`PerformanceEntry$I ~objたちを格納する（初期~時は空）。
</dd>
</dl>

◎
Each ECMAScript global environment has:
◎
a performance observer task queued flag
◎
a list of registered performance observer objects that is initially empty
◎
a performance entry buffer to store PerformanceEntry objects that is initially empty
</div>

<p>
~objに
`関連する処理能~entry~buffer@
は、［
~objに`関連する大域~obj$
］に結付けられている`処理能~entry~buffer$を指す。
◎
The relevant performance entry buffer is the performance entry buffer associated with the relevant global object.
</p>

		<section id="extensions-to-the-performance-interface">
<h3 title="Extensions to the Performance interface">3.1. `Performance^I ~interfaceに対する拡張</h3>

<p>
この節では、［
処理能に関係する各種~属性, および［
`処理能時列線$からの処理能~計量~dataを検索取得する
］ために利用される 各種~method
］を~hostするように，
`HR-TIME-2$r の `Performance$I ~interfaceを拡張する。
◎
This extends the Performance interface [HR-TIME-2] and hosts performance related attributes and methods used to retrieve the performance metric data from the Performance Timeline.
</p>

<pre class="idl">
partial interface `Performance$I {
    `PerformanceEntryList$I `getEntries$m();
    `PerformanceEntryList$I `getEntriesByType$m(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$m(`DOMString$ %name, optional `DOMString$ %type);
};

typedef `sequence$&lt;`PerformanceEntry$I&gt; `PerformanceEntryList$I;
</pre>

<p>
`PerformanceEntryList@I
は、 `PerformanceEntry$I の連列を表現する
— それは、開発者に~JS配列~用の便利~methodすべてを供する。
◎
The PerformanceEntryList represents a sequence of PerformanceEntry, providing developers with all the convenience methods found on JavaScript arrays.
</p>

<dl class="idl-def" id="methods">
	<dt id="getentries-method">`getEntries()@m</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れに`関連する処理能~entry~buffer$, ~NULL, ~NULL )
◎
3.1.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, and name and type set to null.
</dd>

	<dt id="getentriesbytype-method">`getEntriesByType(type)@m</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れに`関連する処理能~entry~buffer$, ~NULL, %type )
◎
3.1.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, name set to null, and type set to type.
</dd>

	<dt id="getentriesbyname-method">`getEntriesByName(name, type)@m</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れに`関連する処理能~entry~buffer$, %name, %type （省略時は ~NULL） )
◎
3.1.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, name set to name, and type set to null if optional entryType is omitted, and type set to type otherwise.
</dd>
</dl>

		</section>
		<section id="the-performanceentry-interface">
<h3 title="The PerformanceEntry interface">3.2. `PerformanceEntry^I ~interface</h3>

<p>
`PerformanceEntry$I
~interfaceは、様々な計量による処理能~dataを~hostする。
◎
The PerformanceEntry interface hosts the performance data of various metrics.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceEntry@I {
    readonly attribute `DOMString$           `name$m;
    readonly attribute `DOMString$           `entryType$m;
    readonly attribute `DOMHighResTimeStamp$I `startTime$m;
    readonly attribute `DOMHighResTimeStamp$I `duration$m;
    [`Default$] `object$ `toJSON$m();
};
</pre>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、此れの識別子を返すモノトスル。
この識別子は、一意になる必要はない。
◎
This attribute MUST return an identifier for this PerformanceEntry object. This identifier does not have to be unique.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、此れで表現される
<a href="http://www.w3.org/wiki/Web_Performance/EntryType">~interface型</a>
を述べる `DOMString^I を返すモノトスル。
◎
This attribute MUST return the type of the interface represented by this PerformanceEntry object.
</dd>
	<dd class="note">
<p>
他の仕様で定義される `entryType^m 値の例には、次が挙げられる：
</p>

<ul ><li>`mark^l, `measure^l `USER-TIMING-2$r
</li><li>`navigation^l `NAVIGATION-TIMING-2$r
</li><li>`resource^l `RESOURCE-TIMING-2$r
</li><li>`longtask^l 【仕様は不明】
</li><li>`paint^l `PAINT-TIMING$r 【この項は、この訳による補完】
</li></ul>

◎
Note
◎
Example entryType values defined by other specifications include: "mark" and "measure" [USER-TIMING-2], "navigation" [NAVIGATION-TIMING-2], "resource" [RESOURCE-TIMING-2], and "longtask".
</dd>

	<dt>`startTime@m</dt>
	<dd>
取得子は、［
此れの処理能~計量にて最初に記録された時刻印
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
処理能~計量に開始-時刻の概念は適用されない場合、
0 を返すことにしてもヨイ。
◎
This attribute MUST return the time value of the first recorded timestamp of this performance metric. If the startTime concept doesn't apply, a performance metric may choose to return a startTime of 0.
</dd>

	<dt id="attributes">`duration@m</dt>
	<dd>
取得子は、［
此れに記録される~event全体の所要時間
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
これは概して，此れに［
最初に記録された時刻印
］から［
最後に記録された時刻印
］までの時間~差になる。
処理能~計量に所要時間の概念が適用されない場合、
0 を返すことにしてもヨイ。
◎
This attribute MUST return the time value of the duration of the entire event being recorded by this PerformanceEntry. Typically, this would be the time difference between the last recorded timestamp and the first recorded timestamp of this PerformanceEntry. If the duration concept doesn't apply, a performance metric may choose to return a duration of 0.
</dd>

	<dt>`toJSON()@m</dt>
	<dd>
~call時には、 `WebIDL$r による`既定の~toJSON演算$を走らす。
◎
When toJSON is called, run [WebIDL]'s default toJSON operation.
</dd>
</dl>

		</section>
		<section id="the-performanceobserver-interface">
<h3 title="The PerformanceObserver interface">3.3. `PerformanceObserver^I ~interface</h3>


<p>
`PerformanceObserver$I ~interfaceを利用すれば、`処理能時列線$を観測して，新たな処理能~計量（ `PerformanceEntry$I ~obj）が記録される度に通知させれる。
また，任意選択で、すでに~buffer済みの処理能~計量も通知させれる。
◎
The PerformanceObserver interface can be used to observe the Performance Timeline to be notified of new performance metrics as they are recorded, and optionally buffered performance metrics. 
</p>

<p>
`PerformanceObserver$I ~objは、単に
`処理能~観測器@
とも称される。
各 `処理能~観測器$には、次のものが結付けられる：
◎
Each PerformanceObserver has these associated concepts:
</p>

<dl>
	<dt>`~callback@pO</dt>
	<dd>
作成-時に設定される，
`PerformanceObserverCallback$I ~callback。
◎
A PerformanceObserverCallback set on creation.
</dd>

	<dt>`~buffer@pO</dt>
	<dd>
`PerformanceEntryList$I ~obj。
この~objが表現する連列は、初期~時は空とする。
◎
A PerformanceEntryList object called the observer buffer that is initially empty.
</dd>

	<dt>`種別@pO</dt>
	<dd>
次のいずれか
— 初期~時は `未定義^i とする
【`登録-済み$になった時点で、他の値に更新される】
⇒
`未定義^i ／ `一個^i ／ `複数個^i
◎
A DOMString observer type which is initially "undefined".
</dd>

	<dt>`~options~list@pO</dt>
	<dd>
0 個以上の `PerformanceObserverInit$I 辞書からなる~list, または ε （なし）。
初期~時は ε とする。
`登録-済み$である間は非 ε になる。
◎
↓↓</dd>
	<dd class="trans-note">【
原文では、
“登録-済み処理能~観測器”
という別個の構造体を定義して，それに
— `処理能~観測器$への参照とともに —
`~options~list$pOを保たせているが、この構造体は，実質的に［
処理能~観測器は`処理能~観測器~list$内に含まれるかどうか
］の区別を表現するだけに過ぎず，無為に冗長なので、この訳では単純化している。
】</dd>
</dl>

<div >

<p class="idl-def">
`PerformanceObserver(callback)@m
構築子の被呼出時には、次を走らすモノトスル：
</p>

<ol ><li>%観測器 ~LET 新たな `PerformanceObserver$I ~obj
</li><li>%観測器 の`~callback$pO ~SET %callback
</li><li>~RET %観測器
</li></ol>

◎
The `PerformanceObserver(callback)` constructor must create a new PerformanceObserver object with PerformanceObserverCallback set to callback and then return it.
◎
↑↑A registered performance observer is a struct consisting of an observer member (a PerformanceObserver object) and an options list member (a list of PerformanceObserverInit dictionaries).
</div>

<pre class="idl">
callback `PerformanceObserverCallback@I = void (
    `PerformanceObserverEntryList$I %entries,
    `PerformanceObserver$I %observer
);

[`Constructor$(`PerformanceObserverCallback$I %callback),
`Exposed$=(Window,Worker)]
interface `PerformanceObserver@I {
    void `observe$m(`PerformanceObserverInit$I %options);
    void `disconnect$m();
    `PerformanceEntryList$I `takeRecords$m();
    static readonly attribute `FrozenArray$&lt;`DOMString$&gt; `supportedEntryTypes$m;
};
</pre>

<p class="note">注記：
処理能~overheadを最小限に保つためには、~appは，関心のある~event種別のみを申込んで、処理能~dataを観測する必要がなくなったなら，観測器を
`disconnect()$m するべきである。
名前（ `name$m ）による絞込みは~supportされない
— それは，暗黙的にすべての~event種別を申込むことになり、アリではあるが，大量の~eventを生成することになるので。
<!-- discouraged -->
◎
Note
◎
To keep the performance overhead to minimum the application ought only subscribe to event types that it is interested in, and disconnect the observer once it no longer needs to observe the performance data. Filtering by name is not supported, as it would implicitly require a subscription for all event types — this is possible, but discouraged, as it will generate a significant volume of events.
</p>

			<section id="observe-method">
<h4 title="observe() method">3.3.1. `observe(options)@m ~method</h4>

<p id="dfn-register-the-observer">
この~methodは、此れが`登録-済み$であれば 此れを更新し，そうでなければ此れを`登録-済み$にする。
◎
The observe() method instructs the user agent to register the observer and＼
</p>

<p class="idl-def">
被呼出時には、次を走らすモノトスル：
◎
must run these steps:
• Let observer be the context object.
</p>

<ol>
	<li>
%種別たち ~LET ［
%~options に `entryTypes$d ~memberは在するならば それ ／
~ELSE_ ε
］
◎
↓</li>
	<li>
%種別 ~LET ［
%~options に `type$d ~memberは在するならば それ ／
~ELSE_ ε
］
◎
↓</li>
	<li>
~IF［
%種別たち ~EQ ε 
］~AND［
%種別 ~EQ ε
］
⇒
~THROW `SyntaxError^E
◎
If options's entryTypes and type members are both omitted, then throw a SyntaxError.
</li>
	<li>
~IF［
%種別たち ~NEQ ε
］~AND［
%~options に `entryTypes$d 以外の~memberは在する
］
⇒
~THROW `SyntaxError^E
◎
If options's entryTypes is present and any other member is also present, then throw a SyntaxError.
</li>
	<li>
<p>
此れの`種別$pOに応じて：
◎
Update or check observer's observer type by running these steps:
</p>
		<dl class="switch">
			<dt>
`未定義^i
◎
If observer's observer type is "undefined":
</dt>
			<dd>
此れの`種別$pO ~SET ［
%種別たち ~NEQ ε ならば `複数個^i ／
~ELSE_ `一個^i
］
◎
If options's entryTypes member is present, then set observer's observer type to "multiple".
◎
If options's type member is present, then set observer's observer type to "single".
</dd>

			<dt>`一個^i</dt>
			<dd>
~IF［
%種別たち ~NEQ ε
］
⇒
~THROW `InvalidModificationError^E
◎
If observer's observer type is "single" and options's entryTypes member is present, then throw an InvalidModificationError.
</dd>

			<dt>`複数個^i</dt>
			<dd>
~IF［
%種別 ~NEQ ε
］
⇒
~THROW `InvalidModificationError^E
◎
If observer's observer type is "multiple" and options's type member is present, then throw an InvalidModificationError.
</dd>
		</dl>
	</li>
	<li>
%観測器~list ~LET 此れに`関連する大域~obj$の`処理能~観測器~list$
◎
↓</li>
	<li>
<p>
~IF［
此れの`種別$pO ~EQ `複数個^i
］：
◎
If observer's observer type is "multiple", run the following steps:
• Let entry types be options's entryTypes sequence.
</p>
		<ol>
			<li>
%種別たち から［
`~supportされる~entry種別たち$に含まれない種別
］をすべて除去する
⇒
~UAは、除去された種別があれば，開発者に通知するベキである
— 例えば、~console警告にそれらを挙げるのが適切になるであろう。
◎
Remove all types from entry types that are not contained in supported entry types. The user agent SHOULD notify developers if entry types is modified. For example, a console warning listing removed types might be appropriate.
</li>
			<li>
~IF［
%種別たち は空である
］
⇒
~RET
⇒
~UAは、登録は中止されたことを開発者に通知するベキである
— 例えば，~console警告が適切になるであろう。
◎
If the resulting entry types sequence is an empty sequence, abort these steps. The user agent SHOULD notify developers when the steps are aborted to notify that registration has been aborted. For example, a console warning might be appropriate.
</li>
			<li>
~IF［
此れ ~NIN %観測器~list
］
⇒
此れを %観測器~list に付加する
◎
↓</li>
			<li>
此れ の`~options~list$pO ~SET %~options のみからなる~list
◎
If the list of registered performance observer objects of relevant global object contains a registered performance observer whose observer is the context object, replace its options list with a list containing options as its only item.
◎
Otherwise, create and append a registered performance observer object to the list of registered performance observer objects of relevant global object, with observer set to the context object and options list set to a list containing options as its only item.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ 此れの`種別$pO ~EQ `一個^i ）：
◎
Otherwise, run the following steps:
• Assert that observer's observer type is "single".
</p>
		<ol>
			<li>
~IF［
%種別 ~NIN `~supportされる~entry種別たち$
］
⇒
~RET
⇒
~UAは、これが起きたことを開発者に通知するベキである
— 例えば，~console警告を介して。
◎
If options's type is not contained in supported entry types, abort these steps. The user agent SHOULD notify developers when this happens, for instance via a console warning.
</li>
			<li>
<p>
~IF［
此れ ~IN %観測器~list
］：
◎
If the list of registered performance observer objects of relevant global object contains a registered performance observer obs whose observer is the context object:
</p>
				<ol>
					<li>
~IF［
此れの`~options~list$pO内の ある~itemの `type$d ~EQ %種別
］
⇒
此れの`~options~list$pO内の その~itemを %~options に置換する
◎
If obs's options list contains a PerformanceObserverInit item currentOptions whose type is equal to options's type, replace currentOptions with options in obs's options list.
</li>
					<li>
~ELSE
⇒
%~options を此れの`~options~list$pOに付加する
◎
Otherwise, append options to obs's options list.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒＃
此れを %観測器~list に付加する；
此れの`~options~list$pO ~SET %~options のみからなる~list
◎
Otherwise, create and append a registered performance observer object to the list of registered performance observer objects of relevant global object, with observer set to the context object and options list set to a list containing options as its only item.
</li>
			<li>
~IF［
%~options の `buffered$d ~EQ ~T
］
⇒
次の結果を，此れの`~buffer$pOに付加する
⇒
`~bufferを絞込む$( 此れに`関連する処理能~entry~buffer$, ~NULL, %種別 )
◎
If options's buffered flag is set:
• Let entries be the PerformanceEntryList object returned by the algorithm with buffer set to relevant performance entry buffer, name set to null and type set to options's type.
• Append entries to the context object's observer buffer.
</li>
		</ol>
	</li>
</ol>

<p class="note">
同じ `PerformanceObserver$I ~obj上で `observe(options)$m を~callするときは、
%options の［
`entryTypes$d, `type$d
］のうち，~~一貫して片方のみを利用する必要がある
— 例えば `observe()$m を `entryTypes$d を与えて~callしてから，
`type$d を与えて また~callした場合、例外が投出される。
これには、~callがどう積重なるかについて混同を避けることが意味されている。
`entryTypes$d を利用する下では、
`PerformanceObserverInit$I 内の他の~memberは利用できないことに加え、後方互換性のため，複数回の `observe()$m ~callは 以前のそれを上書きすることになる
— この事例では一回の~callで足りるべきなので。
他方， `type$d を利用する下では、一回の~callは 1 個の種別のみ指定するので，各~callは積重なることになる。
この場合も、同じ `type$d を与える下で繰り返し `observe()$m を~callしたときは，上書きすることになる。
◎
A PerformanceObserver object needs to always call observe() with options's entryTypes set OR always call observe() with options's type set. If one PerformanceObserver calls observe() with entryTypes and also calls observe with type, then an exception is thrown. This is meant to avoid confusion with how calls would stack. When using entryTypes, no other parameters in PerformanceObserverInit can be used. In addition, multiple observe() calls will override for backwards compatibility and because a single call should suffice in this case. On the other hand, when using type, calls will stack because a single call can only specify one type. Calling observe() with a repeated type will also override.
</p>

				<section id="performanceobserverinit-dictionary">
<h5 title="PerformanceObserverInit dictionary">3.3.1.1. `PerformanceObserverInit^I 辞書</h5>

<pre class="idl">
dictionary `PerformanceObserverInit@I {
    `sequence$&lt;`DOMString$&gt; `entryTypes$d;
    DOMString `type$d;
    `boolean$ `buffered$d;
};
</pre>

<dl class="idl-def">
	<dt>`entryTypes@d</dt>
	<dd>
観測されることになる一連の~entry種別からなる~list。
この~listが在する場合、空であってはナラナイ, かつ
他のすべての~memberも在してはナラナイ。
~UAは、この~list内の種別のうち，自身が認識しないものは無視するモノトスル。
◎
A list of entry types to be observed. If present, the list MUST NOT be empty and all other members MUST NOT be present. Types not recognized by the user agent MUST be ignored.
</dd>

	<dt>`type@d</dt>
	<dd>
観測されることになる単独の~entry種別。
~UAは、自身が認識しない種別を無視するモノトスル。
◎
A single entry type to be observed. A type that is not recognized by the user agent MUST be ignored. Other members may be present.
</dd>

	<dt>`buffered@d</dt>
	<dd>
~buffer済み~entryたちも`~buffer$pOに~queueするべきかどうかを指示する。
◎
A flag to indicate whether buffered entries should be queued into observer's buffer.
</dd>
</dl>

				</section>
				<section id="performanceobserverentrylist-interface">
<h5 title="PerformanceObserverEntryList interface">3.3.1.2. `PerformanceObserverEntryList^I ~interface</h5>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceObserverEntryList@I {
    `PerformanceEntryList$I `getEntries$mO();
    `PerformanceEntryList$I `getEntriesByType$mO(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$mO(`DOMString$ %name, optional `DOMString$ %type);
};
</pre>

<dl class="idl-def">
	<dt id="getentries-method-0">`getEntries()@mO</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れが表現する`~buffer$pO, ~NULL, ~NULL )
◎
3.3.3.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, and name and type set to null.
</dd>

	<dt id="getentriesbytype-method-0">`getEntriesByType(type)@mO</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れが表現する`~buffer$pO, ~NULL, %type )
◎
3.3.3.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, name set to null, and type set to type.
</dd>

	<dt id="getentriesbyname-method-0">`getEntriesByName(name, type)@mO</dt>
	<dd>
被呼出時には、次の結果を返すモノトスル
⇒
`~bufferを絞込む$( 此れが表現する`~buffer$pO, %name, %type （省略時は ~NULL） )
◎
3.3.3.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, name set to name, and type set to null if optional entryType is omitted, and type set to type otherwise.
</dd>
</dl>

				</section>
			</section>
			<section id="takerecords-method">
<h4 title="takeRecords() method">3.3.2. `takeRecords()@m ~method</h4>

<div class="p">
<p class="idl-def">
被呼出時には、次を走らすモノトスル：
</p>

<ol>
	<li>
%複製 ~LET 此れの`~buffer$pOの複製
</li>
	<li>
此れの`~buffer$pOを空にする
</li>
	<li>
~RET %複製
</li>
</ol>

◎
The takeRecords() method must return a copy of the context object's observer buffer, and also empty context object's observer buffer.
</div>


			</section>
			<section id="disconnect-method">
<h4 title="disconnect() method">3.3.3. `disconnect()@m ~method</h4>

<div class="p">
<p class="idl-def">
被呼出時には、次を走らすモノトスル：
</p>

<ol>
	<li>
此れに`関連する大域~obj$の`処理能~観測器~list$から，此れを除去する
</li>
	<li>
此れの`~options~list$pO ~LET ε
</li>
	<li>
此れの`~buffer$pOを空にする
</li>
</ol>

◎
The disconnect() method must remove the context object from the list of registered performance observer objects of relevant global object, and also empty context object's observer buffer.
</div>

			</section>
			<section id="supportedentrytypes-attribute">
<h4>3.3.4. `supportedEntryTypes@m 属性</h4>

<p>
~UAは、
`~supportされる~entry種別たち@
— ［
~UAが `PerformanceObserver$I ~interface用に~supportする~entry種別を表現している文字列
］からなる~list —
を保守するモノトスル。
この~listは、`処理能~entry種別を登録する$~algoを介して
新たな~entry種別を定義する各種~仕様により拡充される。
◎
The user agent MUST maintain supported entry types, a list of strings representing the entry types which the user agent supports for the PerformanceObserver interface. This list is populated by specifications that define new entry types via the register a performance entry type algorithm.
</p>

<p class="idl">
取得子は、次を返すモノトスル
⇒
`~supportされる~entry種別たち$を複製してから~alphabet-順序で~sortした結果の~list
◎
When supportedEntryTypes's attribute getter is called, run the following steps:
• Let result be a copy of the user agent's supported entry types.
• Sort result in alphabetical order.
• Return result.
</p>

<p class="note">
この属性は、~UAがどの~entry種別を~supportするか，容易に知ることを~web開発者に許容する。
◎
This attribute allows web developers to easily know which entry types are supported by the user agent.
</p>

			</section>
		</section>
	</section>
	<section id="processing">
<h2 title="Processing">4. 処理</h2>

		<section id="queue-a-performanceentry">
<h3 title="Queue a PerformanceEntry">4.1. `PerformanceEntry^I を~queueする</h3>

<div class="p">
<p>
`処理能~entryを~queueする@
ときは、所与の
( `PerformanceEntry$I ~obj %新たな~entry, %処理能~entry~bufferに追加する~flag ~IN { `~bufferに追加する^i, ε }（省略時は ε ） )
に対し，次を走らす：
</p>

◎
To queue a PerformanceEntry (new entry) with an optional add to performance entry buffer flag, which is unset by default, run these steps:
</div>

<ol>
	<li>
%~entry種別 ~LET %新たな~entry の `entryType$m 値
◎
↓</li>
	<li>
%大域~obj ~LET `関連する大域~obj$
【どの~objに`関連する大域~obj$かは、この~algoを呼出した文脈に依存する。】
◎
↓</li>
	<li>
%大域~obj の`処理能~観測器~list$内の ~EACH ( `処理能~観測器$ %観測器 ) に対し
⇒
~IF［
%観測器 の`~options~list$pO内に ある `PerformanceObserverInit$I ~item %D が在って，［
%~entry種別 ~IN %D の `entryTypes^m
］~OR［
%~entry種別 ~EQ %D の `entryType^m
］を満たす
］
⇒
%観測器 の`~buffer$pOに %新たな~entry を付加する
◎
Let interested observers be an initially empty set of PerformanceObserver objects.
◎
For each registered performance observer (regObs):
• If regObs's options list contains a PerformanceObserverInit item whose entryTypes member includes entryType or whose type member equals to entryType, append regObs's observer to interested observers.
◎
For each observer in interested observers:
• Append new entry to observer's observer buffer.
</li>
	<li>
~IF［
%処理能~entry~bufferに追加する~flag ~NEQ ε
］
⇒
%新たな~entry を %大域~obj の`処理能~entry~buffer$に追加する
◎
If the add to performance entry buffer flag is set, add new entry to the performance entry buffer.
</li>
	<li>
~IF［
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~EQ ~ON
］
⇒
~RET
◎
If the performance observer task queued flag is set, terminate these steps.
</li>
	<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~ON
◎
Set performance observer task queued flag.
</li>
	<li>
<p>
次の下位手続きを走らす`~taskを~queueする$
— この~task用の`~task源$は、
`処理能~時列線~task源@
とする：
◎
Queue a task that consists of running the following substeps. The task source for the queued task is the performance timeline task source.
</p>
		<ol>
			<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~OFF
◎
Unset performance observer task queued flag.
</li>
			<li>
%通知-~list ~LET ［
%大域~obj の`処理能~観測器~list$
］の複製
<!-- ＊
複製をとるのは、後段で~callされる~callbackによる影響を避けるため
-->
◎
Let notify list be a copy of relevant global object's list of registered performance observer objects.
</li>
			<li>
<p>
%通知-~list 内の~EACH ( `処理能~観測器$ %観測器 ) に対し：
◎
For each PerformanceObserver object po in notify list, run these steps:
</p>
				<ol>
					<li>
~IF［
%観測器 の`~buffer$pOは空である
］
⇒
~CONTINUE
◎
↓</li>
					<li>
%~entryたち ~LET %観測器 の`~buffer$pOの複製
◎
Let entries be a copy of po’s observer buffer.
</li>
					<li>
%観測器 の`~buffer$pOを空にする
◎
Empty po’s observer buffer.
</li>
					<li>
<p>
次を渡して %観測器 の`~callback$pOを~callする
⇒＃
引数~list « %~entryたち, %観測器 »,
`~callback this 値$ %観測器
</p>

<p>
この段にて例外が`投出-$された場合は、その`例外を報告する$。
</p>

◎
If entries is non-empty, call po’s callback with entries as first argument and po as the second argument and callback this value. If this throws an exception, report the exception.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p>
`処理能~時列線~task源$用の`~task~queue$は、低優先度の~queueである
— ~UAは、処理能~監視~codeの影響0を最小限に抑えるため，アリなら遊休中に処理するべきである。
◎
The performance timeline task queue is a low priority queue that, if possible, should be processed by the user agent during idle periods to minimize impact of performance monitoring code.
</p>

		</section>
		<section id="filter-buffer-by-name-and-type">
<h3 title="Filter buffer by name and type">4.2. ~bufferを ( %名前, %種別 ) で絞込む</h3>

<div class="p">
<p>
この~algoは、所与の：
</p>

<ul ><li>%~buffer — `PerformanceEntry$I ~objの~list
</li><li>%名前 — 文字列, 省略時は ~NULL
</li><li>%種別  — 文字列, 省略時は ~NULL
</li></ul>

<p>
に対し，次を走らせた結果の `PerformanceEntryList$I ~objを返す：
</p>

<ol>
	<li>
%~entry~obj~list ~LET ［
下に与える下位手続きを走らせた結果の~list
］を［
~listを成す各~objの `startTime$m の時系列順
］に~sortした結果の~list
— `startTime$m が同じ~objどうしの順序は指定されない
</li>
	<li>
~RET %~list を包含する新たな `PerformanceEntryList$I ~obj
</li>
</ol>

<p>
上で利用される下位手続きは、次を走らす：
</p>

◎
Given a buffer and optional name and type string values this algorithm returns a PerformanceEntryList object that contains a list of PerformanceEntry objects sorted in chronological order with respect to startTime; objects with the same startTime have unspecified ordering.
</div>

<ol>
	<li>
%~list ~LET 空~list
◎
Let the list of entry objects be the empty PerformanceEntryList.
</li>
	<li>
<p>
%~buffer 内の ~EACH ( `PerformanceEntry$I ~obj %~entry~obj ) に対し：
◎
For each PerformanceEntry object (entryObject) in the buffer, in chronological order with respect to startTime:
</p>
		<ol>
			<li>
~IF［
%名前 ~NIN { ~NULL, %~entry~obj の `name$m 属性~値 )
］
⇒
~CONTINUE
◎
If name is not null and entryObject's name attribute does not match name in a case-sensitive manner, go to next entryObject.
</li>
			<li>
~IF［
%種別 ~NEQ { ~NULL, %~entry~obj の `entryType$m 属性~値 }
］
⇒
~CONTINUE
◎
If type is not null and entryObject's type attribute does not match type in a case-sensitive manner, go to next entryObject.
</li>
			<li>
%~list に %~entry~obj を追加する
◎
Add entryObject to the list of entry objects.
</li>
  </ol>
  </li>
  <li>
~RET %~list
◎
Return the list of entry objects.
</li>
</ol>

		</section>
		<section id="register-performance-entry-type">
<h3 title="Register performance entry type">4.3. 処理能~entry種別を登録する</h3>

<p>
`処理能~entry種別を登録する@
ときは、所与の
( 文字列 %種別 )
に対し，`~supportされる~entry種別たち$に %種別 を付加する。
【当然ながら、同じ文字列がすでに登録-済みの場合は付加しないであろう。】
◎
To register a performance entry type, run the following steps:
• Let type be the input string.
• Append type to supported entry types.
</p>

		</section>
	</section>
	<section id="privacy-security">

<h3 title="Privacy and Security">5. ~privacyと保安</h3>

<p>
この仕様は、
`HR-TIME-2$r に定義された `Performance$I ~interfaceを拡張し，`処理能時列線$［
に~entryを~queueする／から~entryを検索取得する
］ための~methodを供する。
高分解能の計時~情報を公開することによる［
~privacy／保安
］上の考慮点については、
`HR-TIME-2$r を参照されたし。
◎
This specification extends the Performance interface defined by [HR-TIME-2] and provides methods to queue and retrieve entries from the performance timeline. Please refer to [HR-TIME-2] for privacy and security considerations of exposing high-resoluting timing information.
</p>
	</section>
	<section class="appendix">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に協力された次の方々に：
</p>

<div lang="en-x-a0">
Thanks to Arvind Jain, Boris Zbarsky, Jatinder Mann, Nat Duca, Philippe Le Hegaret, Ryosuke Niwa, Shubhie Panicker, Todd Reifsteck, Yoav Weiss, and Zhiheng Wang, for their contributions to this work.
</div>
	</section>

</main></div>

