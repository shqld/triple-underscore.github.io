<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Worklets Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
//case 'mb': // IDL dictionary member
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
case 'sl':
	text = `[[${key}]]`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Worklets Level 1
spec_date:2020-08-18
trans_update:2020-08-19
source_checked:180508
	page_state_key:CSS
original_url:https://drafts.css-houdini.org/worklets/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2020,use
trans_1st_pub:2018-02-27


●●class_map
t:type
e:element
a:attr
E:error
sl:js-slot
jv:js-value
jA:abstract

●●tag_map
I:code
m:code
e:code
E:code
a:code
at:code
h:code
c:code
v:code
t:var
sl:span
jv:code
jA:span
i:i


●●words_table1
CSSPAINTAPI:css-paint-api-ja.html

●●words_table

WorkletGlobalScope:
id:
clear::::
agent:
scope::::スコープ
main::::
random::::ランダム
	~secureでない:unsecure
worklet:
小task:microtask::小 task:小タスク

	●処理一般
計数:counter:~
memory::::メモリ
処理待ち:pending::~
再投出-:rethrow:~
	何もしない:do nothing
kill:
	開始し直す:restart
	-:continuing

	●非同期／並列処理
process::::プロセス
	thread安全:thread-safe
joining:
存続期間:lifetime::~
pipeline::::パイプライン
stage:
phase:
stateless:
断続的:continual::~
束ねら:tieさ:~
並列化-:parallelize::~
並列性:parallelism::~
冪等:idempotent::~
冪等性:idempotence::~
冪等性:idempotency::~
投機-:speculate:~
投機的:speculative::~
同時並行性:concurrency::~
	途中:in the middle of
	どこでも:wherever
	舞台裏では:behind the scenes

	●仕様
opt-out:
overhead::::オーバーヘッド
放棄-:abandon:~
書く:writeする:~

異常:abnormal:~
透過的:transparent:~
	問わない:agnostic
実施上は:practicalには:実施においては

	~overheadの高い:high-overhead
	必要に応じて:as required
	constraints
	simply
	控えめ:sparing
	あり得る:potential
	課され:impose
	そのため、:Due to this
	~~従来の前提:previously held assumptions
	他に比して:relatively
	-:we
	-:asked to

	●未分類（動詞
作成時の:creation::~
	insertion
終了-:terminate::~
超過-:exceed::~
print:
併合-:merge::~
住まう:liveする::~
	sent
	debug用:debugging
	~NULL にされる:clear
	選ぶ:choose
	し続け:keep
	対する応答は〜~cache済み:hit
	-:assocated
	属する:belong

	●未分類
fake:
surface:
strict-mode:strict mode
時刻:time::~
埋込元:embedder::埋め込み元

	数:number
地点:point::~

	●指示語
	高い:high
	個別に:distinct
	だけ:just
	#3:number 3
	でない:non-
	以降:rest of
	:against
	~worklet大域~scope:WorkletGlobalScope

	●変数
	~worklet~event~loop:workletEventLoop
	~realm実行~文脈:realmExecutionContext
	外側~設定群:outsideSettings
	内側~設定群:insideSettings
	実行~文脈~executionContext
	継承された~API用~基底~URL:inheritedAPIBaseURL
	-:inheritedResponsibleBrowsingContext
	継承された~referrer施策:inheritedReferrerPolicy
	設定群~obj:settingsObject
	資格証~mode:credentialOptions
	~module応答~map:moduleResponsesMap
	処理待ち~task構造体:pendingTaskStruct
	~module~URL~record:moduleURLRecord
	~worklet大域~scope型:workletGlobalScopeType
	~worklet大域~scope:workletGlobalScope
	~class構築子:classConstructor
	~class構築子:classCtor
	~class~instance:classInstance

●●original_id_map

●●mdn_urls
worklet:API/Worklet
	workletglobalscope:API/WorkletGlobalScope
	dictdef-workletoptions:API/WorkletOptions

●●link_map

	●IDL
Global:~WEBIDLjs#Global
Exposed:~WEBIDLjs#Exposed
NewObject:~WEBIDLjs#NewObject

undefined:~WEBIDL#idl-undefined
USVString:~WEBIDL#idl-USVString

I.Worklet:#worklet
I.WorkletGlobalScope:#workletglobalscope
I.WorkletOptions:#dictdef-workletoptions
I.PaintWorkletGlobalScope:~CSSPAINTAPI#paintworkletglobalscope
I.RequestCredentials:~FETCH#requestcredentials
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.EventTarget:~DOM4#interface-eventtarget
I.Window:~WINDOW#window
I.Document:#dom-document
	~HTMLINFRA#dom-document
	I.FakeWorkletGlobalScope:#fakeworkletglobalscope

E.SyntaxError:~WEBIDL#syntaxerror
E.AbortError:~WEBIDL#aborterror
	DOMException:~WEBIDL#idl-DOMException

m.addModule:#dom-worklet-addmodule
m.credentials:#dom-workletoptions-credentials
	m.registerAnArbitaryClass:#dom-fakeworkletglobalscope-registeranarbitaryclass
m.self:~WORKERS#dom-workerglobalscope-self


	●用語
計数:#pending-tasks-struct-counter
~worklet大域~scopeを作成する:#create-a-workletglobalscope

~worklet~scriptを~fetchして呼出す:#fetch-and-invoke-a-worklet-script
~worklet~scriptを~fetchする:#fetch-a-worklet-script
処理待ち~task構造体:#pending-tasks-struct
登録-済み~class構築子~map:#registered-class-constructors-map
~workletの環境~設定群~objを設定しておく:#set-up-a-worklet-environment-settings-object

	sl.HostDefined

~worklet大域~scope:#worklet-global-scope
wL.環境~設定群~obj:#_workletglobalscope-environment-settings-object
wL.~module~map:#workletglobalscope-module-map
wL.所有者~文書:#workletglobalscope-owner-document
wL.~worklet大域~scope実行~環境:#worklet-global-scope-execution-environment
wL.~module応答~map:#module-responses-map
wL.~worklet大域~scope型:#worklet-global-scope-type
wL.~worklet大域~scope~list:#worklets-workletglobalscopes
wL.~worklet行先~種別:#worklet-destination-type

	●用語（外部
構造体:~INFRA#struct
有順序~map:~INFRA#ordered-map
	~keyたちを取得する:~INFRA#map-getting-the-keys

新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve

継承-:~WEBIDL#dfn-inherit
~callback関数を呼出す:~WEBIDLjs#es-invoking-callback-functions

相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record


UTF-8:~ENCODING#utf-8

~fetch:~FETCH#concept-fetch
要請:~FETCH#concept-request
rq.~URL:~FETCH#concept-request-url
rq.行先:~FETCH#concept-request-destination

並列的:~HTMLINFRA#in-parallel
非同期に完了する:~HTMLINFRA#_asynchronously-complete

閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
破棄され:~WINDOW#a-browsing-context-is-discarded
不透明な生成元:~ORIGIN#concept-origin-opaque
~web~worker:~WORKERS#workers
~workerの環境~設定群~objを設定しておく:~WORKERS#set-up-a-worker-environment-settings-object

	＊
文書~環境:#_document-environment
	~WAPI#document-environment
環境~設定群~obj:~WAPI#environment-settings-object
~event~loop:~WAPI#event-loop
~module~worker~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~module~scriptを走らす:~WAPI#run-a-module-script
~worklet~agentを得する:~WAPI#obtain-a-worklet-agent
新たな~JS~realmを作成する:~WAPI#creating-a-new-javascript-realm
rM.大域~obj:~WAPI#concept-realm-global

小task:~WAPI#microtask
小task~queue:~WAPI#microtask-queue
~module~script:~WAPI#module-script
~fetchを遂行する:~WAPI#fetching-scripts-perform-fetch
~taskを~queueする:~WAPI#queue-a-task
関連な設定群~obj:~WAPI#relevant-settings-object
例外を報告する:~WAPI#report-the-exception
~module~map:~WAPI#module-map

enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~id:~WAPI#concept-environment-id
enV.生成元:~WAPI#concept-settings-object-origin
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.埋込元~施策:~WAPI#concept-settings-object-embedder-policy
	廃）enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.担当の文書:~WAPI#responsible-document
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context

再投出-用~error:~WAPI#concept-script-error-to-rethrow

	ES6:https://www.ecma-international.org/ecma-262/6.0/
jA.Construct:~TC39#sec-construct
	~ES6#sec-construct
jA.Invoke:~TC39#sec-invoke
	~ES6#sec-invoke
~strict-mode:~TC39#sec-strict-mode-code
	~ES6#sec-strict-mode-code

大域~objの~CSP~listを初期化する:~CSP3#initialize-global-object-csp

●●ref_data
WEBAUDIO=副         g200kg.github.io/web-audio-api-ja/


●●ref_normative

[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-PAINT-API-1]
    Ian Kilpatrick; Dean Jackson. CSS Painting API Level 1. 9 August 2018. CR. URL: https://www.w3.org/TR/css-paint-api-1/ 
[WEBAUDIO]
    Paul Adenot; Hongchan Choi. Web Audio API. 11 June 2020. CR. URL: https://www.w3.org/TR/webaudio/ 


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Worklets Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	http://www.w3.org/TR/worklets-1/

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bworklets%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[worklets] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)

編集
	<a href="mailto:ikilpatrick@chromium.org">Ian Kilpatrick</a>

最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/labels/worklets-1">GitHub Issues</a>

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master/worklets

発行者
	<a href="http://www.w3.org/Style/CSS/members">CSS Working Group</a> (part of the <a href="http://www.w3.org/Style/">Style Activity</a>)

</script>

<!-- 
<a href="https://github.com/w3c/css-houdini-drafts/issues">GitHub Issues</a> are <a href="https://lists.w3.org/Archives/Public/public-houdini-archive/">archived</a>
 -->

</head>

<body>

<header>


	<hgroup>
<h1>Worklets Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT


<p>
この仕様は、~main~JS実行~環境からは独立に，具現化~pipelineを成す~stageたち内で~scriptを走らすための~APIを定義する。
◎
This specification defines an API for running scripts in stages of the rendering pipeline independent of the main javascript execution environment.
</p>



	</section>
	<section id="status">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下，この節の他の内容は、<a href="css-common-ja.html#status">~CSS日本語訳~共通~page</a>／冒頭の仕様~metadataに委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

		<section id="motivations">
<h3 title="Motivations">1.1. 動機</h3>

~INFORMATIVE

<p>
`文書~環境@
†内に拡張~地点を定義できるようにするのは、困難である
— 具現化~engineは、~phaseの途中で何が起こり得るかについて，~~従来の前提を放棄する必要があるので。
【†原文による<a href="~HTMLLS/webappapis.html#document-environment">リンク先の定義</a>（~HTML仕様）は、現在は廃されている。】
◎
Allowing extension points defined in the document environment is difficult, as rendering engines would need to abandon previously held assumptions for what could happen in the middle of a phase.
</p>

<p>
例えば具現化~engineは、~layout~phaseの間は，~DOMは改変されないものと見做している。
◎
For example, during the layout phase the rendering engine assumes that no DOM will be modified.
</p>


<p>
加えて、`文書~環境$内に拡張~地点を定義することは、具現化~engineが，`文書~環境$と同じ~thread内で作業を遂行することを制約する。
（具現化~engineが，~thread~joining保証【？】に加えて ~thread安全な~APIも許容するような，複階的, かつ~overheadの高い基盤を追加しない限り）。
◎
Additionally defining extension points in the document environment would restrict rendering engines to performing work in the same thread as the document environment. (Unless rendering engines added complex, high-overhead infrastructure to allow thread-safe APIs in addition to thread joining guarantees).
</p>

<p>
~workletは、具現化~engineが現在~依拠しているものは保証し続けつつ，そのような拡張~地点を具現化~engine内に許容するよう設計されている。
◎
The worklet is designed to allow such extension points in rendering engines, while keeping guarantees which rendering engines rely currently on.
</p>


<p>
~workletは`~web~worker$に類似するが：
◎
Worklets are similar to web workers however they:
</p>

<ul>
	<li>
~threadを問わない。
すなわち、特定0の~thread上で走らすように定義されない。
具現化~engineは、それらを自身が選ぶどこで走らせてもヨイ。
◎
Are thread-agnostic. That is, they are not defined to run on a particular thread. Rendering engines may run them wherever they choose.
</li>
	<li>
並列性の目的で、複数の［
大域~scopeの~instance
］を重複して作成できる。
◎
Are able to have multiple duplicate instances of the global scope created for the purpose of parallelism.
</li>
	<li>
~event~APIに基づかない。
代わりに，いくつかの~classが大域~scopeに登録され、それらの~methodは，~UAにより呼出されることになる。
◎
Are not event API based. Instead classes are registered on the global scope, whose methods are to be invoked by the user agent.
</li>
	<li>
<p>
大域~scope上の~API~surfaceは、抑制される。
</p>
<p class="trans-note">【
`WebIDL$r の用語で述べるならば、 `Exposed$ 拡張属性を通して`~worklet大域~scope$に公開される~interfaceは，他（ ~workerや~window ）に比して限られている。
】</p>
◎
Have a reduced API surface on the global scope.
</li>
	<li>
［
後続の仕様や~UAにより定義される大域~scope
］用として，存続期間がある。
それらは、文書の存続期間に束ねられない。
◎
Have a lifetime for the global scope which is defined by subsequent specifications or user agents. They aren’t tied to the lifetime of the document.
</li>
	<li>
~overheadが他に比して高いので，控えめに利用されるべきである。
そのため、~workletは，別々の~script間で共有されるものと期待される。
このことは、`文書~環境$に類似する。
◎
As worklets have a relatively high overhead, they should be used sparingly. Due to this worklets are expected to be shared between separate scripts. This is similar to the document environment.
</li>
</ul>

		</section>
		<section id="code-idempotency">
<h3 title="Code Idempotency">1.2. ~codeの冪等性</h3>

<p>
~workletを利用する仕様
— 以下、この節を通して，単に %当該~仕様 と記す —
のうち一部のもの（例： `css-paint-api-1$r ）は、各 作業を［
複数の~threadに並列化する ／
必要に応じて別~threadへ移動する
］ことを，~UAに許容する。
◎
Some specifications which use worklets ([css-paint-api-1]), allow user agents to parallelize work over multiple threads, or to move work between threads as required.
</p>

<p>
%当該~仕様 の下で~class上の~methodを呼出す順序は、複数の~UA間で異なるかもしれない。
◎
In these specifications user agents might invoke methods on a class in a different order to other user agents.
</p>

<p>
その結果による~UA間の互換性~riskを防止するため、 %当該~仕様 の~APIを用いて大域~scopeに~classを登録する作者は，~codeを冪等にするべきである。
すなわち，ある~class上の［
1 個以上の~methodが成す組
］は、所与の特定0の入力に対し同じ出力を生産するべきある。
◎
As a result of this, to prevent this compatibility risk between user agents, authors who register classes on the global scope using these APIs, should make their code idempotent. That is, a method or set of methods on a class should produce the same output given a particular input.
</p>

<p>
次に挙げる技法は、 %当該~仕様 が，~codeを冪等な仕方で書くのを作者に促すために利用される：
◎
The following techniques are used in order to encourage authors to write code in an idempotent way:
</p>

<ul>
	<li>
大域~objへの参照-（例： `DedicatedWorkerGlobalScope$I 上の `self$m ）は、持たないようにする。
◎
No reference to the global object, e.g. self on a DedicatedWorkerGlobalScope.
</li>
	<li>
~codeは`~module~script$として読込まれるようになる
— その結果、~codeは， `this^jv を他と共有することなく`~strict-mode$で実行される。
これは、［
複数の~module~scriptが、大域~scope上の共用~objを参照することにより，同じ状態を共有する
］ことを防止する。
◎
Code is loaded as a module script which resulting in the code being executed in strict mode code without a shared this. This prevents two different module scripts sharing state by referencing shared objects on the global scope.
</li>
	<li>
<p>
%当該~仕様 は、次を~UAに要求しなければナラナイ：
</p>
		<ul>
			<li>
`Worklet$I ごとに 2 個~以上の `WorkletGlobalScope$I が常にあること。
</li>
			<li>
ある~class上の［
1 個以上の~methodが成す組
］を 特定0の大域~scopeに~randomにアテガうこと。
</li>
		</ul>
<p>
 %当該~仕様 は、~memoryが拘束された下では，~opt-outを供せる。
</p>
◎
These specifications must require user agents to always have at least two WorkletGlobalScopes per Worklet and randomly assign a method or set of methods on a class to a particular global scope. These specifications can provide an opt-out under memory constraints.
</li>
	<li>
~UAは、 %当該~仕様 が定義する `WorkletGlobalScope$I 【を継承する~interfaceの~instance】を，いつでも作成でき, 破壊できる。
【作成したそれは、関連な `Worklet$I の`~worklet大域~scope~list$wLに追加されることになる。】
◎
User agents can create and destroy WorkletGlobalScopes at any time for these specifications.
</li>
</ul>


		</section>
		<section id="speculative-evaluation">
<h3 title="Speculative Evaluation">1.3. 投機的な評価</h3>


<p>
~workletを利用する一部の仕様（例： `css-paint-api-1$r ）は、~UAの状態に基づいて~class上の~methodを呼出してもヨイ。
複~thread間の同時並行性を高めるため、~UAは，未来にあり得る状態に基づいて，~methodを投機的に呼出してもヨイ。
◎
Some specifications which use worklets ([css-paint-api-1]) may invoke methods on a class based on the state of the user agent. To increase the concurrency between threads, a user agent may invoke a method speculatively, based on potential future states.
</p>


<p>
これらの仕様においては、~UAは，~class上の~methodを［
いつでも，および
~UAの現在の状態に対応するものに限らず 他の引数でも
］呼出して, ~cacheしてもヨイ
— そのような投機的な評価の結果は，即時には表示されないが、~UAの状態が投機された状態に合致するとき，利用できる。
これは、~UAと~worklet~thread間の同時並行性を高めるであろう。
◎
In these specifications user agents might invoke methods on a class at any time, and with any arguments, not just ones corresponding to the current state of the user agent. The results of such speculative evaluations are not displayed immediately, but may be cached for use if the user agent state matches the speculated state. This may increase the concurrency between the user agent and worklet threads.
</p>


<p>
この結果による，~UA間の互換性~riskを防止するため、これらの~APIを用いて大域~scopeに
~classを登録する作者は、自身の~codeを~statelessにするべきである。
すなわち，~methodを呼出すことによる効果は、その結果に限られるべきである
— 変異-可能な状態を更新するような副作用は，一切伴わずに。
◎
As a result of this, to prevent this compatibility risk between user agents, authors who register classes on the global scope using these APIs, should make their code stateless. That is, the only effect of invoking a method should be its result, not any side-effects such as updating mutable state.
</p>

<p>
~code冪等性を促す同じ技法は、~stateless~codeを書くことも，作者に促す。
◎
The same techniques which encourage code idempotence also encourage authors to write stateless code.
</p>



		</section>
	</section>
	<section id="infrastructure">
<h2 title="Infrastructure">2. 基盤</h2>

		<section id="the-global-scope">
<h3 title="The Global Scope">2.1. 大域~scope</h3>

<p>
`WorkletGlobalScope$I ~objは、
`~worklet大域~scope@
を供する。
それは、 `Worklet$I の大域~実行~文脈を表現する。
◎
The WorkletGlobalScope object provides a worklet global scope which represents the global execution context of a Worklet.
</p>

<p class="trans-note">【
<a href="~WORKERS#the-global-scope">~workerのときと同様に</a>，概念的には、［
`WorkletGlobalScope$I ／ `Worklet$I
］が，同じ~workletが［
内側／外側
］に “見せる顔” になる。
】</p>

<pre class="idl">
[`Exposed$=Worklet]
interface `WorkletGlobalScope@I {
};
</pre>

<p>
各 `WorkletGlobalScope$I には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`所有者~文書@wL</dt>
	<dd>
初期~時には ~NULL とする。
それは、`~worklet大域~scopeを作成する$~algoの内側で設定される。
◎
Each WorkletGlobalScope has an assocated owner document. It is initially null and set inside the create a WorkletGlobalScope algorithm.
</dd>
	<dd>
`Document$I ~obj %文書 が【`属する閲覧文脈$が】`破棄され$るときは、
%文書 を`所有者~文書$wLとしているどの `WorkletGlobalScope$I に対しても，その`所有者~文書$wLは ~NULL にされるべきである。
◎
Whenever a Document object is discarded, each WorkletGlobalScope whose owner document is that Document object, should clear its owner document.
</dd>

	<dt>`環境~設定群~obj@wL</dt>
	<dd>
`環境~設定群~obj$。
【`~workletの環境~設定群~objを設定しておく$ときに， `HostDefined^sl に格納される。】
◎
Each WorkletGlobalScope has an associated environment settings object.
</dd>

	<dt>`~module~map@wL</dt>
	<dd>
`~module~map$。
初期~時には空とする。
◎
Each WorkletGlobalScope has an associated module map. It is a module map, initially empty.
</dd>

	<dt>`~worklet大域~scope実行~環境@wL</dt>
	<dd>
この実行~環境は、並列的にしても（すなわち，別々の~thread等
— ~thread, ~process, その他の等価な構成子 —
に分ける）,
それが属する `Worklet$I ~objが他と同じ~thread等に住まうようにしてもヨイ。
どの~thread等に住まうかは、~UAが裁定する。
◎
Each WorkletGlobalScope has a worklet global scope execution environment. This execution environment may be parallel (i.e. it may be on a separate thread, process, or other equivalent construct), or it may live on the same thread or process as the Worklet object it belongs to. Which thread or process it lives on is decided by the user agent.
</dd>
</dl>


<p class="note">注記：
`WorkletGlobalScope$I は、 `DedicatedWorkerGlobalScope$I に比して制限された大域~scopeである。
他の仕様は、 `WorkletGlobalScope$I を拡張するものと期待される
— ［
~UAが 作成して~methodを呼出すための~classを，作者が登録する
］のを許容する~methodを加えることにより（例えば `registerAClass()^m の様な名前の）。
◎
Note: The WorkletGlobalScope has a limited global scope when compared to a DedicatedWorkerGlobalScope. It is expected that other specifications will extend WorkletGlobalScope with registerAClass methods which will allow authors to register classes for the user agent create and invoke methods on.
</p>


<p>
【この仕様において】`例外を報告する$所では、任意選択で，何もしないか, 開発者~consoleに例外を報告する。
◎
When asked to report an exception, do nothing instead, or optionally report the exception to a developer console.
</p>


<p class="issue">
~HTMLによる`例外を報告する$は、
`EventTarget$I でない大域~objでも働けるよう，更新する必要がある。
<a href="~HTMLissue/2611">&lt;~HTMLissue/2611&gt;</a>
◎
HTML’s report an exception needs updating to work with non-EventTarget global objects. &lt;https://github.com/whatwg/html/issues/2611&gt;
</p>



			<section id="the-event-loop">
<h4 title="The event loop">2.1.1. ~event~loop</h4>


<p>
各 `WorkletGlobalScope$I ~objは、個別に`~event~loop$を持つ
— この~event~loopは：
◎
Each WorkletGlobalScope object has a distinct event loop.＼
</p>
<ul>
	<li>
`閲覧文脈$には結付けられない。
◎
This event loop has no associated browsing context.＼
</li>
	<li>
`~worklet大域~scopeを作成する$~algoにより作成される。
◎
The event loop is created by the create a WorkletGlobalScope algorithm.
</li>
	<li>
上で定義した`~worklet大域~scope実行~環境$wL下で走る。
◎
The event loop is run on the worklet global scope execution environment defined above.
</li>
	<li>
それを利用するのは、次に挙げるものに限られるものと予期されている
⇒＃
`addModule()$m に結付けられている~task ／
作者により定義され，~UAが呼出す~callback ／
`小task$
◎
It is expected that only tasks associated addModule(), the user agent invoking author defined callbacks, and microtasks will use this event loop.
</li>
</ul>

<p class="note">注記：
<a href="#event-loop-processing-model">~event~loop処理~model</a>
は，断続的に~loopするものと指定していても、実施上は，実装がそれを行うものとは期待されてはいない。
`小task~queue$は、作者により供された`~callback関数を呼出す$間に，空にされる。
◎
Note: Even through the event loop processing model specifies that it loops continually, practically implementations aren’t expected to do this. The microtask queue is emptied while invoking callback functions provided by the author.
</p>

			</section>
			<section id="creating-a-workletglobalscope">
<h4 title="Creating a WorkletGlobalScope">2.1.2.  `WorkletGlobalScope^I の作成-法</h4>

<div class="algorithm">

<p>
~UAは
`~worklet大域~scopeを作成する@
ときは、所与の
⇒＃
%~worklet大域~scope型,
%~module応答~map,
%外側~設定群,
%資格証~mode
◎終
に対し，次の手続きを走らすモノトスル：
◎
When a user agent is to create a WorkletGlobalScope, given workletGlobalScopeType, moduleResponsesMap, and outsideSettings, it must run the following steps:
</p>

<ol>
	<li>
%~agent ~LET `~worklet~agentを得する$( %外側~設定群 )
⇒
この~agentは、`~worklet大域~scope実行~環境$wLに対応する
— この手続きの以降は、その文脈の下で走らす
◎
Let agent be the result of obtaining a worklet agent given outsideSettings. This agent corresponds to the a worklet global scope execution environment. Run the rest of these steps in that context.
</li>
	<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で、`新たな~JS~realmを作成する$( %~agent )
⇒
大域~obj用には型 %~worklet大域~scope型 の新たな~objを作成する
◎
Let realmExecutionContext be the result of creating a new JavaScript realm given agent and the following customizations:
• For the global object, create a new workletGlobalScopeType object.＼
</li>
	<li>
%~worklet大域~scope ~LET 前~段にて作成した大域~obj
◎
Let workletGlobalScope be the created object.
</li>
	<li>
%内側~設定群 ~LET
`~workletの環境~設定群~objを設定しておく$( %~realm実行~文脈, %外側~設定群 )
◎
Let insideSettings be the result of set up a worklet environment settings object given realmExecutionContext, and outsideSettings.
</li>
	<li>
%~worklet大域~scope の`所有者~文書$wL ~SET %外側~設定群 の`担当の文書$enV
◎
Set workletGlobalScope’s owner document to outsideSettings’s responsible document.
</li>
	<li>
`大域~objの~CSP~listを初期化する$( %~worklet大域~scope, † )
【† 何らかの応答も引数に必要だが、言及されていない】
◎
Invoke the initialize a global object’s CSP list algorithm given workletGlobalScope.
</li>
	<li>
<p>
%~module応答~map 内の~EACH( %~entry ) に対し：
◎
For each entry in the given moduleResponsesMap (in insertion order), run the following substeps:
</p>
		<ol>
			<li>
%~module~URL~record ~LET %~entry の~key
◎
Let moduleURLRecord be entry’s key.
</li>
			<li>
%~script ~LET 次を走らせて`非同期に完了する$まで待機した結果の`~module~script$
⇒
`~worklet~scriptを~fetchする$(
%~module~URL~record,
【 %行先 を成す引数が指定されていない】,
%~module応答~map,
%資格証~mode,
%外側~設定群,
%内側~設定群
)
◎
Let script be the result of fetch a worklet script given moduleURLRecord, moduleResponsesMap, outsideSettings, and insideSettings when it asynchronously completes.
</li>
			<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
		</ol>

<p class="note">注記：
この段において`~worklet~scriptを~fetchする$ときには、実際に~network要請が遂行されることはない
— 対する応答は、~workletの`~module応答~map$wL内に~cache済みなので。
また、構文解析~errorにもならない
— この時点では、別の~worklet大域~scopeにより成功裡に構文解析されているはずなので。
すなわち、ここで %~script が ~NULL になることは，決してないはずである。
◎
Note: Fetch a worklet script won’t actually perform a network request as it will hit the worklet’s module responses map. It also won’t have a parsing error as at this point it should have successfully been parsed by another worklet global scope. I.e. script should never be null here.
</p>
	</li>
	<li>
%内側~設定群 により指定される`担当の~event~loop$enVを走らす
◎
Run the responsible event loop specified by insideSettings.
</li>
</ol>
</div>


			</section>
			<section id="script-settings-for-worklets">
<h4 title="Script settings for worklets">2.1.3. ~worklet用の~script設定群</h4>

<div class="algorithm">

<p>
`~workletの環境~設定群~objを設定しておく@
ときは、所与の
( %実行~文脈, %外側~設定群 )
に対し，次の手続きを走らすモノトスル：
◎
When a user agent is to set up a worklet environment settings object, given a executionContext, and outsideSettings, it must run the following steps:
</p>
<ol>
	<li>
%生成元 ~LET 一意かつ`不透明な生成元$
◎
Let origin be a unique opaque origin.
</li>
	<li>
%継承される~API用~基底~URL ~LET %外側~設定群 の`~API用~基底~URL$enV
◎
Let inheritedAPIBaseURL be outsideSettings’s API base URL.
</li>
	<li>
%継承される~referrer施策 ~LET %外側~設定群 の`~referrer施策$enV
◎
Let inheritedReferrerPolicy be outsideSettings’s referrer policy.
</li>
	<li>
%継承される埋込元~施策 ~LET %外側~設定群 の`埋込元~施策$enV
◎
Let inheritedEmbedderPolicy be outsideSettings’s embedder policy.
</li>
	<li>
%~realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of executionContext’s Realm component.
</li>
	<li>
%~worklet大域~scope ~LET %~realm の`大域~obj$rM
◎
Let workletGlobalScope be realm’s global object.
</li>
	<li>
<p>
%設定群~obj ~LET 各種~algoが次のように定義される，新たな`環境~設定群~obj$：
◎
Let settingsObject be a new environment settings object whose algorithms are defined as follows:
</p>
		<ul>
			<li>
`~realm実行~文脈$enV
⇒
~RET %実行~文脈
◎
The realm execution context
• Return executionContext.
</li>
			<li>
`~module~map$enV
⇒
~RET %~worklet大域~scope の`~module~map$wL
◎
The module map.
• Return workletGlobalScope’s module map.
</li>
			<li>
`担当の文書$enV
⇒
適用-可能でない
◎
The responsible document
• Not applicable
</li>
			<li>
`~API用~URL文字~符号化法$enV
⇒
~RET `UTF-8$
◎
The API URL character encoding
• Return UTF-8.
</li>
			<li>
`~API用~基底~URL$enV
⇒
~RET %継承される~API用~基底~URL
◎
The API base URL
• Return inheritedAPIBaseURL.
</li>
			<li>
`生成元$enV
⇒
~RET %生成元
◎
The origin
• Return origin.
</li>
			<li>
`~referrer施策$enV
⇒
~RET %継承される~referrer施策
◎
The referrer policy
• Return inheritedReferrerPolicy.
</li>
			<li>
`埋込元~施策$enV
⇒
~RET %継承される埋込元~施策
◎
The embedder policy
• Return inheritedEmbedderPolicy.
</li>
		</ul>
	</li>
	<li>
%設定群~obj の
⇒＃
`~id$enV ~SET 新たな一意かつ不透明な文字列,
`作成時の~URL$enV ~SET %継承される~API用~基底~URL,
`~top-level作成時の~URL$enV ~SET ~NULL,
`~top-level生成元$enV ~SET %外側~設定群 の`~top-level生成元$enV
`~target閲覧文脈$enV ~SET ~NULL,
`作動中の~sw$enV ~SET ~NULL
◎
Set settingsObject’s id to a new unique opaque string, creation URL to inheritedAPIBaseURL, top-level creation URL to null, top-level origin to outsideSettings’s top-level origin, target browsing context to null, and active service worker to null.
</li>
	<li>
%~realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm’s [[HostDefined]] field to settingsObject.
</li>
	<li>
~RET %設定群~obj
◎
Return settingsObject.
</li>
</ol>

</div>


<p class="issue">
これを，`~workerの環境~設定群~objを設定しておく$~algoに併合する。
◎
Merge this with https://html.spec.whatwg.org/multipage/workers.html#set-up-a-worker-environment-settings-object
</p>



			</section>
		</section>
		<section id="worklet-section">
<h3 title="Worklet">2.2. ~worklet</h3>


<p>
`Worklet$I ~objは、
結付けられている `WorkletGlobalScope$I の中に， 1 個~以上の~module~scriptを追加する能力を供する。
~UAは、
`WorkletGlobalScope$I に登録された各~classを作成して，それらの~methodを呼出せるようになる。
◎
The Worklet object provides the capability to add module scripts into its associated WorkletGlobalScopes. The user agent can then create classes registered on the WorkletGlobalScopes and invoke their methods.
</p>


<pre class="idl">
[`Exposed$=Window]
interface `Worklet@I {
    [`NewObject$] Promise&lt;`undefined$&gt; `addModule$m(
      USVString %moduleURL,
      optional `WorkletOptions$I %options = {}
    );
};

dictionary `WorkletOptions@I {
    `RequestCredentials$I `credentials@m = "same-origin";
};
</pre>


<p>
各 `Worklet$I ~objは、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~worklet大域~scope型@wL</dt>
	<dd>
`WorkletGlobalScope$I を`継承-$する~interface型（例： `PaintWorkletGlobalScope$I ）。
新たな `WorkletGlobalScope$I ~objを作成するときに利用される。
◎
A Worklet has a worklet global scope type. This is used for creating new WorkletGlobalScope and the type must inherit from WorkletGlobalScope.
◎
Note: As an example the worklet global scope type might be a PaintWorkletGlobalScope.
</dd>

	<dt>`~worklet大域~scope~list@wL</dt>
	<dd>
【`~worklet大域~scope型$wLの~objの~list。】
初期~時には空とする。
この~listは、~UAが新たな<!-- its＊ --> `WorkletGlobalScope$I ~objを作成することを選んだときに拡充される。
◎
A Worklet has a list of the worklet’s WorkletGlobalScopes. Initially this list is empty; it is populated when the user agent chooses to create its WorkletGlobalScope.
</dd>

	<dt>`~worklet行先~種別@wL</dt>
	<dd>
これは、`~module~worker~script~graphを~fetchする$ときに，`要請$の`行先$rqを設定するために利用される。
◎
A Worklet has a worklet destination type. This is used for setting the destination requests from fetch a module worker script graph.
</dd>

	<dt>`~module応答~map@wL</dt>
	<dd>
`有順序~map$。
その各~entryは、~module~URLを`~fetch$応答に対応付ける。
~entryたちの順序は挿入-順になる。
この~mapへの~accessは、~thread安全になるべきある。
◎
A Worklet has a module responses map. This is a ordered map of module URLs to values that are a fetch responses. The map’s entries are ordered based on their insertion order. Access to this map should be thread-safe.
</dd>
	<dd>
この~mapは、異なる時点に作成される `WorkletGlobalScope$I が［
同じ~script~source~textの集合を包含し，挙動が同じになる
］ことを確保するために存在する。
追加的な `WorkletGlobalScope$I ~objの作成は、作者からは透過的になるべきである。
◎
The module responses map exists to ensure that WorkletGlobalScopes created at different times contain the same set of script source text and have the same behaviour. The creation of additional WorkletGlobalScopes should be transparent to the author.
</dd>
	<dd class="note">
<p>注記：
実施上は、 `addModule()$m の~algoを実装する際に~thread安全な~mapを利用することは，~UAに期待されていない。
~UAは代わりに，その~methodが~callされたとき、~main~thread上で~module~graphを~fetchして，~fetchされた~source（`~module応答~map$wL内に包含される~data）を
`WorkletGlobalScope$I を有する各~threadに送信できる。
◎
Practically user agents aren’t expected to implement the following algorithm using a thread-safe map. Instead when addModule() is called user agents can fetch the module graph on the main thread, and send the fetched sources (the data contained in the module responses map) to each thread which has a WorkletGlobalScope.
</p>

<p>
~UAは，新たな `WorkletGlobalScope$I を作成したいと望む場合には、単純に［
~main~threadから~fetchされたすべての~sourceからなる~list
］を［
`WorkletGlobalScope$I を所有している~thread
］へ送信できる。
◎
If the user agent wishes to create a new WorkletGlobalScope it can simply sent the list of all fetched sources from the main thread to the thread which owns the WorkletGlobalScope.
</p>
	</dd>
</dl>

<p>
`処理待ち~task構造体@
は、次のものからなる`構造体$である：
◎
A pending tasks struct is a struct consisting of:
</p>

<ul>
	<li>
`計数@
— これは、下の~algoにより利用される。
【これ一つしかないのに構造体で包装している理由は、整数~値をとる計数を参照として渡せるようにするため。】
◎
A counter.
◎
This is used by the algorithms below.
</li>
</ul>

<div class="algorithm">

<p class="idl">
`Worklet$I ~objの
`addModule(moduleURL, options)@m
~method手続きは：
◎
When the addModule(moduleURL, options) method is called on a Worklet object, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
◎
Let worklet be this Worklet.
</li>
	<li>
%外側~設定群 ~LET 此れに`関連な設定群~obj$
◎
Let outsideSettings be the relevant settings object of this.
</li>
	<li>
%~module~URL~record ~LET %moduleURL を %外側~設定群 に`相対的に構文解析-$した`結果の~URL~record$
<!-- ＊原文誤（ ~CSSSYN#css-parse-something-according-to-a-css-grammar ） -->
◎
Let moduleURLRecord be the result of parsing the moduleURL argument relative to outsideSettings.
</li>
	<li>
~IF［
%~module~URL~record ~EQ `失敗^i
］
⇒＃
`SyntaxError$E 例外で %~promise を`却下する$；
~RET %~promise
◎
If moduleURLRecord is failure, then reject promise with a "SyntaxError" DOMException and return promise.
</li>
	<li>
~RET %~promise
— ただし、この~algoは`並列的$に継続する
◎
Return promise, and then continue running this algorithm in parallel.
</li>
	<li>
%資格証~mode ~LET %options の `credentials$m ~member
◎
Let credentialOptions be the credentials member of options.
</li>
	<li>
%~module応答~map ~LET 此れの`~module応答~map$wL
◎
Let moduleResponsesMap be worklet’s module responses map.
</li>
	<li>
%~worklet大域~scope型 ~LET 此れの`~worklet大域~scope型$wL
◎
Let workletGlobalScopeType be worklet’s worklet global scope type.
</li>
	<li>
%行先 ~LET %~worklet の`~worklet行先~種別$wL
◎
Let destination be worklet’s worklet destination type.
</li>
	<li>
%大域~scope~list ~LET 此れの`~worklet大域~scope~list$wL
◎
↓</li>
	<li>
<p>
~IF［
%大域~scope~list は空である
］：
◎
If the worklet’s WorkletGlobalScopes is empty, run the following steps:
</p>
		<ol>
			<li>
%O ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
`~worklet大域~scopeを作成する$(
%~worklet大域~scope型,
%~module応答~map,
%外側~設定群,
%資格証~mode
)
◎
Create a WorkletGlobalScope given workletGlobalScopeType, moduleResponsesMap, and outsideSettings.
</li>
			<li>
%大域~scope~list に %O を追加する
◎
Add the WorkletGlobalScope to worklet’s WorkletGlobalScopes.
</li>
		</ol>

<p>
~UAは、~workletの型に依存して，この時点で追加的な `WorkletGlobalScope$I を作成してもヨイ。
◎
Depending on the type of worklet the user agent may create additional WorkletGlobalScopes at this time.
</p>

<p class="note">注記：
特定的には、
`css-paint-api-1$r は 複数の大域~scopeを許容する一方で，
`webaudio$r ~APIは許容しない。
◎
Note: Specifically the [css-paint-api-1] allows for multiple global scopes, while the [webaudio] API does not.
◎
↑↑Wait for this step to complete before continuing.
</p>

</li>
	<li>
%処理待ち~task構造体 ~LET 次のように初期化された，新たな`処理待ち~task構造体$
⇒
`計数$ ~SET `~worklet大域~scope~list$wLの長さ
◎
Let pendingTaskStruct be a new pending tasks struct with counter initialized to the length of worklet’s WorkletGlobalScopes.
</li>
	<li>
`~worklet大域~scope~list$wL内の~EACH( %~worklet大域~scope ) に対し
⇒
%~worklet大域~scope
【<a href="#the-event-loop">の~event~loop</a>】
の中で，次を走らす`~taskを~queueする$
⇒
`~worklet~scriptを~fetchして呼出す$(
%~worklet大域~scope,
%~module~URL~record,
%行先,
%~module応答~map,
%資格証~mode,
%外側~設定群,
%処理待ち~task構造体,
%~promise
)
◎
For each workletGlobalScope in the worklet’s WorkletGlobalScopes, queue a task on the workletGlobalScope to fetch and invoke a worklet script given workletGlobalScope, moduleURLRecord, destination, moduleResponsesMap, credentialOptions, outsideSettings, pendingTaskStruct, and promise.
</li>
</ol>

<p class="note">注記：
%~promise は、`~worklet~scriptを~fetchして呼出す$~algoの中で［
却下- ／ 解決-
］される。
◎
Note: The rejecting and resolving of the promise occurs within the fetch and invoke a worklet script algorithm.
</p>
</div>

<div class="algorithm">

<p>
`~worklet~scriptを~fetchして呼出す@
ときは、所与の
⇒＃
%~worklet大域~scope,
%~module~URL~record,
%行先,
%~module応答~map,
%資格証~mode,
%外側~設定群,
%処理待ち~task構造体,
%~promise
◎終
に対し，次の手続きを走らすモノトスル：
◎
When the user agent is to fetch and invoke a worklet script given workletGlobalScope, moduleURLRecord, destination, moduleResponsesMap, credentialOptions, outsideSettings, pendingTaskStruct, and promise, the user agent must run the following steps:
</p>

<p class="note">注記：
この~algoは、`~worklet大域~scope実行~環境$wLの中で走ることになる。
◎
Note: This algorithm is to be run within the worklet global scope execution environment.
</p>

<ol>
	<li>
%内側~設定群 ~LET %~worklet大域~scope の`環境~設定群~obj$wL
◎
Let insideSettings be the workletGlobalScope’s associated environment settings object.
</li>
	<li>
%~script ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
`~worklet~scriptを~fetchする$(
%~module~URL~record,
%行先,
%~module応答~map,
%資格証~mode,
%外側~設定群,
%内側~設定群
)
◎
Let script by the result of fetch a worklet script given moduleURLRecord, destination, moduleResponsesMap, credentialOptions, outsideSettings, and insideSettings when it asynchronously completes.
</li>
	<li>
<p>
~IF［
%~script ~EQ ~NULL
］
⇒
%外側~設定群 の`担当の~event~loop$enVの中で，次を走らす`~taskを~queueする$：
◎
If script is null, then queue a task on outsideSettings’s responsible event loop to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
%処理待ち~task構造体 の`計数$ ~NEQ −1
］：
◎
If pendingTaskStruct’s counter is not -1, then run these steps:
</p>
				<ol>
					<li>
%処理待ち~task構造体 の`計数$ ~SET −1
◎
Set pendingTaskStruct’s counter to -1.
</li>
					<li>
`AbortError$E 例外で %~promise を`却下する$
◎
Reject promise with an "AbortError" DOMException.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~error ~LET %~script の`再投出-用~error$
◎
↓</li>
	<li>
<p>
~IF［
%~error ~NEQ ~NULL
］
⇒
%外側~設定群 の`担当の~event~loop$enVの中で，次を走らす`~taskを~queueする$：
◎
If script’s error to rethrow is not null, then queue a task on outsideSettings’s responsible event loop given script’s error to rethrow to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
%処理待ち~task構造体 の`計数$ ~NEQ −1
］：
◎
If pendingTaskStruct’s counter is not -1, then run these steps:
</p>
				<ol>
					<li>
%処理待ち~task構造体 の`計数$ ~SET −1
◎
Set pendingTaskStruct’s counter to -1.
</li>
					<li>
%~error で %~promise を`却下する$
◎
Reject promise with error to rethrow.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
	<li>
<p>
%外側~設定群 の`担当の~event~loop$enVの中で，次を走らす`~taskを~queueする$：
◎
Queue a task on outsideSettings’s responsible event loop to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
%処理待ち~task構造体 の`計数$ ~NEQ −1
］：
◎
If pendingTaskStruct’s counter is not -1, then run these steps:
</p>
				<ol>
					<li>
%処理待ち~task構造体 の`計数$ ~DECBY 1
◎
Decrement pendingTaskStruct’s counter by 1.
</li>
					<li>
~IF［
%処理待ち~task構造体 の`計数$ ~EQ 0
］
⇒
%~promise を`解決する$
◎
If pendingTaskStruct’s counter is 0, then resolve promise.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">

<p>
`~worklet~scriptを~fetchする@
ときは、所与の
⇒＃
%~module~URL~record,
%行先,
%~module応答~map,
%資格証~mode,
%外側~設定群,
%内側~設定群
◎終
に対し，次を走らすモノトスル： 
◎
When the user agent is to fetch a worklet script given moduleURLRecord, destination, moduleResponsesMap, credentialOptions, outsideSettings, and insideSettings, the user agent must run the following steps:
</p>

<p class="note">注記：
この~algoは、`~worklet大域~scope実行~環境$wLの中で走ることになる。
◎
Note: This algorithm is to be run within the worklet global scope execution environment.
</p>
<ol>
	<li>
<p>
%~fetch ~LET 次を走らす手続き
⇒
`~module~worker~script~graphを~fetchする$(
%~module~URL~record,
%外側~設定群,
%行先,
%資格証~mode,
%内側~設定群
)
— 加えて、次に与える`~fetchを遂行する$手続きも渡す
◎
Fetch a module worker script graph given moduleURLRecord, outsideSettings, destination, credentialOptions, and insideSettings.
</p>

<p>
手続きは、所与の
( %要請 )
に対し，次を遂行する：
◎
To perform the fetch given request, perform the following steps:
</p>
		<ol>
			<li>
%~cache ~LET %~module応答~map
◎
Let cache be the moduleResponsesMap.
</li>
			<li>
%~url ~LET %要請 の`~URL$rq
◎
Let url be request’s url.
</li>
			<li>
~IF［
%~cache[ %~url ] ~EQ `fetching^l
］
⇒
%~cache[ %~url ] が変化するまで待機する
◎
If cache contains an entry with key url whose value is "fetching", wait until that entry’s value changes, then proceed to the next step.
</li>
			<li>
~IF［
%~cache[ %~url ] ~NEQ ε
］
⇒
%~cache[ %~url ] を結果として，`非同期に完了する$
◎
If cache contains an entry with key url, asynchronously complete this algorithm with that entry’s value, and abort these steps.
</li>
			<li>
%~cache[ %~url ] ~SET `fetching^l
◎
Create an entry in cache with key url and value "fetching".
</li>
			<li>
%応答 ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
%要請 を`~fetch$する
◎
Fetch request.
◎
Let response be the result of fetch when it asynchronously completes.
</li>
			<li>
%~cache[ %~url ] ~SET %応答
◎
Set the value of the entry in cache whose key is url to response, and＼
</li>
			<li>
%応答 を結果として`非同期に完了する$
◎
asynchronously complete this algorithm with response.
</li>
		</ol>
	</li>
	<li>
~RET %~fetch を遂行して，`非同期に完了する$まで待機した結果
◎
Return the result of fetch a module worker script graph when it asynchronously completes.
</li>
</ol>

</div>


<p class="note">注記：
特定的には、［
~scriptを構文解析する ／
~network越しに読込む
］のに失敗した場合，~promiseは却下されることになる。
~promiseを最初に評価する間に，~scriptが~errorを投出した場合、解決されることになる
— それが解決される値を与える~classが、正しく登録されていたなら。
<!-- as a classes＊？ -->
◎
Note: Specifically, if a script fails to parse or fails to load over the network, it will reject the promise. If the script throws an error while first evaluating the promise it will resolve as a classes may have been registered correctly.
</p>

<div class="example">

<p>
作者が `Worklet$I の中に~codeを追加するとき、その~codeは，複数の `WorkletGlobalScope$I 上で走ることにもなり得る。
例えば：
◎
When an author adds code into a Worklet the code may run against multiple WorkletGlobalScopes, for example:
</p>

<pre class="lang-js">
// script.js
console.log('Hello from a WorkletGlobalScope!');
</pre>


<pre class="lang-js">
// main.js
await CSS.paintWorklet.addModule('script.js');
</pre>

<p>
~UAは、舞台裏では， `script.js^c を 4 個の大域~scopeの中に読込んでもヨイ
— その事例では、~UAの~debug用~toolは，次を~printすることになる：
◎
Behind the scenes the user agent may load the script.js into 4 global scopes, in which case the debugging tools for the user agent would print:
</p>


<pre class="lang-js">
[paintWorklet#1] Hello from a WorkletGlobalScope!
[paintWorklet#4] Hello from a WorkletGlobalScope!
[paintWorklet#2] Hello from a WorkletGlobalScope!
[paintWorklet#3] Hello from a WorkletGlobalScope!
</pre>

<p>
~UAが，この例の `WorkletGlobalScope$I #3 を~killして開始し直すものと裁定した場合、その開始-時に，~debug用~tool内に再度
`[paintWorklet#3] Hello from a WorkletGlobalScope!^c
を~printすることになる。
◎
If the user agent decided to kill and restart a WorkletGlobalScope number 3 in this example, it would print [paintWorklet#3] Hello from a WorkletGlobalScope! again in the debugging tools when this occurs.
</p>
</div>


<p class="issue">
`WorkletGlobalScope$I の中に ~codeを宣言的に読込む能が必要。
<a href="https://github.com/w3c/css-houdini-drafts/issues/47">&lt;https://github.com/w3c/css-houdini-drafts/issues/47&gt;</a>
◎
Need ability to load code into a WorkletGlobalScope declaratively. &lt;https://github.com/w3c/css-houdini-drafts/issues/47&gt;
</p>



		</section>
		<section id="lifetime-of-the-worklet">
<h3 title="Lifetime of the Worklet">2.3. ~workletの存続期間</h3>


<p>
`Worklet$I の存続期間は、それが属する~obj
— 例えば `Window$I —
に束ねられる。
◎
The lifetime of a Worklet is tied to the object it belongs to, for example the Window.
</p>

<p>
`WorkletGlobalScope$I を継承する~interface %A を定義する仕様は：
◎
↓</p>

<ul>
	<li>
%A の存続期間を定義するべきである。
◎
The lifetime of a WorkletGlobalScope should be defined by subsequent specifications which inherit from WorkletGlobalScope.
</li>
	<li>
%A を いつでも終了できるものと定義してもヨイ
— 特に、処理待ち演算が無い場合や, ［
課される時間~制限sを超過するような，無限~loopや~callback
］などの異常な演算が検出された場合には。
◎
Subsequent specifications may define that a WorkletGlobalScope can be terminated at any time particularly if there are no pending operations, or detects abnormal operation such as infinite loops and callbacks exceeding imposed time limits.
</li>
</ul>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">3. ~securityの考慮点</h2>


<p class="issue">
~workletを~secureでない文脈にも許容するかどうか, 等々を裁定する必要がある
<a href="https://github.com/w3c/css-houdini-drafts/issues/92">&lt;https://github.com/w3c/css-houdini-drafts/issues/92&gt;</a>
◎
Need to decide if to allow worklets for unsecure context, etc. &lt;https://github.com/w3c/css-houdini-drafts/issues/92&gt;
</p>



	</section>
	<section class="example" id="examples">
<h2 title="Examples">4. 例</h2>

~INFORMATIVE

<p>
以下の例では、~window上で `FakeWorklet^I （“~fakeの” ~worklet ）を利用する。
◎
For these examples we’ll use a fake worklet on window.
</p>

<div><!--  class="example" -->

<pre class="idl">
partial interface Window {
  [SameObject] readonly attribute Worklet fakeWorklet1;
  [SameObject] readonly attribute Worklet fakeWorklet2;
};
</pre>


<pre class="idl">
[`Global$=(Worklet,FakeWorklet),Exposed=FakeWorklet]
interface FakeWorkletGlobalScope : `WorkletGlobalScope$I {
    undefined【！void】 `registerAnArbitaryClass^m(DOMString %type, Function %classConstructor);
};
</pre>


<p>
各 `FakeWorkletGlobalScope^I は、
`登録-済み~class構築子~map@
を持つ。
◎
Each FakeWorkletGlobalScope has a map of the registered class constructors map.
</p>

<p>
`registerAnArbitaryClass(type, classConstructor)^m
~methodが~callされたとき、~UAは，`登録-済み~class構築子~map$に型 %type の %classConstructor を追加することになる。
◎
When the registerAnArbitaryClass(type, classConstructor) method is called, the user agent will add the classConstructor of type to the map of registered class constructors map.
</p>

</div>

		<section id="example-single">
<h3 title="Loading scripts into a worklet.">4.1. ~workletの中へ~scriptを読込むとき</h3>

<pre class="lang-js">
window.fakeWorklet1.addModule('script1.js');
window.fakeWorklet1.addModule('script2.js');

/* <span class="comment">
他からは `fakeWorklet1^c は~callされていないとするなら、次のいずれも，~scriptを読込む妥当な順序になる：
◎
Assuming no other calls to fakeWorklet1 valid script loading orderings are:
</span> */
// 1. 'script1.js', 'script2.js'
// 2. 'script2.js', 'script1.js'
</pre>



		</section>
		<section id="example-multiple">
<h3 title="Loading scripts into multiple worklets.">4.2. 複数の~workletの中へ~scriptを読込むとき</h3>


<pre class="lang-js">
Promise.all([
    window.fakeWorklet1.addModule('script1.js'),
    window.fakeWorklet2.addModule('script2.js')
]).then(function() {
    /* <span class="comment">
両~scriptの~codeとも読込まれたので，ここで それらに依拠する~taskを行える。
◎
Both scripts now have loaded code, can do a task which relies on this.
</span> */
});
</pre>


		</section>
		<section id="example-class">
<h3 title="Create a registered class and invoke a method.">4.3. 登録-済み~classを作成して~methodを呼出す</h3>

<pre class="lang-js">
/* <span class="comment">
`FakeWorkletGlobalScope^I の内側
◎
Inside FakeWorkletGlobalScope
</span> */
registerAnArbitaryClass('key', class FooClass {
    process(%arg) {
        return !%arg;
    }
});
</pre>


<p>
例として，~UAが 新たな~class~instance上で `process^m を呼出したいと求めるなら、次の手続きに従うこともできる
◎
As an example, if the user agent wants to invoke "process" on a new class instance, the user agent could follow the following steps:
</p>

<ol>
	<li>
<p>
%~worklet大域~scope ~LET 当の~fake `Worklet$I の`~worklet大域~scope~list$wLからの `FakeWorkletGlobalScope^I
【複数あり得るので、~UAが適切などれかを選ぶことになる。】
◎
Let workletGlobalScope be a FakeWorkletGlobalScope from the list of worklet’s WorkletGlobalScopes from the fake Worklet.
</p>

<p>
~UAは、次を行った上で，その結果を利用しても<em>ヨイ</em>
⇒
~fake `Worklet$I を与える下で `~worklet大域~scopeを作成する$
◎
The user agent may also create a WorkletGlobalScope given the fake Worklet and use that.
</p>

	</li>
	<li>
%~class構築子 ~LET `登録-済み~class構築子~map$[ `key^l ]
◎
Let classCtor be the result of performing a lookup in registered class constructors map with "key" as the key.
</li>
	<li>
%~class~instance ~LET `Construct$jA( %~class構築子 )
◎
Let classInstance be the result of Construct(classCtor).
</li>
	<li>
%結果 ~LET `Invoke$jA( %~class~instance, `process^l, « `true^l » )
◎
Let result be the result of Invoke(O=classInstance, P="process", Arguments=["true"]).
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

		</section>
	</section>
</main></div>
