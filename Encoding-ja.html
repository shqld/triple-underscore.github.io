<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard — 符号化法 標準（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

.label {
	color: #666;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: black;
}

code > dfn {
	color: inherit;
}

.code-point,
.hex-value {
	font-family: sans-serif0, sans-serif;
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend > tr > :first-child > div {
	box-sizing: border-box;
	width: 2em;
	height: 2em;
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}



@supports (display: grid) and (display: contents) {

#_index_list {
	min-width: 30em;
	max-width: 70em;
}

#_index_list tr {
	grid-template-areas:
		"名前 索引 視覚化 被覆域"
		"名前 備考 備考 備考"
	;
	grid-template-columns: 10em 1fr 1fr 1fr;
}

#_index_list tr > *:nth-child(1) {
	grid-area: 名前;
	border-left-width: 0;
}

#_index_list tr > *:nth-child(2) {
	grid-area: 索引;
}

#_index_list tr > *:nth-child(3) {
	grid-area: 視覚化;
}

#_index_list tr > *:nth-child(4) {
	grid-area: 被覆域;
}

#_index_list tr > *:nth-child(5) {
	grid-area: 備考;
}

}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#refs${key}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'lb': // label
	text = `"<code class="label">${text}</code>"`;
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = `#${key.toLowerCase()}`;
	break;
case 'U': // Unicode code point
	text = `U+${key}`;
	break;
case 'X': // byte value
	text = `0x${key}`;
	break;
case 'sl': // internal slot
	text = `[[${key}]]`;
	break;
case 'idx':
	return idx_html(key);
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}

	function idx_html(key){
		const k = key.toLowerCase();
		const url = 'https://encoding.spec.whatwg.org/';

		let txt = `
<a href="${url}index-${k}.txt">index-${k}.txt</a>`;
		let vis = `
<td><a href="${url}${k}.html">索引 <b class="ename">${key}</b> 視覚-化</a>`;
		let cover = `
<td><a href="${url}${k}-bmp.html">索引 <b class="ename">${key}</b> BMP 被覆域</a>`;

		switch(key){
			case 'jis0208':
				vis += `,
<a href="${url}shift_jis.html">索引~Shift_JIS視覚-化</a>`;
			break;
			case 'gb18030-ranges':
			case 'iso-2022-jp-katakana':
				vis = cover = '<td>';
			break;
//			case 'ISO-8859-8-I'
		}

		return txt + vis + cover;
	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Encoding
spec_date:2019-02-11
trans_update:2019-01-10
source_checked:180823
spec_status:LS
original_url:https://encoding.spec.whatwg.org/
ref_id_prefix:refs
copyright:2019,whatwg
trans_1st_pub:2012-10-22


●●class_map
E:error
n:ename
U:code-point
X:hex-value
sl:js-slot
jA:abstract
jv:js-value

●●tag_map
I:code
m:code
E:code
n:b
U:span
X:span
i:i
i1:i
V:var
sl:span
jA:span
jv:code

●●link_map


	●IDL
Exposed:~WEBIDL#Exposed

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncoderEncodeIntoResult:#dictdef-textencoderencodeintoresult
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

I.GenericTransformStream:#generictransformstream
I.TextDecoderCommon:#textdecodercommon
I.TextDecoderStream:#textdecoderstream
I.TextEncoderCommon:#textencodercommon
I.TextEncoderStream:#textencoderstream

I.ReadableStream:~STREAMS#rs-class
I.WritableStream:~STREAMS#ws-class
I.TransformStream:~STREAMS#ts-class

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
unsigned long long:~WEBIDL#idl-unsigned-long-long

m.TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.TextEncoder:#dom-textencoder
m.decode:#dom-textdecoder-decode
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode
m.encodeInto:#dom-textencoder-encodeinto

m.read:#dom-textencoderencodeintoresult-read
m.written:#dom-textencoderencodeintoresult-written

m.TextEncoderStream:#dom-textencoderstream
m.TextDecoderStream:#dom-textdecoderstream
m.readable:#dom-generictransformstream-readable
m.writable:#dom-generictransformstream-writable

m.pipeThrough:~STREAMS#rs-pipe-through

mb.fatal:#dom-textdecoderoptions-fatal
mb.ignoreBOM:#dom-textdecoderoptions-ignorebom

mb.stream:#dom-textdecodeoptions-stream

	%input:#dom-textdecoder-decode-input-options-input
	%label:#dom-textdecoder-textdecoder-label-options-label
	%label:#dom-textdecoderstream-textdecoderstream-label-options-label
	%options:#dom-textdecoder-decode-input-options-options
	%options:#dom-textdecoder-textdecoder-label-options-options
	%options:#dom-textdecoderstream-textdecoderstream-label-options-options

	●

~byte:~INFRA#byte
~ASCII~byte:~INFRA#ascii-byte
~cp:~INFRA#code-point
~scalar値:~INFRA#scalar-value
~ASCII~cp:~INFRA#ascii-code-point
~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII小文字~化する:~INFRA#ascii-lowercase
byte.長さ:~INFRA#byte-sequence-length

~encoding:#encoding
名前:#name
~label:#label
~decoder:#decoder
~Unicodeに~decodeする:#decode
~UTF-8~decodeする:#utf-8-decode
~BOMはそのままに~UTF-8~decodeする:#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8~decodeする:#utf-8-decode-without-bom-or-fail
~UTF-8~encodeする:#utf-8-encode
~encodingを利用して~encodeする:#encode
~encoder:#encoder
~handler:#handler
~error~mode:#error-mode
~error:#error
完遂d:#finished
継続-:#continue
~EoS:#end-of-stream
~labelから~encodingを取得する:#concept-encoding-get
~encodingから出力~encodingを取得する:#get-an-output-encoding
~token:#concept-token
~stream:#concept-stream
~tokenを読取る:#concept-stream-read
前付加する:#concept-stream-prepend
前付加-:#concept-stream-prepend
~pushする:#concept-stream-push
走らす:#concept-encoding-run
~tokenを処理する:#concept-encoding-process

	●
索引:#index
索引~cp:#index-code-point
索引~pointer:#index-pointer
索引~Big5~pointer:#index-big5-pointer
索引~Big5:#index-big5
索引~EUC-KR:#index-euc-kr
索引~jis0208:#index-jis0208
索引~jis0212:#index-jis0212
索引~Shift_JIS~pointer:#index-shift_jis-pointer
索引~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
索引~gb18030範囲集:#index-gb18030-ranges
索引~gb18030範囲集~cp:#index-gb18030-ranges-code-point
索引~gb18030範囲集~pointer:#index-gb18030-ranges-pointer

索引~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8出現~byte数:#utf-8-bytes-seen
~UTF-8要~byte数:#utf-8-bytes-needed
~UTF-8下限:#utf-8-lower-boundary
~UTF-8上限:#utf-8-upper-boundary

単byte~encoding:#single-byte-encoding
単byte索引:#index-single-byte


	●名前
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

	●encoder／decoder IDL
dec.~encoding:#textdecoder-encoding
dec.~decoder:#textdecoder-decoder
dec.~stream:#textdecoder-stream
dec.~BOMignore~flag:#textdecoder-ignore-bom-flag
dec.~BOMseen~flag:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode
dec.~no_flush~flag:#textdecoder-do-not-flush-flag
dec.~streamを直列化する:#concept-td-serialize

ts.~decoder:#textdecoderstream-decoder
ts.~encoder:#textencoderstream-encoder
ts.~stream:#textdecoderstream-stream

~cuを~scalar値に変換する:#convert-code-unit-to-scalar-value
~chunkを~decodeして~enqueueする:#decode-and-enqueue-a-chunk
~chunkを~encodeして~enqueueする:#encode-and-enqueue-a-chunk
~encodeして一掃する:#encode-and-flush
一掃して~enqueueする:#flush-and-enqueue

処理待ち高位~surrogate:#textencoderstream-pending-high-surrogate
形式変換:#generictransformstream-transform


	●各種 encoder／decoder

~UTF-8~decoder:#utf-8-decoder
~UTF-8~encoder:#utf-8-encoder
共用~UTF-16~decoder:#shared-utf-16-decoder
~replacement~decoder:#replacement-decoder
~replacementによる~errorはすでに返した~flag:#replacement-error-returned-flag

単byte~decoder:#single-byte-decoder
単byte~encoder:#single-byte-encoder

~GBK~flag:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030~decoder:#gb18030-decoder
~gb18030~encoder:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5~decoder:#big5-decoder
~Big5~encoder:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212~flag:#euc-jp-jis0212-flag
~EUC-JP~decoder:#euc-jp-decoder
~EUC-JP~encoder:#euc-jp-encoder

~ISO-2022-JP~decoder:#iso-2022-jp-decoder
~ISO-2022-JP~encoder:#iso-2022-jp-encoder

~ISO-2022-JP~decoder状態:#iso-2022-jp-decoder-state
~ISO-2022-JP~decoder出力~状態:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JP出力~flag:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escape開始:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JP~encoder状態:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JIS~decoder:#shift_jis-decoder
~Shift_JIS~encoder:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KR~decoder:#euc-kr-decoder
~EUC-KR~encoder:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16~lead~surrogate:#utf-16-lead-surrogate
~UTF-16~decoder:#utf-16-decoder
~UTF-16LE~decoder:#utf-16le-decoder
~UTF-16BE~decoder:#utf-16be-decoder
~UTF-16BE~decoder~flag:#utf-16be-decoder-flag

~x-user-defined~decoder:#x-user-defined-decoder
~x-user-defined~encoder:#x-user-defined-encoder

	~byte列に変換-:#convert-a-code-unit-to-bytes

indexes.json:https://encoding.spec.whatwg.org/indexes.json

	●用語（外部
jA.CreateTransformStream:~STREAMS#create-transform-stream
jA.TransformStreamDefaultControllerEnqueue:~STREAMS#transform-stream-default-controller-enqueue

~JS文字列:~INFRA#javascript-string
~scalar値~文字列:~INFRA#scalar-value-string
~cu:~INFRA#code-unit

投出-:~WEBIDL#dfn-throw
~IDL値に変換-:~WEBIDL#dfn-convert-ecmascript-to-idl-value
複製を取得する:~WEBIDL#dfn-get-buffer-source-copy
~byte列への参照を取得-:~WEBIDL#dfn-get-buffer-source-reference

~chunk:~STREAMS#chunk
可読~stream:~STREAMS#readable-stream
可書~stream:~STREAMS#writable-stream
形式変換~stream:~STREAMS#transform-stream


●●words_table1

bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 


●●words_table


	●仕様
API:
algo:algorithm:::アルゴリズム
手続き:steps:~
段:step:~
UA:user agent:UA:::ユーザエージェント
形上では:technicalには:形の上では
歴史的:historical:~
規範的:normative:~
	規範的でない:non-normative:~
統一的:universal:~
適切:appropriate:~
互換性:compatibility:~
互換:compatible:~
非互換:incompatible:~
理由:reason:~
特能:feature::~
課題:issue:~
問題:problem:~
違法:illegal:~
自明:trivial:~
基本的:basic:~
網羅的:exhaustive:~
共通の:commonな:~
共通な:commonな:~
基盤:infrastructure:~
有意:significant:~
保守的:conservative:~
合法:legitimate:~
移行-:move:~
重要:important:~
特別:special:~
完全さ:completeness:~
仕組み:mechanism:~
事例:case:~
各種用語:terminology:~
意味論:semantics:~
旧来の:legacyな:~
標準:standard:~
	標準:Standard
無関連:irrelevant:関連しない
仕様:spec:~
	省略時は:optional
browser::::ブラウザ
proprietary::::プロプライエタリ
platform::::プラットフォーム
リバースエンジニア:reverse engineer:~
security::::セキュリティ
効率的:efficient:~

背景:background:~
有用:useful:~
強く:strongに:~
仕方:way:~
簡明:clear:~
隔たり:gap:~
詳細:details:~
進行中:ongoing:~
過去:past:~
共通的に:commonに:よく
資質:nature:~
凡例:legend:~
考慮点:considerations:~
能:ability:~
概して:typicalに:~
概念:concept:~
許容-:allow:~
目標:goal:~
可用:available:~
	特に:in particular
	助力:help
	~~標準の:The
	~~考慮
	一式で:in combination with
	より~~一般的には:larger
	備考
	入手できる:available
	則って
	~~十分:fine
	様に
	広く:widespread
	序:Preface
	要-
	不要:no need
	必要:need／have to
	必要とされ:necessary
	決して
	見かけ上:superficially
	説明:Notes
	限らない
	にもかかわらず:nonetheless
	あいにく:unfortunately
	後の:future
	~~不正な:bogus
	例
	例えば
	注記
	特に:In particular
	関する:-

	●仕様（動詞
support::::サポート
追加的な:additionalな:追加の
避ける:avoidする:~
影響-:affect:~
利用者:user:~
利用-:use:~
利用:use:~
	利用-中:in use
	利用されない:unused
波及-:influence:~
意図的:intentional:~
意図-:intend:~
除外-:exclude:~
除外:exclusion:~
排他的:exclusive:~
既存の:existing:~
作者:author:~
供さな:provideしな:~
	供する:-
提供-:offer:~
収束:converge:~
相互運用可能:interoperable:~
究明:investigation:~
末端利用者:end user:~
可能化-:enable:~
不能化-:disable:~
報告-:report:~
解釈:interpretation:~
制御:control:~
未知:unknown:~
拘束:constraints:~
拘束-:constrain:~
制約的:restrictive:~
奨励-:encourage:~
	促す
拡散-:spread:~
逸脱-:deviate:~
判別-:distinguish:~
開発者:developer:~
義務付けら:mandateさ:~
要求-:require:~
取組む:addressする:取り組む
制限-:limit:~
働く:workする:~
拡張-:extend:~
拡張:extension:~
既定:default:~
fallback:::フォールバック
実装-:implement:~
実装:implementation:~
定義-:define:~
定義:definition:~
未定義:undefined:~
最適化-:optimize:~
依存-:depend:~
公開-:expose:~
共用:shared::~
共有-:share:~
流布-:deploy:~
配備-:deploy:~
	配備-済みの:deployed
許可-:permit:~
生産側:producer:~
生産-:produce:~
消費側:consumer:~
消費者:consumer:~
誘発-:trigger:~
違反:violation:~
取扱い:handling:取り扱い
取扱う:handleする:取り扱う
要旨した:outlineした:要旨を述べた
霧消-:go away:~
挙動:behavior:ふるまい
相応しい:suitableな:~
組合せて:combineして:組み合せて
相違-:differ:~
包装-:wrap:~
	〜を包装する:wrapper
受容-:accept:~
保全-:preserve:~
存在-:exist:~
在する:presentする:在る
周知の:knownな:~
	-:known
読者:reader:~
演習:exercise:~
	~~用法の一つを示す:demonstrates an approach one could take to use
	~~対処-:deal with
	扱い:dealing with
	準じる:match
	知られ:known／
		追い易く:easy to follow
	挙げ-:list
	示され:-
	呼ぶ:-
	埋める:-
	壊す:break
	変わって:change
	見えない:not see
	見よ:see
	記され
	記す
	一緒に:together with
	したがって:therefore
	一方で:whereas
	同様に:similarly-
	残しておく:left as


	●動詞（未分類
分割-:split:~
合致-:match::~
断片化:fragment 化:~
対応関係:mapping:対応付け
対応付ける:mapする:~
対応付けて:mapして:~
対応付けら:mapさ:~
表現-:represent:~
識別-:identify:~
識別子:identifier:~
前置-:prefix::~
重複-:duplicate:~
開始:start:~
終端:end:~
包含-:contain::~
文脈:context::~
内容:content::~
結付けら:associateさ:結び付けら
見出す:findする:~
見出され:findされ:~
参照-:reference::~
参照:reference::~
移動-:move:~
保持-:hold:~
	持つ
	一新-:set anew
	所与の:given
	与え:give
	転換-:turn
	失わせ:loss
	戻す:back
	出くわし:hit
	~~空いた:newly-vacated
	含まれ／含められ／含んで:include
	表す:signify
	対:combination
	被せた:Layering 〜  on top
	加え
	指-:-
	得られ:-
	得る:-
	終える:-
	行う

	●network／保安
URL:
protocol::::プロトコル
header::::ヘッダ
server::::サーバ
client::::クライアント
資源:resource::~:リソース
form::::フォーム
提出:submission::~
手入力-:enter:~
攻撃:attack:~
攻撃者:attacker:~
防ぐ:preventする:~
注入-:inject:~
注意深く:carefulに:~
細工:craft:~
情報喪失:information loss:~
安全:safe:~
上書き:override:~
合意:agree:~
不一致:mismatch:~
交換:interchange:~
隠す:maskする:~
隠せな:maskできな:~
	突く:abuse
	至らせ:resulting in
	~~検知されることなく:silent

	●符号化法
Unicode:
CJK:
block::::ブロック
私用領域:Private Use Area:~
	香港増補字符集
	基本多言語面
	互換漢字

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul:::ハングル

byte::::バイト
単byte:single-byte::単 byte:単バイト:シングルバイト
複byte:multi-byte::複 byte:複バイト:マルチバイト
surrogate::::サロゲート
scalar::::スカラー
flag::::フラグ
cp:code point::符号位置::コードポイント
cu:code unit::符号単位::コードユニット
索引:index::~::インデックス
pointer::::ポインタ
符号化文字集合:coded character set::~

BOM:
BOMseen:BOM seen:BOM 確認済み
BOMignore:ignore BOM:BOM 無視
簡体字:simplified::~
繁体字:traditional::~
ASCII:
空:empty:~
空の:emptyな:~
	空行:empty string
文字列:string::~
文字:character::~
小文字:lowercase::~
範囲:range::~
範囲集:ranges::~
空白:whitespace:~
大小無視:case-insensitive:~
数字:digit:~

code::::コード
encode:::符号化::エンコード
encoding:::符号化法::エンコーディング
encoder:::符号化器::エンコーダ
decode:::復号::デコード
decoder:::復号器::デコーダ
label::::ラベル
正準的:canonical::~
形式:format::データ形式::フォーマット

半角:halfwidth::~
全角:fullwidth::~
katakana::::カタカナ

	●stream
token::::トークン
stream::::ストリーム
streaming::::ストリーム処理
可読:readable::読み取れる
読取れる:readできる::読み取れる
読取る:readする::読み取る
読取られ:readされ::読み取られ
読取っ:readし::読み取っ
	読取結果:読み取った結果
	unread:〜を元に戻す
可書:writable::書き込める
書込まれ:writeされ::書き込まれ
書込む:writeする::書き込む
制御器:controller::~
形式変換:transform::~
終端:end::~
EoS:end-of-stream::stream 終端:ストリーム終端
buffer::::バッファ
chunk::::チャンク
enqueue:
offset:
coder:
一掃-:flush::~
flush:
lead:::頭部
trail:::尾部
	頭部と尾部:leading and trailing
構文解析:parsing::~::パース処理
直列化-:serialize::~::シリアル化
継続-:continue::~
完遂d:finished::完遂
源:source::~::ソース
連結-:concatenate:~

	~buffer源:bufferSource
	出力~chunk:outputChunk
	一掃する~algo:flushAlgorithm
	形式変換~algo:transformAlgorithm
	開始~algo:startAlgorithm

	●一般処理
error::::エラー
escape:escape 
handler::::ハンドラ
call:
no_flush:do not flush:状態維持
mode::::モード
hook::::フック
option::::オプション
data::::データ
literal::::リテラル
	出現~byte数:byte seen
	fatal:
失敗-:fail::~
失敗:failure::~

状態:state::~::ステート
実行:execution:~
走らす:runする:~
走らせ:runし:~
	かけた:run through
返す:returnする:~
返さな:returnしな:~
返され:returnされ:~
返した:returnした:~
繰返:繰り返
変換-:convert:~
却下-:reject::~
解決-:resolve::~
処理-:process::~
処理器:processor::~::プロセッサ
処理待ち:pending::~
入力:input::~
出力:output::~
	~~出力:emit
呼出して:invokeして:呼び出して
呼出され:invokeされ:呼び出され
呼出す:invokeする:呼び出す
呼出時:invoke 時:呼び出し時
被呼出時:被 invoke 時:~
	invocation

演算:operation:~
演算対象:operand:~
検査-:check:~
終了-:terminate:~
往来-:roundtrip::~

下限:lower boundary::~
上限:upper boundary::~
順序:order:~
有順序:ordered:~
区切子:delimiter:~
範囲検査:limit check:~
	〜が返す値:〜の return value
	〜にかける:runs them through


	●データ型／操作／IDL
IDL:
list::::リスト
table::::テーブル
entry::::エントリ
bit::::ビット
shift::::シフト
field::::フィールド
obj:object:::オブジェクト
method:::メソッド
interface:::インタフェース
instance::::インスタンス
member::::メンバ
mixin:
pair::::ペア
promise:
辞書:dictionary::~
属性:attribute::~
構築子:constructor::~::コンストラクタ
投出-:throw::~
例外:exception::~
引数:argument:~
内包-:include::~
型:type::~
置換-:replace::~
push:::::プッシュ
前付加-:prepend::~
付加-:append::~
挿入-:insert::~
除去-:remove::~
取得子:getter::~
取得-:get::~
設定-:set::~
変化:changes:~
変更:changes:~
変更-:change:~
生成-:generate:~
論理:logical:~
配列:array::~
複製:copy:~
加算:addition:~
減算:subtraction:~
乗算:multiplication:~
除算:division:~
剰余:remainder:~
整数:integer:~
基数:base:~
名前:name::~
名:name::~
命名-:name::~
値:value:~
長さ:length:~

	●未分類
JS:JavaScript
HTML:
視覚-:visual::~
	視覚-化:visualize
	視覚-化:visualization
被覆域:coverage:~
覆う:coverする:~
layout::::レイアウト
script::::スクリプト
区画:area::~
一意:unique:~
一覧:table:~

別名:alias:~
正確a:accurate:正確
等価:equivalent:~
精度:precision:~
方向:direction:~
programming::::プログラミング
言語:language:~
委譲-:delegate:~
格納-:store:~
改変-:modify:~
進捗:progress:~
	算術式:equation
	統合:Unified
	伴われない no 〜 present
	一致-:identical
	優先される:has priority over／more authoritative
	等しい
	数
	数値:number
	桁:digit
	〜進数
	〜進表記
	~~孤立した:lone
	組み立て直:reassemble
	一致:identical

	●指示語
新たな:new:~
初期:initial:~
単独の:single:~
自前の:own:~
現在の:current:~
最初の:first:~
最後の:last:~
全体的な:overall:~
高位:high:~

	結果:result
	結果の:resulting
	左上隅:top left corner
	ある程度:some extent
	より小さい:less than
	他
	他の:other
	諸々の:miscellaneous
	前:before
	各:each
	同じ:same／
	多い:often
	前述の:aforementioned
	対応-:correspond
	少なくとも:at least
	後続の:subsequent／later
	尾部の:trailing
	最短:shortest
	頭部の:leading
	かつての:former
	全くの:fully
	若干の:slight
	少し:slighty
	下位:least significant
	もはや:no longer
	逆方向:vice versa
	等々:and so on
	並び／列:sequence
	成立-:true
	この:this
	その:that
	これらの:these
	3 種の:three
	自身:themselves
	一部を成す:part of
	代わりに:instead
	ここ:here
	介:via
	2 つの〜に:between
	唯一の／のみ:only
	複数:multiple／
	2 回:twice
	様々な:various
	下:below
	冒頭
	一つ
	一
	一連の
	一部
	上
	下
	以上
	以下
	下記
	中
	主に
	以外
	何か
	何も
	何らか
	元の
	先の
	入らない
	入る
	内
	列目
	別
	先頭
	右辺
	左辺
	各種
	各行
	多くの
	対象
	属する
	後者
	最初
	最大
	次
	次の
	次回
	番目
	節
	面
	項
	除いて／除き／除く
	該当-
	超え
	部分
	間
	際し
	非
	種の
	回
	常に
	後は
	時
	最も
	末尾
	個
	個数
	一方で
	伴-
	化
	化-
	場合
	備える
	場所
	対し／対する
	項目数
	右／左
	年
	応じて
	方
	法
	済む
	括弧内
	有-
	有無
	無い
	点で
	片
	的
	異なる
	相互に
	省略-:without
	総数
	行:row／line
	万
	組
	表
	語

	●訳注
	代用対
	含意-
	固有の
	保持-
	内部状態
	制約-
	区点番号
	数値的
	数字列
	識別子
	日付
	時系列的
	構造
	機能
	外字
	角括弧
	記号
	記法
	記述
	訳
	訳者
	試す
	集合
	静的
	変数
	追加
	意味
	意味-
	表記規約
	用い


●●ref_normative

[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[STREAMS]
    Adam Rice; Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/

●●ref_informative

[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml/


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="https://encoding.spec.whatwg.org/">Encoding Standard</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a> (<a href="https://github.com/whatwg/encoding/issues/new">new issue</a>, <a href="https://github.com/whatwg/encoding/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/encoding/commits
	<a href="https://encoding.spec.whatwg.org/commit-snapshots/1e225ce4ef77436607b659a3e3444e5df4dd102b/">Snapshot as of this commit</a>
	<a href="https://twitter.com/encodings">@encodings</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/encoding">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>



</head>

<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding — 符号化法</h1>
	</hgroup>

</header>


<main id="MAIN" hidden>
	<section id="preface">

<h2 title="Preface">1. 序</h2>

<p>
~UTF-8~encodingは、統一的な符号化文字集合である~Unicodeの交換に最も適切な~encodingである。
よって，この仕様は、新たな［
~protocolと形式
］, および［
新たな文脈~下で流布される既存の形式
］に対し、~UTF-8~encodingを要求する（また，定義する）。
◎
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
~encodingには，他のもの（旧来の~encoding）もあり，過去にある程度までは定義されているが、~UA間で常に同じように実装されているとは限らない。
また、常に同じ~labelを利用してるわけでもなく、~encodingの中の未定義の区画, あるいは かつての~proprietaryな区画についての扱いも，相違することが多い。
この仕様は、新たな実装が~encoding実装をリバースエンジニアせずに済むように，また, 既存の~UAが一つに収束できるようにするため、これらの隔たりを埋めることに取組む。
◎
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
特に，この仕様は、それらの~encodingと，そのそれぞれにおける［
~byte列と`~scalar値$ 列を相互に変換する~algo
］, および［
一連の`~label$を識別する正準的な名前
］を定義する。
また、~encodingの各種~algoのうち一部を~JSに公開する~APIも定義する。
◎
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAは，すでに
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
に挙げられている~labelからも 有意に逸脱している。
旧来の~encodingを これ以上~拡散させないため、この仕様は，前述の詳細について網羅的であり， registry はもう不要である。
特に，この仕様は、~encodingを拡張するための仕組みは供さない。
◎
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityに関する背景</h2>

<p>
~encodingには、いくつかの~security上の課題がある
— 生産側と消費側の間で，［
利用-中の~encoding, あるいは所与の~encodingの実装-法
］について合意されてないときに。
例えば 2011 年には、次のような攻撃が報告されている：
そこでは、［
攻撃者が何らかの~fieldを制御し得るような， JSON 資源
］内の `22^X ~trail~byteを “隠す” ために，`Shift_JIS$n の~lead~byte `82^X が利用された。
生産側からは，これが違法な~byte対であっても問題が見えない一方で、消費側では，この~byte対を単独の `FFFD^U として~decodeする~~結果、全体的な解釈が変わってしまう — `0022^U は重要な区切子なので。
［
`~scalar値$に対し複数~byteを利用する~encoding
］の~decoderには、今や，違法な~byte対の事例では，［
範囲 `0000^U 〜 `007F^U に入る~scalar値
］を “隠せない” ようにすることが要求される
— 前述の~byte対に対しては、出力が［
`FFFD^U `0022^U
］になるように。
◎
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to “mask” a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be “masked”. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
これは、より~~一般的には，［
~lead~byteが伴われないときに，`~ASCII~byte$を`~ASCII~cp$でない何かに対応付ける
］ような~encodingにおける課題である。
これらは， “~ASCII非互換” の~encodingであり、あいにく，すでに流布された内容のために要求されるが、［
`ISO-2022-JP$n, `UTF-16BE$n, `UTF-16LE$n
］以外のものは，~supportされない。
（その種の 他の~encoding`~label$についても、未知な~encodingへ~fallbackせずに，`replacement$n ~encodingに対応付けてよいかどうかの究明が
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">進行中にある</a>
。）
攻撃の一~例として、注意深く細工された内容を資源の中へ注入して，利用者に~encodingを上書きするよう促す~~結果、例えば~scriptの実行に至らせるものがある。
◎
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are “ASCII-incompatible” encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution. 
</p>

<p>
~HTMLや~HTMLの~form特能に見出される~URLに利用される~encoderも、その~encodingにより表現できない~scalar値がある場合には，若干の情報喪失につながり得る。
例えば，資源が `windows-1252$n ~encodingを利用しているとき、~serverは，末端利用者が~formに手入力した “💩” と “&amp;#128169;” とを判別できなくなる。
◎
Encoders used by URLs found in HTML and HTML’s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering “💩” and “&amp;#128169;” into a form.
</p>

<p>
ここに要旨した問題は、~UTF-8を排他的に利用しているときは，霧消する。
それが、今やすべてに対し~UTF-8~encodingが義務付けられている理由の一つである。
◎
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">注記：
<a href="#browser-ui">~browser UI</a> 節も見よ。
◎
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 進数には "0x" が前置される。
◎
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
算術式の中のすべての数値は整数であり、各種~~演算は次の記号で表現される：
</p>

<table>
<thead><tr><th>記号
<th>意味
</thead><tbody>

<tr><th>~PLUS
<td>加算

<tr><th>~MINUS
<td>減算

<tr><th>~INCBY
<td>左辺~値に対する右辺~値による加算

<tr><th>~DECBY
<td>左辺~値に対する右辺~値による減算

<tr><th>~MUL
<td>乗算

<tr><th>~DIV
<td>整数の除算（小数切り捨て）

<tr><th>~MOD
<td>整数の除算の剰余（ modulo ）

<tr><th>~Lshift
<td>論理~左~shift

<tr><th>~Rshift
<td>論理~右~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR

</tbody></table>

<p class="trans-note">【
記号 ~INCBY, ~DECBY は訳者による追加。
】</p>

◎
In equations, all numbers are integers, addition is represented by "+", subtraction by "−", multiplication by "×", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|". 
</div>

<p>
論理~右~shiftの演算対象の精度は、少なくとも 21 ~bit以上にするモノトスル。
◎
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
`~token@
は、`~byte$や`~cp$などの， 1 個の~data片である。
◎
A token is a piece of data, such as a byte or code point.
</p>

<p>
`~stream@
は、有順序`~token$列を表現する。
`~EoS@
は、`~stream$にそれ以上 読取れる`~token$は無いことを表す，特別な`~token$である。
◎
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">【
~streamと~token列は（ “静的な” ）~data構造としては同じでも，
 “~stream” には，そのアクセスが［
先頭（入力として与えられた場合）／末尾（出力~先の場合）
］に（ “時系列的に” ）制約されることが含意される。
】</p>

<div class="algorithm">
<p>
~streamから
`~tokenを読取る@
ときは、所与の
( `~stream$ %~stream )
に対し，次を走らすモノトスル：
</p>
<ol>
	<li>
~IF［
%~stream は空である
］
⇒
~RET `~EoS$
</li>
	<li>
%~stream の先頭から 1 個の~tokenを除去する
</li>
	<li>
~RET 前~段で除去した~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->
◎
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<div class="algorithm">
<p>
1 個~以上の`~token$を`~stream$に
`前付加する@
ときは、それらの~tokenを，~streamの先頭に, 所与の順序を保ったまま挿入するモノトスル。
◎
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>
</div>

<p class="example">
~token列 "<code>&amp;#128169;</code>" を~stream "<code> hello world</code>" の先頭に挿入した結果は，~stream "<code>&amp;#128169; hello world</code>" になり、次回に読取られる~tokenは <code>&amp;</code> になる。
<!-- 💩 --><!-- #x1F4A9 = 128169 decimal -->
◎
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<div class="algorithm">
<p>
1 個~以上の`~token$を`~stream$に
`~pushする@
ときは、それらの~tokenを，~streamの末尾に, 所与の順序を保ったまま付加するモノトスル。
◎
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>
</div>

	</section>

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（此れ, ~LET, ~ON, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
加えて、次の記法も用いられる：
</p>

<table><thead><tr><th style="min-width: 10em;">記法
<th>意味
</thead>

<tbody>
<tr><th style="white-space:nowrap;">~byte列 [ %value1, %value2, … ]
<td>
数値的に %value1, %value2 … と同じ値をとる一連の`~byte$からなる, 所与の順序による，新たな`~token$列の~instanceを意味する。
角括弧の中が空
— “~byte列 [] ” —
と記されたときは，空の`~token$列を意味する。

<tr><th style="white-space:nowrap;">~cp [ %value ]
<td>
数値的に %value と同じ値をとる 1 個の`~cp$からなる，新たな`~token$列の~instanceを意味する。

</tbody></table>

	</section>
	<section id="encodings">
<h2 title="Encodings">4. ~encoding</h2>

<p>
`~encoding@
（ `encoding^en ）は、`~scalar値$ 列から~byte列への対応関係
【~encode】
および逆方向への対応関係
【~decode】
を定義する。
それぞれの`~encoding$には、
`名前@
および， 1 個~以上の
`~label@
が<a href="#encoding-labels">あてがわれている</a>。
◎
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

<p class="note">注記：
この仕様は、~Unicode標準に定義される `encoding scheme^en として，同じ名前を伴う 3 種の`~encoding$
— `UTF-8$n, `UTF-16LE$n, `UTF-16BE$n —
を定義する。
`~encoding$は、~BOM（ `byte order mark^en, “バイト順マーク” ）の取扱いにおいて `encoding scheme^en から相違する
— ~BOMの取扱いは、この仕様においては［
`~encoding$自身の一部を成す代わりに，それを包装する~algoの一部を成している
］一方で，
~Unicode標準においては `encoding scheme^en の定義の一部を成す。
`~UTF-8~decodeする$~algoと一緒に利用される `UTF-8$n は、同じ名前の `encoding scheme^en に合致する。
この仕様は、同様に命名される `encoding scheme^en に合致するような［
`UTF-16LE$n ／ `UTF-16BE$n
］と組合せて包装する~algoは，供さない。
`UNICODE$r
◎
This specification defines three encodings with the same names as encoding schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE. The encodings differ from the encoding schemes by byte order mark (also known as BOM) handling not being part of the encodings themselves and instead being part of wrapper algorithms in this specification, whereas byte order mark handling is part of the definition of the encoding schemes in the Unicode Standard. UTF-8 used together with the UTF-8 decode algorithm matches the encoding scheme of the same name. This specification does not provide wrapper algorithms that would combine with UTF-16LE and UTF-16BE to match the similarly-named encoding schemes. [UNICODE]
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. ~encoderと~decoder</h3>

<p>
各種 `~encoding$には、［
`~decoder@
（ `decoder^en ）,
`~encoder@
（ `encoder^en ）
］が結付けられる。
各［
`~decoder$ ／ `~encoder$
］には、
`~handler@
が結付けられる。
`~handler$は、
( `~stream$, 1 個の`~token$ )
を入力にとり，次のいずれかを返す~algoである
⇒＃
`完遂d@ ／
空でない`~token$列† ／
`~error@ — ~optionで`~cp$も伴い得る†† ／
`継続-@
◎
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</p>

<p class="trans-note">【†
ほとんどの~decoderの~handlerは， 1 個の~cpからなる~token列を返すが、
`~Big5~decoder$の~handlerだけ， 2 個の~cpを返す場合がある。
】【††
~encoderの~handlerに限り、常に，~cpも伴う~errorを返す。
】</p>

<p class="note">注記：
［
`replacement$n, `UTF-16BE$n, `UTF-16LE$n
］`~encoding$には、`~encoder$はない。
◎
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>


<p>
以下で利用される
`~error~mode@
は：
◎
An error mode as used below is＼
</p>
<ul>
	<li>
`~decoder$においては、次のいずれかをとる
⇒
`replacement^l（既定）,
`fatal^l
◎
"replacement" (default) or "fatal" for a decoder and＼
</li>
	<li>
`~encoder$においては、次のいずれかをとる
⇒
`fatal^l（既定）,
`html^l
◎
"fatal" (default) or "html" for an encoder.
</li>
</ul>

<p class="note">注記：
XML 処理器は、その`~decoder$の`~error~mode$を `fatal^l に設定することになる。
`XML$r
◎
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">注記：
`~error~mode$に `html^l が存在する理由は、~URLや~HTML~formにおいては，`~error$に際しても旧来の`~encoder$は終了させない取扱いを要するためである。
`html^l `~error~mode$は、合法な入力と判別できない列を~~出力させ，~~検知されることなく~dataを失わせる。
これを防ぐため、開発者には `UTF-8$n `~encoding$の利用が強く奨励される。
`URL$r
`HTML$r
◎
html exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algorithm">
<p>
`~encoding$の［
`~decoder$ ／ `~encoder$
］ %~coder を
`走らす@
ときは、所与の
⇒＃
入力`~stream$ %入力,
出力`~stream$ %出力,
`~error~mode$ %~mode （省略時は ε ）
◎終
に対し，次を走らす：
◎
To run an encoding’s decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</p>

<ol>
	<li>
~IF［
%~mode ~EQ ε
］
⇒
%~mode ~SET %~coder に応じて
⇒＃
`~decoder$であるならば `replacement^l ／
`~encoder$であるならば `fatal^l
◎
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>
	<li>
%~coder~instance ~LET 新たな %~coder の~instance
◎
Let encoderDecoderInstance be a new encoderDecoder.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%結果 ~LET  `~tokenを処理する$( `~tokenを読取る$( %入力 ), %~coder~instance, %入力, %出力, %~mode )
◎
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$
］
⇒
~RET %結果
◎
If result is not continue, return result.
◎
Otherwise, do nothing. 
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`~tokenを処理する@
ときは、所与の
⇒＃
`~token$ %~token ,
`~encoding$の［ `~encoder$／`~decoder$ ］の~instance %~coder~instance,
入力`~stream$ %入力,
出力`~stream$ %出力,
`~error~mode$ %~mode（省略時は ε ）
◎終
に対し，次を走らす：
◎
To process a token token for an encoding’s encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</p>

<ol>
	<li>
~IF［
%~mode ~EQ ε
］
⇒
%~mode ~SET %~coder~instance に応じて
⇒＃
`~decoder$の~instanceであるならば `replacement^l ／
`~encoder$の~instanceであるならば `fatal^l
◎
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>
	<li>
%結果 ~LET 次を与える下で， %~coder~instance の`~handler$を走らせた結果
⇒
( %入力, %~token )
◎
Let result be the result of running encoderDecoderInstance’s handler on input and token.
</li>
	<li>
~IF［
%結果 ~IN { `継続-$, `完遂d$ }
］
⇒
~RET %結果
◎
If result is continue or finished, return result.
</li>
	<li>
~IF［
%結果 は 1 個~以上の`~token$である
］
⇒＃
%結果 を %出力 に`~pushする$；
~RET `継続-$
◎
Otherwise, if result is one or more tokens, push result to output.
</li>
	<li>
~Assert：
%結果 は`~error$である
◎
Otherwise, if result is error,＼
</li>
	<li>
<p>
%~mode に応じて：
◎
switch on mode and run the associated steps:
</p>
		<dl class="switch">
			<dt>`replacement^l</dt>
			<dd>
`FFFD^U を %出力 に`~pushする$
◎
Push U+FFFD to output.
</dd>

			<dt>`html^l</dt>
			<dd>
次に与える~cp列を %入力 に`前付加する$
⇒＃
`0026^U,
`0023^U,
%結果 の`~cp$を基数 10 により最短で表現する`~ASCII数字$列,
`003B^U
◎
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing result’s code point in base ten, followed by U+003B to input.
</dd>
			<dd>
【すなわち、 `&amp;#<var>数字列</var>;^l 】
</dd>

			<dt>`fatal^l</dt>
			<dd>
~RET `~error$
◎
Return error.
</dd>
		</dl>
	</li>
	<li>
~RET `継続-$
◎
Return continue.
</li>
</ol>
</div>

		</section>
		<section id="names-and-labels">
<h3 title="Names and labels">4.2. 名前と~label</h3>

<p>
~UAは、下の一覧に挙げる`~encoding$とそれらの`~label$すべてを~supportするモノトスル。
~UAは、他の`~encoding$や`~label$は~supportしないモノトスル。
◎
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">注記：
どの~encodingについても、その`~label$の集合は，`名前$を`~ASCII小文字~化$したものを含んでいる。
◎
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p>
作者は、 `UTF-8$n `~encoding$を利用した上で，その利用が識別されるように［
`~ASCII大小無視$で `utf-8^lb に合致する`~label$
］を利用しなければナラナイ。
◎
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
新たな［
~protocolと形式
］, あるいは［
新たな文脈~下で流布される既存の形式
］には、 `UTF-8$n `~encoding$が排他的に利用されなければナラナイ。
これらの［
~protocolや形式
］の`~encoding$の［
`名前$や`~label$
］は、 `utf-8^lb として公開されなければナラナイ。
◎
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding’s name or label, they must expose it as "utf-8".
</p>

<div class="algorithm">
<p>
`~labelから~encodingを取得する@
ときは、所与の
( 文字列 %~label )
に対し，次を走らす：
◎
To get an encoding from a string label, run these steps:
</p>

<ol>
	<li>
%~label から頭部と尾部の`~ASCII空白$を除去する
◎
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IF［
%~label が下の一覧のいずれかの`~label$に`~ASCII大小無視$で合致する
］
⇒
~RET 合致した`~label$に対応する`~encoding$
◎
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>
	<li>
~RET `失敗^i
◎
↑</li>
</ol>
</div>

<p class="note">注記：
この［
`~label$を`~encoding$に対応付ける~algo
］は、
<a href="https://www.unicode.org/reports/tr22/tr22-8.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 節</a>
によるものより基本的かつ制約的である
— 配備-済みの内容と互換になることが必要とされるので。
◎
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
<thead><tr><th>`名前$◎ Name
<th>`~label$◎ Labels
</thead>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#the-encoding">~~標準の~encoding</a>
◎
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`utf-8^lb
`utf8^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-single-byte-encodings">旧来の単byte~encoding</a>
◎
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(simplified)-encodings">旧来の複byte Chinese （簡体字） ~encoding</a>
◎
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(traditional)-encodings">旧来の複byte Chinese （繁体字）~encoding</a>
◎
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-japanese-encodings">旧来の複byte Japanese ~encoding</a>
◎
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-korean-encodings">旧来の複byte Korean ~encoding</a>
◎
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-miscellaneous-encodings">旧来の諸々の~encoding</a>
◎
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
	</tbody>
</table>

<p class="note">注記：
すべての`~encoding$とそれらの`~label$は、規範的でない資源
`indexes.json$
からも入手できる。
◎
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

		</section>
		<section id="output-encodings">
<h3 title="Output encodings">4.3 出力~encoding</h3>

<div class="algorithm">
<p>
`~encodingから出力~encodingを取得する@
ときは、所与の
( `~encoding$ %~encoding )
に対し，次を走らす：
◎
To get an output encoding from an encoding encoding, run these steps:
</p>

<ol>
	<li>
~IF［
%~encoding ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
］
⇒
~RET `UTF-8$n
◎
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>
	<li>
~RET %~encoding
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
この~algoは、それを必要とする［
~URLの構文解析 ／ ~HTML~form提出
］にて有用になる。
◎
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>
</div>

		</section>
	</section>
	<section id="indexes">
<h2 title="Indexes">5. 索引</h2>

<p>
ほとんどの旧来の`~encoding$では、
【~encodingごとに固有の】
`索引@
が利用される。
`索引$とは、一連の~entryからなる有順序~listであり、各~entryは［
~pointerと, それに対応する~cp
］からなる組である。
`索引$の中では、~pointerは一意であり，~cpは重複し得る。
◎
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">注記：
効率的な実装は、`~encoding$ごとに，その`~decoder$と`~encoder$のそれぞれに最適化された， 2 つの`索引$を備えることになるであろう。
◎
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="algorithm">
<p>
`索引$
【の~dataを供する下記の資源】
から，~pointerとそれに対応する~cpを見出すためには：
</p>

<ol>
	<li>
まず、 %行~list をその資源の内容を `000A^U で一連の “行” に分割した結果とする。
</li>
	<li>
%行~list から［
空行 ／ `0023^U で開始される行
］をすべて除去する。
</li>
	<li>
<p>
%行~list の各~行に対し，行を `0009^U で分割したときの：
</p>

<ul><li>最初の項が~pointer（ 10 進表記）を与える。
</li><li>次の項が対応する~cp（ 16 進表記）を与える。
</li><li>他の項は無関連。
</li></ul>
	</li>
</ol>

◎
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource’s contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">注記：
各`索引$の冒頭には、変更の有無を記すため，
<i>Identifier</i> と <i>Date</i>
【識別子と日付】
が記されている。
<i>Identifier</i> の変化は、`索引$に変更が加えられたことを表す。
◎
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%索引 の中で %~pointer が指す
`索引~cp@
とは、
%索引 内に %~pointer が［
在るならば，それに対応する~cp ／
無ければ ~NULL
］である。
◎
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%索引 の中で %~cp を指す
`索引~pointer@
とは、
%索引 内に %~cp に対応する~pointerが［
在るならば，それらのうちの <em>最初の</em> ~pointer ／
無ければ ~NULL
］である。
◎
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<div class="note" id="visualization">
<p>注記：
各 索引には，規範的でない視覚-化があり、`索引~jis0208$には， `Shift_JIS$n 視覚-化も別にある。
加えて，基本多言語面（
BMP ／ Basic Multilingual Plane ／ `0000^U 〜 `FFFF^U
）における被覆域の視覚-化もある。
ただし、［
`索引~gb18030範囲集$ ／ `索引~ISO-2022-JP~katakana$
］には，これらの視覚-化はない。
◎
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
視覚-化における凡例
◎
The legend for the visualizations is:
</caption>

<thead><tr><th>表示
<th>説明
</thead>

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
対応する~cpは無い。
◎
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8で 2 ~byte。
◎
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8で 2 ~byte, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8で 3 ~byte（私用領域でない）
◎
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8で 3 ~byte（私用領域でない）, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
私用領域
◎
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
私用領域, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Private Use, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8で 4 ~byte
◎
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8で 4 ~byte, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
先に現れているものと重複する~cpに対応する。
◎
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJK互換漢字（ `CJK Compatibility Ideograph^en ）
◎
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJK統合漢字拡張 A
◎
CJK Unified Ideographs Extension A

</tbody>
</table>

</div>


<p>
以下は、この仕様で定義される`索引$のうち，`単byte索引$でないものであり、それぞれに自前の~tableがある：
【視覚-化／被覆域の~tableは巨大なことに注意】
◎
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list" class="grid-table">
<thead><tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
<th>備考
</thead><tbody>

<tr><td>`索引~Big5@
<td>`Big5$idx
<td>
これは、香港増補字符集（ `Hong Kong Supplementary Character Set^en ）, および他の共通の拡張と一式で、~Big5標準に合致する。
◎
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tr><td>`索引~EUC-KR@
<td>`EUC-KR$idx
<td>
これは、 KS X 1001 標準と 統合~Hangul~code（ `Unified Hangul Code^en ）に合致する。
Windows Codepage 949 としても共通的に知られている。
これ全体で、~Unicodeの~Hangul音節文字（ `Hangul Syllables^en ）~blockを覆う。
~Hangul~blockのうち，視覚-化における左上隅が~pointer 9026 にあるもの
【？】
は、~Unicode順に並ぶ。
`Taken separately^en 【？】,
この索引における残りの~Hangul音節文字も、~Unicode順に並ぶ。
◎
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too. 

<tr><td>`索引~gb18030@
<td>`gb18030$idx
<td>
これは、各~cpが 2 ~byteに~encodeされる GB18030-2005 標準に合致する
— ただし，配備-済みの内容と互換になるよう、 `A3^X `A0^X は `3000^U に対応付けられる。
この索引~全体で、~Unicodeの~CJK統合漢字（ `CJK Unified Ideographs^en ）~blockを覆う。
その~block内の~entryのうち，視覚-化における（最初の） `3000^U より上または左にあるものは、~Unicode順に並ぶ。
◎
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tr><td>`索引~gb18030範囲集@
<td>`gb18030-ranges$idx
<td>
この`索引$は、すべての~cpを挙げていくと項目数が 100 万を超えてしまう点で，他のすべてと異なる（ 207 面の範囲と自明な範囲検査により，きれいに表現できるが）。
したがって、 4 ~byte に~encodeされる~cpについてのみ，見かけ上 GB18030-2005 標準に合致する。
下の［
`索引~gb18030範囲集~cp$ ／
`索引~gb18030範囲集~pointer$
］も見よ。
◎
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

<tr><td>`索引~jis0208@
<td>`jis0208$idx
<td>
IBM と NEC によるかつての~proprietary拡張も含まれている， JIS X 0208 標準。
◎
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tr><td>`索引~jis0212@
<td>`jis0212$idx
<td>
JIS X 0212 標準。
これを利用するのは、`~EUC-JP~decoder$に限られる（~encoderからは利用されない）
— 広く~supportされていないので。
◎
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tr><td>`索引~ISO-2022-JP~katakana@
<td>`iso-2022-jp-katakana$idx
<td>
これは、
`Unicode Normalization Form KC^en
に従って，半角~katakanaを全角~katakanaに対応付ける。
ただし、［
`FF9E^U ／ `FF9F^U
］は［
`309B^U ／ `309C^U
］に対応付ける
— ［
`3099^U ／ `309A^U
］ではなく
【これらはいずれも、濁点／半濁点】
。
これを利用するのは、`~ISO-2022-JP~encoder$に限られる。
`UNICODE$r
◎
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]

</tbody></table>


<div class="algorithm">
<p>
%~pointer が指す
`索引~gb18030範囲集~cp@
は、次の手続きが返す~cpである：
◎
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>

<ol>
	<li>
~IF［
39419 ~LT %~pointer ~LT 189000
］~OR［
1237575 ~LT %~pointer
］
⇒
~RET ~NULL
◎
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>
	<li>
~IF［
%~pointer ~EQ 7457
］
⇒
~RET ~cp `E7C7^U
◎
If pointer is 7457, return code point U+E7C7.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲集$の中で %~pointer を超えない最後の~pointer
◎
Let offset be the last pointer in index gb18030 ranges that is less than or equal to pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset が指している~cp
◎
↑</li>
	<li>
~RET 値が［
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
］なる~cp
◎
Return a code point whose value is code point offset + pointer − offset.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp を指す
`索引~gb18030範囲集~pointer@
は、次の手続きが返す~pointerである：
◎
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `E7C7^U
］
⇒
~RET ~pointer 7457
◎
If code point is U+E7C7, return pointer 7457.
</li>
	<li>
%~offset ~LET `索引~gb18030範囲集$の中で %~cp を超えない最後の~cp
◎
Let offset be the last code point in index gb18030 ranges that is less than or equal to code point and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset に対応する~pointer
◎
↑</li>
	<li>
~RET 値が［
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
］なる~pointer
◎
Return a pointer whose value is pointer offset + code point − offset.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp を指す
`索引~Shift_JIS~pointer@
は、次の手続きが返す~pointerである：
◎
The index Shift_JIS pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
<p>
%索引 ~LET `索引~jis0208$ から，［
~pointerが範囲 { 8272 〜 8835 } に入る~entry
］すべてを除外した索引
◎
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">
`索引~jis0208$は、重複する~cpを包含するので、これらの~entryの除外により，後続の~cpが利用されるようになる。
◎
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%~cp を指す
`索引~Big5~pointer@
は、次の手続きが返す~pointerである：
◎
The index Big5 pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
<p>
%索引 ~LET `索引~Big5$から［
~pointerが ( (`A1^X ~MINUS `81^X) ~MUL 157 ) より小さい~entry
］すべてを除外した索引
◎
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) × 157. 
</p>

<p class="note">注記：
香港増補字符集（ `Hong Kong Supplementary Character Set^en ）拡張を~literalとして返さないようにする。
◎
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IF［
%~cp ~IN 
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
］
⇒
~RET
%索引 の中で %~cp に対応する <em>最後の</em> ~pointer
◎
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">注記：
他にも重複している~cpはあるが、それら用には，<em>最初の</em> ~pointerが利用されることになる。
◎
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>
</div>

<hr>

<p class="note">注記：
すべての`索引$は、規範的でない資源
`indexes.json$
からも入手できる（ `索引~gb18030範囲集$の形式は、範囲を表現できるようにするため，少し異なるものにされている）。
◎
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">
<h2 title="Hooks for standards">6. 他の標準~用の~hook</h2>

<div class="note">
<p>注記：
次に挙げる各種~algo（以下に定義される）は、他の仕様からの~~利用が意図されている：
◎
The algorithms defined below (decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode) are intended for usage by other standards.
</p>

<dl>
	<dt>`~UTF-8~decodeする$</dt>
	<dd>
新たな形式は、~decodeするときは，これを利用すること（次項は別として）。
◎
For decoding, UTF-8 decode is to be used by new formats.＼
</dd>

	<dt>`~BOMはそのままに~UTF-8~decodeする$</dt>
	<dt>`~BOMも失敗-もそのままに~UTF-8~decodeする$</dt>
	<dd>
形式や~protocolの中の識別子や~byte列~用には、これらを利用すること。
◎
For identifiers or byte sequences within a format or protocol, use UTF-8 decode without BOM or UTF-8 decode without BOM or fail.
</dd>

	<dt>`~UTF-8~encodeする$</dt>
	<dd>
~encodeするときは、これを利用すること。
◎
For encoding, UTF-8 encode is to be used.
</dd>

	<dt>`~encodingを利用して~encodeする$</dt>
	<dt>`~Unicodeに~decodeする$</dt>
	<dd>
標準は、互換性を得るために必要な場合を除き，これらは利用しないことが強く奨励される。
◎
Standards are strongly discouraged from using decode and encode, except as needed for compatibility.
</dd>
</dl>

<p>
`~label$を`~encoding$に転換するときは、`~labelから~encodingを取得する$~algoを利用すること。
◎
The get an encoding algorithm is to be used to turn a label into an encoding.
</p>

</div>

<div class="algorithm">
<p>
`~Unicodeに~decodeする@
ときは、所与の
( ~byte~stream %~stream, ~fallback~encoding %~encoding )
に対し，次を走らす：
◎
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>
	<li>
%~BOMseen~flag ~LET ~OFF
◎
Let BOM seen flag be unset.
</li>
	<li>
<p>
次を 3 回まで繰返す：
</p>
		<ol>
			<li>
%~byte ~LET `~tokenを読取る$( %~stream )
</li>
			<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~BREAK
</li>
			<li>
%buffer に %~byte を付加する
</li>
		</ol>
◎
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>
	<li>
<p>
~IF［
次の表の中で， 1 列目に示された~byte列が %buffer の先頭の~byte列に合致する行がある
］
⇒＃
%~encoding ~SET その行の 2 列目に与えられる `~encoding$；
%~BOMseen~flag ~LET ~ON
◎
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>

<table>
<thead><tr><th>~BOM◎ Byte order mark
<th>~encoding◎ Encoding
</thead>

<tbody><tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n

</tbody></table>

<p class="note">注記：
配備-済みの内容との互換性を得るため、~BOMは他より~~優先される。
HTTP が利用される文脈においては、これは，
`<code class="header">Content-Type</code>`
~headerの意味論に対する違反である。
◎
For compatibility with deployed content, the byte order mark is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
~IF［
%~BOMseen~flag ~EQ ~OFF
］
⇒
%buffer を %~stream に`前付加する$
◎
If BOM seen flag is unset, prepend buffer to stream.
</li>
	<li>
~ELIF ［
%~encoding ~NEQ `UTF-8$n
］~AND［
%buffer の長さ ~EQ 3
］
⇒
%buffer の最後の~byteを %~stream に`前付加する$
◎
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>
	<li>
%出力 ~LET 新たな~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
%~encoding の`~decoder$を`走らす$( %~stream, %出力 )
◎
Run encoding’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~UTF-8~decodeする@
ときは、所与の
( ~byte~stream %~stream )
に対し，次を走らす：
◎
To UTF-8 decode a byte stream stream, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>
	<li>
<p>
次を 3 回まで繰返す：
</p>
		<ol>
			<li>
%~byte ~LET `~tokenを読取る$( %~stream )
</li>
			<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~BREAK
</li>
			<li>
%buffer に %~byte を付加する
</li>
		</ol>
◎
Read three bytes from stream into buffer.
</li>
	<li>
~IF［
%buffer ~NEQ ~byte列 [ `EF^X, `BB^X, `BF^X ]
］
⇒
%buffer を %~stream に`前付加する$
◎
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>
	<li>
%出力 ~LET 新たな~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
`UTF-8$n の`~decoder$を`走らす$( %~stream, %出力 )
◎
Run UTF-8’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~BOMはそのままに~UTF-8~decodeする@
ときは、所与の
( ~byte~stream %~stream )
に対し，次を走らす：
◎
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>

<ol>
	<li>
%出力 ~LET 新たな~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
`UTF-8$n の`~decoder$を`走らす$( %~stream, %出力 )
◎
Run UTF-8’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~BOMも失敗-もそのままに~UTF-8~decodeする@
ときは、所与の
( ~byte~stream %~stream )
に対し，次を走らす：
◎
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>

<ol>
	<li>
%出力 ~LET 新たな~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
`UTF-8$n の`~decoder$を`走らす$( %~stream, %出力, `fatal^l )
◎
Let potentialError be the result of running UTF-8’s decoder with stream, output, and "fatal".
</li>
	<li>
~IF［
前~段の結果 ~EQ `~error$
］
⇒
~RET `失敗^i
◎
If potentialError is error, return failure.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~encodingを利用して~encodeする@
ときは、所与の
( ~encoding %~encoding,
~cp~stream %~stream 
) に対し，次を走らす：
◎
To encode a code point stream stream using encoding encoding, run these steps:
</p>

<ol>
	<li>
~Assert：
%~encoding ~NIN 
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
◎
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>
	<li>
%出力 ~LET 新たな~byte`~stream$
◎
Let output be a byte stream.
</li>
	<li>
 %~encoding の`~encoder$を`走らす$( %~stream, %出力, `html^l )
◎
Run encoding’s encoder with stream, output, and "html".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
これは主に、~URLと~HTML~form用の旧来の~hookである。
`~UTF-8~encodeする$を被せた方が、決して`~error$を誘発させないので安全である。
`URL$r
`HTML$r
◎
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>
</div>

<div class="algorithm">
<p>
`~UTF-8~encodeする@
ときは、所与の
( ~cp~stream %~stream )
に対し，次を走らす
⇒
~RET `~encodingを利用して~encodeする$( `UTF-8$n, %~stream )
◎
To UTF-8 encode a code point stream stream, return the result of encoding stream using encoding UTF-8.
</p>
</div>

	</section>
	<section id="api">
<h2 title="API">7. ~API</h2>

<p>
この節では Web IDL `WEBIDL$r の各種用語を利用する。
~browser~UAは、この~APIを~supportするモノトスル。
~JS実装は、この~APIを~supportするベキである。
他の~UA／~programming言語は、必要に応じて相応しい~API（これではないかもしれない）を利用することが奨励される。
◎
This section uses terminology from Web IDL. Browser user agents must support this API. JavaScript implementations should support this API. Other user agents or programming languages are encouraged to use an API suitable to their needs, which might not be this one. [WEBIDL]
</p>

<div class="example">
<p>
次の例は、 `TextEncoder$I ~objを利用して，文字列の配列を `ArrayBuffer$I に~encodeする。
結果は次を内容とする `Uint8Array$I になる：
<span class="block">
先頭が（ `Uint32Array$I としての）文字列の個数，その後は：
<span class="block">
最初の文字列の（ `Uint32Array$I としての）長さ,
`UTF-8$n に~encodeされたその文字列~data，<br>
2 番目の文字列の（ `Uint32Array$I としての）長さ,
その文字列~data，<br>
…
</span>
等々と続く。
</span>
◎
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
次の例は、［［
前の例, または `UTF-8$n 以外の~encodingに等価な~algo
］により生産される形式に~encodeされた~data
］を含んでいる `ArrayBuffer$I を~decodeして、元の，一連の文字列からなる配列に戻す。
◎
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>


		<section id="interface-mixin-textdecodercommon">
<h3 title="Interface mixin TextDecoderCommon">7.1. ~interface~mixin `TextDecoderCommon^I</h3>

<pre class="idl">
interface mixin `TextDecoderCommon@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
};
</pre>

<p>
`TextDecoderCommon$I ~interface~mixinは、［
`TextDecoder$I, `TextDecoderStream$I
］~objに共通な属性を定義する。
これらの~objには、次のものが結付けられる（括弧内は初期~値）
⇒＃
`~encoding@dec,
`~BOMignore~flag@dec（ ~OFF ）,
`~BOMseen~flag@dec（ ~OFF ）,
`~error~mode@dec（ `replacement^l ）
◎
The TextDecoderCommon interface mixin defines common attributes that are shared between TextDecoder and TextDecoderStream objects. These objects have an associated encoding, ignore BOM flag (initially unset), BOM seen flag (initially unset), and error mode (initially "replacement").
</p>

<div class="algorithm">
<p>
これらの~objには、
`~streamを直列化する@dec
~algoも結付けられる。
それは、所与の`~stream$ %~stream に対し，次を走らす：
◎
These objects also have an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%~token ~LET `~tokenを読取る$( %~stream )
◎
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IF［
`~encoding$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n }
］~AND［
`~BOMignore~flag$dec ~EQ ~OFF
］~AND［
`~BOMseen~flag$dec ~EQ ~OFF
］：
◎
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, then:
</p>
				<ol>
					<li>
~IF［
%~token ~EQ `FEFF^U
］
⇒
`~BOMseen~flag$dec ~SET ~ON
◎
If token is U+FEFF, then set BOM seen flag.
</li>
					<li>
~ELIF［
%~token ~NEQ `~EoS$
］
⇒＃
`~BOMseen~flag$dec ~SET ~ON；
%出力 に %~token を付加する
◎
Otherwise, if token is not end-of-stream, then set BOM seen flag and append token to output.
</li>
					<li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~token ~NEQ `~EoS$
］
⇒
%出力 に %~token を付加する
◎
Otherwise, if token is not end-of-stream, then append token to output.
</li>
			<li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoは、~APIの利用者に より多くの制御を与えるため，［
~platformの他の場所で利用される，`~Unicodeに~decodeする$ ~algo
］とは、~BOMの取扱いの点で意図的に異なるものにされている。
◎
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>
</div>

<hr>

<dl class="idl-def">
	<dt>`encoding@m</dt>
	<dd>
取得子は、次の結果を返すモノトスル
⇒
`~ASCII小文字~化する$( 此れの`~encoding$decの`名前$ )
◎
The encoding attribute’s getter, when invoked, must return this object’s encoding’s name in ASCII lowercase.
</dd>

	<dt>`fatal@m</dt>
	<dd>
取得子は、［
此れの`~error~mode$dec ~EQ `fatal^l ならば ~T ／ ~ELSE_ ~F
］を返すモノトスル。
◎
The fatal attribute’s getter, when invoked, must return true if this object’s error mode is "fatal", and false otherwise.
</dd>

	<dt>`ignoreBOM@m</dt>
	<dd>
取得子は、［
此れの`~BOMignore~flag$dec ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返すモノトスル。
◎
The ignoreBOM attribute’s getter, when invoked, must return true if this object’s ignore BOM flag is set, and false otherwise.
</dd>
</dl>

		</section>
		<section id="interface-textdecoder">
<h3 title="Interface TextDecoder">7.2. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ `fatal@mb = false;
  `boolean$ `ignoreBOM@mb = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ `stream@mb = false;
};

[<a href="#dom-textdecoder">Constructor</a>(
  optional `DOMString$ %label = "utf-8",
  optional `TextDecoderOptions$I %options
),
 Exposed=(Window,Worker)]
interface `TextDecoder@I {
  `USVString$ `decode$m(
    optional BufferSource %input,
    optional `TextDecodeOptions$I %options
  );
};

`TextDecoder$I includes `TextDecoderCommon$I;
</pre>

<p class="trans-note">【
<a href="Encoding-test.html">利用-中の~browserでこの特能を試す</a>
】</p>

<p>
各 `TextDecoder$I ~objには、次のものが結付けられる（括弧内は初期~値）
⇒＃
`~decoder@dec †,
`~stream@dec,
`~no_flush~flag@dec（ ~OFF ）
◎
A TextDecoder object has an associated decoder, stream, and do not flush flag (initially unset).
</p>

<p class="trans-note">【†
`~encoding$decに対応する`~decoder$の，ある~instance。
`~decoder$には，内部状態を保持する変数を伴うものもあるので、~objごとに~instanceを要する。
】</p>


<dl class="domintro">
	<dt>%decoder = new `TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
新たな `TextDecoder$I ~obj を返す。
◎
Returns a new TextDecoder object.
</dd>
	<dd>
%label が`~label$でない, または
%label が `replacement$n である場合、
`RangeError$E が`投出-$される。
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`~encoding$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$decが `fatal^l ならば ~T を, 他の場合は ~F を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMignore~flag$dec に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返す。
◎
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
<p>
%input を `~encoding$decの`~decoder$にかけた結果を返す。
~streamを断片化して処理するときは、
%options の `stream^m ~memberを ~T にした下で，この~method 0 回~以上~呼出してから， %options を省略して（または その `stream^m ~memberを ~F にして）
1 回だけ呼出すことで行える。
後者の呼出時に %input もないならば、両~引数とも省略するのが最も簡明になる。
◎
Returns the result of running encoding’s decoder. The method can be invoked zero or more times with options’s stream set to true, and then once without options’s stream (or set to false), to process a fragmented stream. If the invocation without options’s stream (or set to false) has no input, it’s clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l の下で，
`~encoding$decの`~decoder$が`~error$を返した場合、
`TypeError$E が`投出-$される。
◎
If the error mode is "fatal" and encoding’s decoder returns error, throws a TypeError.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextDecoder(label, options)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らすモノトスル：
◎
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%~encoding ~LET `~labelから~encodingを取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
			<li>
~IF［
%~encoding ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
			<li>
%dec ~LET 新たな `TextDecoder$I ~obj
◎
Let dec be a new TextDecoder object.
</li>
			<li>
%dec の `~encoding$dec ~SET %~encoding
◎
Set dec’s encoding to encoding.
</li>
			<li>
~IF［
%options の `fatal^m ~member ~EQ ~T
］
⇒
%dec の `~error~mode$dec ~SET `fatal^l
◎
If options’s fatal member is true, then set dec’s error mode to "fatal".
</li>
			<li>
~IF［
%options の `ignoreBOM^m ~member ~EQ ~T
］
⇒
%dec の `~BOMignore~flag$dec ~SET `fatal^l
◎
If options’s ignoreBOM member is true, then set dec’s ignore BOM flag.
</li>
			<li>
~RET %dec
◎
Return dec.
</li>
		</ol>
	</dd>

	<dt>`decode(input, options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The decode(input, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`~no_flush~flag$dec ~EQ ~OFF
］
⇒＃
此れの`~decoder$dec ~SET 新たな［ 此れの`~encoding$decの`~decoder$ ］；
此れの`~stream$dec ~SET 新たな`~stream$；
此れの`~BOMseen~flag$dec ~SET ~OFF
◎
If the do not flush flag is unset, set decoder to a new encoding’s decoder, set stream to a new stream, and unset the BOM seen flag.
</li>
			<li>
此れの`~no_flush~flag$dec ~SET［
%options の `stream^m ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］
◎
If options’s stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>
			<li>
<p>
~IF［
%input は与えられている
］
⇒
%input の<a href="~WEBIDL#dfn-get-buffer-source-copy">複製</a>を 此れの`~stream$decに`~pushする$
◎
If input is given, then push a copy of input to stream.
</p>
<p class="note">注記：
実装には、この複製を避けるよう実装することが強く奨励される。
そうするときは、 %input が変更されても，後の `decode()$m の~callに影響しないようにする必要がある。
◎
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>
			</li>
			<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
			<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenを読取る$( 此れの`~stream$dec )
◎
Let token be the result of reading from stream.
</li>
					<li>
<p>
~IF［
%~token ~EQ `~EoS$
］~AND［
此れの`~no_flush~flag$dec ~EQ ~ON
］
⇒
~RET `~streamを直列化する$dec( %出力 )
◎
If token is end-of-stream and the do not flush flag is set, then return output, serialized.
</p>

<p class="note">
~streamingでは、［
`~no_flush~flag$dec ~EQ ~ON
］のときに，ここで`~EoS$を取扱うことなく，その~flagを ~OFF にしない仕方で働く。
この仕方により、後続の呼出時には，`~decoder$decは この~algoの最初の段で一新されず、その状態は保全される。
◎
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
					</li>
					<li>
%結果 ~LET `~tokenを処理する$( %~token, 此れの`~decoder$dec, 此れの`~stream$dec, %出力, 此れの`~error~mode$dec )
◎
Otherwise:
◎
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>
					<li>
~IF［
%結果 ~EQ `完遂d$
］
⇒
~RET `~streamを直列化する$dec( %出力 )
◎
If result is finished, then return output, serialized.
</li>
					<li>
~IF［
%結果 ~EQ `~error$
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, then throw a TypeError.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="interface-mixin-textencodercommon">
<h3 title="Interface mixin TextEncoderCommon">7.3. ~interface~mixin `TextEncoderCommon^I</h3>

<pre class="idl">
interface mixin `TextEncoderCommon@I {
  readonly attribute `DOMString$ `~encoding0$m;
};
</pre>

<p>
`TextEncoderCommon$I ~interface~mixinは、［
`TextEncoder$I, `TextEncoderStream$I
］~objに共通な属性を定義する。
◎
The TextEncoderCommon interface mixin defines common attributes that are shared between TextEncoder and TextEncoderStream objects.
</p>

<dl class="idl-def">
	<dt>`~encoding0@m</dt>
	<dd>
取得子は、 `utf-8^l を返すモノトスル。
◎
The encoding attribute’s getter, when invoked, must return "utf-8".
</dd>
</dl>

		</section>
		<section id="interface-textencoder">
<h3 title="Interface TextEncoder">7.4. ~interface `TextEncoder^I</h3>

<pre class="idl">
dictionary `TextEncoderEncodeIntoResult@I {
  `unsigned long long$ `read@m;
  `unsigned long long$ `written@m;
};

[<a href="#dom-textencoder">Constructor</a>,
 Exposed=(Window,Worker)]
interface `TextEncoder@I {
  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
  `TextEncoderEncodeIntoResult$I `encodeInto$m(`USVString$ %source, `Uint8Array$ %destination);
};
`TextEncoder$I includes `TextEncoderCommon$I;
</pre>

<p class="note">注記：
`TextEncoder$I ~objは、`UTF-8$n しか~supportしないので，構築子に %label 引数は無い。
また、~scalar値~bufferを要する`~encoder$は無いので， `stream^m の~optionもない。
◎
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = new `TextEncoder()$m</dt>
	<dd>
新たな `TextEncoder$I ~obj を返す。
◎
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input を `UTF-8$n の`~encoder$にかけた結果を返す。
◎
Returns the result of running UTF-8’s encoder.
</dd>

	<dt>%encoder . `encodeInto(source, destination)$m</dt>
	<dd>
%source を渡して`~UTF-8~encoder$を走らせた結果を %destination の中に格納して，その進捗を `TextEncoderEncodeIntoResult$I 辞書として返す
— 結果の
⇒＃
`read$m は %source から変換された`~cu$数になる ／
`written$m は %destination 内で改変された~byte数になる
◎
Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as a dictionary whereby read is the number of converted code units of source and written is the number of bytes modified in destination.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextEncoder()@m</dt>
	<dd>
この構築子の被呼出時には、新たな `TextEncoder$I ~objを返すモノトスル。
◎
The TextEncoder() constructor, when invoked, must return a new TextEncoder object.
</dd>

	<dt>`encode(input)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The encode(input) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%入力 ~LET %input を`~stream$に変換した結果
◎
Convert input to a stream.
</li>
			<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
			<li>
<p>
~WHILE 無条件 ：
◎
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenを読取る$( %入力 )
◎
Let token be the result of reading from input.
</li>
					<li>
%結果 ~LET `~tokenを処理する$( %~token, `~UTF-8~encoder$, %入力, %出力 )
◎
Let result be the result of processing token for the UTF-8 encoder, input, output.
</li>
					<li>
<p>
~Assert：
%結果 ~NEQ `~error$
◎
Assert: result is not error.
</p>

<p class="note">注記：
`~UTF-8~encoder$が`~error$を返すことはない。
◎
The UTF-8 encoder cannot return error.
</p>
					</li>
					<li>
~IF［
%結果 ~EQ `完遂d$
］
⇒
~RET ［［
%出力 を~byte列に変換した結果
］を包含する `ArrayBuffer$I
］を包装する，新たな `Uint8Array$I ~obj
◎
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>`encodeInto(source, destination)@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The encodeInto(source, destination) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%read ~LET 0
◎
Let read be 0.
</li>
			<li>
%written ~LET 0
◎
Let written be 0.
</li>
			<li>
%destinationBytes ~LET %destination が保持している`~byte列への参照を取得-$した結果
◎
Let destinationBytes be the result of getting a reference to the bytes held by destination.
</li>
			<li>
%~~上限 ~LET %destinationBytes の`長さ$byte
◎
↓</li>
			<li>
<p>
%利用されない ~LET 新たな`~stream$
◎
Let unused be a new stream.
</p>

<p class="note">注記：
下にて呼出される`~handler$~algoは
この引数を要求するが、`~UTF-8~encoder$はそれを利用しない。
◎
The handler algorithm invoked below requires this argument, but it is not used by the UTF-8 encoder.
</p>
			</li>
			<li>
%source ~SET %source を`~stream$に変換した結果
◎
Convert source to a stream.
</li>
			<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
				<ol>
					<li>
%~token ~LET `~tokenを読取る$( %source )
◎
Let token be the result of reading from source.
</li>
					<li>
%結果 ~LET 次を与える下で，`~UTF-8~encoder$の`~handler$を走らせた結果
⇒
( %利用されない, %~token )
◎
Let result be the result of running the UTF-8 encoder’s handler on unused and token.
</li>
					<li>
~IF［
%結果 ~EQ `完遂d$
］
⇒
~BREAK
◎
If result is finished, then break.
◎
Otherwise:
</li>
					<li>
~IF［
%written ~PLUS %結果 を成す~byte数 ~GT %~~上限
］
⇒
~BREAK
◎
If destinationBytes’s length − written is greater than or equal to the number of bytes in result, then:
</li>
					<li>
%read ~INCBY ［
%~token ~LTE `FFFF^U ならば 1 ／
~ELSE_ 2
］
◎
• If token is greater than U+FFFF, then increment read by 2.
• Otherwise, increment read by 1.
</li>
					<li>
%destinationBytes の中へ，~byte~offset %written の所から %結果 を書込む
◎
• Write the bytes in result into destinationBytes, from byte offset written.
</li>
					<li>
%written ~INCBY %結果 を成す~byte数
◎
• Increment written by the number of bytes in result.
◎
Otherwise, break.
</li>
				</ol>
			</li>
			<li>
~RET 次のようにされた新たな `TextEncoderEncodeIntoResult$I 辞書
⇒＃
`read$m ~member ~SET %read,
`written$m ~member ~SET %written
◎
Return a new TextEncoderEncodeIntoResult dictionary whose read member is read and written member is written.
</li>
		</ol>
	</dd>
</dl>


<div class="example">
<p>
`encodeInto()$m ~methodを利用すれば、文字列を既存の `ArrayBuffer$I ~objの中へ~encodeできる。
下における様々な詳細は，読者~向けの演習として残しておくが、この例は，この~methodの~~用法の一つを示すものである：
◎
The encodeInto() method can be used to encode a string into an existing ArrayBuffer object. Various details below are left as an exercise for the reader, but this demonstrates an approach one could take to use this method:
</p>

<pre>
function convertString(%buffer, %input, %callback) {
  let %bufferSize = 256,
      %bufferStart = malloc(%buffer, %bufferSize),
      %writeOffset = 0,
      %readOffset = 0;
  while (true) {
    const view = new Uint8Array(%buffer, %bufferStart + %writeOffset, %bufferSize - %writeOffset),
          {%read, %written} = cachedEncoder.encodeInto(%input.substring(%readOffset), view);
    %readOffset += %read;
    %writeOffset += %written;
    if (%readOffset === %input.length) {
      %callback(%bufferStart, %writeOffset);
      free(%buffer, %bufferStart);
      return;
    }
    %bufferSize *= 2;
    %bufferStart = realloc(%buffer, %bufferStart, %bufferSize);
  }
}
</pre>
</div>

		</section>
		<section id="interface-mixin-generictransformstream">
<h3 title="Interface mixin GenericTransformStream">7.5. ~interface~mixin `GenericTransformStream^I</h3>

<p>
`GenericTransformStream$I ~interface~mixinは、~IDLにおいて`形式変換~stream$の概念を表現する。
それは、 `TransformStream$I ではない
— 同じ~interfaceを備え，その一つへ委譲されるが。
◎
The GenericTransformStream interface mixin represents the concept of a transform stream in IDL. It is not a TransformStream, though it has the same interface and it delegates to one.
</p>

<pre class="idl">
interface mixin `GenericTransformStream@I {
  readonly attribute `ReadableStream$I `readable$m;
  readonly attribute `WritableStream$I `writable$m;
};
</pre>

<p>
`GenericTransformStream$I を内包する各~objには、 `TransformStream$I 型の
`形式変換@
が結付けられる。
◎
An object that includes GenericTransformStream has an associated transform of type TransformStream.
</p>

<dl>
	<dt>`readable@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
此れの`形式変換$ . `readable^sl
◎
The readable attribute’s getter, when invoked, must return this object’s transform.[[readable]].
</dd>

	<dt>`writable@m</dt>
	<dd>
取得子は次を返すモノトスル
⇒
此れの`形式変換$ . `writable^sl
◎
The writable attribute’s getter, when invoked, must return this object’s transform.[[writable]].
</dd>
</dl>

		</section>
		<section id="interface-textdecoderstream">
<h3 title="Interface TextDecoderStream">7.6. Interface `TextDecoderStream$I</h3>

<pre class="idl">
[<a href="#dom-textdecoderstream">Constructor</a>(optional `DOMString$ %label = "utf-8", optional `TextDecoderOptions$I %options),
 `Exposed$=(Window,Worker)]
interface `TextDecoderStream@I {
};
`TextDecoderStream$I includes `TextDecoderCommon$I;
`TextDecoderStream$I includes `GenericTransformStream$I;
</pre>


<p>
各 `TextDecoderStream$I ~objには、次のものが結付けられる
⇒＃
`~decoder@ts,
`~stream@ts
◎
A TextDecoderStream object has an associated decoder, and stream.
</p>

<dl class="domintro">
	<dt>%decoder = new <a href="#dom-textdecoderstream">TextDecoderStream([%label = "utf-8" [, %options]])</a></dt>
	<dd>
新たな `TextDecoderStream$I ~objを返す。
◎
Returns a new TextDecoderStream object.
</dd>
	<dd>
%label が［
`~label$でない／
`replacement$n 用の`~label$である
］場合、 `RangeError$E が`投出-$される。
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`~encoding$decの`名前$を，小文字~化した上で返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
［
`~error~mode$dec ~EQ `fatal^l ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
［
`~BOMignore~flag$dec ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その`~chunk$たちは、 `writable$m に書込まれた~chunkたちに対し，`~encoding$decの`~decoder$を走らせた結果の文字列たちになる。
◎
Returns a readable stream whose chunks are strings resulting from running encoding’s decoder on the chunks written to writable.
</dd>

	<dt>%decoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、 `BufferSource$I ~chunkたちを受容して
— `readable$m に可用にされる前に —
`~encoding$decの`~decoder$にかける。
◎
Returns a writable stream which accepts BufferSource chunks and runs them through encoding’s decoder before making them available to readable.
</dd>
	<dd>
<p>
これは概して、 `ReadableStream$I 源の `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="example">
var %decoder = new TextDecoderStream(%encoding);
byteReadable
  .pipeThrough(%decoder)
  .pipeTo(%textWritable);
</pre>

</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l
かつ`~encoding$decの`~decoder$は`~error$を返す場合、
`readable$m, `writable$m
とも `TypeError$E で~errorにされることになる。
◎
If the error mode is "fatal" and encoding’s decoder returns error, both readable and writable will be errored with a TypeError.
</dd>
</dl>


<dl class="idl-def">
	<dt>`TextDecoderStream(label, options)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らすモノトスル：
◎
The TextDecoderStream(label, options) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%~encoding ~LET `~labelから~encodingを取得する$( %label )
◎
Let encoding be the result of getting an encoding from label.
</li>
			<li>
~IF［
%~encoding ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
			<li>
%dec ~LET 新たな `TextDecoderStream$I ~obj
◎
Let dec be a new TextDecoderStream object.
</li>
			<li>
%dec の`~encoding$dec ~SET %~encoding
◎
Set dec’s encoding to encoding.
</li>
			<li>
~IF［
%options の `fatal^mb ~member ~EQ ~T
］
⇒
%dec の`~error~mode$dec ~SET `fatal^l
◎
If options’s fatal member is true, then set dec’s error mode to "fatal".
</li>
			<li>
~IF［
%options の`ignoreBOM^c ~member ~EQ ~T
］
⇒
%dec の`~BOMignore~flag$dec ~SET ~ON
◎
If options’s ignoreBOM member is true, then set dec’s ignore BOM flag.
</li>
			<li>
%dec の`~decoder$ts ~SET %dec の`~encoding$dec用の新たな`~decoder$
◎
Set dec’s decoder to a new decoder for dec’s encoding, and＼
</li>
			<li>
%dec の`~stream$ts ~SET 新たな`~stream$
◎
set dec’s stream to a new stream.
</li>
			<li>
%開始~algo ~LET 引数をとらず，何も返さない~algo
◎
Let startAlgorithm be an algorithm that takes no arguments and returns nothing.
</li>
			<li>
%形式変換~algo ~LET
( %~chunk ) を引数に，次を走らす~algo
⇒
`~chunkを~decodeして~enqueueする$( %dec, %~chunk )
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the decode and enqueue a chunk algorithm with dec and chunk.
</li>
			<li>
%一掃する~algo ~LET 引数をとらず，次を走らす~algo
⇒
`一掃して~enqueueする$( %dec )
◎
Let flushAlgorithm be an algorithm which takes no arguments and runs the flush and enqueue algorithm with dec.
</li>
			<li>
%dec の`形式変換$ ~SET 次を~callした結果
⇒
`CreateTransformStream$jA( %開始~algo, %形式変換~algo, %一掃する~algo )
◎
Let transform be the result of calling CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm).
◎
Set dec’s transform to transform.
</li>
			<li>
~RET %dec
◎
Return dec.
</li>
		</ol>
	</dd>
</dl>

<div class="algorithm">
<p>
`~chunkを~decodeして~enqueueする@
~algoは、所与の
( `TextDecoderStream$I ~obj %dec, %~chunk )
に対し，次を走らす：
◎
The decode and enqueue a chunk algorithm, given a TextDecoderStream object dec and a chunk, runs these steps:
</p>

<ol>
	<li>
%~buffer源 ~LET %~chunk を `BufferSource$I 型の`~IDL値に変換-$した結果
⇒
例外が投出されたときは
⇒
~RET その例外で却下される~promise
◎
Let bufferSource be the result of converting chunk to a BufferSource. If this throws an exception, then return a promise rejected with that exception.
</li>
	<li>
%dec の`~stream$ts に次の結果を`~pushする$
⇒
`複製を取得する$( %~buffer源 )
⇒
例外が投出されたときは
⇒
~RET その例外で却下される~promise
◎
Push a copy of bufferSource to dec’s stream. If this throws an exception, then return a promise rejected with that exception.
</li>
	<li>
%制御器 ~LET 
%dec の`形式変換$ . `transformStreamController^sl
◎
Let controller be dec’s transform.[[transformStreamController]].
</li>
	<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
	<li>
<p>
~WHILE 無条件
◎
While true, run these steps:
</p>
		<ol>
			<li>
%~token ~LET `~tokenを読取る$( %dec の`~stream$ts )
◎
Let token be the result of reading from dec’s stream.
</li>
			<li>
<p>
~IF［
%~token ~EQ `~EoS$
］：
◎
If token is end-of-stream, run these steps:
</p>
				<ol>
					<li>
%出力~chunk ~LET `~streamを直列化する$dec( %出力 )
◎
Let outputChunk be output, serialized.
</li>
					<li>
~IF［
%出力~chunk は空でない
］
⇒
次を~callする
⇒
`TransformStreamDefaultControllerEnqueue$jA( %制御器, %出力~chunk )
◎
if outputChunk is non-empty, call TransformStreamDefaultControllerEnqueue(controller, outputChunk).
</li>
					<li>
~RET `undefined^jv で解決される新たな~promise
◎
Return a new promise resolved with undefined.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~tokenを処理する$( %~token, %dec の`~decoder$ts, %dec の`~stream$ts, %出力, %dec の`~error~mode$dec )
◎
Let result be the result of processing token for dec’s decoder, dec’s stream, output, and dec’s error mode.
</li>
			<li>
~IF［
%結果 ~EQ `~error$
］
⇒
~RET `TypeError$E 例外で却下される新たな~promise
◎
If result is error, then return a new promise rejected with a TypeError exception.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`一掃して~enqueueする@
~algoは、
入力 `ReadableStream$I ~objからの~dataの終端を取扱う
— それは、所与の
( `TextDecoderStream$I ~obj %dec )
に対し，次を走らす：
◎
The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a TextDecoderStream object dec, runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
	<li>
%結果 ~LET `~tokenを処理する$( `~EoS$, %dec の`~decoder$ts, %dec の`~stream$ts, %出力, %dec の`~error~mode$dec )
◎
Let result be the result of processing end-of-stream for dec’s decoder and dec’s stream, output, and dec’s error mode.
</li>
	<li>
<p>
~IF［
%結果 ~EQ `完遂d$
］：
◎
If result is finished, run these steps:
</p>
		<ol>
			<li>
%出力~chunk ~LET `~streamを直列化する$dec( %出力 )
◎
Let outputChunk be output, serialized.
</li>
			<li>
%制御器 ~LET 
%dec の`形式変換$ . `transformStreamController^sl
◎
Let controller be dec’s transform.[[transformStreamController]].
</li>
			<li>
~IF［
%出力~chunk は空でない
］
⇒
次を~callする
⇒
`TransformStreamDefaultControllerEnqueue$jA( %制御器, %出力~chunk )
◎
If outputChunk is non-empty, call TransformStreamDefaultControllerEnqueue(controller, outputChunk).
</li>
			<li>
~RET `undefined^jv で解決される新たな~promise
◎
Return a new promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET `TypeError$E 例外で却下される新たな~promise
◎
Otherwise, return a new promise rejected with a TypeError exception.
</li>
	</ol>
</div>


		</section>
		<section id="interface-textencoderstream">
<h3 title="Interface TextEncoderStream">7.7. ~interface `TextEncoderStream^I</h3>

<pre class="idl">
[<a href="#dom-textencoderstream">Constructor</a>,
 `Exposed$=(Window,Worker)]
interface `TextEncoderStream@I {
};

`TextEncoderStream$I includes `TextEncoderCommon$I;
`TextEncoderStream$I includes `GenericTransformStream$I;
</pre>


<p>
各 `TextEncoderStream$I ~objには、次のものが結付けられる
⇒＃
`~encoder@ts,
`処理待ち高位~surrogate@ （初期~時には~NULL)
◎
A TextEncoderStream object has an associated encoder, and pending high surrogate (initially null).
</p>

<p class="note">注記：
`TextEncoderStream$I ~objは `UTF-8$n しか~supportしないので、
%~label 引数 を提供しない。
◎
A TextEncoderStream object offers no label argument as it only supports UTF-8.
</p>

<dl class="domintro">
	<dt>%encoder = new `TextEncoderStream()$m</dt>
	<dd>
新たな `TextEncoderStream$I ~objを返す。
◎
Returns a new TextEncoderStream object.
</dd>
	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `readable$m</dt>
	<dd>
`可読~stream$を返す。
その各`~chunk$は、 `writable$m に書込まれた~chunkたちに対し
`UTF-8$n の`~encoder$を走らせた結果の `Uint8Array$I になる。
◎
Returns a readable stream whose chunks are Uint8Arrays resulting from running UTF-8’s encoder on the chunks written to writable.
</dd>

	<dt>%encoder . `writable$m</dt>
	<dd>
`可書~stream$を返す。
それは、文字列~chunkたちを受容して
— `readable$m に可用にされる前に —
`UTF-8$n の`~encoder$にかける。
◎
Returns a writable stream which accepts string chunks and runs them through UTF-8’s encoder before making them available to readable.
</dd>
	<dd>
<p>
これは概して、
`ReadableStream$I 源の `pipeThrough$m ~methodを介して利用されることになる。
◎
Typically this will be used via the pipeThrough() method on a ReadableStream source.
</p>

<pre class="example">
%textReadable
  .pipeThrough(new TextEncoderStream())
  .pipeTo(%byteWritable);
</pre>

	</dd>
</dl>


<dl class="idl-def">
	<dt>`TextEncoderStream()@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らすモノトスル：
◎
The TextEncoderStream() constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%enc ~LET 新たな `TextEncoderStream$I ~obj
◎
Let enc be a new TextEncoderStream object.
</li>
			<li>
%enc の`~encoder$ts ~SET `UTF-8$n の`~encoder$
◎
Set enc’s encoder to UTF-8’s encoder.
</li>
			<li>
%開始~algo ~LET 引数をとらず，何も返さない~algo
◎
Let startAlgorithm be an algorithm that takes no arguments and returns nothing.
</li>
			<li>
%形式変換~algo ~LET ( %~chunk ) を引数に，次を走らす~algo
⇒
`~chunkを~encodeして~enqueueする$( %enc, %~chunk )
◎
Let transformAlgorithm be an algorithm which takes a chunk argument and runs the encode and enqueue a chunk algorithm with enc and chunk.
</li>
			<li>
%一掃する~algo ~LET 次を走らす~algo
⇒
`~encodeして一掃する$( %enc )
◎
Let flushAlgorithm be an algorithm which runs the encode and flush algorithm with enc.
</li>
			<li>
%enc の`形式変換$ ~SET 次を~callした結果
⇒
`CreateTransformStream$jA( %開始~algo, %形式変換~algo, %一掃する~algo )
◎
Let transform be the result of calling CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm).
◎
Set enc’s transform to transform.
</li>
			<li>
~RET %enc
◎
Return enc.
</li>
		</ol>
	</dd>
</dl>

<hr>

<div class="algorithm">
<p>
`~chunkを~encodeして~enqueueする@
~algoは、所与の
( `TextEncoderStream$I ~obj %enc, %~chunk )
に対し，次を走らす：
◎
The encode and enqueue a chunk algorithm, given a TextEncoderStream object enc and chunk, runs these steps:
</p>

<ol>
	<li>
<p>
%入力 ~LET %~chunk を `DOMString^I 型の`~IDL値に変換-$した結果
⇒
例外が投出されたときは
⇒
~RET その例外で却下される~promise
◎
Let input be the result of converting chunk to a DOMString. If this throws an exception, then return a promise rejected with that exception.
</p>

<p class="note">注記：
ここでは `DOMString^I が利用される
— 2 つの~chunkに分割された~surrogate~pairを，適切な~scalar値に組み立て直せるようにするため。
他の挙動は `USVString^I と一致する
— 特に，~~孤立した~surrogateは `FFFD^U に置換されることになる。
◎
DOMString is used here so that a surrogate pair that is split between chunks can be reassembled into the appropriate scalar value. The behavior is otherwise identical to USVString. In particular, lone surrogates will be replaced with U+FFFD.
</p>
	</li>
	<li>
%入力 を`~stream$に変換する
◎
Convert input to a stream.
</li>
	<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
	<li>
%制御器 ~LET 
%enc の`形式変換$ . `transformStreamController^sl
◎
Let controller be enc’s transform.[[transformStreamController]].
</li>
	<li>
<p>
~WHILE 無条件
◎
While true, run these steps:
</p>
		<ol>
			<li>
%~token ~LET `~tokenを読取る$( %入力 )
◎
Let token be the result of reading from input.
</li>
			<li>
<p>
~IF［
%~token ~EQ `~EoS$
］：
◎
If token is end-of-stream, run these steps:
</p>
				<ol>
					<li>
%出力 ~SET %出力 を~byte列に変換した結果
◎
Convert output into a byte sequence.
</li>
					<li>
<p>
~IF［
%出力 は空でない
］：
◎
If output is non-empty, run these steps:
</p>
						<ol>
							<li>
%~chunk ~LET %出力 を包含している `ArrayBuffer$I を包装する，新たな `Uint8Array$I ~obj
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
							<li>
次を~callする
⇒
`TransformStreamDefaultControllerEnqueue$jA( %制御器, %~chunk )
◎
Call TransformStreamDefaultControllerEnqueue(controller, chunk).
</li>
						</ol>
					</li>
					<li>
~RET `undefined^jv で解決される新たな~promise
◎
Return a new promise resolved with undefined.
</li>
				</ol>
			</li>
			<li>
%結果 ~LET `~cuを~scalar値に変換する$( %enc, %~token, %入力 )
◎
Let result be the result of executing the convert code unit to scalar value algorithm with enc, token and input.
</li>
			<li>
~IF［
%結果 ~NEQ `継続-$
］
⇒
`~tokenを処理する$( %結果, `~encoder$ts, %入力, %出力 )
◎
If result is not continue, then process result for encoder, input, output.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">
<p>
`~cuを~scalar値に変換する@
~algoは、所与の
( `TextEncoderStream$I ~obj %enc, %~token, ~stream %入力 )
に対し，次を走らす：
◎
The convert code unit to scalar value algorithm, given a TextEncoderStream object enc, token, and stream input, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%enc の`処理待ち高位~surrogate$ ~NEQ ~NULL
］：
◎
If enc’s pending high surrogate is non-null, run these steps:
</p>
		<ol>
			<li>
%高位~surrogate ~LET 
%enc の`処理待ち高位~surrogate$

◎
Let high surrogate be enc’s pending high surrogate.
</li>
			<li>
%enc の`処理待ち高位~surrogate$ ~SET ~NULL
◎
Set enc’s pending high surrogate to null.
</li>
			<li>
~IF［
%~token ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET ~cp [ `10000^X + (( %高位~surrogate ~MINUS `D800^X ) ~Lshift 10) + ( %~token ~MINUS `DC00^X ) ]
◎
If token is in the range U+DC00 to U+DFFF, inclusive, then return a code point whose value is 0x10000 + ((high surrogate − 0xD800) &lt;&lt; 10) + (token − 0xDC00).
</li>
			<li>
%入力 に %~token を`前付加する$
◎
Prepend token to input.
</li>
			<li>
~RET `FFFD^U 
◎
Return U+FFFD.
</li>
		</ol>
	</li>
	<li>
~IF［
%~token ~IN { `D800^U 〜 `DBFF^U }
］
⇒＃
`処理待ち高位~surrogate$ ~SET %~token；
~RET `継続-$
◎
If token is in the range U+D800 to U+DBFF, inclusive, then set pending high surrogate to token and return continue.
</li>
	<li>
~IF［
%~token ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET `FFFD^U
◎
If token is in the range U+DC00 to U+DFFF, inclusive, then return U+FFFD.
</li>
	<li>
~RET %~token
◎
Return token.
</li>
</ol>

<p class="note">注記：
これは `INFRA$r による
`~JS文字列$を`~scalar値~文字列$に
<a href="~INFRA#javascript-string-convert">変換する~algo</a>と等価になるが、
2 つの文字列に分割された~surrogate~pairも許容する。
`INFRA$r
◎
This is equivalent to the "convert a JavaScript string into a scalar value string" algorithm from the Infra Standard, but allows for surrogate pairs that are split between strings. [INFRA]
</p>
</div>

<div class="algorithm">
<p>
`~encodeして一掃する@
~algoは、所与の
( `TextEncoderStream$I ~obj %enc )
に対し，次を走らす：
◎
The encode and flush algorithm, given a TextEncoderStream object enc, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%enc の`処理待ち高位~surrogate$ ~NEQ ~NULL
］：
◎
If enc’s pending high surrogate is non-null, run these steps:
</p>
		<ol>
			<li>
%制御器 ~LET %enc の`形式変換$ . `transformStreamController^sl
◎
Let controller be enc’s transform.[[transformStreamController]].
</li>
			<li>
<p>
%出力 ~LET ~byte列 `EF^X `BF^X `BD^X
◎
Let output be the byte sequence 0xEF 0xBF 0xBD.
</p>

<p class="note">注記：
これは、~replacement文字 `FFFD^U を~UTF-8に~encodeしたものになる。
◎
This is the replacement character U+FFFD encoded as UTF-8.
</p>
			</li>
			<li>
%~chunk ~LET %出力 を包含している `ArrayBuffer$I を包装する，新たな `Uint8Array$I ~obj
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
			<li>
次を~callする
⇒
`TransformStreamDefaultControllerEnqueue$jA( %制御器, %~chunk )
◎
Call TransformStreamDefaultControllerEnqueue(controller, chunk).
</li>
		</ol>
	</li>
	<li>
~RET `undefined^jv で解決される新たな~promise
◎
Return a new promise resolved with undefined.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="the-encoding">
<h2 title="The encoding">8. ~~標準の~encoding</h2>

<p class="trans-note">【
この “~~標準の” は “The” の対訳であり、およそ，
“規範とされるべき唯一無二の”
を意味する。
】</p>

		<section id="utf-8">
<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8~decoder</h4>

<p class="note">注記：
~BOMは、`~label$より~~優先される
— その方が配備-済みの内容において正確aになるものと見出されたので。
したがってそれは、`~UTF-8~decoder$~algoの一部を成さない
— 代わりに［
`~Unicodeに~decodeする$ ／ `~UTF-8~decodeする$
］~algoの一部を成す。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the UTF-8 decoder algorithm but rather the decode and UTF-8 decode algorithms.
</p>


<p>
各［
`UTF-8$n の`~decoder$
］には、次のものが結付けられる
⇒＃
`~UTF-8~cp@（初期~時 0 ）,
`~UTF-8出現~byte数@（初期~時 0 ）,
`~UTF-8要~byte数@（初期~時 0 ）,
`~UTF-8下限@（初期~時 `80^X ）,
`~UTF-8上限@（初期~時 `BF^X ）
◎
UTF-8’s decoder’s has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
`UTF-8$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
UTF-8’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］~AND［
`~UTF-8要~byte数$ ~NEQ 0
］
⇒＃
`~UTF-8要~byte数$ ~SET 0；
~RET `~error$
◎
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
<p>
~IF［
`~UTF-8要~byte数$ ~EQ 0
］：
◎
If UTF-8 bytes needed is 0, based on byte:
</p>

		<ol>
			<li>
<p>
%~byte に応じて：
◎
↑</p>

				<dl class="switch">
					<dt>`00^X 〜 `7F^X</dt>
					<dd>
~RET ~cp [ %~byte ]
◎
Return a code point whose value is byte.
</dd>

					<dt>`C2^X 〜 `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8要~byte数$ ~SET 1
◎
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">（ %~byte の下位 5 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x1F.
◎
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X 〜 `EF^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `E0^X
］
⇒
`~UTF-8下限$ ~SET `A0^X
◎
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IF［
%~byte ~EQ `ED^X
］
⇒
`~UTF-8上限$ ~SET `9F^X
◎
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 2
◎
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">（ %~byte の下位 4 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0xF.
◎
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X 〜 `F4^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `F0^X
］
⇒
`~UTF-8下限$ ~SET `90^X
◎
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IF［
%~byte ~EQ `F4^X
］
⇒
`~UTF-8上限$ ~SET `8F^X
◎
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 3
◎
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">（ %~byte の下位 3 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x7.
◎
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>
その他
◎
Otherwise
</dt>
					<dd>
~RET `~error$
◎
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `継続-$
◎
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~byte ~NIN { `~UTF-8下限$ 〜 `~UTF-8上限$ }
］：
◎
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, then:
</p>

		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0,＼
</li>
			<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
			<li>
%~byte を %~stream に`前付加する$
◎
Prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
◎
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
`~UTF-8~cp$内の既存の~bitを左へ 6 ~bit ~shiftして，~~空いた下位 6 ~bitに %~byte の下位 6 ~bitをあてがう。
◎
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8出現~byte数$ ~INCBY 1
◎
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IF［
`~UTF-8出現~byte数$ ~NEQ `~UTF-8要~byte数$
］
⇒
~RET `継続-$
◎
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
◎
Let code point be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 ) 
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

<p class="note">注記：
上の`~UTF-8~decoder$における拘束は、~Unicode標準の
“Best Practices for Using U+FFFD”
に準じる。
他のふるまいは Encoding 標準の下では許可されない（同じ結果が得られるなら、他の~algoでも~~十分であり，むしろ奨励される）。
`UNICODE$r
◎
The constraints in the UTF-8 decoder above match “Best Practices for Using U+FFFD” from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8~encoder</h4>

<p>
`UTF-8$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
UTF-8’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp が属する範囲に応じて
⇒＃
{ `0080^U 〜 `07FF^U } ならば ( 1, `C0^X ) ／
{ `0800^U 〜 `FFFF^U } ならば ( 2, `E0^X ) ／
{ `10000^U 〜 `10FFFF^U } ならば ( 3, `F0^X )
◎
Set count and offset based on the range code point is in:
◎
U+0080 to U+07FF, inclusive
• 1 and 0xC0
U+0800 to U+FFFF, inclusive
• 2 and 0xE0
U+10000 to U+10FFFF, inclusive
• 3 and 0xF0
</li>
	<li>
%~byte列 ~LET ~byte列 [ ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset ]
◎
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 × count)) + offset.
</li>
	<li>
<p>
~WHILE %count ~GT 0
：
◎
While count is greater than 0:
</p>

		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
◎
Set temp to code point &gt;&gt; (6 × (count − 1)).
</li>
	<li>
%~byte列 に
( `80^X ~bOR ( %temp ~bAND `3F^X ) )
を付加する
◎
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
	<li>
%count ~DECBY 1
◎
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byte列
◎
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
この~algoは、~Unicode標準に述べられるものと一致する結果を得るが，完全さのためここに含められている。
`UNICODE$r
◎
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>


			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">
<h2 title="Legacy single-byte encodings">9. 旧来の単byte~encoding</h2>

<p>
各~byteが［
１個の~cpに対応するか, または対応する~cpは無い
］ような`~encoding$を
`単byte~encoding@
と呼ぶ。
すべての`単byte~encoding$が、同じ［
`~decoder$, `~encoder$
］を共有する。
`単byte~decoder$／`単byte~encoder$から参照される
`単byte索引@
は、利用される`単byte~encoding$に依存し，次の一覧で定義される。
［
`ISO-8859-8^n, `ISO-8859-8-I^n
］を除くすべての`単byte~encoding$は、それぞれに一意な`索引$を持つ。
◎
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">【
被覆域の~tableは巨大なことに注意。
】</p>

<table>
<thead><tr><th>`名前$
<th>`索引$
<th>視覚-化
<th>基本多言語面（ BMP ）の被覆域
</thead>

<tbody>
<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n と同じ
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</tbody>
</table>

<p class="note">注記：
~layout方向に波及することから、 `ISO-8859-8$n と `ISO-8859-8-I$n の`~encoding$の`名前$は異なるものにされている。
歴史的に、このことは `ISO-8859-6$n と "ISO-8859-6-I" についても該当していたが、それはもはや成立しない。
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->
◎
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>



		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. 単byte~decoder</h3>

<p>
`単byte~encoding$の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Single-byte encodings’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`単byte索引$ の中で
( %~byte ~MINUS `80^X )
が指す`索引~cp$
◎
Let code point be the index code point for byte − 0x80 in index single-byte.
</li>
	<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. 単byte~encoder</h3>

<p>
`単byte~encoding$ の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Single-byte encodings’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`単byte索引$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index single-byte.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
~RET ~byte列 [ %~pointer ~PLUS `80^X ]
◎
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">
<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. 旧来の複byte Chinese （簡体字） ~encoding</h2>

		<section id="gbk">
<h3 title="GBK">10.1 ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1 ~GBK~decoder</h4>

<p>
`GBK$n の`~decoder$は，`gb18030$n の`~decoder$である。
◎
GBK’s decoder is gb18030’s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2 ~GBK~encoder</h4>

<p>
`GBK$n の~encoderは，［
`~GBK~flag$ ~SET ~ON
］にされた`gb18030$n の`~encoder$である。
◎
GBK’s encoder is gb18030’s encoder with its GBK flag set.
</p>


<p class="note">注記：
`GBK$n を`gb18030$nに対する全くの別名にしないのは、
`GBK$n の`~encoder$により生成された内容を，旧来の~serverや他の消費者をなるべく壊すことなく，保守的に移行するためである。
◎
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK’s encoder.
</p>
			</section>
		</section>


		<section id="gb18030">
<h3 title="gb18030">10.2. ~gb18030</h3>


			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030~decoder</h4>

<p>
各［
`gb18030$n の`~decoder$
］には、次のものが結付けられる
⇒＃
`~gb1@（初期~時 0 ）,
`~gb2@（初期~時 0 ）,
`~gb3@（初期~時 0 ）
◎
gb18030’s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
`gb18030$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
gb18030’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
］
⇒
~RET `完遂d$
◎
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and＼
</li>
			<li>
~RET `~error$
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb3$ ~NEQ `00^X
］：
◎
If gb18030 third is not 0x00, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~byte ~NIN { `30^X 〜 `39^X }
］：
◎
If byte is not in the range 0x30 to 0x39, inclusive, then:
</p>
				<ol>
					<li>
~byte列 [ `~gb2$, `~gb3$, %~byte ] を %~stream に`前付加する$
◎
Prepend gb18030 second, gb18030 third, and byte to stream.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$
◎
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET 次に与える~pointerが指す`索引~gb18030範囲集~cp$
⇒
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
◎
Let code point be the index gb18030 ranges code point for ((gb18030 first − 0x81) × (10 × 126 × 10)) + ((gb18030 second − 0x30) × (10 × 126)) + ((gb18030 third − 0x81) × 10) + byte − 0x30.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
			<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
			<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb2$ ~NEQ `00^X
］：
◎
If gb18030 second is not 0x00, then:
</p>

		<ol>
			<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb3$ ~SET %~byte ；
~RET `継続-$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>
			<li>
~byte列 [ `~gb2$, %~byte ] を %~stream に`前付加する$
◎
Prepend gb18030 second followed by byte to stream,＼
</li>
			<li>
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X )
◎
set gb18030 first and gb18030 second to 0x00, and＼
</li>
			<li>
~RET `~error$
◎
return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb1$ ~NEQ `00^X
］：
◎
If gb18030 first is not 0x00, then:
</p>

		<ol>
			<li>
~IF［
%~byte ~IN { `30^X 〜 `39^X }
］
⇒＃
`~gb2$ ~SET %~byte ；
~RET `継続-$
◎
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$
◎
Let lead be gb18030 first,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null, and＼
</li>
			<li>
`~gb1$ ~SET `00^X
◎
set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − offset).
</li>
			<li>
%~cp ~LET %~pointer に応じて
⇒
~NULL ならば ~NULL ／
~ELSE_ `索引~gb18030$ の中で %~pointer が指す`索引~cp$
◎
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~gb1$ ~SET %~byte ；
~RET `継続-$
◎
↓</li>
	<li>
~RET %~byte に応じて
⇒＃
`~ASCII~byte$ならば ~cp [ %~byte ] ／
`80^X ならば ~cp [ `20AC^U ] ／
 `FF^X  ならば `~error$
◎
If byte is an ASCII byte, return a code point whose value is byte.
◎
If byte is 0x80, return code point U+20AC.
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
◎
Return error.
</li>
</ol>


			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030~encoder</h4>

<p>
各［
`gb18030$n の`~encoder$
］には、次のものが結付けられる
⇒
`~GBK~flag@（初期~時 ~OFF ）
◎
gb18030’s encoder has an associated GBK flag (initially unset).
</p>

<p>
`gb18030$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
gb18030’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
%~cp ~EQ `E5E5^U
］
⇒
~RET %~cp を伴う`~error$
◎
If code point is U+E5E5, return error with code point.
</p>

<p class="note">注記：
配備-済みの内容との互換性を得るため、 `索引~gb18030$ は［
`A3^X `A0^X
］を `E5E5^U ではなく `3000^U に対応付けている。
したがって往来できない。
◎
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IF［
`~GBK~flag$ ~EQ ~ON
］~AND［
%~cp ~EQ `20AC^U
］
⇒
~RET ~byte列 [ `80^X ]
◎
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>
	<li>
%~pointer ~LET
`索引~gb18030$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index gb18030.
</li>
	<li>
<p>
~IF［
%~pointer ~NEQ ~NULL
］：
◎
If pointer is non-null, then:
</p>

		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
◎
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ［
%~trail  ~IN { `00^X 〜 `3E^X } ならば `40^X<!--0x7F-0x40--> ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>
			<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IF［
`~GBK~flag$ ~EQ ~ON
］
⇒
~RET %~cp を伴う`~error$
◎
If GBK flag is set, return error with code point.
</li>
	<li>
%~pointer ~SET
%~cp
を指す`索引~gb18030範囲集~pointer$
◎
Set pointer to the index gb18030 ranges pointer for code point.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
◎
Let byte1 be pointer / (10 × 126 × 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
◎
Set pointer to pointer % (10 × 126 × 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
◎
Let byte2 be pointer / (10 × 126). 
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
◎
Set pointer to pointer % (10 × 126). 
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
◎
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
◎
Let byte4 be pointer % 10. 
</li>
	<li>
~RET ~byte列 [
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
]
◎
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">
<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. 旧来の複byte Chinese （繁体字）~encoding</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


		<section id="big5">
<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5~decoder</h4>

<p>
各［
`Big5$n の`~decoder$
］には、次のものが結付けられる
⇒
`~Big5~lead@（初期~時 `00^X ）
◎
Big5’s decoder has an associated Big5 lead (initially 0x00).
</p>

<p>
`Big5$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Big5’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
</p>

		<ol>
			<li>
~IF［
`~Big5~lead$ ~NEQ `00^X
］
⇒＃
`~Big5~lead$ ~SET `00^X ；
~RET `~error$
</li>
			<li>
~RET `完遂d$
</li>
		</ol>
◎
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
◎
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>
	<li>
<p>
~IF［
`~Big5~lead$ ~NEQ `00^X
］：
◎
If Big5 lead is not 0x00,＼
</p>

		<ol>
			<li>
%~lead ~LET `~Big5~lead$
◎
 let lead be Big5 lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~Big5~lead$ ~SET `00^X
◎
set Big5 lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `62^X <!-- 0x62 = 0xA1-0x7E+1+0x40 -->
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `A1^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 + (byte − offset).
</li>
			<li>
<p>
~IF［
下の表の中で， 1 列目が %~pointer に等しい行がある
］
⇒
~RET 同じ行の 2 列目の <em>2 個の</em> ~cpからなる`~token$列
◎
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

<!-- https://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
<table><thead><tr><th>~pointer◎ Pointer
<th>~cp◎ Code points
<th>説明（この段には無関連）◎ Notes
</thead>

<tbody id="_big5-lead"><tr><td>1133<!-- 0x88 0x62 -->
<td>`00CA^U `0304^U
<td>Ê̄ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1135<!-- 0x88 0x64 -->
<td>`00CA^U `030C^U
<td>Ê̌ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

<tr><td>1164<!-- 0x88 0xA3 -->
<td>`00EA^U `0304^U
<td>ê̄ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1166<!-- 0x88 0xA5 -->
<td>`00EA^U `030C^U
<td>ê̌ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</tbody></table>
<!-- we do this to avoid PUA -->


<p class="note">注記：
`索引$ は単独の~cpに制限されるので、これらの~pointerにはこの表が利用される。
◎
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~Big5$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~Big5~lead$ ~SET %~byte ；
~RET `継続-$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5~encoder</h4>

<p>
`Big5$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Big5’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET %~cp を指す`索引~Big5~pointer$
◎
Let pointer be the index Big5 pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
◎
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
◎
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X<!--0x7F-0x40--> ／
~ELSE_ `62^X<!--0xA1-0x3F-->
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>
	<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">
<h2 title="Legacy multi-byte Japanese encodings">12. 旧来の複byte Japanese ~encoding</h2>


		<section id="euc-jp">
<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JP~decoder</h4>

<p>
各［
`EUC-JP$n の`~decoder$
］には、次のものが結付けられる
⇒＃
`~EUC-JP~jis0212~flag@（初期~時 ~OFF ）；
`~EUC-JP~lead@（初期~時 `00^X）
◎
EUC-JP’s decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
`EUC-JP$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-JP’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET `~error$
◎
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$
◎
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
~IF［
`~EUC-JP~lead$ ~EQ `8E^X
］~AND［
%~byte ~IN { `A1^X 〜 `DF^X }
］
⇒＃
`~EUC-JP~lead$ ~SET `00^X ；
~RET ~cp [ `FF61^X ~MINUS `A1^X ~PLUS %~byte ]
◎
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8F^X
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~jis0212~flag$ ~SET ~ON ；
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$
◎
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］：
◎
If EUC-JP lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$
◎
let lead be EUC-JP lead,＼
</li>
			<li>
`~EUC-JP~lead$ ~SET `00^X
◎
set EUC-JP lead to 0x00, and then:
</li>
			<li>
%~cp ~LET ~NULL
◎
Let code point be null.
</li>
			<li>
<p>
~IF［
%~lead ~IN { `A1^X 〜 `FE^X }
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］：
</p>
				<ol>
					<li>
%索引 ~LET `~EUC-JP~jis0212~flag$に応じて
⇒＃
~OFF ならば`索引~jis0208$ ／
~ON ならば `索引~jis0212$
</li>
					<li>
%~cp ~SET %索引 の中で
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
が指す`索引~cp$
</li>
				</ol>
◎
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212~flag$ ~SET ~OFF
◎
Unset the EUC-JP jis0212 flag.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `8E^X, `8F^X, `A1^X 〜 `FE^X }
］
⇒＃
`~EUC-JP~lead$ ~SET %~byte ；
~RET `継続-$
◎
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>


			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JP~encoder</h4>

<p>
`EUC-JP$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-JP’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoS$ ならば `完遂d$ ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
`FF61^U 〜 `FF9F^U ならば ~byte列 [ `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) ] ／
~ELSE_ ~NULL
◎
If code point is end-of-stream, return finished.
◎
If code point is an ASCII code point, return a byte whose value is code point.
◎
If code point is U+00A5, return byte 0x5C.
◎
If code point is U+203E, return byte 0x7E.
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、 ~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
◎
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
◎
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">
<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JP~decoder</h4>

<p>
各［
`ISO-2022-JP$n の`~decoder$
］には、次のものが結付けられる
⇒＃
`~ISO-2022-JP~decoder状態@（初期~時 `ASCII$i）,
`~ISO-2022-JP~decoder出力~状態@（初期~時 `ASCII$i ）,
`~ISO-2022-JP~lead@（初期~時 `00^X ）,
`~ISO-2022-JP出力~flag@（初期~時 ~OFF ）
◎
ISO-2022-JP’s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
`ISO-2022-JP$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，`~ISO-2022-JP~decoder状態$に応じて 次を走らす：
◎
ISO-2022-JP’s decoder’s handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ；
~RET `継続-$
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`0E^X, `0F^X, `1B^X 以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET ~cp [ %~byte ]
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
• Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</li>
			<li>
`~EoS$
⇒＃
~RET `完遂d$
◎
end-of-stream
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET `~error$
◎
Otherwise
• Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ；
~RET `継続-$
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`5C^X
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET ~cp [ `00A5^U ]
◎
0x5C
• Unset the ISO-2022-JP output flag and return code point U+00A5.
</li>
			<li>
`7E^X
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET ~cp [ `203E^U ]
◎
0x7E
• Unset the ISO-2022-JP output flag and return code point U+203E.
</li>
			<li>
`0E^X, `0F^X, `1B^X, `5C^X, `7E^X
以外の`~ASCII~byte$
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET ~cp [ %~byte ]
◎
0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
• Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</li>
			<li>
`~EoS$
⇒＃
~RET `完遂d$
◎
end-of-stream
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET `~error$
◎
Otherwise
• Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ；
~RET `継続-$
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `5F^X
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET ~cp [ `FF61^X ~MINUS `21^X ~PLUS %~byte ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
0x21 to 0x5F
• Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 − 0x21 + byte.
</li>
			<li>
`~EoS$
⇒＃
~RET `完遂d$
◎
end-of-stream
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET `~error$
◎
Otherwise
• Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ；
~RET `継続-$
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return continue.
</li>
			<li>
`21^X 〜 `7E^X
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP~decoder状態$ ~SET `~trail~byte$i ；
~RET `継続-$
◎
0x21 to 0x7E
• Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</li>
			<li>
`~EoS$
⇒＃
~RET `完遂d$
◎
end-of-stream
• Return finished.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP出力~flag$ ~SET ~OFF ；
~RET `~error$
◎
Otherwise
• Unset the ISO-2022-JP output flag and return error.
</li>
		</ol>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<ol class="switch">
			<li>
`1B^X
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ；
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
0x1B
• Set ISO-2022-JP decoder state to escape start and return error.
</li>
			<li>
<p>
`21^X 〜 `7E^X
：
◎
0x21 to 0x7E
</p>
				<ol>
					<li>
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i
◎
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
◎
Let pointer be (ISO-2022-JP lead − 0x21) × 94 + byte − 0x21.
</li>
					<li>
%~cp ~LET
`索引~jis0208$ の中で %~pointer が指す`索引~cp$
◎
Let code point be the index code point for pointer in index jis0208.
</li>
					<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
					<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
				</ol>
			</li>
			<li>
`~EoS$
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i ；
%~byte を %~stream に`前付加する$ ；
~RET `~error$
◎
end-of-stream
• Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</li>
			<li>
その他
⇒＃
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i ；
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
Otherwise
• Set ISO-2022-JP decoder state to lead byte and return error.
</li>
		</ol>
	</dd>

	<dt>`~escape開始@i</dt>
	<dd>
		<ol>
			<li>
~IF［
%~byte ~IN { `24^X<!--＄-->, `28^X<!--(--> }
］
⇒＃
`~ISO-2022-JP~lead$ ~SET %~byte ；
`~ISO-2022-JP~decoder状態$ ~SET `~escape$i ；
~RET `継続-$
◎
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
%~byte を %~stream に`前付加する$
◎
Prepend byte to stream.
</li>
			<li>
`~ISO-2022-JP出力~flag$ ~SET ~OFF
◎
Unset the ISO-2022-JP output flag,＼
</li>
			<li>
`~ISO-2022-JP~decoder状態$ ~SET `~ISO-2022-JP~decoder出力~状態$
◎
set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and＼
</li>
			<li>
~RET `~error$
◎
return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$
◎
Let lead be ISO-2022-JP lead and＼
</li>
			<li>
`~ISO-2022-JP~lead$ ~SET `00^X
◎
set ISO-2022-JP lead to 0x00.
</li>
			<li>
%状態 ~LET 
( %~lead, %~byte )
に応じて
⇒＃
( `28^X, `42^X<!--B--> ) ならば `ASCII$i ／
( `28^X, `4A^X<!--J--> ) ならば `Roman$i1 ／
( `28^X, `49^X<!--I--> ) ならば `katakana$i ／
( `24^X, `40^X<!--＠--> ) ならば `~lead~byte$i ／
( `24^X, `42^X<!--B-->  ) ならば `~lead~byte$i ／
~ELSE_ ~NULL
◎
Let state be null.
◎
If lead is 0x28 and byte is 0x42, set state to ASCII.
◎
If lead is 0x28 and byte is 0x4A, set state to Roman.
◎
If lead is 0x28 and byte is 0x49, set state to katakana.
◎
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IF［
%状態 ~NEQ ~NULL
］：
◎
If state is non-null, then:
</p>

				<ol>
					<li>
`~ISO-2022-JP~decoder状態$ ~SET %状態
◎
↓</li>
					<li>
`~ISO-2022-JP~decoder出力~状態$ ~SET %状態
◎
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%出力~flag ~LET `~ISO-2022-JP出力~flag$
◎
Let output flag be the ISO-2022-JP output flag.
</li>
					<li>
`~ISO-2022-JP出力~flag$ ~SET ~ON
◎
Set the ISO-2022-JP output flag.
</li>
					<li>
~RET ［
%出力~flag ~EQ ~OFF ならば `継続-$ ／
~ELSE_ `~error$
］
◎
Return continue, if output flag is unset, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~byte列 [ %~lead, %~byte ] を %~stream に`前付加する$
◎
Prepend lead and byte to stream.
</li>
			<li>
`~ISO-2022-JP出力~flag$ ~SET ~OFF
◎
Unset the ISO-2022-JP output flag,＼
</li>
					<li>
`~ISO-2022-JP~decoder状態$ ~SET `~ISO-2022-JP~decoder出力~状態$
◎
set ISO-2022-JP decoder state to ISO-2022-JP decoder output state and＼
</li>
					<li>
~RET `~error$
◎
return error.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JP~encoder</h4>

<div class="note">

<p>注記：
`~ISO-2022-JP~encoder$は、［
複数の出力を連結した結果を対応する`~decoder$にかけたとき，`~error$になり得る
］ような，唯一の`~encoder$である。
◎
The ISO-2022-JP encoder is the only encoder for which the concatenation of multiple outputs can result in an error when run through the corresponding decoder.
</p>

<p class="example">
`00A5^U を~encodeした結果は
[ `1B^X `28^X `4A^X `5C^X `1B^X `28^X `42^X ]
を与える。
それを 2 回~行った結果を連結してから~decodeした結果は、
[ `00A5^U `FFFD^U `00A5^U ]
になる。
◎
Encoding U+00A5 gives 0x1B 0x28 0x4A 0x5C 0x1B 0x28 0x42. Doing that twice, concatenating the results, and then decoding yields U+00A5 U+FFFD U+00A5.
</p>

</div>

<p>
各［
`ISO-2022-JP$n の`~encoder$
］には、次のものが結付けられる
⇒
`~ISO-2022-JP~encoder状態@
— 次のいずれかをとり得る（初期~時 `ASCII$i1 ）
⇒
`ASCII@i1 ／
`Roman@i1 ／
`jis0208@i1
◎
ISO-2022-JP’s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
`ISO-2022-JP$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
ISO-2022-JP’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~cp ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~NEQ `ASCII$i1
］
⇒＃
%~cp を %~stream に`前付加する$ ；
`~ISO-2022-JP~encoder状態$ ~SET `ASCII$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `完遂d$
◎
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~ISO-2022-JP~encoder状態$ ~IN
{ `ASCII$i1, `Roman$i1 }
］~AND［
%~cp ~IN { `000E^U, `000F^U, `001B^U }
］
⇒
~RET `FFFD^U を伴う`~error$
◎
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
攻撃を防ぐため、これは %~cp ではなく， `FFFD^U を返す。
◎
This returns U+FFFD rather than code point to prevent attacks.
</p>
<!-- https://github.com/whatwg/encoding/issues/15 -->
	</li>
	<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~EQ `ASCII$i1
］~AND［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
`~ISO-2022-JP~encoder状態$ ~EQ `Roman$i1
］：
</p>
		<ol>
			<li>
%結果 ~LET %~cp に応じて
⇒＃
`005C^U, `007E^U 以外の`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
~ELSE_ ~NULL
</li>
			<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
		</ol>
◎
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, then:
• If code point is an ASCII code point, return a byte whose value is code point.
• If code point is U+00A5, return byte 0x5C.
• If code point is U+203E, return byte 0x7E.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］~AND［
`~ISO-2022-JP~encoder状態$ ~NEQ `ASCII$i1
］
⇒＃
%~cp を %~stream に`前付加する$ ；
`~ISO-2022-JP~encoder状態$ ~SET `ASCII$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IF［
%~cp ~NIN { `00A5^U, `203E^U }
］~AND［
`~ISO-2022-JP~encoder状態$ ~NEQ `Roman$i1
］
⇒＃
%~cp を %~stream に`前付加する$ ；
`~ISO-2022-JP~encoder状態$ ~SET `Roman$i1 ；
~RET ~byte列 [ `1B^X, `28^X, `4A^X ]
◎
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
~IF［
%~cp ~IN { `FF61^U 〜 `FF9F^U }
］
⇒
%~cp ~SET `索引~ISO-2022-JP~katakana$の中で
( %~cp ~MINUS `FF61^X )
が指す`索引~cp$ 
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, set it to the index code point for code point − 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、 ~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~NEQ `jis0208$i1
］
⇒＃
%~cp を %~stream に`前付加する$ ；
`~ISO-2022-JP~encoder状態$ ~SET `jis0208$i1 ；
~RET ~byte列 [ `1B^X, `24^X, `42^X ]
◎
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
◎
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
◎
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">
<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>

			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JIS~decoder</h4>


<p>
各［
`Shift_JIS$n の`~decoder$
］には、次のものが結付けられる
⇒
`~Shift_JIS~lead@（初期~時 `00^X ）
◎
Shift_JIS’s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
`Shift_JIS$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Shift_JIS’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］
⇒＃
`~Shift_JIS~lead$ ~SET `00^X ；
~RET `~error$
◎
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$
◎
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］：
◎
If Shift_JIS lead is not 0x00,＼
</p>

		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$
◎
let lead be Shift_JIS lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~Shift_JIS~lead$ ~SET `00^X
◎
set Shift_JIS lead to 0x00, and then:
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>
			<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `BF^X } ならば `81^X ／
~ELSE_ `C1^X
］
◎
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FC^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead − lead offset) × 188 + byte − offset.
</li>
			<li>
<p>
~IF［
%~pointer ~IN { 8836 〜 10715 }
］
⇒
~RET ~cp [ `E000^X ~MINUS 8836 ~PLUS %~pointer ]
<!-- subtraction is done first to avoid upsetting compilers -->
◎
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 − 8836 + pointer.
</p>

<p class="note">注記：
これは EUDC として周知の，旧来の Windows によるものと相互運用可能にする。
<!-- PUA -->
◎
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">【
EUDC — いわゆる外字のための機能。
】【
8836 = 94 ~MUL 94 は~Shift_JIS（ JIS X 0208 ）の
`<a href="https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7">区点番号</a>^_
の総数。
結果の~cpは~Unicode私用領域に入る。
】</p>

			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~jis0208$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `~ASCII~byte$, `80^X}
］
⇒
~RET ~cp [ %~byte ]
<!-- Opera has 0x7E -->
◎
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `A1^X 〜 `DF^X }
］
⇒
~RET ~cp [ `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `9F^X, `E0^X 〜 `FC^X }
］
⇒＃
`~Shift_JIS~lead$ ~SET %~byte ；
~RET `継続-$
◎
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JIS~encoder</h4>

<p>
`Shift_JIS$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Shift_JIS’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET %~cp に応じて
⇒＃
`~EoS$ ならば `完遂d$ ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`0080^U ならば ~byte列 [ %~cp ] ／
`00A5^U ならば ~byte列 [ `5C^X ] ／
`203E^U ならば ~byte列 [ `7E^X ] ／
`FF61^U 〜 `FF9F^U ならば ~byte列 [ ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X ] ／
~ELSE_ ~NULL
◎
If code point is end-of-stream, return finished.
◎
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
◎
If code point is U+00A5, return byte 0x5C.
◎
If code point is U+203E, return byte 0x7E.
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point − 0xFF61 + 0xA1.
</li>
	<li>
~IF［
%結果 ~NEQ ~NULL
］
⇒
~RET %結果
◎
↑</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
%~pointer ~LET
%~cp を指す`索引~Shift_JIS~pointer$
◎
Let pointer be the index Shift_JIS pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
◎
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `1E^X } ならば `81^X ／
~ELSE_ `C1^X<!-- 0xA0-0x81 -->
］
◎
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
◎
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>
	<li>
~RET ~byte列 [ ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">
<h2 title="Legacy multi-byte Korean encodings">13. 旧来の複byte Korean ~encoding</h2>

		<section id="euc-kr">
<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KR~decoder</h4>

<p>
各［
`EUC-KR$n の`~decoder$
］には、次のものが結付けられる
⇒
`~EUC-KR~lead@（初期~時 `00^X ）
◎
EUC-KR’s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
`EUC-KR$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-KR’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］
⇒＃
`~EUC-KR~lead$ ~SET `00^X ；
~RET `~error$
◎
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$
◎
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］：
◎
If EUC-KR lead is not 0x00,＼
</p>
		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$
◎
let lead be EUC-KR lead,＼
</li>
			<li>
%~pointer ~LET ~NULL
◎
let pointer be null,＼
</li>
			<li>
`~EUC-KR~lead$ ~SET `00^X
◎
set EUC-KR lead to 0x00, and then:
</li>
			<li>
~IF［
%~byte ~IN { `41^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
◎
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − 0x41).
</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~EUC-KR$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒＃
`~EUC-KR~lead$ ~SET %~byte ；
~RET `継続-$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KR~encoder</h4>

<p>
`EUC-KR$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-KR’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`索引~EUC-KR$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index EUC-KR.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
◎
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

<!-- removed from the spec 20130823
13.2 iso-2022-kr id="iso-2022-kr"
-->

	</section>
	<section id="legacy-miscellaneous-encodings">
<h2 title="Legacy miscellaneous encodings">14. 旧来の諸々の~encoding</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">注記：
`replacement$n `~encoding$は、~serverと~clientにおける `~encoding$の~supportの不一致を突く，ある種の攻撃を防ぐためのものである。
◎
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacement~decoder</h4>

<p>
各［
`replacement$n の`~decoder$
］には、次のものが結付けられる
⇒
`~replacementによる~errorはすでに返した~flag@（初期~時 ~OFF ）
◎
replacement’s decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
`replacement$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
replacement’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂d$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
~IF［
`~replacementによる~errorはすでに返した~flag$ ~EQ ~OFF
］
⇒＃
`~replacementによる~errorはすでに返した~flag$ ~SET ~ON ；
~RET `~error$
◎
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>
	<li>
~RET `完遂d$
◎
Return finished.
</li>
</ol>

<p class="trans-note">【
`replacement$n には、`~encoder$はない。
】</p>


			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">
<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">14.2. ~UTF-16BEと~UTF-16LEに共通の基盤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. 共用~UTF-16~decoder</h4>

<p class="note">注記：
~BOMは`~label$より優先される。
それは，配備-済みの内容において、どの`~label$よりも正確aであることが見出されているので。
したがって それは、`共用~UTF-16~decoder$の一部ではなく，`~Unicodeに~decodeする$ ~algoの一部になる。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
各［
`共用~UTF-16~decoder$
］には、次のものが結付けられる
⇒＃
`~UTF-16~lead~byte@（初期~時 ~NULL ）,
`~UTF-16~lead~surrogate@（初期~時 ~NULL ）,
`~UTF-16BE~decoder~flag@（初期~時 ~OFF ）
◎
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
`共用~UTF-16~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
shared UTF-16 decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~UTF-16~lead~byte$ ~NEQ ~NULL
］~OR［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET ~NULL；
`~UTF-16~lead~surrogate$ ~SET ~NULL；
~RET `~error$
◎
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is non-null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂d$
◎
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~UTF-16~lead~byte$ ~EQ ~NULL
］
⇒＃
`~UTF-16~lead~byte$ ~SET %~byte ；
~RET `継続-$
◎
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>
	<li>
%~cu ~LET `~UTF-16BE~decoder~flag$に応じて
⇒＃
~ON ならば ( ( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte ) ／
~OFF  ならば ( ( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$ )
◎
Let code unit be the result of:
• UTF-16BE decoder flag is set
•• (UTF-16 lead byte &lt;&lt; 8) + byte.
• UTF-16BE decoder flag is unset
•• (byte &lt;&lt; 8) + UTF-16 lead byte.
</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
◎
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IF［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］：
◎
If UTF-16 lead surrogate is non-null,＼
</p>

		<ol>
			<li>
%~lead~surrogate ~LET `~UTF-16~lead~surrogate$
◎
let lead surrogate be UTF-16 lead surrogate,＼
</li>
			<li>
`~UTF-16~lead~surrogate$ ~SET ~NULL
◎
set UTF-16 lead surrogate to null, and then:
</li>
			<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET ~cp [
`10000^X ~PLUS ( ( %~lead~surrogate ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %~cu ~MINUS `DC00^X )
]
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate − 0xD800) &lt;&lt; 10) + (code unit − 0xDC00).
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
◎
Let byte1 be code unit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
◎
Let byte2 be code unit &amp; 0x00FF.
</li>
			<li>
%~byte列 ~LET %~utf-16be~flag に応じて
⇒＃
~ON ならば ~byte列 [ %byte1, %byte2 ] ／
~OFF ならば ~byte列 [ %byte2, %byte1 ]
◎
Let bytes be two bytes whose values are byte1 and byte2, if the UTF-16BE decoder flag is set, and byte2 and byte1 otherwise.
</li>
			<li>
%~byte列 を %~stream に`前付加する$
◎
Prepend the bytes to stream and return error.
</li>
			<li>
~RET `~error$
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%~cu ~IN { `D800^U 〜 `DBFF^U }
］
⇒＃
`~UTF-16~lead~surrogate$ ~SET %~cu ；
~RET `継続-$
◎
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>
	<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET `~error$
<!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>
	<li>
~RET ~cp [ %~cu ]
◎
Return code point code unit.
</li>
</ol>


			</section>
		</section>
		<section id="utf-16be">
<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>

			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BE~decoder</h4>


<p>
`UTF-16BE$n の`~decoder$は、［
`~UTF-16BE~decoder~flag$ ~SET ~ON
］にされた`共用~UTF-16~decoder$である。
◎
UTF-16BE’s decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>


			</section>
		</section>

		<section id="utf-16le">
<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">注記：
配備-済みの内容に~~対処するため、 `utf-16^lb, `utf-16le^lb のいずれも `UTF-16LE$n 用の`~label$にされている。
◎
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LE~decoder</h4>


<p>
`UTF-16BE$n の`~decoder$は、`共用~UTF-16~decoder$である。
◎
UTF-16LE’s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>

		<section id="x-user-defined">
<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">注記：
これは形上では`単byte~encoding$であるが、~algo的に実装できるので，別々に定義される。
◎
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-defined~decoder</h4>

<p>
`x-user-defined$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
x-user-defined’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~RET %~byte に応じて
⇒＃
`~EoS$ならば `完遂d$ ／
`~ASCII~byte$であるならば ~cp [ %~byte ] ／
~ELSE_ ~cp [ `F780^X ~PLUS %~byte ~MINUS `80^X ]
◎
If byte is end-of-stream, return finished.
◎
If byte is an ASCII byte, return a code point whose value is byte.
◎
Return a code point whose value is 0xF780 + byte − 0x80.
</li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-defined~encoder</h4>

<p>
`x-user-defined$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
x-user-defined’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~RET %~cp に応じて
⇒＃
`~EoS$ならば `完遂d$ ／
`~ASCII~cp$ならば ~byte列 [ %~cp ] ／
`F780^U 〜 `F7FF^U ならば ~byte列 [ %~cp ~MINUS `F780^X ~PLUS `80^X ] ／
~ELSE_ %~cp を伴う`~error$
◎
If code point is end-of-stream, return finished.
◎
If code point is an ASCII code point, return a byte whose value is code point.
◎
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point − 0xF780 + 0x80.
◎
Return error with code point.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">
<h2 title="Browser UI">15. ~browser UI</h2>

<p>
~browserには、資源の~encodingに対する上書きを可能化させないことが奨励される。
にもかかわらず，その種の特能が在する場合、前述の
<a href="#security-background">~security上の課題</a>
から，~browserは， `UTF-16BE$n／`UTF-16LE$n を~optionとして提供するベキでない。
~browserは、資源が `UTF-16BE$n／`UTF-16LE$n を利用して~decodeされた場合でも，この特能を不能化するベキである。
◎
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">実装~上の考慮点</h2>

<p>
この標準における`~encoding$用の`~decoder$は、任意の`前付加-$を備える`~stream$を~supportする代わりに，次により実装することもできる：
◎
Instead of supporting streams with arbitrary prepend, the decoders for encodings in this standard could be implemented with:
</p>

<ol>
	<li>
読取った現在の~byteを元に戻す能。
◎
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n 用の単byte（ `24^X ／ `28^X ）~buffer。
◎
↓</li>
	<li>
<p>
`gb18030$n 用の単byte（ `~ASCII~byte$ ）~buffer。
◎
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n に対しては、［
`~gb3$ ~NEQ `00^X
］の間に~~不正な~byteに出くわしたときは、`~gb2$は，次に返されることになる単byte~bufferの中に移動でき、`~gb3$が
— 単byte~bufferが返されて空にされた後， `00^X でないことが検査されたなら —
新たな`~gb1$になる。
これは、 `gb18030$n における 1 個目と 3 個目の~byte範囲が一致するので可能になる。
◎
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JP~encoder$には，追加的な状態として`~ISO-2022-JP~encoder状態$が必要になるが、それ以外では，この標準における`~encoding$用のどの`~encoder$にも 追加的な状態や~bufferは要求されない。
◎
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、~encodingを相互運用可能なものにするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を~~現在の姿に仕立て上げてきた。
特に，次の方々に感謝する：
◎
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

<div lang="en-x-a0">

<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
Christopher Foo,
David Carlisle,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">譚永鋒</span> (Frank Yung-Fong Tang),
Sam Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">村井純</span> (Jun Murai),
<span lang="ko">신정식</span> (Jungshik Shin),
Jxck,
<span lang="ko">강 성훈</span> (Kang Seonghoon),
<span lang="ja">川幡太一</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">田村健人</span> (Kent Tamura),
Leif Halvard Silli,
Luke Wagner,
Maciej Hirsz,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Mattias Buelens,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Øistein E. Andersen,
Peter Krefting,
Philip Jägenstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
<span lang="ja">寺田健</span> (Takeshi Terada),
Vyacheslav Matva, and
<span lang="ja">成瀬ゆい</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>

<p>
Copyright © 2019 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

</div>

	</section>

</main>

