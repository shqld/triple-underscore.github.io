<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Semantics — request method, request header（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP Semantics
trans_update:2020-08-28
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
abbr_url:HTTPrq
spec_status:IETFID
no_original_dfn:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls
field.expect:HTTP/Headers/Expect
	field.max-forwards:HTTP/Headers/Max-Forwards
field.if-match:HTTP/Headers/If-Match
field.if-none-match:HTTP/Headers/If-None-Match
field.if-modified-since:HTTP/Headers/If-Modified-Since
field.if-unmodified-since:HTTP/Headers/If-Unmodified-Since
field.if-range:HTTP/Headers/If-Range
field.range:HTTP/Headers/Range
field.accept:HTTP/Headers/Accept
field.accept-charset:HTTP/Headers/Accept-Charset
field.accept-encoding:HTTP/Headers/Accept-Encoding
field.accept-language:HTTP/Headers/Accept-Language
field.authorization:HTTP/Headers/Authorization
field.proxy-authorization:HTTP/Headers/Proxy-Authorization
field.from:HTTP/Headers/From
field.referer:HTTP/Headers/Referer
field.user-agent:HTTP/Headers/User-Agent

CONNECT:HTTP/Methods/CONNECT
DELETE:HTTP/Methods/DELETE
GET:HTTP/Methods/GET
HEAD:HTTP/Methods/HEAD
OPTIONS:HTTP/Methods/OPTIONS
POST:HTTP/Methods/POST
PUT:HTTP/Methods/PUT
TRACE:HTTP/Methods/TRACE

●●link_map

h.If:~RFCx/rfc4918#section-10.4

p.Accept-Charset:~HTTPrq#p.Accept-Charset
p.Accept-Encoding:~HTTPrq#p.Accept-Encoding
p.Accept-Language:~HTTPrq#p.Accept-Language
p.Accept:~HTTPrq#p.Accept
p.Authorization:~HTTPrq#p.Authorization
p.Expect:~HTTPrq#p.Expect
p.From:~HTTPrq#p.From
p.If-Match:~HTTPrq#p.If-Match
p.If-Modified-Since:~HTTPrq#p.If-Modified-Since
p.If-None-Match:~HTTPrq#p.If-None-Match
p.If-Range:~HTTPrq#p.If-Range
p.If-Unmodified-Since:~HTTPrq#p.If-Unmodified-Since
p.Max-Forwards:~HTTPrq#p.Max-Forwards
p.Proxy-Authorization:~HTTPrq#p.Proxy-Authorization
p.Range:~HTTPrq#p.Range
p.Referer:~HTTPrq#p.Referer
p.User-Agent:~HTTPrq#p.User-Agent

sdir.private:~HTTPcache#cache-response-directive.private
sdir.immutable:~RFC8246#cache-response-directive.immutable

既定の重み:~HTTPsem#defult-weight
最終-受信者:~HTTPrq#final-recipient
条件付き:~HTTPrq#preconditions
	製品~識別子:~HTTPrq#product-identifier

新鮮:~HTTPcache#fresh
再検証:~HTTPcache#revalidating
無効化-:~HTTPcache#invalidate
~cache指令:~HTTPcache#cache-directive
	無効化-:~HTTPcache#invalidation

c.message/http:~HTTPmsg#media.type.message.http
c.q:~HTTPsem#c.q


r.RFC2068:~HTTPsem#RFC2068
r.RFC2774:~HTTPsem#RFC2774
r.RFC3986:~HTTPsem#RFC3986
r.RFC4648:~HTTPsem#RFC4648
r.RFC5789:~HTTPsem#RFC5789
r.RFC6265:~HTTPsem#RFC6265
r.RFC7616:~HTTPsem#RFC7616
r.RFC7617:~HTTPsem#RFC7617
r.RFC8246:~HTTPsem#RFC8246
r.RFC8446:~HTTPsem#RFC8446

var.名前:#auth-param-name
var.値:#auth-param-value

~challenge:~HTTPrq#challenge

c.realm:#realm

base64:~4648#section-4
base64url:~4648#section-5
base32:~4648#section-7
base16:~4648#section-8

~lock:~RFCx/rfc4918#section-6

cite.~HTTP認証~scheme~registry:~IANA-a/http-authschemes
cite.~HTTP~method~registry:~IANA-a/http-methods
	●§

7.1.1.1:~HTTPsem#charset
8:#methods
	8.2.1:#safe.methods
9:#request.header.fields
9.2.1:#evaluation
9.2.2:#precedence
9.3:#field.range
9.5:#request.auth
11.2:~HTTPrs#response.validator
11.2.2.2:~HTTPrs#lastmod.comparison
12.3:~HTTPsem#attack.pathname
12.9:~HTTPsem#sensitive.information.in.uris
12.12:~HTTPsem#fingerprinting
12.14:~HTTPsem#overlapping.ranges
12.15.4:~HTTPsem#security.auth.add.resp
12.15.1:~HTTPsem#confidentiality.of.credentials

Messaging/6:~HTTPmsg#message.body
Messaging/9.6:~HTTPmsg#persistent.tear-down
Caching/3.3:~HTTPcache#caching.authenticated.responses
Caching/4.3.2:~HTTPcache#validation.received
Caching/4.3.5:~HTTPcache#head.effects
Caching/4:~HTTPcache#constructing.responses.from.caches

	接続:#connection
	形式変換-:#message.transformations
	形式変換:#message.transformations

要請~密入~攻撃:~HTTPmsg#request.smuggling

	~HTTP11:~HTTPmsg#version-1.1
	~message本体:~HTTPmsg#message.body
	~payload:~HTTPmsg#payload-body
	~payload本体:~HTTPmsg#payload-body

●●section_map

●●words_table1

●●words_table

	●仕様
保つ:keepする:~
仮想:virtual::~
誂えら:tailorさ:あつらえら
誂える:tailorする:あつらえる
無用:useless:~
想起-:envision:~
働得る:work し得る:働き得る
機能:function:~
心配:fear:~
負担:burden:~
特典:benefit:~
無差別:indiscriminate:~
無視r:disregard:無視することに
請求-:demand:~
放置:inactivity:~
協力的:cooperative:~
短絡:short-circuit:~
特殊用途の:special-purpose:~
理解度:intelligibility:~
直交的:orthogonal:独立
一助:help:~
価値:value:~
浪費-:waste:~
アタリマエ:ubiquitous::あたりまえ
兆候:signal:~
改訂履歴:revision::~
不作為:inadvertent:~
木目細かな:fine-grainedな:~
最大化する:maximizeする:最大限に得る
正当化-:justify:~
楽観的:optimistic:~
不許可に:disallow:~
厳格:stringent:~
排する:eliminateする:~
衝突-:collide:~

	相互運用するため:for the sake of interoperating
	跡をなぞる:trace
	限られて:limited
	整合性:consistent with
	~~働く:act
	~~非常:unusual
	~~価する:deserve
	~~価する:worthwhile
	~~馴染んで:familiar with
	~~責務者:person responsible for
	挙げ:mention
	~~無為に:circumvents
	必要とされてはいないが:, but not necessarily
	~~可能性:potentially
	かねない:potentially
	~~関知:held accountable for
	~~意味:sense
	優先:take precedence over
	くだけて言えば:Informally／:Verbally
	~~調べる:examin
	~~見做される:presume
	~~前提にする:presume
	-:pertaining
	受ける:achieve
	課す:put
	適宜:as appropriate
	~~長年にわたり:for a long time
	難しく:hard
	予約-済みでない:unreserved
	反して:against
	害を及ぼす:causing harm
	~~考えられがち:tempting to think of
	~~受容され易い
	やり方:fashion
	~~強いる:prevent
	~~望ましくない:unfortunate
	まずない:unlikely
	ならない見込みが高い:unlikely
	~~落と:markdown
	反し:contrary
	大きく:highly
	It knows that:わかっている
	~~特徴がある:distinguished
	いずれにせよ、:Regardless
	他にもある:(among others)
	解さなければならない:must-understand
	に関して指令する:has some direction regarding
	はるかに:far more
	誰かが〜たいていは:people
	力点が置かれる所:focus
	無分別:foolish
	~~考えられる:suggested
	込み入った:elaborate
	話す:speak する
	〜から:by virtue of
	多少を問わず:more or less than
	挙げられ:mention
	言って:say
	滅多にない:seldom
	指定されていない:unspecified
	ほぼ:nearly
	“同じさの質”: “sameness” ~quality
	用意があった:willing to
	よく似る:very similar
	前項に代えて:Alternatively
	失われ:lost
	失われ:lose

	●保安
被保護:protected:~
想定-:suppose:~
受動的:passive:~
密入:smuggling:~
	おそれがある:potential as
whitelist:

	●web
投函-:post:~
目録:catalog::~::カタログ
ニュースグループ:newsgroup:::~
メーリングリスト:mailing list:::~
ブログ:blog:::~
課金:charge:~
記事:article:~
広告料:advertising account:~
	広告-用:advertising
掲示板:bulletin board:~
英国:British:~
Danish::デンマーク語
言語上の:linguistic:~
in-line::::インライン
解析:analytics:~
仮装-:masquerade:~
誤入力:mistype:~

	●未分類
スキーム:scheme:::~
再検証:revalidation::~
新鮮:fresh::~
差控える:forgoする:差し控える
wildcard::::ワイルドカード
不変:unchanged:~
後側の:later:~
backup::::バックアップ
alphabet::::アルファベット
filename::::ファイル名
製品:product::~
下位製品:subproduct::~
deactivate:::非 active 化:非アクティブ化
loop-back::::ループバック
pipe::::パイプ
周知の:well-knownな:~
SMTP:
臨時の:limited-time:~
綴り:spell:~
読取専用:read-only:読み取り専用
加工:craft:~
切落す:truncateする:切り落とす
満杯:full:~
spam::::スパム
編集-:edit:~
編集:editing:~
小数点:decimal point:~
traversal:
閉な:closed:閉じた
区分-:partition:~
探索:search::検索
上書-:overwrite::上書き
可分:non-atomic:~
増分:increment:~
semaphore::::セマフォ
拡がり:expansion:~

	~~獲得-:gain
	^en:deep linking
	~~実行済みで:enact されて
	築く:building:構築
	~~最新の:up-to-date な
	増やす:increase
	また，:In turn

	●言い換え
	~secure化されてない:unsecured
	きちんと~supportされ:well-supported
	束縛される:bound to
	埋め~~始め:starts filling
	~~埋め込まれ:within
	~~時区間:window
	~~過去に戻る:back in time
	~~併用:with
	~~巨大:huge:巨大
	築く:building
	~~特徴:-
	群:group of
	全面的:entirely
	~~事前:before actually doing so
	初回:first time
	次回:second
	次回:next
	様々な~~断片:dimension
	要請-中にある:being requested
	-:speaking
	から来た:came from
	大多数:overwhelming majority
	環境設定し直す:reconfigure
	安全か否か:between safe and unsafe
	-:highlighted by 
	~~元に戻す:undo
	任意の:arbitrary
	に宛てて:target
	戻れる:back-links
	返送:back
	同期-に乏しい:poorly synchronized
	一種／:variation
	~~大体 同じ:around the same
	期間:period of time
	~~直前:-

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP Semantics</a>
の
§ 8. Request Methods,
§ 9. Request Header Fields
を日本語に翻訳したものです。
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP 意味論 — 要請メソッドと要請ヘッダ</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

<p class="trans-note">【
この~pageでは、
<a href="~HTTPsem">~HTTP意味論</a>
を成す内容のうち，§ 8, § 9 のみを述べる。
仕様の~metadata情報は、その~pageを参照されたし。
】</p>

<main id="MAIN0">

	<section id="methods">
<h2 title="Request Methods">8. 要請~method</h2>

		<section id="method.overview">
<h3 title="Overview">8.1. 概観</h3>

<p>
要請 `method^p ~tokenが、要請の意味論の首な源になる：
それは、`~client$が［
当の要請を為した目的, および成功裡な結果として期待するもの
］を指示する。
◎
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
</p>

<p>
`要請~method$の意味論は、要請~内に［
その~methodと競合しないような意味論を追加する，何らかの~header
］が在るときには、更に特化され得る（ `9$sec ）。
例えば，~clientは、`条件付き要請~header$を送信して，［
`~target資源$の現在の状態に要請される動作
］を条件付きにすることができる。
◎
The request method's semantics might be further specialized by the semantics of some header fields when present in a request (Section 9) if those additional semantics do not conflict with the method. For example, a client can send conditional request header fields (Section 9.2) to make the requested action conditional on the current state of the target resource.
</p>

<pre class="bnf">
`method$p
    = `token$p
</pre>
【！ Errata 4224 Rejected】

<p>
~HTTPは、~~元々は，分散型の~obj~system用の~interfaceとして利用できるように設計された。
`要請~method$は、［
識別された~obj上に定義された~methodの呼出ngが，意味論を適用することになる
］のと ほぼ同じように，［
`~target資源$に意味論を適用するもの
］として想起された。
◎
HTTP was originally designed to be usable as an interface to distributed object systems. The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.
</p>

<p>
そのため、 `method$p ~tokenは，文字大小区別である
— ［
~method名が文字大小区別であるような，~objに基づく~system
］への~gatewayとしても，利用され得るので。
標準~化された~method名は、慣行により，大文字のみからなる US-ASCII 英字で定義される。
◎
The method token is case-sensitive because it might be used as a gateway to object-based systems with case-sensitive method names. By convention, standardized methods are defined in all-uppercase US-ASCII letters.
</p>

<p>
分散型の~objと違って、~HTTPにおける標準~化された`要請~method$は，`資源$に特有ではない
— ~networkに基づく~systemにおいては、統一的な~interfaceの方が［
可視性, 再利用
］を良く供するので `REST$r 。
標準~化された~methodは、いったん定義されたなら，どの資源に適用されるときにも 同じ意味論を備える~OUGHT
— それらの意味論を，自身に［
実装する／許容する
］かどうかは、それぞれの資源が決定するが。
◎
Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]. Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed.
</p>

<p>
この仕様は、~HTTPにおいて共通的に利用される，いくつかの標準~化された~methodを定義する。
それらは、次の一覧に要旨される：
◎
This specification defines a number of standardized methods that are commonly used in HTTP, as outlined by the following table.
◎
Table 10
Method 	Description 	Ref.
</p>

<table>
<thead><tr>
<th>~method
<th>記述
</thead><tbody>

<tr><td>`GET$m
<td>
`~target資源$の現在の`表現$を転送する。
◎
Transfer a current representation of the target resource. 	8.3.1

<tr><td>`HEAD$m
<td>
`GET$m と同じだが，要請~本体は転送しない。
◎
Same as GET, but do not transfer the response body. 	8.3.2

<tr><td>`POST$m
<td>
要請~payloadに対し，資源に特有な処理を遂行する。
◎
Perform resource-specific processing on the request payload. 	8.3.3

<tr><td>`PUT$m
<td>
~target資源の現在の表現~すべてを，要請~payloadに置換する。
◎
Replace all current representations of the target resource with the request payload. 	8.3.4

<tr><td>`DELETE$m
<td>
~target資源の現在の表現~すべてを，除去する。
◎
Remove all current representations of the target resource. 	8.3.5

<tr><td>`CONNECT$m
<td>
~target資源で識別される`~server$へ，`~tunnel$を確立する。
◎
Establish a tunnel to the server identified by the target resource. 	8.3.6

<tr><td>`OPTIONS$m
<td>
~target資源~用の通信~optionを述べる。
◎
Describe the communication options for the target resource. 	8.3.7

<tr><td>`TRACE$m
<td>
~target資源への経路に沿って~message~loop-back~testを遂行する。
◎
Perform a message loop-back test along the path to the target resource. 	8.3.8
</tbody></table>

<p>
すべての一般用`~server$は、
`GET$m および `HEAD$m を~supportしなければナラナイ。
他の~methodの~supportは、すべて`任意選択^2119である。
◎
All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.
</p>

<div class="p">
<p>
`~target資源$に許容される~methodの集合は，
`Allow$h ~header内に~listできる／され得る。
加えて，その集合は、
【応答ごとに】
動的に変更できる／変化し得る。
◎
The set of methods allowed by a target resource can be listed in an Allow header field (Section 11.4.2). However, the set of allowed methods can change dynamically.＼
</p>

<p>
`生成元~server$は：
◎
＼
</p>
<ul>
	<li>
自身が認識できない／実装していない `要請~method$を受信したときは、
`501$st で応答するベキである。
◎
When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code.＼
</li>
	<li>
自身に既知であるが，~target資源には許容されない `要請~method$を受信したときは、
`405$st で応答するベキである。
◎
When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code.
</li>
</ul>
</div>

		</section>
		<section id="method.properties">
<h3 title="Common Method Properties">8.2. 共通な~method~property</h3>

<div>
<table><thead><tr>
<th>~method
<th>安全か？
<th>冪等か？
</thead><tbody>

<tr><td>`CONNECT$m
<td>no
<td>no

<tr><td>`DELETE$m
<td>no
<td>yes

<tr><td>`GET$m
<td>yes
<td>yes

<tr><td>`HEAD$m
<td>yes
<td>yes

<tr><td>`OPTIONS$m
<td>yes
<td>yes

<tr><td>`POST$m
<td>no
<td>no

<tr><td>`PUT$m
<td>no
<td>yes

<tr><td>`TRACE$m
<td>yes
<td>yes

</tbody></table>
◎
Table 11
Method 	Safe 	Idempotent 	Ref.

CONNECT 	no 	no 	8.3.6
DELETE 	no 	yes 	8.3.5
GET 	yes 	yes 	8.3.1
HEAD 	yes 	yes 	8.3.2
OPTIONS 	yes 	yes 	8.3.7
POST 	no 	no 	8.3.3
PUT 	no 	yes 	8.3.4
TRACE 	yes 	yes 	8.3.8
</div>

			<section id="safe.methods">
<h4 title="Safe Methods">8.2.1. 安全な~method</h4>

<p>
`要請~method$は、［
それに定義される意味論が本質的に読取専用
］であるとき，
`安全^dfn
（ `safe^en ）であると見なされる
— すなわち，`~client$は、［
安全な~methodを`~target資源$に適用した結果
］として，`生成元~server$上の いかなる状態~変化も，要請しない／期待しない。
同様に，［
安全な~methodの適度な利用
］は、生成元~server上に，いかなる［
害／~propertyの損失／~~非常な負担
］も及ぼさないものと期待されている。
◎
Request methods are considered "safe" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.
</p>

<p>
この［
安全な~methodの定義
］は、その呼出ngが［
有害にもなり得る ／
読取専用でない~~部分がある ／
副作用を及ぼす
］ような挙動を含まないことを 実装に~~強いるものではない。
しかしながら，重要な点は、`~client$は［
追加的な挙動を要請しないし, それについて~~関知できない
］ことにある。
例えば、ほとんどの~serverは，［
~methodに関わらず，応答が完了するごとに 要請~情報を~access~log~fileに付加する
］が、［
その~log~storageが満杯になり，~serverが~crashする可能性がある
］としても，安全と見なされる。
同様に，~Web広告を選定することにより起動される 安全な要請には、広告料を課金するような副作用があることが多い。
◎
This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server. Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account.
</p>

<p>
この仕様が定義する`要請~method$のうち［
`GET$m ,
`HEAD$m ,
`OPTIONS$m ,
`TRACE$m
］は、安全であるものと定義される。
◎
Of the request methods defined by this specification, the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.
</p>

<p>
~methodが安全か否かを判別する目的は、［
自動化された検索取得~処理n（~spider）／
~cache処理能の最適化（事前fetch）
］が，害を及ぼす心配なしに働けるようにすることにある。
加えて，~UAが［
信用できない~~可能性もある内容
］を処理する際に、安全でない~methodが自動的に利用されないよう，適切な拘束を適用することも可能になる。
◎
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm. In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content.
</p>

<p>
`~UA$は、~methodが安全か否かを判別して、安全でない動作は要請される前に利用者が自覚できるよう，~~行われ得る動作を利用者に呈示するベキである。
◎
A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.
</p>

<p>
`資源$が［
`~target~URI$に~~埋め込まれた~parametersが，動作を選定する効果を持つ
］ように構築されているとき、［
その動作が，`要請~method$の意味論に整合する
］ことを確保することは，資源~所有者の責務である。
例えば，［
~Webに基づく内容~編集~softwareが，
`query$p ~parameterに~~埋め込まれた動作を利用する
］ことは、共通的にある
— "`page?do=delete^c" など。
そのような資源の目的が，安全でない動作の遂行-である場合、資源~所有者は，［
それが安全な要請~methodを利用して~accessされる
］ときには，その動作を不能化するか, 不許可にしなければナラナイ。
さもなければ、［
~link保守, 事前fetch, 探索~indexを築く, 等々
］の~~目的で，［
どの`~URI$参照に対しても，自動化~処理により `GET$m が遂行される
］ときに、~~望ましくない副作用が~~生じることになる。
◎
When a resource is constructed such that parameters within the target URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as "page?do=delete". If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.
</p>

			</section>
			<section id="idempotent.methods">
<h4 title="Idempotent Methods">8.2.2. 冪等~method</h4>

<p>
`要請~method$は、［
複数回の［
互いに一致する，その~methodを伴う要請
］により意図される，`~server$に対する効果
］が［
単独の そのような要請による効果
］と同じになるとき，
`冪等^dfn
（ `idempotent^en ）であると見なされる。
この仕様が定義する要請~methodのうち［
`PUT$m,
`DELETE$m,
`安全$であるもの
］は、冪等である。
【`安全$な要請~methodは、定義により，この仕様が定義しないものでも冪等になるであろう。】
◎
A request method is considered "idempotent" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.
</p>

<p>
`安全$の定義と同様に、冪等性の定義が適用されるのは，［
利用者から何が要請されたか
］に限られる
— `~server$が、各 冪等な要請に対し［
その~logを別にとるのも,
改訂~制御~用の履歴を維持するのも,
他の非~冪等な副作用を実装するのも
］自由である。
◎
Like the definition of safe, the idempotent property only applies to what has been requested by the user; a server is free to log each request separately, retain a revision control history, or implement other non-idempotent side effects for each idempotent request.
</p>

<p>
冪等な~methodには、［
`~client$が`~server$の応答を読取れるようになる前に，通信が失敗した場合には、要請を自動的に繰返せる
］という~~特徴がある。
例えば、~clientが `PUT$m 要請を送信したとき，応答が受信される前に 下層の接続が~closeされた場合、~clientは，新たな接続を確立して冪等な要請を再試行できる。
元の要請が成功していたとしても、その要請を繰返した結果が
— 応答は相違するかもしれないが —
意図された効果と同じになることは，わかっているので。
◎
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response. For example, if a client sends a PUT request and the underlying connection is closed before any response is received, then the client can establish a new connection and retry the idempotent request. It knows that repeating the request will have the same intended effect, even if the original request succeeded, though the response might differ.
</p>

<div class="p">
<p>
`~client$は、［
`冪等$でない~methodを伴う要請
］を自動的に再試行するベキではない
— ただし，何らかの手段により次のいずれかを行い得るときは除く：
◎
A client SHOULD NOT automatically retry a request with a non-idempotent method unless it has＼
</p>
<ul>
	<li>
~methodに関わらず，実際に`要請の意味論$が`冪等$であることを知る。
◎
some means to know that the request semantics are actually idempotent, regardless of the method, or＼
</li>
	<li>
元の要請は決して【~target資源に】適用されていないことを検出する。
◎
some means to detect that the original request was never applied.
</li>
</ul>

<p>
例えば，［
所与の`資源$に対する `POST$m 要請が安全である
］ことを（設計または環境設定を通して）知る`~UA$は、その要請を自動的に繰返せる。
同様に，［
~version制御~repository上で運用するように特定的に設計された~UA
］は、部分的~失敗~条態から，概ね次の流れで回復するであろう：
◎
For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by＼
</p>
<ol>
	<li>
接続が失敗した後に，`~target資源$の改訂履歴を検査する。
◎
checking the target resource revision(s) after a failed connection,＼
</li>
	<li>
部分的に適用された変更を復帰するか, 修正する。
◎
reverting or fixing any changes that were partially applied,＼
</li>
	<li>
しかる後，その失敗した要請を自動的に再試行する。
◎
and then automatically retrying the requests that failed.
</li>
</ol>
</div>

<p>
一部の~clientは、自動的な再試行を起動するために，より弱い兆候を利用する。
例えば、 `POST$m 要請を送信したが，応答を一部でも受信する前に下層の~transport接続が~closeされたとき。
これは共通して実装されているが、推奨されない。
◎
Some clients use weaker signals to initiate automatic retries. For example, when a POST request is sent, but the underlying transport connection is closed before any part of the response is received. Although this is commonly implemented, it is not recommended.
</p>

<p>
`~proxy$は、冪等でない要請を自動的に再試行してはナラナイ。
`~client$は、［
失敗した自動的な再試行
］を自動的に再試行するベキでない。
◎
A proxy MUST NOT automatically retry non-idempotent requests. A client SHOULD NOT automatically retry a failed automatic retry.
</p>

			</section>
			<section id="cacheable.methods">
<h4 title="Methods and Caching">8.2.3. ~methodと~caching</h4>

<p>
~cacheが応答を格納して利用するためには、結付けられている~methodが~cachingを明示的に許容していて，応答を後続の要請を満足するために利用できる条件について詳細を与える必要がある
— ~method定義がそうしていない場合、~cacheできない。
追加的な要件については、 `Caching$r を見よ。
◎
For a cache to store and use a response, the associated method needs to explicitly allow caching, and detail under what conditions a response can be used to satisfy subsequent requests; a method definition which does not do so cannot be cached. For additional requirements see [Caching].
</p>

<p>
この仕様は、［
`GET$m, `HEAD$m, `POST$m 
］~method用の~caching意味論を定義する
— 大多数の~cache実装は、 `GET$m, `HEAD$m のみを~supportしているが。
◎
This specification defines caching semantics for GET, HEAD, and POST, although the overwhelming majority of cache implementations only support GET and HEAD.
</p>

			</section>
		</section>
		<section id="method.definitions">
<h3 title="Method Definitions">8.3. ~method定義</h3>

			<section id="GET">
<h4>8.3.1. `GET^m</h4>

<p>
`GET^m ~methodは、現在の［
`~target資源$用に`選定される表現$
］を転送するよう要請する。
◎
The GET method requests transfer of a current selected representation for the target resource.
</p>

<p>
`GET^m は、情報を検索取得する首な仕組みであり，ほぼすべての処理能 最適化の力点が置かれる所である。
よって、誰かが［
~HTTPを介して識別できる何らかの情報を検索取得する
］ことについて話すとき，たいていは `GET^m 要請を為すことを指している。
成功裡な応答は、`~target~URI$により識別される “同じさの質” を反映する。
また，応用を［
重要な各~資源に対し，~URIを生産する
］よう構築すれば、他の応用にとって可用になる資源は~~増え，~Webの更なる拡がりを促進する~network効果を生産することになる。
◎
GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request. A successful response reflects the quality of "sameness" identified by the target URI. In turn, constructing applications such that they produce a URI for each important resource results in more resources being available for other applications, producing a network effect that promotes further expansion of the Web.
</p>

<p>
資源~識別子は 遠隔~file~systemの~pathnameで，`表現$は そのような~file内容の複製であると、~~考えられがちである。
事実、多くの資源が実装されている方法でもある（関係する~securityの考慮点については `12.3$sec を見よ）。
しかしながら、実施において そのような制限は無い。
◎
It is tempting to think of resource identifiers as remote file system pathnames and of representations as being a copy of the contents of such files. In fact, that is how many resources are implemented (see Section 12.3 for related security considerations). However, there are no such limitations in practice.
</p>

<p>
資源~用の~HTTP~interfaceは、単に［
内容~objの~tree ／
様々な~database~record上の~program的な~view ／
他の情報~systemへの~gateway
］などとして実装される見込みも高い。
`~URI$対応付けの仕組みが，~file~systemに縛られているときでも、`生成元~server$は，［
~fileを直に転送するのではなく，［
要請を入力に~fileを実行して、その出力として，表現を送信する
］ように環境設定される
］こともある。
いずれにせよ、 `GET^m に対する応答において，［
その各~資源~識別子を，どの実装に対応させるか
］や, ［
各~実装が［
`~target資源$の現在の表現を選定して送信すること
］を，どう管理するか
］を知る必要があるのは、生成元~serverのみである。
◎
The HTTP interface for a resource is just as likely to be implemented as a tree of content objects, a programmatic view on various database records, or a gateway to other information systems. Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly. Regardless, only the origin server needs to know how each of its resource identifiers corresponds to an implementation and how each implementation manages to select and send a current representation of the target resource in a response to GET.
</p>

<p>
`~client$は、要請~内に `Range$h ~headerを送信することにより，
`GET^m の意味論を “範囲~要請”
— `選定された表現$を成すいくつかの部分に限り，転送を要請する要請 —
に改めることもできる。
◎
A client can alter the semantics of GET to be a "range request", requesting transfer of only some part(s) of the selected representation, by sending a Range header field in the request (Section 9.3).
</p>

<p>
~clientは、 `GET^m 要請~内に本体を`生成する$ベキでない。
`GET^m 要請~内に受信される~payloadには、意味論は定義されず，要請の意味や~targetを改めることはない
— 加えて，`要請~密入~攻撃$ `Messaging$r のおそれがあるので、一部の実装を［
要請を却下して接続を~closeする
］よう導くかもしれない。
◎
A client SHOULD NOT generate a body in a GET request. A payload received in a GET request has no defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [Messaging]).
</p>

<p>
`GET^m 要請に対する応答は，`~cache可能$である
— `Cache-Control$h ~headerから指示されない限り、［
後続の `GET^m ／ `HEAD$m 要請を満足する
］ために，その応答を~cacheに利用してもヨイ。
~cacheは、 `GET^m 要請~内に受信した~payloadを
— その内容を問わず —
無視して~cacheする見込みが高い。
◎
The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [Caching]). A cache that receives a payload in a GET request is likely to ignore that payload and cache regardless of the payload contents.
</p>

<p>
情報の検索取得が，利用者が供した情報から`~target~URI$を構築する仕組み
— 例： `GET^m を利用している~formの~query~fieldなど —
で遂行されるとき、~URIの中に開示するには適切にならない，敏感になり得る~dataが供されるかもしれない（ `12.9$sec を見よ）。
一部の事例では、そのような情報を露呈しないよう，当の~dataを［
~filter／形式変換
］できる。
他の事例では
— 特に，応答を~cacheしても便益は無いときは —
`GET^m に代えて `POST$m ~methodを利用すれば、そのような情報は，通例的に
— 新たな~URIを構築することなく —
要請の本体~内に伝送されることになる。
◎
When information retrieval is performed with a mechanism that constructs a target URI from user-provided information, such as the query fields of a form using GET, potentially sensitive data might be provided that would not be appropriate for disclosure within a URI (see Section 12.9). In some cases, the data can be filtered or transformed such that it would not reveal such information. In others, particularly when there is no benefit from caching a response, using the POST method (Section 8.3.3) instead of GET will usually transmit such information in the request body rather than construct a new URI.
</p>

			</section>
			<section id="HEAD">
<h4>8.3.2. `HEAD^m</h4>

<p>
`HEAD^m ~methodは、［
~serverが，応答~内に`~message本体$を送信してはナラナイ（すなわち，応答は、`~header節$の終端で終了する）
］ことを除いて、 `GET$m と一致する。
`~server$は、 `HEAD^m 要請に対する応答~内に，［
要請が `GET$m であったときに送信することになる~headerたち
］と同じ~headerたちを送信するベキである
— ただし、それらのうち`~payload~header$は省略されてもヨイ。
この~methodは、［
`表現~data$を転送することなく，`選定された表現$についての~metadataを得する
］ために利用でき、また，［［
妥当性 ／ ~accessibility ／ 近過去の改変
］のために~hypertext~linkを~testする
］ときに，利用されることが多い。
◎
The HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section). The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields (Section 7.3) MAY be omitted. This method can be used for obtaining metadata about the selected representation without transferring the representation data and is often used for testing hypertext links for validity, accessibility, and recent modification.
</p>

<p>
`HEAD^m 要請~messageの~payloadには、意味論は定義されない
— 既存の実装には、`~payload本体$を伴って送信されてきた `HEAD^m 要請を，却下するものもある。
◎
A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.
</p>

<p>
`HEAD^m 要請に対する応答は，`~cache可能$である
— `Cache-Control$h ~headerから指示されない限り、［
後続の `HEAD^m 要請を満足する
］ために~cacheが利用されてもヨイ。
`HEAD^m 応答も，［
以前に~cacheされた `GET$m に対する応答
］に効果を及ぼすことがある
— `Caching/4.3.5$sec を見よ。
◎
The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [Caching]). A HEAD response might also have an effect on previously cached responses to GET; see Section 4.3.5 of [Caching].
</p>

			</section>
			<section id="POST">
<h4>8.3.3. `POST^m</h4>

<p>
`POST^m ~methodは、［
`~target資源$が，自前の特有な意味論に則って，要請~内に同封された`表現$を処理する
］ことを要請する。
例えば `POST^m は、次の機能~用に利用される（他にもある）:
◎
The POST method requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics. For example, POST is used for the following functions (among others):
</p>
<ul>
	<li>
［
HTML ~formに手入力された一連の~field
］などの~data~blockを，~data取扱い処理nに供する。
◎
Providing a block of data, such as the fields entered into an HTML form, to a data-handling process;
</li>
	<li>
［
掲示板,
ニュースグループ,
メーリングリスト,
ブログ,
その他~同類の記事~群
］などへ，~messageを投函する。
◎
Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles;
</li>
	<li>
`生成元~server$により まだ識別されていない，新たな資源を作成する。
◎
Creating a new resource that has yet to be identified by the origin server; and
</li>
	<li>
既存の資源の，いくつかの`表現$に、~dataを付加する。
◎
Appending data to a resource's existing representation(s).
</li>
</ul>

<p>
`生成元~server$は、［
`POST^m 要請の処理~結果に依存して，適切な状態s~codeを選ぶ
］ことにより，応答の意味論を指示する
— `POST^m に対する応答~内には、この仕様が定義する ほぼすべての状態s~codeを，受信させることもできる（例外は： `206$st, `304$st, `416$st ）。
◎
An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification could be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)).
</p>

<div class="p">
<p>
`POST^m 要請が成功裡に処理された結果，`生成元~server$上にて 1 個以上の資源が作成された場合、生成元~serverは，次を包含する `201$st 応答を送信するベキである：
◎
If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing＼
</p>
<ul>
	<li>
［
作成された`首な資源$用の識別子
］を供する `Location$h ~header,
◎
a Location header field that provides an identifier for the primary resource created (Section 11.1.2) and＼
</li>
	<li>
新たな資源（たち）を指しつつ, 要請の状態sも述べるような，`表現$。
◎
a representation that describes the status of the request while referring to the new resource(s).
</li>
</ul>
</div>

<p>
`POST^m 要請に対する応答は、`~cache可能$になるのは［
それが，明示的な`鮮度~情報$を内包する, かつ `Content-Location$h ~headerは `POST^m の`~target~URI$と同じ値をとる
］ときに限られる。
~cache済み `POST^m 応答は、後の［
`GET$m ／ `HEAD$m
］要請を満足するために再利用できるが、
`POST^m 要請には再利用できない
— `POST^m は`生成元~server$を通して書き出されることが要求され, そうするのは安全でないので。
`Caching/4$sec を見よ。
◎
Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [Caching]) and a Content-Location header field that has the same value as the POST's target URI (Section 7.2.5). A cached POST response can be reused to satisfy a later GET or HEAD request, but not a POST request, since POST is required to be written through to the origin server, because it is unsafe; see Section 4 of [Caching].
</p>

<p>
`POST^m の処理~結果が，既存の資源の`表現$と等価になる場合、`生成元~server$は、［
その既存の資源の識別子を `Location$h ~header【！~field】内に伴う， `303$st 応答
］を送信して，`~UA$を~redirectしてもヨイ。
これには、特典がある
— 資源~識別子を~UAに供して，表現を［
`共用~cache$が，より~~受容し易い~method
］を介して転送させるような
— ~UAが~cache済み表現をまだ持っていない場合には，余分な要請~costがかかるが。
◎
If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.
</p>

			</section>
			<section id="PUT">
<h4>8.3.4. `PUT^m</h4>

<p>
`PUT^m ~methodは、［
`~target資源$の状態を，［
要請~message~payload内に同封された`表現$により定義される状態
］として作成する, あるいはその状態に置換する
］ことを要請する。
［
所与の表現に対する成功裡な `PUT^m
］は、［
同じ~target資源に対する後続の `GET$m の結果が，
`200$st 応答~内に送信されている表現と等価になる
］ことを示唆する。
しかしながら，［
そのような状態~変化が観測-可能になる
］ことは保証されない
— ~target資源は、［
後続の `GET$m が受信される前に，並列的な 他の~UAにより動作されたり
］, ［
`生成元~server$による動的~処理の~subjectである
］こともあるので。
成功裡な応答は、その処理~時点で［
~UAの意図が，生成元~serverにより達成された
］ことのみを含意する。
◎
The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
</p>

<p>
`生成元~server$には、以下の要件が課される
— 以下、 `PUT^m された`表現$を `P^V と記す：
◎
↓</p>
<ul>
	<li>
<p>
`~target資源$が現在の`表現$を：
◎
↓</p>
		<ul>
			<li>
持たない場合
⇒
`PUT^m が何か一つを成功裡に作成したときは、
`201$st 応答を`~UA$に送信してその旨を伝えなければナラナイ。
◎
If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.＼
</li>
			<li>
持つ場合
⇒
その表現が， `P^V の状態に則って 成功裡に改変されたときは、
`200$st または `204$st 応答を送信して，要請の成功裡な完了を指示しなければナラナイ。
◎
If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.
</li>
		</ul>
	</li>
	<li>
`PUT^m 要請~内に受信した［
`~header$／`~trailer$
］のうち，認識できないものは、無視する（すなわち，資源~状態の一部として保存しない）ベキである。
◎
An origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., do not save them as part of the resource state).
</li>
	<li>

<div class="p">
<p>
［
`~target資源$に備わる［
`PUT^m により変更できない／されることにはならない
］ようにする，どの拘束
］にも， `P^V が整合することを検証yするベキである。
これは特に、`生成元~server$が［
`~URI$に関係する内部 環境設定~情報を利用して，
`GET$m 応答~上の`表現~metadata$用の値を設定している
］ときに，重要になる。
◎
An origin server SHOULD verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT. This is particularly important when the origin server uses internal configuration information related to the URI in order to set the values for representation metadata on GET responses.＼
</p>

<p>
`P^V が~target資源と整合でないときには、次のいずれかをするベキである：
◎
When a PUT representation is inconsistent with the target resource, the origin server SHOULD either＼
</p>
		<ul>
			<li>
［
`P^V を形式変換するか, 資源についての環境設定を変更する
］ことにより，それらを整合させる。
◎
make them consistent, by transforming the representation or changing the resource configuration, or＼
</li>
			<li>
［
何故 `P^V が相応しくないかを説明するに足る情報
］を包含する，適切な~error~messageで応答する。
それが `Content-Type$h 値に対する拘束に特有であるときは、［
`409$st ／ `415$st
］が示唆される。
◎
respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.
</li>
		</ul>
</div>

<p>
例えば，［
`~target資源$が常に `Content-Type$h に "`text/html^c" を持つ
］ように環境設定されていて, ［
`P^V は `Content-Type$h に "`image/jpeg^c" を持つ
］場合、次のいずれかをする~OUGHT：
◎
For example, if the target resource is configured to always have a Content-Type of "text/html" and the representation being PUT has a Content-Type of "image/jpeg", the origin server ought to do one of:
</p>

		<ul>
			<li>
~target資源が新たな`~MIME型$を反映するように，環境設定し直す。
◎
reconfigure the target resource to reflect the new media type;
</li>
			<li>
`P^V を新たな資源~状態として保存する前に、
`P^V の形式が資源の形式と整合するように，
`P^V を形式変換する。
◎
transform the PUT representation to a format consistent with that of the resource before saving it as the new resource state; or,
</li>
			<li>
要請に対し、［
~target資源が "`text/html^c" に制限されていることを指示する， `415$st 応答
］で却下する
— たぶん［
新たな`表現$に相応しい~targetになる，異なる資源への~link
］を内包するような。
◎
reject the request with a 415 (Unsupported Media Type) response indicating that the target resource is limited to "text/html", perhaps including a link to a different resource that would be a suitable target for the new representation.
</li>
		</ul>
	</li>
</ul>

<div class="p">
<p>
~HTTPは、次のものは定義しない：
◎
HTTP does not define＼
</p>
<ul>
	<li>
`PUT^m ~methodが `生成元~server$の状態に正確にどう影響するかについて
— ［
~UA要請の意図や, 生成元~serverによる応答の意味論により表出できるもの
］を超えるような。
◎
exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and＼
</li>
	<li>
資源が何になり得るかについて
— ［
~HTTPを介して供される~interface
］を超えるような，その言葉が表すいかなるイミにおいても。
◎
the semantics of the origin server response.＼
It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP.＼
</li>
	<li>
資源~状態がどう “格納される” か。
◎
It does not define how resource state is "stored", nor＼
</li>
	<li>
資源~状態が変化した結果，そのような~storageがどう変化し得るか。
◎
how such storage might change as a result of a change in resource state, nor＼
</li>
	<li>
生成元~serverが，資源~状態をどう`表現$に翻訳するか。
◎
how the origin server translates resource state into representations.＼
</li>
</ul>

<p>
一般に，［
資源~interfaceの背後にある，実装の詳細すべて
］は、~serverにより意図的に隠される。
◎
Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.
</p>
</div>

<div class="p">
<p>
`生成元~server$は、次の両者が~~満たされない限り，［
`PUT^m に対する成功裡な応答
］内に
— `ETag$h や `Last-Modified$h などの —
`検証子~header$を送信してはナラナイ：
◎
An origin server MUST NOT send a validator header field (Section 11.2), such as an ETag or Last-Modified field, in a successful response to PUT unless＼
</p>
<ul>
	<li>
要請の`表現~data$は、本体にいかなる形式変換も適用されずに，保存された（すなわち，資源の新たな表現~dataは、 `PUT^m 要請~内に受信された表現~dataと一致する）。
◎
the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and＼
</li>
	<li>
`検証子$を成す`~field値$は、新たな`表現$を反映している。
◎
the validator field value reflects the new representation.＼
</li>
</ul>

<p>
この要件により，`~UA$は、［
~memory内に持つ表現の本体が，現在の `PUT^m の結果そのままであるとき
］を知れるようになる
— したがって，生成元~serverから再び検索取得する必要はなくなり、また，［
応答~内に受信した，新たな`検証子$（たち）
］を未来の`条件付き要請$に利用して，偶発的な上書-を防止できるようになる。
◎
This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 9.2).
</p>
</div>

<div class="p">
<p>
`POST$m と `PUT^m の間の根本的な相違は、同封された`表現$の意図が異なることにある：
◎
The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation.＼
</p>
<ul>
	<li>
`POST$m 要請には、`~target資源$が［
同封された表現を，資源による自前の意味論に則って取扱う
］ことが意図される。
◎
The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas＼
</li>
	<li>
`PUT^m 要請は、［
同封された表現が，~target資源の状態を置換する
］ものとして定義される。
◎
the enclosed representation in a PUT request is defined as replacing the state of the target resource.＼
</li>
</ul>

<p>
よって，`PUT^m の意図は、その正確な効果が 生成元~serverのみに既知であっても，`冪等$であり、`中継者$からは可視になる。
◎
Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.
</p>
</div>

<p>
`PUT^m 要請を適正に解釈するためには、［
~UAが，どの`~target資源$が【利用者から】欲されているか知っている
］ことが前提になる。
［
~clientに利するために、状態変更 要請を受信した後，適正な`~URI$を選定する~service
］は、
`PUT^m ではなく， `POST$m ~methodを利用して実装するベキである。
`生成元~server$は、要請された `PUT^m を
— それにより`~target資源$の状態を変更することなく —
異なる資源に適用したいと望む場合
— 当の資源が異なる~URIへ移動されたときなど —
には，適切な `3xx$st 応答を送信しなければナラナイ。
また，`~UA$は、要請を~redirectするかどうかに関して，自前の裁定を下してもヨイ。
◎
Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.
</p>

<p>
`~target資源$に適用される `PUT^m 要請は、他の`資源$に副作用を及ぼし得る。
例えば，ある記事は、 “各種~version” （ある時点で他のいずれかの~versionと同じ状態を共有する，互いに異なる資源）を識別するために，別々の`~URI$を持ち得る。
したがって， “現在の~version” の~URIに対する成功裡な `PUT^m 要請は、~target資源の状態を変化させた上で，新たな~versionの資源を作成する
— 更には、関係する資源~間の~linkを追加することもある。
◎
A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying "the current version" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on "the current version" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.
</p>

<div class="p">
<p>
所与の`~target資源$に対し `PUT^m を許容する`生成元~server$は、［
`Content-Range$h ~headerを包含する `PUT^m 要請
］に対しては， `400$st 応答を送信しなければナラナイ
— その~payloadは、［
誤って全部的な`表現$として `PUT^m された，部分的~内容【！ ＊？】
］である見込みが高いので。
部分的な内容の更新は、次のいずれかによりアリである：
◎
An origin server that allows PUT on a given target resource MUST send a 400 (Bad Request) response to a PUT request that contains a Content-Range header field (Section 7.3.4), since the payload is likely to be partial content that has been mistakenly PUT as a full representation. Partial content updates are possible＼
</p>
<ul>
	<li>
より大きい資源のある部位に重なるような状態にある，別々に識別される資源を~targetする。
◎
by targeting a separately identified resource with state that overlaps a portion of the larger resource, or＼
</li>
	<li>
部分的な更新~用に特定的に定義された，異なる~methodを利用する（例えば，`RFC5789$r にて定義される `PATCH$m ~method）。
◎
by using a different method that has been specifically defined for partial updates (for example, the PATCH method defined in [RFC5789]).
</li>
</ul>
</div>

<p>
`PUT^m ~methodに対する応答は、`~cache可能$でない。
成功裡な `PUT^m 要請が，［
`~target~URI$用に格納-済みな応答を 1 個以上~持つ~cache
］を通して渡された場合、それらの格納-済み応答は，`無効化-$されることになる。
◎
Responses to the PUT method are not cacheable. If a successful PUT request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [Caching]).
</p>

			</section>
			<section id="DELETE">
<h4>8.3.5. `DELETE^m</h4>

<p>
`DELETE^m ~methodは、［
`生成元~server$に，`~target資源$と，その現在の機能性との間の結付けを除去してもらう
］ことを要請する。
この~methodの効果は、 UNIX の rm ~commandに類似する：
それは、［
以前に結付けられた情報が削除される
］という期待ではなく，［
生成元~serverによる~URI対応付けにおける削除~演算
］を表出する。
◎
The DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.
</p>

<p>
`~target資源$が 現在の`表現$を 1 個以上~持つ場合に，それらが［
`生成元~server$により破壊されたり, 結付けられた~storageが取戻される
］かどうかは、［
その資源の資質と, 生成元~serverによる その実装（この仕様の視野を超える）
］に全面的に依存する。
同様に、 `DELETE^m の結果として，［
~databaseや~gateway接続など，資源の他の実装~側面
］が~deactivateされる／~archiveされる必要が~~生じることもある。
一般に，生成元~serverが `DELETE^m を許容するのは、削除を成遂げる仕組みが制定されている資源に限られるものと見做されている。
◎
If the target resource has one or more current representations, they might or might not be destroyed by the origin server, and the associated storage might or might not be reclaimed, depending entirely on the nature of the resource and its implementation by the origin server (which are beyond the scope of this specification). Likewise, other implementation aspects of a resource might need to be deactivated or archived as a result of a DELETE, such as database or gateway connections. In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion.
</p>

<p>
`DELETE^m ~methodを許容する資源は、相対的に少数である
— それは首に、［
利用者が，その効果に関して指令する
］ような，遠隔~著作~用の環境に利用される。
例えば，［
`PUT$m 要請を利用して，以前に作成された資源
］や［
`POST$m 要請に対する`201$st 応答の `Location$h ~headerを介して識別される資源
］は、それらの動作を~~元に戻すような，対応する `DELETE^m 要請を許容することもある。
同様に，［
~HTTP利用して改訂を制御する~clientなど，遠隔~運用~用の著作~機能を実装する~custom~UA実装
］では、［
~version~repositoryに対応するように加工されている，~serverの~URI空間
］についての前提に基づいて， `DELETE^m を利用できることもある。
◎
Relatively few resources allow the DELETE method — its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the Location header field after a 201 (Created) response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.
</p>

<div class="p">
<p>
`DELETE^m ~methodが成功裡に適用された場合、`生成元~server$は、動作~~状況に応じて，次のいずれかの状態s~codeを送信するベキである：
◎
If a DELETE method is successfully applied, the origin server SHOULD send
</p>
<ul>
	<li>
動作は成功する見込みが高いが、まだ~~実行済みでない場合
⇒
`202$st
◎
a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted,
</li>
	<li>
動作は実行済みで、更なる情報は給されない場合
⇒
`204$st
◎
a 204 (No Content) status code if the action has been enacted and no further information is to be supplied, or
</li>
	<li>
動作は実行済みで、応答~messageが［
その状態sを述べる`表現$
］を内包する場合
⇒
`200$st
◎
a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status.
</li>
</ul>

【！ Errata ID: 4436 "," → ";" 訳には影響なし】
</div>

<p>
`~client$は、 `DELETE^m 要請~内に本体を生成するベキでない。
`DELETE^m 要請~内に受信された~payloadは、意味論は定義されない
— 要請の意味や~targetを改めることはないことに加え，一部の実装に要請を却下するよう導くかもしれない。
◎
A client SHOULD NOT generate a body in a DELETE request. A payload received in a DELETE request has no defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request.
</p>

<p>
`DELETE^m ~methodに対する応答は、`~cache可能$でない。
成功裡な `DELETE^m 要請が［
`~target~URI$用に格納-済みな応答を， 1 個以上~持つ~cache
］を通して渡された場合、それらの格納-済み応答は，`無効化-$されることになる。
◎
Responses to the DELETE method are not cacheable. If a successful DELETE request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [Caching]).
</p>

			</section>
			<section id="CONNECT">
<h4>8.3.6. `CONNECT^m</h4>

<p>
`CONNECT^m ~methodは、［［
`要請~target$により識別される，行先の生成元~server
］への`~tunnel$を確立する
］こと, および［
それに成功したならば、~tunnelが~closeされるまで，受信者の挙動を
— 両~方向とも —
~dataの盲目的な回送に制約する
］ことを，`受信者$に要請する。
~tunnelは、［
1 個以上の`~proxy$を通して，端点間の仮想~接続を作成する
］ときに共通的に利用される
— しかる後、 ~TLS（ `Transport Layer Security^en, `RFC8446$r ）を利用して~secure化できるようになる。
◎
The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request target and, if successful, thereafter restrict its behavior to blind forwarding of data, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security, [RFC8446]).
</p>

<p>
`CONNECT^h は，~HTTP接続の［
要請／応答
］に関する資質を変更するので、その意味論を~protocolの伝送路~形式へ対応付ける仕方は，特定の~HTTP~versionごとに異なるかもれない。
◎
Because CONNECT changes the request/response nature of an HTTP connection, specific HTTP versions might have different ways of mapping its semantics into the protocol's wire format.
</p>

<p>
`CONNECT^m は、`~proxy$への要請に利用するためのみに意図されている。
`生成元~server$は，［
自身に向けられた `CONNECT^m 要請を受信した
］ときは、接続が確立されたことを指示するために，
`2xx$st で応答してもヨイ。
しかしながら，ほとんどの生成元~serverは、 `CONNECT^m を実装しない。
◎
CONNECT is intended only for use in requests to a proxy. An origin server that receives a CONNECT request for itself MAY respond with a 2xx (Successful) status code to indicate that a connection is established. However, most origin servers do not implement CONNECT.
</p>

<p>
`~client$が `CONNECT^m 要請を送信するときは、`要請~target$として，
`authority$p 成分を送信しなければナラナイ
— すなわち，`要請~target$は、~colonで分離された，`~tunnel$の行先の［
~host名, ~port番号
］のみからなる。
◎
A client sending a CONNECT request MUST send the authority component (described in Section 3.2 of [RFC3986]) as the request target; i.e., the request target consists of only the host name and port number of the tunnel destination, separated by a colon.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
</pre>
</div>

<div class="p">
<p>
`受信者$`~proxy$は、［
`要請~target$へ直に接続する
］か, あるいは［
別の~proxyを利用するよう環境設定されている場合は，
`CONNECT^m 要請を`内方$にある次の~proxyへ回送する
］ことにより，`~tunnel$を確立できる：
◎
The recipient proxy can establish a tunnel either by directly connecting to the request target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy.＼
</p>
<ul>
	<li>
どの `2xx$st 応答も、［
成功裡な応答の`~header節$を締めくくる空行
］の直後に，［
`送信者$（および すべての内方`~proxy$）が~tunnel~modeへ切替えることになる
］ことを指示する
— その空行より後に受信される~dataは、［
`要請~target$により識別される~server
］からのものになる。
◎
Any 2xx (Successful) response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the blank line that concludes the successful response's header section; data received after that blank line is from the server identified by the request target.＼
</li>
	<li>
成功裡な応答 以外のどの応答も、［
~tunnelは まだ形成されておらず，接続は ~HTTPにより統治され続ける
］ことを指示する。
◎
Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
</li>
</ul>
</div>

<div class="p">
<p>
`~tunnel$は、［
~tunnel中継者が，いずれかの側がその接続を~closeしたことを検出した
］とき，~closeされる
— その際には、`中継者$は，順に次をしなければナラナイ：
◎
A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST＼
</p>
<ol>
	<li>
~closeされた側から来た，応答待ち~dataすべてを、他の側へ送信することを試みる。
◎
attempt to send any outstanding data that came from the closed side to the other side,＼
</li>
	<li>
接続を両~側とも~closeする。
◎
close both connections, and＼
</li>
	<li>
送達されてない残りの~dataは、すべて破棄する。
◎
then discard any remaining data left undelivered.
</li>
</ol>
</div>

<p>
~proxy認証が，`~tunnel$を作成するための権限を確立するために利用されることもある。
◎
Proxy authentication might be used to establish the authority to create a tunnel.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
</pre>
</div>

<p>
任意な~serverへ`~tunnel$を確立することには、有意な~riskがある
— 特に、その行先が，~Web流通~用には意図されていない［
周知の／予約-済みな
］~TCP~portであるときは。
例えば，［
"`example.com:25^c" への `CONNECT^m
］は、~proxyに［
~SMTP流通~用に予約-済みな~port
］へ接続するよう示唆することになるであろう
— 許容された場合、~proxyを，~spam~emailを中継させるように騙せてしまう。
`CONNECT^m を~supportする`~proxy$は、その利用を［
既知な~portの制限された集合
］または［
環境設定できる，安全な`要請~target$たちからなる~whitelist
］に制約するベキである。
◎
There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to "example.com:25" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
</p>

<p>
`~server$は、［
`CONNECT^m に対する `2xx$st 応答
］内に［
`Transfer-Encoding$h ／ `Content-Length$h
］~headerを送信してはナラナイ。
`~client$は、［
`CONNECT^m に対する成功裡な応答
］内に受信された［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerを，無視しなければナラナイ。
◎
A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.
</p>

<p>
`CONNECT^m 要請~messageの~payloadには、意味論は定義されない
— 既存の実装には、`~payload本体$を伴って送信されてきた `CONNECT^m 要請を却下するものもある。
◎
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
</p>

【！ Errata 4351 Rejected ~ERRATA/eid4351】

<p>
`CONNECT^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the CONNECT method are not cacheable.
</p>

			</section>
			<section id="OPTIONS">
<h4>8.3.7. `OPTIONS^m</h4>

<p>
`OPTIONS^m ~methodは、［
`生成元~server$／介在している`中継者$
］に対し，［
`~target資源$に可用な通信~optionについての情報
］を要請する。
この~methodにより，`~client$は、資源に対する動作を含意することなく［［
資源に結付けられた，~optionや要件
］／
~serverの能力
］を決定できるようになる。
◎
The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action.
</p>

<p>
`OPTIONS^m 要請のうち，`要請~target$として~asterisk （ "`*^c" ）を伴うものは、特定の資源に対してではなく，
`~server-wide@
に適用される。
`~server$の通信~optionは，概して資源に依存するので、この種の要請が有用になるのは
— “`ping^en” や “`no-op^en” の類いの~methodのような —
~clientが~serverの能力を~testする以上のことは何もしないものに限られる。
例えば これを、［
`~HTTP11$への適合性（または その欠如）について，`~proxy$を~testする
］ときに利用できる。
◎
An OPTIONS request with an asterisk ("*") as the request target (Section 6.1) applies to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof).
</p>

<p>
`要請~target$が~asterisk "`*^c" でない場合、当の `OPTIONS^m 要請は，`~target資源$と通信するときに可用な~optionに適用される。
◎
If the request target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.
</p>

<div class="p">
<p>
`~server$は、そのような `OPTIONS^m に対し成功裡な応答を`生成する$ときは：
◎
A server generating a successful response to OPTIONS＼
</p>
<ul>
	<li>
自身が実装している~headerのうち，［
`~target資源$に適用-可能な，任意選択な特能を指示するかもしれないもの
］（例： `Allow$h ）すべてを
— この仕様で定義されていない拡張があれば，それも含めて —
送信するベキである。
◎
SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.＼
</li>
	<li>
応答~payloadも（もしあれば）、~machineやヒトから読取可能な`表現$により，通信~optionを述べるかもしれない。
そのような表現~用の標準~形式は、この仕様では定義されないが，将来の~HTTP拡張により定義されるかもしれない。
◎
The response payload, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.
</li>
</ul>
</div>

<p>
`~client$は、 `OPTIONS^m 要請~内に，［
要請の`連鎖$にある，特定の`受信者$
］に宛てて `Max-Forwards$h ~headerを送信してもヨイ。
`~proxy$は、受信した要請を回送するときには，それが
`Max-Forwards$h ~headerを伴っていない限り，
`Max-Forwards$h ~headerを`生成し$てはナラナイ。
◎
A client MAY send a Max-Forwards header field in an OPTIONS request to target a specific recipient in the request chain (see Section 9.1.2). A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.
</p>

<p>
`~client$は、［
`~payload本体$を包含する `OPTIONS^m 要請
］を`生成する$ときは，［
`表現$の`~MIME型$を述べる妥当な `Content-Type$h ~header
］を送信しなければナラナイ。
この仕様は，そのような~payloadのいかなる利用も定義しないことに注意。
◎
A client that generates an OPTIONS request containing a payload body MUST send a valid Content-Type header field describing the representation media type. Note that this specification does not define any use for such a payload.
</p>

<p>
`OPTIONS^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the OPTIONS method are not cacheable.
</p>

			</section>
			<section id="TRACE">
<h4>8.3.8. `TRACE^m</h4>

<div class="p">
<p>
`TRACE^m ~methodは、当の要請~messageに対し，［
遠隔からの，応用~levelの~loop-back
］を要請する。
要請の`最終-受信者$は、受信した~messageを反映するべく，次のような `200$st 応答を~clientへ返送するベキである：
</p>
<ul>
	<li>
応答には， `Content-Type$h 値に "`message/http$c" を伴わせる。
</li>
	<li>
受信した~messageを，応答の`~message本体$に含ませる。
</li>
	<li>
ただし、下に述べるいくつかの`~field$は，~messageから除外する。
</li>
</ul>
◎
The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the message body of a 200 (OK) response with a Content-Type of "message/http" (Section 10.1 of [Messaging]).＼
</div>

<p>
`最終-受信者@
とは、`生成元~server$, または最初に［
要請~内の `Max-Forwards$h 値に 0 を受信した`~server$
］である。
◎
The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 9.1.2).
</p>

<p>
`~client$は、 `TRACE^m 要請~内に［
応答により開示され得るような，敏感な~dataを包含する`~field$
］を`生成し$てはナラナイ。
例えば，［
格納されている利用者の`資格証$（ `9.5$sec ）や~cookie `RFC6265$r
］を `TRACE^m 要請~内に送信するような~UAは、無分別であろう。
要請の`最終-受信者$が，応答~本体を`生成する$ときには、［
敏感な~dataを包含しそうな どの要請`~field$
］も除外するベキである。
◎
A client MUST NOT generate fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials Section 9.5 or cookies [RFC6265] in a TRACE request. The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response body.
</p>

<p>
`TRACE^m により、`~client$は，［
要請の`連鎖$における，他方の終端で受信されているもの
］を見て，その~dataを［
~test用や診断~情報
］に利用できるようになる。
特に関心を呼ぶものは、要請~連鎖の跡をなぞる，
`Via$h ~headerの値である。
`Max-Forwards$h ~headerにより、~clientは，要請~連鎖の長さを制限できるようになる
— それは、［
~messageを回送している`~proxy$の`連鎖$が，無限~loopになっている
］かどうか，~testするときに有用になる。
◎
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (Section 6.6.1) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
</p>

<p>
`~client$は、 `TRACE^m 要請~内に`~message本体$を送信してはナラナイ。
◎
A client MUST NOT send a message body in a TRACE request.
</p>

<p>
`TRACE^m ~methodに対する応答は、`~cache可能$でない。
◎
Responses to the TRACE method are not cacheable.
</p>

			</section>
		</section>
		<section id="method.extensibility">
<h3 title="Method Extensibility">8.4. ~methodの拡張能</h3>

<p>
この仕様の視野から外れる，追加的な~methodも、~HTTPにおける利用~用に指定されている。
そのような~methodは、すべて，`~HTTP~method~registry^citeの中に登録される~OUGHT。
◎
Additional methods, outside the scope of this specification, have been specified for use in HTTP. All such methods ought to be registered within the "Hypertext Transfer Protocol (HTTP) Method Registry".
</p>

			<section id="method.registry">
<h4 title="Method Registry">8.4.1. ~method~registry</h4>

<p>
`~HTTP~method~registry$cite
は、`要請~method$~token用の名前空間を定義する。
◎
The "Hypertext Transfer Protocol (HTTP) Method Registry", maintained by IANA at &lt;https://www.iana.org/assignments/http-methods&gt;, registers method names.
</p>

<p>
~HTTP~method登録には、次に挙げる~fieldを含めなければナラナイ
⇒＃
~method名（ `8$sec ）,
`安全$かどうか（ "yes" または "no" ）,
`冪等$かどうか（ "yes" または "no" ）,
仕様~textへの~pointer
◎
HTTP method registrations MUST include the following fields:
• Method Name (see Section 8)
• Safe ("yes" or "no", see Section 8.2.1)
• Idempotent ("yes" or "no", see Section 8.2.2)
• Pointer to specification text
</p>

【！https://www.rfc-editor.org/errata/eid5300】

<p>
この名前空間に追加される値は、
`IETF による考査$を要する。
◎
Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

			</section>
			<section id="considerations.for.new.methods">
<h4 title="Considerations for New Methods">8.4.2. 新たな~methodに対する考慮点</h4>

<p>
標準~化された~methodは、汎用である
— すなわち，それらは、特定0の［
`~MIME型$／資源の種類／応用
］のみならず，どの資源にも適用-可能になり得る。
そのような新たな~methodは、［
単独の［
応用／~data形式
］に特有でない，文書
］内に登録されることが選好される
— 直交的な技術は、直交的な仕様に~~価するので。
◎
Standardized methods are generic; that is, they are potentially applicable to any resource, not just one particular media type, kind of resource, or application. As such, it is preferred that new methods be registered in a document that isn't specific to a single application or data format, since orthogonal technologies deserve orthogonal specification.
</p>

<p>
~messageの構文解析（ `Messaging/6$sec ）は，（ `HEAD$m に対する応答は別として）~methodの意味論に依存しない必要があるので、新たな~methodの定義は，要請, 応答どちらの~messageにおいても［
構文解析~algoを変更する／`~message本体$が在ることを禁制する
］ことはできない。
新たな~methodの定義は、［
`Content-Length$h ~headerの値に "`0^c" を要求する
］ことにより，［
長さ 0 の`~message本体$のみが許容される
］ように指定できる。
◎
Since message parsing (Section 6 of [Messaging]) needs to be independent of method semantics (aside from responses to HEAD), definitions of new methods cannot change the parsing algorithm or prohibit the presence of a message body on either the request or the response message. Definitions of new methods can specify that only a zero-length message body is allowed by requiring a Content-Length header field with a value of "0".
</p>

<div class="p">
<p>
新たな~method定義は、次を指示する必要がある：
◎
A new method definition needs to indicate＼
</p>
<ul>
	<li>
`安全$か？
`冪等$か？
`~cache可能$か？
◎
whether it is safe (Section 8.2.1), idempotent (Section 8.2.2), cacheable (Section 8.2.3),＼
</li>
	<li>
要請~内に在る`~payload本体$に，どのような意味論が結付けられるか？
◎
what semantics are to be associated with the payload body if any is present in the request and＼
</li>
	<li>
`~header$や`状態s~code$の意味論に，どのような精緻化を~~施すか？
◎
what refinements the method makes to header field or status code semantics.＼
</li>
</ul>

<p>
加えて，その定義は、次も述べる~OUGHT：
◎
＼
</p>
<ul>
	<li>
~cache可能である場合、どの条件~下で，どのように
⇒＃
応答を~cacheに格納できるか？ ／
~cacheを後続の要請を満足するために利用できるか？
◎
If the new method is cacheable, its definition ought to describe how, and under what conditions, a cache can store a response and use it to satisfy a subsequent request.＼
</li>
	<li>
条件付きにできるか？
— できる場合、条件が偽のときに，~serverはどう応答するか？
◎
The new method ought to describe whether it can be made conditional (Section 9.2) and, if so, how a server responds when the condition is false.＼
</li>
	<li>
`部分的な応答$（ `9.3$sec ）の意味論~用の，何らかの利用はあり得るか？
— その場合、それも文書~化する~OUGHT。
◎
Likewise, if the new method might have some use for partial response semantics (Section 9.3), it ought to document this, too.
</li>
</ul>
</div>

<p class="note">注記：
"`M-^c" から開始する~method名は、定義しないこと
— その接頭辞は、［
`RFC2774$r によりアテガわれる意味論を持つ
］ものと誤解釈され易いので。
◎
Note: Avoid defining a method name that starts with "M-", since that prefix might be misinterpreted as having the semantics assigned to it by [RFC2774].
</p>

			</section>
		</section>
	</section>
	<section id="request.header.fields">
<h2 title="Request Header Fields">9. 要請~header</h2>

<div class="p">
<p>
`~client$は、次のいずれかのために
`要請~header^dfn
を送信する：
◎
A client sends request header fields to＼
</p>
<ul>
	<li>
要請~文脈についての更なる情報を供する。
◎
provide more information about the request context,＼
</li>
	<li>
`~target資源$の状態に基づいて，要請を条件付きにする。
◎
make the request conditional based on the target resource state,＼
</li>
	<li>
応答に選好される形式を示唆する。
◎
suggest preferred formats for the response,＼
</li>
	<li>
認証用の`資格証$を給する。
◎
supply authentication credentials, or＼
</li>
	<li>
期待される要請~処理を改変する。
◎
modify the expected request processing.＼
</li>
</ul>

<p>
これらの`~field$は、~programming言語の~methodに渡す~parameterに類似な，要請の改変子として動作する。
◎
These fields act as request modifiers, similar to the parameters on a programming language method invocation.
</p>
</div>

		<section id="request.controls">
<h3 title="Controls">9.1. 制御</h3>

<p>
`制御~header@
とは、要請に対し 特定の取扱いを指令する，`要請~header$である：
◎
Controls are request header fields that direct specific handling of the request.
</p>

<div>
<ul><li>`Cache-Control$h `Caching$r
</li><li>`Expect$h
</li><li>`Host$h
</li><li>`Max-Forwards$h
</li><li>`Pragma$h `Caching$r
</li><li>`Range$h
</li><li>`TE$h
</li></ul>

◎
Table 12
Field Name 	Ref.
• Cache-Control 	Section 5.2 of [Caching]
• Expect 	9.1.1
• Host 	6.5
• Max-Forwards 	9.1.2
• Pragma 	Section 5.4 of [Caching]
• TE 	5.6.5
</div>

			<section id="field.expect">
<h4>9.1.1. `Expect^h</h4>

<p>
要請~内の `Expect^h ~headerは、
`期待^dfn
（ `expectation$p ）を指示する
— それは、［
当の要請を適正に取扱うためには、~serverが~supportする必要がある
］ような，一定の挙動の集合である。
◎
The "Expect" header field in a request indicates a certain set of behaviors (expectations) that need to be supported by the server in order to properly handle this request.
</p>

<pre class="bnf">
`Expect@p
    = #`expectation$p
`expectation@p
    = `token$p [ "=" ( `token$p / `quoted-string$p ) `parameters$p ]
</pre>

<p>
`Expect^h `~field値$は文字大小無視である。
◎
The Expect field value is case-insensitive.
</p>

<p>
この仕様が定義する唯一の期待は、
"`100-continue$c" である（定義される~parameterは無い）。
◎
The only expectation defined by this specification is "100-continue" (with no defined parameters).
</p>

<p>
`Expect^h にて［
`100-continue$c 以外の~memberを包含している`~field値$
］を受信した`~server$は、
`417$st で応答して，予期されない期待には応えられないことを指示してもヨイ。
◎
A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.
</p>

<p>
`期待$
`100-continue@c
は、［
`~client$は，当の要請~内に（大概は巨大な）`~message本体$を送信しつつあり、［
~method, `~target~URI$, および各種~header
］が［
即時に成功をもたらすには足らない／~redirectになる／~error応答になる
］かどうかについて，`暫定-応答$ `100$st の受信-を望んでいる
］ことを`受信者$に伝える。
これにより、~clientは，~~事前に［
~message本体を送信するに~~価するかどうかの指示
］があるまで待機できるようになり、~message本体が~~巨大なときや,
~errorになる見込みが高いと~clientが見越すとき（例：以前に検証yされた認証用の`資格証$を伴わずに，初回に状態変更~methodを送信するとき）に，効率性を改善できる。
◎
A 100-continue expectation informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a 100 (Continue) interim response if the method, target URI, and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the message body before actually doing so, which can improve efficiency when the message body is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).
</p>

<div class="example">
<p>
例えば，次で始まる要請により：
◎
For example, a request that begins with
</p>

<pre class="lang-http">
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue
</pre>
</div>

<p>
`生成元~server$は、［
`~client$が，不必要な~data転送で~pipeを埋め~~始める
］前に，［
`401$st や `405$st などの~error~message
］で即時に応答できるようになる。
◎
allows the origin server to immediately respond with an error message, such as 401 (Unauthorized) or 405 (Method Not Allowed), before the client starts filling the pipes with an unnecessary data transfer.
</p>

<p>
`~client$に課される要件は：
◎
Requirements for clients:
</p>
<ul>
	<li>
`~message本体$を内包しない要請~内に
`100-continue$c 期待を`生成し$てはナラナイ。
◎
A client MUST NOT generate a 100-continue expectation in a request that does not include a message body.
</li>
	<li>
要請の`~message本体$を送信する前に， `100$st 応答を待機するつもりがあるときは、
`100-continue$c 期待を包含する `Expect^h ~headerを送信しなければナラナイ。
◎
A client that will wait for a 100 (Continue) response before sending the request message body MUST send an Expect header field containing a 100-continue expectation.
</li>
	<li>
`100-continue$c 期待を送信してから，特定の長さの時間 待機することは、要求されない
— 応答がまだ受信されないうちに，`~message本体$の送信を続行してもヨイ。
更には，
`100$st 応答は ~HTTP10中継者を通しては送信され得ないので、~message本体を送信する前に不定~期間 待機するベキでない。
◎
A client that sends a 100-continue expectation is not required to wait for any specific length of time; such a client MAY proceed to send the message body even if it has not yet received a response. Furthermore, since 100 (Continue) responses cannot be sent through an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite period before sending the message body.
</li>
	<li>
`100-continue$c 期待を包含する要請に対する応答~内に， `417$stを受信したときは、その要請を，
`100-continue$c 期待を除いた上で，繰返すベキである
— この `417^st0 応答は、単に，［
応答の`連鎖$は、期待を~supportしていない
］ことを指示するので（例：~HTTP10~serverを通して渡されるとき）。
◎
A client that receives a 417 (Expectation Failed) status code in response to a request containing a 100-continue expectation SHOULD repeat that request without a 100-continue expectation, since the 417 response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server).
</li>
</ul>

<p>
`~server$に課される要件は：
◎
Requirements for servers:
</p>
<ul>
	<li>
~HTTP10要請~内に受信された
`100-continue$c 期待は、無視しなければナラナイ。
◎
A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.
</li>
	<li>
次のいずれかに該当する場合、
`100$st 応答の送信を省略してもヨイ
⇒＃
対応する要請の`~message本体$の一部をすでに受信している／
~frame法が，~message本体が無いことを指示している
◎
A server MAY omit sending a 100 (Continue) response if it has already received some or all of the message body for the corresponding request, or if the framing indicates that there is no message body.
</li>
	<li>
`100$st 応答を送信した後，`~message本体$を受信して処理したなら、接続が尚早に~closeされない限り，最終的には `最終-応答$【！最終-状態s~code】を送信しなければナラナイ。
◎
A server that sends a 100 (Continue) response MUST ultimately send a final status code, once the message body is received and processed, unless the connection is closed prematurely.
</li>
	<li>
要請の`~payload本体$ 全体を読取る前に，`最終-応答$【！最終-状態s~code】で応答するときは、次のどちらを意図するか指示するベキである
⇒＃
接続を~closeする（例： `Messaging/9.6$sec を見よ）／
~payload本体の読取りを継続する
◎
A server that responds with a final status code before reading the entire request payload body SHOULD indicate whether it intends to close the connection (e.g., see Section 9.7 of [Messaging]) or continue reading the payload body.
</li>
</ul>

<p>
［
`生成元~server$／`~proxy$
］は、`~HTTP11$（以上の~versionの）［
~method, `~target~URI$, 完全な`~header節$
］を受信したとき，それが［
`100-continue$c 期待を包含していて，要請の`~message本体$が後続することを指示している
］ならば：
◎
↓</p>
<ul>
	<li>
<p>
`生成元~server$は、次のいずれかをしなければナラナイ：
◎
An origin server MUST, upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request message body will follow, either＼
</p>
		<ul>
			<li>
［
~method, `~target~URI$, 各~header
］を精査するだけで，状態sを決定できるならば、即時に その`状態s~code$を伴う`最終-応答$【！最終-状態s~codeを伴う応答】を送信する。
◎
send an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or＼
</li>
			<li>
`100$st 応答を送信して，~clientに要請の`~message本体$を送信してもらうよう奨励する
— この場合、この応答を送信する前に，~message本体を待機してはナラナイ。
◎
send an immediate 100 (Continue) response to encourage the client to send the request's message body. The origin server MUST NOT wait for the message body before sending the 100 (Continue) response.
</li>
		</ul>
	</li>
	<li>
<p>
`~proxy$は、次のいずれかをしなければナラナイ：
◎
A proxy MUST, upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request message body will follow, either＼
</p>
		<ul>
			<li>
［
~method, `~target~URI$, 各~header
］を精査するだけで，状態sを決定できるならば、即時に その`状態s~code$を伴う`最終-応答$【！最終-状態s~codeを伴う応答】を送信する。
◎
send an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or＼
</li>
			<li>
<p>
`内方$にある次の`~server$へ対応する［
~method, `~target~URI$【！＊`request-line$p】, `~header節$
］を送信することにより、`生成元~server$へ向けて当の要請を回送し始める。
◎
begin forwarding the request toward the origin server by sending a corresponding request-line and header section to the next inbound server.＼
</p>

<p>
ただし，［
内方にある次の~serverが~HTTP10のみを~supportする
］ことを（環境設定または過去のやりとりから）予見できるならば、`~client$に`~message本体$を送信し始めてもらうよう，即時に `100$st 応答を`生成し$てもヨイ。
◎
If the proxy believes (from configuration or past interaction) that the next inbound server only supports HTTP/1.0, the proxy MAY generate an immediate 100 (Continue) response to encourage the client to begin sending the message body.
</p>
			</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`Expect^h ~headerは、
~~元々の~HTTP11 `RFC2068$r が発行された後に，［
`暫定-応答$ `100$st を要請する手段
］と［
解さなければならない拡張を指示するための一般的な仕組み
］の両者として追加された。
しかしながら，この拡張の仕組みは、~clientからは未だ利用されていないことに加え，多くの~serverは その要件を実装していないため、拡張の仕組みの具現化は，無用と化している。
`100-continue$c の定義とその処理を単純~化するため、この仕様は，その拡張の仕組みを除去した。
◎
Note: The Expect header field was added after the original publication of HTTP/1.1 [RFC2068] as both the means to request an interim 100 (Continue) response and the general mechanism for indicating must-understand extensions. However, the extension mechanism has not been used by clients and the must-understand requirements have not been implemented by many servers, rendering the extension mechanism useless. This specification has removed the extension mechanism in order to simplify the definition and processing of 100-continue.
</p>

			</section>
			<section id="field.max-forwards">
<h4>9.1.2. `Max-Forwards^h</h4>

<p>
`Max-Forwards^h ~headerは、`要請~method$［
`TRACE$m ／ `OPTIONS$m
］と伴に，［
要請が`~proxy$により回送される回数
］を制限する仕組みを供する。
これは、`~client$が［`連鎖$の途上で［
失敗する／~loopする
］ように出現する要請
］の跡をなぞろうと試みるとき，有用になり得る。
◎
The "Max-Forwards" header field provides a mechanism with the TRACE (Section 8.3.8) and OPTIONS (Section 8.3.7) request methods to limit the number of times that the request is forwarded by proxies. This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
</p>

<pre class="bnf">
`Max-Forwards@p
    = 1*DIGIT
</pre>

<p>
`Max-Forwards^h は、［
当の要請~messageを回送できる残りの回数
］を指示する~decimal整数を値にとる。
◎
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message can be forwarded.
</p>

<div class="p">
<p>
各 `中継者$は、
`Max-Forwards^h ~headerを包含している［
`TRACE$m ／ `OPTIONS$m 
］要請を受信したときは、要請を回送するに先立って，その値 `N^V を検査して更新しなければナラナイ。
`中継者$は、 `N^V に応じて：
◎
Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request.＼
</p>
<ul class="switch">
	<li>
`N^V ~EQ 0 の場合
⇒
要請を回送してはナラナイ
— 代わりに、`最終-受信者$として応答しなければナラナイ。
◎
If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient.＼
</li>
	<li>
他の場合（ `N^V ≥ 1 ）
⇒
回送する~message内に
`Max-Forwards^h ~header【！~field】を
— その`~field値$を次のうち最小に更新した上で —
`生成し$なければナラナイ
⇒＃
`N^V − 1,
当の受信者が `Max-Forwards^h 用に~supportする最大~値
◎
If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.
</li>
</ul>
</div>

<p>
`受信者$は、［
他の要請~methodに伴って受信した `Max-Forwards^h ~header
］については，無視してもヨイ。
◎
A recipient MAY ignore a Max-Forwards header field received with any other request methods.
</p>

			</section>
		</section>
		<section id="preconditions">
<h3 title="Preconditions">9.2. 事前条件</h3>

<p>
`条件付き要請^dfn
（ `conditional request^en ）とは、
1 個~以上の`条件付き要請~header$を伴う`~HTTP要請$である。
`条件付き要請~header^dfn
（ “事前条件~header” とも称される†）とは、［
要請~methodを`~target資源$に適用する前
］に~testされることになる，
`事前条件@
（ `precondition^en ）
を指示する要請~headerである。
`9.2.1$sec は、事前条件がいつ適用されるかを定義する。
`9.2.2$sec は、事前条件が複数個~在るときの評価~順序を定義する。
◎
A conditional request is an HTTP request with one or more request header fields that indicate a precondition to be tested before applying the request method to the target resource. Section 9.2.1 defines when preconditions are applied. Section 9.2.2 defines the order of evaluation when more than one precondition is present.
</p>

<p class="trans-note">【†
これら 2 つの用語は、同義と見受けられる（その差異は、この仕様からは読み取れない）。
［
条件付き要請／条件付き~header
］は、単に “条件付き” とも総称される（文脈に応じて両者または適切な方を指すであろう）。
】</p>

<p>
条件付き `GET$m 要請は、~HTTP~cache更新 `Caching$r 用の効率的な仕組みの大部分を~~占める。
`条件付き$は、
“`更新喪失@”
問題
— 並列的に動作している ある~clientが，別の~clientによる成果を偶発的に上書きすること —
を防止するために，［
`PUT$m や `DELETE$m  などの状態変更~method
］にも適用され得る／できる。
◎
Conditional GET requests are the most efficient mechanism for HTTP cache updates [Caching]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the "lost update" problem: one client accidentally overwriting the work of another client that has been acting in parallel.
</p>

<p>
`条件付き要請$の`事前条件$は、［
一体としての，`~target資源$の状態（その現在の値の集合）
］, あるいは［
以前に得された`表現$（その集合~内の 1 つの値）
］にて観測される状態に基づく。
`資源$は、現在の表現として，［
それぞれが自前の観測-可能な状態を伴うような，複数の表現
］を持つかもしれない。
条件付き要請の仕組みは、~serverが その利点を得ようと意図するならば，［
要請から`選定された表現$への対応関係は、時経過にわたり一貫する
］ものと見做す。
いずれにせよ、対応関係が一貫しなくなり，~serverが適切な`表現$を選定-不能になっても、事前条件が偽に評価される結果，害になることはない。
◎
Conditional request preconditions are based on the state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). A resource might have multiple current representations, each with its own observable state. The conditional request mechanisms assume that the mapping of requests to a selected representation (Section 7) will be consistent over time if the server intends to take advantage of conditionals. Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false.
</p>

<p>
次に挙げる要請~headerは、`~target資源$の状態に対する`事前条件$を設置することを，`~client$に許容する
— それは、偽に評価されたときには［
~method意味論に対応する動作
］を適用しない†ようにする条件を与える
⇒＃
`If-Match$h
`If-None-Match$h
`If-Modified-Since$h
`If-Unmodified-Since$h
`If-Range$h†
◎
The following request header fields allow a client to place a precondition on the state of the target resource, so that the action corresponding to the method semantics will not be applied if the precondition evaluates to false.＼
</p>

<p class="trans-note">【†
`If-Range^h については、適用~対象が（~method意味論に直に対応する動作ではなく） `Range$h ~headerになる点で，他の事前条件~headerと異なる。
】</p>

<p>
この仕様が定義する各種 `事前条件$は、［
先立つ［
~target資源の`表現$
］から得された`検証子$の集合
］と［
`選定された表現$用の，それらの検証子の現在の状態
］との比較からなる。
よって，これらの事前条件は、~target資源の状態が［
~clientに既知である，所与の状態
］から変化したかどうかを評価する。
そのような評価の効果は、
`9.2.1$sec に定義されるように［
~method意味論, `条件付き$の選択
］に依存する。
◎
Each precondition defined by this specification consists of a comparison between a set of validators obtained from prior representations of the target resource to the current state of validators for the selected representation (Section 11.2). Hence, these preconditions evaluate whether the state of the target resource has changed since a given state known by the client. The effect of such an evaluation depends on the method semantics and choice of conditional, as defined in Section 9.2.1.
◎
Table 13
Field Name 	Ref.
• If-Match 	9.2.3
• If-None-Match 	9.2.4
• If-Modified-Since 	9.2.5
• If-Unmodified-Since 	9.2.6
• If-Range 	9.2.7
</p>

			<section id="evaluation">
<h4 title="Evaluation">9.2.1. 評価</h4>

<div class="p">
<p>
`受信者$である［
`~cache$／`生成元~server$
］は
— 以下により除外されるときを除いて —
［
自身による通常の要請~検査を成功裡に遂行した後
］かつ［
要請~本体（もし在れば）を処理するか，`要請~method$に結付けられた動作を遂行する
］~~直前【いずれか早い方】に，受信した要請の`事前条件$を評価しなければナラナイ。
◎
Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request body (if any) or perform the action associated with the request method.＼
</p>

<p>
~serverは：
◎
＼</p>
<ul>
	<li>
<p>
次に該当する場合、受信したすべての`事前条件$を無視しなければナラナイ
⇒
当の要請が それらの条件を伴っていなかったとするとき、対する応答の`状態s~code$は
— 要請~本体の処理に先立って —
［
`2xx$st, `412$st
］以外になる
◎
A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request body, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).＼
</p>

<p>
言い換えれば，有意な処理が生じる前に検出された~redirectや失敗は、`事前条件$の評価よりも優先される。
◎
In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.
</p>
	</li>
	<li>
［
`~target資源$に対する`生成元~server$でない
］かつ［
`~target資源$に対する要請~用の~cacheとしても動作し得ない
］ならば、この仕様が定義する`条件付き要請~header$を評価してはナラナイ
— 要請を回送するときは、それらの~headerも回送しなければナラナイ。
そのような~headerを生成した~clientは、それを評価するのは，現在の`表現$を供せる~serverであることを意図しているので。
◎
A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation.＼
</li>
	<li>
`選定される表現$の［
選定, 改変
］を孕まない`要請~method$
— `CONNECT$m, `OPTIONS$m, `TRACE$m など —
に伴って受信した`条件付き要請~header$のうち，この仕様が定義するものは、無視しなければナラナイ。
◎
Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.
</li>
</ul>
</div>

<p>
~protocol拡張は、再検証を誘発し得る条件を改変し得ることに注意。
例えば， `immutable$sdir `~cache指令$ `RFC8246$r は、`新鮮$な応答の再検証を，~clientから要請されようが差控えるよう ~cacheに指図する。
◎
Note that protocol extensions can modify the conditions under which revalidation is triggered. For example, the "immutable" cache directive (defined by [RFC8246]) instructs caches to forgo revalidation of fresh responses even when requested by the client.
</p>

<p>
~HTTPに対する拡張により定義される条件付き要請~headerは、［
すべての受信者 ／
一般的な`~target資源$の状態 ／
`資源$の~group
］に対し，条件を設置することもある。
一例として， WebDAV における `If$h ~headerは、［
`~lock$など，複数の資源の様々な側面
］に対し，要請を条件付きにし得る
— 受信者が その~fieldを解する, かつ実装するならば。
◎
Conditional request header fields that are defined by extensions to HTTP might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the "If" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([RFC4918], Section 10.4).
</p>

<p>
`条件付き要請~header$は，（ `HEAD$m, `GET$m の間で意味論の整合性を保つため）
`HEAD$m ~methodと伴用できるものと定義されるが、条件付き `HEAD$m を送信することに~~利点はない
— 何故なら，成功裡な応答は、
`304$st 応答と~~大体~同じ~sizeになり，
`412$st 応答よりも有用なので。
◎
Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response.
</p>

			</section>
			<section id="precedence">
<h4 title="Precedence">9.2.2. 優先順</h4>

<div class="p">
<p>
要請~内に`条件付き要請~header$が~~複数~在る場合、それらの~fieldが評価される順序が重要になる。
実施においては、この文書にて定義される各種~fieldは、次の~~理由から，一貫して［
ある単独の，論理的な順序
］で実装されている：
◎
When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since＼
</p>
<ul>
	<li>
“`更新喪失$” のための`事前条件$は、`~cache検証$よりも厳密な要件を備える。
◎
"lost update" preconditions have more strict requirements than cache validation,＼
</li>
	<li>
検証された~cacheは、`部分的な応答$よりも効率的である。
◎
a validated cache is more efficient than a partial response, and＼
</li>
	<li>
`entity-tag$p は、日時~検証子よりも正確aと~~見做されている。
◎
entity tags are presumed to be more accurate than date validators.
</li>
</ul>
</div>

<p>
受信者である［
~cache／`生成元~server$
］は、要請における［
この仕様にて定義される各種`事前条件$
］を，次の順序で評価しなければナラナイ：
◎
A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order:
</p>

<p class="trans-note">【
以下における “応答する” は、そこで評価~~手続きを終えることも意味する。
】</p>
<ol>
	<li>
<p>
次がすべて満たされるならば…
</p>
		<ul>
			<li>
受信者は`生成元~server$である
</li>
			<li>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li>
要請に `If-Match$h が在って，その事前条件は偽に評価される

</li>
					<li>
要請に `If-Match$h は無い, かつ［
要請に `If-Unmodified-Since$h が在って，その事前条件は偽に評価される
］
</li>
				</ul>
			<li>
次に該当しない
⇒
要請は状態変更~methodであって，すでに成功したものと決定できた（詳細は前項の各~fieldの記述を見よ）
</li>
		</ul>
<p>
…ならば
⇒
`412$st で応答する
</p>

◎
When recipient is the origin server and If-Match is present, evaluate the If-Match precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 9.2.3)
◎
When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:
• if true, continue to step 3
• if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 9.2.6)
</li>
	<li>
<p>
要請の~methodに応じて：
</p>
		<dl class="switch">
			<dt>`GET$m</dt>
			<dt>`HEAD$m</dt>
			<dd>
<p>
次のいずれかが満たされるならば…：
</p>
				<ul>
					<li>
要請に `If-None-Match$h が在って，その事前条件は偽に評価される
</li>
					<li>
要請に `If-None-Match$h は無い, かつ［
要請に `If-Modified-Since$h が在って，その事前条件は偽に評価される
］
</li>
				</ul>
<p>
…ならば
⇒
`304$st で応答する
</p>

			</dd>
			<dt>その他</dt>
			<dd>
要請に `If-None-Match$h が在って，その事前条件は偽に評価されるならば
⇒
`412$st で応答する
</dd>
		</dl>

◎
When If-None-Match is present, evaluate the If-None-Match precondition:
• if true, continue to step 5
• if false for GET/HEAD, respond 304 (Not Modified)
• if false for other methods, respond 412 (Precondition Failed)
◎
When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition:
• if true, continue to step 5
• if false, respond 304 (Not Modified)
</li>
	<li>
<p>
次がすべて満たされるならば…：
</p>
				<ul>
					<li>
~methodは `GET$m である
</li>
					<li>
`Range$h, `If-Range$h ともに在る
</li>
					<li>
`If-Range$h 事前条件を評価したとき，検証子が合致する
</li>
					<li>
`Range$h 指定は`選定された表現$に適用-可能である
</li>
				</ul>
<p>
…ならば
⇒
`206$st で応答する
</p>

◎
When the method is GET and both Range and If-Range are present, evaluate the If-Range precondition:
• if the validator matches and the Range specification is applicable to the selected representation, respond 206 (Partial Content)
</li>
	<li>
すべての条件は満たされたので、要請された動作を遂行した上で，その成功／失敗に則って応答する。
◎
Otherwise,
• all conditions are met, so perform the requested action and respond according to its success or failure.
</li>
</ol>

<p>
追加的な条件付き要請~headerを定義するような，~HTTPに対する拡張は、［［
この文書にて定義されるもの, および
実施において見出され得る他の`条件付き$
］と，そのような~fieldを評価する順序
］に関する，自前の期待を定義する~OUGHT。
◎
Any extension to HTTP that defines additional conditional request header fields ought to define its own expectations regarding the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.
</p>

			</section>
			<section id="field.if-match">
<h4>9.2.3. `If-Match^h</h4>

<p>
`If-Match^h ~headerは、受信者である`生成元~server$に対し，`要請~method$を次による条件付きにする：
◎
The "If-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を `S^V とするとき、`~field値$に応じて：
◎
the recipient origin server either＼
</p>
		<ul class="switch" id="condition-If-Match">
			<li>
"`*^c" の場合
⇒
`S^V は空でない。
◎
having at least one current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^V 内に［
~list内の ある~memberに合致する `entity-tag$p
］を持つものがある。
◎
having a current representation of the target resource that has an entity-tag matching a member of the list of entity-tags provided in the field value.
</li>
		</ul>
	</li>
	<li>
`生成元~server$は、
`If-Match^h に対し `entity-tag$p を比較するときには，`強い比較~関数$を利用しなければナラナイ
— ~clientが，この`事前条件$に意図しているのは、［
`表現~data$に何か変化があった場合には，~methodを適用しない
］ことなので。
◎
An origin server MUST use the strong comparison function when comparing entity-tags for If-Match (Section 11.2.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.
</li>
</ul>

<pre class="bnf">
`If-Match@p
    = "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</pre>
</div>

<p>
`If-Match^h は、［［
同じ`資源$に対し，複数の~UAが並列的に動作し得る
］ときの，偶発的な上書-（すなわち， “`更新喪失$”問題）
］を防止するために，状態変更~method（例：
`POST$m, `PUT$m, `DELETE$m
）と伴に，最もよく利用される。
また、どの~methodにも利用できる／され得る
— `選定された表現$が［
当の`~client$が、以前の要請に対し，すでに（あるいは`部分的$に）格納した応答
］に合致しない場合には、要請を中止するために。
◎
If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the "lost update" problem). It can also be used with any method to abort a request if the selected representation does not match one that the client has already stored (or partially stored) from a prior request.
</p>

<p>
`If-Match^h ~headerを受信した`生成元~server$は、~methodの遂行に先立って
— `9.2.1$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Match">前述の条件</a>を評価しなければナラナイ
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Match header field MUST evaluate the condition as per Section 9.2.1 prior to performing the method.
◎
To evaluate a received If-Match header field:
• If the field value is "*", the condition is true if the origin server has a current representation for the target resource.
• If the field value is a list of entity-tags, the condition is true if any of the listed tags match the entity-tag of the selected representation.
• Otherwise, the condition is false.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server MUST NOT perform the requested method if a received If-Match condition evaluates to false.＼
</li>
	<li>
代わりに，`状態s~code$ `412$st で応答して、当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、`選定される表現$には，すでに適用されたように出現している場合
］には、前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ（すなわち，~UAから要請された変更はすでに成功したが、たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気づかなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、複数の~UAが，共通な資源に対し~semaphoreとして書込んでいると（例：可分な増分）、衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、厳格に［
~methodが`安全$でない場合は、失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
他の事例【`安全$な場合】では、当の資源の現在の状態についての混同を排するよう，成功~応答から `ETag$h ~fieldを除外すれば、次回の要請として `GET$m を遂行するよう~UAに奨励するかもしれない。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a non-atomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.
</p>
	</li>
</ul>

<p>
`If-Match^h ~headerは、格納-済み応答には適用-可能でないので，~cacheや`中継者$からは無視され得る。
◎
The If-Match header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

<p>
`If-Match^h ~headerに［
"`*^c" と他の値（ "`*^c" も含む）
］を包含している~list値が伴われる場合、相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-Match header field with a list value containing "*" and other values (including other instances of "*") is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-none-match">
<h4>9.2.4. `If-None-Match^h</h4>

<div class="p">
<p>
`If-None-Match^h ~headerは、受信者である［
~cache／`生成元~server$
］に対し，`要請~method$を次による条件付きにする：
◎
The "If-None-Match" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`~target資源$の現在の`表現$からなる集合を `S^V とするとき、`~field値$に応じて：
◎
a recipient cache or origin server either＼
</p>
		<ul class="switch" id="condition-If-None-Match">
			<li>
"`*^c" の場合
⇒
`S^V は空である。
◎
not having any current representation of the target resource, when the field value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^V 内で`選定される表現$として［
~list内の ある~memberに合致する `entity-tag$p
］を持つものはない。
◎
having a selected representation with an entity-tag that does not match any of those listed in the field value.
</li>
		</ul>
	</li>
	<li>
受信者は、 `If-None-Match^h 用に `entity-tag$p を比較するときには，`弱い比較~関数$を利用しなければナラナイ
— `弱い検証子$である `entity-tag$p は、`表現~data$が変化したとしても，`~cache検証$に利用できるので。
◎
A recipient MUST use the weak comparison function when comparing entity-tags for If-None-Match (Section 11.2.3.2), since weak entity-tags can be used for cache validation even if there have been changes to the representation data.
</li>
</ul>
</div>

<pre class="bnf">
`If-None-Match@p
    = "*" / #`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</pre>
</div>

<p>
`If-None-Match^h は、［
~transactionの~overheadを最小に~~抑えて，~cache済み情報の効率的な更新を可能化する
］ために、首に，条件付き `GET$m 要請にて利用される。
~clientが `entity-tag$p を持つ 1 個以上の格納-済み応答の更新を欲するときは、
`GET$m 要請を為すときに［
それらの `entity-tag$p からなる~listを包含する， `If-None-Match^h ~header
］を`生成する$ベキである
— これにより、受信者~serverは、［
それら格納-済み応答のいずれかが，`選定された表現$に合致した
］ときに，それを指示する `304$st 応答を送信できるようになる。
◎
If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity-tags, the client SHOULD generate an If-None-Match header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation.
</p>

<p>
`If-None-Match^h は、`安全$でない`要請~method$（例： `PUT$m ）にも，値 "`*^c" を伴わせて利用できる
— これにより，~clientは、`資源$が現在の`表現$を持たないものと予見できるときに，`~target資源$の既存の表現を不作為に改変することを防止できる。
これは、［
~~複数の~clientが，`~target資源$に対する初期~表現を作成しようと試みた
］ときに発生し得る， “`更新喪失$” 問題の一種である。
◎
If-None-Match can also be used with a value of "*" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 8.2.1). This is a variation on the "lost update" problem that might arise if more than one client attempts to create an initial representation for the target resource.
</p>

<p>
`If-None-Match^h ~headerを受信した`生成元~server$は、~methodの遂行に先立って
— `9.2.1$sec に従う下で —
その~field値に与えられた<a href="#condition-If-None-Match">前述の条件</a>を
評価しなければナラナイ
— 条件が偽に評価された場合
◎
An origin server that receives an If-None-Match header field MUST evaluate the condition as per Section 9.2.1 prior to performing the method.
◎
To evaluate a received If-None-Match header field:
• If the field value is "*", the condition is false if the origin server has a current representation for the target resource.
• If the field value is a list of entity-tags, the condition is false if one of the listed tags matches the entity-tag of the selected representation.
• Otherwise, the condition is true.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
An origin server MUST NOT perform the requested method if the condition evaluates to false;＼
</li>
	<li>
代わりに，［
`要請~method$が `GET$m または `HEAD$m ならば `304$st ／
他の要請~methodに対しては `412$st
］で応答しなければナラナイ。
◎
instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.
</li>
</ul>

<p>
~cacheが受信した `If-None-Match^h ~headerの取扱い課される要件は、
`Caching/4.3.2$sec
にて定義される。
◎
Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [Caching].
</p>

<p>
`If-None-Match^h ~headerに［
"`*^c" と他の値（ "`*^c" も含む）を包含している~list値
］が伴われる場合、相互運用可能にならない見込みが高いことに注意。
◎
Note that an If-None-Match header field with a list value containing "*" and other values (including other instances of "*") is unlikely to be interoperable.
</p>

			</section>
			<section id="field.if-modified-since">
<h4>9.2.5. `If-Modified-Since^h</h4>

<div class="p">
<p>
`If-Modified-Since^h ~headerは、［
`GET$m ／ `HEAD$m
］要請~methodを，次による条件付きにする：
◎
The "If-Modified-Since" header field makes a GET or HEAD request method conditional on＼
</p>
<ul id="condition-If-Modified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は、`~field値$が供する日時より近過去である。
◎
the selected representation's modification date being more recent than the date provided in the field value.＼
</li>
</ul>

<p>
`選定された表現$の~dataが変更されていない場合、その転送を避けれるようになる。
◎
Transfer of the selected representation's data is avoided if that data has not changed.
</p>
</div>

<pre class="bnf">
`If-Modified-Since@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
~fieldの例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
受信者は、要請が `If-None-Match$h ~headerも包含する場合には，
`If-Modified-Since^h を無視しなければナラナイ
— `If-None-Match$h 内の条件は，
`If-Modified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-None-Match$h を実装していない~~可能性もある古い`中継者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.
</p>

<div class="p">
<p>
受信者は、次のいずれかの場合には，
`If-Modified-Since^h ~headerを無視しなければナラナイ：
◎
A recipient MUST ignore the If-Modified-Since header field＼
</p>
<ul>
	<li>
受信した~field値は、
`HTTP-date$p として妥当でないか，
1 個以上の~memberからなる。
◎
if the received field value is not a valid HTTP-date, the field value has more than one member, or＼
</li>
	<li>
要請~methodは `GET$m, `HEAD$m のいずれでもない。
◎
if the request method is neither GET nor HEAD.
</li>
</ul>
</div>

<p>
受信者は、
`If-Modified-Since^h ~field値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.
</p>

<div class="p">
<p>
`If-Modified-Since^h は、概して，次に挙げる別個な目的に利用される：
◎
If-Modified-Since is typically used for two distinct purposes:＼
</p>
<ul>
	<li>
(A)
`entity-tag$p を持たないような~cache済み`表現$を，効率的に更新する。
◎
1) to allow efficient updates of a cached representation that does not have an entity-tag and＼
</li>
	<li>
(B)
［
~web~traversalによる，`資源$への検索取得
］の対象範囲を，近過去に変更されたもののみに制限する。
◎
2) to limit the scope of a web traversal to resources that have recently changed.
</li>
</ul>
</div>

<div class="p">
<p>
上の (A) に利用される場合、~cacheは，概して，
`If-Modified-Since^h の~field値を`生成する$ときに［
~cache済み~messageの `Last-Modified$h ~field値
］を利用することになる。
この挙動は、次の事例において，最も相互運用-可能になる：
◎
When used for cache updates, a cache will typically use the value of the cached message's Last-Modified field to generate the field value of If-Modified-Since. This behavior is most interoperable for cases＼
</p>
<ul>
	<li>
`時計$の同期-に乏しいとき, または
◎
where clocks are poorly synchronized or＼
</li>
	<li>
~serverが，［
時刻印の正確な合致のみを尊守する
］ことを選んだとき（［
`生成元~server$の`時計$が正された
］または［
`表現$が~backupの~archiveから格納し直された
］ことにより，
`Last-Modified$h 日時が “~~過去に戻る” ように出現する問題に因り）。
◎
when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go "back in time" when the origin server's clock is corrected or a representation is restored from an archived backup).＼
</li>
</ul>

<p>
しかしながら，~cacheは、ときには，［
~cache済み~messageの `Date$h ~headerや,
~messageを受信したときの局所的な時計による時刻
］などの他の~dataに基づいて，~field値を`生成する$こともある
— 特に，~cache済み~messageが `Last-Modified$h ~fieldを包含しないときに。
◎
However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a Last-Modified field.
</p>
</div>

<p>
上の (B) に利用される場合、~UAは，［
自前の局所的な時計, または
先立つ応答にて~serverから受信した `Date$h ~header
］に基づいて， `If-Modified-Since^h ~field値を`生成する$ことになる。
`生成元~server$が，［
`選定された表現$の `Last-Modified$h ~fieldに基づく，時刻印の正確な合致
］を選んだ場合、［
~UAが，~data転送を［
指定された~~時区間~内に変更されたもの
］のみに制限する
］一助にはならなくなることになる。
◎
When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own local clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
</p>

<div class="p">
<p>
`If-Modified-Since^h ~headerを受信した`生成元~server$は、`~method$の遂行に先立って
— `9.2.1$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Modified-Since">前述の条件</a>を評価するベキである
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Modified-Since header field SHOULD evaluate the condition as per Section 9.2.1 prior to performing the method.＼
</p>
<ul>
	<li>
要請された~methodを遂行するベキでない
◎
The origin server SHOULD NOT perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field value;＼
</li>
	<li>
代わりに，次のみを内包する， `304$st 応答を`生成する$ベキである
⇒
【応答の受信者が】以前に~cacheした応答を［
識別する／更新する
］ために有用になる~metadata
◎
instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.
</li>
</ul>
</div>

<p>
~cacheが受信した `If-Modified-Since^h ~headerの取扱いに課される要件は、
`Caching/4.3.2$sec
にて定義される。
◎
Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [Caching].
</p>

			</section>
			<section id="field.if-unmodified-since">
<h4>9.2.6. `If-Unmodified-Since^h</h4>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerは、`要請~method$を
<span id="condition-If-Unmodified-Since">次の`否定^em</span>
による条件付きにする：
◎
The "If-Unmodified-Since" header field makes the request method conditional on＼
</p>
<ul>
	<li>
<p>
`選定された表現$には［
`改変~日時$がある†
］かつ［
その最後の改変~日時は、`~field値$が供する日時より近過去である
］。
◎
the selected representation's last modification date being earlier than or equal to the date provided in the field value.＼
</p>

<p class="trans-note">【†
この条件（この改訂による追加）は、原文では後に現れているが，評価-可能になるために必要になるので ここに移動している。
（ `If-Modified-Since$h には，改変~日時の有無について述べられていないが、同様に必要になろう。）
】</p>
	</li>
</ul>

<p>
この~fieldは、~UAが`表現$用の `entity-tag$p を持たない所で， `If-Match$h と同じ目的を成遂げる。
◎
This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation.
</p>
</div>

<pre class="bnf">
`If-Unmodified-Since@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
`If-Unmodified-Since^h ~headerの受信者は：
◎
↓</p>
<ul>
	<li>
要請が `If-Match$h ~headerも包含する場合は、
`If-Unmodified-Since^h を無視しなければナラナイ
— `If-Match$h 内の条件は，
`If-Unmodified-Since^h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは、［
`If-Match$h を実装していないかもしれない古い`中継者$
］と相互運用するために限られる。
◎
A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.
</li>
	<li>
受信した`~field値$は妥当な `HTTP-date$p でない場合（~field値は日時の~listとして出現している場合も含む）、
`If-Unmodified-Since^h ~headerを無視しなければナラナイ。
◎
A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).
</li>
	<li>
`If-Unmodified-Since^h ~field値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.
</li>
</ul>

<p>
`If-Unmodified-Since^h は、状態変更~method（例： `POST$m, `PUT$m, `DELETE$m ）と伴に最もよく利用される
— ［
その`表現$に `entity-tag$p を給さない`資源$
］上で，複数の~UAが並列的に動作し得るときの、偶発的な上書-（すなわち， “`更新喪失$” 問題）を防止するために。
また、どの~methodにも利用できる／され得る
— `選定された表現$が［
当の`~client$が、以前の要請に対し，すでに（あるいは`部分的$に）格納した応答
］に合致しないときは、要請を中止するために。
◎
If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the "lost update" problem). It can also be used with any method to abort a request if the selected representation does not match one that the client already stored (or partially stored) from a prior request.
</p>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerを受信した`生成元~server$は、`~method$の遂行に先立って
— `9.2.1$sec に従う下で —
その~field値に与えられた<a href="#condition-If-Unmodified-Since">前述の条件</a>を評価しなければナラナイ
— 条件が偽に評価された場合：
◎
An origin server that receives an If-Unmodified-Since header field MUST evaluate the condition as per Section 9.2.1 prior to performing the method.
</p>
<ul>
	<li>
要請された~methodを遂行してはナラナイ。
◎
If the selected representation has a last modification date, the origin server MUST NOT perform the requested method if that date is more recent than the date provided in the field value.＼
</li>
	<li>
代わりに，`状態s~code$ `412$st で応答して、当の条件付き要請は失敗したことを指示してもヨイ。
◎
Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code.＼
</li>
	<li>
<p>
［
当の要請は状態変更~演算であり、`選定される表現$には，すでに適用されたように出現している場合
］には、前項に代えて，`状態s~code$ `2xx$st で応答してもヨイ（すなわち，~UAから要請された変更はすでに成功したが、たぶん［
先立つ応答~messageが失われた／他の~UAにより等価な変更が為された
］ため，~UAは それに気づかなかった）。
◎
Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).
</p>

<p>
これを許容することで，多くの著作~利用事例は より効率的になるが、［
複数の~UAが，よく似るが協力的でない変更~要請を為している場合
］には，~riskも伴われる。
例えば、複数の~UAが，共通な資源に対し~semaphoreとして書込んでいると（例：可分な増分）、衝突する見込みが高く，重要な状態~遷移が失われかねない。
そのような種類の資源~用には、厳格に［
~methodが`安全$でない場合は、失敗した どの事前条件に対しても `412$st0 を送信する
］方が良い。
◎
Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.
</p>
	</li>
</ul>
</div>

<p>
`If-Unmodified-Since^h ~headerは、格納-済み応答には適用-可能でないので，~cacheや`中継者$からは無視され得る。
◎
The If-Unmodified-Since header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

			</section>
			<section id="field.if-range">
<h4>9.2.7. `If-Range^h</h4>

<p>
`If-Range^h ~headerは、
`If-Match$h や `If-Unmodified-Since$h に~~似るが，［
検証子が合致しない場合には， `Range$h ~headerを無視する
］よう受信者に指図するための、特別な`条件付き要請$の仕組みを供する。
合致しない場合、 `412$st 応答の代わりに，新たな，`選定された表現$が転送されることになる。
◎
The "If-Range" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response.
</p>

<p>
`~client$が，［
`表現$の`部分的$な複製を持っていて, 表現~~全体の~~最新の複製を望む
］ならば、
`Range$h ~headerを，（
`If-Unmodified-Since$h, `If-Match$h
のいずれか, または両者を利用する）条件付き `GET$m と伴に利用できる。
しかしながら、表現が改変されたために`事前条件$が失敗した場合、~clientは，現在の表現~~全体を得するために，もう一度~要請を為さなければならなくなる。
◎
If a client has a partial copy of a representation and wishes to have an up-to-date copy of the entire representation, it could use the Range header field with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the precondition fails because the representation has been modified, the client would then have to make a second request to obtain the entire current representation.
</p>

<p>
`If-Range^h ~headerにより、~clientは，次回の要請を “短絡” できるようになる。
くだけて言えば、次のような意味になる
⇒
“表現がまだ不変なら， `Range$h にて要請している部位t（たち）を送信してください。
そうでなければ，表現~~全体を送信してください。”
◎
The "If-Range" header field allows a client to "short-circuit" the second request. Informally, its meaning is as follows: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.
</p>

<pre class="bnf">
`If-Range@p
    = `entity-tag$p / `HTTP-date$p
</pre>

<p>
`~client$は、
`Range$h ~headerを包含しない要請~内に，
`If-Range^h ~headerを`生成し$てはナラナイ。
`~server$は、
`Range$h ~headerを包含しない要請~内に受信した `If-Range^h ~headerを，無視しなければナラナイ。
`生成元~server$は、
`Range$h 要請を~supportしない`~target資源$に対する要請~内に受信した `If-Range^h ~headerを，無視しなければナラナイ。
◎
A client MUST NOT generate an If-Range header field in a request that does not contain a Range header field. A server MUST ignore an If-Range header field received in a request that does not contain a Range header field. An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.
</p>

<div class="p">
<p>
`~client$は、次のいずれかを包含する `If-Range^h ~headerを`生成し$てはナラナイ：
◎
↓</p>
<ul>
	<li>
弱い（ `weak$p を伴う） `entity-tag$p 。
◎
A client MUST NOT generate an If-Range header field containing an entity-tag that is marked as weak.＼
</li>
	<li>
`HTTP-date$p
— ただし、~clientが対応する`表現$用の `entity-tag$p を持たない, かつ
その日時が `11.2.2.2$sec にて定義されるイミで`強い検証子$になる場合は除く。
◎
A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity-tag for the corresponding representation and the date is a strong validator in the sense defined by Section 11.2.2.2.
</li>
</ul>
</div>

<div class="p">
<p>
`If-Range^h による`事前条件$を評価する`~server$は、
`If-Range$p に供されている`検証子$に応じて：
◎
A server that evaluates an If-Range precondition＼
</p>
<ul class="switch">
	<li>
`entity-tag$p の場合
⇒
`entity-tag^p を比較する際には，`強い比較~関数$を利用しなければナラナイ。
◎
MUST use the strong comparison function when comparing entity-tags (Section 11.2.3.2) and＼
</li>
	<li>
`HTTP-date$p の場合
⇒
それが（ `11.2.2.2$sec に定義されるイミで）`強い検証子$でない場合には、その事前条件を偽に評価しなければナラナイ。
◎
MUST evaluate the condition as false if an HTTP-date validator is provided that is not a strong validator in the sense defined by Section 11.2.2.2.＼
</li>
</ul>

<p>
妥当な `entity-tag^p と妥当な `HTTP-date^p は、判別できる
— 最初の 2 文字について `DQUOTE$P の有無を~~調べることにより。
◎
A valid entity-tag can be distinguished from a valid HTTP-date by examining the first two characters for a DQUOTE.
</p>
</div>

<p>
`~server$は、
`If-Range^h ~header内に与えられた`検証子$が［
`~target資源$の`選定された表現$に対する現在の`検証子$
］に合致する場合には，
`Range$h ~headerを要請されたとおり処理するベキであり、合致しない場合には，
`Range$h ~headerを無視しなければナラナイ。
この［
正確な合致による比較
］は
— `検証子$が `HTTP-date$p のときも含め —
［
`If-Unmodified-Since$h 条件付きを評価するときの “より早期かどうか” の比較
］から相違することに注意。
◎
If the validator given in the If-Range header field matches the current validator for the selected representation of the target resource, then the server SHOULD process the Range header field as requested. If the validator does not match, the server MUST ignore the Range header field. Note that this comparison by exact match, including when the validator is an HTTP-date, differs from the "earlier than or equal to" comparison used when evaluating an If-Unmodified-Since conditional.
</p>

			</section>
		</section>
		<section id="field.range">
<h3>9.3. `Range^h</h3>

<p>
`GET$m 要請~上の `Range^h ~headerは、［
`選定された表現$~~全体ではなく，その`表現~data$を成す 1 個~以上の部分範囲
］に限り転送を要請するよう，~method意味論を改変する。
◎
The "Range" header field on a GET request modifies the method semantics to request transfer of only one or more subranges of the selected representation data (Section 7.1), rather than the entire selected representation.
</p>

<pre class="bnf">
`Range@p
    = `ranges-specifier$p
</pre>

<p>
`~client$は、［
要請が取消された／接続が落とされた
］結果，~data転送の中断に遭遇することはよくある。
~clientが`部分的$な`表現$を格納したときは、後続の要請にて，
表現~~全体を転送するのでなく，その表現の残り~~部分を要請することが望ましい。
同様に，局所的な~storageが制限されている機器は、より大きい`表現$の下位集合のみを要請できることで便益を得ることもある
— 巨大な文書の単独の~pageや, 様々な~~断片による埋込d画像としてなど。
◎
Clients often encounter interrupted data transfers as a result of canceled requests or dropped connections. When a client has stored a partial representation, it is desirable to request the remainder of that representation in a subsequent request rather than transfer the entire representation. Likewise, devices with limited local storage might benefit from being able to request only a subset of a larger representation, such as a single page of a very large document, or the dimensions of an embedded image.
</p>

<p>
範囲~要請は，~HTTPの`任意選択^2119な特能であり、この特能を実装していない（または，`~target資源$に対しては~supportしていない）`受信者$が，相互運用能に影響iすることなく，それが通常の `GET$m 要請であったかのように応答できるように設計されている。
部分的な応答は、この特能を実装しないかもしれない~cacheから
全部的な応答に誤解されないように，別個な`状態s~code$で指示される。
◎
Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability. Partial responses are indicated by a distinct status code to not be mistaken for full responses by caches that might not implement the feature.
</p>

<p>
`~server$は、 `Range^h ~headerを無視してもヨイ。
しかしながら，［
`生成元~server$／中継~cache
］は、アリなときは`~byte範囲$を~supportする~OUGHT
— `Range^h は［
部分的に失敗した転送の効率的な回復や,
巨大な`表現$の部分的な検索取得
］を~supportするので。
`~server$は、［
`GET$m 以外の要請~methodに伴って受信された `Range^h ~header
］は無視しなければナラナイ。
◎
A server MAY ignore the Range header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since they support efficient recovery from partially failed transfers and partial retrieval of large representations. A server MUST ignore a Range header field received with a request method other than GET.
</p>

<p>
範囲~要請の仕組みは、拡張-可能な範囲~型も許容するように設計されているが、この仕様は，`~byte範囲$に対する要請のみを定義する。
◎
Although the range request mechanism is designed to allow for extensible range types, this specification only defines requests for byte ranges.
</p>

<p>
`生成元~server$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を無視しなければナラナイ。
`~proxy$は、［
自身が解さない`範囲~単位$を包含する
`Range^h ~header
］を破棄してもヨイ。
◎
An origin server MUST ignore a Range header field that contains a range unit it does not understand. A proxy MAY discard a Range header field that contains a range unit it does not understand.
</p>

<p>
範囲~要請を~supportする`~server$は、［
他と†重合する範囲が 3 個~以上ある, あるいは
昇順による順序で~listされていない 多数の小~範囲の集合
］からなる
`Range^h ~headerを無視-または却下してもヨイ
— いずれも，壊れた~client, あるいは故意による~DoS攻撃（ `12.14$sec ）を指示するので。
`~client$は、処理nや転送が，同じ~dataを包摂する単独の範囲より内来的に非~効率的な，複数の範囲を要請するベキでない。
【†おそらく。 3 箇所~以上で重合する／同じ箇所に重合する範囲が 3 個~以上、などの解釈も考えられなくはないが。】
◎
A server that supports range requests MAY ignore or reject a Range header field that consists of more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since both are indications of either a broken client or a deliberate denial-of-service attack (Section 12.14). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.
</p>

<p>
範囲~要請を~supportする~serverは、`選定された表現$に本体が無いときには（すなわち，その表現~dataの長さは 0 ），
`Range^h ~headerを無視してもヨイ。
◎
A server that supports range requests MAY ignore a Range header field when the selected representation has no body (i.e., the selected representation data is of zero length).
</p>

<p>
複数の範囲を要請する`~client$は、それらの範囲を昇順による順序で~listするベキである（概して，完全な`表現$~内にそれらが受信されることになる順序で）
— 後側の部位tをより早期に要請する必要が特にない限り。
例えば，［
一連の部位tについての内部~目録を伴う，巨大な`表現$
］を処理している~UAは、後側の部位tを最初に要請することも必要になり得る
— 特に，`表現$が逆~順序で格納されている~pageからなっていて，~UAが一度に 1 ~pageの転送を望む場合には。
◎
A client that is requesting multiple ranges SHOULD list those ranges in ascending order (the order in which they would typically be received in a complete representation) unless there is a specific need to request a later part earlier. For example, a user agent processing a large representation with an internal catalog of parts might need to request later parts first, particularly if the representation consists of pages stored in reverse order and the user agent wishes to transfer one page at a time.
</p>

<p>
`Range^h ~headerが評価されるのは、`事前条件~header$を評価した後であり，［
`Range^h ~headerが無いときの結果が `200$st 応答になる
］場合に限られる。
言い換えれば、条件付き `GET$m の結果が `304$st 応答になる場合には，範囲は無視される。
◎
The Range header field is evaluated after evaluating the precondition header fields defined in Section 9.2, and only if the result in absence of the Range header field would be a 200 (OK) response. In other words, Range is ignored when a conditional GET would result in a 304 (Not Modified) response.
</p>

<p>
`If-Range$h ~headerを， `Range^h ~headerを適用する際の`事前条件$として利用できる。
◎
The If-Range header field (Section 9.2.7) can be used as a precondition to applying the Range header field.
</p>

<p>
`~server$は、すべての`事前条件$は真に評価され, かつ
`~target資源$に対する `Range^h ~headerを~supportする場合には：
◎
↓</p>
<ul>
	<li>
指定された範囲（たち）が妥当かつ`満足可能$な場合、次を包含する~payloadを伴う `206$st 応答を送信するベキである
⇒
［
要請された範囲のうち，`満足可能$なもの
］に対応する， 1 個~以上の部分的な表現
◎
If all of the preconditions are true, the server supports the Range header field for the target resource, and the specified range(s) are valid and satisfiable (as defined in Section 7.1.4.2), the server SHOULD send a 206 (Partial Content) response with a payload containing one or more partial representations that correspond to the satisfiable ranges requested.
</li>
	<li>
他の場合、 `416$st 応答を送信するベキである。
◎
If all of the preconditions are true, the server supports the Range header field for the target resource, and the specified range(s) are invalid or unsatisfiable, the server SHOULD send a 416 (Range Not Satisfiable) response.
</li>
</ul>

【！ Errata ID: 4665 Rejected: 2017-02-23】

		</section>
		<section id="request.conneg">
<h3 title="Negotiation">9.4. 折衝</h3>

<div class="p">
<p>
次に挙げる`要請~header$は、［
応答~内容の`~proactive折衝$
］に携わるために，`~UA$により送信され得る
⇒＃
`Accept$h,
`Accept-Charset$h,
`Accept-Encoding$h,
`Accept-Language$h
</p>

<p>
これらの~field内に送信される選好は、次に挙げるものを含め，応答~内のどの内容にも適用される
⇒＃
`~target資源$の`表現$,
~errorや処理~状態sの`表現$,
~protocolの中に出現し得る 他の~text文字列
</p>

◎
The following request header fields can be sent by a user agent to engage in proactive negotiation of the response content, as defined in Section 7.4.1. The preferences sent in these fields apply to any content in the response, including representations of the target resource, representations of error or processing status, and potentially even the miscellaneous text strings that might appear within the protocol.
◎
Table 14
Field Name 	Ref.
Accept 	9.4.1
Accept-Charset 	9.4.2
Accept-Encoding 	9.4.3
Accept-Language 	9.4.4
</div>

<p>
これらの~headerそれぞれに対し、それを包含しない要請は，［
当の~headerが表す折衝の軸に関しては、~UAの選好は無い
］ことを含意する。
要請~内に当の~headerは在って，［
応答~用に可用な表現のうち，その~headerに則って受容-可能と見なせるものは無い
］場合、`生成元~server$は，［
`406$st 応答を送信して，その~headerを尊守する
］ことも［
応答を`内容~折衝の~subject$ではないかのように扱って，その~headerは無視rする
］こともできる。
しかしながら，これ【包含しないこと】は、［
~clientは、その表現を利用-可能になる
］ことを含意するものではない。
◎
For each of these header fields, a request that does not contain it implies that the user agent has no preference on that axis of negotiation. If the header field is present in a request and none of the available representations for the response can be considered acceptable according to it, the origin server can either honor the header field by sending a 406 (Not Acceptable) response or disregard the header field by treating the response as if it is not subject to content negotiation for that request header field. This does not imply, however, that the client will be able to use the representation.
</p>

<p class="note">注記：
これらの~headerの送信は、~serverにとっては，［
~UAからの要請の特性から個々人を識別する
］ことをより容易にする（ `12.12$sec ）。
◎
Note: Sending these header fields makes it easier for a server to identify an individual by virtue of the user agent's request characteristics (Section 12.12).
</p>

<p>
これらの各~headerは、［
指定されていない値を選定するための，~wildcard値
］を定義する（ "`*^c" とされることが多い）。
~wildcardは無い場合、その~field内に明示的に挙げられなかった どの値も，~clientには “受容-可能でない” ものと見なされる。
◎
Each of these header fields defines a wildcard value (often, "*") to select unspecified values. If no wildcard is present, all values not explicitly mentioned in the field are considered "not acceptable" to the client.
</p>

<p class="note">注記：
実施においては、内容~折衝に利用される~wildcardの実用的な価値は，限られている
— 例えば、
“多少を問わず，何か（何らかの特定の値）より `image/*^c を選好します”
と言っても，有用になることは滅多にないので。
~clientは、
`Accept: */*;q=0^c
を送信することにより，［
より選好される形式は可用でない場合には、 `406$st0 応答を送信する
］よう明示的に要請できるが、他の応答も依然として取扱える必要がある
— ~serverには、~clientの選好を無視することも許容されるので。
◎
Note: In practice, using wildcards in content negotiation has limited practical value, because it is seldom useful to say, for example, "I prefer image/* more or less than (some other specific value)". Clients can explicitly request a 406 (Not Acceptable) response if a more preferred format is not available by sending Accept: */*;q=0, but they still need to be able to handle a different response, since the server is allowed to ignore their preference.
</p>

			<section id="field.accept">
<h4>9.4.1. `Accept^h</h4>

<p>
`~UA$は、 `Accept^h ~headerを利用して，応答の`~MIME型$に関する自身の選好を指定できる。
例えば、要請が［
自身が欲する型からなる小さな集合に，特定的に制限される
］ことを指示するときに利用できる
— ~in-line画像に対する要請など。
◎
The "Accept" header field can be used by user agents to specify their preferences regarding response media types. For example, Accept header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
</p>

<p>
~serverにより送信された応答~内の `Accept^h は、［
同じ`資源$に対する後続の要請
］の~payloadには［
どの内容~型が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept provides information about what content types are preferred in the payload of a subsequent request to the same resource.
</p>

<pre class="bnf">
`Accept@p
    = #( `media-range$p [ `accept-params$p ] )

`media-range@p
    = ( "*/*"
        / ( `type$p "/" "*" )
        / ( `type$p "/" `subtype$p )
      ) `parameters$p
`accept-params@p
    = `weight$p *( `accept-ext$p )
`accept-ext@p
    = `OWS$p ";" `OWS$p `token$p [ "=" ( `token$p / `quoted-string$p ) ]
</pre>

<p>
`media-range$p における文字~asterisk "`*^c" は、`~MIME型$をある範囲に~group化するために利用される
⇒＃
"`*/*^c" は，すべての~MIME型を指示する／
"`type^V`/*^c" は， `type^V ~MIME型を成すすべての下位型を指示する。
◎
The asterisk "*" character is used to group media types into ranges, with "*/*" indicating all media types and "type/*" indicating all subtypes of that type.＼
</p>

<p>
`media-range$p には、その範囲の~MIME型に適用-可能な`~MIME型~parameter$も内包できる。
◎
The media-range can include media type parameters that are applicable to that range.
</p>

<div class="p">
<p>
各 `media-range$p には、順に，次のものが後続し得る：
◎
Each media-range might be followed by＼
</p>
<ol>
	<li>
0 個以上の，
適用-可能な`~MIME型~parameter$（ `parameter$p ）（例： "`charset^c" ）
◎
zero or more applicable media type parameters (e.g., charset),＼
</li>
	<li>
0 〜 1 個の，（ `weight$p を成す） `q$c ~parameter
— 相対的な重み（`品質~値$）を指示する
◎
an optional "q" parameter for indicating a relative weight (Section 7.4.4), and then＼
</li>
	<li>
0 個以上の，拡張~parameter（ `accept-ext$p ）
◎
zero or more extension parameters.＼
</li>
</ol>

<p>
`q$c ~parameterは，その前後の~parameter集合の分離子として~~働くので、拡張（ `accept-ext$p ）が在るならば，必要とされる。
◎
The "q" parameter is necessary if any extensions (accept-ext) are present, since it acts as a separator between the two parameter sets.
</p>
</div>

<p class="note">注記：
［
`Accept^h の拡張~parameter（ `accept-params$p ）から`~MIME型~parameter$を分離する，~parameter名 "`q^c"
］の利用は、歴史的な実施に因る。
これにより， `media-range$p においては［
"`q^c" と命名される`~MIME型~parameter$
］は利用できなくなるが、［
~IANA~MIME型~registryには， `q$c ~parameterはまだ無いこと
］および［
`Accept^h における`~MIME型~parameter$の利用eは稀である
］下では、そのような出来事は，まずないと予見されている。
将来の~MIME型においては、"`q^c" と命名されるどのような~parameterも登録しないことが奨励される。
◎
Note: Use of the "q" parameter name to separate media type parameters from Accept extension parameters is due to historical practice. Although this prevents any media type parameter named "q" from being used with a media range, such an event is believed to be unlikely given the lack of any "q" parameters in the IANA media type registry and the rare usage of any media type parameters in Accept. Future media types are discouraged from registering any parameter named "q".
</p>

<div class="example">
<p>
例：
◎
The example
</p>

<pre class="lang-http">
Accept: audio/*; q=0.2, audio/basic
</pre>

<p>
これは、次の様に解釈される
⇒
“ `audio/basic^c を選好しますが、無いなら［
品質を `80%^ ~~落とした上で，最良に可用な `audio^c 型
］があれば，それを送信してください。”
◎
is interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% markdown in quality".
</p>
</div>

<div class="example">
<p>
より込み入った例：
◎
A more elaborate example is
</p>

<pre class="lang-http">
Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
</pre>

<p>
これは、くだけて言えば，次の様に解釈されるであろう
⇒
“`~MIME型$ `text/html^c と `text/x-c^c を等しく選好しますが、無ければ `text/x-dvi^c による表現を, それも無ければ `text/plain^c による表現を送信してください”
◎
Verbally, this would be interpreted as "text/html and text/x-c are the equally preferred media types, but if they do not exist, then send the text/x-dvi representation, and if that does not exist, send the text/plain representation".
</p>
</div>

<p>
`media-range$p は、より特定な［
`media-range$p ／ `~MIME型$
］で上書きできる。
所与の型に，複数の `media-range$p が適用されている場合、最も特定な参照が優先される。
◎
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*, text/plain, text/plain;format=flowed, */*
</pre>

<p>
の優先順は、次になる：
◎
have the following precedence:
</p>
<ol ><li>`text/plain;format=flowed^c
</li><li>`text/plain^c
</li><li>`text/*^c
</li><li>`*/*^c
</li></ol>
</div>

<p>
所与の型に結付けられる`~MIME型$の 品質~係数は、［
型に合致する，最も優先される `media-range$p
］を見出すことにより決定される。
◎
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence that matches the type.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept: text/*;q=0.3, text/plain;q=0.7, text/plain;format=flowed,
        text/plain;format=fixed;q=0.4, */*;q=0.5
</pre>

<p>
に対しては、次に挙げる値が結付けられる：
◎
would cause the following values to be associated:
</p>

<div>
<table><thead><tr><td>~MIME型
<td>`品質~値$
</thead>

<tbody><tr><td>`text/plain;format=flowed^c
<td>`1^c

<tr><td>`text/plain^c
<td>`0.7^c

<tr><td>`text/html^c
<td>`0.3^c

<tr><td>`image/jpeg^c
<td>`0.5^c

<tr><td>`text/plain;format=fixed^c
<td>`0.4^c

<tr><td>`text/html;level=3^c
<td>`0.7^c

</tbody></table>
◎
Table 15
Media Type 	Quality Value
text/plain;format=flowed 	1
text/plain 	0.7
text/html 	0.3
image/jpeg 	0.5
text/plain;format=fixed 	0.4
text/html;level=3 	0.7
</div>
</div>

<p class="note">注記：
~UAは、一定 範囲の~media用に，`品質~値$の既定の集合を供し得る。
しかしながら，~UAが［
他の具現化~agentとヤリトリし得ない閉な~system
］でない限り、この既定の集合は，利用者により環境設定できる~OUGHT。
◎
Note: A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user.
</p>
			</section>
			<section id="field.accept-charset">
<h4>9.4.2. `Accept-Charset^h</h4>

<p>
`~UA$は、 `Accept-Charset^h ~headerを送信して，［
~textな応答~内容~内の`~charset$に対する自身の選好
］を指示できる。
例えば~UAは、より［
包括的な／特殊用途の
］~charsetを解する能力を備えるならば、この~headerにより，その能力を［
それらの~charsetで情報を表現する能力を備えている生成元~server
］へ通達できるようになる。
◎
The "Accept-Charset" header field can be sent by a user agent to indicate its preferences for charsets in textual response content. For example, this field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
</p>

<pre class="bnf">
`Accept-Charset@p
    = #( ( `charset$p / "*" ) [ `weight$p ] )
</pre>
<p>
各~charset名は、`7.1.1.1$sec にて定義される。
`~UA$は、各~charsetに［
利用者の相対的~選好を指示する`品質~値$
］を結付けてもヨイ。
◎
Charset names are defined in Section 7.1.1.1. A user agent MAY associate a quality value with each charset to indicate the user's relative preference for that charset, as defined in Section 7.4.4.＼
</p>

<div class="example">
<p>
例えば：
◎
An example is
</p>

<pre class="lang-http">
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</pre>
</div>

<p>
`Accept-Charset^h ~fieldにおける特別な値 "`*^c" は、在るならば，その~field内に挙げられていない どの`~charset$にも合致する。
◎
The special value "*", if present in the Accept-Charset field, matches every charset that is not mentioned elsewhere in the Accept-Charset field.
</p>

<p class="note">注記：
`Accept-Charset^h は、非推奨にされた。
~UTF-8がほぼアタリマエになったのと、利用者が選好する~charsetの詳細な~listの送信は，［
帯域幅を浪費し,
待時間を増やし,
受動的な指紋収集をずっと容易にする（ `12.12$sec ）
］ので。
ほとんどの一般用~UAは、 `Accept-Charset^h を送信しない
— そうするよう特定的に環境設定されない限り。
◎
Note: Accept-Charset is deprecated because UTF-8 has become nearly ubiquitous and sending a detailed list of user-preferred charsets wastes bandwidth, increases latency, and makes passive fingerprinting far too easy (Section 12.12). Most general-purpose user agents do not send Accept-Charset, unless specifically configured to do so.
</p>

			</section>
			<section id="field.accept-encoding">
<h4>9.4.3. `Accept-Encoding^h</h4>

<p>
`Accept-Encoding^h ~headerは、`内容~符号法$に関する選好を指示するために利用できる。
◎
The "Accept-Encoding" header field can be used to indicate preferences regarding the use of content codings (Section 7.1.2).
</p>

<p>
~UAにより送信された要請~内の `Accept-Encoding^h は、対する応答~内に`内容~符号法$を受容-可能であることを指示する。
◎
When sent by a user agent in a request, Accept-Encoding indicates the content codings acceptable in a response.
</p>

<p>
~serverにより送信された応答~内の `Accept-Encoding^h は、［
同じ`資源$に対する後続の要請
］の~payloadには［
どの`内容~符号法$が選好されるか
］についての情報を供する。
◎
When sent by a server in a response, Accept-Encoding provides information about what content codings are preferred in the payload of a subsequent request to the same resource.
</p>

<p>
"`identity@c"
~tokenは、選好する符号化は無いことを通信するための，
“符号化しない” の同義語として利用される。
◎
An "identity" token is used as a synonym for "no encoding" in order to communicate when no encoding is preferred.
</p>

<pre class="bnf">
`Accept-Encoding@p
    = #( `codings$p [ `weight$p ] )
`codings@p
    = `content-coding$p / "`identity$c" / "*"
</pre>

<p>
各 符号法~値（ `codings$p ）には、［
その符号化法に結付けられる選好~度を表現する，`品質~値$
］も与えられてもヨイ。
`Accept-Encoding^h ~header内の記号~asterisk "`*^c"
は、可用な`内容~符号法$のうち［
その~header内に明示的に~listされていないもの
］すべてに合致する。†a
◎
Each codings value MAY be given an associated quality value representing the preference for that encoding, as defined in Section 7.4.4. The asterisk "*" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept-Encoding: compress, gzip
Accept-Encoding:
Accept-Encoding: *
Accept-Encoding: compress;q=0.5, gzip;q=1.0
Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
</pre>
</div>

				<section id="_request.accept-encoding">
<h5>9.4.3.1. 要請~内の `Accept-Encoding^h</h5>

<p>
`~server$は、次の規則を利用して，［
所与の`表現$用の`内容~符号法$は，`~UA$にとって受容-可能になるかどうか
］を~testする：
◎
A server tests whether a content-coding for a given representation is acceptable using these rules:
</p>
<ol>
	<li>
要請~内に `Accept-Encoding^h ~fieldが無い場合、どの`内容~符号法$も受容-可能であると見なされる。†b
◎
If no Accept-Encoding field is in the request, any content-coding is considered acceptable by the user agent.
</li>
	<li>
<p>
`表現$が`内容~符号法$を持たない場合、
`Accept-Encoding^h の`~field値$が次のいずれかを満足する場合を除き，既定で受容-可能である†c：
◎
If the representation has no content-coding, then it is acceptable by default unless specifically excluded by the Accept-Encoding field stating either＼
</p>
		<ul>
			<li>
"`identity;q=0^c" を伴う。
◎
"identity;q=0" or＼
</li>
			<li>
"`*;q=0^c" を伴う, かつ［
明示的な品質値を伴う `identity^c
］は伴わない。
◎
"*;q=0" without a more specific entry for "identity".
</li>
		</ul>

<p class="trans-note">【
"`identity$c" も内容~符号法の一種（恒等変換）と見なして、表現が内容~符号法を持たないことを，
“表現は内容~符号法 "`identity^c" を持つ”
と解釈すれば、この規則は，次項による規則の特別な場合と見なせる。
】</p>

	</li>
	<li>
`表現$の`内容~符号法$が［
`Accept-Encoding^h の`~field値$内に~listされているもの
］である場合、それに`品質値$ 0 が付随していない限り，受容-可能である。
（`品質値$の定義により，値 0 は “受容-可能でない”ことを意味する）。†d
◎
If the representation's content-coding is one of the content-codings listed in the Accept-Encoding field value, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in Section 7.4.4, a qvalue of 0 means "not acceptable".)
</li>
	<li>
複数の `内容~符号法$が受容-可能である場合、受容-可能な`内容~符号法$のうち［
最も高い`品質値$（ ~NEQ 0 ）を伴うもの
］が選好される。†e
◎
If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.
</li>
</ol>

<div class="p">
<p>
`Accept-Encoding^h ~headerの`~field値$が空である場合、［
`~UA$は、応答~内に どの`内容~符号法$も~~望まない
］ことを含意する。†f
◎
An Accept-Encoding header field with a field value that is empty implies that the user agent does not want any content-coding in response.＼
</p>

<p>
`生成元~server$は、［
要請~内に `Accept-Encoding^h ~headerが在る
］かつ［
応答に可用な どの`表現$も
受容-可能として~listされた`内容~符号法$を持たない
］場合には，`内容~符号法$を伴わない応答を送信するベキである。†g
◎
If an Accept-Encoding header field is present in a request and none of the available representations for the response have a content-coding that is listed as acceptable, the origin server SHOULD send a response without any content-coding.
</p>
</div>

<div class="trans-note">

<p>【
~serverが，選好される内容~符号法を選定する手続きは、以下のように定式化できるであろう：
】</p>

<p>
尚，ここでは、 "`identity^c" も内容~符号法の一種と見なす。
また、以下に現れる “（†…）” は，上のどの規則が反映されているかを表す。
</p>

<p>
まず、（表現に可用かどうかに関わらず，）~UAにとって受容-可能と見なされる内容~符号法の集合 `S^V, および それらの各 品質値を得る：
</p>
<ol>
	<li>
<p>
`V^V ~LET 要請~内に `Accept-Encoding^h ~headerは［
在るならば その`~field値$ ／
無いならば "`*^c" （†b）
］
</p>

<p>
上の規則では、
`V^V の中に同じ内容~符号法（ あるいは "`*^c" ）が複数 現れる場合の挙動が指定されていない
— 以降では、この種の競合は，次に挙げるような何らかの挙動により解消されていると見なす
⇒＃
何らかの基準に従って，それらのうちの一つに絞り、残りは `V^V から除去する／
それらをすべて `V^V から除去する／
構文~errorとして，~headerは無かったかのように扱う
</p>

	</li>
	<li>
`V^V の中の，品質値を伴わない［
内容~符号法, および "`*^c"
］の品質値は、`既定の重み$ 1 と見なす。
</li>
	<li>
`Q^V ~LET ［
`V^V の中に "`*^c" が現れるならば，その品質値 ／
他の場合は 0
］（†c, †d, †f）。
</li>
	<li>
`V^V に~listされていない，どの内容~符号法の品質値も、 `Q^V と見なす（†a）。
</li>
	<li>
`S^V は、既知な すべての内容~符号法（ "`identity$c" も含む）のうち，品質値が 0 でないものからなる集合である（†a, †c, †d）。
</li>
</ol>

<p>
応答に最も選好される内容~符号法は、
</p>
<ul>
	<li>
`T^V ~LET 応答に可用なすべての表現の，内容~符号法の集合††
</li>
	<li>
`R^V ~LET `S^V, `T^V の交差集合
</li>
</ul>

<p>
とするとき：
</p>
<ul>
	<li>
`R^V が空~集合ならば（どれも選好されないが） `identity^c と見なすべきである（†c, †g）（†f）††
</li>
	<li>
他の場合、 `R^V の中で，品質値が最~大なものたち（†e）。
</li>
</ul>

<p>††
通常は， `identity$c は常に `T^V に含まれると考えられるが、明言されていない
— ~serverが強制的に他の内容~符号法のみに限定することも，あるかもしれない。
</p>
</div>

				</section>
				<section id="_response.accept-encoding">
<h5>9.4.3.2. 応答~内の `Accept-Encoding^h</h5>

<p>
`Accept-Encoding^h ~headerが応答~内に在るときは、［
資源は，当の応答に結付けられている要請にて受容する用意があった`内容~符号法$たち
］を指示する。
その`~field値$は、要請におけるそれと同じ仕方で評価される。
◎
When the Accept-Encoding header field is present in a response, it indicates what content codings the resource was willing to accept in the associated request. The field value is evaluated the same way as in a request.
</p>

<p>
この情報は、結付けられている要請に特有であることに注意。
~supportされる符号化法の集合は、同じ~server上の他の資源~用のそれとは異なるかもしれない。
また、時間とともに変化したり，要請の他の側面（`要請~method$など）に依存することもある。
◎
Note that this information is specific to the associated request; the set of supported encodings might be different for other resources on the same server and could change over time or depend on other aspects of the request (such as the request method).
</p>

<p>
所与の`内容~符号法$を~supportしないことに因り，要請に対し失敗した~serverは、
`415$st で応答する~OUGHT
— 加えて，その応答~内に `Accept-Encoding^h ~headerを内包して、当の課題は［
内容~符号法, ~MIME型
］のどちらに関係するか判別するのを，~clientに許容する~OUGHT。
~MIME型に関係する課題との混同を避けるため、
`415^st0 を伴う要請に対し内容~符号法に無関係な事由で失敗した~serverは，
`Accept-Encoding^h ~headerを内包してはナラナイ。
◎
Servers that fail a request due to an unsupported content coding ought to respond with a 415 (Unsupported Media Type) status and include an Accept-Encoding header field in that response, allowing clients to distinguish between issues related to content codings and media types. In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.
</p>

<p>
`Accept-Encoding^h は、［
`~client$による`内容~符号法$の楽観的な利用に対する，
`415$st 状態s~codeを伴う応答
］内で，最も共通的に利用される。
しかしながら，この~headerは、［
`内容~符号法$が~supportされることを~clientに指示して，未来のヤリトリを最適化する
］ためにも利用できる。
例えば，［
要請~payloadは 圧縮~符号法の利用を正当化するほど十分に大きかったが，~clientがそうするのに失敗した
］とき、`資源$は `2xx$st 応答~内に この~headerを内包するかもしれない。
◎
The most common use of Accept-Encoding is in responses with a 415 (Unsupported Media Type) status code, in response to optimistic use of a content coding by clients. However, the header field can also be used to indicate to clients that content codings are supported, to optimize future interactions. For example, a resource might include it in a 2xx (Successful) response when the request payload was big enough to justify use of a compression coding but the client failed do so.
</p>

<p class="note">注記：
ほとんどの~HTTP10応用は、`内容~符号法$に結付けられた`品質値$を［
認識しない／順守しない
］。
これは、`品質値$が働かないかもしれず，［
`x-gzip^c や `x-compress^c
］との~~併用も許可されないことを意味する。
◎
Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues might not work and are not permitted with x-gzip or x-compress.
</p>

				</section>
			</section>
			<section id="field.accept-language">
<h4>9.4.4. `Accept-Language^h</h4>

<p>
`~UA$は、 `Accept-Language^h ~headerを利用して［
応答において選好される自然~言語（`言語~tag$）の集合
］を指示できる。
【！ 言語~tagは、6.1.3にて定義される。】
◎
The "Accept-Language" header field can be used by user agents to indicate the set of natural languages that are preferred in the response. Language tags are defined in Section 7.1.3.
</p>

<pre class="bnf">
`Accept-Language@p
    = #( `language-range$p [ `weight$p ] )
`language-range@p
    = &lt;language-range, `RFC4647/2.1$sec&gt;
</pre>

【！ Errata ID: 4734 Rejected】

<p>
各 `language-range$p には、［
それが指定する言語~範囲に結付けられる，利用者の選好~度を表現する，`品質~値$
］を与えれる。
◎
Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in Section 7.4.4.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Accept-Language: da, en-gb;q=0.8, en;q=0.7
</pre>

<p>
は、次を意味することになる：
“~Danishを選好しますが，英国~英語 や他~種の英語も受容します”。
◎
would mean: "I prefer Danish, but will accept British English and other types of English".
</p>
</div>

<p>
一部の受信者は、特に，`品質~値$が等しくアテガわれた~tagに対し，［
`言語~tag$が~listされる順序を，優先度~順の指示として扱う
］ことに注意（どの~tagの品質値も 1 でなくなる）。
しかしながら、この挙動には依拠できない。
多くの~UAは、一貫性のため, および 相互運用能を最大化するため、各`言語~tag$に一意な`品質~値$をアテガった上で，それらを品質の降順で~listする。
言語~優先度~listについての追加的な論点は、`RFC4647/2.3$sec に。
◎
Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1). However, this behavior cannot be relied upon. For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality. Additional discussion of language priority lists can be found in Section 2.3 of [RFC4647].
</p>

<p>
`RFC4647/3$sec は、数種の照合スキームを，照合~用に定義している。
実装は、自身の要件に最も適切な照合スキームを提供できる。
"Basic Filtering" スキーム（ `RFC4647/3.3.1$sec ）は、以前に［
`RFC2616/14.4$sec にて，~HTTP用として定義された照合スキーム
］と一致する。
◎
For matching, Section 3 of [RFC4647] defines several matching schemes. Implementations can offer the most appropriate matching scheme for their requirements. The "Basic Filtering" scheme ([RFC4647], Section 3.3.1) is identical to the matching scheme that was previously defined for HTTP in Section 14.4 of [RFC2616].
</p>

<p>
毎~要請ごとに［
利用者の，完全な言語上の選好
］を伴う `Accept-Language^h ~headerを送信することは、利用者が期待する~privacyに反し得る（ `12.12$sec ）。
◎
It might be contrary to the privacy expectations of the user to send an Accept-Language header field with the complete linguistic preferences of the user in every request (Section 12.12).
</p>

<p>
言語の理解度は，個々の利用者に大きく依存するので、`~UA$は，［
利用者が，言語上の選好を（~UA自身の環境設定を通して, あるいは 利用者が制御できる~system設定による既定により）制御できる
］ようにする必要がある。
そのような制御を利用者に供さない`~UA$は、
`Accept-Language^h ~headerを送信してはナラナイ。
◎
Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting). A user agent that does not provide such control to the user MUST NOT send an Accept-Language header field.
</p>

<p class="note">注記：
`~UA$は、［
選好の設定~時に，利用者~向けの指導
］を供する~OUGHT
— 利用者が、上に述べた言語~照合の詳細について，~~馴染んでいることは稀なので。
例えば，利用者は、［
"`en-gb^c" を選定すれば、英国~英語が可用でなくても，どの種類の英語~文書であれ~serveされるようになる
］ものと見做すかもしれない。
~UAは、そのような事例では，［
照合の挙動をより良くするために，~listに "`en^c" を追加する
］ことを示唆できる。
◎
Note: User agents ought to provide guidance to users when setting a preference, since users are rarely familiar with the details of language matching as described above. For example, users might assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. A user agent might suggest, in such a case, to add "en" to the list for better matching behavior.
</p>

			</section>
		</section>
		<section id="request.auth">
<h3 title="Authentication Credentials">9.5. 認証用の資格証</h3>

<p>
~HTTPは、~access制御と認証~用の一般的な~frameworkを，拡張-可能な［
［`~challenge$→応答］
`認証~scheme$の集合
］を介して，供する
— それは、`~server$により~client要請を~challengeするために, および
`~client$により認証~情報を供するために利用できる。
◎
HTTP provides a general framework for access control and authentication, via an extensible set of challenge-response authentication schemes, which can be used by a server to challenge a client request and by a client to provide authentication information.
</p>

<p>
認証用の`資格証$を運ばせるために，次の 2 つの~headerが利用される。
利用者~認証~用の様々な~customな仕組みが、この目的に
`Cookie$h ~header `RFC6265$r
を利用することに注意。
◎
Two header fields are used for carrying authentication credentials. Note that various custom mechanisms for user authentication use the Cookie header field for this purpose, as defined in [RFC6265].
</p>

<div>
<ul><li>`Authorization$h
</li><li>`Proxy-Authorization$h
</li></ul>

◎
Table 16
Field Name 	Ref.
Authorization 	9.5.3
Proxy-Authorization 	9.5.4
</div>

			<section id="challenge.and.response">
<h4 title="Challenge and Response">9.5.1. ~challengeと応答</h4>

<div class="p">
<p>
~HTTPは、単純な，［`~challenge$→応答］による認証~frameworkを供する
— それは、次の 2 つの目的に利用できる：
◎
HTTP provides a simple challenge-response authentication framework that can be used＼
</p>
<ul>
	<li>
`~server$が~client要請を~challengeする。
◎
by a server to challenge a client request and＼
</li>
	<li>
`~client$が認証~情報を供する。
◎
by a client to provide authentication information.＼
</li>
</ul>

<p>
各
`~challenge@（ `challenge$p ）
は、順に，次の情報からなる：
◎
＼</p>
<ol>
	<li>
`認証~scheme@
（ `auth-scheme$p ）
を識別する，文字大小無視 `token$p 。
◎
It uses a case-insensitive token as a means to identify the authentication scheme, followed by＼
</li>
	<li>
<p>
その~schemeの下で認証を受けるために必要とされる，追加的な情報
— 次のいずれかをとり得る：
◎
additional information necessary for achieving authentication via that scheme. The latter can be either＼
</p>
		<ul>
			<li>
いくつかの`認証~parameter$からなる，~comma区切りの~list。
◎
a comma-separated list of parameters or＼
</li>
			<li>
base64 符号化された情報を保持できる，単独の［
文字~並び
］（ `token68$p ）。
◎
a single sequence of characters capable of holding base64-encoded information.
</li>
		</ul>
	</li>
</ol>
</div>

<div class="p">
<p>
各
`認証~parameter@
（ `auth-param$p ）は、
"`=^c" で~~区切られた
`名前@var
と
`値@var
の~pairであり：
◎
Authentication parameters are name=value pairs, where＼
</p>
<ul>
	<li>
`名前$var
は、文字大小無視で照合される `token$p である。
◎
the name token is matched case-insensitively, and＼
</li>
	<li>
同じ `名前$var が生じるのは、 `challenge$p ごとに 1 個まででなければナラナイ。
◎
each parameter name MUST only occur once per challenge.
</li>
</ul>
</div>

<pre class="bnf">
`auth-scheme@p
    = `token$p

`auth-param@p
    = `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )

`token68@p
    = 1*( `ALPHA$P / `DIGIT$P / "-" / "." / "_" / "~" / "+" / "/" ) *"="
</pre>

<p>
`token68$p 構文は、予約-済みでない 66 個の~URI文字（ `RFC3986/2.3$sec ）に加えて，空白~以外の少数の文字も許容する
— 次に挙げる符号化法 `RFC4648$r を，~paddingの有無も込みで保持できるようにするための
⇒＃
`base64$,
`base64url$ （~URLや~filenameに用いても安全な~alphabet）,
`base32$,
`base16$ （ 16 進）
◎
The token68 syntax allows the 66 unreserved URI characters ([RFC3986]), plus a few others, so that it can hold a base64, base64url (URL and filename safe alphabet), base32, or base16 (hex) encoding, with or without padding, but excluding whitespace ([RFC4648]).
</p>

<p>
`401$st 応答~messageは、`~UA$への権限付与を~challengeするために，`生成元~server$により利用され、［
要請された資源に適用-可能な， 1 個~以上の `challenge$p
］を包含する， `WWW-Authenticate$h ~headerを含む。
◎
A 401 (Unauthorized) response message is used by an origin server to challenge the authorization of a user agent, including a WWW-Authenticate header field containing at least one challenge applicable to the requested resource.
</p>

<p>
`407$st 応答~messageは、`~client$への権限付与を~challengeするために，`~proxy$により利用され、［
要請された資源~用に~proxyに適用-可能な， 1 個~以上の `challenge$p
］を包含する， `Proxy-Authenticate$h ~headerを含む。
◎
A 407 (Proxy Authentication Required) response message is used by a proxy to challenge the authorization of a client, including a Proxy-Authenticate header field containing at least one challenge applicable to the proxy for the requested resource.
</p>

<pre class="bnf">
`challenge@p
    = `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<p class="note">注記：
多くの`~client$は、［
未知な~schemeを包含するような `challenge$p
］の構文解析-に失敗する。
この問題~用の対処法は、きちんと~supportされている~schemeたち（ "`basic^c" など）を，~~最初の方に挙げることである。
◎
Note: Many clients fail to parse a challenge that contains an unknown scheme. A workaround for this problem is to list well-supported schemes (such as "basic") first.
</p>

<p>
`~UA$は
— 必要とされてはいないが通例的には， `401$st を受信した後に —
［
要請に `Authorization$h ~headerを内包する
］ことにより，［
自身を`生成元~server$から認証してもらう
］ことができる。
◎
A user agent that wishes to authenticate itself with an origin server — usually, but not necessarily, after receiving a 401 (Unauthorized) — can do so by including an Authorization header field with the request.
</p>

<p>
`~client$は
— 必要とされてはいないが通例的には， `407$st を受信した後に —
［
要請に `Proxy-Authorization$h ~headerを内包する
］ことにより，［
自身を`~proxy$から認証してもらう
］ことができる。
◎
A client that wishes to authenticate itself with a proxy — usually, but not necessarily, after receiving a 407 (Proxy Authentication Required) — can do so by including a Proxy-Authorization header field with the request.
</p>

<div class="p">
<p>
`Authorization$h, `Proxy-Authorization$h
両`~field値$とも，要請-中にある`資源$が属する `realm$c 用の［
`~client$の
`資格証@（ `credentials$p ）
］を包含する
— 応答~内に（場合によっては過去のある時点で）受信された `challenge$p に基づくような。
`~UA$は、それらの値を，次のようにして作成する~OUGHT：
◎
Both the Authorization field value and the Proxy-Authorization field value contain the client's credentials for the realm of the resource being requested, based upon a challenge received in a response (possibly at some point in the past). When creating their values, the user agent ought to do so by＼
</p>
<ul>
	<li>
受信した `challenge$p たちのうち，［
自身が解する かつ最も~secureと見なすような， `auth-scheme$p
］を伴うものを選定する。
◎
selecting the challenge with what it considers to be the most secure auth-scheme that it understands,＼
</li>
	<li>
利用者から適宜 `資格証$を得する。
◎
obtaining credentials from the user as appropriate.＼
</li>
</ul>

<p>
`資格証$を~header`~field値$の中に伝送することは、下層~接続の機密性に関する，有意な~securityの考慮点も含意する
— `12.15.1$sec を見よ。
◎
Transmission of credentials within header field values implies significant security considerations regarding the confidentiality of the underlying connection, as described in Section 12.15.1.
</p>
</div>

<pre class="bnf">
`credentials@p
    = `auth-scheme$p [ 1*`SP$P ( `token68$p / #`auth-param$p ) ]
</pre>

<div class="p">
<p>
`生成元~server$は、被保護~資源~用の`資格証$が［
省略されている ／
無効である（例： 不良~password） ／
部分的である（例：`認証~scheme$が複数~回の往来を要求する）
］ような要請の受領~時には，次のような `401$st 応答を送信するベキである：
◎
Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that＼
</p>
<ul>
	<li>
`WWW-Authenticate$h ~headerを包含する。
◎
contains a WWW-Authenticate header field＼
</li>
	<li>
この~headerには、 1 個~以上の［
要請された資源に適用-可能な `challenge$p
］を伴わせる（場合によっては 新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the requested resource.
</li>
</ul>
</div>

<div class="p">
<p>
同様に，認証を要求する`~proxy$は、~proxy`資格証$が［
省略されている／無効である／部分的である
］ような要請の受領~時には，次のような `407$st 応答を`生成する$ベキである：
◎
Likewise, upon receipt of a request that omits proxy credentials or contains invalid or partial proxy credentials, a proxy that requires authentication SHOULD generate a 407 (Proxy Authentication Required) response that＼
</p>
<ul>
	<li>
`Proxy-Authenticate$h ~headerを包含する。
◎
contains a Proxy-Authenticate header field＼
</li>
	<li>
この~headerには、 1 個~以上の［
その`~proxy$に適用-可能な `challenge$p
］を伴わせる（場合によっては 新たなそれも含ませる）。
◎
with at least one (possibly new) challenge applicable to the proxy.
</li>
</ul>
</div>

<p>
`~server$は、妥当であるが ~accessを~~獲得するには必要十分でない`資格証$を受信したときは，状態s~code `403$st で応答する~OUGHT。
◎
A server that receives valid credentials that are not adequate to gain access ought to respond with the 403 (Forbidden) status code (Section 10.5.4).
</p>

<p>
~HTTPは、この単純な［`~challenge$→応答］~frameworkによる応用を，~access認証のみに制約しない。
追加的な仕組みも利用できる
— ［
~transport~levelの認証として, あるいは
~messageによる~encapsulationを介して
］, および［
認証~情報を指定する追加的な~headerを伴わせる
］ような。
しかしながら、そのような追加的な仕組みは，この仕様では定義しない。
◎
HTTP does not restrict applications to this simple challenge-response framework for access authentication. Additional mechanisms can be used, such as authentication at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, such additional mechanisms are not defined by this specification.
</p>

			</section>
			<section id="protection.space">
<h4 title="Protection Space (Realm)">9.5.2. 保護~空間（ `realm^c ）</h4>

<p>
`名前$var
`realm@c
の`認証~parameter$は、`認証~scheme$における保護の視野
— `保護~空間$ —
を指示する利用が望まれるときのために，予約されている。
◎
The "realm" authentication parameter is reserved for use by authentication schemes that wish to indicate a scope of protection.
</p>

<p>
`保護~空間@
は、~accessされている`~server$の
`正準的~root~URI@
— `~target~URI$の［
`scheme$p, `authority$p
］成分の組 —
と, この `realm$c 値（もし在るなら）との組合nにより定義される。
`realm$c により、`~server$上の被保護~資源たちを，いくつかの`保護~空間$に区分できるようになる
— それぞれが自前の［
`認証~scheme$や, 権限付与~database
］を伴うような。
`realm$c 値は、一般に，`生成元~server$により アテガわれる文字列であり、`認証~scheme$に特有な追加的な意味論を持ち得る。
応答は、［
同じ `auth-scheme$p を伴いつつ, 異なる `realm$c 値を伴う
］ような，複数の `challenge$p を持ち得ることに注意。
◎
A protection space is defined by the canonical root URI (the scheme and authority components of the target URI; see Section 6.1) of the server being accessed, in combination with the realm value if present. These realms allow the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme and/or authorization database. The realm value is a string, generally assigned by the origin server, that can have additional semantics specific to the authentication scheme. Note that a response can have multiple challenges with the same auth-scheme but with different realms.
</p>

<p>
`保護~空間$は、`資格証$を自動的に適用できるような~domainを決定する。
先立つ要請に権限付与されていた場合、`~UA$は、その`保護~空間$に属する他のすべての要請に対し，同じ`資格証$を ある期間までは再利用してもヨイ
— その期間は、［
`認証~scheme$, `認証~parameter$たち, 利用者の選好（環境設定できるような放置 時間制限など）
］のうち いくつかから決定される。
`認証~scheme$により特定的に許容されない限り、単独の`保護~空間$は，その`~server$の視野から外へは拡張できない。
◎
The protection space determines the domain over which credentials can be automatically applied. If a prior request has been authorized, the user agent MAY reuse the same credentials for all other requests within that protection space for a period of time determined by the authentication scheme, parameters, and/or user preferences (such as a configurable inactivity timeout). Unless specifically allowed by the authentication scheme, a single protection space cannot extend outside the scope of its server.
</p>

<p>
歴史的な理由から、`送信者$は， `quoted-string$p 構文のみを`生成し$なければナラナイ。
~~長年にわたり両 表記法を受容してきた既存の`~client$との相互運用能を最大にするため、
`受信者$は， `token$p, `quoted-string$p 両~構文の~supportを要し得る。
◎
For historical reasons, a sender MUST only generate the quoted-string syntax. Recipients might have to support both token and quoted-string syntax for maximum interoperability with existing clients that have been accepting both notations for a long time.
</p>

			</section>
			<section id="field.authorization">
<h4>9.5.3. `Authorization^h</h4>

<p>
`Authorization^h ~headerにより、`~UA$は，自身を`生成元~server$から認証してもらうことが可能になる
— 必要とされてはいないが通例的には， `401$st 応答を受信した後に。
その値は、［
要請-中にある資源の `realm$c 用の，`~UA$の認証~情報
］を包含する`資格証$からなる。
◎
The "Authorization" header field allows a user agent to authenticate itself with an origin server — usually, but not necessarily, after receiving a 401 (Unauthorized) response. Its value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
</p>

<pre class="bnf">
`Authorization@p
    = `credentials$p
</pre>

<p>
要請が認証され, かつ `realm$c も指定されている場合、同じ`資格証$は，［
この `realm$c に属する 他のすべての要請に対しても，妥当である
］と~~見做されるようになる（`認証~scheme$自体が，他のもの
— `challenge$p 値に則って, あるいは同期された`時計$を利用して様々になるような，`資格証$など —
を要求しない限りにおいて）。
◎
If a request is authenticated and a realm specified, the same credentials are presumed to be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).
</p>

<p>
要請を回送している`~proxy$は、その要請~内のどの `Authorization^h ~headerも，改変してはナラナイ。
~HTTP~cacheによる `Authorization^h ~headerの取扱い［
の詳細／に課される要件
］については、
`Caching/3.3$sec
を見よ。
◎
A proxy forwarding a request MUST NOT modify any Authorization fields in that request. See Section 3.3 of [Caching] for details of and requirements pertaining to handling of the Authorization field by HTTP caches.
</p>

			</section>
			<section id="field.proxy-authorization">
<h4>9.5.4. `Proxy-Authorization^h</h4>

<p>
`Proxy-Authorization^h ~headerは、
`~client$が，認証を要求する`~proxy$に対し，自身を（または その利用者を）識別してもらうことを可能にする。
その値は、［［
当の~proxyや, 要請-中にある資源の `realm$c
］用の，`~client$の認証~情報
］を包含する，`資格証$からなる。
◎
The "Proxy-Authorization" header field allows the client to identify itself (or its user) to a proxy that requires authentication. Its value consists of credentials containing the authentication information of the client for the proxy and/or realm of the resource being requested.
</p>

<pre class="bnf">
`Proxy-Authorization@p
    = `credentials$p
</pre>

<p>
`Authorization$h と違って，
`Proxy-Authorization^h ~headerは、［
`Proxy-Authenticate$h ~headerを利用して認証を請求した，`内方$にある次の`~proxy$
］に限り適用される。
`連鎖$にて複数の~proxyが利用されているときは、
`Proxy-Authorization^h ~headerは，［
`資格証$を受信することを期待していた最初の内方~proxy
］により消費される。
複数の~proxyが，所与の要請を協力的に認証する仕組みを成している場合、
`~proxy$は，~client要請からの`資格証$を 次の~proxyへ中継してもヨイ。
◎
Unlike Authorization, the Proxy-Authorization header field applies only to the next inbound proxy that demanded authentication using the Proxy-Authenticate field. When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first inbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.
</p>

			</section>
			<section id="auth.scheme.extensibility">
<h4 title="Authentication Scheme Extensibility">9.5.5. 認証~schemeの拡張能</h4>

<p>
一般的な~frameworkは別として、この文書は，どの認証~schemeも指定しない。
［
新たな／既存の
］認証~schemeは、独立に指定された上で，
`~HTTP認証~scheme~registry$cite
の中に登録される~OUGHT。
例えば，認証~scheme［
"`basic^c" ／ "`digest^c"
］は、［
`RFC7617$r ／ `RFC7616$r
］にて定義される。
◎
Aside from the general framework, this document does not specify any authentication schemes. New and existing authentication schemes are specified independently and ought to be registered within the "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry". For example, the "basic" and "digest" authentication schemes are defined by RFC 7617 and RFC 7616, respectively.
</p>

				<section id="auth.scheme.registry">
<h5 title="Authentication Scheme Registry">9.5.5.1. 認証~scheme~registry</h5>

<p>
［
`~challenge$および`資格証$における，`認証~scheme$
］用の名前空間は、
`~HTTP認証~scheme~registry$cite
にて保守され, 定義される。
◎
The "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry" defines the namespace for the authentication schemes in challenges and credentials. It is maintained at &lt;https://www.iana.org/assignments/http-authschemes&gt;.
</p>

<p>
登録には、次に挙げる~fieldを含めなければナラナイ
⇒＃
`認証~scheme$名,
仕様~textへの~pointer,
注記（省略可）
◎
Registrations MUST include the following fields:
• Authentication Scheme Name
• Pointer to specification text
• Notes (optional)
</p>

<p>
この名前空間に追加される値は、
`IETF による考査$を要する。
◎
Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

				</section>
				<section id="considerations.for.new.auth.schemes">
<h5 title="Considerations for New Authentication Schemes">9.5.5.2. 新たな認証~schemeに対する考慮点</h5>

<p>
~HTTP認証~frameworkは、次の側面において，新たな`認証~scheme$がどう働得るかについて拘束を課す：
◎
There are certain aspects of the HTTP Authentication framework that put constraints on how new authentication schemes can work:
</p>
<ul>
	<li>
~HTTP認証は、`~stateless$であることを~~前提にする：
要請を認証するために必要とされる，すべての情報が、その要請~内に供されなければナラナイ
— `~server$が それに先立つ要請を記憶することに依存するのではなく。
下層~接続に［
基づく／束縛される
］認証は、この仕様の視野から外れる
— それは、［
その接続が、認証-済み利用者~以外のどの主体からも利用され得ない
］ことを確保する手順が踏まれない限り，内来的に欠陥があるものとされる。
◎
HTTP authentication is presumed to be stateless: all of the information necessary to authenticate a request MUST be provided in the request, rather than be dependent on the server remembering prior requests. Authentication based on, or bound to, the underlying connection is outside the scope of this specification and inherently flawed unless steps are taken to ensure that the connection cannot be used by any party other than the authenticated user (see Section 2.2).
</li>
	<li>
`名前$var `realm$c の`認証~parameter$は、`保護~空間$を定義するものとして予約される。
新たな~schemeは、 "`realm^c" をその定義と非~互換な仕方で利用してはナラナイ。
◎
The authentication parameter "realm" is reserved for defining protection spaces as described in Section 9.5.2. New schemes MUST NOT use it in a way incompatible with that definition.
</li>
	<li>
既存の`認証~scheme$との互換性を得るために， `token68$p 表記法が導入された
— それは、［
`challenge$p／`credentials$p
］ごとに 1 個しか利用できない。
したがって，新たな~schemeは、代わりに `auth-param$p 構文を利用する~OUGHT
— さもなければ，将来の拡張が不可能になるので。
◎
The "token68" notation was introduced for compatibility with existing authentication schemes and can only be used once per challenge or credential. Thus, new schemes ought to use the auth-param syntax instead, because otherwise future extensions will be impossible.
</li>
	<li>
<p>
［
`challenge$p／`credentials$p
］の構文解析は，この仕様により定義され、新たな`認証~scheme$は，それを改変できない。
`auth-param$p 構文が利用されるときは、すべての~parameterが
`token$p, `quoted-string$p 両~構文を~supportする~OUGHT。
また，構文上の拘束は、構文解析-後の（すなわち， `quoted-string$p を処理した後の）`~field値$に対し，定義される~OUGHT。
これは、`受信者$が，［
すべての`認証~scheme$に適用される，汎用 構文解析器
］を利用できるようにするために必要とされる。
◎
The parsing of challenges and credentials is defined by this specification and cannot be modified by new authentication schemes. When the auth-param syntax is used, all parameters ought to support both token and quoted-string syntax, and syntactical constraints ought to be defined on the field value after parsing (i.e., quoted-string processing). This is necessary so that recipients can use a generic parser that applies to all authentication schemes.
</p>

<p class="note">注記：
"`realm^c" ~parameter用の値の構文が `quoted-string$p に制約される事は、悪い設計の選択であった
— 新たな~parameterに対しては繰返されない。
◎
Note: The fact that the value syntax for the "realm" parameter is restricted to quoted-string was a bad design choice not to be repeated for new parameters.
</p>
	</li>
	<li>
新たな~schemeの定義は、未知な拡張~parameterの扱いを定義する~OUGHT。
一般に、
“無視しなければならない”
とする規則が
“解さなければならない”
とするよりも選好される
— さもなければ、旧来の`受信者$が在る下で，新たな~parameterを導入することが難しくなるので。
更には、新たな~parameterを定義するための施策を述べる方が良い（ “〜の仕様を更新せよ” や, “この~registryを利用せよ” など）。
◎
Definitions of new schemes ought to define the treatment of unknown extension parameters. In general, a "must-ignore" rule is preferable to a "must-understand" rule, because otherwise it will be hard to introduce new parameters in the presence of legacy recipients. Furthermore, it's good to describe the policy for defining new parameters (such as "update the specification" or "use this registry").
</li>
	<li>
`認証~scheme$は、［
`生成元~server$による認証（すなわち， `WWW-Authenticate$h を利用）／
`~proxy$による認証（すなわち， `Proxy-Authenticate$h を利用）
］に利用できるかどうかを文書~化する必要がある。
◎
Authentication schemes need to document whether they are usable in origin-server authentication (i.e., using WWW-Authenticate), and/or proxy authentication (i.e., using Proxy-Authenticate).
</li>
	<li>
<p>
`Authorization$h ~header内に運ばれる`資格証$は，`~UA$に特有なので、それが出現する要請の視野の下で，~HTTP~cacheに対する `private$sdir `Cache-Control$h 応答~指令と同じ効果を持つ。
◎
The credentials carried in an Authorization header field are specific to the user agent and, therefore, have the same effect on HTTP caches as the "private" Cache-Control response directive (Section 5.2.2.7 of [Caching]), within the scope of the request in which they appear.
</p>
<p>
したがって，新たな`認証~scheme$は、`資格証$を `Authorization$h ~header内に運ばせないことを選ぶ場合（例えば，新たに定義される~headerを利用して）、~cachingを明示的に不許可にする必要がある
— `Cache-Control$h 応答~指令（例： `private$sdir ）の利用を義務化することにより。
◎
Therefore, new authentication schemes that choose not to carry credentials in the Authorization header field (e.g., using a newly defined header field) will need to explicitly disallow caching, by mandating the use of Cache-Control response directives (e.g., "private").
</p>
	</li>
	<li>
［
`Authentication-Info$h, `Proxy-Authentication-Info$h
］その他の，認証に関係する応答~headerを利用している~schemeは、関係する~securityの考慮点を考慮して文書~化する必要がある（ `12.15.4$sec を見よ）。
◎
Schemes using Authentication-Info, Proxy-Authentication-Info, or any other authentication related response header field need to consider and document the related security considerations (see Section 12.15.4).
</li>
</ul>

				</section>
			</section>
		</section>
		<section id="request.context">
<h3 title="Request Context">9.6. 要請~文脈</h3>

<p>
次に挙げる`要請~header$は、［
利用者, ~UA, 要請の背後にある資源
］についての情報も含め，要請の文脈について 追加的な情報を供する
⇒＃
`From$h,
`Referer$h,
`User-Agent$h
◎
The following request header fields provide additional information about the request context, including information about the user, user agent, and resource behind the request.
◎
Table 17
Field Name 	Ref.
From 	9.6.1
Referer 	9.6.2
User-Agent 	9.6.3
</p>

			<section id="field.from">
<h4>9.6.1. `From^h</h4>

<p>
`From^h ~headerは、［
要請を~~発行する~UAを制御するヒト利用者
］の~Internet~email~addressを包含する。
~addressは、~machineから利用-可能な，
`RFC5322/3.4$sec にて定義される `mailbox^p になる~OUGHT：
◎
The "From" header field contains an Internet email address for a human user who controls the requesting user agent. The address ought to be machine-usable, as defined by "mailbox" in Section 3.4 of [RFC5322]:
</p>

<pre class="bnf">
`From@p
    = `mailbox$p

`mailbox@p
    = &lt;mailbox, `RFC5322/3.4$sec&gt;
</pre>

<div class="example">
<p>
例：
◎
An example is:
</p>

<pre class="lang-http">
From: webmaster@example.org
</pre>
</div>

<p>
`From^h ~headerが非~robotic~UAにより送信されることは稀である。
`~UA$は、利用者により明示的に環境設定されない限り，
`From^h ~headerを送信するベキでない
— ［
利用者の~privacyへの関心や, それらの~siteの~security施策
］と競合するであろうから。
◎
The From header field is rarely sent by non-robotic user agents. A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.
</p>

<p>
~robotic~UAは、自身が［
過度の／求まれていない／妥当でない
］要請を送信しているときなど，［
~server上に問題が生じた場合に，~robotを稼働させている~~責務者と連絡をとれる
］ような，［
妥当な `From^h ~header
］を送信するベキである。
◎
A robotic user agent SHOULD send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.
</p>

<p>
`~server$は、 `From^h ~headerを［
~access制御や認証
］用に利用するベキでない
— ほとんどの受信者は、この~headerの値を公な情報であると見做すことになるので。
◎
A server SHOULD NOT use the From header field for access control or authentication, since most recipients will assume that the field value is public information.
</p>

			</section>
			<section id="field.referer">
<h4>9.6.2. `Referer^h</h4>

<p>
`Referer^h ~headerにより、`~UA$は［
`~target~URI$を得した所の資源
］用に，`~URI$参照を指定できるようになる（すなわち， “referrer（~~参照元）”
— `~field名$の綴りは誤っているが）。
`~UA$は、 `Referer^h `~field値$を`生成する$際に，~URI参照に［
`fragment$p ／ `userinfo$p
］成分 `RFC3986$r を内包してはナラナイ。
◎
The "Referer" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the "referrer", though the field name is misspelled). A user agent MUST NOT include the fragment and userinfo components of the URI reference [RFC3986], if any, when generating the Referer field value.
</p>

<pre class="bnf">
`Referer@p
    = `absolute-URI$p / `partial-URI$p
</pre>

<p>
`~field値$は、`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、参照先の~URIは，`~target~URI$に相対的になる（ `RFC3986/5$sec ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 2.4), the referenced URI is relative to the target URI ([RFC3986], Section 5).
</p>

<p>
`Referer^h ~headerにより、`~server$は，［
単純な解析,
~log取り,
最適化された~caching,
等々
］のために，他の資源へ戻れる~linkを生成できるようになる。
それはまた、保守~用に［
廃用にされた／誤入力された
］~linkを見出すことも可能にする。
一部の~serverは、 `Referer^h ~headerを，［
他~siteからの~link（いわゆる “`deep linking^en” ）を否認したり,
CSRF （ cross-site request forgery ）を制約する
］ための手段として利用するが、すべての要請がそれを包含するわけではない。
◎
The Referer header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc. It also allows obsolete or mistyped links to be found for maintenance. Some servers use the Referer header field as a means of denying links from other sites (so-called "deep linking") or restricting cross-site request forgery (CSRF), but not all requests contain it.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Referer: http://www.example.org/hypertext/Overview.html
</pre>
</div>

<p>
`~target~URI$が［
~URIを持たない源から得されたもの
］である場合（例：利用者~keyboardからの入力, 利用者の~bookmark）、
`Referer^h ~fieldを除外するか, または その値に "`about:blank^c" を送信しなければナラナイ。
◎
If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent MUST either exclude the Referer field or send it with a value of "about:blank".
</p>

<p>
`Referer^h ~fieldが［
要請の文脈や, 利用者の閲覧~履歴についての情報
］を露呈し得る場合、それは，［
参照元~資源の識別子が（~account名などの）個人-情報を露呈したり
］, あるいは［
資源が機密的と想定される（~firewallの背後や, ~secure化された~serviceの内部など）
］場合に，~privacy上の懸念になる。
ほとんどの一般用~UAは、［
参照元~資源が局所的な［
"file" ／ "data"
］`~URI$である
］ときには， `Referer^h ~headerを送信しない。
`~UA$は、［
参照元~pageが~secure~protocolで受信されていた
］場合には，~secure化されてない~HTTP要請~内に
`Referer^h ~headerを送信してはナラナイ。
追加的な~securityの考慮点については、 `12.9$sec を見よ。
◎
The Referer field has the potential to reveal information about the request context or browsing history of the user, which is a privacy concern if the referring resource's identifier reveals personal information (such as an account name) or a resource that is supposed to be confidential (such as behind a firewall or internal to a secured service). Most general-purpose user agents do not send the Referer header field when the referring resource is a local "file" or "data" URI. A user agent MUST NOT send a Referer header field in an unsecured HTTP request if the referring page was received with a secure protocol. See Section 12.9 for additional security considerations.
</p>

<p>
一部の`中継者$は，［
外向けの要請から `Referer^h ~headerを無差別に除去する
］ことが、既知である。
これは、 CSRF 攻撃に対する保護に干渉するような，~~望ましくない副作用を及ぼす
— それは、利用者にとり，はるかに有害になる。
`Referer^h 内への情報~開示を制限したいと望む［
`中継者$／`~UA$拡張
］は、それらの変更を［
内部~domain名を `pseudonym$p に置換したり，
`query$p や`path$p 成分を切落す
］などの，特定の編集-に制約する~OUGHT。
`中継者$は、［
~field値が，`~target~URI$と同じ `scheme$p ＆ `host$p を共有する
］ときは， `Referer^h ~headerを改変したり削除するベキでない。
◎
Some intermediaries have been known to indiscriminately remove Referer header fields from outgoing requests. This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users. Intermediaries and user agent extensions that wish to limit information disclosure in Referer ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the query and/or path components. An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the target URI.
</p>

			</section>
			<section id="field.user-agent">
<h4>9.6.3. `User-Agent^h</h4>

<div class="p">
<p>
`User-Agent^h ~headerは、［
要請を出生した`~UA$
］についての情報を包含する
— `~server$は、次のために，これを利用することが多い：
◎
The "User-Agent" header field contains information about the user agent originating the request, which is often used by servers＼
</p>
<ul>
	<li>
報告された相互運用能の問題を絞り込むための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~UA制限を避けるために，［
対処する／応答を誂える
］。
◎
to work around or tailor responses to avoid particular user agent limitations, and＼
</li>
	<li>
利用されている~browserや OS に関する解析。
◎
for analytics regarding browser or operating system use.＼
</li>
</ul>

<p>
`~UA$は、特定的に環境設定されていない限り，各~要請~内に `User-Agent^h ~fieldを送信するベキである。
◎
A user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so.
</p>
</div>

<pre class="bnf">
`User-Agent@p
    = `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`User-Agent^h `~field値$は、
1 個~以上の
`製品~識別子@
（ `product$p ）からなり，各~製品~識別子には 0 個以上の~comment（
`comment$p
）が後続する。
それらは組で，［
~UA~software, および その有意な下位製品
］を識別する。
慣行により，製品~識別子は、~UA~softwareを識別するために［
それらの有意度の降順
］で~listされる。
各 `製品~識別子$は、［
名前, 省略可能な~version（ `product-version$p ）
］からなる。
◎
The User-Agent field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.4.1.3), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.
</p>

<pre class="bnf">
`product@p
    = `token$p ["/" `product-version$p]
`product-version@p
    = `token$p
</pre>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
`生成する$`製品~識別子$を［
製品を識別するために必要とされるもの
］に制限するベキである。
◎
A sender SHOULD limit generated product identifiers to what is necessary to identify the product;＼
</li>
	<li>
`製品~識別子$の中に［
広告-用その他の本質的でない情報
］を`生成し$てはナラナイ。
◎
a sender MUST NOT generate advertising or other nonessential information within the product identifier.＼
</li>
	<li>
`product-version$p 内に，~version識別子でない情報を`生成する$ベキでない（すなわち，［
同じ製品~名の 一連の~version
］は、［
製品~識別子の `product-version$p 部位
］においてのみ相違する~OUGHT）。
◎
A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</pre>
</div>

<div class="p">
<p>
`~UA$は：
◎
A user agent＼
</p>
<ul>
	<li>
不必要に木目細かな詳細を包含する `User-Agent^h ~fieldを，`生成する$ベキでない。
◎
SHOULD NOT generate a User-Agent field containing needlessly fine-grained detail and＼
</li>
	<li>
第三者主体による下位製品の追加を，制限するベキである。
◎
SHOULD limit the addition of subproducts by third parties.＼
</li>
</ul>

<p>
不必要に長く詳細な `User-Agent^h `~field値$は、要請の待時間を増やし，利用者の望みに反して, 識別される~risk（ “`指紋収集$” ）を高める。
◎
Overly long and detailed User-Agent field values increase request latency and the risk of a user being identified against their wishes ("fingerprinting").
</p>
</div>

<p>
同様に，実装には、［
他の実装の製品~tokenを，互換性を宣言するために利用する
］ことは奨励されない
— そうすると，この~fieldの目的を~~無為にするので。
別の~UAとして仮装する~UAに対しては、`受信者$は，［
利用者が意図的に，その別の~UA用に誂えられた応答を見たいと欲している
］ものと見做せる
— その応答が、実際に利用されている~UAで働くかどうかに関わらず。
◎
Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field. If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used.
</p>

			</section>
		</section>
	</section>
</main></div>
