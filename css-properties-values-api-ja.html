<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Properties and Values API Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
.js, .js-value, .js-slot {
	color: #006633;
}
.js-value {
	font-family: sans-serif0, sans-serif;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};

	PAGE_DATA.words_table1 += PAGE_DATA.unicode_map
	.replace( /\n(\w+):(.+)/g, function(t0, t1, t2){
		return(
`\nU${t1}:<span class="code-point">U+${t1}</span> <small class="cp-name">${t2}</small> (<code>&#x${t1};</code>)`
		);
	});
	delete PAGE_DATA.unicode_map

	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'issue':
	return(
`<a href="https://github.com/w3c/css-houdini-drafts/issues/${key}">issue#${key}</a>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>


<script type="text/plain" id="_source_data">

●●options
spec_title:CSS Properties and Values API Level 1
spec_date:2019-04-05
trans_update:2019-04-07
source_checked:180703
original_url:https://drafts.css-houdini.org/css-properties-values-api/
	page_state_key:CSS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2019,use
trans_1st_pub:2018-05-12


●●class_map
p:property
v:value
u:unit
f:func
t:type
u:unit
at:at-rule
css:css
e:element
a:attr
at:at-rule
E:error
sl:js-slot
U:code-point

●●tag_map
p:code
f:code
u:code
v:code
t:var
at:code
I:code
m:code
E:code
e:code
u:code
a:code
css:code
c:code
sl:span
U:span
i:i

●●original_id_map

●●link_map
	●IDL
E.InvalidModificationError:~WEBIDL#invalidmodificationerror
E.SyntaxError:~WEBIDL#syntaxerror

DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean

I.CSS:~CSSOM1#namespacedef-css
I.Document:~DOM4#document
I.PropertyDescriptor:#dictdef-propertydescriptor

sl.registeredPropertySet:#dom-window-registeredpropertyset-slot

m.inherits:#dom-propertydescriptor-inherits
m.initialValue:#dom-propertydescriptor-initialvalue
m.name:#dom-propertydescriptor-name
m.registerProperty:#dom-css-registerproperty
m.supports:~CSSCOND#dom-css-supports
m.supports:~CSSCOND#dom-css-supports-conditiontext
m.syntax:#dom-propertydescriptor-syntax

	#dom-css-registerproperty-descriptor-descriptor
	#dom-css-unregisterproperty-name-name

	●CSS
at.supports:~CSSCOND#at-ruledef-supports

p.color:~CSSCOLOR#propdef-color
p.font-size:~CSSFONTS#propdef-font-size
p.line-height:~CSS2VISUDET#propdef-line-height

u.em:~CSSVAL#em
u.ex:~CSSVAL#ex
u.cap:~CSSVAL#cap
u.ch:~CSSVAL#ch
u.ic:~CSSVAL#ic
u.lh:~CSSVAL#lh
u.rem:~CSSVAL#rem
u.rlh:~CSSVAL#rlh

t.angle:~CSSVAL#angle-value
t.calc():~CSSVAL#funcdef-calc
t.color:~CSSCOLOR#typedef-color
	t.color:~CSSWGcss-color-3/#valuea-def-color
t.ident:~CSSVAL#typedef-ident
t.custom-ident:~CSSVAL#identifier-value
t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.dimension-token:~CSSSYN#typedef-dimension-token
t.declaration-value:~CSSSYN#typedef-declaration-value
t.image:~CSSIMAGE#typedef-image
t.integer:~CSSVAL#integer-value
t.length:~CSSVAL#length-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.number:~CSSVAL#number-value
t.percentage:~CSSVAL#percentage-value
t.resolution:~CSSVAL#resolution-value
t.time:~CSSVAL#time-value
t.transform-function:~TRANSFORM#typedef-transform-function
t.url:~CSSVAL#url-value
t.ident-token:~CSSSYN#typedef-ident-token
t.whitespace-token:~CSSSYN#typedef-whitespace-token

f.var:~CSSVAR#funcdef-var
f.calc:~CSSVAL#funcdef-calc

	v.green:~CSSCOLOR#valdef-color-green
v.inherit:~CASCADE#valdef-all-inherit
v.unset:~CASCADE#valdef-all-unset
v.red:~CSSCOLOR#valdef-color-red
	RED:~CSSCOLOR#valdef-color-red
	Red:~CSSCOLOR#valdef-color-red

v.revert:~CASCADE#valdef-all-revert
v.blue:~CSSCOLOR#valdef-color-blue
v.black:~CSSCOLOR#valdef-color-black

	<https://github.com/w3c/css-houdini-drafts/issues/118>:https://github.com/w3c/css-houdini-drafts/issues/118

	●用語
独立に算出-可能:#computationally-independent
~custom~propを登録する:#register-a-custom-property

~data型~名:#data-type-name
~data型~名を消費する:#consume-a-data-type-name
量指定済み~data型~名:#pre-multiplied-data-type-name

結合子:#combinator
量指定子:#multipliers

構文~成分:#syntax-component
構文~成分~名:#syntax-component-name
構文~成分を消費する:#consume-a-syntax-component
構文~記述子:#syntax-descriptor
構文~記述子を消費する:#consume-a-syntax-descriptor
~supportされる構文~成分~名:#css-supported-syntax-component-name
構文~文字列:#syntax-string
全称~構文~記述子:#universal-syntax-descriptor
等価な~token列:#equivalent-token-sequence

	§:#calculation-of-computed-values

	●用語（ CSS
~CSS全域~keyword:~CSSVAL#css-wide-keywords
~math関数:~CSSVAL#math-function
正準的~単位:~CSSVAL#canonical-unit

~cascade:~CASCADE#cascade
指定d値:~CASCADE#specified-value

~custom~prop:~CSSVAR#custom-property
算出d値の時点で無効:~CSSVAR#invalid-at-computed-value-time

~token化:~CSSSYN#tokenization
則って構文解析-:~CSSSYN#css-parse-something-according-to-a-css-grammar
名前~符号位置:~CSSSYN#name-code-point
名前開始~符号位置:~CSSSYN#name-start-code-point
名前を消費する:~CSSSYN#consume-name
現入力~符号位置:~CSSSYN#current-input-code-point
現入力~符号位置を消費し直す:~CSSSYN#reconsume-the-current-input-code-point
次入力~符号位置:~CSSSYN#next-input-code-point
次入力~符号位置を繰り返し消費する:~CSSSYN#repeatedly-consume-next-code-point
空白:~CSSSYN#whitespace
識別子から開始して:~CSSSYN#check-if-three-code-points-would-start-an-identifier
	~CSSSYN#would-start-an-identifier
入力~stream:~CSSSYN#input-stream
~CSS値を直列化する:~CSSOM1#serialize-a-css-value

	●用語（外部

符号位置:~INFRA#code-point
~ASCII大小無視:~INFRA#ascii-case-insensitive
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace

~list:~INFRA#list
~size:~INFRA#list-size
構造体:~INFRA#struct
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
文字列:~INFRA#string
長さ:~INFRA#string-length

結付けられている文書:~WINDOW#concept-document-window
現在の大域~obj:~WAPI#current-global-object
	~THROW:~WEBIDL#dfn-throw




●●words_table1

●●words_table


	●型／構造／操作
data::::データ
item::::アイテム
slot::::スロット
options:::option 集
集合:set::~
下位集合:subset::~
member::::メンバ
method::::メソッド
list::::リスト
size::::サイズ
record::::レコード
obj:object:::オブジェクト
辞書:dictionary::~
構造体:struct::~
真偽値:boolean::~
文字列:string::~
整数:integer::~
色:color::~
真:true::~
実数:number::~
型:type::~
空:empty::~
付加-:append::~
作成-:create::~
除去-:remove::~
置換-:replace::~
値:value::~
名:name::~
名前:name::~
名前開始:name-start::~
順序:order::~
設定-:set:~
	設定し直す:reset
追加-:add:~
変換-:convert::~
変化-:change:~
変更-:change:~
包含-:contain::~
生成-:generate::~
改変-:modify::~
結付けら:associate さ:結び付けら

	●処理
処理-:process:~
前処理-:preprocess:~
上書き:override:~
無視-:ignore:~
登録-:register::~
	登録-法:registering
	登録-済み:registered
登録:registration::~
未登録に:unregister::~
未登録な:unregisterd::未登録の
	登録されていない:unregistered
計算:calculation:~
実行-:execute:~
被呼出時:被 invoke 時:~
	被呼出時:called
pipeline:
flag::::フラグ
引数:argument::~
比較-:compare::~
解決-:resolve::~
解決:resolution::~
違反-:violate::~
評価-:evaluate::~
等価:equivalent:~
test::::テスト
失敗:failure::~
入力:input::~
他全部:anything else:その他
構文解析-:parse::~
構文解析:parsing::~
解析済み:parsed::~
現入力:current input::現在の入力
次入力:next input::次の入力
消費-:consume::~
剥ぐ:strip する:~

	繰り返し:repeatedly
	何もしない:do nothing

	●構文
ASCII:
calc:
keyword::::キーワード
token::::トークン
	並び:sequence
	〜列:sequence
stream::::ストリーム
	区切りの:-separated
空白:whitespace::~
式:expression::~
符号位置:code point::~
	符号位置ごとに:codepoint-wise
space::::スペース
comma::::カンマ
小文字:lower-case::~
大小無視:case-insensitive::~
成分:component::~
単位:unit::~
妥当:valid::~
	妥当でない:invalid
無効:invalid::~
百分率:percentage::~
量指定子:multiplier::~
量指定済み:pre-multiplied::~
結合子:combinator::~
合致-:match::~
照合-:match::~
生成規則:production::~
生産-:produce::~
直列化-:serialize::~::シリアル化
構文:syntax::~
全称:universal::~
絶対:absolute::~
相対:relative::~
規則:rule::~
識別子:identifier::~
長さ:length::~
math:
文法:grammar::~
記述子:descriptor::~
寛容:liberal:~
開始-:start:~

	~~対象の:being multiplied-
	-:followed by
	`ident^t:ident
	`px^css :pixel
	`color$t／`color$p:color
	全部的な構文:full breadth
	~~項:clause／item
	`url^f:URL
	直後:immediately followed by／:immediately after
	^i:EOF

	●CSS ／ animation
cascade::::カスケード
animation::::アニメーション
初期:initial::~
算出-:compute::~
	独立に算出-可能:computationally independent
算出d:computed::算出
算出:computation::~
条件付き:conditional::~
補間-:interpolate::~
補間:interpolation::~
遷移:transition::~
宣言:declaration::~
宣言d:declared::宣言
始値:start::~
終値:end::~
関数:function::~
全域:-wide:~
単純:simple:~
call:
custom::::カスタム
layout::::レイアウト
	length-percentage:#1
prop:property:::プロパティ
stylesheet::::スタイルシート
style::::スタイル
要素:element::~
親:parent::~
根:root::~::ルート
継承-:inherit::~
継承:inheritance::~
文書:document::~

代用し:substitute し::置き換え
代用され:substitute され::置き換えられ
代用:substitution::置き換え

	●仕様
API:
CSS:
algo::::アルゴリズム
level::::レベル
UA:user agent:UA
module::::モジュール
privacy::::プライバシー
security::::セキュリティ
可用:available:~
事例:case:~
将来:future:~
影響0:impact:影響
情報:information:~
方式:manner:~
標準:standard:~
	注意:note
特色機能:feature:~
独立:independent:~
目的:purpose:~
直に:direct に:~
相互運用能:interoperability:~
	interop
知識:knowledge:~
課題:issue:~
通常の:normal な:~
通常通り:as normal に:通常どおり
適切:appropriate:~
基礎的な:primitive:~
段階:stage:~
仕方:way:~
アリ:possible:可能
	同様に:similarly
	の様な:like
	言い換えれば:In other words
	問わず／関わらず:regardless
	どちらに〜ようが:regardless of whether
	例:example
	例えば:for example
	べき:should
	しかしながら，:however
	よって:hence
	したがって:thus
	よくある:frequently
	-:identically
	-:optionally
	-:precise
	ない限り:so long as
	ほぼ何でも:nearly anything
	しようが:even though
	としても:even if
	-:we
	ので:Therefore

	●仕様（動詞
fall-back:fall back:::フォールバック
fallback::::フォールバック
support::::サポート
特別:special:~
仕様:spec:~
指定-:specify::~
指定d:specified::指定
	指定d値になる:as specified
受容-:accept:~
作者:author:~
	作者:user
供-:provide:~
依拠-:rely::~
制約-:restrict:~
制限-:limit:~
定義-:define:~
定義な:-defined:定義の
定義:definition:~
実装:implementation:~
導入-:introduce:~
手段:means:~
手続き:steps:~
拡張-:extend:~
挙動する:behave する:ふるまう
挙動:behaviour:ふるまい
	挙動:behavior:~
推奨-:recommend:~
改める:alter する:~
既知の:known:~
望む:wish する:~
期待-:expect:~
決定-:determine:~
確保-:ensure:~
考慮点:considerations:~
表記規約:conventions:~
複階性:complexity:複雑さ
見なさ:consider さ:~
考慮-:consider:~
許容-:allow:~
調整-:adjust:~
述べる:describe する:~
述べら:describe さ:~
	に従って:as described in
適用-:apply:~
避ける:avoid する:~
	記され:written
制御-:control:~
	により制御され:-controlled
包括的:comprehensive:~
拡げる:expand する:~
真似る:resembleする:~
見出され:find され:~
影響-:affect:~
有意:significant:~
拘束:constraint:~
追加的な:additional な:追加の
	追加して:additional
	加えて:additional
	-:Additional
利用-:use:~
	利用して:using
	利用-可能:usable
指示-:indicate:~
見做す:assume する:~

	とする:suppose
	結果になる:end up
	則って:according
	扱う:treat
	補うもの:complementary
	表す:express
	序論:introduction:~
	内部:private:~
	-:means
	より~~優先され:supersed
	従う:follow
	に注意:note
	〜とする:suppose

	●未分類
web:
参照-:reference:~
参照:reference:~

内部的:internal::~
操作-:manipulate:~
組入れる:incorporate する:~
	re-incorporated into
組合わせ:combination:組み合せ
組合でき:combine でき:組み合せれ
組合して:combine して:組み合せて
表現-:represent:~
選定-:select:~
塗り:paint::~
環境設定:configuration::~
大域的:global::~::グローバル
大域:global::~::グローバル
既定の:default::~::デフォルト
既定:default::~::デフォルト
基底:base::~
URL:
相違:difference:~
自動的:automatic:~
循環依存:dependency cycle:~
辺:edge:~
	辺で結ぶ:add an edge
	現れ-:appear
	生じ:occur
	-:down the DOM tree
	-:gain
	-:get#1
	`class^a:class#1
	:against
	:become
	~method:function
	近く:closely
	成す:contained in
	切り替わる:flip
	-:re
	-:passing
	-:repetition
	単位による:expressed in
	転換-:turned into
	時点／〜時:time
	になる:become
	除いて:except
	-:get 〜ed

	●指示語
現在の:current:~
全部的:full:~
新たな:new:~
元の:original:~
	:one
	0 個~以上:zero or more
	1 個以上:one or more
	2 個目:first／:second
	1 個の:single
	0 〜 1 個の:optional／:optionally
	最初の:first
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	その:those
	それら:they
	それらの:their
	そのような:such
	与-:give
	介:via
	他の:other
	他の場合:otherwise
	何か:something
	各:each
	同じ:same
	含-:include
	対応-:corresponding
	常に:always
	所与の:given
	次の:the following
	何ものも:anything
	他方:On the other hand,
	も:neither is,
	等々:any other casing variants
	上に挙げた:preceding
	一方で:while
	とり:take
	残された唯一の:left only
	両者:both
	中間:intermediate
	以上:at least
	それまで:previously
	依然として／〜としても:still
	異なる:different
	結果:result
	結果の:resulting
	および:as well as
	ここ:here
	上:above
	下:below
	別の:another
	前:before
	後:after
	複数の:multiple
	に対して:against
	代わりに:instead
	唯一の:only
	間:during
	間で:across
	ごく:very
	-:finally
	の間:between
	新たな:initially empty
	以降の各節:remainder of this chapter
	他のもの:anything else
	節:section

●●unicode_map
0023:NUMBER SIGN
002A:ASTERISK
002B:PLUS SIGN
003C:LESS-THAN SIGN
003E:GREATER-THAN SIGN
005C:REVERSE SOLIDUS
007C:VERTICAL LINE

●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-CONDITIONAL-3]
    CSS Conditional Rules Module Level 3 URL: https://www.w3.org/TR/css3-conditional/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-ANIMATIONS]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[CSS3-TRANSITIONS]
    David Baron; et al. CSS Transitions. 11 October 2018. WD. URL: https://www.w3.org/TR/css-transitions-1/ 
[CSS3-VALUES]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 31 January 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 March 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-LAYOUT-API-1]
    Greg Whitworth; et al. CSS Layout API Level 1. 12 April 2018. WD. URL: https://www.w3.org/TR/css-layout-api-1/ 
[CSS-PAINT-API-1]
    Ian Kilpatrick; Dean Jackson. CSS Painting API Level 1. 9 August 2018. CR. URL: https://www.w3.org/TR/css-paint-api-1/ 


●●trans_metadata
<p>
~THIS_PAGEは、 W3C により
編集者草案として公開された
<a href="~SPEC_URL">CSS Properties and Values API Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://drafts.css-houdini.org/css-properties-values-api-1/ 

最新 発行バージョン
	https://www.w3.org/TR/css-properties-values-api-1/ 

以前のバージョン
	https://www.w3.org/TR/2017/WD-css-properties-values-api-1-20171109/ 
	http://www.w3.org/TR/2016/WD-css-properties-values-api-1-20160607/ 

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bcss-properties-values-api%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[css-properties-values-api] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)

最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/labels/css-properties-values-api-1">GitHub Issues</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="mailto:daniel.glazman@disruptive-innovations.com">Daniel Glazman</a>
	<a href="mailto:stearns@adobe.com">Alan Stearns</a>
	<a href="mailto:gwhit@microsoft.com">Greg Whitworth</a>

前任編集者
	<a href="mailto:shanestephens@google.com">Shane Stephens</a>
	<a href="mailto:esprehn@chromium.org">Elliot Sprehn</a>

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master/css-properties-values-api

</script>


</head><body>

<header>

	<hgroup>
<h1 id="title">CSS Properties and Values API Level 1</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>


	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この~CSS~moduleは、新たな~CSS~propを登録するための~APIを定義する。
この~APIを利用して登録された~propは、［
型, 継承の挙動, 初期~値
］を定義する構文解析-構文を伴って供される。
◎
This CSS module defines an API for registering new CSS properties. Properties registered using this API are provided with a parse syntax that defines a type, inheritance behaviour, and an initial value.
</p>



	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSは、~web文書の［
~layout, 塗り, 挙動
］を改変するために操作できる~propたちが成す，包括的な集合を定義している。
しかしながら、~web作者が，この集合に~propを追加して拡張したいと望むこともよくある。
◎
CSS defines a comprehensive set of properties that can be manipulated in order to modify the layout, paint, or behaviour of a web document. However, web authors frequently wish to extend this set with additional properties.
</p>


<p>
`css-variables$r は、作者が制御する~propを定義するための基礎的な手段を供しているが、これらの~propは、常に~token~listを値にとり, 常に継承されるモノトスル。
加えて、それが影響0し得るのは，文書の~layoutや塗りに限られる
— `var^f 参照を介して他の~propの値を組入れることにより。
◎
[css-variables] provides primitive means for defining user-controlled properties, however these properties always take token lists as values, must always inherit, and can only impact document layout or paint by being re-incorporated into the value of other properties via a var() reference.
</p>


<p>
この仕様は、 `css-variables$r を拡張し，［
値~型, 初期~値, 定義-済みの継承の挙動
］を備える~propを登録できるようにする。
◎
This specification extends [css-variables], allowing the registration of properties that have a value type, an initial value, and a defined inheritance behaviour.
</p>


<p>
この仕様は［
`css-paint-api-1$r ／ `css-layout-api-1$r
］を補うものであり、~custom~propが［
塗り／~layout
］の挙動に直に影響0できるようにする。
◎
This specification is complementary to [css-paint-api-1] and [css-layout-api-1], which allow custom properties to directly impact paint and layout behaviours respectively.
</p>


	</section>
	<section id="registering-custom-properties">
<h2 title="Registering custom properties">2. ~custom~propの登録-法</h2>


<pre class="idl">
dictionary `PropertyDescriptor$I {
  required `DOMString$ `name$m;
           `DOMString$ `syntax$m = "*";
  required `boolean$   `inherits$m;
           `DOMString$ `initialValue$m;
};

partial namespace `CSS$I {
  void `registerProperty$m(`PropertyDescriptor$I %descriptor);
};
</pre>

<p>
加えて，各 `Document$I ~objは、
`registeredPropertySet@sl
内部~slotも持つ
— それは、登録-済み~custom~propについて述べる~recordたちが成す集合を~~保持する。
◎
Additional, the Document object gains a new [[registeredPropertySet]] private slot, which is a set of records that describe registered custom properties.
</p>


		<section id="the-propertydescriptor-dictionary">
<h3 title="The PropertyDescriptor dictionary">2.1. `PropertyDescriptor^I 辞書</h3>

<p id="propertydescriptor">
`PropertyDescriptor@I
辞書は、作者が指定した［
~custom~prop用の環境設定~options
］を表現する
— それは、次の~memberからなる：
◎
A PropertyDescriptor dictionary represents author-specified configuration options for a custom property. PropertyDescriptor dictionaries contain the following members:
</p>

<dl class="idl-def">
	<dt>`name@m
◎
name, of type DOMString
</dt>
	<dd>
定義する~custom~propの名前を与える。
◎
The name of the custom property being defined.
</dd>

	<dt>`syntax@m
◎
syntax, of type DOMString, defaulting to "*"
</dt>
	<dd>
この~custom~propをどう構文解析するかを表現する文字列を与える。
◎
A string representing how this custom property is parsed.
</dd>

	<dt>`inherits@m
◎
inherits, of type boolean
</dt>
	<dd>
この~custom~propは［
継承するべきならば ~T ／
他の場合は ~F
］。
◎
True if this custom property should inherit down the DOM tree; False otherwise.
</dd>

	<dt>`initialValue@m
◎
initialValue, of type DOMString
</dt>
	<dd>
この~custom~propの初期~値を与える。
◎
The initial value of this custom property.
</dd>
</dl>



		</section>
		<section id="the-registerproperty-function">
<h3 title="The registerProperty() function">2.2. `registerProperty()^m ~method</h3>

<dl class="idl-def">
	<dt>`registerProperty(descriptor)@m</dt>
	<dd>
%descriptor に供された環境設定~optionsに則って~custom~propを登録する。
◎
The registerProperty(PropertyDescriptor descriptor) method registers a custom property according to the configuration options provided in descriptor.＼
</dd>
	<dd>
被呼出時には、次を実行するモノトスル
⇒
`~custom~propを登録する$(
%descriptor の `name$m ~memberの値,
%descriptor の `syntax$m ~memberの値,
%descriptor の `inherits$m ~memberの値,
%descriptor の `initialValue$m ~memberの値
)
◎
When it is called, it executes the register a custom property algorithm, passing the options in its descriptor argument as arguments of the same names.
</dd>
</dl>

<div class="algorithm">

<p>
`~custom~propを登録する@
ときは、所与の
( 文字列 %名前,
文字列 %構文,
真偽値 %継承する,
文字列 %初期~値
)
に対し，次の手続きを実行する：
◎
To register a custom property with name being a string, and optionally syntax being a string, inherits being a boolean, and initialValue being a string, execute these steps:
</p>

<ol>
	<li>
%~prop集合 ~LET `現在の大域~obj$に`結付けられている文書$の `registeredPropertySet$sl ~slot値
◎
Let property set be the value of the current global object’s associated Document’s [[registeredPropertySet]] slot.
</li>
	<li>
%解析済み名 ~LET %名前 を `custom-property-name$t として構文解析した結果
◎
Attempt to parse name as a &lt;custom-property-name&gt;.＼
</li>
	<li>
~IF［
%解析済み名 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If this fails, throw a SyntaxError and exit this algorithm.
◎
Otherwise, let parsed name be the parsed value.
</li>
	<li>
~IF［
%~prop集合 内に［
~prop名 ~EQ %解析済み名
］なる~recordは在る
］
⇒
~THROW `InvalidModificationError$E
◎
If property set already contains an entry with parsed name as its property name (compared codepoint-wise), throw an InvalidModificationError and exit this algorithm.
</li>
	<li>
%構文~記述子 ~LET `構文~記述子を消費する$( %構文 )
◎
Attempt to consume a syntax descriptor from syntax.＼
</li>
	<li>
~IF［
%構文~記述子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If it returns failure, throw a SyntaxError. Otherwise, let syntax descriptor be the returned syntax descriptor.
</li>
	<li>
%解析済み初期~値 ~LET `失敗^i
◎
↓</li>
	<li>
<p>
~IF［
%構文~記述子 は`全称~構文~記述子$である
］：
</p>
		<ol>
			<li>
~IF［
%初期~値 ~EQ ε
］
⇒
%解析済み初期~値 ~SET 空
— これは［
`css-variables$r に定義される~custom~propの “既定の” 初期~値
］として扱うモノトスル。
◎
If syntax descriptor is the universal syntax descriptor, and initialValue is not present, let parsed initial value be empty. This must be treated identically to the "default" initial value of custom properties, as defined in [css-variables]. Skip to the next step of this algorithm.
</li>
			<li>
~ELSE
⇒
%解析済み初期~値 ~SET %初期~値 を `declaration-value$t に`則って構文解析-$した結果
◎
Otherwise, if syntax descriptor is the universal syntax descriptor, parse initialValue as a &lt;declaration-value&gt;. If this fails, throw a SyntaxError and exit this algorithm. Otherwise, let parsed initial value be the parsed result. Skip to the next step of this algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%初期~値 ~NEQ ε
］：
◎
Otherwise, if initialValue is not present, throw a SyntaxError and exit this algorithm.
</p>
		<ol>
			<li>
%解析済み初期~値 ~SET %初期~値 を %構文~記述子 に`則って構文解析-$した結果
◎
Otherwise, parse initialValue according to syntax descriptor.＼
</li>
	<li>
~IF［
%解析済み初期~値 ~NEQ `失敗^i
］~AND［
%解析済み初期~値 は`独立に算出-可能$でない
］
⇒
%解析済み初期~値 ~SET `失敗^i
◎
If this fails, throw a SyntaxError and exit this algorithm.
◎
Otherwise, let parsed initial value be the parsed result. If parsed initial value is not computationally independent, throw a SyntaxError and exit this algorithm.
</li>
		</ol>
	</li>
	<li>
~IF［
%解析済み初期~値 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
↑</li>
	<li>
%~prop集合 に次のようにされた`構造体$を`付加する$set
<!-- 同等性？ -->
⇒＃
~prop名 ~SET %解析済み名,
構文 ~SET %構文~記述子,
初期~値 ~SET %解析済み初期~値,
継承-~flag ~SET %継承する
◎
Set inherit flag to the value of inherits.
◎
Let registered property be a struct with a property name of parsed name, a syntax of syntax descriptor, an initial value of parsed initial value, and an inherit flag of inherit flag. Append registered property to property set.
</li>
</ol>

</div>

<p>
~prop値は、次に挙げるもののみを利用して算出d値に変換できるならば
`独立に算出-可能@
とされる
⇒＃
要素~上の~propの値,
~CSSにより変更し得ない “大域的な” 情報
◎
A property value is computationally independent if it can be converted into a computed value using only the value of the property on the element, and "global" information that cannot be changed by CSS.
</p>

<div class="example">

<p>
例えば `5px^v は、`独立に算出-可能$になる
— それを算出d値に変換した結果は ~~元のままなので。
同様に，`1in^v も、`独立に算出-可能$になる
— 算出d値に変換するときには，［
`1in^v は `96px^v である
］という “大域的な知識” のみに依拠し、~CSSにおける何ものも，それを［
改める／調整する
］ことはないので。
◎
For example, 5px is computationally independent, as converting it into a computed value doesn’t change it at all. Similarly, 1in is computationally independent, as converting it into a computed value relies only on the "global knowledge" that 1in is 96px, which can’t be altered or adjusted by anything in CSS.
</p>

<p>
他方 `3em^v は`独立に算出-可能$でない
— それは、要素（または要素の親）上の `font-size$p 値に依拠するので。
`var$f 関数を伴う値も`~custom~prop$の値に依拠するので~~同様になる。
◎
On the other hand, 3em is not computationally independent, because it relies on the value of font-size on the element (or the element’s parent). Neither is a value with a var() function, because it relies on the value of a custom property.
</p>

</div>

<p>
所与の型を伴う~custom~propが登録されたとき、その~prop用の指定d値を算出d値に転換する処理-は，選定された型により全部的に定義される
— <a href="#calculation-of-computed-values">§算出d値の計算</a>
にて述べるように。
◎
When a custom property is registered with a given type, the process via which specified values for that property are turned into computed values is defined fully by the type selected, as described in §2.3 Calculation of Computed Values.
</p>

<p class="note">注記：
将来には、~propを未登録にする仕方も追加され得る。
◎
Note: A way to unregister properties may be added in the future.
</p>

<p>
~custom~propの登録は、いかなる仕方でも，`~cascade$に影響しないモノトスル。
登録された~prop用に指定した構文を問わず、`~custom~prop$は，構文解析-時点では 通常通りほぼ何でも受容するように構文解析される。
しかしながら，登録された`~custom~prop$に対する`指定d値$が 登録した構文に違反する場合、~propは`算出d値の時点で無効$になる（したがって，登録した初期~値に設定し直される）。
◎
Registering a custom property must not affect the cascade in any way. Regardless of what syntax is specified for a registered property, at parse time it is still parsed as normal for a custom property, accepting nearly anything. If the specified value for a registered custom property violates the registered syntax, however, the property becomes invalid at computed-value time (and thus resets to the registered initial value).
</p>

<div class="example">

<p>
既定では、一連の~token並びとして構文解析できる どの~custom~prop宣言も妥当になる。
よって，次の~stylesheetによる結果は：
◎
By default, all custom property declarations that can be parsed as a sequence of tokens are valid. Hence, the result of this stylesheet:
</p>

<pre class="lang-css">
.thing {
  --my-color: green;
  --my-color: url("not-a-color");
  color: var(--my-color);
}
</pre>

<p>
`class^a `thing^l を伴う要素の `color$p ~propは、 `inherit$v に設定される
— 2 個目の `--my-color^p 宣言は 構文解析-時に 1 個目のものを上書きし（両者とも妥当である）、
`color$p ~prop内の `var$f 参照は `算出d値の時点で無効$と見出されるので（ `url("not-a-color")^v は `color$t でないので）。
~CSS~pipelineのこの段階（算出d値の時点）で可用な~fallbackは，~propの初期~値しかなく、
`color$p の事例では `inherit$v になる。
利用-可能な妥当な値は他にもあるが（ `green^v ）、
`url^f がより~~優先されるので，構文解析-時に除去される。
◎
is to set the color property of elements of class "thing" to inherit. The second --my-color declaration overrides the first at parse time (both are valid), and the var() reference in the color property is found to be invalid at computed-value time (because url("not-a-color") is not a color). At this stage of the CSS pipeline (computation time), the only available fallback is the initial value of the property, which in the case of color is inherit. Although there was a valid usable value (green), this was removed during parsing because it was superseded by the URL.
</p>

<p>
次を~callした場合：
◎
If we call:
</p>

<pre class="lang-javascript">
CSS.registerProperty({
  name: "--my-color",
  syntax: "&lt;color&gt;",
  initialValue: "black",
  inherits: false
});
</pre>

<p>
この登録が上の~stylesheetを構文解析する前, 後どちらに生じようが、構文解析が有意に変化することはない。
登録が生じたときの，唯一の相違は：
代わりに `--my-color^p ~propが`算出d値の時点で無効$になり、その初期~値 `black$v に設定される。
それから、 `color$p が妥当に `black$v に設定される
— `算出d値の時点で無効$にされ， `inherit$v になるのではなく。
◎
the parsing doesn’t significantly change, regardless of whether the registration occurs before or after the stylesheet above. The only difference is that it’s the --my-color property that becomes invalid at computed-value time instead and gets set to its initial value of black; then color is validly set to black, rather than being invalid at computed-value time and becoming inherit.
</p>

</div>

		</section>
		<section id="calculation-of-computed-values">
<h3 title="Calculation of Computed Values">2.3. 算出d値の計算</h3>

<p>
~custom~propの構文は、その~prop用に［
指定d値から算出d値を生成する方法
］を全部的に決定する。
◎
The syntax of a custom property fully determines how computed values are generated from specified values for that property.
</p>

<p>
`~CSS全域~keyword$（ `revert$v も含む）が生成する算出d値は、
`css3-values$r, `css-cascade-4$r
に従う。
他の場合：
◎
The CSS-wide keywords and revert generate computed values as described in [css3-values] and [css-cascade-4] respectively. Otherwise:
</p>

<ul>
	<li>
`length^t 値~用の算出d値は、 `px^css 単位による絶対~長さになる。
◎
For &lt;length&gt; values, the computed value is the absolute length expressed in pixels.
</li>
	<li>
<p>
`length-percentage^t 値~用の算出d値は、次のいずれかになる：
◎
For &lt;length-percentage&gt; values, the computed value is one of the following:
</p>

		<ul>
			<li>
指定d値は長さ単位のみ包含する場合
⇒
算出d値は `px^css 単位による絶対~長さになる。
◎
if the specified value contains only length units, the computed value is the absolute length expressed in pixels.
</li>
			<li>
指定d値は百分率のみを包含する場合
⇒
算出d値は単純な百分率になる。
◎
if the specified value contains only percentages, the computed value is a simple percentage.
</li>
			<li>
他の場合
⇒
算出d値は［
`px^css 単位による絶対~長さ, 百分率~値
］を包含している `calc$f 式になる。
◎
otherwise, the computed value is a calc expression containing an absolute length expressed in pixels, and a percentage value.
</li>
		</ul>
	</li>
	<li>
`color^t 値~用の算出d値は、
`CSS-COLOR-4$r による
<a href="~CSSCOLOR#resolving-color-values">色~値の解決-法</a>
に従う。
◎
For &lt;color&gt; values, the value is computed as described in CSS Color 4 §4 Resolving Color values.
</li>
	<li>
［
`angle^t ／
`time^t ／
`resolution^t
］値~用の算出d値は、その`正準的~単位$に~~換算した結果になる
— 値が `calc$f 式の場合†は `CSS-VALUES-4$r に
<a href="~CSSVAL#calc-computed-value">従って評価される</a>
。
【†他の`~math関数$については、触れられていない。他所の `calc^f についても同様。】
◎
For &lt;angle&gt;, &lt;time&gt; and &lt;resolution&gt; values, the computed value is the value expressed in its canonical unit, with calc() expressions evaluated as described in CSS Values.
</li>
	<li>
［
`custom-ident^t ／
`ident^t ／
`*^l
］値~用の算出d値は、指定d値になる。
◎
For &lt;custom-ident&gt;, ident, or "*" values, the computed value is as specified.
</li>
	<li>
<p>
`url^t 値~用の算出d値は、次のいずれかになる：
◎
For &lt;url&gt; values, the computed value is one of the following:
</p>
		<ul>
			<li>
~URLは相対~URLである場合、算出d値は `css3-values$r に従って絶対~URLに解決される。
◎
if the URL is a relative URL, the computed value is the resolved absolute URL as described in [css3-values].
</li>
			<li>
他の場合、算出d値は指定d値になる。
◎
otherwise, the computed value is as specified.
</li>
		</ul>
<p>
`image^t 値~用の算出d値は、値~内に現れる すべての［
相対~URLは `css3-values$r に従って絶対~URLに解決される／
長さは算出d値に解決される
］ことを除いて，指定d値になる。
◎
For &lt;image&gt; values, the computed value is as specified, except that relative URLs that appear in the value are resolved to absolute URLs as described in [css3-values], and all lengths are resolved to their computed values.
</p>
	</li>
	<li>
<p>
［
`integer^t ／ `number^t ／ `percentage^t
］値~用の算出d値は、次のいずれかになる：
◎
For &lt;integer&gt;, &lt;number&gt; and &lt;percentage&gt; values, the computed value is one of the following:
</p>
		<ul>
			<li>
指定d値は `calc$f 式である場合、それを評価した結果になる。
◎
if the specified value is a calc() expression, the computed value is the evaluated result of that expression.
</li>
			<li>
他の場合、指定d値になる。
◎
otherwise, the computed value is as specified.
</li>
		</ul>
	</li>
	<li>
`transform-function^t 値~用の算出d値は、（ `transform-list^t 内に包含されたものも含め，）指定d値を成すすべての長さ値をそれぞれの算出d値に解決した結果になる。
◎
For &lt;transform-function&gt; values (including those contained in &lt;transform-list&gt; values), the computed value is as specified but with all lengths resolved to their computed values.
</li>
	<li>
［［
`|^l で区切られた何項かからなる`構文~文字列$
］により指定される値
］用の算出d値は、［
指定d値に合致する最初の~~項
］用の計算~規則を適用した結果になる。
◎
For values specified by a syntax string that include "|" clauses, the computed value is given by applying the calculation rules for the first clause that matches to the specified value.
</li>
	<li>
~list値~用の算出d値は、~listを成す各項を算出d値に~~置換した結果になる。
◎
For list values, the computed value is a list of the computed values of the primitives in the list.
</li>
</ul>


		</section>
		<section id="supports">
<h3 title="Registered Properties and @supports">2.4. 登録された~propと `supports^at</h3>

<p>
登録されていない~custom~propは、 `supports$at を介して~testされるときには “常に妥当” になる
— `@supports (--foo: red) {...}^css の様な規則を評価した結果は、~custom~prop用の（ごく寛容な）構文に違反しない限り，常に真になる。
◎
Unregistered custom properties are “always valid” when tested via @supports; a rule like `@supports (--foo: red) {...}` is always true so long as you don’t violate the (very liberal) syntax for custom properties.
</p>

<p>
~custom~propを登録しても、これが変化することはない。
例えば，ある~custom~propが `syntax: "&lt;color&gt;"^c で登録されたとしても、
`@supports (--foo: 1em) {...}^css
の様な規則は真に評価され，その~styleは適用される。
◎
Registering a custom property does not change this. Even if a custom property is, for example, registered with `syntax: "&lt;color&gt;"`, a rule like `@supports (--foo: 1em) {...}` will still evaluate as true and apply those styles.
</p>

<p class="note">注記：
これは、登録された~custom~propを構文解析するときの挙動に合致する。
構文に `&lt;color&gt;^l を指定して登録された~custom~prop `--foo^p が，
`--foo: 1em;^css
と記されたとしても、構文解析-時には，依然として妥当として受容されることになる
— が、自動的に`算出d値の時点で無効$になる。
`supports$at は構文解析-時の挙動を~testするので、登録した構文を問わず，すべての値を妥当として受容する。
◎
Note: This matches the parsing behavior of registered custom properties. A registered custom property specified as `"&lt;color&gt;"` but written as `--foo: 1em;` will still be accepted as valid at parse-time, but be automatically invalid at computed-value time. As @supports tests parse behavior, it thus also accepts all values as valid regardless of the registered syntax.
</p>

		</section>
		<section id="dependency-cycles">
<h3 title="Dependency cycles via relative units">2.5. 相対~単位を介する循環依存</h3>

<p>
登録された~custom~propは、循環依存の解決にあたり，登録されていない~custom~propと同じ規則に従うが、以下に挙げる追加的な拘束も~~課される:
◎
Registered custom properties follow the same rules for dependency cycle resolution as unregistered custom properties, with the following additional constraints:
</p>

<p>
登録された~custom~propのうち、構文~成分に［
`length$t ／ `length-percentage$t
］を伴うものは：
◎
For any registered custom property with a &lt;length&gt; or &lt;length-percentage&gt; syntax component:
</p>

<ul>
	<li>
~propは［
`em$u ／ `ex$u ／ `cap$u ／ `ch$u ／ `ic$u ／ `lh$u
］単位を包含する場合
⇒
~propと現在の要素の `font-size$p ~propとの間を辺で結ぶ。
◎
If the property contains any of the following units: em, ex, cap, ch, ic, lh; then add an edge between the property and the font-size of the current element.
</li>
	<li>
~propは `lh$u 単位を包含する場合
⇒
~propと現在の要素の `line-height$p ~propとの間を辺で結ぶ。
◎
If the property contains the lh unit, add an edge between the property and the line-height of the current element.
</li>
	<li>
~propは［
`rem$u ／ `rlh$u
］単位を包含する場合
⇒
~propと根~要素の `font-size$p ~propとの間を辺で結ぶ。
◎
If the property contains any of the following units: rem, rlh; then add an edge between the property and the font-size' of the root element.
</li>
	<li>
~propは `rlh$u 単位を包含する場合
⇒
~propと根~要素の `line-height$p ~propとの間を辺で結ぶ。
◎
If the property contains the rlh unit, add an edge between the property and the line-height' of the root element.
</li>
</ul>

<div class="example">
<p>
例えば，次の登録が与えられたとする：
◎
For example, given this registration:
</p>

<pre class="lang-javascript">
CSS.registerProperty({
  name: "--my-font-size",
  syntax: "&lt;length&gt;",
  initialValue: "0px",
  inherits: false
});
</pre>

<p>
次の~styleは、循環依存を生産することになる：
◎
the following will produce a dependency cycle:
</p>

<pre class="lang-css">
div {
  --my-font-size: 10em;
  font-size: var(--my-font-size);
}
</pre>

<p>
`font-size^p は、値 `unset$v が指定されていたかのように挙動することになる。
◎
and font-size will behave as if the value unset was specified.
</p>

</div>

		</section>
	</section>
	<section id="syntax-strings">
<h2 title="Syntax Strings">3. 構文~文字列</h2>

<p>
`構文~文字列@
は、［
登録-済み~custom~propが受容する値~型
］を述べる。
構文~文字列は、`構文~成分~名$, および
0 〜 1 個の［
`量指定子$／`結合子$
］を伴う。
◎
A syntax string describes the value types accepted by a registered custom property. Syntax strings consists of syntax component names, that are optionally multiplied and combined.
</p>

<p>
構文~文字列は、次のいずれかの`構文~記述子$に構文解析され得る：
◎
A syntax string can be parsed into a syntax descriptor, which is either:
</p>

<ul>
	<li>
何個かの`構文~成分$からなる~list
— 各~構文~成分は、
<a href="#supported-names">§~supportされる名前</a>
にて指定される対応する値~型を受容する。
◎
A list of syntax components, each of which accept the value types specified in §3.1 Supported names, or
</li>
	<li>
`全称~構文~記述子$（ `*^l ）
— ~~任意の妥当な~token~streamを受容する。
◎
The universal syntax descriptor (*), which accepts any valid token stream.
</li>
</ul>

<p class="note">注記：
指定された構文を問わず，すべての~custom~propは、`~CSS全域~keyword$を受容して，それらの値を適切に処理する。
◎
Note: Regardless of the syntax specified, all custom properties accept CSS-wide keywords, and process these values appropriately.
</p>

<div class="example">

<p>
例えば，次のものは、どれも妥当な構文~文字列になる：
◎
For example, the following are all valid syntax strings.
</p>

<dl>
	<dt>`&lt;length&gt;^l</dt>
	<dd>
<!-- Any valid 略 -->
長さ値を受容する
◎
accepts length values
</dd>

	<dt>`&lt;length&gt; | &lt;percentage&gt;^l</dt>
	<dd>
［
長さ ／ 百分率／ 百分率を与える~calc式 ／ 長さを与える~calc式
］値を受容するが、［
長さ値, 百分率~値
］の組合わせを包含している~calc式は受容しない。
◎
accepts lengths, percentages, percentage calc expressions, and length calc expressions, but not calc expressions containing a combination of length and percentage values.
</dd>

	<dt>`&lt;length-percentage&gt;^l</dt>
	<dd>
［
`&lt;length&gt; | &lt;percentage&gt;^l
］が受容するすべての値, および
長さ値と百分率~値の組合わせを包含している~calc式を受容する。
◎
accepts all values that "&lt;length&gt; | &lt;percentage&gt;" would accept, as well as calc expressions containing a combination of both length and percentage values.
</dd>

	<dt>`big | bigger | BIGGER^l</dt>
	<dd>
［
`big^v, `bigger^v, `BIGGER^v
］（いずれも `ident^t ）を受容する。
◎
accepts the ident big, or the ident bigger, or the ident BIGGER.
</dd>

	<dt>`&lt;length&gt;+^l</dt>
	<dd>
1 個~以上の長さ値が成す，~space区切りの~listを受容する。
◎
accepts a space-separated list of length values.
</dd>
	<dt>`*^l</dt>
	<dd>
妥当な どの~token~streamも受容する。
◎
accepts any valid token stream
</dd>
</dl>

</div>


<p class="note">注記：
構文~文字列の内部的な文法は、
<a href="~CSSVAL#value-defs">値~定義~構文</a> `CSS-VALUES-4$r
の下位集合である。
この仕様の将来~levelでは、［
~CSS~propが許容する全部的な構文を，より近く真似る~custom~prop
］も許容するように，許容される文法の複階性を拡げるものと期待されている。
◎
Note: The internal grammar of syntax strings is a subset of the CSS Value Definition Syntax. Future levels of this specification are expected to expand the complexity of the allowed grammar, allowing custom properties that more closely resemble the full breadth of what CSS properties allow.
</p>

<p>
以降の各節では、構文~文字列の内部的な文法を述べる。
◎
The remainder of this chapter describes the internal grammar of the syntax strings.
</p>

		<section id="supported-names">
<h3 title="Supported names">3.1. ~supportされる名前</h3>

<p>
この節は、
`~supportされる構文~成分~名@
および［
結果の`構文~成分$が受容する，その成分~名に対応する型
］を定義する。
◎
This section defines the supported syntax component names, and the corresponding types accepted by the resulting syntax component.
</p>

<dl>
	<dt>`&lt;length&gt;^l</dt>
	<dd>
<!-- Any valid -->
`length$t 値
◎
Any valid &lt;length&gt; value
</dd>

	<dt>`&lt;number&gt;^l</dt>
	<dd>
`number$t 値
◎
&lt;number&gt; values
</dd>

	<dt>`&lt;percentage&gt;^l</dt>
	<dd>
`percentage$t 値
◎
Any valid &lt;percentage&gt; value
</dd>

	<dt>`&lt;length-percentage&gt;^l</dt>
	<dd>
`length$t 値
◎
Any valid &lt;length&gt;＼
</dd>
	<dd>
`percentage$t 値
◎
or &lt;percentage&gt; value,＼
</dd>
	<dd>
`length$t, `percentage$t 成分を組合している `calc()$t 式
【`~math関数$？】
◎
any valid &lt;calc()&gt; expression combining &lt;length&gt; and &lt;percentage&gt; components.
</dd>

	<dt>`&lt;color&gt;^l</dt>
	<dd>
`color$t 値
◎
Any valid &lt;color&gt; value
</dd>

	<dt>`&lt;image&gt;^l</dt>
	<dd>
`image$t 値
◎
Any valid &lt;image&gt; value
</dd>

	<dt>`&lt;url&gt;^l</dt>
	<dd>
`url$t 値
◎
Any valid &lt;url&gt; value
</dd>

	<dt>`&lt;integer&gt;^l</dt>
	<dd>
`integer$t 値
◎
Any valid &lt;integer&gt; value
</dd>

	<dt>`&lt;angle&gt;^l</dt>
	<dd>
`angle$t 値
◎
Any valid &lt;angle&gt; value
</dd>

	<dt>`&lt;time&gt;^l</dt>
	<dd>
`time$t 値
◎
Any valid &lt;time&gt; value
</dd>

	<dt>`&lt;resolution&gt;^l</dt>
	<dd>
`resolution$t 値
◎
Any valid &lt;resolution&gt; value
</dd>

	<dt>`&lt;transform-function&gt;^l</dt>
	<dd>
`transform-function$t 値
◎
Any valid &lt;transform-function&gt; value
</dd>

	<dt>`&lt;custom-ident&gt;^l</dt>
	<dd>
`custom-ident$t 値
◎
Any valid &lt;custom-ident&gt; value
</dd>

	<dt>
`識別子から開始して$いる並びのうち，
<a href="~CSSSYN#consume-name">名前として消費できる</a>, かつ
`custom-ident$t 生成規則に合致するもの
◎
Any sequence which starts an identifier, can be consumed as a name, and matches the &lt;custom-ident&gt; production
</dt>
	<dd>
その識別子
◎
That identifier
</dd>
	<dd class="note">注記：
`custom-ident$t は、符号位置ごとに比較される。
これは、~UA定義な~CSSにおける通常の挙動（ ~ASCIIに制限され, `~ASCII大小無視$で比較される）と異なる。
なので， `Red^v の様な `ident^t を指定した場合、値 `Red^v は受容されるが， `red^v, `RED^v は合致しない。
~CSS表記規約に合致するためには、 `ident^t は~ASCIIのみに制約した上で，小文字で記すことが推奨される。
◎
Note: &lt;custom-ident&gt;s are compared codepoint-wise with each other; this is different than the normal behavior of UA-defined CSS which limits itself to ASCII and is ASCII case-insensitive. So, specifying an ident like Red means that the precise value Red is accepted; red, RED, and any other casing variants are not matched by this. It is recommended that idents be restricted to ASCII and written in lower-case, to match CSS conventions.
</dd>

	<dt>`&lt;transform-list&gt;^l</dt>
	<dd>
1 個以上の妥当な `transform-function$t 値からなる~list。
これは、 `&lt;transform-function&gt;+^l に等価な，`量指定済み~data型~名$であることに注意。
◎
A list of valid &lt;transform-function&gt; values. Note that "&lt;transform-list&gt;" is a pre-multiplied data type name equivalent to "&lt;transform-function&gt;+"
</dd>
</dl>


<p class="note">注記：
構文~文字列 `*^l は、`全称~構文~記述子$を生産する
— それは`構文~成分$ではないので、`量指定子$を付与できないし，他のものと`結合子$で組合できない。
◎
Note: A syntax string of "*" will produce the universal syntax descriptor, which is not a syntax component. Therefore, "*" may not be multiplied or combined with anything else.
</p>

		</section>
		<section id="multipliers">
<h3 title="The '+' and '#' multipliers">3.2. `+^css, `#^css 量指定子</h3>

<p>
`量指定済み~data型~名$を除き、`構文~成分~名$には，直後に量指定子を付与してもヨイ：
◎
Any syntax component name except pre-multiplied data type names may be immediately followed by a multiplier:
</p>

<dl>
	<dt>~U002B</dt>
	<dd>
~space区切りの~listを指示する。
◎
Indicates a space-separated list.
</dd>

	<dt>~U0023</dt>
	<dd>
~comma区切りの~listを指示する。
◎
Indicates a comma-separated list.
</dd>
</dl>

<div class="example">

<dl>
	<dt>`&lt;length&gt;+^l</dt>
	<dd>
1 個以上の長さ値からなる~space区切りの~listを受容する
◎
accepts a space-separated list of length values
</dd>

	<dt>`&lt;color&gt;#^l</dt>
	<dd>
1 個以上の色~値からなる~comma区切りの~listを受容する
◎
accepts a comma-separated list of color values
</dd>
</dl>
</div>

<p class="note">注記：
量指定子は、~~対象の`構文~成分~名$の直後に現れなければナラナイ。
◎
Note: The multiplier must appear immediately after the syntax component name being multiplied.
</p>

		</section>
		<section id="combinator">
<h3 title="The '|' combinator">3.3. `|^css 結合子</h3>

<p>
`構文~文字列$は、 ~U007C を利用して，複数の`構文~成分~名$を供してもヨイ。
そのような構文~文字列による結果は、複数の`構文~成分$を伴う`構文~記述子$になる。
◎
Syntax strings may use U+007C VERTICAL LINE (|) to provide multiple syntax component names. Such syntax strings will result in a syntax descriptor with multiple syntax components.
</p>

<p>
ある~CSS値を構文解析するときに，複数の`構文~成分$を伴う`構文~記述子$が利用される場合、各 構文~成分は，指定された順序で照合される。
◎
When a syntax descriptor with multiple syntax components is used to parse a CSS value, the syntax components are matched in the order specified.
</p>


<p class="note">注記：
すなわち，構文~文字列として
`red | &lt;color&gt;^l
が与えられた下では、［
値 `red^v と照合したときは、識別子として構文解析する
］ことになる一方，［
値 `blue$v と照合したときは、 `color$t として構文解析する
］ことになる。
◎
Note: That is, given the syntax string "red | &lt;color&gt;", matching the value red against it will parse as an identifier, while matching the value blue will parse as a &lt;color&gt;.
</p>

<div class="example">

<dl>
	<dt>`&lt;length&gt; | auto^l</dt>
	<dd>
［
長さ／ `auto^v
］を受容する
◎
accepts a length, or auto
</dd>

	<dt>`foo | &lt;color&gt;# | &lt;integer&gt;^l</dt>
	<dd>
［
`foo^v ／
1 個以上の色~値からなる~comma区切りの~list ／
1 個の整数
］を受容する
◎
accepts foo, a comma-separated list of color values, or a single integer
</dd>
</dl>
</div>

		</section>
		<section id="parsing-syntax">
<h3 title="Parsing the syntax string">3.4. 構文~文字列の構文解析</h3>

			<section id="parsing-definitions">
<h4 title="Definitions">3.4.1. 定義</h4>

<dl>
	<dt>`~data型~名@</dt>
	<dd>
次の順による`符号位置$並び
⇒＃
~U003C,
0 個以上の`名前~符号位置$,
~U003E
◎
A sequence of code points consisting of a U+003C LESS-THAN SIGN (&lt;), followed be zero or more name code points, and terminated by U+003E GREATER-THAN SIGN (&gt;).
</dd>

	<dt>`量指定済み~data型~名@</dt>
	<dd>
`~data型~名$のうち，［
`量指定子$を伴う別の`構文~成分$を表現するもの
］をすでに含んでいるもの。
◎
A data type name that represents another syntax component with a multiplier already included.
</dd>

	<dt>`構文~成分@</dt>
	<dd>
次のものからなる~obj
⇒
`構文~成分~名$,
0 〜 1 個の`量指定子$
◎
An object consisting of a syntax component name, and an optional multiplier.
</dd>

	<dt>`構文~成分~名@</dt>
	<dd>
次のいずれかを与える`符号位置$並び
⇒＃
`~data型~名$ ／
`custom-ident$t を生産し得るもの
◎
A sequence of code points which is either a data type name, or a sequence that can produce a &lt;custom-ident&gt;.
</dd>

	<dt>`構文~記述子@</dt>
	<dd>
1 個以上の`構文~成分$からなる~listが成す~obj。
◎
An object consisting of a list of syntax components.
</dd>

	<dt>`全称~構文~記述子@</dt>
	<dd>
妥当な どの~token~streamも受容する，特別な記述子。
◎
A special descriptor which accepts any valid token stream.
</dd>
</dl>

			</section>
			<section id="consume-syntax-descriptor">
<h4 title="Consume a syntax descriptor">3.4.2. 構文~記述子を消費する</h4>

<div class="algorithm">
<p>
この節では、
`構文~記述子を消費する@
方法を述べる。
それは、所与の
( `文字列$ %文字列 )
から［
`構文~成分$の~listを伴う`構文~記述子$ ／ `全称~構文~記述子$
］を生産する：
◎
This section describes how to consume a syntax descriptor from a string string. It either produces a syntax descriptor with a list of syntax components, or the universal syntax descriptor.
</p>

<ol>
	<li>
%文字列 から`前後の~ASCII空白~列を剥ぐ$
◎
Strip leading and trailing ASCII whitespace from string.
</li>
	<li>
~IF［
%文字列 の`長さ$ ~EQ 0
］
⇒
~RET `失敗^i
◎
If string’s length is 0, return failure.
</li>
	<li>
~IF［
%文字列 ~EQ `*^l （ 1 個の ~U002A ）
］
⇒
~RET `全称~構文~記述子$
◎
If string’s length is 1, and the only code point in string is U+002A ASTERISK (*), return the universal syntax descriptor.
</li>
	<li>
%~stream ~LET %文字列 を成す`符号位置$並びを前処理して作成される`入力~stream$
`css-syntax-3$r
◎
Let stream be an input stream created from the code points of string, preprocessed as specified in [css-syntax-3].＼
</li>
	<li>
%記述子 ~LET 新たな`~list$
◎
Let descriptor be an initially empty list of syntax components.
</li>
	<li>
<p>
%~stream から`次入力~符号位置を繰り返し消費する$：
◎
Repeatedly consume the next input code point from stream:
</p>
		<dl class="switch">
			<dt>`空白$</dt>
			<dd>
何もしない
◎
Do nothing.
</dd>

			<dt>`EOF^i</dt>
			<dd>
				<ol>
					<li>
~IF［
%記述子 の`~size$ ~EQ 0
］
⇒
~RET `失敗^i
</li>
					<li>
~RET %記述子
</li>
				</ol>
◎
If descriptor’s size is greater than zero, return descriptor; otherwise, return failure.
</dd>

			<dt>~U007C</dt>
			<dd>
				<ol>
					<li>
~IF［
%記述子 の`~size$ ~EQ 0
］
⇒
~RET `失敗^i
</li>
					<li>
%結果 ~LET %~stream から`構文~成分を消費する$
</li>
					<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
					<li>
%記述子 に %結果 を`付加する$
</li>
				</ol>
◎
If descriptor’s size is greater than zero, consume a syntax component from stream. If failure was returned, return failure; otherwise, append the returned value to descriptor.
◎
If descriptor’s size is zero, return failure.
</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
%~stream から`現入力~符号位置を消費し直す$
</li>
					<li>
%結果 ~LET %~stream から`構文~成分を消費する$
</li>
					<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
					<li>
%記述子 に %結果 を`付加する$
</li>
				</ol>
◎
Reconsume the current input code point in stream. Consume a syntax component from stream. If failure was returned, return failure; otherwise, append the returned value to descriptor.
</dd>
		</dl>
	</li>
</ol>
</div>

			</section>
			<section id="consume-syntax-component">
<h4 title="Consume a syntax component">3.4.3. 構文~成分を消費する</h4>

<div class="algorithm">
<p>
`符号位置$の %~stream から
`構文~成分を消費する@
ときは：
◎
To consume a syntax component from a stream of code points stream: 
</p>

<ol>
	<li>
%~stream からアリな限り多くの`空白$を消費する
◎
Consume as much whitespace as possible from stream.
</li>
	<li>
%名前 ~SET 空~文字列
</li>
	<li>
%量指定子 ~SET ε（なし）
◎
Let component be a new syntax component with its name and multiplier initially empty.
</li>
	<li>
<p>
%~stream から`次入力~符号位置$を消費する：
◎
Consume the next input code point stream:
</p>
		<dl class="switch">
			<dt>~U003C</dt>
			<dd>
				<ol>
					<li>
%結果 ~LET %~stream から`~data型~名を消費する$
</li>
					<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
					<li>
%名前 ~SET %結果
</li>
				</ol>
◎
Consume a data type name from stream. If it returned a string, set component’s name to the returned value. Otherwise, return failure.
</dd>

			<dt>`名前開始~符号位置$</dt>
			<dt>~U005C</dt>
			<dd>
				<ol>
					<li>
~IF［
%~stream は`識別子から開始して$いない
］
⇒
~RET `失敗^i
</li>
					<li>
%~stream から`現入力~符号位置を消費し直す$
</li>
					<li>
%名前 ~SET %~stream から`名前を消費する$
— その結果は `ident-token$t を与える
</li>
				</ol>
◎
If the stream starts with an identifier, reconsume the current input code point from stream then consume a name from stream, and set component’s name to the returned &lt;ident-token&gt;’s value. Otherwise return failure.
</dd>

			<dt>他全部</dt>
			<dd>
~RET `失敗^i
◎
Return failure.
</dd>
		</dl>
	</li>
	<li>
~IF［
%名前 は`量指定済み~data型~名$である
］
⇒
~RET 次のようにされた新たな`構文~成分$
⇒＃
名前 ~SET %名前,
量指定子 ~SET %量指定子
◎
If component’s name is a pre-multiplied data type name, return component.
</li>
	<li>
<p>
~IF［
%~stream 内の`次入力~符号位置$ ~IN { ~U002B, ~U0023 }
］：
</p>
		<ol>
			<li>
%~stream から`次入力~符号位置$を消費する
</li>
			<li>
%量指定子 ~SET `現入力~符号位置$
</li>
		</ol>
◎
If the next input code point in stream is U+002B PLUS SIGN (+) or U+0023 NUMBER SIGN (#), consume the next input code point from stream, and set component’s multiplier to the current input code point.
</li>
	<li>
~RET 次のようにされた新たな`構文~成分$
⇒＃
名前 ~SET %名前,
量指定子 ~SET %量指定子
◎
Return component.
</li>
</ol>

</div>

			</section>
			<section id="consume-data-type-name">
<h4 title="Consume a data type name">3.4.4. ~data型~名を消費する</h4>

<div class="algorithm">
<p>
`符号位置$の~streamから
`~data型~名を消費する@
ときは：
◎
To consume a data type name from a stream of code points:
</p>


<p class="note">注記：
この~algoは、`符号位置$ ~U003C が すでに~streamから消費-済みであると見做す。
◎
Note: This algorithm assumes that a U+003C LESS-THAN SIGN (&lt;) code point has already been consumed from the stream.
</p>

<ol>
	<li>
%名前 ~LET `&lt;^l（ 1 個の ~U003C ）
◎
Let name initially be a string containing a single U+003C LESS-THAN SIGN (&lt;) code point.
</li>
	<li>
<p>
%~stream から`次入力~符号位置を繰り返し消費する$：
◎
Repeatedly consume the next input code point:
</p>
		<dl class="switch">
			<dt>~U003E</dt>
			<dd>
				<ol>
					<li>
%名前 に`現入力~符号位置$を付加する
</li>
					<li>
~IF［
%名前 は`~supportされる構文~成分~名$である
］
⇒
~RET %名前
</li>
					<li>
~RET `失敗^i
</li>
				</ol>
◎
Append the code point to name. If name is a supported syntax component name, return name. Otherwise return failure.
</dd>

			<dt>`名前~符号位置$</dt>
			<dd>
%名前 に`現入力~符号位置$を付加する
◎
Append the code point to name.
</dd>

			<dt>他全部</dt>
			<dd>
~RET `失敗^i
◎
Return failure.
</dd>
		</dl>
	</li>
</ol>

</div>

			</section>
		</section>
	</section>
	<section id="behavior-of-custom-properties">
<h2 title="Behavior of Custom Properties">4. ~custom~propの挙動</h2>

		<section id="animation-behavior-of-custom-properties">
<h3 title="Animation Behavior of Custom Properties">4.1. ~animationにおける~custom~propの挙動</h3>


<p class="note">注記：
［
`css3-animations$r ／ `css3-transitions$r
］に定義されるように，~custom~propを参照する［
~animation ／ 遷移
］を指定することもアリである。
◎
Note: As defined by [css3-animations] and [css3-transitions], it is possible to specify animations and transitions that reference custom properties.
</p>


<p>
［
~animation／遷移
］から参照される~custom~propは、その型に定義される方式で補間される。
その型が `+^css を伴う~listとして定義されている場合、単純~listとして補間される。
`css3-transitions$r
◎
When referenced by animations and transitions, custom properties interpolate in a manner defined by their types. If their type is defined as a list with "+", it’s interpolated as a simple list [css3-transitions].
</p>

<p>
補間の始値と終値の型が合致する場合、それらは `css3-animations$r に指定されるように補間される。
他の場合、補間は既定の［
50% の所で切り替わるふるまい
］に~fall-backする。
`css3-animations$r
◎
If the start and end of an interpolation have matching types, then they will interpolate as specified in [css3-animations]. Otherwise, the interpolation falls back to the default 50% flip described in [css3-animations].
</p>


<p class="issue">
~custom~prop上の~animationにより補間された中間~結果は、その値を表現している~token~streamを生成-可能になるモノトスル。
相互運用能の課題を避けるため、これが各 実装~間で標準になることを確保するべきである。
◎
Intermediate interpolated results of animations on custom properties must be able to generate a token stream representing their value. We should ensure that this is standard across implementations to avoid interop issues.
</p>

		</section>
		<section id="conditional-rules">
<h3 title="Conditional Rules">4.2. 条件付き規則</h3>


<p>
［
`supports$at 規則 ／
`supports(conditionText)$m ~method
］の挙動は `css-variables$r に指定される。
◎
@supports rules and the supports(conditionText) method behave as specified in [css-variables].
</p>


<p class="note">注記：
言い換えれば，所与の~custom~propが ある値を~supportするかどうか決定する目的においては、~custom~prop用に登録した型は無視され， 1 個~以上の~tokenからなるどの値も妥当と見なされる。
◎
Note: In other words, for the purpose of determining whether a value is supported by a given custom property, the type registered for the custom property is ignored and any value consisting of at least one token is considered valid.
</p>

		</section>
		<section id="relative-urls">
<h3 title="Relative URLs">4.3. 相対~URL</h3>

<p>
登録された~custom~prop内に現れる相対~URL値は、 `css3-values$r に従って全部的~URLに解決される。
◎
Relative URL values that appear in registered custom properties are resolved to full URLs as described in [css3-values].
</p>

<div class="example">
<p>
~URLは，それが現れる~stylesheetの基底~URLに対して解決されるので、複数の相対~URLが異なる基底~URLに対して解決される結果になり得る
— それらが同じ【名前の】~prop内に現れようが。
◎
Because URLs resolve against the base URL of the stylesheet they appear in, we can end up with multiple relative URLs that resolve against different base URLs, even though they appear in the same property.
</p>

<p>
例えば
`--url-foo^p, `--url-bar^p
は、ともに，構文に `url$t を与えて登録された~custom~propとする。
ある~stylesheetが `/style/foo/foo.css^c にあって：
◎
For example, suppose --url-foo and --url-bar are registered custom properties with &lt;url&gt; syntax, and that we have a stylesheet at /style/foo/foo.css:
</p>

<pre class="lang-css">
div {
  --url-foo: url("foo.png");
}
</pre>

<p>
別の~stylesheetが `/style/bar/bar.css^c にあって：
◎
and another stylesheet at /style/bar/bar.css
</p>

<pre class="lang-css">
div {
  --url-bar: url("bar.png");
}
</pre>

<p>
文書は， `/index.html^c にあるとする：
◎
and finally a document at /index.html:
</p>

<pre class="lang-markup">
&lt;link href="/style/foo/foo.css" rel="stylesheet" type="text/css"&gt;
&lt;link href="/style/bar/bar.css" rel="stylesheet" type="text/css"&gt;
&lt;div style="background-image: var(--url-foo), var(---url-bar);"&gt;
&lt;/div&gt;
</pre>

<p>
ここでは、［
`var(--url-foo)^v ／ `var(--url-bar)^v
］参照は［
`/style/foo^c ／ `/style/bar^c
］に対して解決される~URLを生産することになる。
◎
Here, the var(--url-foo) reference would produce a URL that resolves against /style/foo, and the var(--url-bar) reference would produce a URL that resolves against /style/bar.
</p>

</div>

		</section>
		<section id="fallbacks-in-var-references">
<h3 title="Fallbacks in var() references">4.4. `var^f 参照における~fallback</h3>

<p>
`var$f 関数を利用する登録-済み~custom~propへの参照は，~fallbackを供してもヨイが、~fallback値は，参照-先の~custom~propの`構文~記述子$に合致しなければナラナイ
— さもなければ、宣言は`算出d値の時点で無効$になるとする。
◎
References to registered custom properties using the var() function may provide a fallback. However, the fallback value must match the syntax descriptor of the custom property being referenced, otherwise the declaration is invalid at computed-value time.
</p>

<p class="note">注記：
これは、~fallbackが利用されるかどうかに関わらず，適用される。
◎
Note: This applies regardless of whether or not the fallback is being used.
</p>

		</section>
		<section id="substitution">
<h3 title="Substitution">4.5. 代用</h3>

<p>
登録-済み~custom~propの値は、未登録な~custom~propと同様に，別の値の中の `var$f 関数を代用し得る。
しかしながら，登録-済み~custom~propは、その
<a href="#calculation-of-computed-values">算出d値</a>
として代用される
— その値を生産するときに利用される元の~token列ではなく。
◎
Like unregistered custom properties, the value of a registered custom property can be substituted into another value with the var() function. However, registered custom properties substitute as their computed value, rather than the original token sequence used to produce that value.
</p>

<p>
`var$f 関数のうち，登録-済み~custom~propを参照するものは、
`等価な~token列@
— 次の結果の文字列を`~token化$して生産される~token列 —
に置換するモノトスル
⇒
`~CSS値を直列化する$( ~custom~propの算出d値 )
◎
Any var() function that references a registered custom property must be replaced with an equivalent token sequence, which is equal to the token sequence that would have been produced by serializing the computed value, and tokenizing the resulting string.
</p>

<div class="example">

<p>
~custom~prop `--x^p は `length$t 構文で登録されていて， `--y^p は未登録な~custom~propとする。
◎
Suppose that --x is registered with &lt;length&gt; syntax, and that --y is an unregistered custom property.
</p>

<pre class="lang-css">
div {
  font-size: 10px;
  --x: 8em;
  --y: var(--x);
}
</pre>

<p>
`--x^p の算出d値 （を直列化した結果）は `80px^l になるので、
`--y^p の算出d値は，次の順の~token列になる
⇒＃
`whitespace-token$t,
`80^v を値に伴う `dimension-token$t,
単位 `px^u
◎
Because the computed value of --x (when serialized) is "80px", the computed value of --y is: &lt;whitespace-token&gt; followed by &lt;dimension-token&gt; with a value of 80 and unit px.
</p>

</div>

		</section>
	</section>
	<section id="examples">
<h2 title="Examples">5. 例</h2>

		<section class="example">
<h3 title="Example 1: Using custom properties to add animation behavior">5.1. ~custom~propを利用して~animationにおける挙動を追加する例</h3>

<pre class="lang-markup">
&lt;script&gt;
CSS.registerProperty({
  name: "--stop-color",
  syntax: "&lt;color&gt;",
  inherits: false,
  initialValue: "rgba(0,0,0,0)"
});
&lt;/script&gt;

&lt;style&gt;

.button {
  --stop-color: red;
  background: linear-gradient(var(--stop-color), black);
  transition: --stop-color 1s;
}

.button:hover {
  --stop-color: green;
}

&lt;/style&gt;
</pre>



		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

<p>
この仕様に与える特色機能により導入される，既知の~security上の課題は無い。
◎
There are no known security issues introduced by these features.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">7. ~privacyの考慮点</h2>


<p>
この仕様に与える特色機能により導入される，既知の~privacy上の課題は無い。
◎
There are no known privacy issues introduced by these features.
</p>
	</section>

</main></div>

