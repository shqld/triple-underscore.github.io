<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Properties and Values API Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};

	PAGE_DATA.words_table1 += PAGE_DATA.unicode_map
	.replace( /\n(\w+):(.+)/g, function(t0, t1, t2){
		return(
`\nU${t1}:<span class="code-point">U+${t1}</span> <span class="cp-name">${t2}</span> (<code>&#x${t1};</code>)`
		);
	});
	delete PAGE_DATA.unicode_map

	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'issue':
	return(
`<a href="https://github.com/w3c/css-houdini-drafts/issues/${key}">issue#${key}</a>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>


<script type="text/plain" id="_source_data">

●●options
spec_title:CSS Properties and Values API Level 1
spec_date:2019-07-25
trans_update:2019-07-27
source_checked:180703
original_url:https://drafts.css-houdini.org/css-properties-values-api/
	abbr_url:CSSPV1
page_state_key:CSS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2019,use
trans_1st_pub:2018-05-12


●●class_map
p:property
d:descriptor
v:value
u:unit
f:func
t:type
u:unit
at:at-rule
css:css
e:element
a:attr
at:at-rule
E:error
sl:js-slot
U:code-point

●●tag_map
p:code
d:code
f:code
u:code
v:code
t:var
at:code
I:code
m:code
mD:code
E:code
e:code
u:code
a:code
css:code
c:code
sl:span
U:span
i:i

●●original_id_map

●●link_map
	●IDL
Exposed:~WEBIDL#Exposed

DOMString:~WEBIDL#idl-DOMString
CSSOMString:~CSSOM1#cssomstring
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short

E.InvalidModificationError:~WEBIDL#invalidmodificationerror
E.SyntaxError:~WEBIDL#syntaxerror

I.CSS:~CSSOM1#namespacedef-css
I.Document:~DOM4#document
I.PropertyDefinition:#dictdef-propertydefinition
I.CSSStyleValue:~CSSTOM1#cssstylevalue
I.CSSPropertyRule:#csspropertyrule
I.CSSRule:~CSSOM1#cssrule
I.PropertyDescriptor:#dictdef-propertydescriptor

sl.registeredPropertySet:#dom-window-registeredpropertyset-slot
	sl.associatedProperty:~CSSTOM1#dom-cssstylevalue-associatedproperty-slot

m.inherits:#dom-propertydefinition-inherits
m.initialValue:#dom-propertydefinition-initialvalue
m.name:#dom-propertydefinition-name
m.registerProperty:#dom-css-registerproperty
m.supports:~CSSCOND#dom-css-supports
m.~supports0:~CSSCOND#dom-css-supports-conditiontext
m.syntax:#dom-propertydefinition-syntax
m.setProperty:~CSSOM1#dom-cssstyledeclaration-setproperty
m.PROPERTY_RULE:#dom-cssrule-property_rule

m.paintWorklet:~CSSPAINTAPI#dom-css-paintworklet
m.registerPaint:~CSSPAINTAPI#dom-paintworkletglobalscope-registerpaint
m.addModule:~WORKLETS1#dom-worklet-addmodule

mD.name:#dom-propertydescriptor-name
mD.inherits:#dom-propertydescriptor-inherits
mD.initialValue:#dom-propertydescriptor-initialvalue
mD.syntax:#dom-propertydescriptor-syntax

	#dom-css-registerproperty-definition-definition
	#dom-css-unregisterproperty-name-name


	●CSS
at.supports:~CSSCOND#at-ruledef-supports
at.property:#at-ruledef-property
d.inherits:#descdef-property-inherits
d.initial-value:#descdef-property-initial-value
d.syntax:#descdef-property-syntax

p.color:~CSSCOLOR#propdef-color
p.font-size:~CSSFONTS#propdef-font-size
p.line-height:~CSS2VISUDET#propdef-line-height
p.transform:~TRANSFORM#propdef-transform

u.em:~CSSVAL#em
u.ex:~CSSVAL#ex
u.cap:~CSSVAL#cap
u.ch:~CSSVAL#ch
u.ic:~CSSVAL#ic
u.lh:~CSSVAL#lh
u.rem:~CSSVAL#rem
u.rlh:~CSSVAL#rlh

t.angle:~CSSVAL#angle-value
t.calc():~CSSVAL#funcdef-calc
t.color:~CSSCOLOR#typedef-color
	t.color:~CSSWGcss-color-3/#valuea-def-color
t.declaration-list:~CSSSYN#typedef-declaration-list
t.ident:~CSSVAL#typedef-ident
t.custom-ident:~CSSVAL#identifier-value
t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.dimension-token:~CSSSYN#typedef-dimension-token
t.declaration-value:~CSSSYN#typedef-declaration-value
t.image:~CSSIMAGE#typedef-image
t.integer:~CSSVAL#integer-value
t.length:~CSSVAL#length-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.number:~CSSVAL#number-value
t.percentage:~CSSVAL#percentage-value
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.transform-function:~TRANSFORM#typedef-transform-function
t.url:~CSSVAL#url-value
t.ident-token:~CSSSYN#typedef-ident-token
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.transform-list:~TRANSFORM#typedef-transform-list

f.var:~CSSVAR#funcdef-var
f.calc:~CSSVAL#funcdef-calc

	v.green:~CSSCOLOR#valdef-color-green
v.inherit:~CASCADE#valdef-all-inherit
v.unset:~CASCADE#valdef-all-unset
v.red:~CSSCOLOR#valdef-color-red
	RED:~CSSCOLOR#valdef-color-red
	Red:~CSSCOLOR#valdef-color-red

v.revert:~CASCADE#valdef-all-revert
v.blue:~CSSCOLOR#valdef-color-blue
v.black:~CSSCOLOR#valdef-color-black

	<https://github.com/w3c/css-houdini-drafts/issues/118>:https://github.com/w3c/css-houdini-drafts/issues/118

	●用語
独立に算出-可能:#computationally-independent
~custom~propを登録する:#register-a-custom-property

~data型~名:#data-type-name
~data型~名を消費する:#consume-a-data-type-name
量指定済み~data型~名:#pre-multiplied-data-type-name

結合子:#combinator
量指定子:#multipliers

構文~成分:#syntax-component
構文~成分~名:#syntax-component-name
構文~成分を消費する:#consume-a-syntax-component
構文~定義:#syntax-definition
構文~定義を消費する:#consume-a-syntax-definition
~supportされる構文~成分~名:#css-supported-syntax-component-name
構文~文字列:#syntax-string
全称~構文~定義:#universal-syntax-definition
等価な~token列:#equivalent-token-sequence

登録-済み~custom~prop値を具象化する:#reify-a-registered-custom-property-value

	§:#calculation-of-computed-values
	§#syntax-strings

	●用語（ CSS
~CSS全域~keyword:~CSSVAL#css-wide-keywords
~math関数:~CSSVAL#math-function
正準的~単位:~CSSVAL#canonical-unit

~cascade:~CASCADE#cascade
指定d値:~CASCADE#specified-value
算出d値:~CASCADE#computed-value
初期~値:~CASCADE#initial-value

識別子:~CSSVAL#css-identifier

~custom~prop:~CSSVAR#custom-property
算出d値の時点で無効:~CSSVAR#invalid-at-computed-value-time
無効が保証される値:~CSSVAR#guaranteed-invalid-value

~token化:~CSSSYN#tokenization
則って構文解析-:~CSSSYN#css-parse-something-according-to-a-css-grammar
名前~符号位置:~CSSSYN#name-code-point
名前開始~符号位置:~CSSSYN#name-start-code-point
名前を消費する:~CSSSYN#consume-name
現入力~符号位置:~CSSSYN#current-input-code-point
現入力~符号位置を消費し直す:~CSSSYN#reconsume-the-current-input-code-point
次入力~符号位置:~CSSSYN#next-input-code-point
次入力~符号位置を繰返し消費する:~CSSSYN#repeatedly-consume-next-code-point
空白:~CSSSYN#whitespace
識別子から開始して:~CSSSYN#check-if-three-code-points-would-start-an-identifier
	~CSSSYN#would-start-an-identifier
入力~stream:~CSSSYN#input-stream

~CSS値を直列化する:~CSSOM1#serialize-a-css-value

	●用語（ CSS houdini
成分~値~listを具象化する:~CSSTOMR#reify-a-list-of-component-values
数量-値を具象化する:~CSSTOMR#reify-a-numeric-value
変形~関数を具象化する:~CSSTOMR#reify-a-transform-function
変形~listを具象化する:~CSSTOMR#reify-a-transform-list
識別子を具象化する:~CSSTOMR#reify-an-identifier
~CSSStyleValueとして具象化する:~CSSTOMR#reify-as-a-cssstylevalue
画像を具象化する:~CSSTOMR#_reify-image

	●用語（外部
算出d値により:~WANIM#by-computed-value
補間-:~CSSVAL#interpolation

符号位置:~INFRA#code-point
~ASCII大小無視:~INFRA#ascii-case-insensitive
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace

~list:~INFRA#list
構造体:~INFRA#struct
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
文字列:~INFRA#string
長さ:~INFRA#string-length

結付けられている文書:~WINDOW#concept-document-window
現在の大域~obj:~WAPI#current-global-object
	~THROW:~WEBIDL#dfn-throw
~shadow~tree:~DOM4#concept-shadow-tree


●●words_table1
CSSTOMR:css-typed-om-reify-ja.html
CSSPAINTAPI:css-paint-api-ja.html

supports0:supports
●●words_table


	●型／構造
循環依存:dependency cycle:~
辺:edge:~
	辺で結ぶ:add an edge
shadow:

options:::option 集
色:color::~
真:true::~
実数:number::~
名前開始:name-start::~
具象化:reification::~
具象化-:reify::~
CSSStyleValue:

	対応~付けて:matching up
	各~indexごと:index-by-index
	設定し直す:reset

	●処理
前処理-:preprocess:~
	登録-法:registering
	登録-済み:registered
未登録な:unregisterd::未登録の
	登録されていない:unregistered
	被呼出時:called
pipeline:
他全部:anything else:その他
解析済み:parsed::~
現入力:current input::現在の入力
次入力:next input::次の入力
剥ぐ:stripする:~
繰返し:repeatedly::繰り返し
	何もしない:do nothing
	無効が保証される:guaranteed-invalid

	●構文
calc:
	並び:sequence
	〜列:sequence
	区切りの:-separated
式:expression::~
	符号位置ごとに:codepoint-wise
space::::スペース
comma::::カンマ
小文字:lower-case::~
単位:unit::~
無効化-:invalidate::~
量指定子:multiplier::~
量指定済み:pre-multiplied::~
結合子:combinator::~
全称:universal::~
math:
寛容:liberal:~
省略可能:optional:~
形:form:~

	~~対象の:being multiplied-
	-:followed by
	`ident^t:ident
	`px^css :pixel
	`color$t／`color$p:color
	全部的な構文:full breadth
	~~項:clause／item
	`url^f:URL
	直後:immediately followed by／:immediately after
	^i:EOF
	欠落している:missing

	●CSS ／ animation
CSSOM:
For:for:用途
	独立に算出-可能:computationally independent
条件付き:conditional::~
宣言d:declared::宣言
全域:-wide:~
	length-percentage:#1

代用し:substituteし::置き換え
代用され:substituteされ::置き換えられ
代用:substitution::置き換え
数量-:numeric::~
数値:numeric value:~

変形:transform::~
補間-:interpolate::~
補間:interpolation::~
遷移:transition::~

	●仕様
基礎的な:primitive:~
段階:stage:~
包括的:comprehensive:~
拡げる:expandする:~
真似る:resembleする:~

	問わず:regardless
	どちらに〜ようが:regardless of whether
	よって:hence
	よくある:frequently
	-:identically
	-:optionally
	-:precise
	ない限り:so long as
	ほぼ何でも:nearly anything
	しようが:even though
	としても:even if
	-:we
	ので:Therefore

	指定d値になる:as specified
	作者:user
	に従って:as described in
	記され:written
	により制御され:-controlled
	追加して:additional
	加えて:additional
	-:Additional
	利用-可能:usable
	とする:suppose
	結果になる:end up
	補うもの:complementary
	表す:express
	-:means
	より~~優先され:supersed
	〜とする:suppose
	できなくする:prevent
	課される:gain
	気を配る:pay attention
	満たされ:met
	^en:concept-defining

	●未分類
塗り:paint::~
勝つ:winする:~

	組入れる:re-incorporated into
	現れ-:appear
	-:down the DOM tree
	-:gain
	-:get#1
	`class^a:class#1
	:against
	:become
	~method:function
	近く:closely
	成す:contained in
	-:re
	-:passing
	-:repetition
	単位による:expressed in
	転換-:turned into
	時点:time
	〜時:-time
	になる:become
	-:get 〜ed
	後で〜:later-〜

	●指示語
	:one
	0 〜 1 個の:optional／:optionally
	すでに:already-
	その:those
	もの／何ものも:anything
	他のもの:anything else
	も:neither is,
	等々:any other casing variants
	上に挙げた:preceding
	一方で:while
	とり:take
	残された唯一の:left only
	以上:at least
	それまで:previously
	依然として／〜としても:still
	および:as well as
	に対して:against
	唯一の:only
	間で:across
	ごく:very
	-:finally
	新たな:initially empty
	以降の各節:remainder of this chapter
	自体:on its own
	より大きい:larger
	何らかの:whatever

●●unicode_map
0023:NUMBER SIGN
002A:ASTERISK
002B:PLUS SIGN
003C:LESS-THAN SIGN
003E:GREATER-THAN SIGN
005C:REVERSE SOLIDUS
007C:VERTICAL LINE

●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-CONDITIONAL-3]
    CSS Conditional Rules Module Level 3 URL: https://www.w3.org/TR/css3-conditional/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-TYPED-OM-1]
    Shane Stephens; Tab Atkins Jr.; Naina Raisinghani. CSS Typed OM Level 1. 10 April 2018. WD. URL: https://www.w3.org/TR/css-typed-om-1/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[CSS3-VALUES]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. Web Animations. 11 October 2018. WD. URL: https://www.w3.org/TR/web-animations-1/ 
[WebIDL]
    Boris Zbarsky. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 March 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-LAYOUT-API-1]
    Greg Whitworth; et al. CSS Layout API Level 1. 12 April 2018. WD. URL: https://www.w3.org/TR/css-layout-api-1/ 
[CSS-PAINT-API-1]
    Ian Kilpatrick; Dean Jackson. CSS Painting API Level 1. 9 August 2018. CR. URL: https://www.w3.org/TR/css-paint-api-1/ 
[CSS3-ANIMATIONS]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS3-TRANSITIONS]
    David Baron; et al. CSS Transitions. 11 October 2018. WD. URL: https://www.w3.org/TR/css-transitions-1/ 


●●trans_metadata
<p>
~THIS_PAGEは、 W3C により
編集者草案として公開された
<a href="~SPEC_URL">CSS Properties and Values API Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://drafts.css-houdini.org/css-properties-values-api-1/ 

最新 発行バージョン
	https://www.w3.org/TR/css-properties-values-api-1/ 

以前のバージョン
	https://www.w3.org/TR/2017/WD-css-properties-values-api-1-20171109/ 
	http://www.w3.org/TR/2016/WD-css-properties-values-api-1-20160607/ 

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bcss-properties-values-api%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[css-properties-values-api] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)
編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="mailto:daniel.glazman@disruptive-innovations.com">Daniel Glazman</a>
	<a href="mailto:stearns@adobe.com">Alan Stearns</a>
	<a href="mailto:gwhit@microsoft.com">Greg Whitworth</a>
前任編集者
	<a href="mailto:shanestephens@google.com">Shane Stephens</a>
	<a href="mailto:esprehn@chromium.org">Elliot Sprehn</a>

最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/labels/css-properties-values-api-1">GitHub Issues</a>
commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master/css-properties-values-api

</script>


</head><body>

<header>

	<hgroup>
<h1 id="title">CSS Properties and Values API Level 1</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、新たな~CSS~propを登録するための~APIを定義する。
この~APIを利用して登録された~propは、［
型, 継承の挙動, 初期~値
］を定義する構文解析-構文を伴って供される。
◎
This CSS module defines an API for registering new CSS properties. Properties registered using this API are provided with a parse syntax that defines a type, inheritance behaviour, and an initial value.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSは、~web文書の［
~layout, 塗り, 挙動
］を改変するために操作できる~propたちが成す，包括的な集合を定義している。
しかしながら、~web作者が，この集合に~propを追加して拡張したいと望むこともよくある。
◎
CSS defines a comprehensive set of properties that can be manipulated in order to modify the layout, paint, or behaviour of a web document. However, web authors frequently wish to extend this set with additional properties.
</p>

<p>
`css-variables$r は、作者が制御する~propを定義するための基礎的な手段を供しているが、これらの~propは、常に~token~listを値にとり, 常に継承されるモノトスル。
加えて、それが影響iし得るのは，文書の~layoutや塗りに限られる
— `var^f 参照を介して他の~propの値を組入れることにより。
◎
[css-variables] provides primitive means for defining user-controlled properties, however these properties always take token lists as values, must always inherit, and can only impact document layout or paint by being re-incorporated into the value of other properties via a var() reference.
</p>

<p>
この仕様は、 `css-variables$r を拡張し，［
値~型, 初期~値, 定義-済みの継承の挙動
］を備える~propを登録できるようにする。
◎
This specification extends [css-variables], allowing the registration of properties that have a value type, an initial value, and a defined inheritance behaviour.
</p>

<p>
この仕様は［
`css-paint-api-1$r ／ `css-layout-api-1$r
］を補うものであり、~custom~propが［
塗り／~layout
］の挙動に直に影響iできるようにする。
◎
This specification is complementary to [css-paint-api-1] and [css-layout-api-1], which allow custom properties to directly impact paint and layout behaviours respectively.
</p>

	</section>
	<section id="registering-custom-properties">
<h2 title="Registering custom properties">2. ~custom~propの登録-法</h2>

<pre class="idl">
dictionary `PropertyDefinition$I {
  required `DOMString$ `name$m;
           `DOMString$ `syntax$m = "*";
  required `boolean$   `inherits$m;
           `DOMString$ `initialValue$m;
};

partial namespace `CSS$I {
  void `registerProperty$m(`PropertyDefinition$I %definition);
};
</pre>

<p>
加えて，各 `Document$I ~objは、
`registeredPropertySet@sl
内部~slotも持つ
— それは、登録-済み~custom~propについて述べる~recordたちが成す集合を~~保持する。
◎
Additional, the Document object gains a new [[registeredPropertySet]] private slot, which is a set of records that describe registered custom properties.
</p>

		<section id="the-propertydefinition-dictionary">
<h3 title="The PropertyDefinition dictionary">2.1. `PropertyDefinition^I 辞書</h3>

<p id="propertydefinition">
`PropertyDefinition@I
辞書は、作者が指定した［
~custom~prop用の環境設定~options
］を表現する
— それは、次の~memberからなる：
◎
A PropertyDefinition dictionary represents author-specified configuration options for a custom property. PropertyDefinition dictionaries contain the following members:
</p>

<dl class="idl-def">
	<dt>`name@m
◎
name, of type DOMString
</dt>
	<dd>
定義する~custom~propの名前を与える。
◎
The name of the custom property being defined.
</dd>

	<dt>`syntax@m
◎
syntax, of type DOMString, defaulting to "*"
</dt>
	<dd>
この~custom~propをどう構文解析するかを表現する文字列を与える。
◎
A string representing how this custom property is parsed.
</dd>

	<dt>`inherits@m
◎
inherits, of type boolean
</dt>
	<dd>
この~custom~propは［
継承するべきならば ~T ／
他の場合は ~F
］。
◎
True if this custom property should inherit down the DOM tree; False otherwise.
</dd>

	<dt>`initialValue@m
◎
initialValue, of type DOMString
</dt>
	<dd>
この~custom~propの初期~値を与える。
◎
The initial value of this custom property.
</dd>
</dl>

		</section>
		<section id="the-registerproperty-function">
<h3 title="The registerProperty() function">2.2. `registerProperty()^m ~method</h3>

<dl class="idl-def">
	<dt>`registerProperty(definition)@m</dt>
	<dd>
%definition に供された環境設定~optionsに則って~custom~propを登録する。
◎
The registerProperty(PropertyDefinition definition) method registers a custom property according to the configuration options provided in definition.＼
</dd>
	<dd>
被呼出時には、次を実行するモノトスル
⇒
`~custom~propを登録する$( 次に挙げる引数 )
⇒＃
%definition の `name$m ~memberの値,
%definition の `syntax$m ~memberの値,
%definition の `inherits$m ~memberの値,
%definition の `initialValue$m ~memberの値
◎
When it is called, it executes the register a custom property algorithm, passing the options in its definition argument as arguments of the same names.
</dd>
</dl>

<div class="algorithm">

<p>
`~custom~propを登録する@
ときは、所与の
( 文字列 %名前,
文字列 %構文,
真偽値 %継承する,
文字列 %初期~値
)
に対し，次の手続きを実行する：
◎
To register a custom property with name being a string, and optionally syntax being a string, inherits being a boolean, and initialValue being a string, execute these steps:
</p>

<ol>
	<li>
%~prop集合 ~LET `現在の大域~obj$に`結付けられている文書$の `registeredPropertySet$sl ~slot値
◎
Let property set be the value of the current global object’s associated Document’s [[registeredPropertySet]] slot.
</li>
	<li>
%解析済み名 ~LET %名前 を `custom-property-name$t として構文解析した結果
◎
Attempt to parse name as a &lt;custom-property-name&gt;.＼
</li>
	<li>
~IF［
%解析済み名 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If this fails, throw a SyntaxError and exit this algorithm.
◎
Otherwise, let parsed name be the parsed value.
</li>
	<li>
~IF［
%~prop集合 内に［
~prop名 ~EQ %解析済み名
］なる~recordは在る
］
⇒
~THROW `InvalidModificationError$E
◎
If property set already contains an entry with parsed name as its property name (compared codepoint-wise), throw an InvalidModificationError and exit this algorithm.
</li>
	<li>
%構文~定義 ~LET `構文~定義を消費する$( %構文 )
◎
Attempt to consume a syntax definition from syntax.＼
</li>
	<li>
~IF［
%構文~定義 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If it returns failure, throw a SyntaxError. Otherwise, let syntax definition be the returned syntax definition.
</li>
	<li>
%解析済み初期~値 ~LET `失敗^i
◎
↓</li>
	<li>
<p>
~IF［
%構文~定義 は`全称~構文~定義$である
］：
</p>
		<ol>
			<li>
~IF［
%初期~値 ~EQ ε
］
⇒
%解析済み初期~値 ~SET 空
— これは［
`css-variables$r に定義される~custom~propの “既定の” 初期~値
］として扱うモノトスル。
◎
If syntax definition is the universal syntax definition, and initialValue is not present, let parsed initial value be empty. This must be treated identically to the "default" initial value of custom properties, as defined in [css-variables]. Skip to the next step of this algorithm.
</li>
			<li>
~ELSE
⇒
%解析済み初期~値 ~SET %初期~値 を `declaration-value$t に`則って構文解析-$した結果
◎
Otherwise, if syntax definition is the universal syntax definition, parse initialValue as a &lt;declaration-value&gt;. If this fails, throw a SyntaxError and exit this algorithm. Otherwise, let parsed initial value be the parsed result. Skip to the next step of this algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%初期~値 ~NEQ ε
］：
◎
Otherwise, if initialValue is not present, throw a SyntaxError and exit this algorithm.
</p>
		<ol>
			<li>
%解析済み初期~値 ~SET %初期~値 を %構文~定義 に`則って構文解析-$した結果
◎
Otherwise, parse initialValue according to syntax definition.＼
</li>
	<li>
~IF［
%解析済み初期~値 ~NEQ `失敗^i
］~AND［
%解析済み初期~値 は`独立に算出-可能$でない
］
⇒
%解析済み初期~値 ~SET `失敗^i
◎
If this fails, throw a SyntaxError and exit this algorithm.
◎
Otherwise, let parsed initial value be the parsed result. If parsed initial value is not computationally independent, throw a SyntaxError and exit this algorithm.
</li>
		</ol>
	</li>
	<li>
~IF［
%解析済み初期~値 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
↑</li>
	<li>
%~prop集合 に次のようにされた`構造体$を`付加する$set
<!-- 同等性？ -->
⇒＃
~prop名 ~SET %解析済み名,
構文 ~SET %構文~定義,
初期~値 ~SET %解析済み初期~値,
継承-~flag ~SET %継承する
◎
Set inherit flag to the value of inherits.
◎
Let registered property be a struct with a property name of parsed name, a syntax of syntax definition, an initial value of parsed initial value, and an inherit flag of inherit flag. Append registered property to property set.
</li>
</ol>

</div>

<p>
~prop値は、次に挙げるもののみを利用して算出d値に変換できるならば
`独立に算出-可能@
とされる
⇒＃
要素~上の~propの値,
~CSSにより変更し得ない “大域的な” 情報
◎
A property value is computationally independent if it can be converted into a computed value using only the value of the property on the element, and "global" information that cannot be changed by CSS.
</p>

<div class="example">

<p>
例えば `5px^v は、`独立に算出-可能$になる
— それを算出d値に変換した結果は ~~元のままなので。
同様に，`1in^v も、`独立に算出-可能$になる
— 算出d値に変換するときには，［
`1in^v は `96px^v である
］という “大域的な知識” のみに依拠し、~CSSにおける何ものも，それを［
改める／調整する
］ことはないので。
◎
For example, 5px is computationally independent, as converting it into a computed value doesn’t change it at all. Similarly, 1in is computationally independent, as converting it into a computed value relies only on the "global knowledge" that 1in is 96px, which can’t be altered or adjusted by anything in CSS.
</p>

<p>
他方 `3em^v は`独立に算出-可能$でない
— それは、要素（または要素の親）上の `font-size$p 値に依拠するので。
`var$f 関数を伴う値も`~custom~prop$の値に依拠するので~~同様になる。
◎
On the other hand, 3em is not computationally independent, because it relies on the value of font-size on the element (or the element’s parent). Neither is a value with a var() function, because it relies on the value of a custom property.
</p>

</div>

<p>
所与の型を伴う~custom~propが登録されたとき、その~prop用の指定d値を算出d値に転換する処理-は，選定された型により全部的に定義される
— <a href="#calculation-of-computed-values">§ 算出d値の計算</a>
にて述べるように。
◎
When a custom property is registered with a given type, the process via which specified values for that property are turned into computed values is defined fully by the type selected, as described in § 2.3 Calculation of Computed Values.
</p>

<p class="note">注記：
将来には、~propを未登録にする仕方も追加され得る。
◎
Note: A way to unregister properties may be added in the future.
</p>

<p>
~custom~propの登録は、いかなる仕方でも，`~cascade$に影響しないモノトスル。
登録された~prop用に指定した構文を問わず、`~custom~prop$は，構文解析-時点では 通常通りほぼ何でも受容するように構文解析される。
しかしながら，登録された`~custom~prop$に対する`指定d値$が 登録した構文に違反する場合、~propは`算出d値の時点で無効$になる（したがって，登録した初期~値に設定し直される）。
◎
Registering a custom property must not affect the cascade in any way. Regardless of what syntax is specified for a registered property, at parse time it is still parsed as normal for a custom property, accepting nearly anything. If the specified value for a registered custom property violates the registered syntax, however, the property becomes invalid at computed-value time (and thus resets to the registered initial value).
</p>

<div class="example">

<p>
既定では、一連の~token並びとして構文解析できる どの~custom~prop宣言も妥当になる。
よって，次の~stylesheetによる結果は：
◎
By default, all custom property declarations that can be parsed as a sequence of tokens are valid. Hence, the result of this stylesheet:
</p>

<pre class="lang-css">
.thing {
  --my-color: green;
  --my-color: url("not-a-color");
  color: var(--my-color);
}
</pre>

<p>
`class^a `thing^l を伴う要素の `color$p ~propは、 `inherit$v に設定される
— 2 個目の `--my-color^p 宣言は 構文解析-時に 1 個目のものを上書きし（両者とも妥当である）、
`color$p ~prop内の `var$f 参照は `算出d値の時点で無効$と見出されるので（ `url("not-a-color")^v は `color$t でないので）。
~CSS~pipelineのこの段階（算出d値の時点）で可用な~fallbackは，~propの初期~値しかなく、
`color$p の事例では `inherit$v になる。
利用-可能な妥当な値は他にもあるが（ `green^v ）、
`url^f がより~~優先されるので，構文解析-時に除去される。
◎
is to set the color property of elements of class "thing" to inherit. The second --my-color declaration overrides the first at parse time (both are valid), and the var() reference in the color property is found to be invalid at computed-value time (because url("not-a-color") is not a color). At this stage of the CSS pipeline (computation time), the only available fallback is the initial value of the property, which in the case of color is inherit. Although there was a valid usable value (green), this was removed during parsing because it was superseded by the URL.
</p>

<p>
次を~callした場合：
◎
If we call:
</p>

<pre class="lang-javascript">
CSS.`registerProperty$m({
  name: "--my-color",
  syntax: "&lt;color&gt;",
  initialValue: "black",
  inherits: false
});
</pre>

<p>
この登録が上の~stylesheetを構文解析する前, 後どちらに生じようが、構文解析が有意に変化することはない。
登録が生じたときの，唯一の相違は：
代わりに `--my-color^p ~propが`算出d値の時点で無効$になり、その初期~値 `black$v に設定される。
それから、 `color$p が妥当に `black$v に設定される
— `算出d値の時点で無効$にされ， `inherit$v になるのではなく。
◎
the parsing doesn’t significantly change, regardless of whether the registration occurs before or after the stylesheet above. The only difference is that it’s the --my-color property that becomes invalid at computed-value time instead and gets set to its initial value of black; then color is validly set to black, rather than being invalid at computed-value time and becoming inherit.
</p>

</div>

		</section>
		<section id="calculation-of-computed-values">
<h3 title="Calculation of Computed Values">2.3. 算出d値の計算</h3>

<p>
~custom~propの構文は、その~prop用に［
指定d値から算出d値を生成する方法
］を全部的に決定する。
◎
The syntax of a custom property fully determines how computed values are generated from specified values for that property.
</p>

<p>
`~CSS全域~keyword$（ `revert$v も含む）が生成する算出d値は、
`css3-values$r, `css-cascade-4$r
に従う。
他の場合：
◎
The CSS-wide keywords and revert generate computed values as described in [css3-values] and [css-cascade-4] respectively. Otherwise:
</p>

<ul>
	<li>
`length^t 値~用の算出d値は、 `px^css 単位による絶対~長さになる。
◎
For &lt;length&gt; values, the computed value is the absolute length expressed in pixels.
</li>
	<li>
<p>
`length-percentage^t 値~用の算出d値は、次のいずれかになる：
◎
For &lt;length-percentage&gt; values, the computed value is one of the following:
</p>

		<ul>
			<li>
指定d値は長さ単位のみ包含する場合
⇒
算出d値は `px^css 単位による絶対~長さになる。
◎
if the specified value contains only length units, the computed value is the absolute length expressed in pixels.
</li>
			<li>
指定d値は百分率のみを包含する場合
⇒
算出d値は単純な百分率になる。
◎
if the specified value contains only percentages, the computed value is a simple percentage.
</li>
			<li>
他の場合
⇒
算出d値は［
`px^css 単位による絶対~長さ, 百分率~値
］を包含している `calc$f 式になる。
◎
otherwise, the computed value is a calc expression containing an absolute length expressed in pixels, and a percentage value.
</li>
		</ul>
	</li>
	<li>
`color^t 値~用の算出d値は、
`CSS-COLOR-4$r による
<a href="~CSSCOLOR#resolving-color-values">色~値の解決-法</a>
に従う。
◎
For &lt;color&gt; values, the value is computed as described in CSS Color 4 §4 Resolving Color values.
</li>
	<li>
［
`angle^t ／
`time^t ／
`resolution^t
］値~用の算出d値は、その`正準的~単位$に~~換算した結果になる
— 値が `calc$f 式の場合†は `CSS-VALUES-4$r に
<a href="~CSSVAL#calc-computed-value">従って評価される</a>
。
【†他の`~math関数$については、触れられていない。他所の `calc^f についても同様。】
◎
For &lt;angle&gt;, &lt;time&gt; and &lt;resolution&gt; values, the computed value is the value expressed in its canonical unit, with calc() expressions evaluated as described in CSS Values.
</li>
	<li>
［
`custom-ident^t ／
`ident^t ／
`*^l
］値~用の算出d値は、指定d値になる。
◎
For &lt;custom-ident&gt;, ident, or "*" values, the computed value is as specified.
</li>
	<li>
<p>
`url^t 値~用の算出d値は、次のいずれかになる：
◎
For &lt;url&gt; values, the computed value is one of the following:
</p>
		<ul>
			<li>
~URLは相対~URLである場合、算出d値は `css3-values$r に従って絶対~URLに解決される。
◎
if the URL is a relative URL, the computed value is the resolved absolute URL as described in [css3-values].
</li>
			<li>
他の場合、算出d値は指定d値になる。
◎
otherwise, the computed value is as specified.
</li>
		</ul>
<p>
`image^t 値~用の算出d値は、値~内に現れる すべての［
相対~URLは `css3-values$r に従って絶対~URLに解決される／
長さは算出d値に解決される
］ことを除いて，指定d値になる。
◎
For &lt;image&gt; values, the computed value is as specified, except that relative URLs that appear in the value are resolved to absolute URLs as described in [css3-values], and all lengths are resolved to their computed values.
</p>
	</li>
	<li>
<p>
［
`integer^t ／ `number^t ／ `percentage^t
］値~用の算出d値は、次のいずれかになる：
◎
For &lt;integer&gt;, &lt;number&gt; and &lt;percentage&gt; values, the computed value is one of the following:
</p>
		<ul>
			<li>
指定d値は `calc$f 式である場合、それを評価した結果になる。
◎
if the specified value is a calc() expression, the computed value is the evaluated result of that expression.
</li>
			<li>
他の場合、指定d値になる。
◎
otherwise, the computed value is as specified.
</li>
		</ul>
	</li>
	<li>
`transform-function^t 値~用の算出d値は、（ `transform-list^t 内に包含されたものも含め，）指定d値を成すすべての長さ値をそれぞれの算出d値に解決した結果になる。
◎
For &lt;transform-function&gt; values (including those contained in &lt;transform-list&gt; values), the computed value is as specified but with all lengths resolved to their computed values.
</li>
	<li>
［［
`|^l で区切られた何項かからなる`構文~文字列$
］により指定される値
］用の算出d値は、［
指定d値に合致する最初の~~項
］用の計算~規則を適用した結果になる。
◎
For values specified by a syntax string that include "|" clauses, the computed value is given by applying the calculation rules for the first clause that matches to the specified value.
</li>
	<li>
~list値~用の算出d値は、~listを成す各項を算出d値に~~置換した結果になる。
◎
For list values, the computed value is a list of the computed values of the primitives in the list.
</li>
</ul>

		</section>
		<section id="supports">
<h3 title="Registered Properties and @supports">2.4. 登録された~propと `supports^at</h3>

<p>
登録されていない~custom~propは、 `supports$at を介して~testされるときには “常に妥当” になる
— `@supports (--foo: red) {...}^css の様な規則を評価した結果は、~custom~prop用の（ごく寛容な）構文に違反しない限り，常に真になる。
◎
Unregistered custom properties are “always valid” when tested via @supports; a rule like @supports (--foo: red) {...} is always true so long as you don’t violate the (very liberal) syntax for custom properties.
</p>

<p>
~custom~propを登録しても、これが変化することはない。
例えば，ある~custom~propが `syntax: "&lt;color&gt;"^c で登録されたとしても、
`@supports (--foo: 1em) {...}^css
の様な規則は真に評価され，その~styleは適用される。
◎
Registering a custom property does not change this. Even if a custom property is, for example, registered with syntax: "&amp;lt;color&gt;", a rule like @supports (--foo: 1em) {...} will still evaluate as true and apply those styles.
</p>

<p class="note">注記：
これは、登録された~custom~propを構文解析するときの挙動に合致する。
構文に `&lt;color&gt;^l を指定して登録された~custom~prop `--foo^p が，
`--foo: 1em;^css
と記されたとしても、構文解析-時には，依然として妥当として受容されることになる
— が、自動的に`算出d値の時点で無効$になる。
`supports$at は構文解析-時の挙動を~testするので、登録した構文を問わず，すべての値を妥当として受容する。
◎
Note: This matches the parsing behavior of registered custom properties. A registered custom property specified as "&amp;lt;color&gt;" but written as --foo: 1em; will still be accepted as valid at parse-time, but be automatically invalid at computed-value time. As @supports tests parse behavior, it thus also accepts all values as valid regardless of the registered syntax.
</p>

		</section>
		<section id="dependency-cycles">
<h3 title="Dependency cycles via relative units">2.5. 相対~単位を介する循環依存</h3>

<p>
登録された~custom~propは、循環依存の解決にあたり，登録されていない~custom~propと同じ規則に従うが、以下に挙げる追加的な拘束も~~課される:
◎
Registered custom properties follow the same rules for dependency cycle resolution as unregistered custom properties, with the following additional constraints:
</p>

<p>
登録された~custom~propのうち、構文~成分に［
`length$t ／ `length-percentage$t
］を伴うものは：
◎
For any registered custom property with a &lt;length&gt; or &lt;length-percentage&gt; syntax component:
</p>

<ul>
	<li>
~propは［
`em$u ／ `ex$u ／ `cap$u ／ `ch$u ／ `ic$u ／ `lh$u
］単位を包含する場合
⇒
~propと現在の要素の `font-size$p ~propとの間を辺で結ぶ。
◎
If the property contains any of the following units: em, ex, cap, ch, ic, lh; then add an edge between the property and the font-size of the current element.
</li>
	<li>
~propは `lh$u 単位を包含する場合
⇒
~propと現在の要素の `line-height$p ~propとの間を辺で結ぶ。
◎
If the property contains the lh unit, add an edge between the property and the line-height of the current element.
</li>
	<li>
~propは［
`rem$u ／ `rlh$u
］単位を包含する場合
⇒
~propと根~要素の `font-size$p ~propとの間を辺で結ぶ。
◎
If the property contains any of the following units: rem, rlh; then add an edge between the property and the font-size' of the root element.
</li>
	<li>
~propは `rlh$u 単位を包含する場合
⇒
~propと根~要素の `line-height$p ~propとの間を辺で結ぶ。
◎
If the property contains the rlh unit, add an edge between the property and the line-height' of the root element.
</li>
</ul>

<div class="example">
<p>
例えば，次の登録が与えられたとする：
◎
For example, given this registration:
</p>

<pre class="lang-javascript">
CSS.`registerProperty$m({
  name: "--my-font-size",
  syntax: "&lt;length&gt;",
  initialValue: "0px",
  inherits: false
});
</pre>

<p>
次の~styleは、循環依存を生産することになる：
◎
the following will produce a dependency cycle:
</p>

<pre class="lang-css">
div {
  --my-font-size: 10em;
  font-size: var(--my-font-size);
}
</pre>

<p>
`font-size^p は、値 `unset$v が指定されていたかのように挙動することになる。
◎
and font-size will behave as if the value unset was specified.
</p>

</div>

		</section>
	</section>
	<section id="syntax-strings">
<h2 title="Syntax Strings">3. 構文~文字列</h2>

<p>
`構文~文字列@
は、［
登録-済み~custom~propが受容する値~型
］を述べる。
構文~文字列は、`構文~成分~名$, および
0 〜 1 個の［
`量指定子$／`結合子$
］を伴う。
◎
A syntax string describes the value types accepted by a registered custom property. Syntax strings consists of syntax component names, that are optionally multiplied and combined.
</p>

<p>
構文~文字列は、次のいずれかの`構文~定義$に構文解析され得る：
◎
A syntax string can be parsed into a syntax definition, which is either:
</p>

<ul>
	<li>
何個かの`構文~成分$からなる~list
— 各~構文~成分は、
<a href="#supported-names">§ ~supportされる名前</a>
にて指定される対応する値~型を受容する。
◎
A list of syntax components, each of which accept the value types specified in § 3.1 Supported names, or
</li>
	<li>
`全称~構文~定義$（ `*^l ）
— ~~任意の妥当な~token~streamを受容する。
◎
The universal syntax definition (*), which accepts any valid token stream.
</li>
</ul>

<p class="note">注記：
指定された構文を問わず，すべての~custom~propは、`~CSS全域~keyword$を受容して，それらの値を適切に処理する。
◎
Note: Regardless of the syntax specified, all custom properties accept CSS-wide keywords, and process these values appropriately.
</p>

<div class="example">

<p>
例えば，次のものは、どれも妥当な構文~文字列になる：
◎
For example, the following are all valid syntax strings.
</p>

<dl>
	<dt>`&lt;length&gt;^l</dt>
	<dd>
<!-- Any valid 略 -->
長さ値を受容する
◎
accepts length values
</dd>

	<dt>`&lt;length&gt; | &lt;percentage&gt;^l</dt>
	<dd>
［
長さ ／ 百分率／ 百分率を与える~calc式 ／ 長さを与える~calc式
］値を受容するが、［
長さ値, 百分率~値
］の組合nを包含している~calc式は受容しない。
◎
accepts lengths, percentages, percentage calc expressions, and length calc expressions, but not calc expressions containing a combination of length and percentage values.
</dd>

	<dt>`&lt;length-percentage&gt;^l</dt>
	<dd>
［
`&lt;length&gt; | &lt;percentage&gt;^l
］が受容するすべての値, および
長さ値と百分率~値の組合nを包含している~calc式を受容する。
◎
accepts all values that "&lt;length&gt; | &lt;percentage&gt;" would accept, as well as calc expressions containing a combination of both length and percentage values.
</dd>

	<dt>`big | bigger | BIGGER^l</dt>
	<dd>
［
`big^v, `bigger^v, `BIGGER^v
］（いずれも `ident^t ）を受容する。
◎
accepts the ident big, or the ident bigger, or the ident BIGGER.
</dd>

	<dt>`&lt;length&gt;+^l</dt>
	<dd>
1 個~以上の長さ値が成す，~space区切りの~listを受容する。
◎
accepts a space-separated list of length values.
</dd>
	<dt>`*^l</dt>
	<dd>
妥当な どの~token~streamも受容する。
◎
accepts any valid token stream
</dd>
</dl>

</div>

<p class="note">注記：
構文~文字列の内部的な文法は、
<a href="~CSSVAL#value-defs">値~定義~構文</a> `CSS-VALUES-4$r
の下位集合である。
この仕様の将来~levelでは、［
~CSS~propが許容する全部的な構文を，より近く真似る~custom~prop
］も許容するように，許容される文法の複階性を拡げるものと期待されている。
◎
Note: The internal grammar of syntax strings is a subset of the CSS Value Definition Syntax. Future levels of this specification are expected to expand the complexity of the allowed grammar, allowing custom properties that more closely resemble the full breadth of what CSS properties allow.
</p>

<p>
以降の各節では、構文~文字列の内部的な文法を述べる。
◎
The remainder of this chapter describes the internal grammar of the syntax strings.
</p>

		<section id="supported-names">
<h3 title="Supported names">3.1. ~supportされる名前</h3>

<p>
この節は、
`~supportされる構文~成分~名@
および［
結果の`構文~成分$が受容する，その成分~名に対応する型
］を定義する。
◎
This section defines the supported syntax component names, and the corresponding types accepted by the resulting syntax component.
</p>

<dl>
	<dt>`&lt;length&gt;^l</dt>
	<dd>
<!-- Any valid -->
`length$t 値
◎
Any valid &lt;length&gt; value
</dd>

	<dt>`&lt;number&gt;^l</dt>
	<dd>
`number$t 値
◎
&lt;number&gt; values
</dd>

	<dt>`&lt;percentage&gt;^l</dt>
	<dd>
`percentage$t 値
◎
Any valid &lt;percentage&gt; value
</dd>

	<dt>`&lt;length-percentage&gt;^l</dt>
	<dd>
`length$t 値
◎
Any valid &lt;length&gt;＼
</dd>
	<dd>
`percentage$t 値
◎
or &lt;percentage&gt; value,＼
</dd>
	<dd>
`length$t, `percentage$t 成分を組合せている `calc()$t 式
【`~math関数$？】
◎
any valid &lt;calc()&gt; expression combining &lt;length&gt; and &lt;percentage&gt; components.
</dd>

	<dt>`&lt;color&gt;^l</dt>
	<dd>
`color$t 値
◎
Any valid &lt;color&gt; value
</dd>

	<dt>`&lt;image&gt;^l</dt>
	<dd>
`image$t 値
◎
Any valid &lt;image&gt; value
</dd>

	<dt>`&lt;url&gt;^l</dt>
	<dd>
`url$t 値
◎
Any valid &lt;url&gt; value
</dd>

	<dt>`&lt;integer&gt;^l</dt>
	<dd>
`integer$t 値
◎
Any valid &lt;integer&gt; value
</dd>

	<dt>`&lt;angle&gt;^l</dt>
	<dd>
`angle$t 値
◎
Any valid &lt;angle&gt; value
</dd>

	<dt>`&lt;time&gt;^l</dt>
	<dd>
`time$t 値
◎
Any valid &lt;time&gt; value
</dd>

	<dt>`&lt;resolution&gt;^l</dt>
	<dd>
`resolution$t 値
◎
Any valid &lt;resolution&gt; value
</dd>

	<dt>`&lt;transform-function&gt;^l</dt>
	<dd>
`transform-function$t 値
◎
Any valid &lt;transform-function&gt; value
</dd>

	<dt>`&lt;custom-ident&gt;^l</dt>
	<dd>
`custom-ident$t 値
◎
Any valid &lt;custom-ident&gt; value
</dd>

	<dt>
`識別子から開始して$いる並びのうち，
<a href="~CSSSYN#consume-name">名前として消費できる</a>, かつ
`custom-ident$t 生成規則に合致するもの
◎
Any sequence which starts an identifier, can be consumed as a name, and matches the &lt;custom-ident&gt; production
</dt>
	<dd>
その識別子
◎
That identifier
</dd>
	<dd class="note">注記：
`custom-ident$t は、符号位置ごとに比較される。
これは、~UA定義な~CSSにおける通常の挙動（ ~ASCIIに制限され, `~ASCII大小無視$で比較される）と異なる。
なので， `Red^v の様な `ident^t を指定した場合、値 `Red^v は受容されるが， `red^v, `RED^v は合致しない。
~CSS表記規約に合致するためには、 `ident^t は~ASCIIのみに制約した上で，小文字で記すことが推奨される。
◎
Note: &lt;custom-ident&gt;s are compared codepoint-wise with each other; this is different than the normal behavior of UA-defined CSS which limits itself to ASCII and is ASCII case-insensitive. So, specifying an ident like Red means that the precise value Red is accepted; red, RED, and any other casing variants are not matched by this. It is recommended that idents be restricted to ASCII and written in lower-case, to match CSS conventions.
</dd>

	<dt>`&lt;transform-list&gt;^l</dt>
	<dd>
1 個以上の妥当な `transform-function$t 値からなる~list。
これは、 `&lt;transform-function&gt;+^l に等価な，`量指定済み~data型~名$であることに注意。
◎
A list of valid &lt;transform-function&gt; values. Note that "&lt;transform-list&gt;" is a pre-multiplied data type name equivalent to "&lt;transform-function&gt;+"
</dd>
</dl>

<p class="note">注記：
構文~文字列 `*^l は、`全称~構文~定義$を生産する
— それは`構文~成分$ではないので、`量指定子$を付与できないし，他のものと`結合子$で組合できない。
◎
Note: A syntax string of "*" will produce the universal syntax definition, which is not a syntax component. Therefore, "*" may not be multiplied or combined with anything else.
</p>

		</section>
		<section id="multipliers">
<h3 title="The '+' and '#' multipliers">3.2. `+^css, `#^css 量指定子</h3>

<p>
`量指定済み~data型~名$を除き、`構文~成分~名$には，直後に量指定子を付与してもヨイ：
◎
Any syntax component name except pre-multiplied data type names may be immediately followed by a multiplier:
</p>

<dl>
	<dt>~U002B</dt>
	<dd>
~space区切りの~listを指示する。
◎
Indicates a space-separated list.
</dd>

	<dt>~U0023</dt>
	<dd>
~comma区切りの~listを指示する。
◎
Indicates a comma-separated list.
</dd>
</dl>

<div class="example">

<dl>
	<dt>`&lt;length&gt;+^l</dt>
	<dd>
1 個以上の長さ値からなる~space区切りの~listを受容する
◎
accepts a space-separated list of length values
</dd>

	<dt>`&lt;color&gt;#^l</dt>
	<dd>
1 個以上の色~値からなる~comma区切りの~listを受容する
◎
accepts a comma-separated list of color values
</dd>
</dl>
</div>

<p class="note">注記：
量指定子は、~~対象の`構文~成分~名$の直後に現れなければナラナイ。
◎
Note: The multiplier must appear immediately after the syntax component name being multiplied.
</p>

		</section>
		<section id="combinator">
<h3 title="The '|' combinator">3.3. `|^css 結合子</h3>

<p>
`構文~文字列$は、 ~U007C を利用して，複数の`構文~成分~名$を供してもヨイ。
そのような構文~文字列による結果は、複数の`構文~成分$を伴う`構文~定義$になる。
◎
Syntax strings may use U+007C VERTICAL LINE (|) to provide multiple syntax component names. Such syntax strings will result in a syntax definition with multiple syntax components.
</p>

<p>
ある~CSS値を構文解析するときに，複数の`構文~成分$を伴う`構文~定義$が利用される場合、各 構文~成分は，指定された順序で照合される。
◎
When a syntax definition with multiple syntax components is used to parse a CSS value, the syntax components are matched in the order specified.
</p>

<p class="note">注記：
すなわち，構文~文字列として
`red | &lt;color&gt;^l
が与えられた下では、［
値 `red^v と照合したときは、識別子として構文解析する
］ことになる一方，［
値 `blue$v と照合したときは、 `color$t として構文解析する
］ことになる。
◎
Note: That is, given the syntax string "red | &lt;color&gt;", matching the value red against it will parse as an identifier, while matching the value blue will parse as a &lt;color&gt;.
</p>

<div class="example">

<dl>
	<dt>`&lt;length&gt; | auto^l</dt>
	<dd>
［
長さ／ `auto^v
］を受容する
◎
accepts a length, or auto
</dd>

	<dt>`foo | &lt;color&gt;# | &lt;integer&gt;^l</dt>
	<dd>
［
`foo^v ／
1 個以上の色~値からなる~comma区切りの~list ／
1 個の整数
］を受容する
◎
accepts foo, a comma-separated list of color values, or a single integer
</dd>
</dl>
</div>

		</section>
		<section id="parsing-syntax">
<h3 title="Parsing the syntax string">3.4. 構文~文字列の構文解析</h3>

			<section id="parsing-definitions">
<h4 title="Definitions">3.4.1. 定義</h4>

<dl>
	<dt>`~data型~名@</dt>
	<dd>
次の順による`符号位置$並び
⇒＃
~U003C,
0 個以上の`名前~符号位置$,
~U003E
◎
A sequence of code points consisting of a U+003C LESS-THAN SIGN (&lt;), followed be zero or more name code points, and terminated by U+003E GREATER-THAN SIGN (&gt;).
</dd>

	<dt>`量指定済み~data型~名@</dt>
	<dd>
`~data型~名$のうち，［
`量指定子$を伴う別の`構文~成分$を表現するもの
］をすでに含んでいるもの。
◎
A data type name that represents another syntax component with a multiplier already included.
</dd>

	<dt>`構文~成分@</dt>
	<dd>
次のものからなる~obj
⇒
`構文~成分~名$,
0 〜 1 個の`量指定子$
◎
An object consisting of a syntax component name, and an optional multiplier.
</dd>

	<dt>`構文~成分~名@</dt>
	<dd>
次のいずれかを与える`符号位置$並び
⇒＃
`~data型~名$ ／
`custom-ident$t を生産し得るもの
◎
A sequence of code points which is either a data type name, or a sequence that can produce a &lt;custom-ident&gt;.
</dd>

	<dt>`構文~定義@</dt>
	<dd>
1 個以上の`構文~成分$からなる~listが成す~obj。
◎
An object consisting of a list of syntax components.
</dd>

	<dt>`全称~構文~定義@</dt>
	<dd>
妥当な どの~token~streamも受容する，特別な構文~定義。
◎
A special syntax definition which accepts any valid token stream.
</dd>
</dl>

			</section>
			<section id="consume-syntax-definition">
<h4 title="Consume a syntax definition">3.4.2. 構文~定義を消費する</h4>

<div class="algorithm">
<p>
この節では、
`構文~定義を消費する@
方法を述べる。
それは、所与の
( `文字列$ %文字列 )
から［
`構文~成分$の~listを伴う`構文~定義$ ／ `全称~構文~定義$
］を生産する：
◎
This section describes how to consume a syntax definition from a string string. It either produces a syntax definition with a list of syntax components, or the universal syntax definition.
</p>

<ol>
	<li>
%文字列 から`前後の~ASCII空白~列を剥ぐ$
◎
Strip leading and trailing ASCII whitespace from string.
</li>
	<li>
~IF［
%文字列 の`長さ$ ~EQ 0
］
⇒
~RET `失敗^i
◎
If string’s length is 0, return failure.
</li>
	<li>
~IF［
%文字列 ~EQ `*^l （ 1 個の ~U002A ）
］
⇒
~RET `全称~構文~定義$
◎
If string’s length is 1, and the only code point in string is U+002A ASTERISK (*), return the universal syntax definition.
</li>
	<li>
%~stream ~LET %文字列 を成す`符号位置$並びを前処理して作成される`入力~stream$
`css-syntax-3$r
◎
Let stream be an input stream created from the code points of string, preprocessed as specified in [css-syntax-3].＼
</li>
	<li>
%定義 ~LET 新たな`~list$
◎
Let definition be an initially empty list of syntax components.
</li>
	<li>
<p>
~WHILE 無条件：
◎
↓</p>
		<ol>
			<li>
%成分 ~LET %~stream から`構文~成分を消費する$
◎
Consume a syntax component from stream.＼
</li>
			<li>
~IF［
%成分 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If failure was returned, return failure;＼
</li>
			<li>
%定義 に %成分 を`付加する$
◎
otherwise, append the returned value to definition.
</li>
			<li>
%~stream からアリな限り多くの`空白$を消費する
◎
Consume as much whitespace as possible from stream.
</li>
			<li>
<p>
%~stream 内の`次入力~符号位置$を消費する：
◎
Consume the next input code point in stream:
</p>
				<dl class="switch">
					<dt>`EOF^i</dt>
					<dd>
~RET %定義
◎
return definition.
</dd>

					<dt>~U007C</dt>
					<dd>
~CONTINUE
◎
Repeat step 5.
</dd>

					<dt>他全部</dt>
					<dd>
~RET `失敗^i
◎
Return failure.
</dd>
				</dl>
			</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="consume-syntax-component">
<h4 title="Consume a syntax component">3.4.3. 構文~成分を消費する</h4>

<div class="algorithm">
<p>
`符号位置$の %~stream から
`構文~成分を消費する@
ときは：
◎
To consume a syntax component from a stream of code points stream:
</p>

<ol>
	<li>
%~stream からアリな限り多くの`空白$を消費する
◎
Consume as much whitespace as possible from stream.
</li>
	<li>
%名前 ~SET 空~文字列
</li>
	<li>
%量指定子 ~SET ε（なし）
◎
Let component be a new syntax component with its name and multiplier initially empty.
</li>
	<li>
<p>
%~stream 内の`次入力~符号位置$を消費する：
◎
Consume the next input code point in stream:
</p>
		<dl class="switch">
			<dt>~U003C</dt>
			<dd>
				<ol>
					<li>
%結果 ~LET %~stream から`~data型~名を消費する$
</li>
					<li>
~IF［
%結果 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
					<li>
%名前 ~SET %結果
</li>
				</ol>
◎
Consume a data type name from stream. If it returned a string, set component’s name to the returned value. Otherwise, return failure.
</dd>

			<dt>`名前開始~符号位置$</dt>
			<dt>~U005C</dt>
			<dd>
				<ol>
					<li>
~IF［
%~stream は`識別子から開始して$いない
］
⇒
~RET `失敗^i
</li>
					<li>
%~stream から`現入力~符号位置を消費し直す$
</li>
					<li>
%名前 ~SET %~stream から`名前を消費する$
</li>
					<li>
~IF［
%名前 は `custom-ident$t として構文解析されなかった
］
⇒
~RET `失敗^i
</li>
				</ol>
◎
If the stream starts with an identifier, reconsume the current input code point from stream then consume a name from stream, and set component’s name to the returned value. Otherwise return failure.
◎
If component’s name does not parse as a &lt;custom-ident&gt;, return failure
</dd>

			<dt>他全部</dt>
			<dd>
~RET `失敗^i
◎
Return failure.
</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
%名前 は`量指定済み~data型~名$でない
］~AND［
%~stream 内の`次入力~符号位置$ ~IN { ~U002B, ~U0023 }
］：
</p>
		<ol>
			<li>
%~stream から`次入力~符号位置$を消費する
</li>
			<li>
%量指定子 ~SET `現入力~符号位置$
</li>
		</ol>
◎
If component’s name is a pre-multiplied data type name, return component.
◎
If the next input code point in stream is U+002B PLUS SIGN (+) or U+0023 NUMBER SIGN (#), consume the next input code point from stream, and set component’s multiplier to the current input code point.
</li>
	<li>
~RET 次のようにされた新たな`構文~成分$
⇒＃
名前 ~SET %名前,
量指定子 ~SET %量指定子
◎
Return component.
</li>
</ol>
</div>

			</section>
			<section id="consume-data-type-name">
<h4 title="Consume a data type name">3.4.4. ~data型~名を消費する</h4>

<div class="algorithm">
<p>
`符号位置$の~streamから
`~data型~名を消費する@
ときは：
◎
To consume a data type name from a stream of code points:
</p>

<p class="note">注記：
この~algoは、`符号位置$ ~U003C が すでに~streamから消費-済みであると見做す。
◎
Note: This algorithm assumes that a U+003C LESS-THAN SIGN (&lt;) code point has already been consumed from the stream.
</p>

<ol>
	<li>
%名前 ~LET `&lt;^l（ 1 個の ~U003C ）
◎
Let name initially be a string containing a single U+003C LESS-THAN SIGN (&lt;) code point.
</li>
	<li>
<p>
%~stream から`次入力~符号位置を繰返し消費する$：
◎
Repeatedly consume the next input code point:
</p>
		<dl class="switch">
			<dt>~U003E</dt>
			<dd>
				<ol>
					<li>
%名前 に`現入力~符号位置$を付加する
</li>
					<li>
~IF［
%名前 は`~supportされる構文~成分~名$である
］
⇒
~RET %名前
</li>
					<li>
~RET `失敗^i
</li>
				</ol>
◎
Append the code point to name. If name is a supported syntax component name, return name. Otherwise return failure.
</dd>

			<dt>`名前~符号位置$</dt>
			<dd>
%名前 に`現入力~符号位置$を付加する
◎
Append the code point to name.
</dd>

			<dt>他全部</dt>
			<dd>
~RET `失敗^i
◎
Return failure.
</dd>
		</dl>
	</li>
</ol>

</div>

			</section>
		</section>
	</section>
	<section id="behavior-of-custom-properties">
<h2 title="Behavior of Custom Properties">4. ~custom~propの挙動</h2>

		<section id="animation-behavior-of-custom-properties">
<h3 title="Animation Behavior of Custom Properties">4.1. ~animationにおける~custom~propの挙動</h3>

<p class="note">注記：
［
`css3-animations$r ／ `css3-transitions$r
］に定義されるように，~custom~propを参照する［
~animation ／ 遷移
］を指定することもアリである。
◎
Note: As defined by [css3-animations] and [css3-transitions], it is possible to specify animations and transitions that reference custom properties.
</p>


<p>
［
~animation／遷移
］から参照される~custom~propの値は、その値が構文解析された型に則って，`算出d値により$ `補間-$される。
◎
When referenced by animations and transitions, custom property values interpolate by computed value, in accordance with the type that they parsed as.
</p>

<p class="note">注記：
このことは、
<code class="prod">`color^t+</code>
や
<code class="prod">`color^t#</code>
などの値~listは、単純~listとして補間されることを含意する
— 互いの成分を各~indexごとに対応~付けて，成分の個数が合致しない場合は失敗するように。
◎
Note: This implies that a list of values, such as &lt;color&gt;+ or &lt;color&gt;#, will interpolate as a simple list, matching up each component index-by-index, and failing if the number of components doesn’t match.
</p>

<p>
上の規則に対する例外として、［
`transform-list^t ／
`transform-function^t ／
<code class="prod">`transform-function^t+</code>
］として構文解析される値は、代わりに `transform$p ~propに従って補間される。
◎
As an exception to the above rule, a value that parsed as a &lt;transform-list&gt;, a &lt;transform-function&gt;, or a &lt;transform-function&gt;+ instead interpolates as per the transform property.
</p>

<p class="note">注記：
何らかの理由で，構文
<code class="prod">`transform-function^t#</code>
を伴って定義された~custom~propは、先ず単純~listとして補間されてから，各~list~itemが `transform$p 値として補間されることになる。
◎
Note: If, for whatever reason, a custom property is defined with a syntax of &lt;transform-function&gt;#, this will thus first interpolate as a simple list, and then each list item will interpolate as a transform value.
</p>

		</section>
		<section id="conditional-rules">
<h3 title="Conditional Rules">4.2. 条件付き規則</h3>

<p class="note">注記：
［
`supports$at 規則 ／
`~supports0()$m ~method
］は、 `css-variables$r に指定されるように挙動する
— 当の~custom~propが登録-済みか否かを判別することも，登録-済み~propの構文に気を配ることもない。
◎
@supports rules and the supports() method behave as specified in [css-variables], without distinguishing between registered and unregistered custom properties, and paying no attention to registered properties' syntaxes.
</p>

		</section>
		<section id="relative-urls">
<h3 title="Relative URLs">4.3. 相対~URL</h3>

<p>
登録された~custom~prop内に現れる相対~URL値は、 `css3-values$r に従って全部的~URLに解決される。
◎
Relative URL values that appear in registered custom properties are resolved to full URLs as described in [css3-values].
</p>

<div class="example">
<p>
~URLは，それが現れる~stylesheetの基底~URLに対して解決されるので、複数の相対~URLが異なる基底~URLに対して解決される結果になり得る
— それらが同じ【名前の】~prop内に現れようが。
◎
Because URLs resolve against the base URL of the stylesheet they appear in, we can end up with multiple relative URLs that resolve against different base URLs, even though they appear in the same property.
</p>

<p>
例えば
`--url-foo^p, `--url-bar^p
は、ともに，構文に `url$t を与えて登録された~custom~propとする。
ある~stylesheetが `/style/foo/foo.css^c にあって：
◎
For example, suppose --url-foo and --url-bar are registered custom properties with &lt;url&gt; syntax, and that we have a stylesheet at /style/foo/foo.css:
</p>

<pre class="lang-css">
div {
  --url-foo: url("foo.png");
}
</pre>

<p>
別の~stylesheetが `/style/bar/bar.css^c にあって：
◎
and another stylesheet at /style/bar/bar.css
</p>

<pre class="lang-css">
div {
  --url-bar: url("bar.png");
}
</pre>

<p>
文書は， `/index.html^c にあるとする：
◎
and finally a document at /index.html:
</p>

<pre class="lang-markup">
&lt;link href="/style/foo/foo.css" rel="stylesheet" type="text/css"&gt;
&lt;link href="/style/bar/bar.css" rel="stylesheet" type="text/css"&gt;
&lt;div style="background-image: var(--url-foo), var(---url-bar);"&gt;
&lt;/div&gt;
</pre>

<p>
ここでは、［
`var(--url-foo)^v ／ `var(--url-bar)^v
］参照は［
`/style/foo^c ／ `/style/bar^c
］に対して解決される~URLを生産することになる。
◎
Here, the var(--url-foo) reference would produce a URL that resolves against /style/foo, and the var(--url-bar) reference would produce a URL that resolves against /style/bar.
</p>

</div>

		</section>
		<section id="fallbacks-in-var-references">
<h3 title="Fallbacks in var() references">4.4. `var^f 参照における~fallback</h3>

<p>
`var$f 関数を利用する登録-済み~custom~propへの参照は，~fallbackを供してもヨイが、~fallback値は，参照-先の~custom~propの`構文~定義$に合致しなければナラナイ
— さもなければ、宣言は`算出d値の時点で無効$になるとする。
◎
References to registered custom properties using the var() function may provide a fallback. However, the fallback value must match the syntax definition of the custom property being referenced, otherwise the declaration is invalid at computed-value time.
</p>

<p class="note">注記：
これは、~fallbackが利用されるかどうかに関わらず，適用される。
◎
Note: This applies regardless of whether or not the fallback is being used.
</p>

		</section>
		<section id="substitution">
<h3 title="Substitution">4.5. 代用</h3>

<p>
登録-済み~custom~propの値は、未登録な~custom~propと同様に，別の値の中の `var$f 関数を代用し得る。
しかしながら，登録-済み~custom~propは、その
<a href="#calculation-of-computed-values">算出d値</a>
として代用される
— その値を生産するときに利用される元の~token列ではなく。
◎
Like unregistered custom properties, the value of a registered custom property can be substituted into another value with the var() function. However, registered custom properties substitute as their computed value, rather than the original token sequence used to produce that value.
</p>

<p>
`var$f 関数のうち，登録-済み~custom~propを参照するものは、
`等価な~token列@
— 次の結果の文字列を`~token化$して生産される~token列 —
に置換するモノトスル
⇒
`~CSS値を直列化する$( ~custom~propの算出d値 )
◎
Any var() function that references a registered custom property must be replaced with an equivalent token sequence, which is equal to the token sequence that would have been produced by serializing the computed value, and tokenizing the resulting string.
</p>

<div class="example">

<p>
~custom~prop `--x^p は `length$t 構文で登録されていて， `--y^p は未登録な~custom~propとする。
◎
Suppose that --x is registered with &lt;length&gt; syntax, and that --y is an unregistered custom property.
</p>

<pre class="lang-css">
div {
  font-size: 10px;
  --x: 8em;
  --y: var(--x);
}
</pre>

<p>
`--x^p の算出d値 （を直列化した結果）は `80px^l になるので、
`--y^p の算出d値は，次の順の~token列になる
⇒＃
`whitespace-token$t,
［ 数値 80, 単位 `px^l ］を伴う `dimension-token$t
◎
Because the computed value of --x (when serialized) is "80px", the computed value of --y is: &lt;whitespace-token&gt; followed by &lt;dimension-token&gt; with a value of "80" and unit "px".
</p>

</div>

		</section>
	</section>
	<section id="cssom">
<h2 title="CSSOM">5. ~CSSOM</h2>

<p class="note">注記：
登録-済み~custom~prop用に指定された値は、算出d値の時点まで解釈されない。
これは、算出d値を検索取得する~APIに限り影響されることを意味する。
他の~APIは、結付けられている `Document$I の `registeredPropertySet$sl ~slotを無視し，
すべての~custom~propを登録されていないものと扱うモノトスル。
◎
The value specified for a registered custom property is not interpreted until computed-value time. This means that only APIs that retrieve computed values are affected. Other APIs must ignore the [[registeredPropertySet]] slot of the associated Document, and treat all custom properties as unregistered.
</p>

		<section id="css-style-value-reification">
<h3 title="CSSStyleValue Reification">5.1. `CSSStyleValue$I の具象化</h3>

<div class="algorithm">

<p>
`登録-済み~custom~prop値を具象化する@
ときは、所与の
( ~prop %~prop ,`構文~定義$ %構文 )
に対し，次の手続きを走らす：
◎
To reify a registered custom property value given a property property and syntax definition syntax, run these steps:
</p>

<ul>
	<li>
<p>
%~prop の指定d値 %値 に対しては
⇒
~RET `成分~値~listを具象化する$( %値 )
◎
For specified values, reify a list of component values from the value, and return the result.
</p>
	<li>
<p>
%~prop の算出d値 %値 に対しては、
%値 の型に応じて：
◎
For computed values:
</p>
		<dl class="switch">
			<dt>`length$t</dt>
			<dt>`integer$t</dt>
			<dt>`number$t</dt>
			<dt>`angle$t</dt>
			<dt>`time$t</dt>
			<dt>`resolution$t</dt>
			<dt>`percentage$t</dt>
			<dt>`length-percentage$t</dt>
			<dd>
~RET `数量-値を具象化する$( %値 )
◎
If the value is a &lt;length&gt;, &lt;integer&gt;, &lt;number&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;resolution&gt;, &lt;percentage&gt; or &lt;length-percentage&gt;; reify a numeric value from the value and return the result.
</dd>

			<dt>`transform-function$t</dt>
			<dd>
~RET `変形~関数を具象化する$( %値 )
◎
If the value is a &lt;transform-function&gt;, reify a &lt;transform-function&gt; from the value and return the result.
</dd>

			<dt>`transform-list$t</dt>
			<dd>
~RET `変形~listを具象化する$( %値 )
◎
If the value is a &lt;transform-list&gt;, reify a &lt;transform-list&gt; from the value and return the result.
</dd>

			<dt>`image$t</dt>
			<dd>
~RET `画像を具象化する$( %値 )
◎
If the value is an &lt;image&gt;, reify a CSSImageValue from the value and return the result.
</dd>

			<dt>`識別子$</dt>
			<dd>
~RET `識別子を具象化する$( %値 )
◎
If the value is an identifier, reify an identifier from the value and return the result.
</dd>

			<dt>`全称~構文~定義$</dt>
			<dd>
~RET `成分~値~listを具象化する$( %値 )
◎
If syntax is the universal syntax definition, reify a list of component values from the value, and return the result.
</dd>

			<dt>その他</dt>
			<dd>
~RET `~CSSStyleValueとして具象化する$( %~prop, %値 )
◎
Otherwise, reify as a CSSStyleValue with the [[associatedProperty]] internal slot set to property, and return the result.
</dd>
		</dl>
	</li>
</ul>
</div>

		</section>
	</section>
	<section id="at-property-rule">
<h2 title="The @property rule">6. `property^at 規則</h2>

<p>
`property@at
規則は、~JSを走らすことなく，~stylesheet内で直に~custom~propを登録する代替な仕方を供する。
妥当な `property$at 規則は、等価な~parameterで `registerProperty()$m が~callされたかのように，`~custom~propを登録する$ことになる。
◎
The @property rule provides an alternative way to register a custom property, directly in a stylesheet without having to run any JS. Valid @property rules result in a registered custom property, as if registerProperty() had been called with equivalent parameters.
</p>

<p>
登録される~propの意味論は、登録を遂行するときに利用される仕組みに関わらず，同じになる。
すなわち，登録されたなら、［
`registerProperty()$m,
`property$at
］のどちらで登録されていようが，同じ挙動になる。
◎
The semantics of registered properties are the same regardless of the mechanism used to perform the registration. This means that, once registered, it does not matter whether the registration originated from registerProperty() or @property: the property has the same behavior either way.
</p>

<p>
`property$at の構文は：
◎
The syntax of @property is:
</p>

<pre class="prod">
@property `custom-property-name$t {
  `declaration-list$t
}
</pre>

<p>
`property$at 規則には、［
`syntax$d, `inherits$d
］記述子が要求される。
どちらかが欠落している場合、規則~全体が無効になり，無視されるモノトスル。
`initial-value$d 記述子は、構文が`全称~構文~定義$である場合に限り省略可能であり，他の場合は要求される
【！原文誤:universal syntax descriptor → 正:universal syntax definition／以下同様】
— 欠落している場合、全体~規則は無効になり，無視されるモノトスル。
◎
@property rules require a syntax and inherits descriptor; if either are missing, the entire rule is invalid and must be ignored. The initial-value descriptor is optional only if the syntax is the universal syntax descriptor, otherwise the descriptor is required; if it’s missing, the entire rule is invalid and must be ignored.
</p>

<p>
未知な記述子は、無効であり無視されるが，
`property$at 規則を無効化することはない。
◎
Unknown descriptors are invalid and ignored, but do not invalidate the @property rule.
</p>

<p>
同じ `custom-property-name$t 用に複数の妥当な `property$at 規則が定義された場合、~stylesheet順序で最後のものが “勝つ”。
`registerProperty()$m による~custom~prop登録は、同じ `custom-property-name$t 用のどの `property$at 規則にも勝つ。
◎
If multiple valid @property rules are defined for the same &lt;custom-property-name&gt;, the last one in stylesheet order "wins". A custom property registration from CSS.registerProperty() further wins over any @property rules for the same &lt;custom-property-name&gt;.
</p>

<p>
`property$at は、`~shadow~tree$の内側にある~stylesheet内にある場合は無効になり，無視されるモノトスル。
◎
A @property is invalid if it occurs in a stylesheet inside of a shadow tree, and must be ignored.
</p>

<p class="note">注記：
これは将来には，変更されるかもしれない
— ~shadow~tree内の `concept-defining^en ~at-rule【？】の挙動が，もっと一貫するように定義されるに伴い。
◎
Note: This might change in the future, as the behavior of concept-defining at-rules in shadow trees becomes more consistently defined.
</p>

		<section id="the-syntax-descriptor">
<h3 title="The syntax descriptor">6.1. `syntax^d 記述子</h3>

◎述 `syntax@d
◎用 `property$at
◎値 `string$t
◎初 可用でない（注釈文を見よ）
◎
n/a (see prose)
◎表終

<p>
~custom~propの構文を
<a href="#syntax-strings">§ 構文~文字列</a>
にて定義される形で指定する。
この記述子は、
`PropertyDescriptor$I の `syntax$mD ~memberに等価である。
◎
Specifies the syntax of the custom property, in the form defined by § 3 Syntax Strings. This descriptor is equivalent to the syntax member of PropertyDescriptor.
</p>

<p>
`property$at 規則が妥当になるためには、この記述子が要求される。
欠落している場合、 `property$at 規則は無効になる。
◎
The syntax descriptor is required for the @property rule to be valid; if it’s missing, the @property rule is invalid.
</p>

<p>
供された文字列を
<a href="#consume-a-syntax-definition">構文~定義として構文解析-</a>
した結果が `失敗^i になる場合、記述子は無効になり，無視されるモノトスル。
◎
If the provided string does not successfully parse as a syntax definition, the descriptor is invalid and must be ignored.
</p>

		</section>
		<section id="inherits-descriptor">
<h3 title="The inherits descriptor">6.2. `inherits^d 記述子</h3>

◎述 `inherits@d
◎用 `property$at
◎値 `true^v | `false^v
◎初 可用でない（注釈文を見よ）
◎
n/a (see prose)
◎表終

<p>
~custom~propは継承するかどうかを指定する。
この記述子は、
`PropertyDescriptor$I の `inherits$mD ~memberに等価である。
◎
Specifies whether or not the custom property inherits. This is equivalent to the inherits member of PropertyDescriptor.
</p>

<p>
`property$at 規則が妥当になるためには、この記述子が要求される。
欠落している場合、 `property$at 規則は無効になる。
◎
The inherits descriptor is required for the @property rule to be valid; if it’s missing, the @property rule is invalid.
</p>

		</section>
		<section id="initial-value-descriptor">
<h3 title="The initial-value descriptor">6.3. `initial-value^d 記述子</h3>

◎述 `initial-value@d
◎用 `property$at
◎値 `declaration-value$t
◎初 `無効が保証される値$（注釈文を見よ）
◎
the guaranteed-invalid value (but see prose)
◎表終

<p>
~custom~propの`初期~値$を指定する。
この記述子は、
`PropertyDescriptor$I の `initialValue$mD ~memberに等価である。
◎
Specifies the initial value of the custom property. This is equivalent to the initialValue member of PropertyDescriptor.
</p>

<p>
この記述子は、 `syntax$d 記述子の値が`全称~構文~定義$である場合には，省略可能である。
省略された場合、~propの初期~値は，`無効が保証される値$になる。
◎
If the value of the syntax descriptor is the universal syntax descriptor, then the initial-value descriptor is optional. If omitted, the initial value of the property is the guaranteed-invalid value.
</p>

<p>
`syntax$d 記述子の値が`全称~構文~定義$でない場合、
`property$at 規則が妥当になるためには，次に挙げる条件~すべてが満たされなければナラナイ：
◎
Otherwise, if the value of the syntax descriptor is not the universal syntax descriptor, the following conditions must be met for the the @property rule to be valid:
</p>

<ul>
	<li>
`initial-value$d 記述子が在る。
◎
The initial-value descriptor must be present.
</li>
	<li>
`initial-value$d 記述子の値は、
`syntax$d 記述子の値に指定された文法（`構文~定義$）に則って，成功裡に構文解析される。
【！#consume-a-syntax-definition】
◎
The initial-value descriptor’s value must parse successfully according to the grammar specified by the syntax definition.
</li>
	<li>
`initial-value$d は`独立に算出-可能$である。
◎
The initial-value must be computationally independent.
</li>
</ul>

<p>
上のいずれかの条件が満たされない場合、 `property$at 規則は無効になる。
◎
If the above conditions are not met, the @property rule is invalid.
</p>

		</section>
		<section id="extensions-to-css-rule-interface">
<h3 title="Extensions to the CSSRule interface">6.4. `CSSRule^I ~interfaceに対する拡張</h3>

<p>
`CSSRule$I ~interfaceは、次により拡張される：
◎
The CSSRule interface is extended as follows:
</p>

<pre class="idl">
partial interface `CSSRule$I {
    const `unsigned short$ `PROPERTY_RULE@m = 18;
};
</pre>

		</section>
		<section id="the-css-property-rule-interface">
<h3 title="The CSSPropertyRule interface">6.5. `CSSPropertyRule^I ~interface</h3>

<p>
`CSSPropertyRule$I ~interfaceは、ある `property$at 規則を表現する。
◎
The CSSPropertyRule interface represents an @property rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPropertyRule@I : `CSSRule$I {
    readonly attribute `CSSOMString$ `name$mD;
    readonly attribute `CSSOMString$ `syntax$mD;
    readonly attribute `boolean$ `inherits$mD;
    readonly attribute `CSSOMString$? `initialValue$mD;
};
</pre>

<dl>
	<dt>
`name@mD
◎
name, of type CSSOMString, readonly
</dt>
	<dd>
`property$at 規則に結付けられている~custom~prop名。
◎
The custom property name associated with the @property rule.
</dd>

	<dt>
`syntax@mD
◎
syntax, of type CSSOMString, readonly
</dt>
	<dd>
`property$at 規則に結付けられている構文
— 正確に指定されたとおりの。
◎
The syntax associated with the @property, exactly as specified.
</dd>

	<dt>
`inherits@mD
◎
inherits, of type boolean, readonly
</dt>
	<dd>
`property$at 規則に結付けられている `inherits$d 記述子。
◎
The inherits descriptor associated withthe @property rule.
</dd>

	<dt>
`initialValue@mD
◎
initialValue, of type CSSOMString, readonly, nullable
</dt>
	<dd>
`property$at 規則に結付けられている初期~値
— 無い場合は ~NULL になる。
◎
The initial value associated with the @property rule, which may not be present.
</dd>
</dl>

		</section>
	</section>
	<section id="examples" class="example">
<h2 title="Examples">7. 例</h2>

		<section id="example-1">
<h3 title="Example 1: Using custom properties to add animation behavior">7.1. ~custom~propを利用して~animationにおける挙動を追加する例</h3>

<pre class="lang-markup">
&lt;script&gt;
CSS.`registerProperty$m({
  name: "--stop-color",
  syntax: "&lt;color&gt;",
  inherits: false,
  initialValue: "rgba(0,0,0,0)"
});
&lt;/script&gt;

&lt;style&gt;

.button {
  --stop-color: red;
  background: linear-gradient(var(--stop-color), black);
  transition: --stop-color 1s;
}

.button:hover {
  --stop-color: green;
}

&lt;/style&gt;
</pre>

		</section>
		<section id="example-2">
<h3 title="Example 2: Using @property to register a property">7.2. `property^at を利用して~propを登録する例</h3>

<pre class="lang-markup">
&lt;script&gt;
  CSS.`paintWorklet$m.`addModule$m('circle.js');
&lt;/script&gt;
&lt;style&gt;
  @property --radius {
    syntax: "&lt;length&gt;";
    inherits: false;
    initial-value: 0px;
  }

  div {
    width: 100px;
    height: 100px;
    --radius: 10px;
    background: paint(circle);
    transition: --radius 1s;
  }

  div:hover {
    --radius: 50px;
  }
&lt;/style&gt;
&lt;div&gt;&lt;/div&gt;

// circle.js
`registerPaint$m('circle', class {
    static get inputProperties() { return ['--radius']; }
    paint(%ctx, %geom, %properties) {
      let %radius = %properties.get('--radius').value;
      %ctx.fillStyle = 'black';
      %ctx.beginPath();
      %ctx.arc(%geom.width / 2, %geom.height / 2, %radius, 0, 2 * Math.PI);
      %ctx.fill();
    }
});
</pre>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

<p>
この仕様に与える特能により導入される，既知な~security上の課題は無い。
◎
There are no known security issues introduced by these features.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">9. ~privacyの考慮点</h2>

<p>
この仕様に与える特能により導入される，既知な~privacy上の課題は無い。
◎
There are no known privacy issues introduced by these features.
</p>
	</section>

</main></div>


