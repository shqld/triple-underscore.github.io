<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Long Tasks API 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	text = '<span lang="en-x-a1">' + key + '</span>';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Long Tasks API 1
spec_date:2019-02-22
trans_update:2019-03-06
source_checked:190222
page_state_key:TIMING
original_url:https://w3c.github.io/longtasks/
spec_status:ED
ref_id_prefix:bib-
copyright:2019,use
trans_1st_pub:2019-03-06

●●class_map
E:error
a:attr
e:element
et:event-type

●●tag_map
I:code
m:code
a:code
e:code
et:code
c:code
E:code
v:var
V:var
b:b
i:i

●●original_id_map

●●link_map

	●IDL

I.PerformanceLongTaskTiming:#performancelongtasktiming
I.TaskAttributionTiming:#taskattributiontiming
I.DOMHighResTimeStamp:~HRTIME#idl-def-domhighrestimestamp
DOMString:~WEBIDL#idl-DOMString
I.PerformanceEntry:~TIMELINE#the-performanceentry-interface
~window:~WINDOW#the-window-object

m.attribution:#dom-performancelongtasktiming-attribution
m.containerType:#dom-taskattributiontiming-containertype
m.containerName:#dom-taskattributiontiming-containername
m.containerId:#dom-taskattributiontiming-containerid
m.containerSrc:#dom-taskattributiontiming-containersrc
m.duration:~TIMELINE#dom-performanceentry-duration
m.entryType:~TIMELINE#dom-performanceentry-entrytype
m.name:~TIMELINE#dom-performanceentry-name
m.startTime:~TIMELINE#dom-performanceentry-starttime

m.requestIdleCallback:~REQUESTIDLECALLBACK#dom-window-requestidlecallback

l.unknown:#unknown
l.self:#self
l.same-origin-ancestor:#same-origin-ancestor
l.same-origin-descendant:#same-origin-descendant
l.same-origin:#same-origin
l.cross-origin-ancestor:#cross-origin-ancestor
l.cross-origin-descendant:#cross-origin-descendant
l.cross-origin-unreachable:#cross-origin-unreachable
l.multiple-contexts:#multiple-contexts

e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element

a.name:~HEembed#attr-iframe-name
a.src:~HEembed#attr-iframe-src

	●用語
長い~task:#long-task
元凶~閲覧文脈~容器:#culprit-browsing-context-container
	container:#culprit-browsing-context-container
	culprit閲覧文脈:#culprit-browsing-context-container

帰属:#attribution
最小限の元凶~帰属:#minimal-culprit-attribution

長い~taskを報告する:#report-long-tasks


	●用語（外部
~ID:~DOM4#concept-id

~JS~realm:~TC39#sec-code-realms
	~JS~Realm:https://tc39.github.io/ecma262/#sec-code-realms

処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
処理能~entry種別を登録する:~TIMELINE#dfn-register-a-performance-entry-type
作動中の文書:~BROWSERS#active-document
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
	先祖:HTML5#ancestor-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
入子にしている閲覧文脈~容器:~BROWSERS#browsing-context-nested-through
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
子孫~閲覧文脈:~BROWSERS#list-of-the-descendant-browsing-contexts
	子孫:https://html.spec.whatwg.org/multipage/#list-of-the-descendant-browsing-contexts
互いに関係する閲覧文脈~群:~BROWSERS#unit-of-related-browsing-contexts
閲覧文脈~group:~BROWSERS#browsing-context-group




同一-生成元:~ORIGIN#same-origin

~task:~WAPI#concept-task
~event-loop処理~model:~WAPI#event-loop-processing-model
~event-loop:~WAPI#event-loop
小task:~WAPI#microtask
enV.生成元:~WAPI#concept-settings-object-origin
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
関連する~Realm:~WAPI#concept-relevant-realm
関連する設定群~obj:~WAPI#relevant-settings-object
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
描画を更新する:~WAPI#update-the-rendering
~script評価 環境~設定群~obj集合:~WAPI#script-evaluation-environment-settings-object-set

~agent~cluster:~WAPI#integration-with-the-javascript-agent-cluster-formalism

	単位~of関係する閲覧文脈s:https://html.spec.whatwg.org/multipage/#unit-of-related-browsing-contexts

凍結d配列を作成する:~WEBIDL#dfn-create-frozen-array

	in this document:https://docs.google.com/document/d/1tIMI1gau_q6X5EBnjDNiFS5NWV9cpYJ5KKA7xPd3VB8/edit


●●words_table1
REQUESTIDLECALLBACK:requestidlecallback-ja.html


●●words_table

	●IDL／型／構造
queue:::キュー
凍結d:frozen::凍結
entry:::エントリ
callback:
call:
interface:::インタフェース
list:::リスト
field:::フィールド
dequeue:::デキュー
obj:object::オブジェクト
group:::グループ
item:::アイテム
interface:::インタフェース
配列:array::~
型:type::~
種別:type:~
空:empty:~
属性:attribute::~
文書:document::~
新たな:new::~
文字列:string::~
名前:name::~
値:value::~
取得子:getter::~
包含-:contain::~
容器:container::コンテナ
内容:content::~
追加-:add:~
作成-:create::~
要素:element::~
集合:set::~
設定群:settings::~
子孫:descendant::~
先祖:ancestor::~
設定-:set::~
入子に:nest::~

	●処理一般
poll:
	~pollし続ける:polling
target:
task:::タスク
小task:microtask::小タスク
main:::メイン
thread:::スレッド
処理-:process:~
処理:processing:~
走らす:run する:~
完遂-:finish:~
入力:input:~
実行-:execute:~
実行:execution:~
段:step:~
手続き:steps:~
algo:algorithm::アルゴリズム
遂行-:perform:~
阻まれ:block され:~
阻む:block する:~
checkpoint:
garbage:::ガーベジ
収集:collection:~
event:::イベント
event-loop:event loop::イベントループ
source:::ソース
登録-:register::~
	直後の:follows immediately afterwards
返す:return する:~
追跡-:track:~
送達-:deliver:~
通知:notification:~
作動中の:active な::~:アクティブな
観測器:observer::~
評価:evaluation:~
識別-:identify:~
更新-:update:~
更新:update:~
行先:destination:~

	何もしない:end up doing nothing
	早めに抜け出る:bail out 〜 earlier
	各~callから次回の~callまで:between the successive calls

	●計時／long task
最小限の:minimal な:~
帰属:attribution::~
長い:long::~
出自に:originate:~
元凶:culprit::~
時間:time::~
時刻:time::~
所要時間:duration::~
待時間:latency::待ち時間
遅延:delay::~
timer:::タイマー
経過-:elapse::~
計時:timing::~
静止:pause::~
開始-:start::~
終止-:end::~
反応-:react:~
遊休:idle::~
	遊休~callback:idle block:~
	“静止期間”:quiescence
	遊休~時に走らす~codeに割り当てられる “静止期間” が細切れになる:prevents quiescence and long idle blocks
schedule:::スケジュール
処理能:performance::~:パフォーマンス
周期:period:~
周期的:periodic:~
報告-:report::~
報告:report::~
監視:monitoring::~
	長期間:extended periods of time
	以内:in under
超過-:exceed:~
閾値:threshold:~
記録-:record::~
	になる時機:time to
	速く:faster

	●UI
UI:
critical:
scroll:::スクロール
scrolling:::スクロール処理
style:::スタイル
animation:::アニメーション
layout:::レイアウト
touch:::タッチ
	^en:tap, click, scroll, wheel
活動:activity:~
移動:move:~
視覚的:visual:~
ヤリトリ-:interact::やりとり
対話:interaction::~
対話的:interactive::~
	-:〜 interactions

描画:rendering::~
具現化-:render::~
可視:visible::~
応答-:respond::~
応答性:responsiveness::~
体験:experience:~
lock:::ロック
	締め出され:locked up
	~~長い:high
	可変:variable
	即応しない:janky／:yields janky

	●保安
privacy:::プライバシー
security:::セキュリティ
当事者-:first-:~
第三者-:third-:~
主体:party:~
施策:policy::~:ポリシー
保護:protection:~
同一-:same-:~
非同一-:cross-:~
生成元:origin::~:オリジン
	同一-生成元に属さない:非同一-生成元に属する
安全:safe::~
	生成元~安全:origin-safe
	第三者:third:~
攻撃:attack::~
軽減-:mitigate::~
	軽減-:mitigation
発見:discovery:~
	抗する／対し:against

	●仕様
API:
Web:
UA:user agent:UA
app:application::アプリ
browser:::ブラウザ
vendor:::ベンダ
web::::ウェブ
site:::サイト
	~web~site:website
model:::モデル
pattern:::パタン
定義-:define:~
導入:introduce:~
供-:provide:~
要求-:require:~
共通的に:common に:よく
寄与-:contribute:~
開発者:developer:~
関係-:relate:~
アリ:possible:可能
情報:information:~
固守-:adhere:~
結付けら:associate さ:結び付けら
設計:design:~
考慮点:considerations:~
許容-:allow:~
事例:case:~
利用-:use:~
関連する:relevant な:~
予測-:predict:~
	予測-不能:unpredictable
	すべ:way:~
作業:work:~
作者:author:~
働く:work する:~
利用者:user:~
協調:coordination:~
取扱い:handling:~
各種用語:terminology:~
問題:problem:~
固守:adhere:~
孕む:involve する:~
孕んで:involve して:~
実装-:implement:~
実装:implementation:~
将来:future:~
意図的:intentional:~
有意:significant:~
検分-:inspect:~
概観:overview:~
決定-:determine:~
独占-:monopolize:~
	~~相関する:independent
目標:goal:~
示唆-:suggest:~
試みて:attempt:~
論じら:discuss:~
防止-:prevent:~
	できなく:prevent
考査:review:~
今日:today:~
拙く:poor に:~
参考な:informative な:規範的でない
資質:nature:~
必要十分:adequate:~
影響-:affect:~
捕捉-:capture:~
要約:summary:~
意味され:mean され:意図され
表面化-:surface:~
求める:want する:~
不良:bad:~
	短命:bad for battery life
	~~悪影響を及ぼす:bad 〜 implications

	~~目的:target
	ことになるはず:should
	〜に基づく:based
	見よ:see
	例:example
	例えば:for example
	しかしながら，:however
	したがって:therefore
	したがって:thus
	第一に:primarily
	用例:usage example
	大体は:mostly
	今の所は:for now
	見込みが高い:high likelihood
	であろう:likely
	易くする:help
	知られ:known
	知る:know
	序論:introduction
	指す:refer
	称され:referred
	〜版:iterations
	同様:similar
	~~連携:tie up
	よくある:frequent
	~~側面:facet
	~~関与-:be implicated
	~~原因がどこにあるか:where the blame rests for
	不能:unable
	~~無駄になる:only to find out nobody is listening for
	~~実像を~~描く:paint the picture
	~~調べる:look up
	もの:occurrence
	抵触する:prevent 〜 from hitting
	どこからも〜ない:nobody

	●未分類（動詞
検出-:detect:~
受信-:receive:~
外側:outside:~
大域的:global::~:グローバル
閲覧文脈:browsing context::~
所在:location:~
文脈:context:~
既存の:existing:~
長さ:length:~

	指すもの:pointing to
	わたる:span
	含めて:including
	起こる:happen
	~~存在:presence

	●未分類
agent:
cluster:
frame:::フレーム
iframe:
top-level:::トップレベル
window:
環境:environment:~
JS:JavaScript
URL:
install:::インストール
script:::スクリプト
ID:
page:::ページ
code:::コード
script:::スクリプト
解析:analytics:~
Realm:
realm:
battery:::バッテリー
背後:behind:~
組成器:compositor::~
源:source:~
読込まれ:load され::読み込まれ:ロードされ
組立てた:assemble した::組み立てた
	^cite:Long Tasks

	短い:short
	担当していた:responsible
	と:plus
	等し:equal
	~MINUS:minus
	~LT:less than
	-:as follows
	^et:onload
	:unset
	:unit of related browsing contexts

	元凶~設定群:culpritSettings
	行先~設定群:destinationSettings
	行先~realm~list:destinationRealms
	行先~realm:destinationRealm
	T:topmostBC
	~top-level閲覧文脈たち:top-level browsing contexts
	-:descendantBCs
	子孫:descendantBC
	行先~閲覧文脈:destinationBC
	-:destinationOrigin
	新たな~entry:newEntry

	●指示語
現在の:current:~
	少数の:a couple of
	大多数の:major
	全体的に:on the whole
	いずれか:one of
	1 個ずつ:one-by-one
	いくつかの:several
	ここ:here
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they
	それら自身:themselves
	べき:should
	上:above
	下:below
	与-:give
	両者:both
	他の:other
	他の場合:otherwise
	単独の:single
	合間:between
	同じ:same
	因り:due
	多い:often
	常に:always
	後:after
	-:back
	最初の:first
	最後の:last
	様々な:various
	次回の:next
	次の／次に挙げる:the-following
	異なる:different
	等々:etc
	等:and so on
	複数の:multiple
	〜の代わりに:instead
	全体:entire
	超える:greater than
	結果:result
	所与の:given
	読込まれた〜:afterwards
	全体の中での:overall
	組みで:together

●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[HR-TIME-2]
    Ilya Grigorik; James Simonsen; Jatinder Mann. High Resolution Time Level 2. 1 March 2018. CR. URL: https://www.w3.org/TR/hr-time-2/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[PERFORMANCE-TIMELINE-2]
    Ilya Grigorik. Performance Timeline Level 2. 10 January 2019. WD. URL: https://www.w3.org/TR/performance-timeline-2/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Long Tasks API 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

テスト一式
	http://w3c-test.org/longtask-timing/ 
最新の課題
	<a href="https://github.com/w3c/longtasks/issues/">GitHub</a>
編集
	<a href="mailto:panicker@chromium.org">Shubhie Panicker</a> (Google</a>)
	<a href="mailto:igrigorik@chromium.org">Ilya Grigorik</a> (Google</a>)
	<a href="mailto:domenic@chromium.org">Domenic Denicola</a> (Google</a>)
更新履歴
	https://github.com/w3c/longtasks/commits/master
発行者
	<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
メーリングリスト／フィードバック
	<a href="mailto:public-web-perf@w3.org?subject=%5BLongTasks%5D">public-web-perf@w3.org</a> (<a href="mailto:public-web-perf-request@w3.org?subject=subscribe">subscribe</a>, <a href="https://lists.w3.org/Archives/Public/public-web-perf/">archives</a>)

</script>

</head>
<body>

<header>

	<hgroup>
<h1 id="title">Long Tasks API 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">~~要約</h2>

<p>
この文書は、~web~page作者が “長い~task” の~~存在を検出するために利用できる~APIを定義する
— ~UI~threadを長期間~独占して，他の~criticalな~task（例：利用者~入力に反応するなど）を実行するのを阻むような。
◎
This document defines an API that web page authors can use to detect presence of "long tasks" that monopolize the UI thread for extended periods of time and block other critical tasks from being executed - e.g. reacting to user input.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
この節では、発行時点における…
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>


	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~pageが読込まれるに伴い, および利用者が読込まれた~pageとヤリトリする間、［
~app, ~browser
］の両者とも，後で~browserにより実行されるような様々な~eventを~queueする
— 例えば：
~UAは、利用者の活動に基づいて入力~eventを~scheduleする ／
~appは、 `requestAnimationFrame()^m 用の~callbackや他の~callback, 等々を~scheduleする。
~queueに入れられたこれらの~eventは、~browserにより 1 個ずつ~dequeueされ, 実行される。
◎
As the page is loading and while the user is interacting with the page afterwards, both the application and browser, queue various events that are then executed by the browser -- e.g. user agent schedules input events based on user’s activity, the application schedules callbacks for requestAnimationFrame and other callbacks etc. Once in the queue, these events are then dequeued one-by-one by the browser and executed.
</p>

<p>
しかしながら，~taskには長い時間（複数の~frame）かかり得るものもあり、それが起きた場合／とき，~UI~threadは~lockされ, 他のすべての~taskも阻まれる。
これは，利用者からは、利用者~入力に対し~browserが応答-不能になり，~pageから “締め出される” ことで共通的に可視になる。
今日における~web上の不良な利用者~体験の大多数は、それを源としている：
◎
However, some task can take a long time (multiple frames), and if and when that happens, the UI thread is locked and all other tasks are blocked as well. To the user this is commonly visible as a "locked up" page where the browser is unable to respond to user input; this is a major source of bad user experience on the web today:
</p>

<dl>
	<dt>
“対話的になる時機” が遅延される：
◎
Delayed "time to Interactive":
</dt>
	<dd>
~pageが読込まれる間、長い~taskは~main~threadと~~連携することが多い
— その結果、~pageが視覚的に具現化されていても，利用者は~pageとヤリトリできなくなる。
よくある元凶として、拙く設計された第三者-主体の内容が挙げられる。
◎
while the page is loading long tasks often tie up the main thread and prevent the user from interacting with the page even though the page is visually rendered. Poorly designed third-party content is a frequent culprit.
</dd>

	<dt>
入力の待時間が~~長い／可変：
◎
High/variable input latency:
</dt>
	<dd>
~criticalな利用者~対話~event（
`tap^en, `click^en, `scroll^en, `wheel^en, 等々
）は、長い~taskの背後に~queueされ，即応しないため、利用者~体験を予測-不能にする。
◎
critical user interaction events (tap, click, scroll, wheel, etc) are queued behind long tasks, which yields janky and unpredictable user experience.
</dd>

	<dt>
~event取扱いの待時間が~~長い／可変：
◎
High/variable event handling latency:
</dt>
	<dd>
~event~callback（例： `onload^et ~event等）の処理について，前項の入力と同様
— それは、~appの更新を遅延する。
◎
similar to input, but for processing event callbacks (e.g. onload events, and so on), which delay application updates.
</dd>

	<dt>
即応しない［
~animation／~scrolling
］：
◎
Janky animations and scrolling:
</dt>
	<dd>
一部の［
~animation／~scrolling
］は、組成器と~main~threadとの間の協調を要求する
— ~main~threadが長い~taskに因り阻まれた場合、［
~animation／~scrolling
］の応答性に影響し得る。
◎
some animation and scrolling interactions require coordination between compositor and main threads; if the main thread is blocked due to a long task, it can affect responsiveness of animations and scrolling.
</dd>
</dl>

<p>
一部の~app（および `RUM^en† ~vendor）は、すでに， “長い~task” が起こる事例を識別して追跡しようと試みている。
【† `Real user monitoring^en （現実の利用者~体験の監視）】
一例を挙げれば、短い周期的な~timerを~installした上で，各~callから次回の~callまでに経過した時間を検分する~patternが知られている。
経過した時間が~timer周期を超えるならば、
1 個~以上の長い~taskが~timerの実行を遅延させた見込みが高いことになる。
これは大体は働くが、いくつかの点で処理能に~~悪影響を及ぼす：
◎
Some applications (and RUM vendors) are already attempting to identify and track cases where "long tasks" happen. For example, one known pattern is to install a ~short periodic timer and inspect the elapsed time between the successive calls: if the elapsed time is greater than the timer period, then there is high likelihood that one or more long tasks have delayed execution of the timer. This mostly works, but it has several bad performance implications:＼
</p>

<ul>
	<li>
~appが長い~taskを検出するために~pollし続けることにより，遊休~時に走らす~codeに割り当てられる “静止期間” が細切れになる（ `requestIdleCallback()$m を見よ）。
◎
the application is polling to detect long tasks, which prevents quiescence and long idle blocks (see requestIdleCallback);＼
</li>
	<li>
~batteryが短命になる。
◎
it’s bad for battery life;＼
</li>
	<li>
何が遅延させたか知るすべが無い（例：当事者-主体, 第三者-主体 どちらの~codeか？）。
◎
there is no way to know who caused the delay (e.g. first party vs third party code).
</li>
</ul>

<p>
<!-- RESPONSETIME？ -->
`RAIL^en【？】処理能~modelから、［
~appは，利用者~入力から 100ms 以内に応答するべきである
］と示唆されている（~touchによる移動や~scrollingに対しては 16ms 以内）。
この~APIの目標は、この~~目的に抵触し得る~taskについての通知を表面化することである。
ここでは、 50ms 以上かかる~taskを表面化する。
そのような~taskを伴わない~web~siteならば、利用者~入力に対し
— それを受信した時点で実行-中の~taskが完遂するまで 50ms 未満,
それに反応する~taskを実行するのも 50ms 未満になるので —
100ms 以内に応答することになるはずである。
◎
The RAIL performance model suggests that applications should respond in under 100ms to user input (for touch move and scrolling, in under 16ms). Our goal with this API is to surface notifications about tasks that may prevent the application from hitting these targets. We surface tasks that take 50ms or more. A website without these tasks should respond to user input in under 100ms: it will take less than 50ms to finish the task that is being executed when the user input is received and less than 50ms to execute the task to react to such user input.
</p>

		<section id="example">
<h3 title="Usage Example">1.1. 用例</h3>

<pre class="example">
var %observer = new PerformanceObserver(function(%list) {
    var %perfEntries = %list.getEntries();
    for (var %i = 0; i &lt; %perfEntries.length; i++) {
        /* <span class="comment">
長い~task通知を処理する：解析と監視~用に報告する…
◎
Process long task notifications: report back for analytics and monitoring ...
</span> */
    }
});

/* <span class="comment">
長い~task通知~用の観測器を登録する
◎
register observer for long task notifications
</span> */
%observer.observe({entryTypes: ["longtask"]});

/* <span class="comment">
以降，長い~script実行が生じたときは、観測器にて `longtask^l ~entryが~queueされ，受信されることになる。
◎
Long script execution after this will result in queueing and receiving "longtask" entries in the observer.
</span> */
</pre>

		</section>
	</section>
	<section id="sec-terminology">
<h2 title="Terminology">2. 各種用語</h2>


<p>
`長い~task@
（ `long task^en ）とは、次に挙げるもののうち，所要時間が 50ms を超過するものを指す：
◎
Long task refers to any of the following occurrences whose duration exceeds 50ms:
</p>

<ul>
	<li>
~event-loop`~task$
【`~event-loop処理~model$の最初の段で選ばれる~task】
と直後の`小task~checkpointを遂行する$ 段。
これは、ある~event-loop`~task$の所要時間を
— それに結付けられた`小task$も含めて —
捕捉する。
◎
An event loop task plus the perform a microtask checkpoint that follows immediately afterwards. This captures the duration of an event loop task, including its associated microtasks.
</li>
	<li>
`~event-loop処理~model$の中の`描画を更新する$ 段。
◎
An update the rendering step within the event loop processing model.
</li>
	<li>
`~event-loop処理~model$の最後の段から次回の最初の段までにおける静止。
これは、［
`~event-loop$の外側にある~UAの~UI~thread
］内で~UAが遂行する作業を捕捉する。
◎
A pause between the last step and the next first step of the event loop processing model. This captures any work that the user agent performs in its UI thread outside of the event loop.
</li>
</ul>

<p>
`元凶~閲覧文脈~容器@
（ `culprit browsing context^en ）とは、ある`長い~task$に全体的に~~関与している`閲覧文脈~容器$（ `iframe$e, `object$e, 等々）を指す。
◎
Culprit browsing context container refers to the browsing context container (iframe, object, etc.) that is being implicated, on the whole, for a long task.
</p>


<p>
`長い~task$の
`帰属@
（ `attribution^en ）とは、次を識別するものを指す
⇒
長い~taskに有意に寄与した作業の種別（ ~script, ~layoutなど）, および
その作業を担当していた`元凶~閲覧文脈~容器$
◎
Attribution refers to identifying the type of work (such as script, layout etc.) that contributed significantly to the long task, as well as identifying which culprit browsing context container is responsible for that work.
</p>

	</section>
	<section id="sec-longtask-timing">
<h2 title="Long Task Timing">3. 長い~taskの計時</h2>

<p>
長い~taskの計時は、以下の新たな~interfaceを孕む：
◎
Long Task timing involves the following new interfaces:
</p>

		<section id="sec-PerformanceLongTaskTiming">
<h3 title="PerformanceLongTaskTiming interface">3.1. `PerformanceLongTaskTiming^I ~interface</h3>

<pre class="idl">
interface `PerformanceLongTaskTiming@I : `PerformanceEntry$I {
    readonly attribute FrozenArray&lt;`TaskAttributionTiming$I&gt; `attribution$m;
};</pre>

<p>
`PerformanceLongTaskTiming$I の各種 属性の値は、`長い~taskを報告する$処理~modelにて設定される。
それらがどう設定されるかについて，参考な要約を以下に供する：
◎
The values of the attributes of a PerformanceLongTaskTiming are set in the processing model in §4.1 Report long tasks. The following provides an informative summary of how they will be set.
</p>

<ul>
	<li>
<p>
`name$m
属性の取得子は、［
当の長い~taskが出自にしているのは、どの`閲覧文脈$の中の~event-loop`~task$か
］に応じて，次に挙げるいずれかの文字列を返すことになる：
◎
The name attribute’s getter will return one of the following strings:
</p>

<dl>
	<dt>`unknown@l</dt>
	<dd>
出自にしているのは、~event-loop`~task$ではない。
◎
The long task did not originate from an event loop task.
</dd>

	<dt>`self@l</dt>
	<dd>
この`閲覧文脈$。
◎
The long task originated from an event loop task within this browsing context.
</dd>

	<dt>`same-origin-ancestor@l</dt>
	<dd>
`同一-生成元$に属する`先祖~閲覧文脈$。
◎
The long task originated from an event loop task within a same-origin ancestor browsing context.
</dd>

	<dt>`same-origin-descendant@l</dt>
	<dd>
`同一-生成元$に属する`子孫~閲覧文脈$。
◎
The long task originated from an event loop task within a same-origin descendant browsing context.
</dd>

	<dt>`same-origin@l</dt>
	<dd>
`同一-生成元$に属する先祖でも子孫でもない`閲覧文脈$。
◎
The long task originated from an event loop task within a same-origin browsing context that is not an ancestor or descendant.
</dd>

	<dt>`cross-origin-ancestor@l</dt>
	<dd>
`同一-生成元$に属さない`先祖~閲覧文脈$。
◎
The long task originated from an event loop task within a cross-origin ancestor browsing context.
</dd>

	<dt>`cross-origin-descendant@l</dt>
	<dd>
`同一-生成元$に属さない`子孫~閲覧文脈$。
◎
The long task originated from an event loop task within a cross-origin descendant browsing context.
</dd>

	<dt>`cross-origin-unreachable@l</dt>
	<dd>
`同一-生成元$に属さない先祖でも子孫でもない`閲覧文脈$。
◎
The long task originated from an event loop task within a cross-origin browsing context that is not an ancestor or descendant.
</dd>

	<dt>`multiple-contexts@l</dt>
	<dd>
複数の`閲覧文脈$を孕んでいる。
◎
Multiple browsing contexts were involved in the long task.
</dd>
</dl>

	</li>
	<li>
`entryType$m 属性の取得子は、 `longtask^l を返す。
◎
The entryType attribute’s getter will return "longtask".
</li>
	<li>
`startTime$m 属性の取得子は、当の~taskが開始された時点を表す `DOMHighResTimeStamp$I 値を返す。
◎
The startTime attribute’s getter will return a DOMHighResTimeStamp of when the task started.
</li>
	<li>
`duration$m 属性の取得子は、当の~taskの開始-から終止-までに経過した時間を表す `DOMHighResTimeStamp$I 値を返す。
◎
The duration attribute’s getter will return a DOMHighResTimeStamp equal to the elapsed time between the start and end of task.
</li>
	<li>
`attribution@m
属性の取得子は、一連の `TaskAttributionTiming$I ~entryからなる凍結d配列を返す。
◎
The attribution attribute’s getter will return a frozen array of TaskAttributionTiming entries.
</li>
</ul>

		</section>
		<section id="sec-TaskAttributionTiming">
<h3 title="TaskAttributionTiming interface">3.2. `TaskAttributionTiming^I ~interface</h3>

<pre class="idl">
interface `TaskAttributionTiming@I : `PerformanceEntry$I {
    readonly attribute `DOMString$ `containerType$m;
    readonly attribute `DOMString$ `containerSrc$m;
    readonly attribute `DOMString$ `containerId$m;
    readonly attribute `DOMString$ `containerName$m;
};</pre>


<p>
`TaskAttributionTiming$I の各種~属性の値は、`長い~taskを報告する$処理~modelにて設定される。
それらがどう設定されるかについて，参考な要約を以下に供する：
◎
The values of the attributes of a TaskAttributionTiming are set in the processing model in §4.1 Report long tasks. The following provides an informative summary of how they will be set.
</p>

<ul>
	<li>
`name$m 属性の取得子は、常に `unknown^l を返す。
◎
The name attribute’s getter will always return "unknown".
</li>
	<li>
`entryType$m 属性の取得子は、常に `taskattribution^l を返す。
◎
The entryType attribute’s getter will always return "taskattribution".
</li>
	<li>
`startTime$m 属性の取得子は、常に 0 を返す。
◎
The startTime attribute’s getter will always return 0.
</li>
	<li>
`duration$m 属性の取得子は、常に 0 を返す。
◎
The duration attribute’s getter will always return 0.
</li>
	<li>
`containerType@m
属性の取得子は、`元凶~閲覧文脈~容器$の型を返す
— `iframe^l, `embed^l, `object^l など。
◎
The containerType attribute’s getter will return the type of the culprit browsing context container, such as "iframe", "embed", or "object".
</li>
	<li>
`containerName@m
属性の取得子は、`元凶~閲覧文脈~容器$の `name^a 内容~属性の値を返す。
◎
The containerName attribute’s getter will return the value of the container’s name content attribute.
</li>
	<li>
`containerId@m
属性の取得子は、`元凶~閲覧文脈~容器$の `id^a 内容~属性の値を返す。
◎
The containerId attribute’s getter will return the value of the container’s id content attribute.
</li>
	<li>
`containerSrc@m
属性の取得子は、`元凶~閲覧文脈~容器$の `src^a 内容~属性の値を返す。
◎
The containerSrc attribute’s getter will return the value of the container’s src content attribute.
</li>
</ul>


		</section>
		<section id="sec-PointingToCulprit">
<h3 title="Pointing to the culprit">3.3. 元凶を指すもの</h3>

~INFORMATIVE

<p>
`長い~task$は、異なる種別の作業（~script, ~layout, ~style等々など）を孕み得る。
また、異なる`閲覧文脈$の中で実行されることもあれば，大域的な資質を備えるものにもなり得る
— ［
`~agent~cluster$ ／ `互いに関係する閲覧文脈~群$ 【`閲覧文脈~group$】
］全体にわたる長い~garbage収集など。
◎
A long task can involve different types of work (such as script, layout, style etc), and it could be executed within different browsing contexts, or it could be global in nature such as a long garbage collection that spans the entire agent cluster or unit of related browsing contexts.
</p>

<p>
したがって，`帰属$が指すものには少数の~~側面がある：
◎
Thus attribution has a couple of facets:
</p>

<ul>
	<li>
当の長い~taskの生成元や`元凶~閲覧文脈~容器$の［
全体の中での所在
］
— これは、
`最小限の元凶~帰属@
（ `minimal culprit attribution^en ）と称され，
`name$m ~fieldにて捕捉される。
◎
Pointing to the origin of the long task and/or the overall location of the culprit browsing context: this is referred to as minimal culprit attribution and is captured in the name field.
</li>
	<li>
`長い~task$が孕む作業の種別, およびそれに結付けられた`元凶~閲覧文脈~容器$
— これは、 `PerformanceLongTaskTiming$I の `attribution$m ~field内の各 `TaskAttributionTiming$I ~objにて捕捉される。
◎
Pointing to the type of work involved in the long task, and its associated culprit browsing context container: this is captured in TaskAttributionTiming objects in the attribution field of PerformanceLongTaskTiming.
</li>
</ul>

<p>
したがって， `PerformanceLongTaskTiming$I 上の［
`name$m,
`attribution$m
］~fieldの組は、長い~taskの~~原因がどこにあるか~~実像を~~描く。
この情報を送達するときには、~Webの同一-生成元~施策を固守するモノトスル。
◎
Therefore, name and attribution fields on PerformanceLongTaskTiming together paint the picture for where the blame rests for a long task. When delivering this information the Web’s same-origin policy must be adhered to.
</p>

<p>
これらの~fieldは~~相関する
— どう関係するかの概観を次に与える：
◎
These fields are not independent. The following gives an overview of how they are related:
</p>

<div>

<table><thead>
<tr><th>`name$m
</th><th>`attribution$m
（`帰属$）に~~関与している`元凶~閲覧文脈~容器$
</th></tr></thead>

<tbody>

<tr><td>`self$l
</td><td>空
</td></tr>

<tr><td>`same-origin-ancestor$l
</td><td>元凶は同一-生成元に属する
</td></tr>

<tr><td>`same-origin-descendant$l
</td><td>元凶は同一-生成元に属する
</td></tr>

<tr><td>`same-origin$l
</td><td>元凶は同一-生成元に属する
</td></tr>

<tr><td>`cross-origin-ancestor$l
</td><td>空
</td></tr>

<tr><td>`cross-origin-descendant$l
</td><td>空
</td></tr>

<tr><td>`cross-origin-unreachable$l
</td><td>空
</td></tr>

<tr><td>`multiple-contexts$l
</td><td>空
</td></tr>

<tr><td>`unknown$l
</td><td>空
</td></tr></tbody></table>

◎
name 	Culprit browsing context container implicated by attribution
"self" 	empty
"same-origin-ancestor" 	same-origin culprit
"same-origin-descendant" 	same-origin culprit
"same-origin" 	same-origin culprit
"cross-origin-ancestor" 	empty
"cross-origin-descendant" 	empty
"cross-origin-unreachable" 	empty
"multiple-contexts" 	empty
"unknown" 	empty
</div>

		</section>
	</section>
	<section id="sec-processing-model">
<h2 title="Processing model">4. 処理~model</h2>

<p>
`Long Tasks^cite APIを実装する~UAは、【利用される前に】次を走らすモノトスル
⇒
`処理能~entry種別を登録する$( `longtask^l )
◎
A user agent implementing the Long Tasks API must run the register a performance entry type algorithm with "longtask" as input.
</p>

		<section id="report-long-tasks">
<h3 title="Report long tasks">4.1. 長い~taskを報告する</h3>

<div class="algorithm">

<p>
所与の
( %開始-時刻, %終止-時刻, %~top-level閲覧文脈たち, %~task （省略時は ε） )
に対し，次の~algoを遂行する：
◎
Given start time, end time, top-level browsing contexts, and optionally task, perform the following algorithm:
</p>

<ol>
	<li>
~IF［
%終止-時刻 ~MINUS %開始-時刻 ~LT 50ms（長い~taskの閾値）
］
⇒
~RET
◎
If end time minus start time is less than the long tasks threshold of 50 ms, abort these steps.
</li>
	<li>
%行先~realmたち ~LET 空~集合
◎
Let destinationRealms be an empty set.
</li>
	<li>
<p>
（この段は、報告の送達-先になる`~JS~realm$の集合を決定する）
◎
Determine the set of JavaScript Realms to which reports will be delivered:
</p>

<p>
%~top-level閲覧文脈たち 内の
~EACH( `~top-level閲覧文脈$ %T )
に対し：
◎
For each top-level browsing context topmostBC in top-level browsing contexts:
</p>
		<ol>
			<li>
%行先~realmたち に %T の`~window$†に`関連する~Realm$を追加する
◎
Add topmostBC’s Window’s relevant Realm to destinationRealms.
</li>
			<li>
%T にて`作動中の文書$の`子孫~閲覧文脈~list$内の
~EACH( %子孫 )
に対し
⇒
%行先~realmたち に %子孫 の`~window$†に`関連する~Realm$を追加する
◎
Let descendantBCs be topmostBC’s active document’s list of the descendant browsing contexts.
◎
For each descendantBC in descendantBCs, add descendantBC’s Window’s relevant Realm to destinationRealms.
</li>
		</ol>

<p class="trans-note">【†
閲覧文脈の`~window$とは、具体的には，閲覧文脈の `WindowProxy^I ~objが
<a href="~WINDOW#concept-windowproxy-window">代理しているそれ</a>
を指すと考えればよいであろう。
】</p>

	</li>
	<li>
<p>
%行先~realmたち 内の
~EACH( %行先~realm )
に対し【順序は言及されていない】：
◎
For each destinationRealm in destinationRealms:
</p>
		<ol>
			<li>
%名前 ~LET 空~文字列
— これは、下で`最小限の元凶~帰属$を報告するために利用されることになる
◎
Let name be the empty string. This will be used to report minimal culprit attribution, below.
</li>
			<li>
%元凶~設定群 ~LET ~NULL
◎
Let culpritSettings be null.
</li>
			<li>
%元凶~閲覧文脈 ~LET ~NULL
◎
↓↓</li>
			<li>
~IF［
%~task ~EQ ε
］
⇒
%名前 ~SET `unknown$l
◎
If the task argument was not provided, set name to "unknown".
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:＼
</p>
				<ol>
					<li>
<p>
%設定群たち ~LET %~task の`~script評価 環境~設定群~obj集合$
</p>
<p>
（以下では、 %設定群たち を処理して，
%名前, %元凶~設定群
を決定する）
</p>
◎
process task’s script evaluation environment settings object set to determine name and culpritSettings as follows:
</li>
					<li>
~IF［
%設定群たち は空である
］
⇒
%名前 ~SET `unknown$l
◎
If task’s script evaluation environment settings object set is empty: set name to "unknown" and culpritSettings to null.
</li>
					<li>
~IF［
%設定群たち の長さ ~GT 1
］
⇒
%名前 ~SET `multiple-contexts$l
◎
If task’s script evaluation environment settings object set’s length is greater than one: set name to "multiple-contexts" and culpritSettings to null.
</li>
					<li>
<p>
~IF［
%設定群たち の長さ ~EQ 1
］：
◎
If task’s script evaluation environment settings object set’s length is one:
</p>
						<ol>
							<li>
%元凶~設定群 ~SET %設定群たち を成す単独の~item
◎
Set culpritSettings to the single item in task’s script evaluation environment settings object set.
</li>
							<li>
%行先~設定群 ~LET %行先~realm に`関連する設定群~obj$
◎
Let destinationSettings be destinationRealm’s relevant settings object.
◎
↓Let destinationOrigin be destinationSettings’s origin.
</li>
							<li>
%行先~閲覧文脈 ~LET %行先~設定群 の`担当の閲覧文脈$enV
◎
Let destinationBC be destinationSettings’s responsible browsing context.
</li>
							<li>
%子孫~閲覧文脈たち ~LET %行先~閲覧文脈 【にて`作動中の文書$】の`子孫~閲覧文脈~list$
◎
↓</li>
							<li>
%元凶~閲覧文脈 ~SET %元凶~設定群 の`担当の閲覧文脈$enV
◎
↓</li>
							<li>
~IF［
%元凶~設定群 ~EQ %行先~設定群
］
⇒
%名前 ~SET `self$l
◎
If culpritSettings is the same as destinationSettings, set name to "self".
</li>
							<li>
<p>
~IF†［
( %元凶~設定群 の`生成元$enV, %行先~設定群 の`生成元$enV )
は`同一-生成元$である
］：
◎
If culpritSettings’s origin and destinationOrigin are same origin:
</p>

<p class="trans-note">【†
ここは ~ELIF のはず
— さもなければ、前段が無意味になる。
】</p>
								<ol>
									<li>
~IF［
%元凶~閲覧文脈 は %行先~閲覧文脈 の`先祖~閲覧文脈$である
］
⇒
%名前 ~SET `same-origin-ancestor$l
◎
If culpritSettings’s responsible browsing context is an ancestor of destinationBC, set name to "same-origin-ancestor".
</li>
									<li>
~ELIF［
%元凶~閲覧文脈 ~IN %子孫~閲覧文脈たち
］
⇒
%名前 ~SET `same-origin-descendant$l
◎
Otherwise, if culpritSettings’s responsible browsing context is a descendant of destinationBC, set name to "same-origin-descendant".
</li>
									<li>
~ELSE
⇒
%名前 ~SET `same-origin$l
◎
Otherwise, set name to "same-origin".
</li>
								</ol>
							</li>
							<li>
<p>
~ELSE：
◎
Otherwise:
</p>
								<ol>
									<li>
<p>
~IF［
%元凶~閲覧文脈 は %行先~閲覧文脈 の`先祖~閲覧文脈$である
］
⇒＃
%名前 ~SET `cross-origin-ancestor$l；
%元凶~設定群 ~SET ~NULL
◎
If culpritSettings’s responsible browsing context is an ancestor of destinationBC, set name to "cross-origin-ancestor" and set culpritSettings to null.
</p>

<p class="note">注記：
~securityのため、これは報告されない。
開発者は、自身でこれを~~調べるべきである。
◎
NOTE: this is not reported because of security. Developers should look this up themselves.
</p></li>
									<li>
~ELIF［
%元凶~閲覧文脈 ~IN %子孫~閲覧文脈たち
］
⇒
%名前 ~SET `cross-origin-descendant$l
◎
Otherwise, if culpritSettings’s responsible browsing context is a descendant of destinationBC, set name to "cross-origin-descendant".
</li>
									<li>
~ELSE
⇒
%名前 ~SET `cross-origin-unreachable$l
◎
Otherwise, set name to "cross-origin-unreachable".
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%帰属 ~LET ~NULL
◎
If task was not provided, let attribution be null.
</li>
			<li>
<p>
~IF［
%~task ~NEQ ε
］：
◎
Otherwise,＼
</p>
				<ol>
					<li>
<p>
%帰属 ~LET 次のようにされた新たな `TaskAttributionTiming$I ~obj
⇒＃
`name$m 属性 ~SET `unknown$l,
`entryType$m 属性 ~SET `taskattribution^l,
`startTime$m 属性 ~SET 0,
`duration$m 属性 ~SET 0
</p>

<p class="note">注記：
この~APIの将来~版では， `name$m 属性~用に他の値も追加することになるが、今の所は一種類の値しかとり得ない。
</p>

◎
let attribution be a new TaskAttributionTiming object and set its attributes as follows:
◎
Set attribution’s name attribute to "unknown".
◎
NOTE: future iterations of this API will add more values to the name attribute of a TaskAttributionTiming object, but for now it can only be a single value.
◎
Set attribution’s entryType attribute to "taskattribution".
◎
Set attribution’s startTime and duration to 0.
</li>
					<li>
<p>
~IF［
%元凶~閲覧文脈 ~NEQ ~NULL
］~AND［
%元凶~閲覧文脈 を`入子にしている閲覧文脈~容器$ %iframe はある
］~AND［
%iframe は `iframe$e 要素である
］：
◎
If culpritSettings is not null, and culpritSettings’s responsible browsing context has a browsing context container that is an iframe element, then let iframe be that element, and perform the following steps:
</p>

<p class="trans-note">【
条件が満たされない場合、以下の属性に何を設定するか定義されていない。
】</p>

						<ol>
							<li>
%帰属 の `containerType$m 属性 ~SET `iframe^l
◎
Set attribution’s containerType attribute to "iframe".
</li>
							<li>
%帰属 の `containerName$m 属性 ~SET ［
%~iframe は `name$a 内容~属性を有するならば その値 ／
~ELSE_ ~NULL
］
◎
Set attribution’s containerName attribute to the value of iframe’s name content attribute, or null if the attribute is absent.
</li>
							<li>
<p>
%帰属 の `containerSrc$m 属性 ~SET ［
%~iframe は `src$a 内容~属性を有するならば その値 ／
~ELSE_ ~NULL
］
◎
Set attribution’s containerSrc attribute to the value of iframe’s src content attribute, or null if the attribute is absent.
</p>

<p class="note">注記：
ここで~frameの現在の~URLではなく， `src$a 属性を記録するのは意図的である
— これは、第一に~frameを識別し易くすることが意味されていることに加え、非同一-生成元~iframeの現在の~URLの発見を許容するのは，~security問題になるので。
◎
NOTE: it is intentional that we record the frame’s src attribute here, and not its current URL, as this is meant primarily to help identify frames, and allowing discovery of the current URL of a cross-origin iframe is a security problem.
</p>
							</li>
							<li>
%帰属 の `containerId$m 属性 ~SET ［
%~iframe の`~ID$があればその値 ／
~ELSE_ ~NULL
］
◎
Set attribution’s containerId attribute to the value of iframe’s ID, or null if the ID is unset.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%新たな~entry ~LET 次のように設定された新たな `PerformanceLongTaskTiming$I ~obj
⇒＃
`name$m 属性 ~SET %名前
`entryType$m 属性 ~SET `longtask^l
`startTime$m 属性 ~SET %開始-時刻
`startTime$m 属性 ~SET %終止-時刻 ~MINUS %開始-時刻
◎
Create a new PerformanceLongTaskTiming object newEntry and set its attributes as follows:
• Set newEntry’s name attribute to name.
• Set newEntry’s entryType attribute to "longtask".
• Set newEntry’s startTime attribute to start time.
• Set newEntry’s startTime attribute to end time minus start time.
</li>
			<li>
<p>
~IF［
%帰属 ~NEQ ~NULL
］
⇒
%新たな~entry の `attribution$m 属性 ~SET `凍結d配列を作成する$( « %帰属 » )
◎
If attribution is not null, set newEntry’s attribution attribute to a new frozen array containing the single value attribution.
</p>

<p class="note">注記：
この~APIの将来~版では， `attribution$m 属性に他の値も追加することになるが、今の所は単独の値しか包含し得ない。
◎
NOTE: future iterations of this API will add more values to the attribution attribute, but for now it only contains a single value.
</p>
			</li>
			<li>
<p>
%行先~realm 上で`処理能~entryを~queueする$( %新たな~entry )
◎
Queue the PerformanceEntry newEntry on destinationRealm.
</p>

<p class="note">注記：
“処理能~entryを~queueする” ~algoは、登録されている観測器が無い場合は，何もしないことになる。
その事例では、実装は，この~algoから早めに抜け出たいと求めるであろう
— 上で組立てた情報は~~無駄になるので。
◎
NOTE: the "queue a PerformanceEntry" algorithm will end up doing nothing if no observers are registered. Implementations likely will want to bail out from this algorithm earlier in that case, instead of assembling all the above information only to find out nobody is listening for it.
</p>
			</li>
		</ol>
	</li>
</ol>

</div>

		</section>
	</section>
	<section id="priv-sec">
<h2 title="Security &amp; privacy considerations">5. ~securityと~privacy上の考慮点</h2>

<p>
`Long Tasks^cite ~APIは、［
長い~taskの源について，生成元~安全な帰属~情報を含める
］ことにより，同一-生成元~施策を固守する。
また、長い~task用には閾値 50ms がある。
これらは、~browserに対する~security攻撃に抗する必要十分な保護を供する。
◎
Long Tasks API adheres to the same-origin policy by including origin-safe attribution information about the source of the long task. There is a 50ms threshold for long tasks. Together this provides adequate protection against security attacks against browser.
</p>

<p>
しかしながら，~privacyに関係する攻撃はアリである。
この~API自体は新たな~privacy攻撃を導入しないが、既存の~privacy攻撃を速くすることもできる。
これを軽減することはアリであり，
<a href="https://docs.google.com/document/d/1tIMI1gau_q6X5EBnjDNiFS5NWV9cpYJ5KKA7xPd3VB8/edit">この文書</a>
内の~security考査に論じられている。
◎
However, privacy related attacks are possible, while the API doesn’t introduce any new privacy attacks, it could make existing privacy attacks faster. Mitigations for this are possible and discussed in the security review in this document.
</p>

	</section>
</main></div>
