<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fetch Standard （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>

code {
	white-space:nowrap;
}

._narrow-cell {
	position:relative;
}

._narrow-cell > * {
	position: absolute;
	top: -3em;
	left: 0;
}

._narrow-cell > *::before {
	position: absolute;
	top: 1.5em;
	left: 1em;
	color: gray;
	content: "↓";
}

#_cors-safelisted-request-header-table td:first-child {
	white-space: pre-line;
}

td > pre {
	margin: 0;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_ifc = '';

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';
let quote = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'h': // http header
	quote = '`';
	break;
case 'hm': // http method
	quote = '`';
	break;
case 'bl': // byte sequence literal
	quote = '`';
	break;
case 'l':
	quote = '"';
	break;
case 'I':
	if(indicator === '@'){
		idl_ifc = key;
	}
	break;
case 'RqI': // RequestInit member
	href = `#dom-requestinit-${key.toLowerCase()}`;
	break;
case 'RsI': // ResponseInit member
	href = `#dom-responseinit-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = '#dom-' + (
		(key === idl_ifc) ? idl_ifc : `${idl_ifc}-${key}`
	).toLowerCase();
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'dir': // CSP directive
	href = `~CSP3#${key}`;
	break;
case 'e':
	text = `&lt;${text}&gt;`;
	break;
case 'X': // byte value
	text = `0x${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'mF': // IDL member (File)
case 'st': // http responce status code
case 'E': // error name
case 'i': // model constants
case 'A': // abstract opration
case 'V': // variables
case 'p': // protocol element
case 'Z': // escape
default: //
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return (
	quote + text + quote
);

	}
}
// TODO: 各 enum 定数にも id を付与する
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Fetch
spec_date:2020-09-10
trans_update:2020-08-28
source_checked:200806
spec_status:LS
original_url:https://fetch.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,http,security,storage
copyright:,whatwg
trans_1st_pub:2013-04-27

●●class_map
e:element
a:attr
E:error
et:event-type
h:header
hm:method
st:status
dir:directive
p:protocol
css:css
at:css
l:literal
bl:literal
X:hex-value
U:code-point
A:abstract
sl:js-slot
jv:js-value

●●tag_map
I:code
m:code
mF:code
et:code
RqI:code
RsI:code
E:code
h:code
hm:code
l:code
bl:code
c:code
at:code
css:code
e:code
a:code
p:var
st:code
dir:code
s:samp
V:var
i:i
cN:b
X:span
U:span
A:span
sl:span
jv:code
cite:cite
em:em

●●original_id_map

dom-headers-iterable:

●●mdn_urls
http-access-control-allow-credentials:HTTP/Headers/Access-Control-Allow-Credentials
http-access-control-allow-headers:HTTP/Headers/Access-Control-Allow-Headers
http-access-control-allow-methods:HTTP/Headers/Access-Control-Allow-Methods
http-access-control-allow-origin:HTTP/Headers/Access-Control-Allow-Origin
http-access-control-expose-headers:HTTP/Headers/Access-Control-Expose-Headers
http-access-control-Max-age:HTTP/Headers/Access-Control-Max-Age
http-access-control-request-headers:HTTP/Headers/Access-Control-Request-Headers
http-access-control-request-method:HTTP/Headers/Access-Control-Request-Method
http-origin:HTTP/Headers/Origin
http-x-content-type-options:HTTP/Headers/X-Content-Type-Options
http-cross-origin-resource-policy:HTTP/Headers/Cross-Origin-Resource-Policy

headers:API/Headers
body:API/Body
request:API/Request
requestdestination:API/RequestDestination
response:API/Response
	typedefdef-headersinit:API/HeadersInit
	requestinit:API/RequestInit
	requestmode:API/RequestMode
	requestinfo:API/RequestInfo
	requestcredentials:API/RequestCredentials
	requestcache:API/RequestCache
	requestredirect:API/RequestRedirect
	responseinit:API/ResponseInit
	responsetype:API/ResponseType
	bodyinit:API/BodyInit
	typedefdef-xmlhttprequestbodyinit:API/XMLHttpRequestBodyInit

●●link_map

	●HTTP header/methods
h.Access-Control-Allow-Credentials:#http-access-control-allow-credentials
h.Access-Control-Allow-Headers:#http-access-control-allow-headers
h.Access-Control-Allow-Methods:#http-access-control-allow-methods
h.Access-Control-Allow-Origin:#http-access-control-allow-origin
h.Access-Control-Expose-Headers:#http-access-control-expose-headers
h.Access-Control-Max-Age:#http-access-control-Max-age
h.Access-Control-Request-Headers:#http-access-control-request-headers
h.Access-Control-Request-Method:#http-access-control-request-method
h.Origin:#http-origin
h.X-Content-Type-Options:#http-x-content-type-options
h.Cross-Origin-Resource-Policy:#http-cross-origin-resource-policy

h.Accept-Charset:~HTTPrq#field.accept-charset
h.Accept-Encoding:~HTTPrq#field.accept-encoding
h.Accept-Language:~HTTPrq#field.accept-language
h.Accept:~HTTPrq#field.accept
h.Allow:~HTTPrs#field.allow
h.Authorization:~HTTPrq#field.authorization
h.Cache-Control:~HTTPcache#field.cache-control
h.Connection:~HTTPsem#field.connection
h.Content-Encoding:~HTTPsem#field.content-encoding
h.Content-Language:~HTTPsem#field.content-language
h.Content-Length:~HTTPsem#field.content-length
h.Content-Location:~HTTPsem#field.content-location
h.Content-Type:~HTTPsem#field.content-type
h.Date:~HTTPrs#field.date
h.ETag:~HTTPrs#field.etag
h.Expect:~HTTPrq#field.expect
h.Expires:~HTTPcache#field.expires
h.Host:~HTTPsem#field.host
h.If-Match:~HTTPrq#field.if-match
h.If-Modified-Since:~HTTPrq#field.if-modified-since
h.If-None-Match:~HTTPrq#field.if-none-match
h.If-Range:~HTTPrq#field.if-range
h.If-Unmodified-Since:~HTTPrq#field.if-unmodified-since
h.Keep-Alive:~HTTPmsg#compatibility.with.http.1.0.persistent.connections
h.Last-Modified:~HTTPrs#field.last-modified
h.Location:~HTTPrs#field.location
h.Pragma:~HTTPcache#field.pragma
h.Proxy-Authenticate:~HTTPrs#field.proxy-authenticate
h.Range:~HTTPrq#field.range
h.Referer:~HTTPrq#field.referer
h.TE:~HTTPsem#field.te
h.Trailer:~HTTPsem#field.trailer
h.Transfer-Encoding:~HTTPmsg#field.transfer-encoding
h.Upgrade:~HTTPsem#field.upgrade
h.User-Agent:~HTTPrq#field.user-agent
h.Vary:~HTTPrs#field.vary
h.Via:~HTTPsem#field.via
h.WWW-Authenticate:~HTTPrs#field.www-authenticate

h.Link:~HTTPweblink#field.link
h.Cookie:~HTTPcookie#sane-cookie
h.Set-Cookie:~HTTPcookie#sane-set-cookie
h.Timing-Allow-Origin:~RESOURCE-TIMING#dfn-timing-allow-origin
	h.Sec-WebSocket-Key:~RFC6455#
	h.Sec-WebSocket-Version:~RFC6455#
	h.Sec-WebSocket-Protocol:~RFC6455#
	h.Sec-WebSocket-Extensions:~RFC6455#

Content-Security-Policy:~CSP3#header-content-security-policy
Strict-Transport-Security

	Do Not Track HTTP header
	h.DNT:~RFCx/draft-mayer-do-not-track-00

	//未使用
	h.Accept-Ranges:~7233#section-2.3
	h.Age:~7234#section-5.1
	h.Close:~7230#section-8.1
	h.Content-Range:~7233#section-4.2
	h.ETag:~7232#section-2.3
	h.From:~7231#section-5.5.1
	h.MIME-Version:~7231#appendix-A.1
	h.Max-Forwards:~7231#section-5.1.2
	h.Proxy-Authorization:~7235#section-4.4
	h.Retry-After:~7231#section-7.1.3
	h.Server:~7231#section-7.4.2
	h.Warning:~7234#section-5.5

	●mehods
hm.CONNECT:~HTTPrq#CONNECT
hm.DELETE:~HTTPrq#DELETE
hm.GET:~HTTPrq#GET
hm.HEAD:~HTTPrq#HEAD
hm.OPTIONS:~HTTPrq#OPTIONS
hm.POST:~HTTPrq#POST
hm.PUT:~HTTPrq#PUT
hm.TRACE:~HTTPrq#TRACE
hm.TRACK:#biblio-httpverbsec2


p.field-name:~HTTPsem#p.field-name
p.method:~HTTPmsg#p.method
p.delta-seconds:~HTTPcache#p.delta-seconds
p.reason-phrase:~HTTPmsg#p.reason-phrase
	p.wildcard
	p.field-name-or-wildcard
	p.origin-or-null

	●status code
st.101:~HTTPrs#status.101
st.200:~HTTPrs#status.200
st.204:~HTTPrs#status.204
st.205:~HTTPrs#status.205
st.206:~HTTPrs#status.206
st.3xx:~HTTPrs#status.3xx
st.301:~HTTPrs#status.301
st.302:~HTTPrs#status.302
st.303:~HTTPrs#status.303
st.304:~HTTPrs#status.304
st.307:~HTTPrs#status.307
st.308:~HTTPrs#status.308
st.401:~HTTPrs#status.401
st.403:~HTTPrs#status.403
st.407:~HTTPrs#status.407

	●HTML 要素
e.head:~HEmetadata#the-head-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.script:~HEscripting#the-script-element
e.a:~HEtextlevel#the-a-element
e.picture:~HEimages#the-picture-element
e.audio:~HEmedia#the-audio-element
e.embed:~HEembed#the-embed-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.object:~HEembed#the-object-element
e.source:~HEimages#the-source-element
e.track:~HEtrack#the-track-element
e.video:~HEmedia#the-video-element
e.frame:~HTMLobs#frame
e.image:~SVGembedded#ImageElement


	●idl interface／type

Exposed:~WEBIDLjs#Exposed
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.AbortError:~WEBIDL#aborterror
E.TypeError:~WEBIDL#exceptiondef-typeerror

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short
DOMString:~WEBIDL#idl-DOMString
USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
Promise:~WEBIDL#idl-promise

I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array

I.Body:#body
I.BodyInit:#bodyinit
I.Headers:#headers
I.HeadersInit:#typedefdef-headersinit
I.ReadableStream:~STREAMS#readablestream
I.Request:#request
I.RequestCache:#requestcache
I.RequestCredentials:#requestcredentials
I.RequestDestination:#requestdestination
I.RequestInfo:#requestinfo
I.RequestInit:#requestinit
I.RequestMode:#requestmode
I.RequestRedirect:#requestredirect
I.Response:#response
I.ResponseInit:#responseinit
I.ResponseType:#responsetype
I.XMLHttpRequestBodyInit:#typedefdef-xmlhttprequestbodyinit

I.AbortSignal:~DOM4#abortsignal
I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.FormData:~XHR#formdata
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XMLHttpRequestUpload:~XHR#xmlhttprequestupload
I.WebSocket:~WEBSOCKET#websocket
I.URLSearchParams:~URL1#dom-urlsearchparams
I.Window:~WINDOW#window
I.Worker:~WORKERS#worker
I.SharedWorker:~WORKERS#sharedworker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.ServiceWorkerGlobalScope:~SW1#serviceworkerglobalscope
I.ReferrerPolicy:~REFERRER-POLICY#enumdef-referrerpolicy
I.EventSource:~HTMLsse#eventsource


I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.URL:~URL1#url

	■Headers
m.new Headers:#dom-headers
	m.delete:#dom-headers-delete
	m.get:#dom-headers-get
	m.has:#dom-headers-has
	m.set:#dom-headers-set
	m.value:#dom-headers-value
	m.iterable:#dom-headers-iterable

	■Body
	m.body:#dom-body-body
	m.bodyUsed:#dom-body-bodyused
	m.arrayBuffer:#dom-body-arraybuffer
	m.blob:#dom-body-blob
	m.formData:#dom-body-formdata
	m.json:#dom-body-json
	m.text:#dom-body-text

	■BodyInit

	■Request
m.new Request:#dom-request
	m.method:#dom-request-method
	m.url:#dom-request-url
	m.headers:#dom-request-headers
	m.destination:#dom-request-destination
	m.referrer:#dom-request-referrer
	m.referrerPolicy:#dom-request-referrerpolicy
	m.mode:#dom-request-mode
	m.credentials:#dom-request-credentials
	m.cache:#dom-request-cache
	m.redirect:#dom-request-redirect
	m.integrity:#dom-request-integrity
	m.keepalive:#dom-request-keepalive
	m.isReloadNavigation:#dom-request-isreloadnavigation
	m.isHistoryNavigation:#dom-request-ishistorynavigation
	m.signal:#dom-request-signal
	m.clone:#dom-request-clone

	■RequestInfo

	■RequestInit
	m.method:#dom-requestinit-method
	m.headers:#dom-requestinit-headers
	m.body:#dom-requestinit-body
	m.referrer:#dom-requestinit-referrer
	m.referrerPolicy:#dom-requestinit-referrerpolicy
	m.mode:#dom-requestinit-mode
	m.credentials:#dom-requestinit-credentials
	m.cache:#dom-requestinit-cache
	m.redirect:#dom-requestinit-redirect
	m.integrity:#dom-requestinit-integrity
	m.keepalive:#dom-requestinit-keepalive
	m.signal:#dom-requestinit-signal
	m.window:#dom-requestinit-window

	■RequestDestination
	m."":#dom-requestdestination
	m.audio:#dom-requestdestination-audio
	m.audioworklet:#dom-requestdestination-audioworklet
	m.document:#dom-requestdestination-document
	m.embed:#dom-requestdestination-embed
	m.font:#dom-requestdestination-font
	m.image:#dom-requestdestination-image
	m.manifest:#dom-requestdestination-manifest
	m.object:#dom-requestdestination-object
	m.paintworklet:#dom-requestdestination-paintworklet
	m.report:#dom-requestdestination-report
	m.script:#dom-requestdestination-script
	m.sharedworker:#dom-requestdestination-sharedworker
	m.style:#dom-requestdestination-style
	m.track:#dom-requestdestination-track
	m.video:#dom-requestdestination-video
	m.worker:#dom-requestdestination-worker
	m.xslt:#dom-requestdestination-xslt

	■RequestMode
	m.navigate:#dom-requestmode-navigate
	m.same-origin:#dom-requestmode-same-origin
	m.no-cors:#dom-requestmode-no-cors
	m.cors:#dom-requestmode-cors

	■RequestCredentials
	m.omit:#dom-requestcredentials-omit
	m.same-origin:#dom-requestcredentials-same-origin
	m.include:#dom-requestcredentials-include

	■RequestCache
	m.default:#dom-requestcache-default
	m.no-store:#dom-requestcache-no-store
	m.reload:#dom-requestcache-reload
	m.no-cache:#dom-requestcache-no-cache
	m.force-cache:#dom-requestcache-force-cache
	m.only-if-cached:#dom-requestcache-only-if-cached

	■RequestRedirect
	m.follow:#dom-requestredirect-follow
	m.error:#dom-requestredirect-error
	m.manual:#dom-requestredirect-manual

	■Response
m.new Response:#dom-response
	m.error:#dom-response-error
	m.redirect:#dom-response-redirect
	m.status:#dom-response-status
	m.type:#dom-response-type
	m.url:#dom-response-url
	m.redirected:#dom-response-redirected
	m.status:#dom-response-status
	m.ok:#dom-response-ok
	m.statusText:#dom-response-statustext
	m.headers:#dom-response-headers
	m.clone:#dom-response-clone

	■ResponseInit
	m.status:#dom-responseinit-status
	m.statusText:#dom-responseinit-statustext
	m.headers:#dom-responseinit-headers

	■ResponseType
	m.basic:#dom-responsetype-basic
	m.cors:#dom-responsetype-cors
	m.default:#dom-responsetype-default
	m.error:#dom-responsetype-error
	m.opaque:#dom-responsetype-opaque
	m.opaqueredirect:#dom-responsetype-opaqueredirect

m.fetch:#dom-global-fetch
m.response.url:#dom-response-url
m.response.ok:#dom-response-ok
m.navigator.sendBeacon:~BEACON#sec-sendBeacon-method
m.self.importScripts:~WORKERS#dom-workerglobalscope-importscripts
m.navigator.serviceWorker.register:~SW1#dom-serviceworkercontainer-register

mF.size:~FILEAPI#dfn-size
mF.type:~FILEAPI#dfn-type
mF.name:~FILEAPI#dfn-name

et.fetch:~SW1#service-worker-global-scope-fetch-event

at.font-face:~CSSFONT#font-face-rule
at.import:~CASCADE#at-ruledef-import

	●URL
~HTTP_S~scheme:#http-scheme
~network~scheme:#network-scheme
~fetch~scheme:#fetch-scheme
局所~scheme:#local-scheme
局所的:#is-local
応答~URL:#response-url

	●message 構成子
認証~entry:#authentication-entry
~proxy認証~entry:#proxy-authentication-entry

~HTTP~tab-or-space:#http-tab-or-space
~HTTP~tab-or-space~byte:#http-tab-or-space-byte
~HTTP空白:#http-whitespace
~HTTP空白~byte:#http-whitespace-byte
~HTTP改行~byte:#http-newline-byte
資格証:#credentials

~ABNF:#abnf

	●~header~list
~header~list:#concept-header-list
~headerを付加する:#concept-header-list-append
~headerを削除する:#concept-header-list-delete
~headerを設定する:#concept-header-list-set
有構造~field値を取得する:#concept-header-list-get-structured-header
有構造~field値を設定する:#concept-header-list-set-structured-header
~headerを結合する:#concept-header-list-combine
~header~listを~sortして結合する:#concept-header-list-sort-and-combine
~header名たちを小文字~化して~sortした集合に変換する:#convert-header-names-to-a-sorted-lowercase-set

~header~listから値を取得する:#concept-header-list-get
~header~listから値を抽出する:#extract-header-list-values
~header~listから値を取得して復号して分割する:#concept-header-list-get-decode-split
~header~listから~MIME型を抽出する:#concept-header-extract-mime-type

要請~Origin~headerを付加する:#append-a-request-origin-header

	●~header
~header:#concept-header
新たな~header:#_new-header
名前に持つ~header:#_headers-of-name
hd.包含する:#header-list-contains

hd.名前:#concept-header-name
hd.値:#concept-header-value
値を正規化する:#concept-header-value-normalize
~headerから値を抽出する:#extract-header-values
値を抽出-:#extract-header-values
~HTTP引用符付き文字列を収集する:#collect-an-http-quoted-string

~CORS安全とされる要請~header:#cors-safelisted-request-header
~CORS非安全な要請~header名たち:#cors-unsafe-request-header-names
~CORS非安全な要請~header~byte:#cors-unsafe-request-header-byte
~CORSなしで安全とされる要請~header名:#no-cors-safelisted-request-header-name
~CORSなしで安全とされる要請~header:#no-cors-safelisted-request-header
~CORS非~wildcard要請~header名:#cors-non-wildcard-request-header-name
禁止~header名:#forbidden-header-name
禁止~応答~header名:#forbidden-response-header-name
要請~本体~header名:#request-body-header-name
~CORS安全とされる応答~header名:#cors-safelisted-response-header-name
特権的~CORSなし要請~header名:#privileged-no-cors-request-header-name

既定の User-Agent 値:#default-user-agent-value

	●method
~method:#concept-method
~methodを正規化する:#concept-method-normalize
md.正規化-:#concept-method-normalize
禁止~method:#forbidden-method
~CORS安全とされる~method:#cors-safelisted-method

	●status
状態s:#concept-status
~null本体~状態s:#null-body-status
~ok状態s:#ok-status
~redirect状態s:#redirect-status

	●本体
本体:#concept-body
bd.伝送-済み~byte数:#concept-body-transmitted
bd.総~byte数:#concept-body-total-bytes
bd.~source:#concept-body-source
bd.~stream:#concept-body-stream
bd.~done:#concept-body-done
本体を待機する:#concept-body-wait
本体を~cloneする:#concept-body-clone

	●要請
要請:#concept-request
rq.~method:#concept-request-method
rq.~URL:#concept-request-url
rq.局所~URLのみ~flag:#local-urls-only-flag
rq.~header~list:#concept-request-header-list
rq.非安全~要請~flag:#unsafe-request-flag
rq.本体:#concept-request-body
rq.~client:#concept-request-client
rq.予約-済み~client:#concept-request-reserved-client
rq.置換する~client~id:#concept-request-replaces-client-id
rq.~window:#concept-request-window
rq.~keepalive~flag:#request-keepalive-flag
rq.~sw~mode:#request-service-workers-mode
rq.起動元:#concept-request-initiator
rq.行先:#concept-request-destination
rq.優先度:#concept-request-priority
rq.生成元:#concept-request-origin
rq.~referrer:#concept-request-referrer
rq.~referrer施策:#concept-request-referrer-policy
rq.同期~flag:#synchronous-flag
rq.~mode:#concept-request-mode
rq.~CORS予行~利用~flag:#use-cors-preflight-flag
rq.資格証~mode:#concept-request-credentials-mode
rq.資格証利用URL~flag:#concept-request-use-url-credentials-flag
rq.~cache~mode:#concept-request-cache-mode
rq.~redirect~mode:#concept-request-redirect-mode
rq.完全性~metadata:#concept-request-integrity-metadata
rq.暗号用~nonce~metadata:#concept-request-nonce-metadata
rq.構文解析器~metadata:#concept-request-parser-metadata
rq.~reload~navi~flag:#concept-request-reload-navigation-flag
rq.履歴~navi~flag:#concept-request-history-navigation-flag
rq.~tainted生成元~flag:#concept-request-tainted-origin
rq.~URL~list:#concept-request-url-list
rq.現在の~URL:#concept-request-current-url
rq.~redirect数:#concept-request-redirect-count
rq.応答~tainting:#concept-request-response-tainting
rq.~no-cache時に~cache制御~headerを改変しない~flag:#no-cache-prevent-cache-control
rq.~done~flag:#done-flag
rq.計時許容に失敗した~flag:#timing-allow-failed

要請の生成元を直列化する:#serializing-a-request-origin
要請の生成元を~byte直列化する:#byte-serializing-a-request-origin
応答~URLを報告-用に直列化する:#serialize-a-response-url-for-reporting
非同一-生成元~資源~施策~内部~検査:#cross-origin-resource-policy-internal-check
非同一-生成元~埋込元~施策~CORP違反~報告を~queueする:#queue-a-cross-origin-embedder-policy-corp-violation-report

要請を~cloneする:#concept-request-clone
~scriptに類する:#request-destination-script-like
要請~用の本体を伝送する:#concept-request-transmit-body
範囲~headerを追加する:#concept-request-add-range-header

下位資源~要請:#subresource-request
非~下位資源~要請:#non-subresource-request
~navi要請:#navigation-request

	●応答
応答:#concept-response
rs.種別:#concept-response-type
rs.中止~flag:#concept-response-aborted
rs.~URL:#concept-response-url
rs.~URL~list:#concept-response-url-list
rs.状態s:#concept-response-status
rs.状態s~message:#concept-response-status-message
rs.~header~list:#concept-response-header-list
rs.本体:#concept-response-body
rs.~cache状態:#concept-response-cache-state
rs.~CSP~list:#concept-response-csp-list
rs.~CORSに公開される~header名~list:#concept-response-cors-exposed-header-name-list
rs.範囲が要請された~flag:#concept-response-range-requested-flag
rs.計時許容に合格した~flag:#concept-response-timing-allow-passed
rs.~Location~header~URL:#concept-response-location-url

応答を~cloneする:#concept-response-clone

~fetch~group:#concept-fetch-group
~fetch記録:#concept-fetch-record
fg.要請:#concept-fetch-record-request
fg.~fetch:#concept-fetch-record-fetch
fg.終了され:#concept-fetch-group-terminate
fg.終了させる:#concept-fetch-group-terminate
~fetch~groupを終了させる:#concept-fetch-group-terminate

~network~error:#concept-network-error
中止~network~error:#concept-aborted-network-error

絞込み応答:#concept-filtered-response
不透明~redirect絞込み応答:#concept-filtered-response-opaque-redirect
内部~応答:#concept-internal-response
基本~絞込み応答:#concept-filtered-response-basic
~CORS絞込み応答:#concept-filtered-response-cors
不透明な絞込み応答:#concept-filtered-response-opaque
新鮮な応答:#concept-fresh-response
非新鮮な応答:#concept-stale-response
~stale-while-revalidate応答:#concept-stale-while-revalidate-response

	●接続／port／区分
接続~pool:#concept-connection-pool
接続を得する:#concept-connection-obtain
接続:#concept-connection

~network区分~key:#network-partition-key
~network区分~keyを決定する:#determine-the-network-partition-key
~HTTP~cache区分を決定する:#determine-the-http-cache-partition
不良~port:#bad-port
~fetchingは，不良~portに因り阻止されるべきか？:#block-bad-port

	●fetch処理／予行／cache／CORS

~fetch:#concept-fetch
~fetching:#concept-fetch
~main~fetch:#concept-main-fetch
~scheme~fetch:#concept-scheme-fetch
~HTTP~fetch:#concept-http-fetch
~HTTP~redirect~fetch:#concept-http-redirect-fetch
~HTTP~network-or-cache~fetch:#concept-http-network-or-cache-fetch
~HTTP~network~fetch:#concept-http-network-fetch
~CORS予行~fetch:#cors-preflight-fetch-0

終了され:#concept-fetch-terminate
終了させ:#concept-fetch-terminate
終了させる:#concept-fetch-terminate
終了時:#concept-fetch-terminate
	中止~flag:#concept-fetch-terminate
休止-:#concept-fetch-suspend
再開-:#concept-fetch-resume

~fetch~taskを~queueする:#queue-a-fetch-task
~fetch要請~done~taskを~queueする:#queue-a-fetch-request-done-task

要請の本体を処理する:#process-request-body
要請の本体終端を処理する:#process-request-end-of-body
応答を処理する:#process-response
応答の本体終端を処理する:#process-response-end-of-body
応答の~doneを処理する:#process-response-done

内容~符号法sを取扱う:#handle-content-codings

	// cache
~CORS予行~cache:#concept-cache
~cache~entry:#cache-entry
~cache~entryを消去する:#concept-cache-clear
新たな~cache~entryを作成する:#concept-cache-create-entry
~cache合致する:#concept-cache-match
~methodも合致している~cache~entry:#concept-cache-match-method
~header名も合致している~cache~entry:#concept-cache-match-header

cc.~byte直列化した生成元:#concept-cache-origin
cc.~URL:#concept-cache-url
cc.資格証の有無:#concept-cache-credentials
cc.寿命:#concept-cache-max-age
cc.~header名:#concept-cache-header-name
cc.~method:#concept-cache-method

	●CORS／他

~CORS検査:#concept-cors-check
~CORS非同一-生成元:#cors-cross-origin
~CORS~protocol:#cors-protocol
~CORS同一-生成元:#cors-same-origin
~CORS要請:#cors-request
~CORS予行~要請:#cors-preflight-request

~CORBで保護される~MIME型:#corb-protected-mime-type
~CORB検査:#corb-check

非同一-生成元~資源~施策~検査:#cross-origin-resource-policy-check
~TAO検査:#concept-tao-check

整数を直列化する:#serialize-an-integer

行先の素:#concept-potential-destination
行先に翻訳する:#concept-potential-destination-translate

~data_URL処理器:#data-url-processor
~data_URL構造体:#data-url-struct
dU.本体:#data-url-struct-body
dU.~MIME型:#data-url-struct-mime-type

~HTTP~redirectの不可分な取扱い:#atomic-http-redirect-handling
応答は~metadata~listに合致するか？:~SRI1#does-response-match-metadatalist
~nosniffかどうか決定する:#determine-nosniff
~HTTP引用符付き文字列を収集する:#collect-an-http-quoted-string


	●Stream

A.AcquireReadableStreamDefaultReader:~STREAMS#acquire-readable-stream-reader
A.ReadableStreamDefaultControllerClose:~STREAMS#readable-stream-default-controller-close
A.ReadableStreamDefaultControllerEnqueue:~STREAMS#readable-stream-default-controller-enqueue
A.ReadableStreamDefaultControllerGetDesiredSize:~STREAMS#readable-stream-default-controller-get-desired-size
A.IsReadableStreamDisturbed:~STREAMS#is-readable-stream-disturbed
A.IsReadableStreamLocked:~STREAMS#is-readable-stream-locked
A.ReadableStreamDefaultReaderRead:~STREAMS#readable-stream-default-reader-read
A.ReadableStreamCancel:~STREAMS#readable-stream-cancel
A.ReadableStreamTee:~STREAMS#readable-stream-tee
A.ReadableStreamDefaultControllerError:~STREAMS#readable-stream-default-controller-error
A.CreateReadableStream:~STREAMS#create-readable-stream
A.ReadableStreamPipeTo:~STREAMS#readable-stream-pipe-to

c.body.getReader():~STREAMS#rs-get-reader

~dataの~stream:~STREAMS#rs-class
~chunk:~STREAMS#chunk
可書~側:~STREAMS#writable-side
可読~側:~STREAMS#readable-side
~identity形式変換~stream:~STREAMS#identity-transform-stream

読取n要請:~STREAMS#read-request
~chunk手続き:~STREAMS#read-request-chunk-steps
~close手続き:~STREAMS#read-request-close-steps
~error手続き:~STREAMS#read-request-error-steps

RS.~ReadableStream~objを構築する:#concept-construct-readablestream
	可読~streamを構築する:#concept-construct-readablestream
RS.読取器を取得する:#concept-get-reader
RS.~byte列を~enqueueする:#concept-enqueue-readablestream
RS.~closeする:#concept-close-readablestream
RS.~errorにする:#concept-error-readablestream
RS.取消す:#concept-cancel-readablestream
RS.~chunkを読取る:#concept-read-chunk-from-readablestream
RS.すべての~byte列を読取る:#concept-read-all-bytes-from-readablestream
RS.二叉化する:#concept-tee-readablestream
RS.読取n可能:#concept-readablestream-readable
RS.~closeされた:#concept-readablestream-closed
RS.~errorした:#concept-readablestream-errored
RS.妨げられている:#concept-readablestream-disturbed
RS.~lockされている:#concept-readablestream-locked
RS.もっと~dataが必要:#concept-readablestream-need-more-data
	RS.妨げる:#concept-readablestream-disturbed

本体を伝送する~loop:#transmit-body-loop
読取n~loop:#read-loop

	●Fetch API
~fetchを中止する:#abort-fetch
本体と内容~型を抽出する:#concept-bodyinit-extract
本体と内容~型を安全に抽出する:#bodyinit-safely-extract

~guardで検査する:#_check-name-and-value-with-guard
新たな~Headers:#_new-headers
新たな~Response:#_new-response

Hl.~header~list:#concept-headers-header-list
Hl.付加する:#concept-headers-append
Hl.~guard:#concept-headers-guard
Hl.埋める:#concept-headers-fill
特権的~CORSなし要請~headerを除去する:#concept-headers-remove-privileged-no-cors-request-headers

Rq.要請:#concept-request-request
Rq.~Headers:#request-headers
Rq.通達:#request-signal
Rs.応答:#concept-response-response
Rs.~Headers:#response-headers

Bd.妨げられている:#concept-body-disturbed
Bd.~lockされている:#concept-body-locked
Bd.本体:#concept-body-body
Bd.~MIME型:#concept-body-mime-type
本体を消費する:#concept-body-consume-body
~dataを梱包する:#concept-body-package-data

	●INFRA
実装定義:~INFRA#implementation-defined
ときは中止する:~INFRA#abort-when
中止されたときは:~INFRA#if-aborted
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue

~byte列:~INFRA#byte-sequence
長さ:~INFRA#byte-sequence-length
~byte小文字~化する:~INFRA#byte-lowercase
~byte大文字~化する:~INFRA#byte-uppercase
~byte大小無視:~INFRA#byte-case-insensitive
~byte列を~JSONとして構文解析する:~INFRA#parse-json-from-bytes
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
~ASCII空白:~INFRA#ascii-whitespace
~ASCII大小無視:~INFRA#ascii-case-insensitive
符号位置:~INFRA#code-point
位置~変数:~INFRA#string-position-variable
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~forgiving-base64復号する:~INFRA#forgiving-base64-decode
~forgiving-base64符号化する:~INFRA#forgiving-base64-encode
同型に符号化する:~INFRA#isomorphic-encode
同型に復号する:~INFRA#isomorphic-decode
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace

構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
空:~INFRA#list-is-empty
~cloneする:~INFRA#list-clone
map.空:~INFRA#map-is-empty
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
包含して:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
	~EACH:~INFRA#map-iterate
	:~INFRA#map-exists
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
未満の~byte列:~INFRA#byte-less-than

	●外部（HTTP
~field名:~HTTPsem#field-name
~field値:~HTTPsem#field-value
~field行l:~HTTPsem#field-line
~field行l値:~HTTPsem#field-line-value
単数~field:~HTTPsem#singleton-field
条件付き要請:~HTTPrq#preconditions
要請~method:~HTTPrq#methods
~header節:~HTTPsem#header-section
~trailer:~HTTPsem#trailer-field
~payload本体:~HTTPsem#payload.body
内容~符号法:~HTTPsem#content.codings
応答~状態s~code:~HTTPrs#status.codes
部分的~内容:~HTTPrs#status.206
暫定-応答:~HTTPrs#interim-response
最終-応答:~HTTPrs#final-response
安全:~HTTPrq#safe.methods

~target~URI:~HTTPsem#target-URI
~message本体:~HTTPsem#message-body
	~message本体の長さ:~HTTPmsg#message.body.length
現在の齢:~HTTPcache#age.calculations
鮮度~維持期間:~HTTPcache#calculating.freshness.lifetime
	新鮮:~HTTPcache#fresh
	非新鮮:~HTTPcache#stale
	~realm:~HTTPrq#realm
~stale-while-revalidate維持期間:~RFCx/rfc5861#section-3
~ABNF~list拡張:~HTTPsem#abnf.extension

	●外部
~promise型:~WEBIDL#idl-promise
連列~型:~WEBIDL#idl-sequence
~record型:~WEBIDL#idl-record
反復される値~pairたち:~WEBIDL#dfn-value-pairs-to-iterate-over

新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
反応-:~WEBIDLjs#dfn-perform-steps-once-promise-is-settled
充足-時:~WEBIDLjs#upon-fulfillment

有構造~field値:~HEADER-STRUCTURE#structured-field-name-value
有構造~fieldを直列化する:~HEADER-STRUCTURE#text-serialize
有構造~fieldを構文解析する:~HEADER-STRUCTURE#text-parse
	:~HEADER-STRUCTURE#section-2
	:~HEADER-STRUCTURE#section-4.1
	:~HEADER-STRUCTURE#section-4.2

enc.~UTF-8:~ENCODING#utf-8
~UTF-8符号化する:~ENCODING#utf-8-encode
~UTF-8復号する:~ENCODING#utf-8-decode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

~URL:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
url.~domain:~URL1#concept-domain
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment
url.基底~URL不可用~flag:~URL1#url-cannot-be-a-base-url-flag
url.生成元:~URL1#concept-url-origin
url.~path:~URL1#concept-url-path
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~username:~URL1#concept-url-username
url.~password:~URL1#concept-url-password
url.~blob~URL~entry:~URL1#concept-url-blob-entry
url.資格証を含む:~URL1#include-credentials

~form_urlencoded直列化器:~URL1#concept-urlencoded-serializer
~form_urlencoded構文解析器:~URL1#concept-urlencoded-parser
名値~pair~list:~URL1#concept-urlsearchparams-list

~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode

xhr.~entry:~XHR#concept-formdata-entry
	xhr.~entryを作成する:~XHR#create-an-entry

~task:~WAPI#concept-task
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
~network用~task源:~WAPI#networking-task-source
現在の設定群~obj:~WAPI#current-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
環境:~WAPI#environment
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.担当の文書:~WAPI#responsible-document
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~id:~WAPI#concept-environment-id
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.埋込元~施策:~WAPI#concept-settings-object-embedder-policy
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.生成元:~WAPI#concept-settings-object-origin
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
~siteを得する:~ORIGIN#obtain-a-site

~script~fetch~options:~WAPI#script-fetch-options

閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
作動中の文書:~BROWSERS#active-document
入子の閲覧文脈:~BROWSERS#nested-browsing-context

生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
成分組~生成元:~ORIGIN#concept-origin-tuple
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
~site:~ORIGIN#site
~scheme無しで同じ~site:~ORIGIN#schemelessly-same-site
o.~scheme:~ORIGIN#concept-origin-scheme

embP.報告のみの報告先:~ORIGIN#embedder-policy-report-only-reporting-endpoint
embP.報告先:~ORIGIN#embedder-policy-reporting-endpoint
embP.報告のみの値:~ORIGIN#embedder-policy-report-only-value
embP.値:~ORIGIN#embedder-policy-value-2
埋込元~施策~値:~ORIGIN#embedder-policy-value
i.~coep報告~種別:~ORIGIN#coep-report-type

l.require-corp:~ORIGIN#coep-require-corp
l.unsafe-none:~ORIGIN#coep-unsafe-none

並列的:~HTMLINFRA#in-parallel
~mp_form_data境界~文字列:~HTMLforms#multipart/form-data-boundary-string
~mp_form_dataとして符号化する:~HTMLforms#multipart/form-data-encoding-algorithm

読取n演算:~FILEAPI#readOperation
~streamを取得する:~FILEAPI#blob-get-stream

bU.~obj:~FILEAPI#blob-url-entry-object

~CSP指令:~CSP3#csp-directives
~CSP~obj:~CSP3#content-security-policy-object
~CSP~listを設定する:~CSP3#set-response-csp-list

~WebSocket~protocol~handshakeを確立する:#concept-websocket-establish
~WebSocket接続を得する:#concept-websocket-connection-obtain

~WebSocket接続を失敗させる:#fail-the-websocket-connection
~WebSocket接続は確立される:#the-websocket-connection-is-established

~referrer施策:~REFERRER-POLICY#referrer-policy
	#concept-referrer-policy
~referrerを決定-:~REFERRER-POLICY#determine-requests-referrer
~referrer施策を設定する:~REFERRER-POLICY#set-requests-referrer-policy-on-redirect

~navi:~NAVI#navigate
~navigate:~NAVI#navigate
~navigate~algo:~NAVI#navigate
~navigate~fetchを処理する:~NAVI#process-a-navigate-fetch

報告を~queueする:~REPORTING#queue-report

通達に~algoを追加する:~DOM4#abortsignal-add
中止-を通達する:~DOM4#abortsignal-signal-abort
通達に追従させる:~DOM4#abortsignal-follow
aB.中止-済み~flag:~DOM4#abortsignal-aborted-flag

~MIME型:~MIMESNIFF#mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~JSON~MIME型:~MIMESNIFF#json-mime-type
~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type
~MIME型を~byte列に直列化する:~MIMESNIFF#serialize-a-mime-type-to-bytes
~essence:~MIMESNIFF#mime-type-essence
~parameter~map:~MIMESNIFF#parameters
	:~MIMESNIFF#serialize-a-mime-type

_acks1:#_acks1

●●words_table1

SRI1:webappsec-subresource-integrity-ja.html
BEACON:beacon-ja.html
	https://tools.ietf.org/html/draft-ietf-httpbis-header-structure
RFC6455:RFC6455-ja.html
UPGRADE1:webappsec-upgrade-insecure-requests-ja.html
	https://w3c.github.io/webappsec-upgrade-insecure-requests/

ReadableStream: <code>ReadableStream</code> 
mp_form_data:<code>multipart/form-data</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code> 
	Origin:<code class="header">Origin</code>
data_URL:<code class="scheme">data:</code> URL 
stale-while-revalidate:<code class="directive">stale-while-revalidate</code> 


●●words_table

	●構文／直列化
BOM:
wildcard:
percent-::: %-
tab-or-space:tab or space:tab／space
slash::::スラッシュ
forgiving-base64:
文字大小:case::~
	文字大小~法:casing:~
同型に:isomorphic::~
改行:newline::~
部位:part:~
	成功した:successful
剥ぐ:stripする::~
区切子:delimiter:~
分割-:split:~
引用符付き:quoted::~

	頭部:leading／:start
	尾部:trailing／:end
	-:end
	順に連結-:prepend
	10 進数:decimal number

	●data型／操作／構造
number:
null:
multimap:
	( ~key: 値 ):key-value
	value:
成分組:tuple::~
	組:tuple
名値:name-value:: ( 名, 値 ) 
消去-:clear::~::クリア
結合-:combine::~
作成時の:creation::~
昇順:ascending order:~
単数:singleton:::~
	作成-時:creation
	初期~時:initially
	有限:non-infinite
	~GT 0:positive
	負でない:non-negative／
	~IN:contain

	●一般処理／stream/promise／IDL
Headers:
Response:
Request:
pipe::::パイプ
	~pipe法:piping
形式変換:transform::~
close:
open:
chunk::::チャンク
二叉化:tee::~
function:
done:
main:
process::::プロセス
排他的:exclusive:~
妨げら:disturbさ::~
不可分:atomic::~
ok:
早期:early::~
優先度:priority::~
進行中の:ongoing:~

終了-:terminate:~
終了:termination::~
終了時:termination::~
	中止-済み:aborted
中止:aborted::~
休止:suspension::~

読取n:read::読み取り
読取られ:readされ::読み取られ
読取る:readする::読み取る
読取っ:readし::読み取っ
読取器:reader::読み取り器::リーダ
読取れる:readできる::読み取れる
可読:readable::読取れる
	読取n可能:readable::読み取り可能
可書:writable::書込める
identity:

消費:consumption::~
梱包-:package::~
割振る:allocateする::割り振る
	構築-法:constructing
再投出:rethrow::~
例外投出あり:rethrow any exception::~
進展:progression:~
漸進的:progressive:~
不定期:indefinite:~
再帰:recursive:~
計時許容:timing allow::計時の許容
合格-:pass::~

	highWaterMark
	時点が来る:moment arrives
	突き合わせて:against
	end-of-stream:stream 終端
	何もしない:no-op

	●URL
hostname::::ホスト名
username::::ユーザ名
password::::パスワード
blob:
dataURL:data URL

URI:
	location:::ロケーション
	期限

	●ネットワーク／HTTP(S)
WebSocket:
essence:
charset:
http:
HTTP2:HTTP/2
HTTP_S:HTTP(S) 
Location:
keepalive:
network-or-cache::::ネットワーク-or-キャッシュ
下位protocol:subprotocol::下位 protocol:下位プロトコル
	~protocol~list:protocols
ping:
payload::::ペイロード
reload::::リロード
	~download法:downloading
methods::::メソッドたち
trailer::::トレイラ
	参照元
	~cache法:caching
no-cache:
dispatch:
opening:
handshake::::ハンドシェイク
pool::::プール
command::::コマンド
directory::::ディレクトリ
offline::::オフライン
FTP:
	ftp
	file
	LIST
報告先:reporting endpoint::~
端点間:end-to-end::~::エンドツーエンド
内容形式:format::~::フォーマット
	伝送-済み:transmitted

為され:makeされ:~
為さな:makeしな:~
為して:makeして:~
為した:makeした:~
発行i:issue::発行

保管庫:store::~::ストア
本体終端:end-of-body:body 終端:~:ボディ終端
	応答~header:response-header
	出自に:originate from
無効化-:invalidate::~
	無効化-法:invalidation
再検証-:revalidate::~
再検証中:revalidating::~
新鮮化-:fresh::~
	新鮮化-法:freshening
新鮮:fresh::~
非新鮮:stale::~
鮮度:freshness::~
維持期間:lifetime::~
齢:age::~
寿命:max-age:::~

符号法:coding::~::コーディング
符号法s:codings::符号法たち::コーディングたち
昇格-:upgrade::~::アップグレード
重み:weight::~
	通信-法:communicating
確立ng:establishing::確立
条件付き:conditional::~
暫定-:interim::~
最終-:final::~

	条件付きでない:non-conditional
	“最終”:final
	範囲~付き:ranged
	~cache制御:cache-control
	~fetch側:fetcher
	~redirect器:redirector

	●HTTPS／保安／認証／CSP／CORS／MIX
Fetch:
TLS:
	~CORSなし:no-CORS:
CORB:
CORP:
coep:
TAO:
Origin:
tainting:
tainted:
nonce::::ナンス
intranet::::イントラネット
guard::::ガード
nosniff:
	阻止-法:blocking
	阻止される^i:blocked
	許容される^i:allowed
埋込元:embedder::埋め込み元
XSS:cross-site scripting:XSS
資格証利用URL:use-URL-credentials::URL資格証明情報-利用::URLクレデンシャル利用
認証:authentication::~
認証-:authenticate::~
	認証-済み:authenticated
	~proxy認証:proxy-authentication
権限付与:authorization::~
証明書:certificate::~
inflight:::伝送中の
予行:preflight::~::プリフライト
	予行なしの:non-preflighted
	CORS-preflight
random::::ランダム
hash::::ハッシュ
	違反報告
	不透明~redirect:opaque-redirect
暗号用:cryptographic::~
混在:mixed::~
firewall::::ファイアウォール
side-channel:side channel:::サイドチャネル
	別の:side-channel
非安全:unsafe::~
	安全でない:unsafe
安全とさ:safelistさ::~
	安全とされていない:non-safelisted
先天的:a priori:~
秘匿情報:secret:~
騙す:trickする:~
深刻:serious:~
承認-:acknowledge:~
悪用:exploit:~
悪用-:exploit:~
防御:defense:~
特権的:privileged::~
	特権的でない:unprivileged
無毒化-:sanitize::~
	無毒化-:sanitise
私的:private::~
処置:disposition::~

	離れた所に:further from
	疑わしい:dubious
	抗する:against
	報告-用:for reporting

	●仕様
RFC:
内部状態管理:bookkeeping detail:~
不用意:accidental:~
一時的:temporary:~
都合よい:convenientな:~
無害:harmless:~
土台:ground:~
選択余地:options:選択の余地
曖昧:vague:~
有効:effective:~
普通の:ordinary:~
一般論:general:~
遺物:artefact:~
合法:legal:~
	合法でない:illegal
透過的:transparent:~
条項:caveat:~
正常:normal:~
今後の:future:~
	未策定の:future
率直:straightforward:~
網羅的:exhaustive:~
多用途の:versatileな:~
妥協点:compromise:~
素朴:naïve:~
致命的:fatal:~
増補-:augment:~
必要最小限:minimal:~
申請-:file:~
精緻:fine:~
	より精緻:finer
複雑:complicated:~
文言:language:~
一様:uniform:~

	用途:usage
	~~強く:highly
	一貫性を得る:consistent
	省略時は:optional
	optionの:optionally
	明瞭でない:unclear
	細かい点:finer points
	最終的に:eventual
	~~用語:device
	規範的でない:informative
	必要:need／
	すなわち:Namely,
	べき／ベキ:should
	大雑把に言えば:In broad strokes
	~~区分:division
	背景情報:background reading
	比較的:relatively
	低~level:low-level
	高~levelから見れば At a high level,
	まだ:currently
	今の所:for now
	全般に渡り:Throughout
	それなりに／~~相応に:fairly
	世代ごとに:to the next.
	常で:and used to
	様々なものと~~複雑に入り組んでいる:quite involved
	~~暗黙の前提:underlying assumption
	~~起きた:has precedent
	向けの／に向かうに先立ち:on the way
	一箇所に集約:in a single location
	理想だが:ideally
	~~正しい:right
	時点で:Suddenly
	~~本当の:real
	ほぼ間違いなく:highly likely
	見込みが高い:more likely
	かまわない:fine
	ascribe:帰するとみなされ
	足りる:suffices
	今では、:nowadays
	要している:necessitating
	昔から:the old days
	上層:top of
	慎重に事を~~運ぶ:extreme care
	でなくする方へ~~働く:rather
	別法として:alternatively
	およそ役に立たない:rather useless
	功罪:for better or worse
	悪化-:bad／worse
	~~策定:made
	誤記:misspelling
	すなわち:This means
	どうやっても:anyway
	一種に~~落とし込:recast
	あまりに多くの:too many
	-:a.k.a
	[INFRA]:Infra
	ある面で:In a way
	長年にわたり:over the years
	機能する:function
	大多数:major
	~~寛容にされて:rather forgiving
	大部分は:largely
	当面の間は:for the moment
	事:fact
	結果:outcome
	すなわち:means
	他になく:can be 〜 only

	●仕様（動詞
opt-in::::オプトイン
	~opt-in:opt-into
末端利用者:end user:~:::エンドユーザ
給-:supply:~
想定-:suppose:~
統一-:unify:~
発展-:evolve:~
改め:alteration:~
遭遇-:encounter:~
制限付き:limited:~
考案-:invent:~
被った:incurした:~
妨害-:disrupt:~
	妨害する:disruptive
保つ:keepする:~
保って:keepして:~
	し続け:kept
目指す:aimする:~
helper:
誤認-:mistake:~
	ものと誤認して:mistakenly
寄与-:contribute:~
選んで:chooseして:~
選ぶ:chooseする:~
請われ:askされ:~
請う:askする:~
尊重-:respect:~

	利用されない:unused
	含まない／含めない:exclude
	結付きを断つ:disassociateする
	どの〜から利用されるか:relationship
	discourage
	前提に:assume
	もたらす
	〜できreliable
	観測-可能にならないこと:non-observability
	考慮-:consideration
	該当-:pertain
	判別できない:indistinguishable
	壊す:break
	探-:seek
	対処-:deal with
	置き換える:supplants
	書き下ろされ:written down
	助け:help
	~~規定する:stipulates
	みなされる:counts as a
	~~無視して:not paying attention
	念頭に置く:Keep that in mind
	知る:know
	~~整理:sorted through
	~~機能:functional
	~~働き:functioning
	関わらない:not matter
	~~懸案になる:matter
	~~対照的に:as opposed
	必ず:make sure
	促す:prompt
	~~略称され:better known
	呼ばれ:known
	興味を引く:interesting
	調べて:looking at

	●未分類
log::::ログ
	格納-済み:stored
露呈-:reveal::~
捕捉-:capture::~
捕える:catchする::~
浪費-:waste:~
翻訳-:translate:~
維持-:retain:~
担当の:responsibleな::~
共有:sharing:~
絞込み:filtered::絞り込み::フィルタ済み
	はじく:filter out
埋める:fillする:~
id:
forward::最新
memory::::メモリ
internet::::インターネット
再生-:play:~
	再生し直す:replay
区分:partition:~

	改変されてない:unmodified
	予約-済み:reserved
	表す:denote
	外で残存:outlive
	-:mark
	:consist
	渡す:feed
	~INCBY:increase
	やめた:stop
	運ぶ:carry する
	追-:follow
	重ね方:layering
	欠く:lack／:without
	染め:taint
	在る:there are any
	無い:does not contain
	指す:pointer
	残り続ける:stay alive
	やり直す:go through〜again
	出くわした:met
	束ねる:bind
	結果は〜になる:ends up
	渡-／過ぎた:pass
	消え去った:goes away
	重複し得る:potentially duplicate
	前後~pageへの:a.k.a. back-foward navigation
	〜:range
	~~構成-:structure
	-:document
	〜別に分けられる:keyed on
	秒数:seconds／number of seconds
	-:subset
	~call元:caller
	非同一-生成元~埋込元~施策:Cross-Origin Embedder Policy
	~secureでない:non-secure

	●変数
	%~CORSなし要請:noCorsResponse
	%~CORBで無毒化した要請:corbSanitizedResponse
	%内部~応答:internalResponse
	%範囲~値:rangeValue
	%~header名:headerName
	%~http要請:httpRequest
	%~http~cache:httpCache
	%再検証-要請:revalidateRequest
	%再検証中~flag:revalidatingFlag
	%格納-済み応答:storedResponse
	%init:init
	%非安全な名前たち:unsafeNames
	%非安全になり得る名前たち:potentiallyUnsafeNames
	%安全な値の合計~size:safelistValueSize
	%最初の~token:firstToken
	%初期~値:initialValue
	%~MIME型:mimeType
	%開始-位置:positionStart
	%一時的~MIME型:temporaryMimeType
	-:quoteOrBackslash
	%値~list:values
	%直列化した生成元:serializedOrigin
	%有構造~値:structuredValue
	%直列化した値:serializedValue
	%直列化した~URL:serializedURL
	%ws:ws
	%rs:rs
	%報告先:endpoint
	%設定群~obj:settingsObject
	%~navi用:forNavigation
	%埋込元~施策:embedderPolicy
	%報告のみ:reportOnly
	%実際の応答:actualResponse
	%埋込元~施策~値:embedderPolicyValue
	%~top-level生成元:topLevelOrigin
	%~top-level~site:topLevelSite
	%事由:reason
	%読取器:reader
	%読取n要請:readRequest
	%~byte列:bs
	%~error:e
	%~network区分~key:networkPartitionKey
	%第二~key:secondKey
	%処置:disposition
	-:ignoreType

	●指示語

	あらゆるもの:everything
	~~特有なもの:particulars
	以前の:previous
	以前に:previously
	後に:subsequently
	過去の:earlier
	一部／一環:part of
	ある:certain／particular
	〜時には:upon
	むしろ:rather
	まったく:perfectly
	今度:now
	広く:widely
	と同じく:as well as
	上限がある:bound
	~NULL でないこと:nullity
	時機:timing
	残りわずかしかない:there’s only a few bytes of
	すべての`符号位置~並びを収集する$:the remainder of
	先頭:first／
	末尾:last
	先頭, 末尾も含む:inclusive
	~~最後に:finally
	もっぱら:solely
	以外の:excluding
	一体としての:whole
	他のもの:others
	側:-side
	種々の／各種／様々:various
	最短の:shortest possible
	何らかの:any of
	一部分:part of
	何かに〜ない:anything
	の中／過ぎていない:within
	直前の:previous

●●ref_key_map
ORIGIN:RFC6454
WSP:RFC6455
HTTP:RFC7230
HTTPSEMANTICS:RFC7231
HTTPCOND:RFC7232
HTTPRANGE:RFC7233
HTTPCACHING:RFC7234
HTTPAUTH:RFC7235

●●
[WSP-Compression]
    https://tools.ietf.org/id/draft-ietf-hybi-thewebsocketprotocol-09.txt 

●●ref_normative

[ABNF]
    D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[COOKIES]
    A. Barth. HTTP State Management Mechanism. April 2011. Proposed Standard. URL: https://httpwg.org/specs/rfc6265.html 
[CSP]
    Mike West. Content Security Policy Level 3. URL: https://w3c.github.io/webappsec-csp/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FILEAPI]
    Marijn Kruisselbrink; Arun Ranganathan. File API. URL: https://w3c.github.io/FileAPI/ 
[HEADER-STRUCTURE]
    Mark Nottingham; Poul-Henning Kamp. Structured Field Values for HTTP. URL: https://tools.ietf.org/html/draft-ietf-httpbis-header-structure 
[HSTS]
    J. Hodges; C. Jackson; A. Barth. HTTP Strict Transport Security (HSTS). November 2012. Proposed Standard. URL: https://tools.ietf.org/html/rfc6797 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html 
[HTTP-AUTH]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Authentication. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7235.html 
[HTTP-CACHING]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Caching. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7234.html 
[HTTP-COND]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7232.html 
[HTTP-SEMANTICS]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7231.html 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[MIX]
    Mike West. Mixed Content. URL: https://w3c.github.io/webappsec-mixed-content/ 
[REFERRER]
    Jochen Eisinger; Emily Stark. Referrer Policy. URL: https://w3c.github.io/webappsec-referrer-policy/ 
[REPORTING]
    Douglas Creager; et al. Reporting API. URL: https://w3c.github.io/reporting/ 
[RFC7405]
    P. Kyzivat. Case-Sensitive String Support in ABNF. December 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7405 
[RFC7578]
    L. Masinter. Returning Values from Forms: multipart/form-data. July 2015. Proposed Standard. URL: https://tools.ietf.org/html/rfc7578 
[RFC959]
    J. Postel; J. Reynolds. File Transfer Protocol. October 1985. Internet Standard. URL: https://tools.ietf.org/html/rfc959 
[SRI]
    Devdatta Akhawe; et al. Subresource Integrity. URL: https://w3c.github.io/webappsec-subresource-integrity/ 
[STALE-WHILE-REVALIDATE]
    M. Nottingham. HTTP Cache-Control Extensions for Stale Content. May 2010. Informational. URL: https://httpwg.org/specs/rfc5861.html 
[STREAMS]
    Adam Rice; Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[SW]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 
[TLS]
    E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.3. August 2018. Proposed Standard. URL: https://tools.ietf.org/html/rfc8446 
[UPGRADE]
    Mike West. Upgrade Insecure Requests. URL: https://w3c.github.io/webappsec-upgrade-insecure-requests/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/ 
[WSP]
    I. Fette; A. Melnikov. The WebSocket Protocol. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6455 
[XHR]
    Anne van Kesteren. XMLHttpRequest Standard. Living Standard. URL: https://xhr.spec.whatwg.org/ 

●●ref_informative

[EXPECT-CT]
    Emily Stark. Expect-CT Extension for HTTP. URL: https://tools.ietf.org/html/draft-ietf-httpbis-expect-ct-02 
[HTTP-RANGE]
    R. Fielding, Ed.; Y. Lafon, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Range Requests. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7233.html 
[HTTPVERBSEC1]
    Multiple vendors' web servers enable HTTP TRACE method by default.. URL: https://www.kb.cert.org/vuls/id/867593 
[HTTPVERBSEC2]
    Microsoft Internet Information Server (IIS) vulnerable to cross-site scripting via HTTP TRACK method.. URL: https://www.kb.cert.org/vuls/id/288308 
[HTTPVERBSEC3]
    HTTP proxy default configurations allow arbitrary TCP connections.. URL: https://www.kb.cert.org/vuls/id/150227 
[OCSP]
    S. Santesson; et al. X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP. June 2013. Proposed Standard. URL: https://tools.ietf.org/html/rfc6960 
[ORIGIN]
    A. Barth. The Web Origin Concept. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
[RFC2397]
    L. Masinter. The "data" URL scheme. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397 


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">Fetch Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/fetch">GitHub whatwg/fetch</a> (<a href="https://github.com/whatwg/fetch/issues/new">new issue</a>, <a href="https://github.com/whatwg/fetch/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/fetch/commits
	<a href="https://fetch.spec.whatwg.org/commit-snapshots/1ab5615277f9cef60d4e963c10fd2925b6533b81/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/fetchstandard">@fetchstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/fetch">web-platform-tests fetch/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/fetch">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtMzQsNTVhNjAsNjAsMCwwLDAsMjAsLTIwYTYsMTAsMCwwLDEsMTMsLTFhMTAsNiwwLDAsMSwtMSwxM2E2MCw2MCwwLDAsMCwtMjAsMjBhNiwxMCwwLDAsMSwtMTMsMWExMCw2LDAsMCwxLDEsLTEzIiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo="
></a>
	<hgroup>
<h1>Fetch</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
Fetch 標準は、要請（ `request^en ）, 応答（ `response^en ）, および
この 2 つを束ねる処理-
— ~fetching（ `fetching^en ） —
を定義する。
◎
The Fetch standard defines requests, responses, and the process that binds them: fetching.
</p>

<p class="trans-note">【
“`fetch^en”
— 一般英語の語義としては（どこか離れた所から） “取って来る”。
~network上の資源への~~取得~accessには、伝統的にこの語が利用されているようだ（とは言え、この仕様の文脈においては，~HTTP `GET$hm に限られるわけではない）。
単なる “~~取得” では語義が広過ぎるので（
“`get^en”, “`obtain^en”, “`retrieve^en”,
等々），訳語としては “資源~~取得” , “~~取得をかける” などが考えられるが、この訳では原語のまま記す。
】</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
目標は、~web~platform全体にわたる~fetchingを統一して、それが孕む あらゆるものに，一貫した取扱いを供することである
— 次に挙げるものも含め：
◎
The goal is to unify fetching across the web platform and provide consistent handling of everything that involves, including:
</p>

<div>
<ul>
	<li>
各種~URL~scheme
</li>
	<li>
~redirect
</li>
	<li>
非同一-生成元（ `cross-origin^en, “生成元~間をまたがる” ）の意味論
【`同一-生成元$（ `same-origin^en ）の否定でもある。】
</li>
	<li>CSP `CSP$r
【 “`Content Security Policy^en” （ “内容保安施策” ）の略語。この訳では、一貫してこの略語を利用する。】
</li>
	<li>
~sw `SW$r
</li>
	<li>
混在~内容（ `Mixed Content^en ） `MIX$r
</li>
	<li>
`Referer$h ~header `REFERRER$r
</li>
</ul>

◎
• URL schemes
• Redirects
• Cross-origin semantics
• CSP [CSP]
• Service workers [SW]
• Mixed Content [MIX]
• `Referer` [REFERRER]
</div>

<p>
そうするため、元々は `Web Origin Concept^cite `ORIGIN$r にて定義された~HTTP `Origin$h ~headerの意味論にも取って代わる。
◎
To do so it also supersedes the HTTP `Origin` header semantics originally defined in The Web Origin Concept. [ORIGIN]
</p>

	</section>
	<section id="preface">
<h2 title="Preface">1. 序</h2>

<p>
資源の~fetchingは、高~levelから見れば，要請を送ったら応答が返ってくる，それなりに単純な演算である。
しかしながら，その演算の詳細は、様々なものと~~複雑に入り組んでいるため 注意深く書き下ろされていなかったのが常であり，~APIの~~世代ごとに異なっている。
◎
At a high level, fetching a resource is a fairly simple operation. A request goes in, a response comes out. The details of that operation are however quite involved and used to not be written down carefully and differ from one API to the next.
</p>

<p>
数多くの~APIが資源を~fetchする能を供する
— 例えば
⇒＃
~HTMLの `img$e, `script$e 要素 ／
~CSSの `cursor^css, `list-style-image^css ／
~JS~APIの `navigator.sendBeacon()$m, `self.importScripts()$m
◎
Numerous APIs provide the ability to fetch a resource, e.g. HTML’s img and script element, CSS' cursor and list-style-image, the navigator.sendBeacon() and self.importScripts() JavaScript APIs.＼
</p>

<p>
~Fetch標準は、これらの特能~用に，統一された~architectureを供する
— それらすべてが、~redirectや CORS ~protocolなど，~fetchingの様々な側面に関して一貫するように。
◎
The Fetch Standard provides a unified architecture for these features so they are all consistent when it comes to various aspects of fetching, such as redirects and the CORS protocol.
</p>

<p>
~Fetch標準は、 `fetch()$m ~JS~APIも定義する。
それは、~networkingの機能性のほとんどを，~~相応に低~levelな抽象-化の下で公開する。
◎
The Fetch Standard also defines the fetch() JavaScript API, which exposes most of the networking functionality at a fairly low level of abstraction.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ε, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
この仕様の外で定義されている，ほとんどの［
~HTTP~header名 ／
~HTTP~method名 ／
~HTTP応答~状態s~code ／
`~CSP指令$
］には、それを定義する仕様（和訳）への~linkを追加している（これらの~linkは、原文~仕様にはあてがわれていない）。
</p>

	</section>
	<section id="terminology">
<h2 title="Infrastructure">2. 基盤</h2>

<p>
この仕様は Infra Standard に依存する。
`INFRA$r
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、次に挙げる標準による各種用語を利用する
⇒
`ABNF$r
`ENCODING$r
`HTML$r
`HTTP$r
`WEBIDL$r
`MIMESNIFF$r
`STREAMS$r
`URL$r
◎
This specification uses terminology from the ABNF, Encoding, HTML, HTTP, IDL, MIME Sniffing, Streams, and URL Standards. [ABNF] [ENCODING] [HTML] [HTTP] [WEBIDL] [MIMESNIFF] [STREAMS] [URL]
</p>

<p>
`~ABNF@
は、~HTTP, および `RFC7405$r により増補された~ABNFを意味する（特に，~HTTPによる # の追加
【`~ABNF~list拡張$】
）。
◎
ABNF means ABNF as augmented by HTTP (in particular the addition #) and RFC 7405. [RFC7405]
</p>

<hr>

<p>
`資格証@
は、［
~HTTP~cookie ／ ~TLS~client証明書 ／ （~HTTP認証~用の）`認証~entry$
］の総称である。
`COOKIES$r `TLS$r `HTTP-AUTH$r
◎
Credentials are HTTP cookies, TLS client certificates, and authentication entries (for HTTP authentication). [COOKIES] [TLS] [HTTP-AUTH]
</p>

<hr>

<p>
この標準により`~queueされ$る`~task$は、次のいずれかとして，~~記される：
【！ annotated 】
◎
Tasks that are queued by this standard are annotated as one of:
</p>

<ul>
	<li>
`要請の本体を処理する@
◎
process request body
</li>
	<li>
`要請の本体終端を処理する@
◎
process request end-of-body
</li>
	<li>
`応答を処理する@
◎
process response
</li>
	<li>
`応答の本体終端を処理する@
◎
process response end-of-body
</li>
	<li>
`応答の~doneを処理する@
◎
process response done
</li>
</ul>

<p class="trans-note">【
これらの~task（ “〜を処理する” ）は、この仕様に定義される~fetchingを利用する他の仕様（例えば `XHR$r ）が，個々の必要に応じて それぞれに定義するものになる（一種の callback ）。
】</p>

<div class="algo">
<p>
`要請$ %要請 上で［
所与の %演算 を走らす
］ための
`~fetch~taskを~queueする@
ときは、次を走らす：
◎
To queue a fetch task on request request to run an operation, run these steps:
</p>
<ol>
	<li>
~IF［
%要請 の`~client$rq ~EQ ~NULL
］
⇒
~RET
◎
If request’s client is null, terminate these steps.
</li>
	<li>
`~taskを~queueする$( `~network用~task源$，%演算, %要請 の`~client$rqの`担当の~event~loop$enV )
◎
Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch要請~done~taskを~queueする@
ときは、所与の
( %要請 )
に対し
⇒
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`要請の本体終端を処理する$( %要請 )
◎
To queue a fetch-request-done task, given a request, queue a fetch task on request to process request end-of-body for request.
</p>
</div>

<div class="algo">
<p>
`整数を直列化する@
ときは、所与の整数を最短の 10 進数で表現する文字列を返す。
◎
To serialize an integer, represent it as a string of the shortest possible decimal number.
</p>

<p class="XXX">
これは、 `INFRA$r にて もっと記述的な~algoに置換されることになる。
<a href="https://github.com/whatwg/infra/issues/201">infra/201</a>
を見よ。
◎
This will be replaced by a more descriptive algorithm in Infra. See infra/201.
</p>
</div>

		<section id="url">
<h3 title="URL">2.1. ~URL</h3>

<p>
次に挙げる`~scheme$urlが
`局所~scheme@
である
⇒＃
`about^l,
`blob^l,
`data^l
◎
A local scheme is a scheme that is "about", "blob", or "data".
</p>

<p>
`~URL$が
`局所的@
であるとは、その`~scheme$urlが`局所~scheme$であることを意味する。
◎
A URL is local if its scheme is a local scheme.
</p>

<p class="note">注記：
この定義は
`Referrer Policy^cite `REFERRER$r
からも利用される。
◎
This definition is also used by Referrer Policy. [REFERRER]
</p>

<p>
次に挙げる`~scheme$urlが
`~HTTP_S~scheme@
である
⇒＃
`http^l,
`https^l
◎
An HTTP(S) scheme is a scheme that is "http" or "https".
</p>

<p>
次に挙げる`~scheme$urlが
`~network~scheme@
である
⇒＃
`ftp^l,
`~HTTP_S~scheme$
◎
A network scheme is a scheme that is "ftp" or an HTTP(S) scheme.
</p>

<p>
次に挙げる`~scheme$urlが
`~fetch~scheme@
である
⇒＃
`about^l,
`blob^l,
`data^l,
`file^l,
`~network~scheme$
◎
A fetch scheme is a scheme that is "about", "blob", "data", "file", or a network scheme.
</p>

<p class="note">注記：
`~network~scheme$, `~HTTP_S~scheme$, `~fetch~scheme$
は~HTMLからも利用される。
`HTML$r
◎
HTTP(S) scheme, network scheme, and fetch scheme are also used by HTML. [HTML]
</p>

<hr>

<p>
`応答~URL@
は、`~URL$のうち，［
実装は`素片$urlを格納する必要はない
］ものである
— それは、~APIには決して公開されないので。
そのような`~URLを直列化する$ときには、 %素片は除外する~flag は `素片は除外する^i にされる†
— すなわち実装は、それにかまわず，`素片$urlを格納できる。
【† この仕様が定義する~APIにおいては、 `response.url$m 属性。】
◎
A response URL is a URL for which implementations need not store the fragment as it is never exposed. When serialized, the exclude fragment flag is set, meaning implementations can store the fragment nonetheless.
</p>

		</section>
		<section id="http">
<h3 title="HTTP">2.2. ~HTTP</h3>

<p>
`~fetching$は，単なる~HTTPを超えるものを包摂するが、~HTTPからいくつかの概念を流用し，それらを他の手段（例えば `data^c ~URL）を通して得された資源に対してもあてはめる。
◎
While fetching encompasses more than just HTTP, it borrows a number of concepts from HTTP and applies these to resources obtained via other means (e.g., data URLs).
</p>

<p>
`~HTTP~tab-or-space@
は［
`0009^U `TAB^smb ／ `0020^U `SPACE^smb
］である。
◎
An HTTP tab or space is U+0009 TAB or U+0020 SPACE.
</p>

<p>
`~HTTP空白@
は［
`000A^U `LF^smb ／ `000D^U `CR^smb ／ `~HTTP~tab-or-space$
］である。
◎
HTTP whitespace is U+000A LF, U+000D CR, or an HTTP tab or space.
</p>

<p class="note">注記：
`~HTTP空白$が有用になるのは、~HTTP~headerの文脈の外側で再利用される特定の構成子（例：`~MIME型$）に限られる。
~HTTP~header値~用には，`~HTTP~tab-or-space$の利用が選好され、その文脈の外側では，`~ASCII空白$が選好される。
`~ASCII空白$と違って、これは `000C^U `FF^smb を含まない。
◎
HTTP whitespace is only useful for specific constructs that are reused outside the context of HTTP headers (e.g., MIME types). For HTTP header values, using HTTP tab or space is preferred, and outside that context ASCII whitespace is preferred. Unlike ASCII whitespace this excludes U+000C FF.
</p>

<p>
`~HTTP改行~byte@
は、［
`0A^X `LF^smb ／ `0D^X `CR^smb 
］である。
◎
An HTTP newline byte is 0x0A (LF) or 0x0D (CR).
</p>

<p>
`~HTTP~tab-or-space~byte@
は、［
`09^X `HT^smb ／ `20^X `SP^smb
］である。
◎
An HTTP tab or space byte is 0x09 (HT) or 0x20 (SP).
</p>

<p>
`~HTTP空白~byte@
は、［
`~HTTP改行~byte$ ／ `~HTTP~tab-or-space~byte$
］である。
◎
An HTTP whitespace byte is an HTTP newline byte or HTTP tab or space byte.
</p>

<div class="algo">
<p>
`~HTTP引用符付き文字列を収集する@
ときは、所与の
( `文字列$ %入力, `位置~変数$ %位置, %値を抽出する~flag ~IN { `値を抽出する^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To collect an HTTP quoted string from a string input, given a position variable position and optionally an extract-value flag, run these steps:
</p>
<ol>
	<li>
%開始-位置 ~LET %位置
◎
Let positionStart be position.
</li>
	<li>
%値 ~LET 空~文字列
◎
Let value be the empty string.
</li>
	<li>
~Assert：
%位置↗ ~EQ `0022^U `"^smb
◎
Assert: the code point at position within input is U+0022 (").
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%値 に次の結果を付加する
⇒
%入力 内の %位置 から { `0022^U `"^smb, `005C^U `\^smb } 以外の`符号位置~並びを収集する$
◎
Append the result of collecting a sequence of code points that are not U+0022 (") or U+005C (\) from input, given position, to value.
</li>
			<li>
~Assert：
%位置↗ ~IN { ε, `0022^U `"^smb, `005C^U `\^smb }
◎
If position is past the end of input, then break.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `005C^U `\^smb
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%位置↗ ~NEQ ε
］
⇒＃
%値 に %位置↗ を付加する；
%位置 ~INCBY 1；
~CONTINUE
</li>
					<li>
%値 に `005C^U `\^smb を付加する
</li>
				</ol>

◎
Let quoteOrBackslash be the code point at position within input.
◎
Advance position by 1.
◎
If quoteOrBackslash is U+005C (\), then:
• If position is past the end of input, then append U+005C (\) to value and break.
• Append the code point at position within input to value.
• Advance position by 1.
</li>
			<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
%位置 ~INCBY 1
◎
↑↓</li>
			<li>
~BREAK
◎
Otherwise:
• Assert: quoteOrBackslash is U+0022 (").
• Break.
</li>
		</ol>
	</li>
	<li>
~IF［
%値を抽出する~flag ~NEQ ε
］
⇒
~RET %値
◎
If the extract-value flag is set, then return value.
</li>
	<li>
~RET %入力 内の［
%開始-位置 から ( %位置 ~MINUS 1 ) まで
］にある`符号位置$並び
【！inclusive は先頭のみ（例：この時点で %位置↗ は ε かもしれない）】
◎
Return the code points from positionStart to position, inclusive, within input.
</li>
</ol>

<div class="example">
<table><thead><tr><th>入力
<th>出力
<th>出力（ `値を抽出する^i ）
<th>最終- %位置 値†
</thead><tbody>
<tr><td>`<mark>"\</mark>^l
<td>`"\^l
<td>`\^l
<td>2

<tr><td>`<mark>"Hello"</mark> World^l
<td>`"Hello"^l
<td>`Hello^l
<td>7

<tr><td>`<mark>"Hello \\ World\""</mark>^l
<td>`"Hello \\ World\""^l
<td>`Hello \ World"^l
<td>18
</tbody></table>

<p><small>†
この例では、`位置~変数$ %位置 は，常に 0 から開始するとする。
</small></p>

◎
Input 	Output 	Output with the extract-value flag set 	Final position variable value
""\" 	""\" 	"\" 	2
""Hello" World" 	""Hello"" 	"Hello" 	7
""Hello \\ World\""" 	""Hello \\ World\""" 	"Hello \ World"" 	18
◎
The position variable always starts at 0 in these examples.
</div>
</div>

			<section id="methods">
<h4 title="Methods">2.2.1. ~method</h4>

<p>
`~method@
は、 `method$p ~token生成規則に合致する~byte列である。
【~HTTPにおける`要請~method$に対応する。】
◎
A method is a byte sequence that matches the method token production.
</p>

<p>
`~CORS安全とされる~method@
は、次のいずれかの`~method$である
⇒＃
`GET$hm,
`HEAD$hm,
`POST$hm
◎
A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
</p>

<p>
`禁止~method@
は、次のいずれかに`~byte大小無視$で合致する`~method$である
`HTTPVERBSEC1$r
`HTTPVERBSEC2$r
`HTTPVERBSEC3$r
⇒＃
`CONNECT$hm,
`TRACE$hm,
`TRACK$hm
◎
A forbidden method is a method that is a byte-case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`. [HTTPVERBSEC1], [HTTPVERBSEC2], [HTTPVERBSEC3]
</p>

<div class="algo">
<p>
`~methodを正規化する@
ときは、所与の
( `~method$ %M )
に対し，［
%M が次のいずれかに`~byte大小無視$で合致するならば `~byte大文字~化する$( %M ) ／
~ELSE_ %M
］を返す
⇒＃
`DELETE$hm,
`GET$hm,
`HEAD$hm,
`OPTIONS$hm,
`POST$hm,
`PUT$hm
◎
To normalize a method, if it is a byte-case-insensitive match for `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST`, or `PUT`, byte-uppercase it.
</p>

<p class="note">注記：
`~method$は実際には “文字大小区別” であるが、［
後方-互換性, 各種~API間の一貫性
］を得るため，`正規化-$mdが行われる。
◎
Normalization is done for backwards compatibility and consistency across APIs as methods are actually "case-sensitive".
</p>
</div>

<p class="example" id="example-normalization">
`patch^hm を利用した結果は、ほぼ間違いなく
`405 Method Not Allowed^bl になるであろう。
`PATCH^hm の方がずっと成功する見込みが高い。
◎
Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.
</p>

<p class="note">注記：
`~method$に制約はない。
`CHICKEN^hm （ `CHECKIN^hm の誤記ではない）でも，まったく受容-可能である。
`正規化-$mdされるものを除き、文字大小~法についての制約もない。
一貫性を得るため，大文字が奨励されるが、 `Egg^hm や `eGg^hm でもかまわない。
◎
There are no restrictions on methods. `CHICKEN` is perfectly acceptable (and not a misspelling of `CHECKIN`). Other than those that are normalized there are no casing restrictions either. `Egg` or `eGg` would be fine, though uppercase is encouraged for consistency.
</p>

			</section>
			<section id="terminology-headers">
<h4 title="Headers">2.2.2. ~header</h4>

<p>
`~header~list@
は、 0 個以上の`~header$からなる`~list$であり、初期~時は空~listとする。
◎
A header list is a list of zero or more headers. It is initially the empty list.
</p>

<p class="trans-note">【
~HTTPにおける~messageの`~header節$に対応する（現時点では、この仕様には，`~trailer$は現れない）。
】</p>

<p class="note">注記：
`~header~list$は、本質的には特化された ~multimapである
— すなわち，何個かの ( ~key: 値 ) ~pairからなる有順序~listであって，~keyが重複し得るものである。
◎
A header list is essentially a specialized multimap: an ordered list of key-value pairs with potentially duplicate keys.
</p>

<div class="algo">
<p>
`~header~list$ %~list から
`有構造~field値を取得する@
ときは、所与の
( %名前, %型 )
に対し，次の手続きを走らす：
◎
To get a structured field value given a name and a type from a header list list, run these steps:
</p>
<ol>
	<li>
~Assert：
%型 ~IN { `辞書^i, `~list^i, `~item^i }
【！"dictionary", "list", or "item"】
◎
Assert: type is one of "dictionary", "list", or "item".
</li>
	<li>
%値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let value be the result of getting name from list.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If value is null, then return null.
</li>
	<li>
%結果 ~LET `有構造~fieldを構文解析する$( %値, %型 )
◎
Let result be the result of parsing structured fields with input_string set to value and header_type set to type.
</li>
	<li>
~IF［
前~段の構文解析に失敗した
］
⇒
~RET ~NULL
◎
If parsing failed, then return null.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="note">注記：
`有構造~field値を取得する$は、［
`~header$が無いこと,
その`値$hdを`有構造~field値$として構文解析するのに失敗したこと
］を意図的に判別しない。
これは、~web~platformにわたる一様な処理を確保する。
◎
Get a structured field value intentionally does not distinguish between a header not being present and its value failing to parse as a structured field value. This ensures uniform processing across the web platform.
</p>
</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`有構造~field値を設定する@
ときは、所与の~pair
( `名前$hd %名前 / `有構造~field値$ %有構造~値 )
に対し，次を走らす：
◎
To set a structured field value name/structured field value name/structuredValue pair in a header list list, run these steps:
</p>
<ol>
	<li>
%直列化した値 ~LET `有構造~fieldを直列化する$( %有構造~値 )
◎
Let serializedValue be the result of executing the serializing structured fields algorithm on structuredValue.
</li>
	<li>
%~list 内で`~headerを設定する$( %名前 / %直列化した値 )
◎
Set name/serializedValue in list.
</li>
</ol>

<p class="note">注記：
`有構造~field値$は、興味を引く効率的な仕方で［
~HTTPが（最終的に）直列化できる~obj
］として定義される。
~fetchは，当面の間は、`~header$の`値$hdを`~byte列$に限り~supportする。
すなわち、これらの~objを`~header~list$内に設定するためには，直列化を介する他になく、`~header~list$から得するためには，構文解析する他にない。
将来には、それらが~objである事は，端点間で保全されるであろう。
`HEADER-STRUCTURE$r
◎
Structured field values are defined as objects which HTTP can (eventually) serialize in interesting and efficient ways. For the moment, Fetch only supports header values as byte sequences, which means that these objects can be set in header lists only via serialization, and they can be obtained from header lists only by parsing. In the future the fact that they are objects might be preserved end-to-end. [HEADER-STRUCTURE]
</p>

</div>

<hr>

<div class="p">

<p>
所与の`名前$hd（または`~byte列$） %名前 を
`名前に持つ~header@
とは、`~header$であって，その`名前$hdが［
`~byte大小無視$で %名前 に合致する
］ものを指す。
</p>

<p class="trans-note">【
言い換えれば、`~header$の`名前$hdは，常に`~byte大小無視$で比較される
— 元々の~HTTP~protocolが，~header名の文字大小を区別しないので。
】【
この用語は、他所を簡便に記すために，この訳にて導入している。
】</p>

<p>
［
そのような`~header$を所与の`~list$ %~list が`包含して$いる
］という条件は、単に，
“%~list 内に %名前 を`名前に持つ~header$は在る”
と記される（その否定は “無い” と記される）。
</p>

<p class="trans-note">【
この条件は、原文では
“`~header~list$は %名前 を
`包含する@hd”
という句として定義されているが、この訳（および，この仕様を参照している和訳）では，この用語 “包含する” は利用せず，もっぱら`名前に持つ~header$を用いて等価に記すことにする。
】</p>

◎
A header list list contains a name name if list contains a header whose name is a byte-case-insensitive match for name.
</div>

<div class="algo">
<p>
`~header~listから値を取得する@
ときは，所与の
( `~header~list$ %~list, `名前$hd %名前 )
に対し，次を走らす：
◎
To get a name name from a header list list, run these steps:
</p>
<ol>
	<li>
~IF［
%~list 内に %名前 を`名前に持つ~header$は無い
］
⇒
~RET ~NULL
◎
If list does not contain name, then return null.
</li>
	<li>
~RET %~list 内の［
%名前 を`名前に持つ~header$
］すべての`値$hdを互いに［
`2C^X `20^X
］並びで区切って順に連結した結果
◎
Return the values of all headers in list whose name is a byte-case-insensitive match for name, separated from each other by 0x2C 0x20, in order.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listから値を取得して復号して分割する@
ときは、所与の
( `~header~list$ %~list, `名前$hd %名前 )
に対し，次を走らす：
◎
To get, decode, and split a name name from header list list, run these steps:
</p>
<ol>
	<li>
%初期~値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let initialValue be the result of getting name from list.
</li>
	<li>
~IF［
%初期~値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If initialValue is null, then return null.
</li>
	<li>
%入力 ~LET `同型に復号する$( %初期~値 )
◎
Let input be the result of isomorphic decoding initialValue.
</li>
	<li>
%位置 ~LET %入力 内の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%値~list ~LET 空`~list$
◎
Let values be a list of strings, initially empty.
</li>
	<li>
%値 ~LET 空~文字列
◎
Let value be the empty string.
</li>
	<li>
<p>
~WHILE ［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
<p>
%値 に次の結果を付加する
⇒
%入力 内の %位置 から { `0022^U `"^smb, `002C^U `,^smb } 以外の`符号位置~並びを収集する$
◎
Append the result of collecting a sequence of code points that are not U+0022 (") or U+002C (,) from input, given position, to value.
</p>

<p class="note">注記：
結果は空~文字列にもなり得る。
◎
The result might be the empty string.
</p>
			</li>
			<li>
<p>
~IF［
%位置↗ ~NEQ ε
］：
◎
If position is not past the end of input, then:
</p>
				<ol>
					<li>
<p>
~IF［
%位置↗ ~EQ `0022^U `"^smb
］：
◎
If the code point at position within input is U+0022 ("), then:
</p>
						<ol>
							<li>
%値 に次の結果を付加する
⇒
`~HTTP引用符付き文字列を収集する$( %入力, %位置 )
◎
Append the result of collecting an HTTP quoted string from input, given position, to value.
</li>
							<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~CONTINUE
◎
If position is not past the end of input, then continue. 
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~Assert：
%位置↗ ~EQ `002C^U `,^smb
◎
Assert: the code point at position within input is U+002C (,).
</li>
							<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%値 から［
頭部, 尾部
］を成すすべての`~HTTP~tab-or-space$を除去する
◎
Remove all HTTP tab or space from the start and end of value.
</li>
			<li>
%値~list に %値 を`付加する$
◎
Append value to values.
</li>
			<li>
%値 ~SET 空~文字列
◎
Set value to the empty string.
</li>
		</ol>
	</li>
	<li>
~RET %値~list
◎
Return values.
</li>
</ol>
</div>

<div class="example">

<p>
`~header~listから値を取得して復号して分割する$が、その引数 %名前 に `A^bl が与えられた下で，実施において どう機能するかを次に示す：
◎
This is how get, decode, and split functions in practice with `A` as the name argument:
</p>

<table><thead><tr><th>（~network上の）~header列
◎
Headers (as on the network)
<th>出力
</thead><tbody>

<tr><td><pre class="lang-http">
A: nosniff,
</pre>
<td rowspan="2">« `nosniff^l, "" »

<tr><td><pre class="lang-http">
A: nosniff
B: sniff
A:
</pre>

<tr><td><pre class="lang-http">
A: text/html;", x/x
</pre>
<td rowspan="2">« `text/html;", x/x^l »

<tr><td><pre class="lang-http">
A: text/html;"
A: x/x
</pre>

<tr><td><pre class="lang-http">
A: x/x;test="hi",y/y
</pre>
<td rowspan="2">« `x/x;test="hi"^l, `y/y^l »

<tr><td><pre class="lang-http">
A: x/x;test="hi"
C: **bingo**
A: y/y
</pre>

<tr><td><pre class="lang-http">
A: x / x,,,1
</pre>
<td rowspan="2">« `x / x^l, "", "", `1^l »

<tr><td><pre class="lang-http">
A: x / x
A: ,
A: 1
</pre>

<tr><td><pre class="lang-http">
A: "1,2", 3
</pre>
<td rowspan="2">« `"1,2"^l, `3^l »

<tr><td><pre class="lang-http">
A: "1,2"
D: 4
A: 3
</pre>
</tbody></table>

</div>

<div class="algo">
<p>
`~header~list$ %~list に
`~headerを付加する@
ときは、所与の~pair
( `名前$hd %名前 / `値$hd %値 )
に対し，次を走らす：
◎
To append a name/value name/value pair to a header list list, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
%名前 ~SET そのような`~header$のうち最初のものの`名前$hd
◎
If list contains name, then set name to the first such header’s name.
</p>

<p class="note">注記：
これは、 %~list 内に該当する`~header$がすでにあれば，その`名前$hdの文字大小を再利用させる。
該当する~headerが複数あれば、それらすべての名前は同じ文字大小にされることになる。
◎
This reuses the casing of the name of the header already in list, if any. If there are multiple matched headers their names will all be identical.
</p>
	</li>
	<li>
%~list に
`新たな~header$( %名前 / %値 )
を`付加する$
◎
Append a new header whose name is name and value is value to list.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~list$ %~list から
`~headerを削除する@
ときは、所与の
( `名前$hd %名前 )
に対し，次を走らす
⇒
%~list から［
%名前 を`名前に持つ~header$
］をすべて`除去する$
◎
To delete a name name from a header list list, remove all headers whose name is a byte-case-insensitive match for name from list.
</p>
</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`~headerを設定する@
ときは、所与の~pair
( `名前$hd %名前 / `値$hd %値 )
に対し，次を走らす：
◎
To set a name/value name/value pair in a header list list, run these steps: 
</p>
<ol>
	<li>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
そのような`~header$のうち
⇒＃
最初のものに対しては，その`値$hd ~SET %値；
他のものは， %~list から`除去する$
◎
If list contains name, then set the value of the first such header to value and remove the others.
</li>
	<li>
~ELSE
⇒
%~list に
`新たな~header$( %名前 / %値 )
を`付加する$
◎
Otherwise, append a new header whose name is name and value is value to list.
</li>
</ol>

</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`~headerを結合する@
ときは、所与の~pair
( `名前$hd %名前 / `値$hd %値 )
に対し，次を走らす：
◎
To combine a name/value name/value pair in a header list list, run these steps: 
</p>
<ol>
	<li>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
そのような`~header$のうち，最初のものに対し
⇒
その`値$hdの末尾に［
`2C^X, `20^X, %値
］を順に付加する
◎
If list contains name, then set the value of the first such header to its value, followed by 0x2C 0x20, followed by value.
</li>
	<li>
~ELSE
⇒
%~list に
`新たな~header$( %名前 / %値 )
を`付加する$
◎
Otherwise, append a new header whose name is name and value is value to list.
</li>
</ol>

<p class="note">注記：
`~headerを結合する$は、もっぱら［
`XMLHttpRequest$I ／
`~WebSocket~protocol~handshakeを確立する$
］用に在る。
◎
Combine is used by XMLHttpRequest and the WebSocket protocol handshake.
</p>
</div>

<div class="algo">
<p>
`~header名たちを小文字~化して~sortした集合に変換する@
ときは、所与の
( `名前$hdたちからなる`~list$ %~header名たち )
に対し，次を走らす：
◎
To convert header names to a sorted-lowercase set, given a list of names headerNames, run these steps:
</p>
<ol>
	<li>
%~header名~集合 ~LET 新たな`有順序~集合$
◎
Let headerNamesSet be a new ordered set.
</li>
	<li>
%~header名たち を成す
~EACH( %名前 )
に対し
⇒
%~header名~集合 に次の結果を`付加する$set
⇒
`~byte小文字~化する$( %名前 )
◎
For each name of headerNames, append the result of byte-lowercasing name to headerNamesSet.
</li>
	<li>
~RET 
`~listを昇順に~sortする$( %~header名~集合, `未満の~byte列$ )
◎
Return the result of sorting headerNamesSet in ascending order with byte less than.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listを~sortして結合する@
ときは、所与の
( `~header~list$ %~list )
に対し，次を走らす：
◎
To sort and combine a header list list, run these steps:
</p>
<ol>
	<li>
%結果~list ~LET 空`~list$
◎
Let headers be an empty list of name-value pairs with the key being the name and value the value.
</li>
	<li>
%名前たち ~LET `~header名たちを小文字~化して~sortした集合に変換する$( %~list 内のすべての`~header$の`名前$hd )
◎
Let names be the result of convert header names to a sorted-lowercase set with all the names of the headers in list.
</li>
	<li>
<p>
%名前たち 内の
~EACH( %名前 )
に対し：
◎
For each name in names:
</p>
		<ol>
			<li>
%値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let value be the result of getting name from list.
</li>
			<li>
~Assert：
%値 ~NEQ ~NULL
◎
Assert: value is not null.
</li>
			<li>
%結果~list に 次のようにされた~pairを`付加する$
⇒
( ~key, 値 ) ~SET ( %名前, %値 )
◎
Append name-value to headers.
</li>
		</ol>
	<li>
~RET %結果~list
◎
Return headers.
</li>
</ol>
</div>

<hr>

<p>
`~header@
は、
`名前@hd
および
`値@hd
からなる：
◎
A header consists of a name and value.
</p>

<p class="trans-note">【
この仕様を通して、`~header$の［
`名前$hd, `値$hd
］が成す~pair, あるいは それを意図して与えられる~pairは、
“( %名前 / %値 )”
のように，スラッシュで区切った上で丸括弧で括られて記される。
】【
［
`~header$／`名前$hd／`値$hd
］は、~HTTPにおける［
`~field行l$／`~field名$／`~field行l値$
］に対応する。
】</p>

<ul>
	<li>
<p>
`名前$hdは、 `field-name$p ~token生成規則に合致する`~byte列$である。
</p>

<p class="trans-note">【
ある`名前$hdに`~byte大小無視$で合致する どの`~byte列$も、`名前$hdになる。
】</p>
◎
A name is a byte sequence that matches the field-name token production.
</li>
	<li>
<p>
`値$hdは、次の両~条件に合致する`~byte列$である：
◎
A value is a byte sequence that matches the following conditions:
</p>
		<ul>
			<li>
［
頭部, 尾部
］を成す`~HTTP~tab-or-space~byte$は無い。
◎
Has no leading or trailing HTTP tab or space bytes.
</li>
			<li>
`00^X `NUL^smb, `~HTTP改行~byte$は包含しない。
◎
Contains no 0x00 (NUL) or HTTP newline bytes.
</li>
		</ul>

<p class="trans-note">【
定義により、`値$hdは空~byte列もとり得ることになる。
】</p>

<p class="note">注記：
`値$hdの定義は、~HTTP~token生成規則を通しては定義されていない
— <a href="https://github.com/httpwg/http11bis/issues/19">それは壊れている</a>
。
◎
The definition of value is not defined in terms of an HTTP token production as it is broken.
</p>

	</li>
</ul>

<p>
`新たな~header@( %名前 / %値 )
という表記は、
( `名前$hd / `値$hd ) ~SET ( %名前 / %値 )
にされた，新たな`~header$を意味する。
【この表記は、この訳による追加。】
</p>

<div class="algo">
<p>
`値を正規化する@
ときは、所与の
( `~byte列$ %値 )
に対し，
%値 から［
頭部, 尾部
］を成す`~HTTP空白~byte$並びを除去した結果を返す。
◎
To normalize a potentialValue, remove any leading and trailing HTTP whitespace bytes from potentialValue.
</p>
</div>

<hr>

<div class="algo">
<p>
所与の`~header$ %~header が
`~CORS安全とされる要請~header@
かどうか決定するときは、次を走らす：
◎
To determine whether a header header is a CORS-safelisted request-header, run these steps:
</p>
<ol>
	<li>
%値 ~LET %~header の`値$hd
◎
Let value be header’s value.
</li>
	<li>
<p>
~IF［［
%~header は、次の表の 1 列目に挙げるどれを`名前に持つ~header$か
］に応じて，同じ行の 2 列目に与える条件が満たされる
］
⇒
~RET ~F
◎
Byte-lowercase header’s name and switch on the result:
</p>

<table><thead><tr><th>~header名
<th>条件
</thead><tbody id="_cors-safelisted-request-header-table">

<tr><td>`Accept$h
<td>
%値 を成す ある~byteは、`~CORS非安全な要請~header~byte$である
◎
If value contains a CORS-unsafe request-header byte, then return false.

<tr><td>`Accept-Language$h,
`Content-Language$h
<td>
%値 を成す ある~byteは、次に挙げる どれでもない
⇒＃
`20^X `SP^smb,
`2A^X `*^smb,
`2C^X `,^smb,
`2D^X `-^smb,
`2E^X `.^smb,
`30^X `0^smb 〜 `39^X `9^smb,
`3B^X `;^smb,
`3D^X `=^smb,
`41^X `A^smb 〜 `5A^X `Z^smb,
`61^X `a^smb 〜 `7A^X `z^smb,
◎
If value contains a byte that is not in the range 0x30 (0) to 0x39 (9), inclusive, is not in the range 0x41 (A) to 0x5A (Z), inclusive, is not in the range 0x61 (a) to 0x7A (z), inclusive, and is not 0x20 (SP), 0x2A (*), 0x2C (,), 0x2D (-), 0x2E (.), 0x3B (;), or 0x3D (=), then return false.

<tr><td>`Content-Type$h
<td>

<div >

<p>
次のいずれかが満たされる：
</p>
<ul>
	<li>
%値 を成す ある~byteは、`~CORS非安全な要請~header~byte$である
</li>
	<li>
`~MIME型を構文解析する$( %値 ) の結果は `失敗^i, または 次を満たす
⇒
結果の`~essence$ ~NIN { `application/x-www-form-urlencoded^l, `multipart/form-data^l, `text/plain^l }
</li>
</ul>

◎
If value contains a CORS-unsafe request-header byte, then return false.
◎
Let mimeType be the result of parsing value.
◎
If mimeType is failure, then return false.
◎
If mimeType’s essence is not "application/x-www-form-urlencoded", "multipart/form-data", or "text/plain", then return false.
</div>

<p class="warning">
これは、`~header~listから~MIME型を抽出する$ を意図的に利用しない。
その~algoは~~寛容にされており、~serverが実装することは期待されていないので。
◎
This intentionally does not use extract a MIME type as that algorithm is rather forgiving and servers are not expected to implement it.
</p>

<div class="example">

<p>
`~header~listから~MIME型を抽出する$ が利用された場合、次の要請からは~CORS予行~要請は生じなくなり，~server上の素朴な構文解析器は要請~本体を~JSONとして扱うかもしれない：
◎
If extract a MIME type were used the following request would not result in a CORS preflight and a naïve parser on the server might treat the request body as JSON:
</p>

<pre class="lang-js">
fetch("https://victim.example/naïve-endpoint", {
  method: "POST",
  headers: [
    ["Content-Type", "application/json"],
    ["Content-Type", "text/plain"]
  ],
  credentials: "include",
  body: JSON.stringify(exerciseForTheReader)
});
</pre>

</div>

<tr><td>その他
◎
Otherwise
<td>
無条件
◎
Return false.
</tbody></table>

	</li>
	<li>
~IF［
%値 の`長さ$ ~GT 128
］
⇒
~RET ~F
◎
If value’s length is greater than 128, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<p class="note">注記：
~CORS安全とされる `Content-Type$h ~headerには，制限付きな例外がある
— <a href="#cors-protocol-exceptions">§ ~CORS~protocol例外</a>
を見よ。
◎
There are limited exceptions to the `Content-Type` header safelist, as documented in CORS protocol exceptions.
</p>

<p>
次に挙げる~byteは、
`~CORS非安全な要請~header~byte@
とされる
⇒＃
`0^X 〜 `08^X,
`0A^X 〜 `1F^X,
`22^X `"^smb,
`28^X `(^smb,
`29^X `)^smb,
`3A^X `:^smb,
`3C^X `&lt;^smb,
`3E^X `&gt;^smb,
`3F^X `?^smb,
`40^X `@^smb,
`5B^X `[^smb,
`5C^X `\^smb,
`5D^X `]^smb,
`7B^X `{^smb,
`7D^X `}^smb,
`7F^X `DEL^smb
◎
A CORS-unsafe request-header byte is a byte byte for which one of the following is true:
• byte is less than 0x20 and is not 0x09 HT
• byte is 0x22 ("), 0x28 (left parenthesis), 0x29 (right parenthesis), 0x3A (:), 0x3C (&lt;), 0x3E (&gt;), 0x3F (?), 0x40 (@), 0x5B ([), 0x5C (\), 0x5D (]), 0x7B ({), 0x7D (}), or 0x7F DEL.
</p>

<div class="algo">
<p>
`~CORS非安全な要請~header名たち@
は、所与の
( `~header~list$ %~headerたち )
に対し，次に従って決定される：
◎
The CORS-unsafe request-header names, given a header list headers, are determined as follows:
</p>
<ol>
	<li>
%非安全な名前たち ~LET 新たな`~list$
◎
Let unsafeNames be a new list.
</li>
	<li>
%非安全になり得る名前たち ~LET 新たな`~list$
◎
Let potentiallyUnsafeNames be a new list.
</li>
	<li>
%安全な値の合計~size ~LET 0
◎
Let safelistValueSize be 0.
</li>
	<li>
<p>
%~headerたち を成す
~EACH( %~header )
に対し：
◎
For each header of headers:
</p>
		<ol>
			<li>
~IF［
%~header は`~CORS安全とされる要請~header$でない
］
⇒
%非安全な名前たち に %~header の`名前$hdを`付加する$
◎
If header is not a CORS-safelisted request-header, then append header’s name to unsafeNames.
</li>
	<li>
~ELSE
⇒＃
%非安全になり得る名前たち に %~header の`名前$hdを`付加する$；
%安全な値の合計~size ~INCBY %~header の`値$hdの`長さ$
◎
Otherwise, append header’s name to potentiallyUnsafeNames and increase safelistValueSize by header’s value’s length.
</li>
		</ol>
	</li>
	<li>
~IF［
%安全な値の合計~size ~GT 1024
］
⇒
%非安全になり得る名前たち を成す
~EACH( %名前 )
に対し
⇒
%非安全な名前たち に %名前 を`付加する$
◎
If safelistValueSize is greater than 1024, then for each name of potentiallyUnsafeNames, append name to unsafeNames.
</li>
	<li>
~RET `~header名たちを小文字~化して~sortした集合に変換する$( %非安全な名前たち )
◎
Return the result of convert header names to a sorted-lowercase set with unsafeNames.
</li>
</ol>
</div>

<p>
`~CORS非~wildcard要請~header名@
は、［
次に挙げるいずれかの`名前$hdに`~byte大小無視$で合致する`名前$hd
］である
⇒＃
`Authorization$h
◎
A CORS non-wildcard request-header name is a byte-case-insensitive match for `Authorization`.
</p>

<p>
`特権的~CORSなし要請~header名@
は、［
次に挙げるいずれかの`名前$hdに`~byte大小無視$で合致する`名前$hd
］である
⇒＃
`Range$h
◎
A privileged no-CORS request-header name is a header name that is a byte-case-insensitive match for one of
• `Range`
</p>

<div class="note">

<p>注記：
これらは、特権的~APIにより設定され得る~headerであり，それを結付けている要請~objが複製される場合には 保全されるが、その要請が特権的でない~APIにより改変された場合には 除去されることになる。
◎
These are headers that can be set by privileged APIs, and will be preserved if their associated request object is copied, but will be removed if the request is modified by unprivilaged APIs.
</p>

<p>
`Range$h ~headerは，［
<a href="~HTMLlinks#downloading-hyperlinks">~downloadする</a> ／
<a href="~HEmedia#concept-media-load-resource">~mediaを~fetchする</a>
］ときに共通して利用されるが、どちらも，どう利用するかまだ指定していない。
<a href="https://github.com/whatwg/html/pull/2814">html/2914</a>
がこれを解くことを目指す。
◎
`Range` headers are commonly used by downloads and media fetches, although neither of these currently specify how. html/2914 aims to solve this.
</p>

<p>
特定0の要請に`範囲~headerを追加する$ために，~helperが供される。【？】
◎
A helper is provided to add a range header to a particular request.
</p>

</div>

<div class="p">
<p>
所与の`~CORSに公開される~header名~list$rs %~list 内の
`~CORS安全とされる応答~header名@
とは、次をいずれも満たす`名前$hdである：
</p>
<ul>
	<li>
`禁止~応答~header名$でない
</li>
	<li>
［
%~list に挙げられた値,
次に挙げる`名前$hd
］のいずれかに`~byte大小無視$で合致する
⇒＃
`Cache-Control$h,
`Content-Language$h,
`Content-Length$h,
`Content-Type$h,
`Expires$h,
`Last-Modified$h,
`Pragma$h
</li>
</ul>
◎
A CORS-safelisted response-header name, given a CORS-exposed header-name list list, is a header name that is a byte-case-insensitive match for one of
• `Cache-Control`
• `Content-Language`
• `Content-Length`
• `Content-Type`
• `Expires`
• `Last-Modified`
• `Pragma`
• Any value in list that is not a forbidden response-header name.
</div>

<p>
`~CORSなしで安全とされる要請~header名@
とは、次に挙げるいずれかに`~byte大小無視$で合致する`名前$hdである
⇒＃
`Accept$h,
`Accept-Language$h,
`Content-Language$h,
`Content-Type$h
◎
A no-CORS-safelisted request-header name is a header name that is a byte-case-insensitive match for one of
• `Accept`
• `Accept-Language`
• `Content-Language`
• `Content-Type`
</p>

<p>
`~CORSなしで安全とされる要請~header@
とは、次をいずれも満たす`~header$である：
◎
To determine whether a header header is a no-CORS-safelisted request-header, run these steps:
</p>
<ul>
	<li>
`~CORSなしで安全とされる要請~header名$を`名前に持つ~header$である
◎
If header’s name is not a no-CORS-safelisted request-header name, then return false.
</li>
	<li>
`~CORS安全とされる要請~header$である
◎
Return whether header is a CORS-safelisted request-header.
</li>
</ul>

<p>
`禁止~header名@
とは、次のいずれかに該当する`名前$hdである：
◎
A forbidden header name is a header name that is a byte-case-insensitive match for one of
</p>

<ul>
	<li>
<p>
次に挙げるいずれかに`~byte大小無視$で合致するもの
⇒＃
`Accept-Charset$h,
`Accept-Encoding$h,
`Access-Control-Request-Headers$h,
`Access-Control-Request-Method$h,
`Connection$h,
`Content-Length$h,
`Cookie$h,
`Cookie2^h,
`Date$h,
`DNT^h 【<a href="https://tools.ietf.org/html/draft-mayer-do-not-track-00">Do Not Track</a>】,
`Expect$h,
`Host$h,
`Keep-Alive$h,
`Origin$h,
`Referer$h,
`TE$h,
`Trailer$h,
`Transfer-Encoding$h,
`Upgrade$h,
`Via$h
</li>
	<li>
頭部が［
`Proxy-^h, `Sec-^h
］のいずれかに`~byte大小無視$で合致するもの（合致する頭部が全体であるものも含む）。
◎
or a header name that starts with a byte-case-insensitive match for `Proxy-` or `Sec-` (including being a byte-case-insensitive match for just `Proxy-` or `Sec-`).
</li>
</ul>

<p class="note">注記：
これらは、全部的に~UAの制御~下に留め置くため，禁止される。
`Sec-^h で始まる`名前$hdは、~APIから安全に［
`XMLHttpRequest$I
などの，開発者による制御が許容される`~header$が含まれた`~fetch$
］を行えるような，新種の`~header$を創出できるようにするため、予約されている。
`XHR$r
◎
These are forbidden so the user agent remains in full control over them. Names starting with `Sec-` are reserved to allow new headers to be minted that are safe from APIs using fetch that allow control over headers by developers, such as XMLHttpRequest. [XHR]
</p>

<p>
`禁止~応答~header名@
とは、次のいずれかに`~byte大小無視$で合致する`名前$hdである
⇒＃
`Set-Cookie$h,
`Set-Cookie2^h
◎
A forbidden response-header name is a header name that is a byte-case-insensitive match for one of:
• `Set-Cookie`
• `Set-Cookie2`
</p>

<p>
`要請~本体~header名@
とは、次のいずれかに`~byte大小無視$で合致する`名前$hdである
⇒＃
`Content-Encoding$h
`Content-Language$h
`Content-Location$h
`Content-Type$h
◎
A request-body-header name is a header name that is a byte-case-insensitive match for one of:
• `Content-Encoding`
• `Content-Language`
• `Content-Location`
• `Content-Type`
</p>

<hr>

<div class="algo">
<p>
`~headerから値を抽出する@
ときは、所与の
( `~header$ %~header )
に対し，次を走らす：
◎
To extract header values given a header header, run these steps:
</p>
<ol>
	<li>
%~header の`値$hdを［
%~header の`名前$hd用の`~ABNF$
］に従って構文解析する
【 ~HTTPの <a href="~HTTPmsg#field.parsing">§ ~field行lの構文解析</a>】
◎
If parsing header’s value, per the ABNF for header’s name, fails, then return failure.
</li>
	<li>
~RET［
前~段に失敗したならば `失敗^i ／
~ELSE_ 前~段による結果を成す 1 個以上の`値$hd
］
◎
Return one or more values resulting from parsing header’s value, per the ABNF for header’s name.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listから値を抽出する@
ときは、所与の
(`~header~list$ %~header~list, `名前$hd %名前 )
に対し，次を走らす：
◎
To extract header list values given a name name and a header list list, run these steps:
</p>
<ol>
	<li>
%~list ~LET %~header~list 内の［
%名前 を`名前に持つ~header$
］すべてからなる~list
◎
↓</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list does not contain name, then return null.
</li>
	<li>
<p>
~IF［［
%名前 用の`~ABNF$
］にて許容されている`~header$の個数 は 1 個†
］~AND［
%~list 内に複数個の`~header$がある
］
⇒
~RET `失敗^i
◎
If the ABNF for name allows a single header and list contains more than one, then return failure.
</p>

<p class="note">注記：
異なる~errorの取扱いが必要な場合††、事前に~~目的の`~header$を抽出すること。
◎
If different error handling is needed, extract the desired header first.
</p>

<p class="trans-note">【†
すなわち、 %名前 は`単数~field$の名前を与えている。
】【††
~HTTPの
<a href="~HTTPsem#field.order">§ ~fieldの順序と結合</a>
の注記（ `Set-Cookie$h ）に加え，
§ `Content-Length$h の最後の方の記述なども該当するように見受けられる。
】</p>

	</li>
	<li>
%値~list ~LET 空`~list$
◎
Let values be an empty list.
</li>
	<li>
<p>
%~list 内の
~EACH( `~header$ %~header )
に対し：
◎
For each header header list contains whose name is name:
</p>
		<ol>
			<li>
%抽出- ~LET `~headerから値を抽出する$( %~header )
◎
Let extract be the result of extracting header values from header.
</li>
			<li>
~IF［
%抽出- ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If extract is failure, then return failure.
</li>
			<li>
%抽出- 内の
~EACH( `値$hd %値 )
に対し
⇒
%値~list に %値 を付加する
◎
Append each value in extract, in order, to values.
</li>
		</ol>
	</li>
	<li>
~RET %値~list†
◎
Return values.
</li>
</ol>

<p class="trans-note">【†
`単数~field$である場合、この手続きを呼出している所では，結果の %値~list は暗黙的に その最初の値と同一視されている。
】</p>

</div>

<hr>

<p>
`既定の User-Agent 値@
とは、~UAが `User-Agent$h `~header$用に定義する`値$hdである。
◎
A default `User-Agent` value is a user-agent-defined value for the `User-Agent` header.
</p>

			</section>
			<section id="statuses">
<h4 title="Statuses">2.2.3. 状態s</h4>

<p>
`状態s@
は~codeである。
【~HTTPにおける`応答~状態s~code$に対応する。】
◎
A status is a code.
</p>

<p>
次に挙げる`状態s$は、
`~null本体~状態s@
であるとされる
⇒＃
`101$st,
`204$st,
`205$st,
`304$st
◎
A null body status is a status that is 101, 204, 205, or 304.
</p>

<p>
次の範囲に入る`状態s$は、
`~ok状態s@
であるとされる
⇒
`200^st 〜 `299^st
◎
An ok status is any status in the range 200 to 299, inclusive.
</p>

<p>
次に挙げる`状態s$は、
`~redirect状態s@
であるとされる
⇒＃
`301$st,
`302$st,
`303$st,
`307$st,
`308$st
◎
A redirect status is a status that is 301, 302, 303, 307, or 308.
</p>

			</section>
			<section id="bodies">
<h4 title="Bodies">2.2.4. 本体</h4>

<p>
`本体@
（ `body^en ）は、次のものからなる：
◎
A body consists of:
</p>

<dl class="def-list">
	<dt>`~stream@bd</dt>
	<dd>
~NULL または `ReadableStream$I ~obj。
◎
A stream (null or a ReadableStream object).
</dd>

	<dt>`伝送-済み~byte数@bd</dt>
	<dd>
整数
— 初期~時は 0 。
◎
A transmitted bytes (an integer), initially 0.
</dd>

	<dt>`総~byte数@bd</dt>
	<dd>
整数
— 初期~時は 0 。
◎
A total bytes (an integer), initially 0.
</dd>

	<dt>`~source@bd</dt>
	<dd>
初期~時は ~NULL 。
◎
A source, initially null.
</dd>
</dl>

<p class="trans-note">【
本体は、~HTTPにおける~messageの`~payload本体$に対応する。
】</p>

<div class="p">
<p>
`本体$ %本体 は、次のいずれかを満たすならば，
`~done@bd
であるという：
</p>

<ul>
	<li>
%本体 ~EQ ~NULL
</li>
	<li>
%本体 の`~stream$bd は［
`~closeされた$RS ／ `~errorした$RS
］
</li>
</ul>

◎
A body body is said to be done if body is null or body’s stream is closed or errored.
</div>

<div class="algo">
<p>
`本体を待機する@
ときは、所与の
( `本体$ %本体 )
に対し %本体 が`~done$bdになるまで，待機する
◎
To wait for a body body, wait for body to be done.
</p>
</div>

<div class="algo">
<p>
`本体を~cloneする@
ときは、所与の
( `本体$ %本体 )
に対し，次を走らす：
◎
To clone a body body, run these steps:
</p>
<ol>
	<li>
«%out1, %out2» ~LET
%本体 の`~stream$bdを`二叉化する$RS()
◎
Let «out1, out2» be the result of teeing body’s stream.
</li>
	<li>
%本体 の`~stream$bd ~SET %out1
◎
Set body’s stream to out1.
</li>
	<li>
~RET 次のようにされた新たな`本体$
⇒＃
`~stream$bd ~SET %out2；
他の~memberは %本体 から複製する
◎
Return a body whose stream is out2 and other members are copied from body.
</li>
</ol>
</div>

<div class="algo">
<p>
`内容~符号法sを取扱う@
ときは、所与の
( 内容~符号法s† %符号法s, ~byte列 %~byte列 )
に対し，次を走らす
【† 複数の`内容~符号法$が重ねて適用されることもあり得る】
：
◎
To handle content codings given codings and bytes, run these steps:
</p>
<ol>
	<li>
~IF［
%符号法s
【内のいずれかの符号法】
は~supportされていない
］
⇒
~RET %~byte列
◎
If codings are not supported, then return bytes.
</li>
	<li>
~RET ［
次の結果は~errorでないならば その結果 ／
~ELSE_ `失敗^i
］
⇒
~HTTPに従って， %~byte列 を %符号法s で復号する
`HTTP$r
`HTTP-SEMANTICS$r
◎
Return the result of decoding bytes with codings as explained in HTTP, if decoding does not result in an error, and failure otherwise. [HTTP] [HTTP-SEMANTICS]
</li>
</ol>
</div>

			</section>
			<section id="requests">
<h3 title="Requests">2.2.5. 要請</h3>

<p>
`要請@
（ `request^en ）は、`~fetch$への入力を与える。
◎
The input to fetch is a request.
</p>

<p>
`要請$には、以下に挙げるものが結付けられる。
各~項には，それがとり得る値の種類を示す。
他が言明されない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>`~method@rq（ `GET$hm ）</dt>
	<dd>
`~method$。
◎
A request has an associated method (a method). Unless stated otherwise it is `GET`.
</dd>
	<dd class="note">注記：
これは、`~HTTP~fetch$にて述べるように，~redirectの間に【 `POST$hm から】 `GET$hm に更新され得る。
【参考：状態s~code `3xx$st の注記】
◎
This can be updated during redirects to `GET` as described in HTTP fetch.
</dd>

	<dt>`~URL@rq</dt>
	<dd>
`~URL$。
◎
A request has an associated URL (a URL).
</dd>
	<dd class="note">注記：
実装には、これが`要請$の`~URL~list$rq内の最初の`~URL$を指すようにすることが奨励される。
これはもっぱら、~Fetchの中へ~hookする他の標準の便利~用に，別個の~fieldとして供されている。
◎
Implementations are encouraged to make this a pointer to the first URL in request’s URL list. It is provided as a distinct field solely for the convenience of other standards hooking into Fetch.
</dd>
	<dd class="trans-note">【
資源の~fetch先
— ~HTTPにおける`~target~URI$に対応する。
】</dd>

	<dt>`局所~URLのみ~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated local-URLs-only flag. Unless stated otherwise it is unset.
</dd>

	<dt>`~header~list@rq（ 空~list ）</dt>
	<dd>
`~header~list$。
◎
A request has an associated header list (a header list). Unless stated otherwise it is empty.
</dd>

	<dt>`非安全~要請~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated unsafe-request flag. Unless stated otherwise it is unset.
</dd>
	<dd class="note">注記：
`非安全~要請~flag$rqは、給された`~method$rqと`~header~list$rqに基づいて `~CORS予行~fetch$が行われるようにするために，
`fetch()$m や
`XMLHttpRequest$I
などの~APIにより ~T にされる。
これは、~APIにおいて`禁止~method$や`禁止~header名$を~~合法にするものではない。
◎
The unsafe-request flag is set by APIs such as fetch() and XMLHttpRequest to ensure a CORS-preflight fetch is done based on the supplied method and header list. It does not free an API from outlawing forbidden methods and forbidden header names.
</dd>

	<dt>`本体@rq（ ~NULL ）</dt>
	<dd>
~NULL ／ `~byte列$ ／ `本体$。
◎
A request has an associated body (null, a byte sequence, or a body). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
`本体$の中へは、`~fetch$における早期に`~byte列$が<a href="#bodyinit-safely-extract">安全に抽出される</a>ことになる。
この~fieldは、ある種の~redirectに因り，`~HTTP~fetch$の一部として ~NULL に設定され得る。
◎
A byte sequence will be safely extracted into a body early on in fetch. As part of HTTP fetch it is possible for this field to be set to null due to certain redirects.
</dd>

	<dt>`~client@rq</dt>
	<dd>
~NULL または`環境~設定群~obj$。
◎
A request has an associated client (null or an environment settings object).
</dd>

	<dt>`予約-済み~client@rq （ ~NULL ）</dt>
	<dd>
~NULL または `環境$ または `環境~設定群~obj$。
◎
A request has an associated reserved client (null, an environment, or an environment settings object). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
これが利用されるのは、~navi要請, ~worker要請に限られ，~sw要請には利用されない。
それは［
`~navi要請$に対しては `環境$ ／
~worker要請に対しては `環境~設定群~obj$
］を参照する。
◎
This is only used by navigation requests and worker requests, but not service worker requests. It references an environment for a navigation request and an environment settings object for a worker request.
</dd>

	<dt>`置換する~client~id@rq （ 空~文字列 ）</dt>
	<dd>
文字列。
◎
A request has an associated replaces client id (a string). Unless stated otherwise it is the empty string.
</dd>
	<dd class="note">注記：
これが利用されるのは、~navi要請に限られる。
それは、`~target閲覧文脈$enVにて`作動中の文書$の`環境~設定群~obj$の`~id$enVになる。
◎
This is only used by navigation requests. It is the id of the target browsing context’s active document’s environment settings object.
</dd>

	<dt>`~window@rq（ `client^l ）</dt>
	<dd>
次のいずれか
⇒＃
`no-window^l,
`client^l,
`環境~設定群~obj$のうち［その`大域~obj$enVは `Window$I ~objである］もの
◎
A request has an associated window ("no-window", "client", or an environment settings object whose global object is a Window object). Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l 値は、`~fetching$の間に［
`no-window^l ／ `要請$の`~client$rq
］に変更される。
この値は、各種~標準が`要請$の`~window$rqを明示的に設定せずに~fetchingを簡便に利用できるようにするためにある。
◎
The "client" value is changed to "no-window" or request’s client during fetching. It provides a convenient way for standards to not have to explicitly set request’s window.
</dd>

	<dt>`~keepalive~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated keepalive flag. Unless stated otherwise it is unset.
</dd>
	<dd class="note">注記：
これを利用すれば、要請は`環境~設定群~obj$の外で残存できるようになる
— 例えば［
`navigator.sendBeacon()$m ~method／~HTML `img$e 要素 ／
【~CSPの<a href="~CSP3#report-violation">違反~報告</a>】
］は、この~flagを ~T にする。
この~flagが ~T にされた要請は、追加的な処理~要件の~subjectになる。
◎
This can be used to allow the request to outlive the environment settings object, e.g., navigator.sendBeacon and the HTML img element set this flag. Requests with this flag set are subject to additional processing requirements.
</dd>

	<dt>`~sw~mode@rq （ `all^l ）</dt>
	<dd>
次のいずれか
⇒＃
`all^l,
`none^l
◎
A request has an associated service-workers mode, that is "all" or "none". Unless stated otherwise it is "all".
</dd>
	<dd class="note">
<p>注記：
これは、どの~swが，この~fetch用の `fetch$et ~eventを受取るかを決定する：
◎
This determines which service workers will receive a fetch event for this fetch.
</p>
		<dl>
			<dt>`all^l</dt>
			<dd>
関連な~swが，この~fetch用の `fetch$et ~eventを取得することになる。
◎
Relevant service workers will get a fetch event for this fetch.
</dd>

			<dt>`none^l</dt>
			<dd>
どの~swも，この~fetch用の~eventは取得しない。
◎
No service workers will get events for this fetch.
</dd>
		</dl>
	</dd>

	<dt>`起動元@rq（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`download^l,
`imageset^l,
`manifest^l,
`prefetch^l,
`prerender^l,
`xslt^l
◎
A request has an associated initiator, which is the empty string, "download", "imageset", "manifest", "prefetch", "prerender", or "xslt". Unless stated otherwise it is the empty string.
</dd>

<dd class="note">注記：
`要請$の`起動元$rqは、さしあたり 特に細分化されてはいない
— 他の仕様からそう要求されてはいないので。
これは~~主に， `CSP$r ／ `MIX$r を定義し易くするために~~導入された~~用語であり、~JSには公開されない。
◎
A request’s initiator is not particularly granular for the time being as other specifications do not require it to be. It is primarily a specification device to assist defining CSP and Mixed Content. It is not exposed to JavaScript. [CSP] [MIX]
</dd>

	<dt>`行先@rq（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`audio^l,
`audioworklet^l,
`document^l,
`embed^l,
`font^l,
`frame^l,
`iframe^l,
`image^l,
`manifest^l,
`object^l,
`paintworklet^l,
`report^l,
`script^l,
`serviceworker^l,
`sharedworker^l,
`style^l,
`track^l,
`video^l,
`worker^l,
`xslt^l
◎
A request has an associated destination, which is the empty string, "audio", "audioworklet", "document", "embed", "font", "frame", "iframe", "image", "manifest", "object", "paintworklet", "report", "script", "serviceworker", "sharedworker", "style", "track", "video", "worker", or "xslt". Unless stated otherwise it is the empty string.
</dd>
	<dd>
<p>
`要請$の`行先$rqのうち，次に挙げるものは
`~scriptに類する@
とされる
⇒＃
`audioworklet^l,
`paintworklet^l,
`script^l,
`serviceworker^l,
`sharedworker^l,
`worker^l
◎
A request’s destination is script-like if it is "audioworklet", "paintworklet", "script", "serviceworker", "sharedworker", or "worker".
</p>

<p class="warning">
`~scriptに類する$ものを利用する~algoは、 `xslt^l も考慮するベキである
— それも~script実行を生じさせ得るので。
上に挙げていないわけは、常に関連するとは限らず，異なる挙動が要求されることもあるためである。
◎
Algorithms that use script-like should also consider "xslt" as that too can cause script execution. It is not included in the list as it is not always relevant and might require different behavior.
</p>
	</dd>

	<dd class="note">
<p>
次の一覧は、`要請$の各種［
`起動元$rq,
`行先$rq
］が，どの［
~CSP指令, 特能
］から利用されるかを描き出したものである。
一覧は、特能に関しては網羅的ではない。
特能には、その仕様にて関連な値が定義される必要がある：
◎
The following table illustrates the relationship between a request’s initiator, destination, CSP directives, and features. It is not exhaustive with respect to features. Features need to have the relevant values defined in their respective standards.
</p>

<div style="overflow:auto;"><table><thead>
<tr><th>`起動元$rq
◎
Initiator
<th>`行先$rq
◎
Destination
<th>`~CSP指令$
◎
CSP directive
<th>特能
◎
Features
</thead><tbody>

<tr><td rowspan="19">""
<td>`report^l
<td>-
<td>CSP, NEL による報告

<tr><td>`document^l
<td>-
<td>~HTMLの`~navigate~algo$（~top-levelに限る）
◎
HTML’s navigate algorithm (top-level only).

<tr><td>`frame^l
<td>`child-src$dir
<td>~HTMLの `frame$e 要素

<tr><td>`iframe^l
<td>`child-src$dir
<td>~HTMLの `iframe$e 要素

<tr><td>""
<td>`connect-src$dir
<td><span class="preline"
>`navigator.sendBeacon()$m,
`EventSource$I,
~HTMLの `a ping=""^e,
~HTMLの `area ping=""^e,
`fetch()$m,
`XMLHttpRequest$I,
`WebSocket$I,
Cache API【？】

</span>

<tr><td>`object^l
<td>`object-src$dir
<td>~HTMLの `object$e 要素

<tr><td>`embed^l
<td>`object-src$dir
<td>~HTMLの `embed$e 要素

<tr><td>`audio^l
<td>`media-src$dir
<td>~HTMLの `audio$e 要素

<tr><td>`font^l
<td>`font-src$dir
<td>~CSSの `font-face^at 規則

<tr><td>`image^l
<td>`img-src$dir
<td><span class="preline"
>~HTMLの `img src^e,
`/favicon.ico^c 資源,
SVG の `image$e 要素,
</span>
~CSSの［
`background-image^css, `cursor^css, `list-style-image^css
］~prop, …

<tr><td>`audioworklet^l
<td>`script-src$dir
<td>`audioWorklet.addModule()^m

<tr><td>`paintworklet^l
<td>`script-src$dir
<td>`CSS.paintWorklet.addModule()^m

<tr><td>`script^l
<td>`script-src$dir
<td>~HTMLの `script$e 要素, `self.importScripts()$m

<tr><td>`serviceworker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`navigator.serviceWorker.register()$m

<tr><td>`sharedworker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`SharedWorker$I

<tr><td>`worker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`Worker$I

<tr><td>`style^l
<td>`style-src$dir
<td>
~HTMLの `link rel=stylesheet^e,
~CSSの `import^at 規則

<tr><td>`track^l
<td>`media-src$dir
<td>~HTMLの `track$e 要素

<tr><td>`video^l
<td>`media-src$dir
<td>~HTMLの `video$e 要素

<tr><td>`download^l
<td>""
<td>-
<td>~HTMLの `download=""^a, “~link先を保存…” UI

<tr><td>`imageset^l
<td>`image^l
<td>`img-src$dir
<td>~HTMLの `img srcset^e, `picture$e 要素

<tr><td>`manifest^l
<td>`manifest^l
<td>`manifest-src$dir
<td>~HTMLの `link rel=manifest^e 要素

<tr><td>`prefetch^l
<td>""
<td>`prefetch-src$dir
<td>~HTMLの `link rel=prefetch^e 要素

<tr><td>`prerender^l
<td>同上
<td>同上
<td>~HTMLの `link rel=prerender^e 要素

<tr><td>`xslt^l
<td>`xslt^l
<td>`script-src$dir
<td>`&lt;?xml-stylesheet&gt;^c

</tbody></table></div>

<p>
~CSPの `form-action$dir 指令は、直に ~HTMLの［
~navigate／~form提出
］~algoに~hookする必要がある。
◎
CSP’s form-action needs to be a hook directly in HTML’s navigate or form submission algorithm.
</p>

<p>
~CSPは、各種~CSP指令~用に，［
`要請$の`~client$rqの`担当の文書$enVが`属する閲覧文脈$
］の各 `先祖~閲覧文脈$についても検査する必要がある。
◎
CSP will also need to check request’s client’s responsible document’s browsing context’s ancestor browsing contexts for various CSP directives.
</p>

	</dd>

	<dt>`優先度@rq（ ~NULL ）</dt>
	<dd>
~NULL または~UAにより定義される~obj。
【<a href="#_stream-priority">~~説明</a>】
◎
A request has an associated priority (null or a user-agent-defined object). Unless otherwise stated it is null.
</dd>

	<dt>`生成元@rq（ `client^l ）</dt>
	<dd>
<p>
`client^l, または
`生成元$。
◎
A request has an associated origin, which is "client" or an origin. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l は、`~fetching$の間に`生成元$に変化する。
この値は、各種~標準が，`要請$の`生成元$rqを設定せずに~fetchingを簡便に利用できるようにするためにある。
◎
"client" is changed to an origin during fetching. It provides a convenient way for standards to not have to set request’s origin.
</dd>

	<dt>`~referrer@rq（ `client^l ）</dt>
	<dd>
次のいずれか
⇒＃
`no-referrer^l,
`client^l,
`~URL$
◎
A request has an associated referrer, which is "no-referrer", "client", or a URL. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l は、`~fetching$の間に［
`no-referrer^l ／ `~URL$
］に変化する。
この値は、各種~標準が，`要請$の`~referrer$rqを設定せずに~fetchingを簡便に利用できるようにするためにある。
◎
"client" is changed to "no-referrer" or a URL during fetching. It provides a convenient way for standards to not have to set request’s referrer.
</dd>

	<dt>`~referrer施策@rq（ 空~文字列 ）</dt>
	<dd>
`~referrer施策$。
`REFERRER$r
◎
A request has an associated referrer policy, which is a referrer policy. Unless stated otherwise it is the empty string. [REFERRER]
</dd>
	<dd class="note">注記：
これは、［
`環境~設定群~obj$に結付けられている~referrer施策
］を上書きするときに利用できる。
`REFERRER$r
◎
This can be used to override a referrer policy associated with an environment settings object.
</dd>

	<dt>`同期~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated synchronous flag. Unless stated otherwise it is unset.
</dd>

	<dt>`~mode@rq（ `no-cors^l ）</dt>
	<dd>
次のいずれか
⇒＃
`same-origin^l,
`cors^l,
`no-cors^l,
`navigate^l,
`websocket^l
◎
A request has an associated mode, which is "same-origin", "cors", "no-cors", "navigate", or "websocket". Unless stated otherwise, it is "no-cors".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
</p>
		<dl>
			<dt>`same-origin^l</dt>
			<dd>
要請が同一-生成元~URLになることを確保するために利用される。
要請を同一-生成元~URLにできなかった場合、`~fetch$は`~network~error$を返すことになる。
◎
Used to ensure requests are made to same-origin URLs. Fetch will return a network error if the request is not made to a same-origin URL.
</dd>

			<dt>`cors^l</dt>
			<dd>
要請を`~CORS要請$にする。
要請された資源が`~CORS~protocol$に解されなかった場合、~fetchは`~network~error$を返すことになる。
◎
Makes the request a CORS request. Fetch will return a network error if the requested resource does not understand the CORS protocol.
</dd>

			<dt>`no-cors^l</dt>
			<dd>
要請が［
`~CORS安全とされる~method$,
`~CORS安全とされる要請~header$
］を利用するよう制約する。
成功~時には、~fetchは`不透明な絞込み応答$を返すことになる。
◎
Restricts requests to using CORS-safelisted methods and CORS-safelisted request-headers. Upon success, fetch will return an opaque filtered response.
</dd>

			<dt>`navigate^l</dt>
			<dd>
これは、文書~間で`~navigate$するときに限り利用される，特別な~modeである。
◎
This is a special mode used only when navigating between documents.
</dd>

			<dt>`websocket^l</dt>
			<dd>
これは、`~WebSocket~protocol~handshakeを確立する$ときに限り利用される，特別な~modeである。
◎
This is a special mode used only when establishing a WebSocket connection.
</dd>
		</dl>
	</dd>
	<dd class="note">注記：
`要請$の既定の`~mode$rqは `no-cors^l であるが、標準には，新たな特能には利用しないことが~~強く奨励される。
それは、むしろ安全でない。
◎
Even though the default request mode is "no-cors", standards are highly discouraged from using it for new features. It is rather unsafe.
</dd>

	<dt>`~CORS予行~利用~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated use-CORS-preflight flag. Unless stated otherwise, it is unset.
</dd>
	<dd class="note">
<p>
注記：
`~CORS予行~要請$が生じるための条件にはいくつかあるが、［
`~CORS予行~利用~flag$rq ~EQ ~T
］であることは，その 1 つである。
この~flagは、次のいずれかの場合には ~T にされる：
</p>

<ul ><li>`XMLHttpRequestUpload$I ~obj上に登録されている~event~listenerがある
</li><li>要請に `ReadableStream$I ~objが利用されている
</li></ul>

◎
The use-CORS-preflight flag being set is one of several conditions that results in a CORS-preflight request. The use-CORS-preflight flag is set if either one or more event listeners are registered on an XMLHttpRequestUpload object or if a ReadableStream object is used in a request.
</dd>

	<dt>`資格証~mode@rq（ `omit^l ）</dt>
	<dd>
次のいずれか
⇒＃
`omit^l,
`same-origin^l,
`include^l
◎
A request has an associated credentials mode, which is "omit", "same-origin", or "include". Unless stated otherwise, it is "omit".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
</p>
		<dl>
			<dt>`omit^l</dt>
			<dd>
この要請には、資格証を含めない。
◎
Excludes credentials from this request.
</dd>

			<dt>`same-origin^l</dt>
			<dd>
同一-生成元~URLにされた要請には、資格証を含める。
◎
Include credentials with requests made to same-origin URLs.
</dd>

			<dt>`include^l</dt>
			<dd>
この要請には、常に資格証を含める。
◎
Always includes credentials with this request.
</dd>
		</dl>
	</dd>
	<dd class="note">注記：
`要請$の`資格証~mode$rqは、`~fetch$の間，`資格証$の~flowを制御する。
`要請$の`~mode$rq が `navigate^l のときは、その`資格証~mode$rqは `include^l と見做される
— 他の値は、現時点では，`~fetch$に織り込まれていない。
`~HTML^cite がここの所で変更された場合、この標準も対応する変更が必要になる。
◎
Request’s credentials mode controls the flow of credentials during a fetch. When request’s mode is "navigate", its credentials mode is assumed to be "include" and fetch does not currently account for other values. If HTML changes here, this standard will need corresponding changes.
</dd>

	<dt>`資格証利用URL~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated use-URL-credentials flag. Unless stated otherwise, it is unset.
</dd>

	<dt>`~cache~mode@rq（ `default^l ）</dt>
	<dd>
次のいずれか
⇒＃
`default^l,
`no-store^l,
`reload^l,
`no-cache^l,
`force-cache^l,
`only-if-cached^l
◎
A request has an associated cache mode, which is "default", "no-store", "reload", "no-cache", "force-cache", or "only-if-cached". Unless stated otherwise, it is "default".
</dd>
	<dd class="note">注記：
		<dl>
			<dt>`default^l</dt>
			<dd>
<p>
`~fetch$は、~networkへ向かうに先立ち，~HTTP~cacheを検分する。
~HTTP~cache内に要請に合致している［
(1) `新鮮な応答$が在る ／
(2) `~stale-while-revalidate応答$が在る／
(3) `非新鮮な応答$が在る ／
(4) 応答は無い
］とするとき：
</p>

				<ul>
					<li>
(1) ／ (2)
の場合、合致したそれを返す。
</li>
					<li>
(2) の場合、条件付き~network~fetchも為して，対する応答で~HTTP~cache内の合致したそれを更新する。
</li>
					<li>
(3) の場合、条件付き~network~fetchを為して，対する応答で~HTTP~cache内の合致したそれを更新した上で，その結果を返す。
</li>
					<li>
(4) の場合、条件付きでない~network~fetchを為して，対する応答を返した上で，その応答で~HTTP~cacheも更新する。
</li>
				</ul>
<p>
`HTTP$r
`HTTP-SEMANTICS$r
`HTTP-COND$r
`HTTP-CACHING$r
`HTTP-AUTH$r
`STALE-WHILE-REVALIDATE$r
</p>
◎
Fetch will inspect the HTTP cache on the way to the network. If the HTTP cache contains a matching fresh response it will be returned. If the HTTP cache contains a matching stale-while-revalidate response it will be returned, and a conditional network fetch will be made to update the entry in the HTTP cache. If the HTTP cache contains a matching stale response, a conditional network fetch will be returned to update the entry in the HTTP cache. Otherwise, a non-conditional network fetch will be returned to update the entry in the HTTP cache. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH] [STALE-WHILE-REVALIDATE]
</dd>

			<dt>`no-store^l</dt>
			<dd>
~fetchは、~HTTP~cacheが全く無かったかのように挙動する。
◎
Fetch behaves as if there is no HTTP cache at all.
</dd>

			<dt>`reload^l</dt>
			<dd>
~fetchは、~networkへ向かう際には，~HTTP~cacheが全く無かったかのように挙動する。
それがため、通常の要請を作成して，対する応答で~HTTP~cacheを更新する。
◎
Fetch behaves as if there is no HTTP cache on the way to the network. Ergo, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>`no-cache^l</dt>
			<dd>
~fetchは、~HTTP~cache内に要請に合致する応答が［
在れば `条件付き要請$ ／ 無ければ 通常の要請
］を作成した上で、対する応答で~HTTP~cacheを更新する。
◎
Fetch creates a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.
</dd>

			<dt>`force-cache^l</dt>
			<dd>
~fetchは、~HTTP~cache内に要請に合致する応答が在れば，それが非新鮮であっても利用する。
応答が無ければ、通常の要請を作成して，対する応答で~HTTP~cacheを更新する。
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>`only-if-cached^l</dt>
			<dd>
~fetchは、~HTTP~cache内に要請に合致する応答が在れば，それが非新鮮であっても利用する。
応答が無ければ、~network~errorを返す。
（利用できるのは、［
`要請$の`~mode$rq ~EQ `same-origin^l
］の場合に限られる。
~cacheされた~redirectは、［
`要請$の`~redirect~mode$rq ~EQ `follow^l
］~AND［
どの~redirectも`要請$の`~mode$rqに違反しない
］と見做す下で，追従することになる。）
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it returns a network error. (Can only be used when request’s mode is "same-origin". Any cached redirects will be followed assuming request’s redirect mode is "follow" and the redirects do not violate request’s mode.)
</dd>
		</dl>

<p>
`~cache~mode$rqが `default^l の場合、`~header~list$rq内に［
次のいずれかを`名前に持つ~header$
］が在るならば，`~fetch$により `no-store^l に設定される
⇒＃
`If-Modified-Since$h,
`If-None-Match$h,
`If-Unmodified-Since$h,
`If-Match$h,
`If-Range$h
◎
If header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache mode to "no-store" if it is "default".
</p>
	</dd>

	<dt>`~redirect~mode@rq（ `follow^l ）</dt>
	<dd>
次のいずれか
⇒＃
`follow^l,
`error^l,
`manual^l
◎
A request has an associated redirect mode, which is "follow", "error", or "manual". Unless stated otherwise, it is "follow".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
</p>
		<dl>
			<dt>`follow^l</dt>
			<dd>
資源の~fetch時に被ったすべての~redirectに追従する。
◎
Follow all redirects incurred when fetching a resource.
</dd>

			<dt>`error^l</dt>
			<dd>
要請が~redirectに出くわしたときには、`~network~error$を返す。
◎
Return a network error when a request is met with a redirect.
</dd>

			<dt>`manual^l</dt>
			<dd>
要請が~redirectに出くわしたときには、~swが当の~redirectを~offlineで再生し直すのを許容するため，`不透明~redirect絞込み応答$を検索取得する。
他の場合、`~HTTP~redirectの不可分な取扱い$に違反しないよう，応答は`~network~error$と判別-不能になる。
◎
Retrieves an opaque-redirect filtered response when a request is met with a redirect, to allow a service worker to replay the redirect offline. The response is otherwise indistinguishable from a network error, to not violate atomic HTTP redirect handling.
</dd>
		</dl>
	</dd>

	<dt>`完全性~metadata@rq（空~文字列）</dt>
	<dd>
文字列。
◎
A request has associated integrity metadata (a string). Unless stated otherwise, it is the empty string.
</dd>
	<dd class="trans-note">【
~fetchした結果の~dataが，要請する側が期待する~dataと正確に一致するかどうか検証するための~data。
`SRI$r
】</dd>

	<dt>`暗号用~nonce~metadata@rq（空~文字列）</dt>
	<dd>
文字列。
◎
A request has associated cryptographic nonce metadata (a string). Unless stated otherwise, it is the empty string.
</dd>

	<dt>`構文解析器~metadata@rq（空~文字列）</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`parser-inserted^l,
`not-parser-inserted^l
◎
A request has associated parser metadata which is the empty string, "parser-inserted", or "not-parser-inserted". Unless otherwise stated, it is the empty string.
</dd>
	<dd class="trans-note">【
例えば，~scriptが<a href="~HEscripting#parser-inserted">構文解析-時に挿入されたものかどうか</a>を表す。
】</dd>
	<dd class="note">注記：
`要請$の［
`暗号用~nonce~metadata$rq,
`構文解析器~metadata$rq
］は，一般に、`要請$を作成する責を負う~HTML要素~上の各種［
属性, ~flag
］から拡充される【~HTMLの`~script~fetch~options$も見よ】。
これらは、~CSPの各種~algoにおいて，所与の文脈の下で［
要請, または応答
］を阻止するかどうか決定するために利用される。
`CSP$r
◎
A request’s cryptographic nonce metadata and parser metadata are generally populated from attributes and flags on the HTML element responsible for creating a request. They are used by various algorithms in Content Security Policy to determine whether requests or responses are to be blocked in a given context. [CSP]
</dd>

	<dt>`~reload~navi~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated reload-navigation flag. Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
この~flagは、~HTMLの`~navigate~algo$により排他的に利用される。
`HTML$r
◎
This flag is for exclusive use by HTML’s navigate algorithm. [HTML]
</dd>

	<dt>`履歴~navi~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated history-navigation flag. Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
この~flagは、~HTMLの`~navigate~algo$により排他的に利用される。
`HTML$r
◎
This flag is for exclusive use by HTML’s navigate algorithm. [HTML]
</dd>

	<dt>`~tainted生成元~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated tainted origin flag. Unless stated otherwise, it is unset.
</dd>

	<dt>`~URL~list@rq（ « `要請$の`~URL$rqの複製 » ）</dt>
	<dd>
1 個~以上の`~URL$からなる`~list$。
◎
A request has an associated URL list (a list of one or more URLs). Unless stated otherwise, it is a list containing a copy of request’s URL.
</dd>

	<dt>`現在の~URL@rq</dt>
	<dd>
`~URL~list$rq内の最後の`~URL$を指す。
◎
A request has an associated current URL. It is a pointer to the last URL in request’s URL list.
</dd>

	<dt>`~redirect数@rq（ 0 ）</dt>
	<dd>
負でない整数。
【~redirectが生じた回数】
◎
A request has an associated redirect count. Unless stated otherwise, it is zero.
</dd>

	<dt>`応答~tainting@rq（ `basic^l ）</dt>
	<dd>
次のいずれか
⇒＃
`basic^l,
`cors^l,
`opaque^l
◎
A request has an associated response tainting, which is "basic", "cors", or "opaque". Unless stated otherwise, it is "basic".
</dd>
	<dd class="trans-note">【
この要請に対する応答は、何に “~~染まる” か。
~security用の制限を与える（`絞込み応答$の種類として反映されることになる）。
】</dd>

	<dt>`~no-cache時に~cache制御~headerを改変しない~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated prevent no-cache cache-control header modification flag. Unless stated otherwise, it is unset.
</dd>

	<dt>`~done~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated done flag. Unless stated otherwise, it is unset.
</dd>

	<dt>`計時許容に失敗した~flag@rq（ ~F ）</dt>
	<dd>
真偽値。
◎
A request has an associated timing allow failed flag. Unless stated otherwise, it is unset.
</dd>
</dl>

<hr>

<p class="note">注記：
`要請$の次に挙げるものは、`~fetch$ ~algoの内部状態管理に利用される
⇒＃
`~tainted生成元~flag$rq,
`~URL~list$rq,
`現在の~URL$rq,
`~redirect数$rq,
`応答~tainting$rq,
`~done~flag$rq,
`計時許容に失敗した~flag$rq
◎
A request’s tainted origin flag, URL list, current URL, redirect count, response tainting, done flag, and timing allow failed flag are used as bookkeeping details by the fetch algorithm.
</p>

<hr>

<p>
`下位資源~要請@
とは、次のいずれかを`行先$rqとする`要請$である
⇒＃
`audio^l,
`audioworklet^l,
`font^l,
`image^l,
`manifest^l,
`paintworklet^l,
`script^l,
`style^l,
`track^l,
`video^l,
`xslt^l,
空~文字列
◎
A subresource request is a request whose destination is "audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", or the empty string.
</p>

<p>
`非~下位資源~要請@
とは、次のいずれかを`行先$rqとする`要請$である
⇒＃
`document^l,
`embed^l,
`frame^l,
`iframe^l,
`object^l,
`report^l,
`serviceworker^l,
`sharedworker^l,
`worker^l
◎
A non-subresource request is a request whose destination is "document", "embed", "frame", "iframe", "object", "report", "serviceworker", "sharedworker", or "worker".
</p>

<p class="trans-note">【
`下位資源~要請$ではないが、論理的な否定
— すべての要請のうち，下位資源~要請ではないもの —
でもないことに注意。
】</p>

<p>
`~navi要請@
とは、次を`行先$rqとする`要請$である
⇒＃
`document^l,
`embed^l,
`frame^l,
`iframe^l,
`object^l,
◎
A navigation request is a request whose destination is "document", "embed", "frame", "iframe", or "object".
</p>

<p class="note">注記：
これらの用語の用法については
<a href="~SW1#handle-fetch">~fetchを取扱う</a>
を見よ。
`SW$r
◎
See handle fetch for usage of these terms. [SW]
</p>

<hr>

<div class="algo">
<p>
`要請の生成元を直列化する@
ときは、所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
Serializing a request origin, given a request request, is to run these steps:
</p>
<ol>
	<li>
~IF［
%要請 の`~tainted生成元~flag$rq ~EQ ~T
］
⇒
~RET `null^l
◎
If request’s tainted origin flag is set, then return "null".
</li>
	<li>
~RET
`生成元を直列化する$( %要請 の`生成元$rq )
◎
Return request’s origin, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請の生成元を~byte直列化する@
ときは、所与の
( `要請$ %要請)
に対し，次の結果を返す
⇒
`同型に符号化する$( `要請の生成元を直列化する$( %要請 ) )
◎
Byte-serializing a request origin, given a request request, is to return the result of serializing a request origin with request, isomorphic encoded.
</p>
</div>

<hr>

<div class="algo">
<p>
`要請を~cloneする@
ときは、所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
To clone a request request, run these steps:
</p>
<ol>
	<li>
%新~要請 ~LET
%要請 の`本体$rqを除いた部分の複製
◎
Let newRequest be a copy of request, except for its body.
</li>
	<li>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］
⇒
%新~要請 の`本体$rq ~SET `本体を~cloneする$( %要請 の`本体$rq )
◎
If request’s body is non-null, set newRequest’s body to the result of cloning request’s body.
</li>
	<li>
~RET %新~要請
◎
Return newRequest.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`要請~用の本体を伝送する@
ときは、所与の
( `要請$ %要請 )
に対し，次を走らす：
◎
To transmit body for a request request, run these steps:
</p>
<ol>
	<li>
%本体 ~LET %要請 の`本体$rq
◎
Let body be request’s body.
</li>
	<li>
<p>
~IF［
%本体 ~EQ ~NULL
］：
</p>
		<ol>
			<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`要請の本体終端を処理する$( %要請 )
</li>
			<li>
~RET
</li>
		</ol>
◎
If body is null, then queue a fetch task on request to process request end-of-body for request and abort these steps.
</li>
	<li>
<p>
%読取器 ~LET %本体 の`~stream$bdから`読取器を取得する$RS()
◎
Let reader be the result of getting a reader from body’s stream.
</p>

<p class="note">注記：
この演算は例外を投出し得ない。
◎
This operation cannot throw an exception.
</p>
	</li>
	<li>
`本体を伝送する~loop$( %要請, %本体, %読取器 )
◎
Perform the transmit-body loop given request, body, and reader.
</li>
</ol>
</div>

<div class="algo">
<p>
`本体を伝送する~loop@
は、所与の
( %要請, %本体, %読取器 )
に対し：
◎
To perform the transmit-body loop given request, body, and reader:
</p>
<ol>
	<li>
<p>
%読取n要請 ~LET 次に挙げる`~item$sctを伴う，`読取n要請$：
◎
Let readRequest be the following read request:
</p>
		<ul>
			<li>
<p>
`~chunk手続き$は、所与の
( %~chunk )
に対し：
◎
chunk steps, given chunk
</p>
				<ol>
					<li>
~IF［
進行中の~fetchは`終了され$た
］
⇒
~RET
◎
If the ongoing fetch is terminated, then abort these steps.
</li>
					<li>
~IF［
%~chunk は `Uint8Array$I ~objでない
］
⇒＃
進行中の~fetchを`終了させる$()；
~RET
◎
If chunk is not a Uint8Array object, terminate the ongoing fetch and abort these steps.
</li>
					<li>
%~byte列 ~LET 当の `Uint8Array$I ~objが表現している`~byte列$
◎
Let bs be the byte sequence represented by the Uint8Array object.
</li>
					<li>
<p>
この段は`並列的$に走らす：
◎
In parallel:
</p>
						<ol>
							<li>
<p>
%~byte列 を伝送する
— 1 個 以上の~byteが伝送される度に：
◎
Transmit bs. Whenever one or more bytes are transmitted,＼
</p>
								<ol>
									<li>
%本体 の`伝送-済み~byte数$bd ~INCBY 伝送された~byte数
◎
increase body’s transmitted bytes by the number of transmitted bytes and＼
</li>
									<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`要請の本体を処理する$( %要請 )
◎
queue a fetch task on request to process request body for request.
</li>
								</ol>

<p class="note">注記：
%~byte列 が全部的に伝送されるまでは、この段に留まり続ける。
◎
This step blocks until bs is fully transmitted.
</p>
							</li>
							<li>
~IF［
進行中の~fetchは`終了され$ていない
］
⇒
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`本体を伝送する~loop$( %要請, %本体, %読取器 )
◎
If the ongoing fetch is not terminated, then queue a fetch task on request to perform the transmit-body loop given request, body, and reader.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
`~close手続き$は：
◎
close steps
</p>
				<ol>
					<li>
~IF［
進行中の~fetchは`終了され$た
］
⇒
~RET
◎
If the ongoing fetch is terminated, then abort these steps.
</li>
					<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`要請の本体終端を処理する$( %要請 )
◎
Queue a fetch task on request to process request end-of-body for request.
</li>
				</ol>
			</li>
			<li>
<p>
`~error手続き$は、所与の
( %~error )
に対し：
◎
error steps, given e
</p>
				<ol>
					<li>
~IF［
進行中の~fetchは`終了され$た
］
⇒
~RET
◎
If the ongoing fetch is terminated, then abort these steps.
</li>
					<li>
~IF［
%~error は `AbortError$E 例外である
］
⇒
進行中の~fetchを`終了させる$( `中止する^i )
◎
If e is an "AbortError" DOMException, then terminate the ongoing fetch with the aborted flag set.
</li>
					<li>
~ELSE
⇒
進行中の~fetchを`終了させる$()
◎
Otherwise, terminate the ongoing fetch.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
%本体 の`~stream$bdから`~chunkを読取る$RS( %読取器, %読取n要請 )
◎
Read a chunk from body’s stream with reader given readRequest.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`範囲~headerを追加する@
ときは、所与の
( `要請$ %要請, 整数 %先頭, 整数 %末尾 （省略時は ε ）)
に対し，次を走らす：
◎
To add a range header to a request request, with an integer first, and an optional integer last, run these steps:
</p>
<ol>
	<li>
%範囲~値 ~LET `bytes ^bl
◎
Let rangeValue be `bytes `.
</li>
	<li>
%範囲~値 に次の結果を付加する
⇒
`同型に符号化する$( `整数を直列化する$( %先頭 ) )
◎
Serialize and isomorphic encode first, and append the result to rangeValue.
</li>
	<li>
%範囲~値 に `2D^X （ `-^bl ）を付加する
◎
Append 0x2D (-) to rangeValue.
</li>
	<li>
~IF［
%末尾 ~NEQ ε
］
⇒
%範囲~値 に次の結果を付加する
⇒
`同型に符号化する$( `整数を直列化する$( %末尾 ) )
◎
If last is given, then serialize and isomorphic encode it, and append the result to rangeValue.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Range$h / %範囲~値
)
◎
Append `Range`/rangeValue to request’s header list.
</li>
</ol>

<p class="note">注記：
範囲~headerが表す~byte範囲は、先頭, 末尾も含む。
( %先頭, %末尾 ) ~EQ ( 0, 500 ) ならば 501 個の~byteからなる範囲になる。
◎
A range header denotes an inclusive byte range. There a range header where first is 0 and last is 500, is a range of 501 bytes.
</p>

<p class="note">注記：
複数の応答を 1 個の論理的な資源に組合せる特能は、歴史的に~security~bugの源になる。
部分的~応答に対処する特能に対する~security考査を探されたし。
◎
Features that combine multiple responses into one logical resource are historically a source of security bugs. Please seek security review for features that deal with partial responses.
</p>
</div>

<hr>

<div class="algo">
<p>
`応答~URLを報告-用に直列化する@
ときは、所与の
( `応答$ %応答 )
に対し，次を走らす：
◎
To serialize a response URL for reporting, given a response response, run these steps:
</p>
<ol>
	<li>
%応答 の`~URL~list$rqは`空$でない
◎
Assert: response’s URL list is not empty.
</li>
	<li>
<p>
%~url ~LET %応答 の`~URL~list$rq[ 0 ] の複製
◎
Let url be a copy of response’s URL list’s first element.
</p>

<p class="note">注記：
~redirect~targetについての情報が漏洩するのを避けるため、これは， %応答 の`~URL$rqではない（
<a href="~CSP3#security-violation-reports">~CSP報告-用の類似な考慮点</a>
も見よ）。
`CSP$r
◎
This is not response’s URL in order to avoid leaking information about redirect targets (see similar considerations for CSP reporting too). [CSP]
</p>
	</li>
	<li>
`~URLの~usernameを設定する$( %~url, 空~文字列 )
◎
Set the username given url and the empty string.
</li>
	<li>
`~URLの~passwordを設定する$( %~url, 空~文字列 )
◎
Set the password given url and the empty string.
</li>
	<li>
~RET `~URLを直列化する$( %~url, `素片は除外する^i )
◎
Return the serialization of url with the exclude fragment flag set.
</li>
</ol>
</div>

			</section>
			<section id="responses">
<h3 title="Responses">2.2.6. 応答</h3>

<p>
`応答@
（ `response^en ）とは、`~fetch$の結果である。
`応答$は、時間とともに発展していくものであり，その各種~fieldすべてが直ぐに可用になるわけではない。
◎
The result of fetch is a response. A response evolves over time. That is, not all its fields are available straight away.
</p>

<p>
`応答$には、以下に挙げるものが結付けられる。
各~項には，それがとり得る値の種類を示す。
他が言明されない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>`種別@rs（ `default^l ）</dt>
	<dd>
次のいずれか
⇒＃
`basic^l,
`cors^l,
`default^l,
`error^l,
`opaque^l,
`opaqueredirect^l
◎
A response has an associated type which is "basic", "cors", "default", "error", "opaque", or "opaqueredirect". Unless stated otherwise, it is "default".
</dd>

	<dt>`中止~flag@rs（ ~F ）</dt>
	<dd>
真偽値。
◎
A response can have an associated aborted flag, which is initially unset.
</dd>
	<dd class="note">注記：
これは、 ~T ならば［
開発者／末端利用者
］が要請を意図的に中止したことを指示する。
◎
This indicates that the request was intentionally aborted by the developer or end-user.
</dd>

	<dt>`~URL@rs</dt>
	<dd>
`~URL~list$rsの最後の`応答~URL$を指す
— `~URL~list$rsが空ならば ~NULL とする。
◎
A response has an associated URL. It is a pointer to the last response URL in response’s URL list and null if response’s URL list is the empty list.
</dd>

	<dt>`~URL~list@rs（ 空~list ）</dt>
	<dd>
0 個~以上の`応答~URL$からなる`~list$。
◎
A response has an associated URL list (a list of zero or more response URLs). Unless stated otherwise, it is the empty list.
</dd>
	<dd class="note">注記：
最後の`応答~URL$を除いて，この~listは~scriptには公開されない。
そうすると
`~HTTP~redirectの不可分な取扱い$に違反するので。
◎
Except for the last response URL, if any, a response’s URL list cannot be exposed to script. That would violate atomic HTTP redirect handling.
</dd>

	<dt>`状態s@rs（ `200$st ）</dt>
	<dd>
`状態s$。
◎
A response has an associated status, which is a status. Unless stated otherwise it is 200.
</dd>

	<dt>`状態s~message@rs（ 空`~byte列$ ）</dt>
	<dd>
`~byte列$。
◎
A response has an associated status message. Unless stated otherwise it is the empty byte sequence.
</dd>
	<dd class="note">注記：
HTTP/2 接続~越しの応答においては、その状態s~messageは，常に空~byte列になる
— HTTP/2 はそれを~supportしないので。
◎
Responses over an HTTP/2 connection will always have the empty byte sequence as status message as HTTP/2 does not support them.
</dd>
	<dd class="trans-note">【
HTTP/1.x の文脈では，応答の `reason-phrase$p を表現する。
】</dd>

	<dt>`~header~list@rs（空~list）</dt>
	<dd>
`~header~list$。
◎
A response has an associated header list (a header list). Unless stated otherwise it is empty.
</dd>

	<dt>`本体@rs（ ~NULL ）</dt>
	<dd>
~NULL または`本体$。
◎
A response has an associated body (null or a body). Unless stated otherwise it is null.
</dd>

	<dt>`~cache状態@rs（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`local^l
◎
A response has an associated cache state (the empty string or "local"). Unlesss stated otherwise, it is the empty string.
</dd>
	<dd class="note">注記：
これは もっぱら、~sw用途に意図される
`SW$r
◎
This is intended solely for usage by service workers. [SW]
</dd>

	<dt>`~CSP~list@rs（空~list）</dt>
	<dd>
`応答$用の`~CSP~obj$の~list。
`CSP$r
◎
A response has an associated CSP list, which is a list of Content Security Policy objects for the response. The list is empty unless otherwise specified. [CSP]
</dd>

	<dt>`~CORSに公開される~header名~list@rs（空~list）</dt>
	<dd>
0 個以上の`~header$の`名前$hdからなる~list。
◎
A response has an associated CORS-exposed header-name list (a list of zero or more header names). The list is empty unless otherwise specified.
</dd>
	<dd class="note">注記：
`応答$の`~CORSに公開される~header名~list$rsは、概して
`Access-Control-Expose-Headers$h ~headerから`値を抽出-$した結果に設定されることになる。
この~listは、`~CORS絞込み応答$において公開する~headerを決定するときに利用される。
◎
A response will typically get its CORS-exposed header-name list set by extracting header values from the `Access-Control-Expose-Headers` header. This list is used by a CORS filtered response to determine which headers to expose.
</dd>

	<dt>`範囲が要請された~flag@rs （ ~F ）</dt>
	<dd>
真偽値。
◎
A response has an associated range-requested flag, which is initially unset.
</dd>
	<dd class="note">注記：
これは、［
過去の範囲~付き要請からの部分的~応答が，範囲~要請を為していなかった~APIに供される
］ことを防止することを確保するために利用される。
この~flagの用途については、その攻撃の詳細な記述を見よ。
◎
This is used to ensure to prevent a partial response from an earlier ranged request being provided to an API that didn’t make a range request. See the flag’s usage for a detailed description of the attack.
</dd>

	<dt>`計時許容に合格した~flag@rs （ ~F ）</dt>
	<dd>
真偽値。
◎
A response has an associated timing allow passed flag, which is initially unset.
</dd>
	<dd class="note">注記：
これは、~fetchの~call元が，［
返された応答の~flagを調べて，~fetchされた資源~上で敏感な計時~dataは許容されるかどうか決定できるようにする
］ために利用される。
この~flagはまた，~redirectの応答~上では［
~redirect連鎖における直前の応答にて ~T
］ならば ~T に設定する必要があるので、この~flagは，要請の`計時許容に失敗した~flag$rqを利用して内部的に追跡される。
◎
This is used so that the caller to a fetch can determine if sensitive timing data is allowed on the resource fetched by looking at the flag of the response returned. Because the flag on the response of a redirect has to be set if it was set for previous responses in the redirect chain, this is also tracked internally using the request’s timing allow failed flag.
</dd>

	<dt>`~Location~header~URL@rs （ ~NULL †）</dt>
	<dd>
次のいずれか
⇒＃
~NULL,
`失敗^i,
`~URL$
◎
A response can have an associated location URL (null, failure, or a URL). Unless specified otherwise, response has no location URL.
</dd>
	<dd class="note">注記：
この概念は、~Fetchおよび~HTMLの`~navigate~algo$††にて，~redirectを取扱うために利用される。
それは、一度だけ, かつ一貫するように `Location$h ~headerから`値を抽出-$することを確保する。
`HTML$r
◎
This concept is used for redirect handling in Fetch and in HTML’s navigate algorithm. It ensures `Location` has its value extracted consistently and only once. [HTML]
</dd>
	<dd class="trans-note">【
“~Location~header~URL” は原文では `location URL^en であるが、
`Location^h ~headerに基づくことを明確化するため，冗長に記すことにする。
】【†
原文では，既定では
“`has no location URL^en”
（ “~Location~header~URLは無い” ）という句として記されているが、暗に ~NULL を指していると見受けられる。
“無い” を表現する ~NULL と異なる値をとることも~~考えられなくはないが。
】【††
特に、その中で`~navigate~fetchを処理する$とき。
】</dd>
</dl>

<hr>

<p>
次を満たす`応答$は、
`中止~network~error@
と呼ばれる
⇒
［
`~network~error$である
］~AND［
`中止~flag$rs ~EQ ~T
］
◎
A response whose type is "error" and aborted flag is set is known as an aborted network error.
</p>

<p>
次を満たす`応答$は、
`~network~error@
と呼ばれる
⇒
`種別$rs ~EQ `error^l
◎
A response whose type is "error" is known as a network error.
</p>

<div class="p">
<p>
`~network~error$は，常に次をすべて満たすようにされる：
</p>

<ul ><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空~byte列
</li><li>`~header~list$rsは空である
</li><li>`本体$rs ~EQ ~NULL
</li></ul>

◎
A network error is a response whose status is always 0, status message is always the empty byte sequence, header list is always empty, and body is always null.
</div>

<hr>

<p>
`絞込み応答@
とは、`~network~error$でない ある`応答$を，その一部分に制限して公開する~viewである。
その応答を指して，`絞込み応答$の
`内部~応答@
という。
◎
A filtered response is a limited view on a response that is not a network error. This response is referred to as the filtered response’s associated internal response.
</p>

<p class="note">注記：
`~fetch$ ~algoは、~APIが不用意に情報を漏洩させなくするために，その種の~viewを返す。
旧来の理由から，情報を公開させる必要がある場合
— 例：画像~dataを復号器に渡すためなど —
は、結付けられている`内部~応答$を利用できる。
内部~応答は、仕様の内部~algoからのみ “~access可能” であり，決して`絞込み応答$自身にはならない。
◎
The fetch algorithm returns such a view to ensure APIs do not accidentally leak information. If the information needs to be exposed for legacy reasons, e.g., to feed image data to a decoder, the associated internal response can be used, which is only "accessible" to internal specification algorithms and is never a filtered response itself.
</p>

<div class="p">
<p>
`基本~絞込み応答@
とは、次をすべて満たすようにされた`絞込み応答$である：
</p>
<ul>
	<li>
`種別$rs ~EQ `basic^l
</li>
	<li>
`~header~list$rsは、`内部~応答$の`~header~list$rsから 次に該当する`~header$は除外したものからなる
⇒
`名前$hdは `禁止~応答~header名$である
</li>
</ul>
◎
A basic filtered response is a filtered response whose type is "basic" and header list excludes any headers in internal response’s header list whose name is a forbidden response-header name.
</div>

<div class="p">
<p>
`~CORS絞込み応答@
とは、次をすべて満たすようにされた`絞込み応答$である：
</p>
<ul>
	<li>
`種別$rs ~EQ `cors^l
</li>
	<li>
`~header~list$rsは、`内部~応答$の`~CORSに公開される~header名~list$rsから 次に該当する`~header$は除外したものからなる
⇒
`名前$hdは`~CORS安全とされる応答~header名$でない
</li>
</ul>
◎
A CORS filtered response is a filtered response whose type is "cors" and header list excludes any headers in internal response’s header list whose name is not a CORS-safelisted response-header name, given internal response’s CORS-exposed header-name list.
</div>

<div>
<p>
`不透明な絞込み応答@
とは、次をすべて満たすようにされた`絞込み応答$である：
</p>

<ul ><li>`種別$rs ~EQ `opaque^l
</li><li>`~URL~list$rsは空である
</li><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空~byte列
</li><li>`~header~list$rsは空である
</li><li>`本体$rs ~EQ ~NULL
</li></ul>

◎
An opaque filtered response is a filtered response whose type is "opaque", URL list is the empty list, status is 0, status message is the empty byte sequence, header list is empty, and body is null.
</div>

<div>
<p>
`不透明~redirect絞込み応答@
とは、次をすべて満たすようにされた`絞込み応答$である：
</p>

<ul ><li>`種別$rs ~EQ `opaqueredirect^l
</li><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空~byte列
</li><li>`~header~list$rsは空である
</li><li>`本体$rs ~EQ ~NULL
</li></ul>

◎
An opaque-redirect filtered response is a filtered response whose type is "opaqueredirect", status is 0, status message is the empty byte sequence, header list is empty, and body is null.
</div>

<div class="note">注記：

<p>
`不透明~redirect絞込み応答$に対しては、~redirectは後続しないので，`~URL~list$rsが公開されても無害である。
◎
Exposing the URL list for opaque-redirect filtered responses is harmless since no redirects are followed.
</p>

<p>
言い換えれば、［
`不透明な絞込み応答$, `不透明~redirect絞込み応答$
］と`~network~error$とは，ほとんど判別できない。
新たな~APIを導入する際には、情報を漏洩させなくするため，仕様の内部~algoには
`内部~応答$を利用しないこと。
◎
In other words, an opaque filtered response and an opaque-redirect filtered response are nearly indistinguishable from a network error. When introducing new APIs, do not use the internal response for internal specification algorithms as that will leak information.
</p>

<p>
これはまた、 `response.ok$m などの~JS~APIが返す結果は，およそ役に立たないことを意味する。
◎
This also means that JavaScript APIs, such as response.ok, will return rather useless results.
</p>

</div>

<div class="algo">
<p>
`応答を~cloneする@
ときは、所与の
( `応答$ %応答 )
に対し，次を走らす：
◎
To clone a response response, run these steps:
</p>
<ol>
	<li>
~IF［
%応答 は`絞込み応答$である
］
⇒
~RET 次のようにされた絞込み応答
⇒＃
`内部~応答$ ~SET `応答を~cloneする$( %応答 の`内部~応答$ )；
他の部分は %応答 と同一
◎
If response is a filtered response, then return a new identical filtered response whose internal response is a clone of response’s internal response.
</li>
	<li>
%新~応答 ~LET %応答 の`本体$rsを除いた部分の複製
◎
Let newResponse be a copy of response, except for its body.
</li>
	<li>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］
⇒
%新~応答 の`本体$rs ~SET `本体を~cloneする$( %応答 の`本体$rs )
◎
If response’s body is non-null, then set newResponse’s body to the result of cloning response’s body.
</li>
	<li>
~RET %新~応答
◎
Return newResponse.
</li>
</ol>
</div>


<p>
`新鮮な応答@
とは、次を満たす`応答$である
⇒
`現在の齢$は`鮮度~維持期間$を過ぎていない
◎
A fresh response is a response whose current age is within its freshness lifetime.
</p>

<p>
`~stale-while-revalidate応答@
とは、次を満たす`応答$である
⇒
［
`新鮮な応答$でない
］~AND［
`現在の齢$は`~stale-while-revalidate維持期間$を過ぎていない
］
◎
A stale-while-revalidate response is a response that is not a fresh response and whose current age is within the stale-while-revalidate lifetime.
</p>

<p class="trans-note">【
~stale-while-revalidate `Cache-Control$h 指令を伴わない応答は、該当し得ないことになる（維持期間は “無い” ので）。
】</p>

<p>
`非新鮮な応答@
とは、次を満たす`応答$である
⇒
［
`新鮮な応答$でない
］~AND［
`~stale-while-revalidate応答$でない
］
◎
A stale response is a response that is not a fresh response or a stale-while-revalidate response.
</p>

<p class="trans-note">【
<a href="~HTTPcache#stale">~HTTPが定義する非新鮮</a>
（新鮮の否定）より狭義になる。
】</p>

			</section>
			<section id="miscellaneous">
<h4 title="Miscellaneous">2.2.7. その他</h4>

<div class="p">
<p>
`行先の素@
（ `potential destination^en ）は、次のいずれかである：
</p>

<ul ><li>`fetch^l
</li><li>空~文字列でない`行先$rq
</li></ul>

◎
A potential destination is "fetch" or a destination which is not the empty string.
</div>

<div class="algo">
<p>
`行先の素$ %行先の素 を
`行先に翻訳する@
ときは、次を走らす：
◎
To translate a potential destination potentialDestination, run these steps:
</p>
<ol>
	<li>
~IF［
%行先の素 ~EQ `fetch^l
］
⇒
~RET 空~文字列
◎
If potentialDestination is "fetch", then return the empty string.
</li>
	<li>
~Assert：
%行先の素 は`行先$rqである
◎
Assert: potentialDestination is a destination.
</li>
	<li>
~RET %行先の素
◎
Return potentialDestination.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="authentication-entries">
<h3 title="Authentication entries">2.3. 認証~entry</h3>

<p>
`認証~entry@
／
`~proxy認証~entry@
は、［
~HTTP認証／~HTTP~proxy認証
］に利用される［
~username, ~password, ~realm†
］の組であり，1 つ以上の`要請$に結付けられる。
【† ~HTTP仕様の<a href="~HTTPrq#realm">~realm</a> 】
◎
An authentication entry and a proxy-authentication entry are tuples of username, password, and realm, used for HTTP authentication and HTTP proxy authentication, and associated with one or more requests.
</p>

<p>
~UAは、［
~HTTP~cookieと, それに類する追跡~機能性
］が一緒に消去されることを，許容するベキである。
◎
User agents should allow both to be cleared together with HTTP cookies and similar tracking functionality.
</p>

<p>
更なる詳細は~HTTPにて定義される。
`HTTP$r
`HTTP-SEMANTICS$r
`HTTP-COND$r
`HTTP-CACHING$r
`HTTP-AUTH$r
◎
Further details are defined by HTTP. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</p>
		</section>
		<section id="fetch-groups">
<h3 title="Fetch groups">2.4. ~fetch~group</h3>

<p>
各 `環境~設定群~obj$には、
`~fetch~group@
が結付けられる。
◎
Each environment settings object has an associated fetch group.
</p>

<p>
各`~fetch~group$は、いくつかの
`~fetch記録@
からなる，有順序~listを保持する。
◎
A fetch group holds an ordered list of fetch records.
</p>

<p>
各`~fetch記録$には、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`要請@fg</dt>
	<dd>
`要請$。
◎
A fetch record has an associated request (a request).
</dd>

	<dt>`~fetch@fg</dt>
	<dd>
`~fetch$~algoの~instance,
または ~NULL 。
◎
A fetch record has an associated fetch (a fetch algorithm or null).
</dd>

</dl>

<hr>

<div class="algo">
<p>
`~fetch~group$ %G が
`終了され@fg
たときは、次を走らす
⇒
%G 内の
~EACH( `~fetch記録$ %記録 )
に対し
⇒
~IF［
%記録 の`要請$fgは［［
`~done~flag$rq ~EQ ~F
］~OR［
`~keepalive~flag$rq ~EQ ~F
］］を満たす
］
⇒
%記録 の`~fetch$fgを`終了させる$()
◎
When a fetch group is terminated, for each associated fetch record whose request’s done flag or keepalive flag is unset, terminate the fetch record’s fetch.
</p>
</div>

		</section>
		<section id="connections">
<h3 title="Connections">2.5. 接続</h3>

<p>
各~UAには
`接続~pool@
が結付けられる。
`接続~pool$は、
0 個以上の
`接続@
からなる。
各 `接続$は、
( `key^cN（`~network区分~key$）, `origin^cN（`生成元$）, `credentials^cN（真偽値） )
が成す組で識別される。
◎
A user agent has an associated connection pool. A connection pool consists of zero or more connections. Each connection is identified by a key (a network partition key), an origin (an origin), and credentials (a boolean).
</p>

<div class="algo">
<p>
`接続を得する@
ときは、所与の
( %~key, %生成元, %資格証 )
に対し，次を走らす：
◎
To obtain a connection, given a key, origin, and credentials, run these steps:
</p>
<ol>
	<li>
~IF［
~UAの`接続~pool$内に［
( `key^cN, `origin^cN, `credentials^cN ) ~EQ ( %~key, %生成元, %資格証 )
］を満たす`接続$はある
］
⇒
~RET その`接続$
◎
If the user agent’s connection pool contains a connection whose key is key, origin is origin, and credentials is credentials, then return that connection.
</li>
	<li>
%接続 ~LET ~NULL
◎
Let connection be null.
</li>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
%接続 ~SET %生成元 への~HTTP接続を確立しようと~~試みた結果
`HTTP$r
`HTTP-SEMANTICS$r
`HTTP-COND$r
`HTTP-CACHING$r
`HTTP-AUTH$r
`TLS$r
— ただし
⇒
［
%資格証 ~EQ ~F
］の場合は、~TLS~client証明書は`送信しない^emこと
◎
Set connection to the result of establishing an HTTP connection to origin. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH] [TLS]
• If credentials is false, then do not send a TLS client certificate.
</li>
			<li>
~IF［
接続の確立ngに成功しなかった（例： DNS／TCP／TLS の~error）
］
⇒
~RET `失敗^i
◎
If establishing a connection does not succeed (e.g., a DNS, TCP, or TLS error), then return failure.
</li>
		</ol>
	</li>
	<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
</p>
		<ol>
			<li>
~IF［
%接続 ~NEQ ~NULL
］
⇒
%接続 を~closeする
◎
If connection is not null, then close connection.
</li>
			<li>
~RET `失敗^i
◎
Return failure.
</li>
		</ol>
	</li>
	<li>
~UAの`接続~pool$に，次のようにされた %接続 を追加する
⇒
( `key^cN, `origin^cN, `credentials^cN ) ~SET ( %~key, %生成元, %資格証 )
◎
Add connection to the user agent’s connection pool with key being key, origin being origin, and credentials being credentials.
</li>
	<li>
~RET %接続
◎
Return connection.
</li>
</ol>

<p class="note">注記：
これは，意図的にやや曖昧にされている
— 細かい点で，まだ発展し続けているので。
これを述べることは、
`link rel=preconnect^e
による特能を説明する助けになり、また，`接続$は `credentials^cN 別に分けられることを明瞭に~~規定する。
後者は、例えば~TLS~session識別子が［
`credentials^cN ~EQ ~F の`接続$
］と［
~EQ ~T のそれ
］とにまたがって再利用されないことを明確化する。
◎
This is intentionally a little vague as the finer points are still evolving. Describing this helps explain the &lt;link rel=preconnect&gt; feature and clearly stipulates that connections are keyed on credentials. The latter clarifies that e.g., TLS session identifiers are not reused across connections whose credentials are false with connections whose credentials are true.
</p>
【！ See https://github.com/whatwg/fetch/issues/114#issuecomment-143500095 for when we make WebSocket saner 】
</div>

		</section>
		<section id="network-partition-keys">
<h3 title="Network partition keys">2.6. ~network区分~key</h3>

<p>
`~network区分~key@
は、次の 2 つからなる~tupleである
⇒
( `~site$, ~NULL または`実装定義$な値 )
◎
A network partition key is a tuple consisting of a site and null or an implementation-defined value.
</p>

<div class="algo">
<p>
`~network区分~keyを決定する@
ときは、所与の
( %要請 )
に対し，次の手続きを走らす：
◎
To determine the network partition key, given request, run these steps:
</p>
<ol>
	<li>
%~top-level生成元 ~LET ~NULL
◎
Let topLevelOrigin be null.
</li>
	<li>
<p>
~IF［
%要請 の`予約-済み~client$rq ~NEQ ~NULL
］：
◎
If request’s reserved client is non-null, then:
</p>
		<ol>
			<li>
%~top-level生成元 ~SET %要請 の`予約-済み~client$rqの`~top-level生成元$enV
◎
Set topLevelOrigin to request’s reserved client’s top-level origin.
</li>
			<li>
<p>
~IF［
%~top-level生成元 ~EQ ~NULL
］
⇒
%~top-level生成元 ~SET %要請 の`予約-済み~client$rqの`~top-level作成時の~URL$enVの`生成元$url
◎
If topLevelOrigin is null, then set topLevelOrigin to request’s reserved client’s top-level creation URL’s origin.
</p>

<p class="note">注記：
これが起こるのは、~top-level~naviに限られる。
◎
This happens for top-level navigations only.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELIF［
%要請 の`~client$rq ~NEQ ~NULL
］
⇒
%~top-level生成元 ~SET %要請 の`~client$rqの`~top-level生成元$enV
◎
Otherwise, if request’s client is non-null, set topLevelOrigin to request’s client’s top-level origin.
</li>
	<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
	<li>
~Assert：
%~top-level生成元 は`生成元$である
◎
Assert: topLevelOrigin is an origin.
</li>
	<li>
%~top-level~site ~LET `~siteを得する$( %~top-level生成元 )
◎
Let topLevelSite be the result of obtaining a site, given topLevelOrigin.
</li>
	<li>
<p>
%第二~key ~LET ~NULL または`実装定義$な値
◎
Let secondKey be null or an implementation-defined value.
</p>

<p class="XXX">
第二~keyは、意図的に少し曖昧にされている
— より精緻な点で、依然として発展しているので。
<a href="https://github.com/whatwg/fetch/issues/1035">課題 #1035</a>
を見よ。
◎
The second key is intentionally a little vague as the finer points are still evolving. See issue #1035.
</p>
	<li>
~RET ( %~top-level~site, %第二~key )
◎
Return (topLevelSite, secondKey).
</li>
</ol>
</div>

		</section>
		<section id="http-cache-partitions">
<h3 title="HTTP cache partitions">2.7. ~HTTP~cache区分</h3>

<div class="algo">
<p>
`~HTTP~cache区分を決定する@
ときは、所与の
( %要請 )
に対し，次の手続きを走らす：
◎
To determine the HTTP cache partition, given request, run these steps:
</p>
<ol>
	<li>
%~key ~LET `~network区分~keyを決定する$( %要請 )
◎
Let key be the result of determining the network partition key given request.
</li>
	<li>
~IF［
%~key ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If key is null, then return null.
</li>
	<li>
~RET %~key に結付けられている一意な~HTTP~cache
`HTTP-CACHING$r
◎
Return the unique HTTP cache associated with key. [HTTP-CACHING]
</li>
</ol>
</div>

		</section>
		<section id="port-blocking">
<h3 title="Port blocking">2.8. ~portの阻止-法</h3>

<div class="algo">
<p>
`要請$ %要請 の
`~fetchingは，不良~portに因り阻止されるべきか？@
どうか決定するときは、次を走らす：
◎
To determine whether fetching a request request should be blocked due to a bad port, run these steps:
</p>
<ol>
	<li>
%~url ~LET %要請 の`現在の~URL$rq
◎
Let url be request’s current URL.
</li>
	<li>
%~scheme ~LET %~url の`~scheme$url
◎
Let scheme be url’s scheme.
</li>
	<li>
%~port ~LET %~url の`~port$url
◎
Let port be url’s port.
</li>
	<li>
~IF［
%~scheme ~EQ `ftp^l
］~AND［
%~port ~IN { 20, 21 }
］
⇒
~RET `許容される^i
◎
If scheme is "ftp" and port is 20 or 21, then return allowed.
</li>
	<li>
~IF［
%~scheme は`~network~scheme$である
］~AND［
%~port は`不良~port$である
］
⇒
~RET `阻止される^i
◎
Otherwise, if scheme is a network scheme and port is a bad port, then return blocked.
</li>
	<li>
~RET `許容される^i
◎
Return allowed.
</li>
</ol>
</div>

<p>
次の表の一列目に挙げられる`~port$urlは、
`不良~port@
であるとされる：
◎
A port is a bad port if it is listed in the first column of the following table.
</p>

<div style="column-width:12em; column-gap:1em;">
<table><thead><tr><th>~port
<th>代表的な~service
</thead>

<tbody><tr><td>1<td>tcpmux
<tr><td>7<td>echo
<tr><td>9<td>discard
<tr><td>11<td>systat
<tr><td>13<td>daytime
<tr><td>15<td>netstat
<tr><td>17<td>qotd
<tr><td>19<td>chargen
<tr><td>20<td>ftp-data
<tr><td>21<td>ftp
<tr><td>22<td>ssh
<tr><td>23<td>telnet
<tr><td>25<td>smtp
<tr><td>37<td>time
<tr><td>42<td>name
<tr><td>43<td>nicname
<tr><td>53<td>domain
<tr><td>77<td>priv-rjs
<tr><td>79<td>finger
<tr><td>87<td>ttylink
<tr><td>95<td>supdup
<tr><td>101<td>hostriame
<tr><td>102<td>iso-tsap
<tr><td>103<td>gppitnp
<tr><td>104<td>acr-nema
<tr><td>109<td>pop2
<tr><td>110<td>pop3
<tr><td>111<td>sunrpc
<tr><td>113<td>auth
<tr><td>115<td>sftp
<tr><td>117<td>uucp-path
<tr><td>119<td>nntp
<tr><td>123<td>ntp
<tr><td>135<td>loc-srv / epmap
<tr><td>139<td>netbios
<tr><td>143<td>imap2
<tr><td>179<td>bgp
<tr><td>389<td>ldap
<tr><td>427<td>afp (alternate)
<tr><td>465<td>smtp (alternate)
<tr><td>512<td>print / exec
<tr><td>513<td>login
<tr><td>514<td>shell
<tr><td>515<td>printer
<tr><td>526<td>tempo
<tr><td>530<td>courier
<tr><td>531<td>chat
<tr><td>532<td>netnews
<tr><td>540<td>uucp
<tr><td>548<td>afp
<tr><td>556<td>remotefs
<tr><td>563<td>nntp+ssl
<tr><td>587<td>smtp (outgoing)
<tr><td>601<td>syslog-conn
<tr><td>636<td>ldap+ssl
<tr><td>993<td>ldap+ssl
<tr><td>995<td>pop3+ssl
<tr><td>2049<td>nfs
<tr><td>3659<td>apple-sasl
<tr><td>4045<td>lockd
<tr><td>6000<td>x11
<tr><td>6665<td>irc (alternate)
<tr><td>6666<td>irc (alternate)
<tr><td>6667<td>irc (default)
<tr><td>6668<td>irc (alternate)
<tr><td>6669<td>irc (alternate)
<tr><td>6697<td>irc+tls
</tbody></table>
</div>

		</section>
		<section id="should-response-to-request-be-blocked-due-to-mime-type?">
<h3 title="Should response to request be blocked due to its MIME type?">2.9. %要請 に対する %応答 は，~MIME型に因り阻止されるべきか？</h3>

<p>
次の手続きを走らす：
◎
Run these steps:
</p>
<ol>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
<p>
~RET［
次がすべて満たされるならば `阻止される^i ／
~ELSE_ `許容される^i
］：
</p>
		<ul>
			<li>
%~MIME型 ~NEQ `失敗^i
</li>
			<li>
%要請 の`行先$rqは`~scriptに類する$
</li>
			<li>
［
%~MIME型 の`~essence$の頭部は［
`audio/^l, `image/^l, `video/^l
］いずれかに合致する
］~OR［
%~MIME型 の`~essence$ ~EQ `text/csv^l
］
</li>
		</ul>
◎
If mimeType is failure, then return allowed.
◎
Let destination be request’s destination.
◎
If destination is script-like and one of the following is true, then return blocked:
• mimeType’s essence starts with "audio/", "image/", or "video/".
• mimeType’s essence is "text/csv". 
◎
Return allowed.
</li>
</ol>

		</section>
		<section id="streams">
<h3 title="Streams">2.10. ~stream</h3>

<p class="note">注記：
この節は他の標準
— `Streams^cite 自身など —
の中へ統合されるかもしれない。
<a href="https://github.com/whatwg/streams/issues/372">whatwg/streams#372</a>
を見よ。
◎
This section might be integrated into other standards, such as Streams itself. See whatwg/streams#372.
</p>

<p>
この節では、 `ReadableStream$I ~obj用の共通な演算を定義する。
`STREAMS$r
◎
In this section, we define common operations for ReadableStream objects. [STREAMS]
</p>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream に
`~byte列を~enqueueする@RS
ときは、所与の
( `~byte列$ %~byte列 )
に対し：
◎
To enqueue bytes, given a byte sequence bytes and a ReadableStream object stream:
</p>
<ol>
	<li>
<p>
%~chunk ~LET ［
%~byte列 を包含している `ArrayBuffer$I
］を包装している `Uint8Array$I ~obj
⇒
【 `ArrayBuffer$I の作成-時に】例外が投出されたときは
⇒＃
%~stream を`~errorにする$RS( その例外 )；
~RET
◎
Let chunk be a Uint8Array object wrapping an ArrayBuffer object containing bytes.＼
If that threw an exception, error stream with that exception and return.
</p>
	</li>
	<li>
`ReadableStreamDefaultControllerEnqueue$A( %~stream.`readableStreamController^sl, %~chunk )
を~callする
◎
Call ReadableStreamDefaultControllerEnqueue(stream.[[readableStreamController]], chunk).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream を
`~closeする@RS
ときは、次を走らす：
◎
To close a ReadableStream object stream, run these steps:
</p>
<ol>
	<li>
`ReadableStreamDefaultControllerClose$A( %~stream.`readableStreamController^sl )
を~callする
◎
Call ReadableStreamDefaultControllerClose(stream.[[readableStreamController]]).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream を
`~errorにする@RS
ときは、所与の
( 所与の %事由 )
に対し，次を走らす：
◎
To error a ReadableStream object stream with given reason, run these steps:
</p>
<ol>
	<li>
`ReadableStreamDefaultControllerError$A( %~stream.`readableStreamController^sl, %事由 )
を~callする
◎
Call ReadableStreamDefaultControllerError(stream.[[readableStreamController]]), reason).
</li>
</ol>
</div>

<div class="algo">
<p>
`~ReadableStream~objを構築する@RS
ときは、所与の
( %highWaterMark, ~algo %sizeAlgorithm, 動作 %pull, 動作 %cancel )
（いずれも省略時は ε ）に対し，次を走らす：
◎
To construct a ReadableStream object optionally with a highWaterMark, sizeAlgorithm algorithm, pull action, and cancel action, run these steps:
</p>
<ol>
	<li>
%startAlgorithm ~LET `undefined^jv を返す~algo
◎
Let startAlgorithm be an algorithm that returns undefined.
</li>
	<li>
~IF［
%pull ~EQ ε
］
⇒
%pull ~SET 何もしない動作
◎
If pull is not given, then set it to an action that does nothing.
</li>
	<li>
<p>
%pullAlgorithm ~LET 次を走らす~algo：
◎
Let pullAlgorithm be an algorithm that runs these steps:
</p>
		<ol>
			<li>
%pull を走らす
◎
Run pull.
</li>
			<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
~IF［
%cancel ~EQ ε
］
⇒
%cancel ~SET 何もしない動作
◎
If cancel is not given, then set it to an action that does nothing.
</li>
	<li>
<p>
%cancelAlgorithm ~LET 次を走らす~algo：
◎
Let cancelAlgorithm be an algorithm that runs these steps:
</p>
		<ol>
			<li>
%cancel を走らす
◎
Run cancel.
</li>
			<li>
~RET `undefined^jv で`解決される~promise$
◎
Return a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
~IF［
%highWaterMark ~EQ ε
］
⇒
%highWaterMark ~SET `1^jv
◎
If highWaterMark is not given, then set it to 1.
</li>
	<li>
~IF［
%sizeAlgorithm ~EQ ε
］
⇒
%sizeAlgorithm ~SET `1^jv を返す~algo
◎
If sizeAlgorithm is not given, then set it to an algorithm that returns 1.
</li>
	<li>
~RET `CreateReadableStream$A( %startAlgorithm, %pullAlgorithm, %cancelAlgorithm, %highWaterMark, %sizeAlgorithm )
◎
Return CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm).
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream から
`読取器を取得する@RS
ときは、次を走らす：
◎
To get a reader from a ReadableStream object stream, run these steps:
</p>
<ol>
	<li>
%読取器 ~LET
`AcquireReadableStreamDefaultReader$A( %~stream )
を~callした結果
◎
Let reader be the result of calling AcquireReadableStreamDefaultReader(stream).
</li>
	<li>
~RET %読取器
◎
Return reader.
</li>
</ol>
</div>

<div class="algo">
<p>
`ReadableStream$I ~objから
`~chunkを読取る@RS
ときは、所与の
( %読取器, %読取n要請 )
に対し，次を走らす：
</p>
<ol>
	<li>
~RET `ReadableStreamDefaultReaderRead$A( %読取器, %読取n要請 )
</li>
</ol>
◎
To read a chunk from a ReadableStream object with reader, given a read request readRequest, perform ReadableStreamDefaultReaderRead(reader, readRequest).
</div>

<div class="algo">
<p>
`ReadableStream$I ~objから
`すべての~byte列を読取る@RS
ときは、所与の
( %読取器 )
に対し，次を走らす：
◎
To read all bytes from a ReadableStream object with reader, run these steps:
</p>
<ol>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET 空な~byte列
◎
Let bytes be an empty byte sequence.
</li>
	<li>
`読取n~loop$( %読取器, %~byte列, %~promise )
◎
Read-loop given reader, bytes, and promise.
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`読取n~loop@
は、所与の
( %読取器, %~byte列, %~promise )
に対し：
◎
To read-loop given reader, bytes, and promise:
</p>
<ol>
	<li>
<p>
%読取n要請 ~LET 次に挙げる`~item$sctを伴う，新たな`読取n要請$：
◎
Let readRequest be a new read request with the following items:
</p>
		<ul>
			<li>
<p>
`~chunk手続き$は、所与の
( %~chunk )
に対し：
◎
chunk steps, given chunk
</p>
				<ol>
					<li>
~Assert：
%~chunk は `Uint8Array$I ~objである。
◎
Assert: chunk is a Uint8Array object.
</li>
					<li>
%~byte列 に %~chunk を付加する
◎
Append chunk to bytes.
</li>
					<li>
`読取n~loop$( %読取器, %~byte列, %~promise )
◎
Read-loop given reader, bytes, and promise.
</li>
				</ol>
			</li>
			<li>
`~close手続き$は
⇒
%~byte列 で %~promise を`解決する$
◎
close steps
• Resolve promise with bytes.
</li>
			<li>
`~error手続き$は、所与の
( %~error )
に対し
⇒
%~error で %~promise を`却下する$
◎
error steps, given e
• Reject promise with e.
</li>
		</ul>
	</li>
	<li>
`ReadableStreamDefaultReaderRead$A( %読取器, %読取n要請 )
◎
Perform ReadableStreamDefaultReaderRead(reader, readRequest).
</li>
</ol>

<p class="note">注記：
読取器への~accessは排他的になるので、読取nの実際の仕組みは，
【~scriptからは】観測し得ない。
実装は、自身に都合よい より直接的な仕組みも利用できる。
◎
Because the reader grants exclusive access, the actual mechanism of how to read cannot be observed. Implementations could use more direct mechanism if convenient.
</p>

</div>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream を
`取消す@RS
ときは、所与の
( %事由 )
に対し
⇒
~RET `ReadableStreamCancel$A( %~stream, %事由 )
◎
To cancel a ReadableStream object stream with reason, return the result of calling ReadableStreamCancel(stream, reason).
</p>
</div>

<div class="algo">
<p>
`ReadableStream$I ~obj %~stream を
`二叉化する@RS
ときは、次を走らす：
◎
To tee a ReadableStream object stream, run these steps:
</p>
<ol>
	<li>
~RET
`ReadableStreamTee$A( %~stream, ~T )
を~callした結果
◎
Return the result of calling ReadableStreamTee(stream, true).
</li>
</ol>

<p class="trans-note">【
二叉化（ `tee^en ）
— 元の~streamを同じに挙動する二つの~streamに分岐する（
`<a href="https://ja.wikipedia.org/wiki/Tee_%28UNIX%29">tee コマンド</a>^,
T 字路の “tee”）。
】</p>
</div>

<p>
`ReadableStream$I ~obj %~stream は、所与の時点で：
◎
↓</p>
<ul>
	<li>
次を満たすならば
`読取n可能@RS
（ `readable^en ）という
⇒
%~stream.`state^sl ~EQ `readable^l
◎
A ReadableStream object stream is said to be readable if stream.[[state]] is "readable".
</li>
	<li>
次を満たすならば
`~closeされた@RS
（ `closed^en ）という
⇒
%~stream.`state^sl ~EQ `closed^l
◎
A ReadableStream object stream is said to be closed if stream.[[state]] is "closed".
</li>
	<li>
次を満たすならば
`~errorした@RS
（ `errored^en ）という
⇒
%~stream.`state^sl ~EQ `errored^l
◎
A ReadableStream object stream is said to be errored if stream.[[state]] is "errored".
</li>
	<li>
次を満たすならば
`~lockされている@RS
（ `locked^en ）という
⇒
`IsReadableStreamLocked$A( %~stream ) ~EQ ~T 
◎
A ReadableStream object stream is said to be locked if the result of calling IsReadableStreamLocked(stream) is true.
</li>
	<li>
<p>
次を満たすならば
`もっと~dataが必要@RS
（ `need more data^en ）という
⇒
［
%~stream は`読取n可能$RSである
］~AND［
次を~callした結果 ~GT 0
］
⇒
`ReadableStreamDefaultControllerGetDesiredSize$A( %~stream.`readableStreamController^sl )
◎
A ReadableStream object stream is said to need more data if the following conditions hold:
• stream is readable.
• The result of calling ReadableStreamDefaultControllerGetDesiredSize(stream.[[readableStreamController]]) is positive.
</li>
	<li>
次を満たすならば
`妨げられている@RS
（ `disturbed^en ）という
⇒
`IsReadableStreamDisturbed$A( %~stream ) ~EQ ~T
◎
A ReadableStream object stream is said to be disturbed if the result of calling IsReadableStreamDisturbed(stream) is true.
</li>
</ul>

		</section>
	</section>
	<section id="http-extensions">
<h2 title="HTTP extensions">3. ~HTTP拡張</h2>

		<section id="origin-header">
<h3 title="Origin header">3.1. `Origin^h ~header</h3>

<p>
`Origin@h
要請`~header$は、`~fetch$ が出自にしている生成元を指示する。
◎
The `Origin` request header indicates where a fetch originates from.
</p>

<p class="note">注記：
`Origin$h ~headerは、 `Referer$h ~headerの`~path$url情報を露呈させなくした~versionである<small>（この~header名は、本来の英語の綴り “Referrer” と異なることに注意）</small>。
これは、`~HTTP~fetch$のうち，［
`要請$の`応答~tainting$rq ~EQ `cors^l
］の下で行われるもの,
および `要請$の`~method$rqに［
`GET$hm, `HEAD$hm
］以外のものを利用するもの
］すべてに利用される。
互換性の拘束から、すべての`~fetch$に含まれることはない。
◎
The `Origin` header is a version of the `Referer` [sic] header that does not reveal a path. It is used for all HTTP fetches whose request’s response tainting is "cors", as well as those where request’s method is neither `GET` nor `HEAD`. Due to compatibility constraints it is not included in all fetches.
</p>

<p>
その`値$hd用の`~ABNF$は：
◎
Its value ABNF:
</p>

<pre class="bnf">
Origin               = origin-or-null

origin-or-null       = origin / `%s^"null" ; <span class="comment">文字大小区別</span>
origin               = `~scheme$url "://" `~host$url [ ":" `~port$url ]</pre>

<p class="note">注記：
これは `ORIGIN$r による
<a href="~RFCx/rfc6454#section-7">`Origin^h</a>
`~header$を置き換える。
【値に複数個の生成元を含められないようにされている。】
◎
This supplants the `Origin` header. [ORIGIN]
</p>

<hr>

<div class="algo">
<p>
`要請~Origin~headerを付加する@
ときは、所与の
( `要請$ %要請 )
に対し，次の手続きを走らす：
◎
To append a request `Origin` header, given a request request, run these steps:
</p>
<ol>
	<li>
%直列化した生成元 ~LET `要請の生成元を~byte直列化する$( %要請 )
◎
Let serializedOrigin be the result of byte-serializing a request origin with request.
</li>
	<li>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~OR［
%要請 の`~mode$rq ~EQ `websocket^l
］
⇒＃
%要請 の`~header~list$rqに`~headerを付加する$( `Origin^h / %直列化した生成元 )；
~RET
◎
If request’s response tainting is "cors" or request’s mode is "websocket", then append `Origin`/serializedOrigin to request’s header list.
</li>
	<li>
~IF［
%要請 の`~method$rq ~IN { `GET$hm, `HEAD$hm }
］
⇒
~RET
◎
Otherwise, if request’s method is neither `GET` nor `HEAD`, then:
</li>
	<li>
<p>
%要請 の`~referrer施策$rqに応じて：
◎
Switch on request’s referrer policy:
</p>
		<dl class="switch">
			<dt>`no-referrer^l</dt>
			<dd>
%直列化した生成元 ~SET `null^bl
◎
Set serializedOrigin to `null`.
</dd>

			<dt>`no-referrer-when-downgrade^l</dt>
			<dt>`strict-origin^l</dt>
			<dt>`strict-origin-when-cross-origin^l</dt>
			<dd>
~IF［
%要請 の`生成元$rqは`成分組~生成元$である
］~AND［
%要請 の`生成元$rqの`~scheme$o【！ its %~scheme】
~EQ `https^l
］~AND［
%要請 の`現在の~URL$rqの`~scheme$url【！%~scheme】 ~NEQ `https^l
］
⇒
%直列化した生成元 ~SET `null^bl
◎
If request’s origin is a tuple origin, its scheme is "https", and request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
</dd>

			<dt>`same-origin^l</dt>
			<dd>
~IF［
( %要請 の`生成元$rq, %要請 の`現在の~URL$rqの`生成元$url )
は`同一-生成元$でない
］
⇒
%直列化した生成元 ~SET `null^bl
◎
If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.
</dd>

			<dt>その他</dt>
			<dd>
何もしない
◎
Do nothing.
</dd>
		</dl>
	</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Origin^h / %直列化した生成元
)
◎
Append `Origin`/serializedOrigin to request’s header list.
</li>
</ol>

<p class="note">注記：
`要請$の`~referrer施策$rqは、すべての~fetchに織り込まれる
— ~fetch側が明示的に自身の`生成元$を~serverと共有するよう（例えば`~CORS~protocol$の利用を介して）~opt-inしていなくとも。
◎
A request’s referrer policy is taken into account for all fetches where the fetcher did not explicitly opt into sharing their origin with the server, e.g., via using the CORS protocol.
</p>
</div>

		</section>
		<section id="http-cors-protocol">
<h3 title="CORS protocol">3.2. ~CORS~protocol</h3>

<p>
`~CORS~protocol@
は、非同一-生成元 間での応答の共有, および
~HTMLの `form$e 要素で可能なものより多用途の`~fetch$を可能にするためにある。
それは，~HTTPの上層にあり、それにより，応答は［
自身が他の`生成元$と共有し得る
］ことを宣言できるようになる。
◎
To allow sharing responses cross-origin and allow for more versatile fetches than possible with HTML’s form element, the CORS protocol exists. It is layered on top of HTTP and allows responses to declare they can be shared with other origins.
</p>

<p class="note">注記：
これには、~firewallの背後（~intranet）からの応答による~data漏洩を防止するために，~opt-inの仕組みが必要になる。
加えて，`資格証$を含む`要請$にも、敏感になり得る~dataの漏洩を防止するため，~opt-inが必要になる。
◎
It needs to be an opt-in mechanism to prevent leaking data from responses behind a firewall (intranets). Additionally, for requests including credentials it needs to be opt-in to prevent leaking potentially-sensitive data.
</p>

<p>
この節では、`~CORS~protocol$の，~server開発者に該当する部分について説明する。
~UA側に課される要件は、
<a href="#http-new-header-syntax">［ その新たな~HTTP~header ］の構文</a>
を除き，`~fetch$ ~algoの一部として与えられる。
◎
This section explains the CORS protocol as it pertains to server developers. Requirements for user agents are part of the fetch algorithm, except for the new HTTP header syntax.
</p>

			<section id="general">
<h4 title="General">3.2.1. 一般論</h4>

<p>
`~CORS~protocol$は、応答が 非同一-生成元の下でも共有し得るものになるかどうかを指示する，一連の~headerからなる。
◎
The CORS protocol consists of a set of headers that indicates whether a response can be shared cross-origin.
</p>

<p>
［
~HTMLの `form$e 要素で可能なものを超えるもの
］を孕む`要請$においては、［
`要請$の`現在の~URL$rqが `~CORS~protocol$を~supportする
］ことを確保する必要があるので，`~CORS予行~要請$が遂行される。
◎
For requests that are more involved than what is possible with HTML’s form element, a CORS-preflight request is performed, to ensure request’s current URL supports the CORS protocol.
</p>

			</section>
			<section id="http-requests">
<h4 title="HTTP requests">3.2.2. ~HTTP要請</h4>

<p>
`~CORS要請@
とは、 `Origin$h ~headerを含んでいる~HTTP要請である。
が、［
そのような要請が`~CORS~protocol$に関与している
］とは，依拠-可能に識別できない
— この~headerは，［
`GET$hm, `HEAD$hm
］以外の`~method$rqを用いる どの`要請$にも含められるので。
◎
A CORS request is an HTTP request that includes an `Origin` header. It cannot be reliably identified as participating in the CORS protocol as the `Origin` header is also included for all requests whose method is neither `GET` nor `HEAD`.
</p>

<p>
`~CORS予行~要請@
とは、`~CORS~protocol$が解されるかどうか検査するための`~CORS要請$である。
それは、`~method$に `OPTIONS$hm を利用し，次の`~header$を中に含む：
◎
A CORS-preflight request is a CORS request that checks to see if the CORS protocol is understood. It uses `OPTIONS` as method and includes these headers:
</p>

<dl class="def-list">
	<dt>`Access-Control-Request-Method@h</dt>
	<dd>
同じ資源に対する今後の`~CORS要請$に利用され得る
【要請~側が希望する】
`~method$を指示する。
◎
Indicates which method a future CORS request to the same resource might use.
</dd>

	<dt>`Access-Control-Request-Headers@h</dt>
	<dd>
同じ資源に対する今後の`~CORS要請$に利用され得る
【要請~側が希望する】
`~header$を指示する。
◎
Indicates which headers a future CORS request to the same resource might use.
</dd>
</dl>

			</section>
			<section id="http-responses">
<h4 title="HTTP responses">3.2.3. ~HTTP応答</h4>

<p>
`~CORS要請$に対する~HTTP応答には、次の`~header$を含ませれる：
◎
An HTTP response to a CORS request can include the following headers:
</p>

<dl class="def-list">
	<dt>`Access-Control-Allow-Origin@h</dt>
	<dd>
応答に次のどれを返すかを介して，応答が共有し得るものになるかどうかを指示する
⇒＃
`Origin$h 要請`~header$の~literal`値$hd（ `null^bl もとり得る）,
`*^bl
◎
Indicates whether the response can be shared, via returning the literal value of the `Origin` request header (which can be `null`) or `*` in a response.
</dd>

	<dt>`Access-Control-Allow-Credentials@h</dt>
	<dd>
`要請$の`資格証~mode$rq が `include^l であるときに，応答が共有し得るものになるかどうかを指示する。
◎
Indicates whether the response can be shared when request’s credentials mode is "include".
</dd>
	<dd class="note">注記：
`~CORS予行~要請$の際には，`要請$の`資格証~mode$rqは常に `omit^l であるが、後続の`~CORS要請$はそうでないこともある。
したがって、`~CORS予行~要請$に対する~HTTP応答の中でも，~supportの有無が指示される必要がある。
◎
For a CORS-preflight request, request’s credentials mode is always "omit", but for any subsequent CORS requests it might not be. Support therefore needs to be indicated as part of the HTTP response to the CORS-preflight request as well.
</dd>

</dl>

<p>
`~CORS予行~要請$に対する~HTTP応答には、次の`~header$を含ませれる：
◎
An HTTP response to a CORS-preflight request can include the following headers:
</p>

<dl class="def-list">
	<dt>`Access-Control-Allow-Methods@h</dt>
	<dd>
`~CORS~protocol$の目的において，`応答$の`~URL$rsが~supportする`~method$を指示する。
◎
Indicates which methods are supported by the response’s URL for the purposes of the CORS protocol.
</dd>
	<dd class="note">注記：
`Allow$h `~header$は`~CORS~protocol$の目的には関連しない。
◎
The `Allow` header is not relevant for the purposes of the CORS protocol.
</dd>

	<dt>`Access-Control-Allow-Headers@h</dt>
	<dd>
`~CORS~protocol$の目的において，`応答$の`~URL$rsが~supportする`~header$を指示する。
◎
Indicates which headers are supported by the response’s URL for the purposes of the CORS protocol.
</dd>

	<dt>`Access-Control-Max-Age@h</dt>
	<dd>
［
`Access-Control-Allow-Methods$h ／
`Access-Control-Allow-Headers$h
］`~header$から供される情報を~cacheできる期間
【~UA側が~cache内に保持してもよい最長の期間】
を秒数（既定は 5 ）で指示する。
◎
Indicates the number of seconds (5 by default) the information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` headers can be cached.
</dd>
</dl>

<p>
`~CORS予行~要請$でない`~CORS要請$に対する~HTTP応答には、次の`~header$を含ませれる：
◎
An HTTP response to a CORS request that is not a CORS-preflight request can also include the following header:
</p>

<dl class="def-list">
	<dt>`Access-Control-Expose-Headers@h</dt>
	<dd>
応答の一部として公開できる
【~UA側の~script~APIに公開-を許可する】
`~header$を，`名前$hdの~listにより指示する。
◎
Indicates which headers can be exposed as part of the response by listing their names.
</dd>
</dl>

<hr>

<p>
`~CORS~protocol$に関与したいと望まない~serverは、この節に挙げた`~header$を［
`~CORS要請$ ／ `~CORS予行~要請$
］に対する~HTTP応答に含ませてはナラナイ。
~serverには、そのような~HTTP応答に `403$st `状態s$を利用することが奨励される。
◎
In case a server does not wish to participate in the CORS protocol, its HTTP response to the CORS or CORS-preflight request must not include any of the above headers. The server is encouraged to use the 403 status in such HTTP responses.
</p>

			</section>
			<section id="http-new-header-syntax">
<h4 title="HTTP new-header syntax">3.2.4. ［ 新たな~HTTP~header ］の構文</h4>

<p>
`~CORS~protocol$に利用される`~header$の`値$hd用の`~ABNF$は：
◎
ABNF for the values of the headers used by the CORS protocol:
</p>

<pre class="bnf">
Access-Control-Request-Method    = `method$p
Access-Control-Request-Headers   = 1#`field-name$p

wildcard                         = "*"
Access-Control-Allow-Origin      = origin-or-null / wildcard
Access-Control-Allow-Credentials = `%s^"true" ; <span class="comment">文字大小区別</span>
Access-Control-Expose-Headers    = #`field-name$p
Access-Control-Max-Age           = `delta-seconds$p
Access-Control-Allow-Methods     = #`method$p
Access-Control-Allow-Headers     = #`field-name$p
</pre>

<p class="note">注記：
［
`Access-Control-Expose-Headers^h ／
`Access-Control-Allow-Methods^h ／
`Access-Control-Allow-Headers^h
］応答`~header$用の`値$hd `*^blは、［
`資格証$を伴わない`要請$
］に対しては，~wildcardとみなされる。
そのような`要請$に対しては、値 `*^bl をとる［
`~header$の`名前$hd ／
`~method$
］のみに合致させる仕方はない。
◎
For `Access-Control-Expose-Headers`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers` response headers the value `*` counts as a wildcard for requests without credentials. For such requests there is no way to solely match a header name or method that is `*`.
</p>

			</section>
			<section id="cors-protocol-and-credentials">
<h4 title="CORS protocol and credentials">3.2.5. ~CORS~protocolと資格証</h4>

【！ non-normative】

<p>
［
`要請$の`資格証~mode$rq ~EQ `include^l
］のときには、`~fetching$の際に`資格証$を含ませること以外にも，`~CORS~protocol$の~~働きに影響iがある。
◎
When request’s credentials mode is "include" it has an impact on the functioning of the CORS protocol other than including credentials in the fetch.
</p>

<div class="example" id="example-xhr-credentials">

<p>
昔から、 `XMLHttpRequest$I を利用して，`要請$の`資格証~mode$rqを `include^l に設定できていたが：
◎
In the old days, XMLHttpRequest could be used to set request’s credentials mode to "include":
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest()
%client.open("GET", "./")
%client.withCredentials = true
/* … */
</pre>

<div class="p">
<p>
今では次で足りる：
</p>

<pre class="lang-js">
fetch("./", { credentials:"include" }).then(/* … */)
</pre>

◎
Nowadays, fetch("./", { credentials:"include" }).then(/* … */) suffices.
</div>

</div>

<p>
`要請$の`資格証~mode$rqが~serverから観測-可能になることは、必要とされない。
`要請$に`資格証$が存在するときに限り、そのことから観測できる。
そうであっても、`~CORS予行~要請$が`資格証$を含むことは，決してないことに注意。
◎
A request’s credentials mode is not necessarily observable on the server; only when credentials exist for a request can it be observed by virtue of the credentials being included. Note that even so, a CORS-preflight request never includes credentials.
</p>

<p>
したがって~server開発者は、［
`資格証$で “染められた（ `tainted^en ）” 応答を，共有させれるかどうか
］を裁定する必要がある。
また、［
`~CORS予行~要請$を要している`要請$に，`資格証$を含めれるかどうか
］も裁定する必要がある。
一般的に言えば，［
応答を共有させる ／
`資格証$を伴う要請を許容する
］ことは安全でなくする方へ~~働くので、慎重に事を~~運んで，
<a lang="en-x-a0" href="https://en.wikipedia.org/wiki/Confused_deputy_problem">confused deputy problem</a>
（混乱した使節の~~問題）を避ける必要がある。
◎
The server developer therefore needs to decide whether or not responses "tainted" with credentials can be shared. And also needs to decide if requests necessitating a CORS-preflight request can include credentials. Generally speaking, both sharing responses and allowing requests with credentials is rather unsafe, and extreme care has to be taken to avoid the confused deputy problem.
</p>

<p>
`資格証$を伴う応答を共有させるためには、［
`Access-Control-Allow-Origin$h,
`Access-Control-Allow-Credentials$h
］`~header$が重要になる。
次の表に、
`https://rabbit.invalid/^s
へ向けた要請~用の種々の［
合法である／合法でない
］組合nを~~説明する：
◎
To share responses with credentials, the `Access-Control-Allow-Origin` and `Access-Control-Allow-Credentials` headers are important. The following table serves to illustrate the various legal and illegal combinations for a request to https://rabbit.invalid/:
</p>

<table style="margin-top: 5em;">
<tbody><tr><th>
要請の`資格証~mode$rq
◎
Request’s credentials mode
<th><div class="_narrow-cell"><span style="top:-4.5em;">
`Access-Control-Allow-Origin$h
</span></div>
<th><div class="_narrow-cell"><span>
`Access-Control-Allow-Credentials$h
</span></div>
<th>共有される？
◎
Shared?
<th>備考
◎
Notes
<tr>
<td>`omit^l
<td>`*^bl
<td>なし
<td>✅
<td>—

<tr><td>`omit^l
<td>`*^bl
<td>`true^bl
<td>✅
<td>
資格証~mode ~NEQ `include^l の場合、
`Access-Control-Allow-Credentials$h は無視される。
◎
If credentials mode is not "include", then `Access-Control-Allow-Credentials` is ignored.

<tr><td>`omit^l
<td>`https://rabbit.invalid/^bl
<td>なし
<td>❌
<td>
生成元を直列化した結果の末尾は、~slashではない。
◎
A serialized origin has no trailing slash.

<tr><td>`omit^l
<td>`https://rabbit.invalid^bl
<td>なし
<td>✅
<td>—

<tr><td>`include^l
<td>`*^bl
<td>`true^bl
<td>❌
<td>
資格証~mode ~EQ `include^l の場合、
`Access-Control-Allow-Origin$h は `*^bl にできない。
◎
If credentials mode is "include", then `Access-Control-Allow-Origin` cannot be `*`.

<tr><td>`include^l
<td>`https://rabbit.invalid^bl
<td>`true^bl
<td>✅
<td>—

<tr><td>`include^l
<td>`https://rabbit.invalid^bl
<td>`True^bl
<td>❌
<td>
`true^bl は（~byte）文字大小区別。
◎
`true` is (byte) case-sensitive.
</tbody></table>

<p>
同様に、応答~header［
`Access-Control-Expose-Headers$h ／
`Access-Control-Allow-Methods$h ／
`Access-Control-Allow-Headers$h
］の値として `*^bl を利用できるのは、［
`要請$の`資格証~mode$rq ~NEQ `include^l
］のときに限られる。
◎
Similarly, `Access-Control-Expose-Headers`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers` response headers can only use `*` as value when request’s credentials mode is not "include".
</p>

			</section>
			<section id="cors-protocol-examples">
<h4 title="Examples">3.2.6. 例</h4>

<div class="example" id="example-simple-cors">

<p>
`https://foo.invalid/^s にある~scriptは、
`https://bar.invalid/^s から，何か~dataを~fetchしたいと求めているとする（`資格証$も応答~headerへの~accessも重要でないとする）：
◎
A script at https://foo.invalid/ wants to fetch some data from https://bar.invalid/. (Neither credentials nor response header access is important.)
</p>

<pre class="lang-js" id="unicorn">
var %url = "https://bar.invalid/api?key=\
730d67a37d7f3d802e96396d00280768773813fbe726d116944d814422fc1a45\
&amp;data=about:unicorn";
fetch(%url).then(%success, %failure)
</pre>

<p>
`foo.invalid^s の開発者からはまったく透過的になるが、これには，`~CORS~protocol$が利用される
— ~UAは、`~CORS~protocol$の一環として，要請~内に `Origin$h ~headerを含ませることになる：
◎
This will use the CORS protocol, though this is entirely transparent to the developer from foo.invalid. As part of the CORS protocol, the user agent will include the `Origin` header in the request:
</p>

<pre class="lang-http">
Origin: https://foo.invalid
</pre>

<p>
~UAは、 `bar.invalid^s からの応答の受信-時に，
`Access-Control-Allow-Origin$h 応答~headerを検証yすることになる。
その値が［
`https://foo.invalid^bl, `*^bl
］のいずれかならば， %success ~callbackが呼出され、
他の値, あるいは~headerがない場合には， %failure ~callbackが呼出されることになる。
◎
Upon receiving a response from bar.invalid, the user agent will verify the `Access-Control-Allow-Origin` response header. If its value is either `https://foo.invalid` or `*`, the user agent will invoke the success callback. If it has any other value, or is missing, the user agent will invoke the failure callback.
</p>

</div>

<div class="example" id="example-cors-with-response-header">

<p>
`foo.invalid^s の開発者が，今度は、応答~headerにも~accessしつつ，
`bar.invalid^s から何か~dataを~fetchしようと求めたとする：
◎
The developer of foo.invalid is back, and now wants to fetch some data from bar.invalid while also accessing a response header.
</p>

<pre class="lang-js">
fetch(%url).then(%response =&gt; {
  var %hsts = %response.headers.get("strict-transport-security"),
      %csp = %response.headers.get("content-security-policy")
  log(%hsts, %csp)
})
</pre>

<p>
`bar.invalid^s は、先の例と同じく，正しい `Access-Control-Allow-Origin$h 応答~headerを供したとする。
%hsts, %csp の値は、
`Access-Control-Expose-Headers$h 応答~headerに依存することになる。
例えば、応答に次の~headerが含まれていたとする：
◎
bar.invalid provides a correct `Access-Control-Allow-Origin` response header per the earlier example. The values of hsts and csp will depend on the `Access-Control-Expose-Headers` response header. For example, if the response included the following headers
</p>

<pre class="lang-http">
`Content-Security-Policy$: `default-src$dir 'self'
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
Access-Control-Expose-Headers: Content-Security-Policy
</pre>

<p>
この場合，応答が両~headerとも含んでいようが、
%hsts は ~NULL になり， %csp は `default-src 'self'^l になる。
何故なら， `bar.invalid^s は、［
`Access-Control-Expose-Headers$h 応答~header内にそれらの~header名を~listする
］ことにより，各~headerごとに明示的に共有させる必要があるので。
◎
then hsts would be null and csp would be "default-src 'self'", even though the response did include both headers. This is because bar.invalid needs to explicitly share each header by listing their names in the `Access-Control-Expose-Headers` response header.
</p>

<p>
別法として，
`bar.invalid^s は、［
`資格証$を含まない要請に対し，自身による応答~headerすべてを共有させたい
］と求めるなら，
`Access-Control-Expose-Headers$h 応答~headerの値に `*^bl を利用することもできる。
`資格証$を含む要請に対しては、応答~header名は明示的に~listされる必要があり，
`*^bl は利用できない。
◎
Alternatively, if bar.invalid wanted to share all its response headers, for requests that do not include credentials, it could use `*` as value for the `Access-Control-Expose-Headers` response header. If the request would have included credentials, the response header names would have to be listed explicitly and `*` could not be used.
</p>

</div>

<div class="example" id="example-cors-with-credentials">

<p>
`foo.invalid^s の開発者が今度は、`資格証$も含ませつつ， `bar.invalid^s から何か~dataを~fetchしようとしたとする。
`資格証$には明示的な~opt-inが要求されるので、もはや開発者にとっては，
`~CORS~protocol$周りで透過的でなくなる：
◎
The developer of foo.invalid returns, now fetching some data from bar.invalid while including credentials. This time around the CORS protocol is no longer transparent to the developer as credentials require an explicit opt-in:
</p>

<pre class="lang-js">
fetch(%url, { credentials:"include" }).then(%success, %failure)
</pre>

<p>
これもまた、 `bar.invalid^s が含ませた `Set-Cookie$h 応答~headerを，全部的に~~機能させる（さもなければ無視される）。
◎
This also makes any `Set-Cookie` response headers bar.invalid includes fully functional (they are ignored otherwise).
</p>

<p>
~UAは、関連な`資格証$があれば，それも要請~内に必ず含めるようにする。
また、応答にも，より厳密な要件を課す
— `bar.invalid^s からの応答には、 `Access-Control-Allow-Origin$h ~header用に `https://foo.invalid^bl を~listする必要があることに加え（`資格証$が孕まれる下では `*^bl は許容されない），
`Access-Control-Allow-Credentials$h ~headerも在る必要がある：
◎
The user agent will make sure to include any relevant credentials in the request. It will also put stricter requirements on the response. Not only will bar.invalid need to list `https://foo.invalid` as value for the `Access-Control-Allow-Origin` header (`*` is not allowed when credentials are involved), the `Access-Control-Allow-Credentials` header has to be present too: 
</p>

<pre class="lang-http">
Access-Control-Allow-Origin: https://foo.invalid
Access-Control-Allow-Credentials: true
</pre>

<p>
応答が これらの値を伴うこれら 2 つの~headerを含んでいない場合，
%failure ~callbackが呼出される。
しかしながら、
`Set-Cookie$h 応答~headerは尊重されることになる。
◎
If the response does not include those two headers with those values, the failure callback will be invoked. However, any `Set-Cookie` response headers will be respected.
</p>

</div>

			</section>
			<section id="cors-protocol-exceptions">
<h4 title="CORS protocol exceptions">3.2.7. ~CORS~protocolの例外</h4>

<p>
仕様は、~CORS安全とされる~headerに対する制限付きな例外を，安全とされていない［
`Content-Type$h の~header値
］用に許容していた。
そのような例外は、［
~web内容が誘発し得るが，~web内容が制御できるのは必要最小限な［
~headerと本体
］に限られるような要請
］用に~~策定された。
したがって，~serverは、［
非同一-生成元に属する~web内容には，［
次に挙げる［
安全とされていない `Content-Type$h ~header値
］を伴う，予行なしの要請
］を誘発することが許容される
］ものと予期するベキである：
◎
Specifications have allowed limited exceptions to the CORS safelist for non-safelisted `Content-Type` header values. These exceptions are made for requests that can be triggered by web content but whose headers and bodies can be only minimally controlled by the web content. Therefore, servers should expect cross-origin web content to be allowed to trigger non-preflighted requests with the following non-safelisted `Content-Type` header values:
</p>

<ul ><li>`application/csp-report^bl `CSP$r
</li><li>`application/expect-ct-report+json^bl `EXPECT-CT$r
</li><li>`application/xss-auditor-report^bl
</li><li>`application/ocsp-request^bl `OCSP$r
</li></ul>

<p>
仕様は、新たな例外を導入するのは避けるベキである
— そうする場合、~security上の帰結を注意深く考慮するベキである。
新たな例外は、
<a href="https://github.com/whatwg/fetch/issues/new">課題を申請して</a>
提案できる。
◎
Specifications should avoid introducing new exceptions and should only do so with careful consideration for the security consequences. New exceptions can be proposed by filing an issue.
</p>

			</section>
		</section>
		<section id="content-type-header">
<h3 title="Content-Type header">3.3. `Content-Type^h ~header</h3>

<p>
`Content-Type$h ~headerは，大部分は~HTTPにて定義されているが、その処理~modelは，ここに定義される
— ~HTTPが定義する~ABNFは、~web内容と互換でないので。
`HTTP$r
◎
The `Content-Type` header is largely defined in HTTP. Its processing model is defined here as the ABNF defined in HTTP is not compatible with web content. [HTTP]
</p>

<div class="algo">
<p>
`~header~listから~MIME型を抽出する@
ときは、所与の
( `~header~list$ %~headerたち )
に対し，次を走らす：
◎
To extract a MIME type from a header list headers, run these steps:
</p>
<ol>
	<li>
%~charset ~LET ~NULL
◎
Let charset be null.
</li>
	<li>
%~essence ~LET ~NULL
◎
Let essence be null.
</li>
	<li>
%~MIME型 ~LET ~NULL
◎
Let mimeType be null.
</li>
	<li>
%値~list ~LET `~header~listから値を取得して復号して分割する$( %~headerたち, `Content-Type$h )
◎
Let values be the result of getting, decoding, and splitting `Content-Type` from headers.
</li>
	<li>
~IF［
%値~list ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If values is null, then return failure.
</li>
	<li>
<p>
%値~list を成す
~EACH( %値 )
に対し：
◎
For each value of values:
</p>
		<ol>
			<li>
%一時的~MIME型 ~LET `~MIME型を構文解析する$( %値 )
◎
Let temporaryMimeType be the result of parsing value.
</li>
			<li>
~IF［
%一時的~MIME型 ~EQ `失敗^i
］~OR［
%一時的~MIME型 の`~essence$ ~EQ `*/*^l
］
⇒
~CONTINUE
◎
If temporaryMimeType is failure or its essence is "*/*", then continue.
</li>
			<li>
%~MIME型 ~SET %一時的~MIME型
◎
Set mimeType to temporaryMimeType.
</li>
			<li>
%~parameter~map ~LET %~MIME型 の`~parameter~map$
◎
↓</li>
			<li>
<p>
~IF［
%~MIME型 の`~essence$ ~NEQ %~essence
］：
◎
If mimeType’s essence is not essence, then:
</p>
				<ol>
					<li>
%~charset ~SET ~NULL
◎
Set charset to null.
</li>
					<li>
~IF［
%~parameter~map[ `charset^l ] ~NEQ ε
］
⇒
%~charset ~SET %~parameter~map[ `charset^l ]
◎
If mimeType’s parameters["charset"] exists, then set charset to mimeType’s parameters["charset"].
</li>
					<li>
%~essence ~SET %~MIME型 の`~essence$
◎
Set essence to mimeType’s essence.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~parameter~map [ `charset^l ] ~EQ ε
］~AND［
%~charset ~NEQ ~NULL
］
⇒
%~parameter~map[ `charset^l ] ~SET %~charset
◎
Otherwise, if mimeType’s parameters["charset"] does not exist, and charset is non-null, set mimeType’s parameters["charset"] to charset.
</li>
		</ol>
	</li>
	<li>
~IF［
%~MIME型 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If mimeType is null, then return failure.
</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>

<p class="warning">
`~header~listから~MIME型を抽出する$ が返す結果が［
`失敗^i ／
所与の内容形式~用に不正な`~essence$を持つ`~MIME型$
］である場合、致命的な~errorとして扱う。
既存の~web~platform特能は、この~patternに常に従ってはいなかった
— それは、長年にわたり，それらの特能における~security脆弱性の大多数の源であった。
対照的に，`~MIME型$の`~parameter~map$は、概して安全に無視できる。
◎
When extract a MIME type returns failure or a MIME type whose essence is incorrect for a given format, treat this as a fatal error. Existing web platform features have not always followed this pattern, which has been a major source of security vulnerabilities in those features over the years. In contrast, a MIME type’s parameters can typically be safely ignored.
</p>
</div>

<div class="example">

<p>
`~header~listから~MIME型を抽出する$ が、実施においてどう機能するかを次に示す：
◎
This is how extract a MIME type functions in practice:
</p>

<table><thead><tr><th>（~network上の）~header列
◎
Headers (as on the network)
<th>
（<a href="~MIMESNIFF#serialize-a-mime-type">直列化された</a>）出力
◎
Output (serialized)
</thead><tbody>

<tr><td><pre class="lang-http">
Content-Type: text/plain;charset=gbk, text/html
</pre>
<td>`text/html^c

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk;a=b, text/html;x=y
</pre>
<td rowspan="2">`text/html;x=y;charset=gbk^c

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk;a=b
Content-Type: text/html;x=y
</pre>

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk
Content-Type: x/x
Content-Type: text/html;x=y
</pre>
<td>`text/html;x=y^c

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type: cannot-parse
</pre>
<td rowspan="3">`text/html^c

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type: */*
</pre>

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type:
</pre>
</tbody></table>
</div>

		</section>
		<section id="x-content-type-options-header">
<h3 title="X-Content-Type-Options header">3.4. `X-Content-Type-Options^h ~header</h3>

<p>
`X-Content-Type-Options@h
応答`~header$を利用して、［
`応答$の `Content-Type$h `~header$を`要請$の`行先$rqと突き合わせて検査する
］ことを要求できる。
◎
The `X-Content-Type-Options` response header can be used to require checking of a response’s `Content-Type` header against the destination of a request.
</p>

<div class="algo">
<p>
`~nosniffかどうか決定する@
ときは、所与の
( `~header~list$ %~list )
に対し，次を走らす：
◎
To determine nosniff, given a header list list, run these steps:
</p>
<ol>
	<li>
%値たち ~LET `~header~listから値を取得して復号して分割する$( %~list, `X-Content-Type-Options$h )
◎
Let values be the result of getting, decoding, and splitting `X-Content-Type-Options` from list.
</li>
	<li>
~IF［
%値たち ~EQ ~NULL
］
⇒
~RET ~F
◎
If values is null, then return false.
</li>
	<li>
~IF［
%値たち[ 0 ] は `nosniff^l に`~ASCII大小無視$で合致する
］
⇒
~RET ~T
◎
If values[0] is an ASCII case-insensitive match for "nosniff", then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
［
~web開発者／適合性~検査器
］は、
`X-Content-Type-Options$h 用の`値$hdに，次の`~ABNF$を利用しなければナラナイ：
◎
Web developers and conformance checkers must use the following value ABNF for `X-Content-Type-Options`:
</p>

<pre class="bnf">
X-Content-Type-Options = "nosniff" ; <span class="comment">大小無視</span>
</pre>

			<section id="should-response-to-request-be-blocked-due-to-nosniff?">
<h4 title="Should response to request be blocked due to nosniff?">3.4.1. %要請 に対する %応答 は，~nosniffに因り阻止されるべきか？</h4>

<p>
次の手続きを走らす：
◎
Run these steps:
</p>
<ol>
	<li>
~IF［
`~nosniffかどうか決定する$( %応答 の`~header~list$rs ) ~EQ ~F
］
⇒
~RET `許容される^i
◎
If determine nosniff with response’s header list is false, then return allowed.
</li>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
%行先 ~LET %要請 の`行先$rq
◎
Let destination be request’s destination.
</li>
	<li>
<p>
~RET［
次のいずれかが満たされるならば `阻止される^i ／
~ELSE_ `許容される^i
］
⇒
</p>
		<ul>
			<li>
［
%行先 は`~scriptに類する$
］~AND［［
%~MIME型 ~EQ `失敗^i
］~OR［
%~MIME型 は`~JS~MIME型$でない
］］
</li>
			<li>
［
%行先 ~EQ `style^l
］~AND［［
%~MIME型 ~EQ `失敗^i
］~OR［
%~MIME型 の`~essence$ ~NEQ `text/css^l
］］
</li>
		</ul>
◎
If destination is script-like and mimeType is failure or is not a JavaScript MIME type, then return blocked.
◎
If destination is "style" and mimeType is failure or its essence is not "text/css", then return blocked.
◎
Return allowed.
</li>
</ol>

<p class="note">注記：
ここで考慮される`要請$の`行先$rqは、`~scriptに類する$ものか `style^l に限られる
— どの悪用も これらに該当するので。
また、ここで `image^l も考慮すると，配備-済みの内容と互換にならなくなる。
◎
Only request destinations that are script-like or "style" are considered as any exploits pertain to them. Also, considering "image" was not compatible with deployed content.
</p>

			</section>
		</section>
		<section id="corb">
<h3 title="CORB">3.5. ~CORB</h3>

<p class="note">注記：
~CORBとも~~略称される，非同一-生成元からの読取nの阻止-法（ `Cross-Origin Read Blocking^en ）は、疑わしい非同一-生成元~資源~fetchを識別する~algoであり（例： `img^e 要素の内側で~JSONを具現化しようと試みる様な~fetchは、どうやっても失敗することになる），そのような資源が~web~pageに達する前に阻止する。
~CORBは、敏感な~dataを非同一-生成元~web~pageから離れた所に保って，それが漏洩する~riskを抑制する。
◎
Cross-origin read blocking, better known as CORB, is an algorithm which identifies dubious cross-origin resource fetches (e.g., fetches that would fail anyway like attempts to render JSON inside an img element) and blocks them before they reach a web page. CORB reduces the risk of leaking sensitive data by keeping it further from cross-origin web pages.
</p>

<p>
次に挙げるものが，
`~CORBで保護される~MIME型@
とされる
⇒＃
`~HTML~MIME型$,
`~JSON~MIME型$,
`image/svg+xml^bl 以外の`~XML~MIME型$
◎
A CORB-protected MIME type is an HTML MIME type, a JSON MIME type, or an XML MIME type excluding image/svg+xml.
</p>

<div class="note">

<p>注記：
~CORBがなくとも，［
`~CORBで保護される~MIME型$を伴う非同一-生成元~資源
］を成す内容に~accessすることは、次のいずれかになる：
</p>

<ul>
	<li>
`~CORS~protocol$により管理される（例： `XMLHttpRequest$I の事例）
</li>
	<li>
観測-可能にならない（例：~pingや~CSP報告の事例など，応答を無視するもの）
</li>
	<li>
~errorになる（例： `img^e 要素~内に埋込まれた~HTML文書を画像として復号するのに失敗したとき）
</li>
</ul>

<p>
すなわち，~CORBは、~web~pageを妨害することなく，`~CORBで保護される~MIME型$の資源を阻止できる。
</p>
◎
Even without CORB, accessing the content of cross-origin resources with CORB-protected MIME types is either managed by the CORS protocol (e.g., in case of XMLHttpRequest), not observable (e.g., in case of pings or CSP reports which ignore the response), or would result in an error (e.g., when failing to decode an HTML document embedded in an img element as an image). This means that CORB can block CORB-protected MIME types resources without being disruptive to web pages.
</div>

<div class="algo">
<p>
`~CORB検査@
を遂行するときは、所与の
( %要請, %応答 )
に対し，次を走らす：
◎
To perform a CORB check, given a request and response, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `download^l
］
⇒
~RET `許容される^i
◎
If request’s initiator is "download", then return allowed.
</p>

<p class="XXX">
~download法を~naviの一種に~~落とし込めば、この段は除去できる。
◎
If we recast downloading as navigation this step can be removed.
</p>
	</li>
	<li>
~IF［
%要請 の`現在の~URL$rqの`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET `許容される^i
◎
If request’s current URL’s scheme is not an HTTP(S) scheme, then return allowed.
</li>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
~RET `許容される^i
◎
If mimeType is failure, then return allowed.
</li>
	<li>
~IF［
%応答 の`状態s$rs ~EQ `206$st
］~AND［
%~MIME型 は`~CORBで保護される~MIME型$である
］
⇒
~RET `阻止される^i
◎
If response’s status is 206 and mimeType is a CORB-protected MIME type, then return blocked.
</li>
	<li>
<p>
~IF［
`~nosniffかどうか決定する$( %応答 の`~header~list$rs ) ~EQ ~T
］~AND［［
%~MIME型 は`~CORBで保護される~MIME型$である
］~OR［
%~MIME型 の`~essence$ ~EQ `text/plain^l
］］
⇒
~RET `阻止される^i
◎
If determine nosniff with response’s header list is true and mimeType is a CORB-protected MIME type or its essence is "text/plain", then return blocked.
</p>

<p class="note">注記：
~CORBが保護する `text/plain^bl 応答は、 `X-Content-Type-Options: nosniff^bl ~headerを伴うものに限られる。
あいにく，［
その~headerを伴わない, `状態s$rs `206$st の応答
］を保護することは、あまりに多くの［
`~MIME型$に `text/plain^bl を伴う，既存の動画~応答
］を壊すことになる。
◎
CORB only protects text/plain responses with a `X-Content-Type-Options: nosniff` header. Unfortunately, protecting such responses without that header when their status is 206 would break too many existing video responses that have a text/plain MIME type.
</p>
	</li>
	<li>
~RET `許容される^i
◎
Return allowed.
</li>
</ol>
</div>

		</section>
		<section id="cross-origin-resource-policy-header">
<h3 title="Cross-Origin-Resource-Policy header">3.6. `Cross-Origin-Resource-Policy^h ~header</h3>

<p>
`Cross-Origin-Resource-Policy@h
応答`~header$は、次を要求するために利用できる
⇒
［
`要請$の`~mode$rq ~EQ `no-cors^l
］のときには、`要請$の`現在の~URL$rqの`生成元$urlを`要請$の`生成元$rqと突き合わせて検査する
◎
The `Cross-Origin-Resource-Policy` response header can be used to require checking a request’s current URL’s origin against a request’s origin when request’s mode is "no-cors".
</p>

<p>
その`値$hd用の`~ABNF$は：
◎
Its value ABNF:
</p>

<pre class="bnf">
Cross-Origin-Resource-Policy
    = `%s^"same-origin" / `%s^"same-site" / `%s^"cross-origin"; <span class="comment">文字大小区別</span>

</pre>

<p class="trans-note">【
~CORPは、［
非同一-生成元~資源~施策／この~header名
］の略称を表す。
】</p>

<div class="algo">
<p>
`非同一-生成元~資源~施策~検査@
を遂行するときは、所与の
( `生成元$【！`生成元$url】 %生成元, `環境~設定群~obj$ %設定群~obj, 文字列 %行先, `応答$ %応答, 真偽値 %~navi用 （省略時は ~F ）)
に対し，次の手続きを走らす：
◎
To perform a cross-origin resource policy check, given an origin origin, an environment settings object settingsObject, a string destination, a response response, and an optional boolean forNavigation, run these steps:
• Set forNavigation to false if it is not given.
</p>
<ol>
	<li>
%埋込元~施策 ~LET %設定群~obj の`埋込元~施策$enV
◎
Let embedderPolicy be settingsObject’s embedder policy.
</li>
	<li>
<p>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元, `unsafe-none$l, %応答, %~navi用 )
~EQ `阻止される^i
］
⇒
~RET `阻止される^i
◎
If the cross-origin resource policy internal check with origin, "unsafe-none", response, and forNavigation returns blocked, then return blocked.
</p>

<p class="note">注記：
この段が必要になるのは、下に与える非同一-生成元~埋込元~施策に関係しない違反は，報告するよう求まれないからである。
◎
This step is needed because we don’t want to report violations not related to Cross-Origin Embedder Policy below.
</p>
	</li>
	<li>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元 , %埋込元~施策 の`報告のみの値$embP, %応答, %~navi用 )
~EQ `阻止される^i
］
⇒
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする$( %応答, %設定群~obj, %行先, ~T )
◎
If the cross-origin resource policy internal check with origin, embedderPolicy’s report only value, response, and forNavigation returns blocked, then queue a cross-origin embedder policy CORP violation report with response, settingsObject, destination, and true.
</li>
	<li>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元, %埋込元~施策 の`値$embP, %応答, %~navi用 )
~EQ `許容される^i
］
⇒
~RET `許容される^i
◎
If the cross-origin resource policy internal check with origin, embedderPolicy’s value, response, and forNavigation returns allowed, then return allowed.
</li>
	<li>
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする$( %応答, %設定群~obj, %行先, ~F )
◎
Queue a cross-origin embedder policy CORP violation report with response, settingsObject, destination, and false.
</li>
	<li>
~RET `阻止される^i
◎
Return blocked.
</li>
</ol>

<p class="note">注記：
~HTMLの`~navigate~algo$に限り，この検査を %~navi用 に ~T を与える下で利用する
— それはまた、この検査を，常に入子の【閲覧文脈に対する】~navi用に利用する。
他の場合、 %応答 は［
`不透明な絞込み応答$の`内部~応答$か，そうなるもの
］になる。
`HTML$r
◎
Only HTML’s navigate algorithm uses this check with forNavigation set to true, and it’s always for nested navigations. Otherwise, response is either the internal response of an opaque filtered response or a response which will be the internal response of an opaque filtered response. [HTML]
</p>
</div>

<div class="algo">
<p>
`非同一-生成元~資源~施策~内部~検査@
を遂行するときは、所与の
( `生成元$【！`生成元$url】 %生成元, `埋込元~施策~値$ %埋込元~施策~値, `応答$ %応答, 真偽値 %~navi用 )
に対し，次の手続きを走らす：
◎
To perform a cross-origin resource policy internal check, given an origin origin, an embedder policy value embedderPolicyValue, a response response, and a boolean forNavigation, run these steps:
</p>
<ol>
	<li>
~IF［
%~navi用 ~EQ ~T
］~AND［
%埋込元~施策~値 ~EQ `unsafe-none$l
］
⇒
~RET `許容される^i
◎
If forNavigation is true and embedderPolicyValue is "unsafe-none", then return allowed.
</li>
	<li>
<p>
%施策 ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Cross-Origin-Resource-Policy$h )
◎
Let policy be the result of getting `Cross-Origin-Resource-Policy` from response’s header list.
</p>

<p class="note">注記：
`Cross-Origin-Resource-Policy: same-site, same-origin^bl
にされた場合、［
%埋込元~施策~値 ~EQ `unsafe-none$l【すなわち ~NEQ `require-corp$l 】
］である限り，以下において %施策 が何かに合致することは決してないので，
`許容される^i を返すことになる。
`Cross-Origin-Resource-Policy$h ~headerが複数個ある場合も同じ効果になる。
【すなわち，`~field値$が複数個の~tokenを含む場合、~headerが無かったときと同じになる。】
◎
This means that `Cross-Origin-Resource-Policy: same-site, same-origin` ends up as allowed below as it will never match anything, as long as embedderPolicyValue is "unsafe-none". Two or more `Cross-Origin-Resource-Policy` headers will have the same effect.
</p>
	</li>
	<li>
~IF［
%施策 ~NIN { `same-origin^bl, `same-site^bl, `cross-origin^bl }
］
⇒
%施策 ~SET ~NULL
◎
If policy is neither `same-origin`, `same-site`, nor `cross-origin`, then set policy to null.
</li>
	<li>
~IF［
%施策 ~EQ ~NULL
］~AND［
%埋込元~施策~値 ~EQ `require-corp$l
］
⇒
%施策 ~SET `same-origin^bl
◎
If policy is null and embedderPolicyValue is "require-corp", then set policy to `same-origin`.
</li>
	<li>
<p>
%施策 に応じて：
◎
Switch on policy:
</p>
		<dl class="switch">
			<dt>~NULL</dt>
			<dt>`cross-origin^bl</dt>
			<dd>
~RET `許容される^i
◎
Return allowed.
</dd>
			<dt>`same-origin^bl</dt>
			<dd>
~RET ［
次が満たされるならば `許容される^i ／
~ELSE_ `阻止される^i
］
⇒
( %生成元, %応答 の`~URL$rsの`生成元$url )
は、`同一-生成元$である
◎
If origin is same origin with response’s URL’s origin, then return allowed.
◎
Otherwise, return blocked.
</dd>
			<dt>`same-site^bl</dt>
			<dd>
<p>
~RET ［
次が すべて満たされるならば `許容される^i ／
~ELSE_ `阻止される^i
］：
</p>
				<ul>
					<li>
( %生成元, %応答 の`~URL$rsの`生成元$url )
は、`~scheme無しで同じ~site$である
</li>
					<li>
［
%生成元 の`~scheme$url ~EQ `https^l
］~OR［
%応答 の`~URL$rsの`~scheme$url ~NEQ `https^l
］
</li>
				</ul>
◎
If the following are true
• origin is schemelessly same site with response’s URL’s origin
• origin’s scheme is "https" or response’s URL’s scheme is not "https"
then return allowed.
◎
Otherwise, return blocked.
</dd>
			<dd class="note">注記：
`Cross-Origin-Resource-Policy: same-site^bl
は、要請している生成元【 %生成元 】が~secureでない場合，~secureな~transportを介して送達された応答は【条件に】合致すると見なさない
— それらの~hostが~secureか否かを除けば【すなわち，~scheme無しで】同じ~siteであっても。
~secureに~transportされた応答が合致するのは、【要請の】起動元が~secureに~transportされた場合に限られることになる。
◎
`Cross-Origin-Resource-Policy: same-site` does not consider a response delivered via a secure transport to match a non-secure requesting origin, even if their hosts are otherwise same site. Securely-transported responses will only match a securely-transported initiator.
</dd>
		</dl>
	</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする@
ときは、所与の
( `応答$ %応答, `環境~設定群~obj$ %設定群~obj, 文字列 %行先, 真偽値 %報告のみ )
に対し，次の手続きを走らす：
◎
To queue a cross-origin embedder policy CORP violation report, given a response response, an environment settings object settingsObject, a string destination, and a boolean reportOnly, run these steps:
</p>
<ol>
	<li>
%施策 ~LET %設定群~obj の`埋込元~施策$enV
◎
↓</li>
	<li>
%報告先 ~LET %報告のみ に応じて
⇒＃
~T ならば %施策 の`報告のみの報告先$embP／
~F ならば %施策 の`報告先$embP
◎
Let endpoint be settingsObject’s embedder policy’s report only reporting endpoint if reportOnly is true and settingsObject’s embedder policy’s reporting endpoint otherwise.
</li>
	<li>
%直列化した~URL ~LET `応答~URLを報告-用に直列化する$( %応答 )
◎
Let serializedURL be the result of serializing a response URL for reporting with response.
</li>
	<li>
%処置 ~LET %報告のみ に応じて
⇒＃
~T ならば `reporting^l ／
~F ならば `enforce^l
◎
Let disposition be "reporting" if reportOnly is true; otherwise "enforce".
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな~obj：
</p>

<table><thead>
<tr><th>~key
<th>値
</thead><tbody>

<tr><td>`type^l
<td>`corp^l

<tr><td>`blockedURL^l
<td>%直列化した~URL

<tr><td>`destination^l
<td>%行先

<tr><td>`disposition^l
<td>%処置
</tbody></table>

◎
Let body be a new object containing the following properties:
◎
key｜value
"type"｜"corp"
"blockedURL"｜serializedURL
"destination"｜destination
"disposition"｜disposition
</li>
	<li>
`報告を~queueする$( %本体, `~coep報告~種別$i, %報告先, %設定群~obj )
`REPORTING$r
◎
Queue body as the "coep" report type for endpoint on settingsObject. [REPORTING]
</li>
</ol>
</div>

		</section>
	</section>
	<section id="fetching">
<h2 title="Fetching">4. ~fetching</h2>

<div class="note">

<p>注記：
下の~algoは、`~fetching$を定義する。
大雑把に言えば、それは`要請$を~~入力にとり，`応答$を出力する。
◎
The algorithm below defines fetching. In broad strokes, it takes a request and outputs a response.
</p>

<p>
すなわち，［
`要請$の`同期~flag$rq ~EQ ~T
］ならば`応答$を返し，そうでなければ，［
以下において［
`応答を処理する$ ／
`応答の本体終端を処理する$ ／
`応答の~doneを処理する$
］と記される，`応答$用の演算
］を行うための`~fetch~taskを~queueする$。
◎
That is, it either returns a response if request’s synchronous flag is set, or it queues tasks annotated process response, process response end-of-body, and process response done for the response.
</p>

<p>
~uploadを捕捉するため、［
`要請$の`同期~flag$rq ~EQ ~F
］の場合は、`要請$上で，［
以下において［
`要請の本体を処理する$ ／
`要請の本体終端を処理する$
］と記される演算
］を行うための`~fetch~taskを~queueする$こともある。
◎
To capture uploads, if request’s synchronous flag is unset, tasks annotated process request body and process request end-of-body for the request can be queued.
</p>

</div>

<div class="algo">
<p>
`要請$ %要請 を利用して
`~fetch@
を遂行するときは、下に与える手続きを走らす：
◎
To perform a fetch using request, run the steps below.＼
</p>

<ul>
	<li>
進行中の`~fetch$は，
`終了され@
ることもある。
また，各 終了には
%中止~flag
~IN { `中止する^i, ε } が伴われ、指定されない限り ε とする。
【同じ~fetchに対し，複数の終了が生じた場合、どの %中止~flag が優先される？】
◎
An ongoing fetch can be terminated with flag aborted, which is unset unless otherwise specified.
</li>
	<li>
~UAは、進行中の~fetchを
`休止-@
するよう，請われることもある。
~UAは、その休止~要請を受容しても無視してもヨイ。
休止された~fetchは、
`再開-@
できる。
~UAは、［
進行中の~fetchが，当の要請に対する［
~HTTP~cache内の応答
］を更新している場合
］には，休止~要請を無視するベキである。
◎
The user agent may be asked to suspend the ongoing fetch. The user agent may either accept or ignore the suspension request. The suspended fetch can be resumed. The user agent should ignore the suspension request if the ongoing fetch is updating the response in the HTTP cache for the request.
</li>
</ul>

<div class="note">
<p>注記：
次のいずれかが満たされる場合、~UAは，`要請$に対する~HTTP~cache内の~entryを更新しない：
</p>

<ul ><li>要請の`~cache~mode$rq ~EQ `no-store^l
</li><li>応答の `Cache-Control$h ~header値は `no-store^dir を含む `HTTP-CACHING$r
</li></ul>
◎
The user agent does not update the entry in the HTTP cache for a request if request’s cache mode is "no-store" or a `Cache-Control: no-store` header appears in the response. [HTTP-CACHING]
</div>

<ol>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
~IF［
%要請 の`本体$rqは`~byte列$である
］
⇒
%要請 の`本体$rq ~SET 次の結果を成す`本体$
⇒
`本体と内容~型を安全に抽出する$( %要請 の`本体$rq )
◎
If request’s body is a byte sequence, then:
• Let body and ignoreType be the result of safely extracting request’s body.
• Set request’s body to body.
</li>
			<li>
~IF［
%要請 の`~window$rq ~EQ `client^l
］
⇒
%要請 の`~window$rq ~SET ［
次が満たされるならば %要請 の`~client$rq ／
~ELSE_ `no-window^l
］
⇒
%要請 の`~client$rqの`大域~obj$enVは `Window$I ~objである
◎
If request’s window is "client", set request’s window to request’s client, if request’s client’s global object is a Window object, and to "no-window" otherwise.
</li>
			<li>
~IF［
%要請 の`生成元$rq ~EQ `client^l
］
⇒
%要請 の`生成元$rq ~SET %要請 の`~client$rqの`生成元$enV
◎
If request’s origin is "client", set request’s origin to request’s client’s origin.
</li>
			<li>
<p>
~IF［
%要請 の`~header~list$rq内に［
`Accept$h を`名前に持つ~header$
］は無い
］：
◎
If request’s header list does not contain `Accept`, then:
</p>
				<ol>
					<li>
%値 ~LET `*/*^bl
◎
Let value be `*/*`.
</li>
					<li>
<p>
~UAは、 %要請 の`行先$rqに応じて，
%値 を次に与える値に設定するベキである：
◎
A user agent should set value to the first matching statement, if any, switching on request’s destination:
</p>
						<dl class="switch">
							<dt>`document^l</dt>
							<dt>`frame^l</dt>
							<dt>`iframe^l</dt>
							<dd>
`text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8^bl
</dd>

							<dt>`image^l</dt>
							<dd>

`image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5^bl
</dd>

							<dt>`style^l</dt>
							<dd>
`text/css,*/*;q=0.1^bl
</dd>
						</dl>
					</li>
					<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Accept$h / %値
)
◎
Append `Accept`/value to request’s header list.
</li>
				</ol>
			</li>
			<li>
~IF［
%要請 の`~header~list$rq内に［
`Accept-Language$h を`名前に持つ~header$
］は無い
］
⇒
~UAは、次を行うベキである
⇒
 %要請 の`~header~list$rqに`~headerを付加する$(
`Accept-Language$h / 適切な`値$hd
)
◎
If request’s header list does not contain `Accept-Language`, user agents should append `Accept-Language`/an appropriate value to request’s header list.
</li>
			<li>
<p>
~IF［
%要請 の`優先度$rq ~EQ ~NULL
］
⇒
%要請 の`優先度$rq ~SET
%要請 の［
`起動元$rq, `行先$rq
］を適切に利用して得られる，~UAにより定義される~obj
◎
If request’s priority is null, then use request’s initiator and destination appropriately in setting request’s priority to a user-agent-defined object.
</p>

<div class="note" id="_stream-priority">
<p>
注記：
~UAにより定義される~objが包摂し得るのは、次のいずれかである：
</p>

<ul><li>~HTTP2用の，~streamの［
重みと依存関係
］
</li><li>HTTP/1 ~fetchにおける［
~dispatchと処理
］に優先度を与えるために利用される，前項と等価な情報
</li></ul>

◎
The user-agent-defined object could encompass stream weight and dependency for HTTP/2, and equivalent information used to prioritize dispatch and processing of HTTP/1 fetches.
</div>
			</li>
			<li>
<p>
~IF［
%要請 は`下位資源~要請$である
］：
◎
If request is a subresource request, then:
</p>
				<ol>
					<li>
%記録 ~LET 次のようにされた，新たな`~fetch記録$
⇒＃
`要請$fg ~SET %要請；
`~fetch$fg ~SET この`~fetch$~algoの~instance
◎
Let record be a new fetch record consisting of request and this instance of the fetch algorithm.
</li>
					<li>
［
%要請 の`~client$rqの`~fetch~group$を成す，`~fetch記録$たちの~list
］に %記録 を付加する
◎
Append record to request’s client’s fetch group list of fetch records.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
前~段が`中止されたときは$
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If aborted, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
	<li>
~RET `~main~fetch$( %要請 )
◎
Return the result of performing a main fetch using request.
</li>
</ol>
</div>

		<section id="main-fetch">
<h3 title="Main fetch">4.1. ~main~fetch</h3>

<div class="algo">
<p>
`~main~fetch@
を遂行するときは、所与の
( %要請, %再帰~flag ~IN { `再帰あり^i, ε }（省略時は ε ） )
に対し，次の手続きを走らす：
◎
To perform a main fetch using request, optionally with a recursive flag, run these steps:
</p>

<p class="note">注記：
`~main~fetch$が再帰的に呼出されるときには，
%再帰~flag は `再帰あり^i にされる。
◎
When main fetch is invoked recursively recursive flag is set.
</p>
<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
~IF［
%要請 の`局所~URLのみ~flag$rq ~EQ ~T
］~AND［
%要請 の`現在の~URL$rqは`局所的$でない
］
⇒
%応答 ~SET `~network~error$
◎
If request’s local-URLs-only flag is set and request’s current URL is not local, then set response to a network error.
</li>
			<li>
%要請 に対し
<a href="~CSP3#report-for-request">~CSP違反を報告する</a>
`CSP$r
◎
Execute Report Content Security Policy violations for request. [CSP]
</li>
			<li>
<a href="~UPGRADE1#upgrade-request">適切になるなら %要請 を先天的に認証-済み~URLに昇格する</a>
`UPGRADE$r
◎
Upgrade request to a potentially secure URL, if appropriate. [UPGRADE]
</li>
			<li>
<p>
~IF［
次のいずれかの結果 ~EQ `阻止される^i
］…：
</p>

		<ul>
			<li>
%要請 の`~fetchingは，不良~portに因り阻止されるべきか？$
</li>
			<li>
<a href="~MIXED-CONTENT#should-block-fetch">%要請 の~fetchingは，混在~内容として阻止されるべきか？</a>
`MIX$r
</li>
			<li>
<a href="~CSP3#should-block-request">%要請 の~fetchingは，~CSPにより阻止されるべきか？</a>
`CSP$r
</li>
		</ul>

<p>
…ならば
⇒
%応答 ~SET `~network~error$
</p>

◎
If should fetching request be blocked due to a bad port, should fetching request be blocked as mixed content, or should fetching request be blocked by Content Security Policy returns blocked, set response to a network error. [MIX] [CSP]
</li>
			<li>
~IF［
%要請 の`~referrer施策$rq ~EQ 空~文字列
］~AND［
%要請 の`~client$rq ~NEQ ~NULL
］
⇒
%要請 の`~referrer施策$rq ~SET %要請 の`~client$rqの`~referrer施策$enV
`REFERRER$r
◎
If request’s referrer policy is the empty string and request’s client is non-null, then set request’s referrer policy to request’s client’s referrer policy. [REFERRER]
</li>
			<li>
<p>
~IF［
%要請 の`~referrer施策$rq ~EQ 空~文字列
］
⇒
%要請 の`~referrer施策$rq ~SET `no-referrer-when-downgrade^l
◎
If request’s referrer policy is the empty string, then set request’s referrer policy to "no-referrer-when-downgrade".
</p>

<p class="note">注記：
ここでは
`no-referrer-when-downgrade^l
を利用する
— それが、歴史的な既定なので。
◎
We use "no-referrer-when-downgrade" because it is the historical default.
</p>
			</li>
			<li>
<p>
~IF［
%要請 の`~referrer$rq ~NEQ `no-referrer^l
］
⇒
%要請 の`~referrer$rq ~SET
%要請 の`~referrerを決定-$した結果
`REFERRER$r
◎
If request’s referrer is not "no-referrer", set request’s referrer to the result of invoking determine request’s referrer. [REFERRER]
</p>

<p class="note">注記：
`Referrer Policy^cite 仕様に言明されている様に、~UAは，末端利用者に対し，
%要請 の`~referrer$rqを常に `no-referrer^l で上書きするような選択余地, または
より敏感でない情報を公開するような選択余地を与えることができる。
◎
As stated in Referrer Policy, user agents can provide the end user with options to override request’s referrer to "no-referrer" or have it expose less sensitive information.
</p>
			</li>
			<li>
~IF［
%要請 の`現在の~URL$rqの`~scheme$url ~EQ `ftp^l
］~AND［
%要請 の`~client$rqの`作成時の~URL$enVの`~scheme$url ~NEQ `ftp^l
］~AND［
%要請 の`予約-済み~client$rqは［
~NULL, または［
`環境$であって，その`~target閲覧文脈$enVは`入子の閲覧文脈$である
］］］
⇒
%応答 ~SET `~network~error$
◎
If request’s current URL’s scheme is "ftp", request’s client’s creation URL’s scheme is not "ftp", and request’s reserved client is either null or an environment whose target browsing context is a nested browsing context, then set response to a network error.
</li>
			<li>
<p>
~IF［
次のいずれの条件も満たされる
］…：
◎
Set request’s current URL’s scheme to "https" if all of the following conditions are true:
</p>

				<ul>
					<li>
%要請 の`現在の~URL$rqの`~scheme$url ~EQ `http^l
◎
request’s current URL’s scheme is "http"
</li>
					<li>
%要請 の`現在の~URL$rqの`~host$urlは`~domain$urlである
◎
request’s current URL’s host is a domain
</li>
					<li>
<p>
%要請 の`現在の~URL$rqの`~host$urlを
<a href="~RFCx/rfc6797#section-8.2">Known HSTS Host Domain Name Matching</a>
`HSTS$r
に従って照合した結果は、次のいずれかである：
</p>

<ul lang="en-x-a0">
<li>superdomain match with an asserted `includeSubDomains^dir directive
<li>congruent match (with or without an asserted `includeSubDomains^dir directive)
</ul>

◎
Matching request’s current URL’s host per Known HSTS Host Domain Name Matching results in either a superdomain match with an asserted includeSubDomains directive or a congruent match (with or without an asserted includeSubDomains directive). [HSTS]
</li></ul>

<p>
…ならば
⇒
%要請 の`現在の~URL$rqの`~scheme$url ~SET `https^l
◎
↑</p>

			</li>
		</ol>
	</li>
	<li>
前~段が`中止されたときは$
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If aborted, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
	<li>
~IF［
%要請 の`同期~flag$rq ~EQ ~F
］~AND［
%再帰~flag ~EQ ε
］
⇒
~RET — ただし、以降は`並列的$に走らす。
◎
If request’s synchronous flag is unset and recursive flag is unset, run the remaining steps in parallel.
</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET 次の下位手続きを走らせた結果：
◎
If response is null, then set response to the result of running the steps corresponding to the first matching statement:
</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…
</p>
				<ul>
					<li>
［
( %要請 の`現在の~URL$rqの`生成元$, %要請 の`生成元$rq )
は`同一-生成元$である
］~AND［
%要請 の`応答~tainting$rq ~EQ `basic^l
］
◎
request’s current URL’s origin is same origin with request’s origin, and request’s response tainting is "basic"
</li>
					<li>
%要請 の`現在の~URL$rqの`~scheme$url ~EQ `data^l
◎
request’s current URL’s scheme is "data"
</li>
					<li>
%要請 の`~mode$rq ~IN { `navigate^l, `websocket^l }
◎
request’s mode is "navigate" or "websocket"
</li>
				</ul>
<p>
…ならば：
</p>
				<ol>
					<li>
%要請 の`応答~tainting$rq ~SET `basic^l
◎
Set request’s response tainting to "basic".
</li>
					<li>
~RET `~scheme~fetch$( %要請 )
◎
Return the result of performing a scheme fetch using request.
</li>
				</ol>

<p class="note">注記：
~HTMLは、［
`~scheme$url ~EQ `data^l
］なる`~URL$から作成された どの［
文書 ／ ~worker
］に対しても，一意かつ`不透明な生成元$をアテガう。
~swは、［
`~scheme$url ~IN `~HTTP_S~scheme$
］なる`~URL$からのみ作成される。
`HTML$r
`SW$r
◎
HTML assigns any documents and workers created from URLs whose scheme is "data" a unique opaque origin. Service workers can only be created from URLs whose scheme is an HTTP(S) scheme. [HTML] [SW]
</p>
			</li>
			<li>
~IF［
%要請 の`~mode$rq ~EQ `same-origin^l
］
⇒
~RET `~network~error$
◎
request’s mode is "same-origin"
• Return a network error.
</li>
			<li>
<p>
~IF［
%要請 の`~mode$rq ~EQ `no-cors^l
］：
◎
request’s mode is "no-cors"
</p>
				<ol>
					<li>
~IF［
%要請 の`~redirect~mode$rq ~NEQ `follow^l
］
⇒
~RET `~network~error$
◎
If request’s redirect mode is not "follow", then return a network error.
</li>
					<li>
%要請 の`応答~tainting$rq ~SET `opaque^l
◎
Set request’s response tainting to "opaque".
</li>
					<li>
%~CORSなし要請 ~LET `~scheme~fetch$( %要請 )
◎
Let noCorsResponse be the result of performing a scheme fetch using request.
</li>
					<li>
~IF［
%~CORSなし要請 は`絞込み応答$である
］~OR［
`~CORB検査$( %要請, %~CORSなし要請 ) ~EQ `許容される^i
］
⇒
~RET %~CORSなし要請
◎
If noCorsResponse is a filtered response or the CORB check with request and noCorsResponse returns allowed, then return noCorsResponse.
</li>
					<li>
<p>
~RET 次のようにされた新たな`応答$
⇒＃
`状態s$rs ~SET %~CORSなし要請 の`状態s$rs,
`~CSP~list$rs ~SET %~CORSなし要請 の`~CSP~list$rs
◎
Return a new response whose status is noCorsResponse’s status, and CSP list is noCorsResponse’s CSP list.
</p>

<p class="warning">
これが有効な防御になるのは、~side-channel攻撃に抗することに限られる
— %~CORSなし要請 を当の要請を起動した~processから隔離し続けた場合に。
◎
This is only an effective defense against side channel attacks if noCorsResponse is kept isolated from the process that initiated the request.
</p>
					</li>
				</ol>
			</li>
			<li>
~IF［
%要請 の`現在の~URL$rqの`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET `~network~error$
◎
request’s current URL’s scheme is not an HTTP(S) scheme
• Return a network error.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
				<ul>
					<li>
%要請 の`~CORS予行~利用~flag$rq ~EQ ~T
◎
request’s use-CORS-preflight flag is set
</li>
					<li>
［
%要請 の`非安全~要請~flag$rq ~EQ ~T
］~AND［［
%要請 の`~method$rqは `~CORS安全とされる~method$でない
］~OR［
`~CORS非安全な要請~header名たち$( %要請 の`~header~list$rq ) は空でない
］］
◎
request’s unsafe-request flag is set and either request’s method is not a CORS-safelisted method or CORS-unsafe request-header names with request’s header list is not empty
</li>
				</ul>
<p>
…ならば：
</p>
				<ol>
					<li>
%要請 の`応答~tainting$rq ~SET `cors^l
◎
Set request’s response tainting to "cors".
</li>
					<li>
%~CORS予行~付き応答 ~LET `~HTTP~fetch$( %要請, `予行あり^i )
◎
Let corsWithPreflightResponse be the result of performing an HTTP fetch using request with the CORS-preflight flag set.
</li>
					<li>
~IF［
%~CORS予行~付き応答 は`~network~error$である
］
⇒
`~cache~entryを消去する$( %要請 )
◎
If corsWithPreflightResponse is a network error, then clear cache entries using request.
</li>
					<li>
~RET %~CORS予行~付き応答
◎
Return corsWithPreflightResponse.
</li>
				</ol>
			</li>
			<li>
%要請 の`応答~tainting$rq ~SET `cors^l
◎
Otherwise
• Set request’s response tainting to "cors".
</li>
			<li>
~RET `~HTTP~fetch$( %要請 )
◎
• Return the result of performing an HTTP fetch using request.
</li>
		</ol>
	</li>
	<li>
~IF［
%再帰~flag ~EQ `再帰あり^i
］
⇒
~RET %応答
◎
If the recursive flag is set, return response.
</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%応答 は`絞込み応答$でない
］：
◎
If response is not a network error and response is not a filtered response, then:
</p>
		<ol>
			<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］：
◎
If request’s response tainting is "cors", then:
</p>
				<ol>
					<li>
%~header名たち ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Expose-Headers$h )
◎
Let headerNames be the result of extracting header list values given `Access-Control-Expose-Headers` and response’s header list.
</li>
					<li>
<p>
~IF［
%~header名たち ~NIN { ~NULL, `失敗^i }
］：
◎
↓</p>
						<ol>
							<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］~AND［
`*^bl ~IN %~header名たち
］
⇒
%応答 の`~CORSに公開される~header名~list$rs ~SET
%応答 の`~header~list$rs内の各`~header$の`名前$hdからなる~list
— ここで、各~名前は，~list内で一意にする
◎
If request’s credentials mode is not "include" and headerNames contains `*`, then set response’s CORS-exposed header-name list to all unique header names in response’s header list.
</li>
							<li>
<p>
~ELSE
⇒
%応答 の`~CORSに公開される~header名~list$rs ~SET %~header名たち
◎
Otherwise, if headerNames is not null or failure, then set response’s CORS-exposed header-name list to headerNames.
</p>

<p class="note">注記：
この時点でも， %~header名たち のいずれかは `*^bl であり得るが、合致する`~header$は［
`名前$hd ~EQ `*^bl
］を満たすものに限られることになる。
◎
One of the headerNames can still be `*` at this point, but will only match a header whose name is `*`.
</p>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
%応答 ~SET
%応答 を`内部~応答$とする`絞込み応答$であって，
%要請 の`応答~tainting$rqに応じて 次で与えられるもの：
◎
Set response to the following filtered response with response as its internal response, depending on request’s response tainting:
</p>

				<dl class="switch compact">
					<dt>`basic^l</dt>
					<dd>
`基本~絞込み応答$
◎
basic filtered response
</dd>

					<dt>`cors^l</dt>
					<dd>
`~CORS絞込み応答$
◎
CORS filtered response
</dd>

					<dt>`opaque^l</dt>
					<dd>
`不透明な絞込み応答$
◎
opaque filtered response
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%内部~応答 ~LET %応答 に応じて
⇒＃
`~network~error$であるならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Let internalResponse be response, if response is a network error, and response’s internal response otherwise.
</li>
	<li>
<p>
~IF［
%内部~応答 の`~URL~list$rsは`空$である
］
⇒
%内部~応答 の`~URL~list$rs ~SET %要請 の`~URL~list$rqを`~cloneする$
◎
If internalResponse’s URL list is empty, then set it to a clone of request’s URL list.
</p>

<p class="note">注記：
`応答$の`~URL~list$rsは、空になり得る（例えば、当の応答は `about:^c ~URLを表現する場合）。
◎
A response’s URL list can be empty (for example, when the response represents an about URL).
</p>
	</li>
	<li>
~IF［
%要請 の`計時許容に失敗した~flag$rq ~EQ ~F
］
⇒
%内部~応答 の`計時許容に合格した~flag$rs ~SET ~T
◎
If request’s timing allow failed flag is unset, then set internalResponse’s timing allow passed flag.
</li>
	<li>
%内部~応答 の`~CSP~listを設定する$
`CSP$r
◎
Set internalResponse’s CSP list. [CSP]
</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
次のいずれかの結果 ~EQ `阻止される^i
］…：
◎
If response is not a network error and any of the following algorithms returns blocked, then set response and internalResponse to a network error:
</p>

		<ul>
			<li>
<a href="~MIXED-CONTENT#should-block-response">%要請 に対する %内部~応答 は，混在~内容として阻止されるべきか？</a>
`MIX$r
◎
should internalResponse to request be blocked as mixed content [MIX]
</li>
			<li>
<a href="~CSP3#should-block-response">%要請 に対する %内部~応答 は，~CSPにより阻止されるべきか？</a>
`CSP$r
◎
should internalResponse to request be blocked by Content Security Policy [CSP]
</li>
			<li>
<a href="#should-response-to-request-be-blocked-due-to-mime-type?">%要請 に対する %内部~応答 は，~MIME型に因り阻止されるべきか？</a>
◎
should internalResponse to request be blocked due to its MIME type
</li>
			<li>
<a href="#should-response-to-request-be-blocked-due-to-nosniff?">%要請 に対する %内部~応答 は，~nosniffに因り阻止されるべきか？</a>
◎
should internalResponse to request be blocked due to nosniff
</li>
		</ul>

<p>
…ならば
⇒
( %応答, %内部~応答 ) ~SET ( `~network~error$, `~network~error$ )
【！同一の個？ 】
◎
↑</p>

	</li>

	<li>
<p>
~IF［
%応答 の`種別$rs ~EQ `opaque^l
］~AND［
%内部~応答 の`状態s$rs ~EQ `206$st
］~AND［
%内部~応答 の`範囲が要請された~flag$rs ~EQ ~T
］~AND［
%要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は無い
］
⇒＃
%応答 ~SET `~network~error$；
%内部~応答 ~SET `~network~error$
◎
If response’s type is "opaque", internalResponse’s status is 206, internalResponse’s range-requested flag is set, and request’s header list does not contain `Range`, then set response and internalResponse to a network error.
</p>

<div class="note">

<p>注記：
伝統的に，~APIは、範囲が要請されなかった場合でも範囲~付き応答を受容する。
この段は、［
過去の範囲~付き要請からの部分的~応答
］が，範囲~要請を為さなかった~APIに供されることを防止する。
◎
Traditionally, APIs accept a ranged response even if a range was not requested. This prevents a partial response from an earlier ranged request being provided to an API that did not make a range request.
</p>

<details>
<summary>
この段は、次のような攻撃を防止する：
◎
Further details
◎
The above steps prevent the following attack:
</summary>

<p>
~media要素を利用して，非同一-生成元~HTML資源のある範囲が要請されたとする。
これは妥当でない~mediaになるが、応答の~cloneへの参照は，~sw内に維持され得る。
これは、後で~script要素の~fetchに対する応答として利用され得る。
部分的~応答が妥当な~JSであった場合（一体としての資源はそうでなくとも）、それを実行すると私的~dataが漏洩されることになる。
◎
A media element is used to request a range of a cross-origin HTML resource. Although this is invalid media, a reference to a clone of the response can be retained in a service worker. This can later be used as the response to a script element’s fetch. If the partial response is valid JavaScript (even though the whole resource is not), executing it would leak private data.
</p>
</details>
</div>

	</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［［
%要請 の`~method$rq ~IN { `HEAD$hm, `CONNECT$hm }
］~OR［
%内部~応答 の`状態s$rs
は `~null本体~状態s$である
］］
⇒
%内部~応答 の`本体$rs ~SET ~NULL
— 以降、本体への~enqueueはすべて~~無視する
◎
If response is not a network error and either request’s method is `HEAD` or `CONNECT`, or internalResponse’s status is a null body status, set internalResponse’s body to null and disregard any enqueuing toward it (if any).
</p>

<p class="note">注記：
これは、~HTTPに違反する~server用に ~errorの取扱いを標準~化する。
◎
This standardizes the error handling for servers that violate HTTP.
</p>
	</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%要請 の`完全性~metadata$rq ~NEQ 空~文字列
］：
◎
If response is not a network error and request’s integrity metadata is not the empty string, then:
</p>
		<ol>
			<li>
`本体を待機する$( %応答 の`本体$rs )
◎
Wait for response’s body.
</li>
			<li>
~IF［［
%応答 の`本体$rsの`~stream$bdは`~errorした$RS
］でない
］~AND［
`応答は~metadata~listに合致するか？$( %応答, %要請 の`完全性~metadata$rq ) ~EQ ~F
］
⇒
( %応答, %内部~応答 ) ~SET ( `~network~error$, `~network~error$ )
◎
If response’s body’s stream has not errored, and response does not match request’s integrity metadata, set response and internalResponse to a network error. [SRI]
</li>
		</ol>

<p class="note">注記：
これは %応答 上で演算する
— この~algoは %内部~応答 を観測するように想定されていないので。
それを許容すると、攻撃者が~hashを神託機械†（ `oracle^en ）として利用できるようになる。
<span class="trans-note">【†
— 参考：
<a href="http://security.stackexchange.com/questions/10617/what-is-a-cryptographic-oracle">cryptographic oracle</a>,
<a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">padding oracle attack</a>,
`<a href="https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%82%AA%E3%83%A9%E3%82%AF%E3%83%AB">ランダムオラクル</a>^
】</span>
◎
This operates on response as this algorithm is not supposed to observe internalResponse. That would allow an attacker to use hashes as an oracle.
</p>
	</li>
	<li>
<div class="p">
<p>
~IF［
%要請 の`同期~flag$rq ~EQ ~T
］：
</p>

<ol ><li>`本体を待機する$( %内部~応答 の`本体$rs )
</li><li>~RET %応答
</li></ol>

◎
If request’s synchronous flag is set, wait for internalResponse’s body, and then return response.
</div>

<p class="note">注記：
これは`~fetch$を終了させる。
◎
This terminates fetch.
</p>
	</li>
	<li>
<p>
~IF［
%要請 の`現在の~URL$rqの`~scheme$urlは`~HTTP_S~scheme$である
］：
◎
If request’s current URL’s scheme is an HTTP(S) scheme, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`本体$rqは`~done$bdでない
］
⇒
`並列的$に，`本体を待機する$( %要請 の`本体$rq )
◎
↓</li>
			<li>
`~fetch要請~done~taskを~queueする$( %要請 )
◎
If request’s body is done, queue a fetch-request-done task for request.
◎
Otherwise, in parallel, wait for request’s body, and then queue a fetch-request-done task for request.
</li>
		</ol>
	</li>
	<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`応答を処理する$( %応答 )
◎
Queue a fetch task on request to process response for response.
</li>
	<li>
`本体を待機する$( %内部~応答 の`本体$rs )
◎
Wait for internalResponse’s body.
</li>
	<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`応答の本体終端を処理する$( %応答 )
◎
Queue a fetch task on request to process response end-of-body for response.
</li>
	<li>
%要請 の`~done~flag$rq ~SET ~T
◎
Set request’s done flag.
</li>
	<li>
%要請 上で次を走らすための`~fetch~taskを~queueする$
⇒
`応答の~doneを処理する$( %応答 )
◎
Queue a fetch task on request to process response done for response.
</li>
</ol>
</div>

		</section>
		<section id="scheme-fetch">
<h3 title="Scheme fetch">4.2. ~scheme~fetch</h3>

<div class="algo">
<p>
`~scheme~fetch@
を遂行するときは、所与の
( %要請 )
に対し，［
%要請 の`現在の~URL$rq の`~scheme$urlに応じて，次の中から 対応する手続き
］を走らす：
◎
To perform a scheme fetch using request, switch on request’s current URL’s scheme, and run the associated steps:
</p>

<dl class="switch">
	<dt>`about^l</dt>
	<dd>
		<ol>
			<li>
%~url ~LET %要請 の`現在の~URL$rq
◎
↓</li>
			<li>
~IF［
%~url の`基底~URL不可用~flag$url ~EQ ~T
］~AND［
%~url の`~path$urlは 単独の文字列 `blank^l からなる
］
⇒
~RET 次のように設定された，新たな`応答$
⇒＃
`状態s~message$rs ~SET `OK^bl,
`~header~list$rs ~SET « `新たな~header$( `Content-Type$h / `text/html;charset=utf-8^bl ) »,
`本体$rs ~SET 空~byte列
◎
If request’s current URL’s cannot-be-a-base-URL flag is set and path contains a single string "blank", then return a new response whose status message is `OK`, header list consist of a single header whose name is `Content-Type` and value is `text/html;charset=utf-8`, and body is the empty byte sequence.
</li>
			<li>
~RET `~network~error$
◎
Otherwise, return a network error.
</li>
		</ol>

<p class="note">注記：
`about:config^l に類する`~URL$は、`~navi$の間に取扱われ，`~fetch$の文脈~下では`~network~error$になる。
◎
URLs such as "about:config" are handled during navigation and result in a network error in the context of fetching.
</p>

	</dd>

	<dt>`blob^l</dt>
	<dd>
		<ol>
			<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
				<ol>

					<li>
%blob ~LET %要請 の`現在の~URL$rqの`~blob~URL~entry$urlの`~obj$bU
◎
Let blob be request’s current URL’s blob URL entry’s object.
</li>
					<li>
<p>
~IF［
%要請 の`~method$rq ~NEQ `GET$hm
］~OR［
%blob は `Blob$I ~objでない `FILEAPI$r
］
⇒
~RET `~network~error$
◎
If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]
</p>

<p class="note">注記：
`GET^hm `~method$の制約には、相互運用可能にする以外に有用な目的はない。
◎
The `GET` method restriction serves no useful purpose other than being interoperable.
</p>

					</li>
					<li>
%応答 ~LET 次のように設定された，新たな`応答$
⇒
`状態s~message$rs ~SET `OK^bl
◎
Let response be a new response whose status message is `OK`.
</li>
					<li>
%応答 の`~header~list$rsに`~headerを付加する$(
`Content-Length$h / %blob の `size$mF 属性~値
)
◎
Append `Content-Length`/blob’s size attribute value to response’s header list.
</li>
					<li>
%応答 の`~header~list$rsに`~headerを付加する$(
`Content-Type$h / %blob の `type$mF 属性~値
)
◎
Append `Content-Type`/blob’s type attribute value to response’s header list.
</li>
					<li>
%応答 の`本体$rs ~SET
%blob 上で`読取n演算$を遂行した結果
◎
Set response’s body to the result of performing the read operation on blob.
</li>
					<li>
~RET %応答
◎
Return response.
</li>
				</ol>
			</li>
			<li>
前~段が`中止されたときは$
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If aborted, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
		</ol>
	</dd>

	<dt>`data^l</dt>
	<dd>
		<ol>
			<li>
%~dataURL構造体 ~LET `~data_URL処理器$( %要請 の`現在の~URL$rq )
◎
Let dataURLStruct be the result of running the data: URL processor on request’s current URL.
</li>
			<li>
~IF［
%~dataURL構造体 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If dataURLStruct is failure, then return a network error.
</li>
			<li>
~RET 次のように設定された，新たな`応答$
⇒＃
`状態s~message$rs ~SET `OK^bl,
`~header~list$rs ~SET « `新たな~header$( `Content-Type$h / `~MIME型を~byte列に直列化する$( %~dataURL構造体 の`~MIME型$dU ) ) »,
`本体$rs ~SET %~dataURL構造体 の`本体$dU
◎
Return a response whose status message is `OK`, header list consist of a single header whose name is `Content-Type` and value is dataURLStruct’s MIME type, serialized, and body is dataURLStruct’s body.
</li>
		</ol>
	</dd>

	<dt>`file^l</dt>
	<dd>
今の所、あいにく file `~URL$については， `left as an exercise for the reader^en である。
【実装に委ねられる】
◎
For now, unfortunate as it is, file URLs are left as an exercise for the reader.
</dd>
	<dd>
疑わしい場合は`~network~error$を返すこと。
◎
When in doubt, return a network error.
</dd>

	<dt>`ftp^l</dt>
	<dd>
<p>
今の所、あいにく ftp `~URL$については，ほぼ `left as an exercise for the reader^en である。
◎
For now, unfortunate as it is, ftp URLs are mostly left as an exercise for the reader.
</p>
		<ol>
			<li>
%本体 ~LET ~FTPを介して~network越しに %要請 の`現在の~URL$rqから内容を得した結果
`RFC959$r
◎
Let body be the result of the user agent obtaining content from request’s current URL from the network via FTP. [RFC959]
</li>
			<li>
%~MIME型 ~LET `application/octet-stream^bl
◎
Let mime be `application/octet-stream`.
</li>
			<li>
~IF［
%本体 は，~UAが，~FTPの `LIST^c ~commandの結果~用に［
~directoryを~listする~page
］を生成した結果である
］
⇒
%~MIME型 ~SET `text/ftp-dir^bl
◎
If body is the result of the user agent generating a directory listing page for the result of FTP’s LIST command, then set mime to `text/ftp-dir`.
</li>
			<li>
~RET 次のように設定された，新たな`応答$
⇒＃
`状態s~message$rs ~SET `OK^bl,
`~header~list$rs ~SET « `新たな~header$( `Content-Type$h / %~MIME型 ) »,
`本体$rs ~SET %本体
◎
Return a response whose status message is `OK`, header list consists of a single header whose name is `Content-Type` and whose value is mime, and body is body.
</li>
		</ol>
	</dd>
	<dd>
疑わしい場合は`~network~error$を返すこと。
◎
When in doubt, return a network error.
</dd>

	<dt>`~HTTP_S~scheme$</dt>
	<dd>
~RET `~HTTP~fetch$( %要請 )
◎
Return the result of performing an HTTP fetch using request.
</dd>

	<dt>
その他
◎
Otherwise
</dt>
	<dd>
~RET `~network~error$
◎
Return a network error.
</dd>
</dl>
</div>

		</section>
		<section id="http-fetch">
<h3 title="HTTP fetch">4.3. ~HTTP~fetch</h3>

<div class="algo">
<p>
`~HTTP~fetch@
を遂行するときは、所与の
( %要請, %~CORS予行~flag ~IN { `予行あり^i, ε }（省略時は ε ） )
に対し，次の手続きを走らす：
◎
To perform an HTTP fetch using request with an optional CORS-preflight flag, run these steps:
</p>

<p class="note">注記：
%~CORS予行~flag は、ここでも内部状態管理に用いられ，非 ε（ `予行あり^i ）ならば`~CORS予行~要請$が必要になることを指示する。
◎
The CORS-preflight flag bookkeeping detail indicates a CORS-preflight request is needed.
</p>

<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%実際の応答 ~LET ~NULL
◎
Let actualResponse be null.
</li>
	<li>
<p>
~IF［
%要請 の`~sw~mode$rq ~EQ `all^l
］：
◎
If request’s service-workers mode is "all", then:
</p>
		<ol>
			<li>
%応答 ~SET %要請 に対し
<a href="~SW1#handle-fetch">~fetchを取扱った</a>
結果
`HTML$r
`SW$r
◎
Set response to the result of invoking handle fetch for request. [HTML] [SW]
</li>
			<li>
<p>
~IF［
%応答 ~NEQ ~NULL
］：
◎
If response is not null, then:
</p>
				<ol>
					<li>
`要請~用の本体を伝送する$( %要請 )
◎
Transmit body for request.
</li>
					<li>
%実際の応答 ~SET %応答 に応じて
⇒＃
`絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Set actualResponse to response, if response is not a filtered response, and to response’s internal response otherwise.
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>
						<ul>
							<li>
%応答 の`種別$rs ~EQ `error^l
◎
response’s type is "error"
</li>
							<li>
［
%要請 の`~mode$rq ~EQ `same-origin^l
］~AND［
%応答 の`種別$rs ~EQ `cors^l
］
◎
request’s mode is "same-origin" and response’s type is "cors"
</li>
							<li>
［
%要請 の`~mode$rq ~NEQ `no-cors^l
］~AND［
%応答 の`種別$rs ~EQ `opaque^l
］
◎
request’s mode is not "no-cors" and response’s type is "opaque"
</li>
							<li>
［
%要請 の`~redirect~mode$rq ~NEQ `manual^l
］~AND［
%応答 の`種別$rs ~EQ `opaqueredirect^l
］
◎
request’s redirect mode is not "manual" and response’s type is "opaqueredirect"
</li>
							<li>
［
%要請 の`~redirect~mode$rq ~NEQ `follow^l
］~AND［
%応答 の`~URL~list$rs内に複数の~itemがある
］
◎
request’s redirect mode is not "follow" and response’s URL list has more than one item.
</li>
						</ul>
<p>
…ならば
⇒
~RET `~network~error$：
◎
then return a network error.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~CORS予行~flag ~EQ `予行あり^i
］~AND［
次のいずれかが満たされる
］…：
◎
If the CORS-preflight flag is set and one of these conditions is true:
</p>

				<ul>
					<li>
<p>
［
`~methodも合致している~cache~entry$( %要請, %要請 の`~method$rq ) は空である
］~AND［
%要請 は、次のいずれかを満たす
］：
</p>

<ul><li>`~method$rqは `~CORS安全とされる~method$でない
</li><li>`~CORS予行~利用~flag$rq ~EQ ~T
</li></ul>

◎
There is no method cache entry match for request’s method using request, and either request’s method is not a CORS-safelisted method or request’s use-CORS-preflight flag is set.
</li>
					<li>
`~CORS非安全な要請~header名たち$( %要請 の`~header~list$rq )
内のある名前に対し
⇒
`~header名も合致している~cache~entry$( %要請, 名前 ) は空である
◎
There is at least one item in the CORS-unsafe request-header names with request’s header list for which there is no header-name cache entry match using request.
</li>
				</ul>
<p>
…ならば：
◎
Then:
</p>
				<ol>
					<li>
%予行~応答 ~LET `~CORS予行~fetch$( %要請 )
◎
Let preflightResponse be the result of performing a CORS-preflight fetch using request.
</li>
					<li>
~IF［
%予行~応答 は`~network~error$である
］
⇒
~RET %予行~応答
◎
If preflightResponse is a network error, then return preflightResponse.
</li>
				</ol>

<p class="note">注記：
この段は、`~CORS予行~cache$を検査した上で，相応しい~entryがなければ`~CORS予行~fetch$を遂行し、成功したならば この~cacheを拡充する。
`~CORS予行~fetch$の目的は、`~fetch$された資源が`~CORS~protocol$下に~~置かれることを確保することである。
この~cacheは、`~CORS予行~fetch$の回数を最小限にするためにある。
◎
This step checks the CORS-preflight cache and if there is no suitable entry it performs a CORS-preflight fetch which, if successful, populates the cache. The purpose of the CORS-preflight fetch is to ensure the fetched resource is familiar with the CORS protocol. The cache is there to minimize the number of CORS-preflight fetches.
</p>

			</li>
			<li>
<p>
~IF［
%要請 の`~redirect~mode$rq ~EQ `follow^l
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
◎
If request’s redirect mode is "follow", then set request’s service-workers mode to "none".
</p>

<p class="note">注記：
（~swとは~~対照的に）~networkから来る~redirectは、~swには公開されない。
◎
Redirects coming from the network (as opposed to from a service worker) are not to be exposed to a service worker.
<p>
			</li>
			<li>
%実際の応答 ~SET `~HTTP~network-or-cache~fetch$( %要請 )
◎
Set response and actualResponse to the result of performing an HTTP-network-or-cache fetch using request.
</li>
			<li>
%応答 ~SET %実際の応答
◎
↑</li>
			<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~AND［
`~CORS検査$( %要請, %応答 ) ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If request’s response tainting is "cors" and a CORS check for request and response returns failure, then return a network error.
</p>

<p class="note">注記：
`~CORS検査$は、［
`状態s$rs ~IN { `304$st, `407$st } なる`応答$ ／
それが~~懸案になる~swからの`応答$
］には適用されないので、ここで適用される。
◎
As the CORS check is not to be applied to responses whose status is 304 or 407, or responses from a service worker for that matter, it is applied here.
</p>
			</li>
			<li>
~IF［
`~TAO検査$( %要請, %応答 ) ~EQ `失敗^i
］
⇒
%要請 の`計時許容に失敗した~flag$rq ~SET ~T
◎
If the TAO check for request and response returns failure, then set request’s timing allow failed flag.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`opaque^l ~IN { %要請 の`応答~tainting$rq, %応答 の`種別$rs }
］~AND［
`非同一-生成元~資源~施策~検査$( %要請 の`生成元$rq, %要請 の`~client$rq, %要請 の`行先$rq, %実際の応答 )
~EQ `阻止される^i
］
⇒
~RET `~network~error$
◎
If either request’s response tainting or response’s type is "opaque", and the cross-origin resource policy check with request’s origin, request’s client, request’s destination, and actualResponse returns blocked, then return a network error.
</p>

<p class="note">注記：
`非同一-生成元~資源~施策~検査$は、［
~network／~sw
］から来た応答~用に走る。
これは、`~CORS検査$とは異なる
— ［
%要請 の`~client$rq,
~sw
］の埋込元~施策は異なり得るので。
◎
The cross-origin resource policy check runs for responses coming from the network and responses coming from the service worker. This is different from the CORS check, as request’s client and the service worker can have different embedder policies.
</p>
	</li>
	<li>
<p>
~IF［
%実際の応答 の`状態s$rsは`~redirect状態s$である
］：
◎
If actualResponse’s status is a redirect status, then:
</p>
		<ol>
			<li>
<p>
~IF［
%実際の応答 の`状態s$rs ~NEQ `303$st
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
`接続$は~HTTP2を利用している
］
⇒
~UAは `RST_STREAM^c ~frameを伝送してもヨイ
— また，そうすることが奨励される。
◎
If actualResponse’s status is not 303, request’s body is not null, and the connection uses HTTP/2, then user agents may, and are even encouraged to, transmit an RST_STREAM frame.
</p>

<p class="note">注記：
ある種の~communityにおいては、
`303$st は特別な状態sに帰するとみなされ，除外される。
◎
303 is excluded as certain communities ascribe special status to it.
</p>

			</li>
			<li>
%所在 ~LET `~header~listから値を抽出する$( %実際の応答 の`~header~list$rs, `Location$h )
◎
Let location be the result of extracting header list values given `Location` and actualResponse’s header list.
</li>
			<li>
~IF［
%所在 は`値$hdである
］
⇒
%所在 ~SET `~URL構文解析する$( %所在, %実際の応答 の`~URL$rs )
◎
If location is a value, then set location to the result of parsing location with actualResponse’s URL.
</li>
			<li>
%実際の応答 の`~Location~header~URL$rs ~SET %所在
◎
Set actualResponse’s location URL to location.
</li>
			<li>
<p>
%要請 の`~redirect~mode$rq に応じて：
◎
Switch on request’s redirect mode:
</p>

				<dl class="switch">
					<dt>`error^l</dt>
					<dd>
%応答 ~SET `~network~error$
◎
Set response to a network error.
</dd>

					<dt>`manual^l</dt>
					<dd>
%応答 ~SET `内部~応答$が %実際の応答 にされた，`不透明~redirect絞込み応答$
◎
Set response to an opaque-redirect filtered response whose internal response is actualResponse.
</dd>

					<dt>`follow^l</dt>
					<dd>
%応答 ~SET `~HTTP~redirect~fetch$( %要請, %応答 )
◎
Set response to the result of performing HTTP-redirect fetch using request and response.
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
<p>
~RET %応答
◎
Return response.＼
</p>

<p class="note">注記：
手続きはここで終わるが、その後も概して，
%実際の応答 の`本体$rsの`~stream$bdには ~byte列が~enqueueされ続ける。
◎
Typically actualResponse’s body’s stream is still being enqueued to after returning.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="http-redirect-fetch">
<h3 title="HTTP-redirect fetch">4.4. ~HTTP~redirect~fetch</h3>

<p class="note">注記：
この~algoは、上述の`~HTTP~fetch$に加えて，~HTMLの`~navigate~algo$からも利用される。
`HTML$r
◎
This algorithm is used by HTML’s navigate algorithm in addition to HTTP fetch above. [HTML]
</p>

<div class="algo">
<p>
`~HTTP~redirect~fetch@
を遂行するときは、所与の
( %要請, %応答 )
に対し，次の手続きを走らす：
◎
To perform an HTTP-redirect fetch using request and response, run these steps:
</p>
<ol>
	<li>
%実際の応答 ~LET %応答 に応じて
⇒＃
`絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Let actualResponse be response, if response is not a filtered response, and response’s internal response otherwise.
</li>
	<li>
%所在 ~LET %実際の応答 の`~Location~header~URL$rs
◎
↓</li>
	<li>
~IF［
%所在 ~EQ ~NULL
］
⇒
~RET %応答
◎
If actualResponse’s location URL is null, then return response.
</li>
	<li>
~IF［
%所在 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If actualResponse’s location URL is failure, then return a network error.
</li>
	<li>
~IF［
%所在 の`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET `~network~error$
◎
If actualResponse’s location URL’s scheme is not an HTTP(S) scheme, then return a network error.
</li>
	<li>
~IF［
%要請 の`~redirect数$rq ~EQ 20
］
⇒
~RET `~network~error$
◎
If request’s redirect count is twenty, return a network error.
</li>
	<li>
%要請 の`~redirect数$rq ~INCBY 1
◎
Increase request’s redirect count by one.
</li>
	<li>
~IF［
%要請 の`~mode$rq ~EQ `cors^l
］~AND［
%所在 は`資格証を含む$url
］~AND［
( %要請 の`生成元$rq, %所在 の`生成元$url )
は`同一-生成元$`でない^em
］
⇒
~RET `~network~error$
◎
If request’s mode is "cors", actualResponse’s location URL includes credentials, and request’s origin is not same origin with actualResponse’s location URL’s origin, then return a network error.
</li>
	<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~AND［
%所在 は`資格証を含む$url
］
⇒
~RET `~network~error$
◎
If request’s response tainting is "cors" and actualResponse’s location URL includes credentials, then return a network error.
</p>

<p class="note">注記：
これは、非同一-生成元~資源による同一-生成元~URLへの~redirectを捕える。
◎
This catches a cross-origin resource redirecting to a same-origin URL.
</p>
	</li>
	<li>
~IF［
%実際の応答 の`状態s$rs ~NEQ `303$st
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If actualResponse’s status is not 303, request’s body is non-null, and request’s body’s source is null, then return a network error.
</li>
	<li>
~IF［
( %所在 の`生成元$url, %要請 の`現在の~URL$rqの`生成元$rq )
は`同一-生成元$でない
］~AND［
( %要請 の`生成元$url, %要請 の`現在の~URL$rqの`生成元$rq )
は`同一-生成元$でない
］
⇒
%要請 の`~tainted生成元~flag$rq ~SET ~T
◎
If actualResponse’s location URL’s origin is not same origin with request’s current URL’s origin and request’s origin is not same origin with request’s current URL’s origin, then set request’s tainted origin flag.
</li>
	<li>
<p>
~IF［［
%実際の応答 の`状態s$rs ~IN { `301$st, `302$st }
］~AND［
%要請 の`~method$rq ~EQ `POST$hm
］］~OR［［
%実際の応答 の`状態s$rs ~EQ `303$st
］~AND［
%要請 の`~method$rq ~NIN { `GET$hm, `HEAD$hm }
］］：
◎
If one of the following is true
• actualResponse’s status is 301 or 302 and request’s method is `POST`
• actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`
◎
then:
</p>
		<ol>
			<li>
%要請 の
⇒＃
`~method$rq ~SET `GET$hm；
`本体$rq ~SET ~NULL
◎
Set request’s method to `GET` and request’s body to null.
</li>
			<li>
`要請~本体~header名$を成す
~EACH( %~header名 )
に対し
⇒
%要請 の`~header~list$rqから`~headerを削除する$( %~header名 )
◎
For each headerName of request-body-header name, delete headerName from request’s header list.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］
⇒
%要請 の`本体$rq ~SET 次の結果を成す`本体$
⇒
`本体と内容~型を安全に抽出する$( %要請 の`本体$rqの`~source$bd )
◎
If request’s body is non-null, then set request’s body to the first return value of safely extracting request’s body’s source.
</p>

<p class="note">注記：
`~source$bdが ~NULL でないことは、すでに検査~済み。
◎
request’s body’s source’s nullity has already been checked.
</p>
	</li>
	<li>
%要請 の`~URL~list$rqに %所在 を付加する
◎
Append actualResponse’s location URL to request’s URL list.
</li>
	<li>
`~referrer施策を設定する$( %要請, %実際の応答 )
`REFERRER$r
◎
Invoke set request’s referrer policy on redirect on request and actualResponse. [REFERRER]
</li>
	<li>
<p>
~RET `~main~fetch$( %要請, 次に与える値 )
⇒
［
%要請 の`~redirect~mode$rq ~NEQ `manual^l
］ならば `再帰あり^i ／
~ELSE_ ε
◎
Return the result of performing a main fetch using request with recursive flag set if request’s redirect mode is not "manual".
</p>

<p class="note">注記：
ここで `manual^l になるのは、この~algoが~HTMLの`~navigate~algo$から直に呼出されたときに限られる。
◎
It can only be "manual" here when this algorithm is invoked directly from HTML’s navigate algorithm.
</p>

<p class="note">注記：
`応答~tainting$rqが正しくなるようにするため、`~main~fetch$を呼出す必要がある。
◎
This has to invoke main fetch to get response tainting correct.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="http-network-or-cache-fetch">
<h3 title="HTTP-network-or-cache fetch">4.5. ~HTTP~network-or-cache~fetch</h3>

<div class="algo">
<p>
`~HTTP~network-or-cache~fetch@
を遂行するときは、所与の
( %要請, %認証~fetch~flag ~IN { `認証あり^i, ε }（省略時は ε ） )
に対し，次の手続きを走らす：
◎
To perform an HTTP-network-or-cache fetch using request with an optional authentication-fetch flag, run these steps:
</p>

<p class="note">注記：
%認証~fetch~flag は、内部状態管理に用いられる。
◎
The authentication-fetch flag is a bookkeeping detail.
</p>

<p class="note">注記：
`HTTP Range Requests^cite `HTTP-RANGE$r
にしたがって，`部分的~内容$の~cache法を~supportする実装もあるが、~browser~cacheからは広く~supportされていない。
◎
Some implementations might support caching of partial content, as per HTTP Range Requests. [HTTP-RANGE] However, this is not widely supported by browser caches.
</p>

<ol>
	<li>
%~http要請 ~LET ~NULL
◎
Let httpRequest be null.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%格納-済み応答 ~LET ~NULL
◎
Let storedResponse be null.
</li>
	<li>
%~http~cache ~LET ~NULL
◎
Let httpCache be null.
</li>
	<li>
%再検証中~flag ~LET ~F
◎
Let the revalidatingFlag be unset.
</li>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
~IF［
%要請 の`~window$rq ~EQ `no-window^l
］~AND［
%要請 の`~redirect~mode$rq ~EQ `error^l
］
⇒
%~http要請 ~SET %要請
◎
If request’s window is "no-window" and request’s redirect mode is "error", then set httpRequest to request.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~http要請 ~SET %要請 の`本体$rqを除いた部分の複製
◎
Set httpRequest to a copy of request except for its body.
</li>
					<li>
%本体 ~LET %要請 の`本体$rq
◎
Let body be request’s body.
</li>
					<li>
%~http要請 の`本体$rq ~SET %本体
◎
Set httpRequest’s body to body.
</li>
					<li>
~IF［
%本体 ~NEQ ~NULL
］
⇒
%要請 の`本体$rq ~SET 次のようにされた新たな`本体$
⇒＃
`~stream$bd ~SET ~NULL；
`~source$bd ~SET %本体 の`~source$bd
◎
If body is non-null, then set request’s body to a new body whose stream is null and whose source is body’s source.
</li>
				</ol>

<p class="note">注記：
%要請 は複製される
— ここでの %~http要請 は、 %要請 に影響させずに， ~headerを追加できたり, その`本体$rqを読取れるようにする必要があるので。
すなわち、 %要請 は［
~redirect ／ 認証 ／ ~proxy認証
］にて再利用できる。
また，~memory消費を抑制するため、~cloneせずに複製する。
［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］の事例で［
~redirect ／ 認証
］が生じた場合、~fetchは失敗することになる。
◎
request is copied as httpRequest here as we need to be able to add headers to httpRequest and read its body without affecting request. Namely, request can be reused with redirects, authentication, and proxy authentication. We copy rather than clone in order to reduce memory consumption. In case request’s body’s source is null, redirects and authentication will end up failing the fetch.
</p>
			</li>
			<li>
<p>
%資格証~flag ~LET ［
次のいずれかが満たされるならば ~T ／
~ELSE_ ~F
］：
◎
Let credentials flag be set if one of
</p>
				<ul>
					<li>
%要請 の`資格証~mode$rq ~EQ `include^l
◎
request’s credentials mode is "include"
</li>
					<li>
［
%要請 の`資格証~mode$rq ~EQ `same-origin^l
］~AND［
`応答~tainting$rq ~EQ `basic^l
］
◎
request’s credentials mode is "same-origin" and request’s response tainting is "basic"
</li>
				</ul>
<p>　
◎
is true, and unset otherwise.
</p>
			</li>
			<li>
%Content-Length値 ~LET ~NULL
◎
Let contentLengthValue be null.
</li>
			<li>
~IF［
%~http要請 の`本体$rq ~EQ ~NULL
］~AND［
%~http要請 の`~method$rq ~IN
{ `POST$hm, `PUT$hm }
］
⇒
%Content-Length値 ~SET `0^bl
◎
If httpRequest’s body is null and httpRequest’s method is `POST` or `PUT`, then set contentLengthValue to `0`.
</li>
			<li>
~IF［
%~http要請 の`本体$rq ~NEQ ~NULL
］~AND［
%~http要請 の`本体$rqの`~source$bd ~NEQ ~NULL
］
⇒
%Content-Length値 ~SET `同型に符号化する$( `整数を直列化する$( %~http要請 の`本体$rqの`総~byte数$bd ) )
◎
If httpRequest’s body is non-null and httpRequest’s body’s source is non-null, then set contentLengthValue to httpRequest’s body’s total bytes, serialized and isomorphic encoded.
</li>
			<li>
~IF［
%Content-Length値 ~NEQ ~NULL
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Content-Length$h / %Content-Length値
)
◎
If contentLengthValue is non-null, append `Content-Length`/contentLengthValue to httpRequest’s header list.
</li>
			<li>
<p>
~IF［
%Content-Length値 ~NEQ ~NULL
］~AND［
%~http要請 の`~keepalive~flag$rq ~EQ ~T
］：
◎
If contentLengthValue is non-null and httpRequest’s keepalive flag is set, then:
</p>
				<ol>
					<li>
%~inflight~keepalive~byte数 ~LET 0
◎
Let inflightKeepaliveBytes be zero.
</li>
					<li>
%~group ~LET %~http要請 の`~client$rqの`~fetch~group$
◎
Let group be httpRequest’s client’s fetch group.
</li>
					<li>
%~inflight記録~list ~LET ［
%~group 内の`~fetch記録$のうち，その`要請$fgが次を満たすもの
］からなる同順の~list
⇒
［
`~keepalive~flag$rq ~EQ ~T
］~AND［
`~done~flag$rq ~EQ ~F
］
◎
Let inflightRecords be the set of fetch records in group whose request has its keepalive flag set and done flag unset.
</li>
					<li>
<p>
%~inflight記録~list 内の
~EACH( %~fetch記録 )
に対し：
◎
For each fetchRecord in inflightRecords:
</p>
						<ol>
							<li>
%~inflight要請 ~LET %~fetch記録 の`要請$fg
◎
Let inflightRequest be fetchRecord’s request.
</li>
							<li>
%~inflight~keepalive~byte数 ~INCBY
%~inflight要請 の`本体$rqの`総~byte数$bd
◎
Increment inflightKeepaliveBytes by inflightRequest’s body’s total bytes.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
( %Content-Length値 ~PLUS %~inflight~keepalive~byte数 ) ~GT 64 KiB
］
⇒
~RET `~network~error$
◎
If the sum of contentLengthValue and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
</p>

<p class="note">注記：
この~~上限 64 KiB 【 `kibibyte^en — 1024 ~byte単位】は、［
`環境~設定群~obj$の外で残存することが許容され, 本体を包含する要請
【~CSP違反~報告など】
］に対し、その~sizeには上限があり，要請が不定期に残り続けないことを確保するためにある。
◎
The above limit ensures that requests that are allowed to outlive the environment settings object and contain a body, have a bounded size and are not allowed to stay alive indefinitely.
</p>
					</li>
				</ol>
			</li>
			<li>
~IF［
%~http要請 の`~referrer$rqは`~URL$である
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Referer$h / 次の結果
)
⇒
`同型に符号化する$( `~URLを直列化する$( %~http要請 の`~referrer$rq ) )
◎
If httpRequest’s referrer is a URL, then append `Referer`/httpRequest’s referrer, serialized and isomorphic encoded, to httpRequest’s header list.
</li>
			<li>
`要請~Origin~headerを付加する$( %~http要請 )
◎
Append a request `Origin` header for httpRequest.
</li>
			<li>
~IF［
%~http要請 の`~header~list$rq内に［
`User-Agent$h を`名前に持つ~header$
］は無い
］
⇒
~UAは、次を行うベキである
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`User-Agent$h / `既定の User-Agent 値$
)
◎
If httpRequest’s header list does not contain `User-Agent`, then user agents should append `User-Agent`/default `User-Agent` value to httpRequest’s header list.
</li>
					<li>
~IF［
%~http要請 の`~cache~mode$rq ~EQ `default^l
］~AND［
%~http要請 の`~header~list$rq内に［
`If-Modified-Since$h ／
`If-None-Match$h ／
`If-Unmodified-Since$h ／
`If-Match$h ／
`If-Range$h
］を`名前に持つ~header$は在る
］
⇒
%要請 の`~cache~mode$rq ~SET `no-store^l
◎
If httpRequest’s cache mode is "default" and httpRequest’s header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set httpRequest’s cache mode to "no-store".
</li>
			<li>
~IF［
%~http要請 の`~cache~mode$rq ~EQ `no-cache^l
］~AND［
%~http要請 の`~no-cache時に~cache制御~headerを改変しない~flag$rq ~EQ ~F
］~AND［
%~http要請 の`~header~list$rq内に［
`Cache-Control$h を`名前に持つ~header$
］は無い
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Cache-Control$h / `max-age=0^bl
)
◎
If httpRequest’s cache mode is "no-cache", httpRequest’s prevent no-cache cache-control header modification flag is unset, and httpRequest’s header list does not contain `Cache-Control`, then append `Cache-Control`/`max-age=0` to httpRequest’s header list.
</li>
			<li>
<p>
~IF［
%~http要請 の`~cache~mode$rq ~IN
{ `no-store^l, `reload^l }
］：
◎
If httpRequest’s cache mode is "no-store" or "reload", then:
</p>
				<ol>
					<li>
~IF［
%~http要請 の`~header~list$rq内に［
`Pragma$h を`名前に持つ~header$
］は無い
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Pragma$h / `no-cache^bl
)
◎
If httpRequest’s header list does not contain `Pragma`, then append `Pragma`/`no-cache` to httpRequest’s header list.
</li>
					<li>
~IF［
%~http要請 の`~header~list$rq内に［
`Cache-Control$h を`名前に持つ~header$
］は無い
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Cache-Control$h / `no-cache^bl
)
◎
If httpRequest’s header list does not contain `Cache-Control`, then append `Cache-Control`/`no-cache` to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~http要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は在る
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Accept-Encoding$h / `identity^bl
)
◎
If httpRequest’s header list contains `Range`, then append `Accept-Encoding`/`identity` to httpRequest’s header list.
</p>

<div class="note">

<p>注記：
これは、符号化された`応答$の ある部位に対し `内容~符号法sを取扱う$ときの失敗を避ける。
◎
This avoids a failure when handling content codings with a part of an encoded response.
</p>

<p>
加えて，
<a href="https://jakearchibald.github.io/accept-encoding-range-test/">多くの~server</a>
は、［
`identity^bl でない符号化法を受容する場合には、 `Range$h ~headerは無視する
］ものと誤認している。
◎
Additionally, many servers mistakenly ignore `Range` headers if a non-identity encoding is accepted.
</p>
</div>

	</li>
	<li>
<p>
~HTTPに則って %~http要請 の`~header~list$rqを改変する
— %~http要請 の`~header~list$rq内に［
所与の`~header$の`名前$hdを`名前に持つ~header$
］が在る場合には、それを
<a href="#concept-header-list-append">付加-</a>しないこと。
◎
Modify httpRequest’s header list per HTTP. Do not append a given header if httpRequest’s header list contains that header’s name.
</p>

<p class="note">注記：
この段は、何かもっと規範的な形にしたい。
次に挙げる`~header$などは、この時点で必要に応じて
<a href="#concept-header-list-append">付加される</a>
⇒
`Accept-Encoding$h,
`Connection$h,
`DNT^h,
`Host$h
◎
It would be great if we could make this more normative somehow. At this point headers such as `Accept-Encoding`, `Connection`, `DNT`, and `Host`, are to be appended if necessary.
</p>

<p>
この時点では、次に挙げる`~header$は含ませないモノトスル
⇒
`Accept$h,
`Accept-Charset$h,
`Accept-Language$h
◎
`Accept`, `Accept-Charset`, and `Accept-Language` must not be included at this point.
</p>

<p class="note">注記：
`Accept$h, `Accept-Language$h
は、すでに含められている（
`fetch()$m が利用されていない限り
— それは、既定では後者を含めない）。
また、 `Accept-Charset$h を含めても，~byte列を浪費するだけである。
詳細は、
<a href="#http-header-layer-division">~HTTP~header層の~~区分</a>
を見よ。
◎
`Accept` and `Accept-Language` are already included (unless fetch() is used, which does not include the latter by default), and `Accept-Charset` is a waste of bytes. See HTTP header layer division for more details.
</p>

			</li>
			<li>
<p>
`(A)^i：<br>
~IF［
%資格証~flag ~EQ ~T
］：
◎
If credentials flag is set, then:
</p>
				<ol>
					<li>
<p>
~IF［
~UAは %~http要請 用の~cookieを阻止するように環境設定されていない（
`COOKIES$r の
<a href="~HTTPcookie#privacy-considerations">§ 7</a>
を見よ）
］：
◎
If the user agent is not configured to block cookies for httpRequest (see section 7 of [COOKIES]), then:
</p>
						<ol>
							<li>
%~cookie ~LET
( ~UAの~cookie保管庫, %~http要請 の`現在の~URL$rq )
を与える下で
"cookie-string" ~algo（
`COOKIES$r の
<a href="~HTTPcookie#cookie">§ 5.4</a>
）を走らせた結果
◎
Let cookies be the result of running the "cookie-string" algorithm (see section 5.4 of [COOKIES]) with the user agent’s cookie store and httpRequest’s current URL.
</li>
							<li>
~IF［
%~cookie ~NEQ 空~文字列
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Cookie$h / %~cookie
)
◎
If cookies is not the empty string, append `Cookie`/cookies to httpRequest’s header list.
</li>
						</ol>
					</li>
					<li>
~IF［
%~http要請 の`~header~list$rq内に［
`Authorization$h を`名前に持つ~header$
］は在る
］
⇒
~BREAK `(A)^i
◎
If httpRequest’s header list does not contain `Authorization`, then:
</li>
					<li>
%権限付与~値 ~LET ~NULL
◎
Let authorizationValue be null.
</li>
					<li>
~IF［
%~http要請 用の`認証~entry$は在る
］~AND［［
%~http要請 の`資格証利用URL~flag$rq ~EQ ~F
］~OR［
%~http要請 の`現在の~URL$rqに
<a href="~URL1#include-credentials">資格証は含まれて</a>いない
］］
⇒
%権限付与~値 ~SET `認証~entry$
◎
If there’s an authentication entry for httpRequest and either httpRequest’s use-URL-credentials flag is unset or httpRequest’s current URL does not include credentials, then set authorizationValue to authentication entry.
</li>
					<li>
~ELIF［
%~http要請 の`現在の~URL$rqに
<a href="~URL1#include-credentials">資格証は含まれて</a>いる
］~AND［
%認証~fetch~flag ~NEQ ε
］
⇒
%権限付与~値 ~SET %~http要請 の`現在の~URL$rqを
<span class="XXX">`Authorization$h 値に変換-</span>
した結果
◎
Otherwise, if httpRequest’s current URL does include credentials and authentication-fetch flag is set, set authorizationValue to httpRequest’s current URL, converted to an `Authorization` value.
</li>
					<li>
~IF［
%権限付与~値 ~NEQ ~NULL
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`Authorization$h / %権限付与~値
)
◎
If authorizationValue is non-null, then append `Authorization`/authorizationValue to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
<p>
`~proxy認証~entry$がある場合、それを適切に利用する
◎
If there’s a proxy-authentication entry, use it as appropriate.
</p>

<p class="note">注記：
ここでは意図的に %~http要請 の`資格証~mode$rqに依存しないようにされている。
◎
This intentionally does not depend on httpRequest’s credentials mode.
</p>
			</li>
			<li>
%~http~cache ~SET `~HTTP~cache区分を決定する$( %~http要請 )
◎
Set httpCache to the result of determining the HTTP cache partition, given httpRequest.
</li>
			<li>
~IF［
%~http~cache ~EQ ~NULL
］
⇒
%~http要請 の`~cache~mode$rq~SET `no-store^l
◎
If httpCache is null, then set httpRequest’s cache mode to "no-store".
</li>
			<li>
<p>
`(B)^i：<br>

~IF［
%~http要請 の`~cache~mode$rq ~NIN { `no-store^l, `reload^l }
］：
◎
If httpRequest’s cache mode is neither "no-store" nor "reload", then:
</p>
				<ol>
					<li>
<p>
%格納-済み応答 ~SET %~http~cache から応答を選定した結果
⇒
~IF［
該当する応答はない
］
⇒
~BREAK `(B)^i
</p>

<p class="note">注記：
~HTTPにより義務付けられているように、これには，依然として `Vary$h `~header$も織り込まれる。
</p>

◎
Set storedResponse to the result of selecting a response from the httpCache, possibly needing validation, as per the "Constructing Responses from Caches" chapter of HTTP Caching [HTTP-CACHING], if any.
◎
As mandated by HTTP, this still takes the `Vary` header into account.
◎
If storedResponse is non-null, then:
</li>
					<li>
<p>
~IF［
`~cache~mode$rq ~EQ `default^l
］~AND［
%格納-済み応答 は`~stale-while-revalidate応答$である
］~AND［
%~http要請 の`~client$rq ~NEQ ~NULL
］：
◎
If cache mode is "default", storedResponse is a stale-while-revalidate response, and httpRequest’s client is non-null, then:
</p>
						<ol>
							<li>
%応答 ~SET %格納-済み応答
◎
Set response to storedResponse.
</li>
							<li>
%応答 の`~cache状態$rs ~SET `local^l
◎
Set response’s cache state to "local".
</li>
							<li>
%再検証-要請 ~LET `要請を~cloneする$( %要請 )
◎
Let revalidateRequest be a clone of request.
</li>
							<li>
%再検証-要請 の
⇒＃
`~cache~mode$rq ~SET `no-cache^l,
`~no-cache時に~cache制御~headerを改変しない~flag$rq ~SET ~T,
`~sw~mode$rq ~SET `none^l
◎
Set revalidateRequest’s cache mode set to "no-cache".
◎
Set revalidateRequest’s prevent no-cache cache-control header modification flag.
◎
Set revalidateRequest’s service-workers mode set to "none".
</li>
							<li>
<p>
次を`並列的$に遂行する
⇒
`~main~fetch$( %再検証-要請 )
◎
In parallel, perform main fetch using revalidateRequest.
</p>

<p class="note">注記：
この~fetchに意味されるのは， %~http~cache の状態を更新することに限られ、対する応答は，別の~cache~accessまで利用されないことになる。
現在の要請に対する応答には、非新鮮な応答が利用されることになる。
この~fetchは，~clientの文脈で発行iされるので、消え去った場合，要請【 %再検証-要請 ？】は終了されることになる。
◎
This fetch is only meant to update the state of httpCache and the response will be unused until another cache access. The stale response will be used as the response to current request. This fetch is issued in the context of a client so if it goes away the request will be terminated.
</p>
							</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~IF［
%格納-済み応答 は`非新鮮な応答$である
］
⇒
%再検証中~flag ~SET ~T
◎
If storedResponse is a stale response, then set the revalidatingFlag.
</li>
							<li>
<p>
~IF［
%再検証中~flag ~EQ ~T
］~AND［
%~http要請 の`~cache~mode$rq ~NIN { `force-cache^l, `only-if-cached^l }
］：
◎
If the revalidatingFlag is set and httpRequest’s cache mode is neither "force-cache" nor "only-if-cached", then:
</p>
								<ol>
									<li>
~IF［
%格納-済み応答 の`~header~list$rs内に［
`ETag$h を`名前に持つ~header$
］は在る
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`If-None-Match$h / その~headerの`値$hd
)
◎
If storedResponse’s header list contains `ETag`, then append `If-None-Match` with its value to httpRequest’s header list.
</li>
									<li>
~IF［
%格納-済み応答 の`~header~list$rs内に［
`Last-Modified$h を`名前に持つ~header$
］は在る
］
⇒
%~http要請 の`~header~list$rqに`~headerを付加する$(
`If-Modified-Since$h / その~headerの`値$hd
)
◎
If storedResponse’s header list contains `Last-Modified`, then append `If-Modified-Since` with its value to httpRequest’s header list.
</li>
								</ol>

<p class="note">注記：
`HTTP Caching^cite の
<a href="~HTTPcache#freshening.responses">検証~要請の送信-法</a>
も見よ。
`HTTP-CACHING$r
◎
See also the "Sending a Validation Request" chapter of HTTP Caching [HTTP-CACHING].
</p>
							</li>
							<li>
~ELSE
⇒＃
%応答 ~SET %格納-済み応答；
%応答 の`~cache状態$rs ~SET `local^l
◎
Otherwise, set response to storedResponse and set response’s cache state to "local".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
前~段が`中止されたときは$
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If aborted, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
		<ol>
			<li>
~IF［
%~http要請 の`~cache~mode$rq ~EQ `only-if-cached^l
］
⇒
~RET `~network~error$
◎
If httpRequest’s cache mode is "only-if-cached", then return a network error.
</li>
			<li>
%~forward応答 ~LET `~HTTP~network~fetch$( %~http要請, %資格証~flag )
◎
Let forwardResponse be the result of making an HTTP-network fetch using httpRequest with credentials flag if set.
</li>
			<li>
~IF［
%~http要請 の`~method$rqは`安全$でない
］~AND［
%~forward応答 の`状態s$rs ~IN { `200^st 〜 `399^st }
］
⇒＃
`HTTP Caching^cite による
<a href="~HTTPcache#invalidation">§ 無効化-法</a>
にしたがって， %~http~cache 内の適切な格納-済み応答たちを無効化する `HTTP-CACHING$r；
%格納-済み応答 ~SET ~NULL
◎
If httpRequest’s method is unsafe and forwardResponse’s status is in the range 200 to 399, inclusive, invalidate appropriate stored responses in httpCache, as per the "Invalidation" chapter of HTTP Caching, and set storedResponse to null. [HTTP-CACHING]
</li>
			<li>
<p>
~IF［
%再検証中~flag ~EQ ~T
］~AND［
%~forward応答 の`状態s$rs ~EQ `304$st
］：
◎
If the revalidatingFlag is set and forwardResponse’s status is 304, then:
</p>
				<ol>
					<li>
<p>
`HTTP Caching^cite の
<a href="~HTTPcache#freshening.responses">§ 検証にあたっての，格納-済み応答の新鮮化-法</a>
に従って，
%~forward応答 の`~header~list$rsを利用して
%格納-済み応答 の`~header~list$rsを更新する
`HTTP-CACHING$r
◎
Update storedResponse’s header list using forwardResponse’s header list, as per the "Freshening Stored Responses upon Validation" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
これは、~cache内の格納-済み応答も更新する。
◎
This updates the stored response in cache as well.
</li>
					<li>
%応答 ~SET %格納-済み応答
◎
Set response to storedResponse.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
				<ol>
					<li>
%応答 ~SET %~forward応答
◎
Set response to forwardResponse.
</li>
					<li>
<p>
`HTTP Caching^cite による
<a href="~HTTPcache#response.cacheability">§ ~cache内への応答の格納-法</a>
にしたがって，%~http~cache 内に［
%~http要請, %~forward応答
］を格納する
`HTTP-CACHING$r
◎
Store httpRequest and forwardResponse in httpCache, as per the "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
%~forward応答 が`~network~error$である場合、これは実質的に，その~network~errorを~cacheする
— それは “負な~cache法（ `negative caching^en ）” と称されることもある。
◎
If forwardResponse is a network error, this effectively caches the network error, which is sometimes known as "negative caching".
</p>
					</li>
		 		</ol>
			</li>
		</ol>
	</li>
	<li>
%応答 の`~URL~list$rs ~SET %~http要請 の`~URL~list$rqを`~cloneする$
◎
Set response’s URL list to a clone of httpRequest’s URL list.
</li>
	<li>
~IF［
%~http要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は在る
］
⇒
%応答 の`範囲が要請された~flag$rs ~SET ~T
◎
If httpRequest’s header list contains `Range`, then set response’s range-requested flag.
</li>
	<li>
<p>
~IF［
%応答 の`状態s$rs ~EQ `401$st 【Unauthorized】
］~AND［
%~http要請 の`応答~tainting$rq ~NEQ `cors^l
］~AND［
%資格証~flag ~EQ ~T
］~AND［
%要請 の`~window$rqは`環境~設定群~obj$である
］：
◎
If response’s status is 401, httpRequest’s response tainting is not "cors", the credentials flag is set, and request’s window is an environment settings object, then:
</p>
		<ol>
			<li class="XXX">課題：
`WWW-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `WWW-Authenticate` headers, missing, parsing issues.
</li>
			<li>
<p>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］：
◎
If request’s body is non-null, then:
</p>
				<ol>
					<li>
~IF［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If request’s body’s source is null, then return a network error.
</li>
					<li>
%要請 の`本体$rq ~SET 次の結果を成す`本体$
⇒
`本体と内容~型を安全に抽出する$( %要請 の`本体$rqの`~source$bd )
◎
Set request’s body to the first return value of safely extracting request’s body’s source.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の`資格証利用URL~flag$rq ~EQ ~F
］~OR［
%認証~fetch~flag ~NEQ ε
］：
◎
If request’s use-URL-credentials flag is unset or authentication-fetch flag is set, then:
</p>
				<ol>
					<li>
~IF［
進行中の~fetchは`終了され$た
］
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If the ongoing fetch is terminated, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
					<li>
( %~username, %~password ) ~LET
%要請 の`~window$rq
において，末端利用者に
( ~username, ~password )
の~~入力を促して得られた結果
【~~入力が拒否された場合について言及されていない。`中止~network~error$を返す？】
◎
Let username and password be the result of prompting the end user for a username and password, respectively, in request’s window.
</li>
					<li>
`~URLの~usernameを設定する$( %要請 の`現在の~URL$rq, %~username )
◎
Set the username given request’s current URL and username.
</li>
					<li>
`~URLの~passwordを設定する$( %要請 の`現在の~URL$rq, %~password )
◎
Set the password given request’s current URL and password.
</li>
				</ol>
			</li>
			<li>
%応答 ~SET `~HTTP~network-or-cache~fetch$( %要請, `認証あり^i )
◎
Set response to the result of performing an HTTP-network-or-cache fetch using request with authentication-fetch flag set.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 の`状態s$rs ~EQ `407$st 【Proxy Authentication Required】
］：
◎
If response’s status is 407, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`~window$rq ~EQ `no-window^l
］
⇒
~RET `~network~error$
◎
If request’s window is "no-window", then return a network error.
</li>
			<li class="XXX">課題：
`Proxy-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `Proxy-Authenticate` headers, missing, parsing issues.
</li>
			<li>
~IF［
進行中の~fetchは`終了され$た
］
⇒
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If the ongoing fetch is terminated, then:
• Let aborted be the termination’s aborted flag.
• If aborted is set, then return an aborted network error.
• Return a network error.
</li>
			<li>
<p>
%要請 の`~window$rqにおいて、末端利用者に対し 適切に
【認証に関する手続きを】
促し，その結果を`~proxy認証~entry$として保存する
`HTTP-AUTH$r
◎
Prompt the end user as appropriate in request’s window and store the result as a proxy-authentication entry. [HTTP-AUTH]
</p>

<p class="note">注記：
~proxy認証~周辺の詳細は~HTTPにて定義される。
◎
Remaining details surrounding proxy authentication are defined by HTTP.
</p>
			</li>
			<li>
%応答 ~SET `~HTTP~network-or-cache~fetch$( %要請 )
◎
Set response to the result of performing an HTTP-network-or-cache fetch using request.
</li>
		</ol>
	</li>
	<li>
~IF［
%認証~fetch~flag ~NEQ ε
］
⇒
［
%要請, および所与の~realm
］用の`認証~entry$を作成する
◎
If authentication-fetch flag is set, then create an authentication entry for request and the given realm.
</li>
	<li>
<p>
~RET %応答
</p>

<p class="note">注記：
手続きはここで終わるが、その後も概して，
%応答 の`本体$rsの`~stream$bdには~enqueueされ続ける。
</p>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>
</div>

		</section>
		<section id="http-network-fetch">
<h3 title="HTTP-network fetch">4.6. ~HTTP~network~fetch</h3>

<div class="algo">
<p>
`~HTTP~network~fetch@
を遂行するときは、所与の
( `要請$ %要請, 真偽値 %資格証~flag （省略時は ~F ） )
に対し，次の手続きを走らす：
◎
To perform an HTTP-network fetch using request with an optional credentials flag, run these steps:
• Let credentials be true if credentials flag is set, and false otherwise.
</p>
<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%~http~cache ~LET `~HTTP~cache区分を決定する$( %~http要請 )
◎
Let httpCache be the result of determining the HTTP cache partition, given httpRequest.
</li>
	<li>
~IF［
%~http~cache ~EQ ~NULL
］
⇒
%要請 の`~cache~mode$rq~SET `no-store^l
◎
If httpCache is null, then set request’s cache mode to "no-store".
</li>
	<li>
%~network区分~key ~LET `~network区分~keyを決定する$( %要請 )
◎
Let networkPartitionKey be the result of determining the network partition key given request.
</li>
	<li>
<p>
%接続 ~LET %要請 の`~mode$rqに応じて，次を遂行した結果：
◎
Switch on request’s mode:
</p>
		<ul class="switch">
			<li>
`websocket^l
⇒
`~WebSocket接続を得する$( %要請 の`現在の~URL$rq )
◎
"websocket"
• Let connection be the result of obtaining a WebSocket connection, given request’s current URL.
</li>
			<li>
~ELSE_
⇒
`接続を得する$( %~network区分~key, %要請 の`現在の~URL$rqの`生成元$url, %資格証~flag )
◎
Otherwise
• Let connection be the result of obtaining a connection, given networkPartitionKey, request’s current URL’s origin, and credentials.
</li>
		</ul>
	</li>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
~IF［
%接続 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If connection is failure, return a network error.
</li>
			<li>
~IF［
%接続 は~HTTP2接続でない
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
%要請 の`~header~list$rqに`~headerを付加する$(
`Transfer-Encoding$h / `chunked^bl
)
◎
If connection is not an HTTP/2 connection, request’s body is non-null, and request’s body’s source is null, then append `Transfer-Encoding`/`chunked` to request’s header list.
</li>
			<li>

<p>
%応答 ~SET 次の各~条項に従う下で、
%要請 を利用して, %接続 越しに，~HTTP要請を為した結果：
◎
Set response to the result of making an HTTP request over connection using request with the following caveats:
</p>

				<ul>
					<li>
~HTTPによる関連な要件に従うこと。
`HTTP$r
`HTTP-SEMANTICS$r
`HTTP-COND$r
`HTTP-CACHING$r
`HTTP-AUTH$r
◎
Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</li>
					<li>
`~header$すべてが伝送されるまで待機すること。
◎
Wait until all the headers are transmitted.
</li>
					<li>
<p>
`応答$のうち，［
`状態s$rs ~IN { `100^st, `102^st 〜 `199^st }
］なるものは無視すること。
◎
Any responses whose status is in the range 100 to 199, inclusive, and is not 101, are to be ignored.
</p>

<p class="note">注記：
この種の`応答$【`暫定-応答$】には、最終的に， “最終” `応答$【`最終-応答$】が後続する。
◎
These kind of responses are eventually followed by a "final" response.
</p>
					</li>
				</ul>

<p class="note">注記：
~Fetchと~HTTPとの間の正確な重ね方は、依然として~~整理される必要がある。
したがって、ここでの %応答 は，`応答$と~HTTP応答の両者を表現する。
◎
The exact layering between Fetch and HTTP still needs to be sorted through and therefore response represents both a response and an HTTP response here.
</p>

				<ul>
					<li>
%応答 は HTTP/1.0 以下の~versionを介して転送されていて、
%要請 の`~header~list$rqは
( `Transfer-Encoding$h / `chunked^bl )
を包含している場合は
⇒
~RET `~network~error$
◎
If request’s header list contains `Transfer-Encoding`/`chunked` and response is transferred via HTTP/1.0 or older, then return a network error.
</li>
					<li>
<p>
~HTTP要請による結果，~TLS~client証明書~dialogになるときは：
◎
If the HTTP request results in a TLS client certificate dialog, then:
</p>
						<ol>
							<li>
~IF［
%要請 の`~window$rqは`環境~設定群~obj$である
］
⇒
%要請 の`~window$rqにて~dialogを可用にする
◎
If request’s window is an environment settings object, make the dialog available in request’s window.
</li>
							<li>
~ELSE
⇒
~RET `~network~error$
◎
Otherwise, return a network error.
</li>
						</ol>
					</li>
					<li>
`要請~用の本体を伝送する$( %要請 )
◎
Transmit body for request.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
◎
↓• Let aborted be the termination’s aborted flag.
</p>
		<ol>
			<li>
~IF［
%接続 は~HTTP2を利用している
］
⇒
`RST_STREAM^c ~frameを伝送する
◎
If connection uses HTTP/2, then transmit an RST_STREAM frame.
</li>
			<li>
~RET ［
`終了時$の %中止~flag ~NEQ ε ならば `中止~network~error$ ／
~ELSE_ `~network~error$
］
◎
If aborted is set, then return an aborted network error.
◎
Return a network error.
</li>
		</ol>
	</li>
	<li>
%highWaterMark ~LET ~UAが選ぶ［
有限かつ負でない~number, または `Infinity^jv
］
◎
Let highWaterMark be a non-negative, non-NaN number, chosen by the user agent.
</li>
	<li>
%sizeAlgorithm ~LET 次のような~algo
⇒
`~chunk$~objを受容し，~UAが選ぶ［
有限かつ負でない~number
］を返す
◎
Let sizeAlgorithm be an algorithm that accepts a chunk object and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
</li>
	<li>
%pull ~LET
進行中の~fetchが`休止-$しているならば，それを`再開-$する動作
◎
Let pull be an action that resumes the ongoing fetch if it is suspended.
</li>
	<li>
%cancel ~LET 次を走らす動作
⇒
進行中の~fetchを`終了させる$( `中止する^i )
◎
Let cancel be an action that terminates the ongoing fetch with the aborted flag set.
</li>
	<li>
<p>
%~stream ~LET `~ReadableStream~objを構築する$RS( %highWaterMark, %sizeAlgorithm, %pull, %cancel )
◎
Let stream be the result of constructing a ReadableStream object with highWaterMark, sizeAlgorithm, pull, and cancel.
</p>

<p class="note">注記：
この構築~演算からは、例外は投出されない。
◎
This construction operation will not throw an exception.
</p>
	</li>
	<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
		<ol>
			<li>
%応答 の`本体$rs ~SET 次のようにされた新たな`本体$
⇒
`~stream$bd ~SET %~stream
◎
Set response’s body to a new body whose stream is stream.
</li>
			<li>
<p>
~IF［
%応答 には~payload本体~長さがある
］
⇒
%応答 の`本体$rsの`総~byte数$bd ~SET その~payload本体~長さ
◎
If response has a payload body length, then set response’s body’s total bytes to that payload body length.
</p>

<p class="trans-note">【
この条件 “長さがある” は、
<a href="~HTTPmsg#message.body.length">~message本体の長さを決定できる</a>かどうか
（ `HTTP$r ）に対応すると見受けられる（接続が~closeされるまで判明しない場合もある）。
`~payload本体$の長さは、`~message本体$の長さと異なることもある（当の~messageに `Transfer-Encoding$h が在る場合、それによる転送-符号法を復号した結果の長さになる）。
】</p>
			</li>
			<li>
~IF［
%応答 は`~network~error$でない
］~AND［
%要請 の`~cache~mode$rq ~NEQ `no-store^l
］
⇒
%~http~cache 内の［
%要請 に対する %応答
］を更新する
◎
If response is not a network error and request’s cache mode is not "no-store", then update response in httpCache for request.
</li>
			<li>
<p>
~IF［
%資格証~flag ~EQ ~T
］~AND［
~UAは %要請 用の~cookieを阻止するように環境設定されていない（
`COOKIES$r の
<a href="~HTTPcookie#privacy-considerations">§ 7</a>
を見よ）
］
⇒
%応答 の`~header~list$rs内の
~EACH ( `Set-Cookie$h を`名前に持つ~header$ %~header )
に対し
⇒
( %~header の`値$hd, %要請 の`現在の~URL$rq )
を与える下で，
"set-cookie-string" 構文解析~algo（
`COOKIES$r の
<a href="~HTTPcookie#set-cookie">§ 5.2</a>
を見よ）を走らす
◎
If credentials flag is set and the user agent is not configured to block cookies for request (see section 7 of [COOKIES]), then run the "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on the value of each header whose name is a byte-case-insensitive match for `Set-Cookie` in response’s header list, if any, and request’s current URL.
</p>

<p class="note">注記：
これは、利用者の追跡に利用され得る機能性である。
~FINGERPRINTING
◎
This is a fingerprinting vector.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
</p>
		<ol>
			<li>
~IF［
`終了時$の %中止~flag ~NEQ ε
］
⇒
%応答 の`中止~flag$rs ~SET ~T
◎
Let aborted be the termination’s aborted flag.
◎
If aborted is set, then set response’s aborted flag.
</li>
			<li>
~RET %応答
◎
Return response.
</li>
		</ol>
	</li>
	<li>
<p>
この段の中は、`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
<p>
この段の中は、進行中の~fetchが`終了され$た`ときは中止する$：
◎
Run these steps, but abort when the ongoing fetch is terminated:
</p>
<p>
~WHILE 無条件：
◎
While true:
</p>
				<ol>
					<li>
<p>
~IF［
%応答 の~message本体に対し 1 個 以上の~byteが伝送された
］：
◎
If one or more bytes have been transmitted from response’s message body, then:
</p>
						<ol>
							<li>
%~byte列 ~LET 伝送された~byte列
◎
Let bytes be the transmitted bytes.
</li>
							<li>
［
%応答 の`本体$rsの`伝送-済み~byte数$bd
］ ~INCBY ［
%~byte列 の長さ
］
◎
Increase response’s body’s transmitted bytes with bytes’ length.
</li>
							<li>
%符号法s ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Content-Encoding$h )
◎
Let codings be the result of extracting header list values given `Content-Encoding` and response’s header list.
</li>
							<li>
<p>
%~byte列 ~SET `内容~符号法sを取扱う$( %符号法s, %~byte列 )
◎
Set bytes to the result of handling content codings given codings and bytes.
</p>

<p class="note">注記：
これは、依拠し得ていた
`Content-Length^h `~header$を依拠できないものにする。
【！＊】
◎
This makes the `Content-Length` header unreliable to the extent that it was reliable to begin with.
</p>
							</li>
							<li>
~IF［
%~byte列 ~EQ `失敗^i
］
⇒
進行中の~fetchを`終了させる$()
◎
If bytes is failure, then terminate the ongoing fetch.
</li>
							<li>
%~stream に`~byte列を~enqueueする$RS( %~byte列 )
◎
Enqueue bytes given bytes and stream.
</li>
							<li>
~IF［
%~stream は`~errorした$RS
］
⇒
進行中の~fetchを`終了させる$()
◎
If stream is errored, then terminate the ongoing fetch.
</li>
							<li>
~IF［
%~stream は`もっと~dataが必要$RSではない
］~AND［
%要請 の`同期~flag$rq ~EQ ~F
]
⇒
進行中の~fetchを`休止-$するよう，~UAに請う
◎
If stream doesn’t need more data and request’s synchronous flag is unset, ask the user agent to suspend the ongoing fetch.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%応答 の~message本体~用の~byte列の伝送は，正常に終えられた
］
⇒
~IF［
%~stream は`読取n可能$RSである
］
⇒＃
%~stream を`~closeする$RS()；
~BREAK
◎
Otherwise, if the bytes transmission for response’s message body is done normally and stream is readable, then close stream and abort these in-parallel steps.
</li>
				</ol>
			</li>
			<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
</p>
				<ol>
					<li>
<p>
~IF［
`終了時$の %中止~flag ~NEQ ε
］：
◎
Let aborted be the termination’s aborted flag.
◎
If aborted is set, then:
</p>
						<ol>
							<li>
%応答 の`中止~flag$rs ~SET ~T
◎
Set response’s aborted flag.
</li>
							<li>
~IF［
%~stream は`読取n可能$RSである
］
⇒
%~stream を`~errorにする$RS( `AbortError$E 例外 )
◎
If stream is readable, error stream with an "AbortError" DOMException.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%~stream は`読取n可能$RSである
］
⇒
%~stream を`~errorにする$RS( `TypeError$E )
◎
Otherwise, if stream is readable, error stream with a TypeError.
</li>
					<li>
~IF［
%接続 は~HTTP2を利用している
］
⇒
`RST_STREAM^c ~frameを伝送する
◎
If connection uses HTTP/2, then transmit an RST_STREAM frame.
</li>
					<li>
<p>
~ELSE
⇒
~UAは接続を~closeするベキである
— そうすると処理能が悪化するときは除いて
◎
Otherwise, the user agent should close connection unless it would be bad for performance to do so.
</p>

<p class="note">注記：
一例として，~UAは、再利用-可能な接続にて，伝送する~byte数が残りわずかしかないと知るならば、接続を~openしたまま保つこともできる。
この事例では、接続を~closeして 次の~fetch用に~handshake処理-をやり直すと，悪化することもあるので。
◎
For instance, the user agent could keep the connection open if it knows there’s only a few bytes of transfer remaining on a reusable connection. In this case it could be worse to close the connection and go through the handshake process again for the next fetch.
</p>

					</li>
				</ol>

<p class="note">注記：
この段を`並列的$に走らせているのは、この時点では， %応答 の`本体$rsが関連するかどうか明瞭でないためである（ %応答 は~redirectかもしれない）。
◎
These are run in parallel as at this point it is unclear whether response’s body is relevant (response might be a redirect).
</p>

			</li>
		</ol>
	</li>
	<li>
<p>
~RET %応答
</p>

<p class="note">注記：
手続きはここで終わるが、その後も概して，
%応答 の`本体$rsの`~stream$bdには~enqueueされ続ける。
</p>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>
</div>

		</section>
		<section id="cors-preflight-fetch">
<h3 title="CORS-preflight fetch">4.7. ~CORS予行~fetch</h3>

<p class="note">注記：
これは、実質的には，`~CORS~protocol$が解されるかどうか見るための~UA実装であり、`~CORS予行~要請$と呼ばれている。
成功したときは、`~CORS予行~fetch$の回数を最小限にするために，`~CORS予行~cache$を拡充する。
◎
This is effectively the user agent implementation of the check to see if the CORS protocol is understood. The so-called CORS-preflight request. If successful it populates the CORS-preflight cache to minimize the number of these fetches.
</p>

<div class="algo">
<p>
`~CORS予行~fetch@
を遂行するときは、所与の
( %要請 )
に対し，次を走らす：
◎
To perform a CORS-preflight fetch using request, run these steps:
</p>
<ol>
	<li>
<p>
%予行 ~LET 次のように設定された，新たな`要請$
⇒＃
`~method$rq ~SET `OPTIONS$hm,
`~URL$rq ~SET %要請 の`現在の~URL$rq,
`起動元$rq ~SET %要請 の`起動元$rq,
`行先$rq ~SET %要請 の`行先$rq,
`生成元$rq ~SET %要請 の`生成元$rq,
`~referrer$rq ~SET %要請 の`~referrer$rq,
`~referrer施策$rq ~SET %要請 の`~referrer施策$rq,
`~mode$rq ~SET `cors^l,
`~tainted生成元~flag$rq ~SET %要請 の`~tainted生成元~flag$rq,
`応答~tainting$rq ~SET `cors^l
◎
Let preflight be a new request whose method is `OPTIONS`, URL is request’s current URL, initiator is request’s initiator, destination is request’s destination, origin is request’s origin, referrer is request’s referrer, referrer policy is request’s referrer policy, mode is "cors", tainted origin flag is request’s tainted origin flag, and response tainting is "cors".
</p>

<p class="note">注記：
%予行 の`~sw~mode$rqは関わらない
— この~algoは、`~HTTP~fetch$ではなく，`~HTTP~network-or-cache~fetch$を利用するので。
◎
The service-workers mode of preflight does not matter as this algorithm uses HTTP-network-or-cache fetch rather than HTTP fetch.
</p>
	</li>
	<li>
%予行 の`~header~list$rqに`~headerを付加する$(
`Accept$h / `*/*^bl
)
◎
Append `Accept`/`*/*` to preflight’s header list.
</li>
	<li>
%予行 の`~header~list$rqに`~headerを付加する$(
`Access-Control-Request-Method$h / %要請 の`~method$rq
)
◎
Append `Access-Control-Request-Method`/request’s method to preflight’s header list.
</li>
	<li>
%~header~list ~LET
`~CORS非安全な要請~header名たち$( %要請 の`~header~list$rq )
◎
Let headers be the CORS-unsafe request-header names with request’s header list.
</li>
	<li>
<p>
~IF［
%~header~list は`空$でない
］：
◎
If headers is not empty, then:
</p>
		<ol>
			<li>
%値 ~LET %~header~list 内の各~itemを順に， `,^bl で区切って連結した結果
◎
Let value be the items in headers separated from each other by `,`.
</li>
			<li>
%予行 の`~header~list$rqに`~headerを付加する$(
`Access-Control-Request-Headers$h / %値
)
◎
Append `Access-Control-Request-Headers`/value to preflight’s header list.
</li>
		</ol>
<p class="note">注記：
ここで`~headerを結合する$を利用しないのは意図的である。
これは［
`2C^X `20^X
］並びによる仕方で実装されてはいないので
— 功罪はあれど。
◎
This intentionally does not use combine, as 0x20 following 0x2C is not the way this was implemented, for better or worse.
</p>
	</li>
	<li>
%応答 ~LET `~HTTP~network-or-cache~fetch$( %予行 )
◎
Let response be the result of performing an HTTP-network-or-cache fetch using preflight.
</li>
	<li>
<p>
~IF［
`~CORS検査$( %要請, %応答 ) ~EQ `成功^i
］~AND［
%応答 の`状態s$rs は`~ok状態s$である
］：
◎
If a CORS check for request and response returns success and response’s status is an ok status, then:
</p>

<p class="note">注記：
正しい`資格証~mode$rqの利用を確保するため、
`~CORS検査$は， %予行 ではなく %要請 に対して行う。
◎
The CORS check is done on request rather than preflight to ensure the correct credentials mode is used.
</p>
		<ol>
			<li>
%~methods ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Allow-Methods$h )
◎
Let methods be the result of extracting header list values given `Access-Control-Allow-Methods` and response’s header list.
</li>
			<li>
%~header名たち ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Allow-Headers$h )
◎
Let headerNames be the result of extracting header list values given `Access-Control-Allow-Headers` and response’s header list.
</li>
			<li>
~IF［
%~methods ~EQ `失敗^i
］~OR［
%~header名たち ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If either methods or headerNames is failure, return a network error.
</li>
			<li>
<p>
~IF［
%~methods ~EQ ~NULL
］~AND［
`~CORS予行~利用~flag$rq ~EQ ~T
］
⇒
%~methods ~SET %要請 の`~method$rqのみからなる新たな~list
◎
If methods is null and request’s use-CORS-preflight flag is set, then set methods to a new list containing request’s method.
</p>

<p class="note">注記：
これにより、単に［
%要請 の`~CORS予行~利用~flag$rq ~EQ ~T
］であることに因り生じる`~CORS予行~fetch$も，<a href="#concept-cache">~cache</a>される。
◎
This ensures that a CORS-preflight fetch that happened due to request’s use-CORS-preflight flag being set is cached.
</p>
			</li>
			<li>
~IF［
%要請 の`~method$rq ~NIN %~methods
］~AND［
%要請 の`~method$rqは`~CORS安全とされる~method$でない
］~AND［［
%要請 の`資格証~mode$rq ~EQ `include^l
］~OR［
`*^bl ~NIN %~methods
］］
⇒
~RET `~network~error$
◎
If request’s method is not in methods, request’s method is not a CORS-safelisted method, and request’s credentials mode is "include" or methods does not contain `*`, then return a network error.
</li>
			<li>
<p>
%要請 の`~header~list$rq内の
~EACH( %~header )
に対し：
</p>
				<ol>
					<li>
~IF［
%~header は %~header名たち 内のある名前を`名前に持つ~header$である
］
⇒
~CONTINUE
</li>
					<li>
~IF［
%~header は`~CORS非~wildcard要請~header名$を`名前に持つ~header$である
］
⇒
~RET `~network~error$
</li>
				</ol>
◎
If one of request’s header list’s names is a CORS non-wildcard request-header name and is not a byte-case-insensitive match for an item in headerNames, then return a network error.
</li>
			<li>
~IF［
%要請 の`資格証~mode$rq ~EQ `include^l
］~OR［
`*^bl ~NIN %~header名たち
］
⇒
`~CORS非安全な要請~header名たち$( %要請 の`~header~list$rq )
内の
~EACH( %非安全~header名 )
に対し
⇒
%~header名たち 内の
~EACH( %~header名 )
に対し
⇒
~IF［
( 非安全~header名, %~header )
は`~byte大小無視$で合致する
］
⇒
~RET `~network~error$
◎
For each unsafeName in the CORS-unsafe request-header names with request’s header list, if unsafeName is not a byte-case-insensitive match for an item in headerNames and request’s credentials mode is "include" or headerNames does not contain `*`, return a network error.
</li>
			<li>
%寿命 ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Max-Age$h )
◎
Let max-age be the result of extracting header list values given `Access-Control-Max-Age` and response’s header list.
</li>
			<li>
~IF［
%寿命 ~IN { `失敗^i, ~NULL }
］
⇒
%寿命 ~SET 5
◎
If max-age is failure or null, then set max-age to 5.
</li>
			<li>
~IF［
%寿命 ~GT 環境により課される`寿命$ccの上限
］
⇒
%寿命 ~SET その上限
◎
If max-age is greater than an imposed limit on max-age, then set max-age to the imposed limit.
</li>
			<li>
~IF［
~UAは`~CORS予行~cache$を供していない
］
⇒
~RET %応答
◎
If the user agent does not provide for a cache, then return response.
</li>
			<li>
<p>
%~methods 内の
~EACH( %~method )
に対し：
</p>
				<ol>
					<li>
%~entryたち ~LET `~methodも合致している~cache~entry$( %要請, %~method )
</li>
					<li>
~IF［
%~entryたち は空でない
］
⇒
%~entryたち を成す各~entryに対し
⇒
その`寿命$cc ~SET %寿命
</li>
					<li>
~ELSE
⇒
`新たな~cache~entryを作成する$( %要請, %寿命, %~method, ~NULL )
</li>
				</ol>
◎
For each method in methods for which there is a method cache entry match using request, set matching entry’s max-age to max-age.
◎
For each method in methods for which there is no method cache entry match using request, create a new cache entry with request, max-age, method, and null.
</li>
			<li>
<p>
%~header名たち 内の
~EACH( %~header名 )
に対し：
</p>
				<ol>
					<li>
%~entryたち ~LET `~header名も合致している~cache~entry$( %要請, %~header名 )
</li>
					<li>
~IF［
%~entryたち ~NEQ ε
］
⇒
%~entryたち を成す各~entryに対し
⇒
その`寿命$cc ~SET %寿命
</li>
					<li>
<p>
~ELSE
⇒
`新たな~cache~entryを作成する$( %要請, %寿命, ~NULL, %~header名 )
</li>
				</ol>
◎
For each headerName in headerNames for which there is a header-name cache entry match using request, set matching entry’s max-age to max-age.
◎
For each headerName in headerNames for which there is no header-name cache entry match using request, create a new cache entry with request, max-age, null, and headerName.
</li>
			<li>
~RET %応答
◎
Return response.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET `~network~error$
◎
Otherwise, return a network error.
</li>
</ol>
</div>

		</section>
		<section id="cors-preflight-cache">
<h3 title="CORS-preflight cache">4.8. ~CORS予行~cache</h3>

<p>
各~UAは、
`~CORS予行~cache@
を持つ
— それは、 0 個以上の`~cache~entry$からなる`~list$である。
◎
A user agent has an associated CORS-preflight cache. A CORS-preflight cache is a list of cache entries.
</p>

<p>
各
`~cache~entry@
は、次のものからなる：
◎
A cache entry consists of:
</p>

<ul>
	<li>
`~byte直列化した生成元@cc
— `~byte列$
◎
byte-serialized origin (a byte sequence)
</li>
	<li>
`~URL@cc
— `~URL$
◎
URL (a URL)
</li>
	<li>
`寿命@cc
— 秒数
◎
max-age (a number of seconds)
</li>
	<li>
`資格証の有無@cc
— 次のいずれか
⇒＃
`有り^i,
`無し^i
◎
credentials (a boolean)
</li>
	<li>
`~method@cc
— 次のいずれか
⇒＃
~NULL,
`*^bl,
`~method$
◎
method (null, `*`, or a method)
</li>
	<li>
`~header名@cc
— 次のいずれか
⇒＃
~NULL,
`*^bl,
`~header$の`名前$hd
◎
header name (null, `*`, or a header name) 
</li>
</ul>

<p class="trans-note">【
`~method$ccと`~header名$ccは，両立しない~fieldであり、常に，一方は ~NULL, 他方は非 ~NULL になる。
】</p>

<p>
`~cache~entry$は、格納されてから`寿命$ccに指定された秒数だけ過ぎた時点で，除去するモノトスル
— その時点が来る前に除去してもヨイ。
◎
Cache entries must be removed after the seconds specified in their max-age field have passed since storing the entry. Cache entries may be removed before that moment arrives.
</p>

<div class="algo">
<p>
`新たな~cache~entryを作成する@
ときは、所与の
( %要請, %寿命, %~method, %~header名 )
に対し
⇒
`~CORS予行~cache$に［
次のように初期化された，新たな`~cache~entry$
］を`付加する$
⇒＃
`~byte直列化した生成元$cc ~SET `要請の生成元を~byte直列化する$( %要請 ),
`~URL$cc ~SET %要請 の`現在の~URL$rq,
`寿命$cc ~SET %寿命,
`資格証の有無$cc ~SET ［%要請 の`資格証~mode$rq ~EQ `include^l ならば `有り^i ／ ~ELSE_ `無し^i ］,
`~method$cc ~SET %~method,
`~header名$cc ~SET %~header名
◎
To create a new cache entry, given request, max-age, method, and headerName, run these steps:
◎
Let entry be a cache entry, initialized as follows:
◎
byte-serialized origin 
• The result of byte-serializing a request origin with request
• request’s current URL
max-age
• max-age
credentials
• True if request’s credentials mode is "include", and false otherwise
method
• method
header name
• headerName
◎
Append entry to the user agent’s CORS-preflight cache.
</p>
</div>

<div class="algo">
<p>
`~cache~entryを消去する@
ときは、所与の ( %要請 )
に対し
⇒
~UAの`~CORS予行~cache$から，次を満たす`~cache~entry$をすべて除去する
⇒
［
`~byte直列化した生成元$cc ~EQ `要請の生成元を~byte直列化する$( %要請 )
］~AND［
`~URL$cc ~EQ %要請 の`現在の~URL$rq
］
◎
To clear cache entries, given a request, remove any cache entries in the user agent’s CORS-preflight cache whose byte-serialized origin is the result of byte-serializing a request origin with request and whose URL is request’s current URL.
</p>
</div>

<p>
次をすべて満たす`~cache~entry$は、 %要請 に
`~cache合致する@
とされる：
◎
There is a cache entry match for a cache entry entry with request＼
</p>

<ul >
	<li>
`~byte直列化した生成元$cc ~EQ `要請の生成元を~byte直列化する$( %要請 )
◎
if entry’s byte-serialized origin is the result of byte-serializing a request origin with request,＼
</li>
	<li>
`~URL$cc ~EQ %要請 の`現在の~URL$rq
◎
entry’s URL is request’s current URL,＼
</li>
	<li>
［
`資格証の有無$cc ~EQ `有り^i
］~OR［［
`資格証の有無$cc ~EQ `無し^i
］~AND［
%要請 の`資格証~mode$rq ~NEQ `include^l
］］
◎
and one of
• entry’s credentials is true
• entry’s credentials is false and request’s credentials mode is not "include".
is true.
</li>
</ul>

<div class="algo">
<p>
`~methodも合致している~cache~entry@
は、所与の
( %要請, %~method )
に対し，~UAの`~CORS予行~cache$内にある，次を満たす`~cache~entry$たちからなる集合を返す
⇒
［
%要請 に`~cache合致する$
］~AND［
`~method$cc ~IN { %~method, `*^bl }
］
◎
There is a method cache entry match for method using request when there is a cache entry in the user agent’s CORS-preflight cache for which there is a cache entry match with request and its method is method or `*`.
</p>

<p class="trans-note">【†
原文からは、該当する~entryは高々 1 個のように解釈できそうだが，複数あり得るかもしれない
— はっきりしないので、この用語を利用している箇所も含め，複数あり得るとみなして訳している。
次の用語も同様。
】</p>

</div>


<div class="algo">
<p>
`~header名も合致している~cache~entry@
は、所与の
( %要請, %~header名 )
に対し，~UAの`~CORS予行~cache$内にある，次を満たす`~cache~entry$たちからなる集合を返す
⇒
［
%要請 に`~cache合致する$
］~AND［
( ~entryの`~header名$cc %名前, %~header名 )
は次のいずれかを満たす
］：
◎
There is a header-name cache entry match for headerName using request when there is a cache entry in the user agent’s CORS-preflight cache for which there is a cache entry match with request and＼
</p>

<div class="p">
<ul>
	<li>
%名前 は %~header名 に`~byte大小無視$で合致する
</li>
	<li>
［
%名前 ~EQ `*^bl
］~AND［
%~header名 は`~CORS非~wildcard要請~header名$でない
］
</li>
</ul>

◎
one of
• its header name is a byte-case-insensitive match for headerName
• its header name is `*` and headerName is not a CORS non-wildcard request-header name
is true.
</div>
</div>

		</section>
		<section id="cors-check">
<h3 title="CORS check">4.9. ~CORS検査</h3>

<div class="algo">
<p>
`~CORS検査@
は、所与の
( %要請, %応答 )
に対し，次を走らす：
◎
To perform a CORS check for a request and response, run these steps:
</p>
<ol>
	<li>
%生成元 ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Access-Control-Allow-Origin$h )
◎
Let origin be the result of getting `Access-Control-Allow-Origin` from response’s header list.
</li>
	<li>
<p>
~IF［
%生成元 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If origin is null, then return failure.
</p>

<p class="note">注記：
~NULL は `null^bl でないことに注意。
◎
Null is not `null`.
</p>
	</li>
	<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］~AND［
%生成元 ~EQ `*^bl
］
⇒
~RET `成功^i
◎
If request’s credentials mode is not "include" and origin is `*`, then return success.
</li>
	<li>
~IF［
`要請の生成元を~byte直列化する$( %要請 ) ~NEQ %生成元
］
⇒
~RET `失敗^i
◎
If the result of byte-serializing a request origin with request is not origin, then return failure.
</li>
	<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］
⇒
~RET `成功^i
◎
If request’s credentials mode is not "include", then return success.
</li>
	<li>
%資格証 ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Access-Control-Allow-Credentials$h )
◎
Let credentials be the result of getting `Access-Control-Allow-Credentials` from response’s header list.
</li>
	<li>
~IF［
%資格証 ~EQ `true^bl
］
⇒
~RET `成功^i
◎
If credentials is `true`, then return success.
</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>
</div>

		</section>
		<section id="tao-check">
<h3 title="TAO check">4.10. ~TAO検査</h3>

<p class="trans-note">【
~TAOは `Timing-Allow-Origin$h （計時を許容する生成元）の略称。
】</p>

<p>
`~TAO検査@
を遂行するときは、所与の
( %要請, %応答 )
に対し，次の手続きを走らす：
◎
To perform a TAO check for a request and response, run these steps:
</p>

<ol>
	<li>
~IF［
%要請 の`計時許容に失敗した~flag$rq ~EQ ~T
］
⇒
~RET `失敗^i
◎
If request’s timing allow failed flag is set, then return failure.
</li>
	<li>
~IF［
%要請 の`応答~tainting$rq ~EQ `basic^l
］
⇒
~RET `成功^i
◎
If request’s response tainting is "basic", then return success.
</li>
	<li>
%値~list ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `Timing-Allow-Origin$h )
◎
Let values be the result of getting, decoding, and splitting `Timing-Allow-Origin` from response’s header list.
</li>
	<li>
~IF［
`*^l ~IN %値~list
］
⇒
~RET `成功^i
◎
If values contains "*", then return success.
</li>
	<li>
~IF［
`要請の生成元を直列化する$( %要請 ) ~IN %値~list
］
⇒
~RET `成功^i
◎
If values contains the result of serializing a request origin with request, then return success.
</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>

		</section>
	</section>
	<section id="fetch-api">
<h2 title="Fetch API">5. ~fetch~API</h2>

<p>
`fetch()$m ~methodは、資源を`~fetch$するための，比較的 低~levelの~APIであり、
`XMLHttpRequest$I より少しばかり土台を受持つ
— 現時点では、いつ要請の進展（応答の進展ではなく）が来たかを報告する機能を欠いているが。
◎
The fetch() method is relatively low-level API for fetching resources. It covers slightly more ground than XMLHttpRequest, although it is currently lacking when it comes to request progression (not response progression).
</p>

<div class="example" id="fetch-blob-example">
<p>
`fetch()$m ~methodは、ごく率直に，資源を`~fetch$した上で その内容を `Blob$I として抽出する：
◎
The fetch() method makes it quite straightforward to fetch a resource and extract its contents as a Blob:
</p>

<pre class="lang-js">
fetch(`/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; %res.blob()).then(%playBlob);
</pre>

<p class="trans-note">【
記法
“<code>%args =&gt; %code</code>”
は、 %args を入力に %code を走らす無名~関数（
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions">arrow function</a>
）。
】</p>

<p>
特定0の応答~headerの~logをとりたいだけなら：
◎
If you just care to log a particular response header:
</p>

<pre class="lang-js">
fetch(`/^l, {method:`HEAD^l})
  .then(%res =&gt; log(%res.headers.get(`strict-transport-security^l)));
</pre>

<p>
特定0の応答~headerを検査して，非同一-生成元の資源を成す応答を処理したいなら：
◎
If you want to check a particular response header and then process the response of a cross-origin resource:
</p>

<pre class="lang-js">
fetch(`https://pk.example/berlin-calling.json^l, {mode:`cors^l})
  .then(%res =&gt; {
    if(%res.headers.get(`content-type^l) && (
       %res.headers.get(`content-type^l)
         .toLowerCase()
         .indexOf(`application/json^l) &gt;= 0
      )
    ) {
      return %res.json();
    } else {
      throw new TypeError();
    }
  }).then(processJSON);
</pre>

<p>
URL ~query~parameterを~~利用したいなら：
◎
If you want to work with URL query parameters:
</p>

<pre class="lang-js">
var %url = new URL(`https://geo.example.org/api^l),
    %params = {lat:35.696233, long:139.570431};
Object.keys(%params).forEach(
    %key =&gt; %url.searchParams.append(%key, params[%key])
);
fetch(%url).then(/* … */);
</pre>

<p>
本体~dataを漸進的に受信したいなら：
◎
If you want to receive the body data progressively:
</p>

<pre class="lang-js">
function consume(%reader) {
  var %total = 0
  return pump();

  function pump() {
    return %reader.read().then(({%done, %value}) =&gt; {
      if (%done) {
        return;
      }
      %total += %value.byteLength;
      log(``^受信された~byte数 ${%value.byteLength} （総~byte数 ${%total} ）``^
      );
      return pump();
    })
  }
}

fetch(`/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; consume(%res.body.getReader()))
  .then( () =&gt; log(
    `~memory内に全部~~貯めこむことなく，本体~全体を消費できました！^l
  ))
  .catch(%e =&gt; log(`何かまずいことが起きました： ^l + %e))
</pre>
<!-- 
received ${value.byteLength} bytes (${total} bytes in total)
"consumed the entire body without keeping the whole thing in memory!"
"something went wrong: "
-->

</div>

		<section id="headers-class">
<h3 title="Headers class">5.1. `Headers^I ~class</h3>

<pre class="idl">
typedef (
   sequence&lt;sequence&lt;`ByteString$&gt;&gt;
   or record&lt;`ByteString$, `ByteString$&gt;
) `HeadersInit@I;

[`Exposed$=(Window,Worker)]
interface `Headers@I {
  `Headers$mc(optional `HeadersInit$I %init);

  `undefined$ `append$m(`ByteString$ %name, `ByteString$ %value);
  `undefined$ `delete$m(`ByteString$ %name);
  `ByteString$? `get$m(`ByteString$ %name);
  `boolean$ `has$m(`ByteString$ %name);
  `undefined$ `set$m(`ByteString$ %name, `ByteString$ %value);
  `iterable$m&lt;`ByteString$, `ByteString$&gt;;
};
</pre>

<p class="note">注記：
`~header~list$と違って， `Headers$I ~objは複数個の `Set-Cookie$h `~header$は表現できない。
`Set-Cookie^h ~headerは 他のすべての~headerと違って結合できないので，これは ある面で問題になり得るが、この~headerは ~client側~JSには公開されないので，これは受容-可能な妥協点と判断される。
実装は、`~header~list$用であっても
— `Set-Cookie^h ~header用の~data構造も~supportする限り —
より効率的な `Headers$I ~obj表現を選ぶこともできる。
◎
Unlike a header list, a Headers object cannot represent more than one `Set-Cookie` header. In a way this is problematic as unlike all other headers `Set-Cookie` headers cannot be combined, but since `Set-Cookie` headers are not exposed to client-side JavaScript this is deemed an acceptable compromise. Implementations could choose the more efficient Headers object representation even for a header list, as long as they also support an associated data structure for `Set-Cookie` headers.
</p>

<div class="example" id="example-headers-class">

<p>
`Headers$I ~objは、種々の~JS~data構造で初期化できる：
◎
A Headers object can be initialized with various JavaScript data structures: 
</p>

<pre class="lang-js">
/* <span class="comment">
次の~codeは：
</span> */
var %meta = { "Content-Type": "text/xml", "Breaking-Bad": "&lt;3" }
new Headers(%meta)

/* <span class="comment">
次と等価になる：
◎
The above is equivalent to
</span> */
var %meta = [
[ "Content-Type", "text/xml" ],
[ "Breaking-Bad", "&lt;3" ]
]
new Headers(%meta)
</pre>

</div>

<p>
各 `Headers$I ~objには，次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~header~list@Hl（初期~時は空）</dt>
	<dd>
`~header~list$。
◎
A Headers object has an associated header list (a header list), which is initially empty.＼
</dd>
	<dd class="note">注記：
これは、何か他の~objの`~header~list$を指すこともある。
例えば `Request$I ~objの`要請$のそれを指すなど。
◎
This can be a pointer to the header list of something else, e.g., of a request as demonstrated by Request objects.
</dd>

	<dt>`~guard@Hl（初期~時は `none^l ）</dt>
	<dd>
次のいずれか
⇒＃
`immutable^l,
`request^l,
`request-no-cors^l,
`response^l,
`none^l
◎
A Headers object also has an associated guard, which is "immutable", "request", "request-no-cors", "response" or "none".
</dd>
</dl>

<p>
`新たな~Headers@( %~guard, %~list )
という表記は、次のようにされた，新たな `Headers$I ~objを表すとする：
</p>

<ol>
	<li>
`~guard$Hl ~SET %~guard
</li>
	<li>
%~list が省略されていない場合は、前項に加えて
⇒
`~header~list$Hl ~SET %~list
</li>
</ol>

<p class="trans-note">【
この表記は、簡潔に述べるために，この訳に導入したものである。
】</p>

<div class="algo">
<p>
`~guardで検査する@
ときは、所与の
( %名前, %値, `~guard$Hl %~guard )
に対し，次を走らす：
</p>

<p class="trans-note">【
この~algoは、共通な記述を集約するため，この訳に導入したものである。
】</p>

<ol>
	<li>
~IF［
%名前 は`名前$hdでない
］~OR［
%値 は`値$hdでない
］
⇒
~THROW `TypeError$E
</li>
	<li>
<p>
%~guard に応じて：
</p>
		<ul class="switch">
			<li>
`immutable^l
⇒
~THROW `TypeError$E
</li>
			<li>
`request^l
⇒
~IF［
%名前 は`禁止~header名$である
］
⇒
~RET `不合格^i
</li>
			<li>
`response^l
⇒
~IF［
%名前 は`禁止~応答~header名$である
］
⇒
~RET `不合格^i
</li>
			<li>
`request-no-cors^l
⇒
~RET `場合によっては合格^i
</li>
		</ul>
	</li>
	<li>
~RET `合格^i
</li>
</ol>
</div>

<!-- 
If name is not a name( or value is not a value)?, then throw a TypeError.
If 〜’s guard is "immutable", then throw a TypeError.
Otherwise, if 〜’s guard is request and name is a forbidden header name, return.
Otherwise, if 〜’s guard is "request-no-cors" ...
Otherwise, if 〜’s guard is "response" and name is a forbidden response-header name, return.
-->

<div class="algo">
<p>
`Headers$I ~obj %headers に~pair
( `名前$hd %名前 / `値$hd %値 )
を
`付加する@Hl
ときは、次を走らす：
◎
To append a name/value name/value pair to a Headers object (headers), run these steps:
</p>
<ol>
	<li>
%値 ~SET `値を正規化する$( %値 )
◎
Normalize value.
</li>
	<li>
<p>
`~guardで検査する$( %名前, %値, %headers の`~guard$Hl ) の結果に応じて：
</p>
		<ul class="switch">
			<li>
`不合格^i
⇒
~RET
</li>
			<li>
<p>
`場合によっては合格^i：
</p>
				<ol>
					<li>
%一時的な値 ~LET `~header~listから値を取得する$( %headers の`~header~list$Hl, %名前 )
</li>
					<li>
~IF［
%一時的な値 ~EQ ~NULL
］
⇒
%一時的な値 ~SET %値
</li>
					<li>
~ELSE
⇒
%一時的な値 に次を順に付加する
⇒＃
`2C^X,
`20^X,
%値
</li>
					<li>
~IF［
( %名前 / %一時的~値 )
は`~CORSなしで安全とされる要請~header$でない
］
⇒
~RET
</li>
				</ol>
			</li>
		</ul>
◎
If name is not a name or value is not a value, then throw a TypeError.
◎
If headers’s guard is "immutable", then throw a TypeError.
◎
Otherwise, if headers’s guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if headers’s guard is "request-no-cors":
• Let temporaryValue be the result of getting name from headers’s header list.
• If temporaryValue is null, then set temporaryValue to value.
• Otherwise, set temporaryValue to temporaryValue, followed by 0x2C 0x20, followed by value.
• If name/temporaryValue is not a no-CORS-safelisted request-header, then return.
◎
Otherwise, if headers’s guard is "response" and name is a forbidden response-header name, return.
</li>
	<li>
%headers の`~header~list$Hlに`~headerを付加する$(
%名前 / %値
)
◎
Append name/value to headers’s header list.
</li>
	<li>
~IF［
%headers の`~guard$Hl ~EQ `request-no-cors^l
］
⇒
%headers から`特権的~CORSなし要請~headerを除去する$
◎
If headers’s guard is "request-no-cors", then remove privileged no-CORS request headers from headers.
</li>
</ol>
</div>

<div class="algo">
<p>
`Headers$I ~obj %headers を，所与の~obj %~obj で
`埋める@Hl
ときは、次を走らす：
◎
To fill a Headers object headers with a given object object, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~obj は~IDL`連列~型$である
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~obj 内の
~EACH( %~header )
に対し：
◎
If object is a sequence, then for each header in object:
</p>
				<ol>
					<li>
~IF［
%~header 内の~item数 ~NEQ 2
］
⇒
~THROW `TypeError$E
◎
If header does not contain exactly two items, then throw a TypeError.
</li>
					<li>
%headers に
( %~header の 1 個目の~item / %~header の 2 個目の~item )
を`付加する$Hl
◎
Append header’s first item/header’s second item to headers.
</li>
				</ol>
			</li>
		</ol>
	<li>
~ELSE（ %~obj は~IDL`~record型$である ）
⇒
%~obj 内の
~EACH( %~key → %値 )
に対し
⇒
%headers に
( %~key / %値 )
を`付加する$Hl
◎
Otherwise, object is a record, then for each key → value in object, append key/value to headers.
</li>
</ol>
</div>

<div class="algo">
<p>
`Headers$I ~obj %headers から
`特権的~CORSなし要請~headerを除去する@
ときは、次を走らす：
◎
To remove privileged no-CORS request headers from a Headers object (headers), run these steps:
</p>
<ol>
	<li>
`特権的~CORSなし要請~header名$を成す
~EACH( %~header名 )
に対し
⇒
%headers の`~header~list$Hlから`~headerを削除する$( %~header名 )
◎
For each headerName of privileged no-CORS request-header names:
• Delete headerName from headers’s header list.
</li>
</ol>

<p class="note">注記：
これは、 %headers が特権的でない~codeにより改変されたときに~callされる。
◎
This is called when headers are modified by unprivileged code.
</p>
</div>


<div class="algo">
<p>
`new Headers(init)@m
構築子~手続きは：
◎
The new Headers(init) constructor steps are:
</p>
<ol>
	<li>
コレの`~guard$Hl ~SET `none^l
◎
Set this’s guard to "none".
</li>
	<li>
~IF［
%init ~NEQ ε
］
⇒
コレ を %init で`埋める$Hl
◎
If init is given, then fill this with init.
</li>
</ol>
</div>

<div class="algo">
`append(name, value)@m
~method~手続きは
⇒
~RET コレに
( %name / %value )
を`付加する$Hl
◎
The append(name, value) method steps are to append name/value to this.
</div>

<div class="algo">
<p>
`delete(name)@m
~method~手続きは：
◎
The delete(name) method steps are:
</p>
<ol>
	<li>
<p>
`~guardで検査する$( %name, `valid-value^bl, コレの`~guard$Hl ) の結果に応じて：
</p>
		<ul class="switch">
			<li>
`不合格^i
⇒
~RET
</li>
			<li>
`場合によっては合格^i
⇒
~IF［
%name は`~CORSなしで安全とされる要請~header名$でない
］~AND［
%name は`特権的~CORSなし要請~header名$でない
］
⇒
~RET
</li>
		</ul>
◎
If name is not a name, then throw a TypeError.
◎
If this’s guard is "immutable", then throw a TypeError.
◎
Otherwise, if this’s guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if this’s guard is "request-no-cors", name is not a no-CORS-safelisted request-header name, and name is not a privileged no-CORS request-header name, return.
◎
Otherwise, if this’s guard is "response" and name is a forbidden response-header name, return.
</li>
	<li>
~IF［
コレの`~header~list$Hl内に［
%name を`名前に持つ~header$
］は無い
］
⇒
~RET
◎
If this’s header list does not contain name, then return.
</li>
	<li>
コレの`~header~list$Hlから`~headerを削除する$( %name )
◎
Delete name from this’s header list.
</li>
	<li>
~IF［
コレの`~guard$Hl ~EQ `request-no-cors^l
］
⇒
コレから`特権的~CORSなし要請~headerを除去する$
◎
If this’s guard is "request-no-cors", then remove privileged no-CORS request headers from this.
</li>
</ol>
</div>

<div class="algo">
<p>
`get(name)@m
~method~手続きは：
◎
The get(name) method steps are:
</p>
<ol>
	<li>
~IF［
%name は`名前$hdでない
］
⇒
~THROW `TypeError$E
◎
If name is not a name, then throw a TypeError.
</li>
	<li>
~RET `~header~listから値を取得する$( コレの`~header~list$Hl, %name )
◎
Return the result of getting name from this’s header list.
</li>
</ol>
</div>

<div class="algo">
<p>
`has(name)@m
~method~手続きは：
◎
The has(name) method steps are:
</p>
<ol>
	<li>
~IF［
%name は`名前$hdでない
］
⇒
~THROW `TypeError$E
◎
If name is not a name, then throw a TypeError.
</li>
	<li>
~RET
コレの`~header~list$Hl内に［
%name を`名前に持つ~header$
］は［
在るならば ~T ／
無いならば ~F
］
◎
Return true if this’s header list contains name; otherwise false.
</li>
</ol>
</div>

<div class="algo">
<p>
`set(name, value)@m
~method~手続きは：
◎
The set(name, value) method steps are:
</p>
<ol>
	<li>
%value ~SET `値を正規化する$( %value )
◎
Normalize value.
</li>
	<li>
<p>
`~guardで検査する$( %name, %value, コレの`~guard$Hl ) の結果に応じて：
</p>
		<ul class="switch">
			<li>
`不合格^i
⇒
~RET
</li>
			<li>
`場合によっては合格^i
⇒
~IF［
( %name / %value )
は`~CORSなしで安全とされる要請~header$でない
］
⇒
~RET
</li>
		</ul>
◎
If name is not a name or value is not a value, then throw a TypeError.
◎
If this’s guard is "immutable", then throw a TypeError.
◎
Otherwise, if this’s guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if this’s guard is "request-no-cors" and name/value is not a no-CORS-safelisted request-header, return.
◎
Otherwise, if this’s guard is "response" and name is a forbidden response-header name, return.
</li>
	<li>
コレの`~header~list$Hl内で`~headerを設定する$(
%name / %value
)
◎
Set name/value in this’s header list.
</li>
	<li>
~IF［
`~guard$Hl ~EQ `request-no-cors^l
］
⇒
コレから`特権的~CORSなし要請~headerを除去する$
◎
If this’s guard is "request-no-cors", then remove privileged no-CORS request headers from this.
</li>
</ol>
</div>

<div class="algo">
`iterable@m
における`反復される値~pairたち$は、次の結果で与えられる
⇒
`~header~listを~sortして結合する$( コレの`~header~list$Hl )
◎
The value pairs to iterate over are the return value of running sort and combine with this’s header list.
</div>

		</section>
		<section id="bodyinit-unions">
<h3 title="BodyInit unions">5.2. `BodyInit^I 共用体</h3>

<pre class="idl">
typedef (
  `Blob$I or
  `BufferSource$I or
  `FormData$I or
  `URLSearchParams$I or
  `USVString$
) `XMLHttpRequestBodyInit@I

typedef (`ReadableStream$I or `XMLHttpRequestBodyInit$I) `BodyInit@I;
</pre>

<div class="algo">
<p>
`本体と内容~型を安全に抽出する@
ときは、所与の
( %~obj )
に対し，次を走らす
— この手続きは
( `本体$, `Content-Type$h `値$hd )
の組を返す：
◎
To safely extract a body and a `Content-Type` value from object, run these steps:
</p>
<ol>
	<li>
~IF［
%~obj は `ReadableStream$I ~objである
］
⇒
~Assert：
%~obj は次を満たしていない
⇒
［
`妨げられている$RS
］~OR［
`~lockされている$RS
］
◎
If object is a ReadableStream object, then:
• Assert: object is neither disturbed nor locked.
</li>
	<li>
~RET `本体と内容~型を抽出する$( %~obj )
◎
Return the results of extracting object.
</li>
</ol>

<p class="note">注記：
`本体と内容~型を安全に抽出する$演算は、例外を投出しないことが保証される，`本体と内容~型を抽出する$演算である。
◎
The safely extract operation is a subset of the extract operation that is guaranteed to not throw an exception.
</p>
</div>

<div class="algo">
<p>
`本体と内容~型を抽出する@
ときは、所与の
( %~obj, %~keepalive ~IN { `~keepalive^i, ε }（省略時は ε ）)
【！boolean keepalive (default false)】
に対し，次を走らす
— この手続きは
( `本体$, `Content-Type$h `値$hd )
の組を返す：
◎
To extract a body and a `Content-Type` value from object, with an optional boolean keepalive (default false), run these steps:
</p>
<ol>
	<li>
%~stream ~LET %~obj に応じて
⇒＃
`ReadableStream$I ~objであるならば %~obj ／
~ELSE_ `~ReadableStream~objを構築する$RS()
◎
Let stream be object if object is a ReadableStream object; otherwise the result of constructing a ReadableStream object.
</li>
	<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
	<li>
%動作 ~LET ~NULL
◎
Let action be null.
</li>
	<li>
%~source ~LET %~obj に応じて
⇒＃
`ReadableStream$I ~objであるならば ~NULL ／
~ELSE_ %~obj
◎
Let source be null if object is a ReadableStream object; otherwise object.
</li>
	<li>
<p>
%~obj に応じて：
◎
Switch on object:
</p>
		<dl class="switch">
			<dt>`Blob$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET %~obj を読取った結果†
◎
Set action to an action that reads object.
</li>
					<li>
~IF［
%~obj の `type$mF 属性 ~NEQ 空~byte列
］
⇒
%内容~型 ~SET その属性~値
◎
If object’s type attribute is not the empty byte sequence, set Content-Type to its value.
</li>
				</ol>

<p class="trans-note">【†
明確には指定されていないが、以降の処理は，
`FILEAPI$r に定義される`~streamを取得する$ ~algoと同じ結果になると見受けられる。
】</p>
			</dd>

			<dt>
`~byte列$
◎
byte sequence
</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET %~obj
◎
Set action to an action that returns object.
</li>
				</ol>
			</dd>

			<dt>`BufferSource$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET %~obj が保持している
<a href="~WEBIDL#dfn-get-buffer-source-copy">~byte列の複製</a>
◎
Set action to an action that returns a copy of the bytes held by object.
</li>
				</ol>
			</dd>

			<dt>`FormData$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET `~mp_form_dataとして符号化する$( %~obj, `~UTF-8$enc )
◎
Set action to an action that runs the multipart/form-data encoding algorithm, with object as form data set and with UTF-8 as the explicit character encoding.
</li>
					<li>
%内容~型 ~SET `multipart/form-data; boundary=^bl
◎
Set Content-Type to `multipart/form-data; boundary=`,＼
</li>
					<li>
%内容~型 に次を付加する
⇒
%動作 により生成されることになる `~mp_form_data境界~文字列$
◎
followed by the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</li>
				</ol>
			</dd>

			<dt>`URLSearchParams$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET `~form_urlencoded直列化器$( %~obj の`名値~pair~list$ )
◎
Set action to an action that runs the application/x-www-form-urlencoded serializer with object’s list.
</li>
					<li>
%内容~型 ~SET `application/x-www-form-urlencoded;charset=UTF-8^bl
◎
Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.
</li>
				</ol>
			</dd>

			<dt>
`~scalar値~文字列$
◎
scalar value string
</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
~RET `~UTF-8符号化する$( %~obj )
◎
Set action to an action that runs UTF-8 encode on object.
</li>
					<li>
%内容~型 ~SET `text/plain;charset=UTF-8^bl
◎
Set Content-Type to `text/plain;charset=UTF-8`.
</li>
				</ol>
			</dd>

			<dt>`ReadableStream$I</dt>
			<dd>
				<ol>
					<li>
~IF［
%~keepalive ~NEQ ε
］~OR［
%~obj は`妨げられている$Bd
］~OR［
%~obj は`~lockされている$Bd
］
⇒
~THROW `TypeError$E
◎
If keepalive is true, then throw a TypeError. 
◎
If object is disturbed or locked, then throw a TypeError.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
%動作 ~NEQ ~NULL
］
⇒
次に従う下で %動作 を`並列的$に走らす：
◎
If action is non-null, run action in parallel:
</p>
		<ul>
			<li>
【 %動作 の結果から】
1 個以上の~byte %~byte列 が可用になるたびに
⇒
%~stream に`~byte列を~enqueueする$RS( %~byte列 )
◎
Whenever one or more bytes are available and stream is not errored, enqueue bytes given the available bytes and stream.
</li>
			<li>
前項により %~stream が`~errorした$RSときは
⇒
この段を終える
【この場合、次項を飛ばしても同じ結果になると見受けられる。】
◎
↑</li>
			<li>
%動作 を走らせ終えたときは
⇒
%~stream を`~closeする$RS()
◎
When running action is done, close stream.
</li>
		</ul>
	</li>
	<li>
%本体 ~LET 次のようにされた新たな`本体$
⇒＃
`~stream$bd ~SET %~stream；
`~source$bd ~SET %~source
◎
Let body be a body whose stream is stream and whose source is source.
</li>
	<li>
~RET
( %本体, %内容~型 )
◎
Return body and Content-Type.
</li>
</ol>
</div>

		</section>
		<section id="body-mixin">
<h3 title="Body mixin">5.3. `Body^I ~mixin</h3>

<pre class="idl">
interface mixin `Body@I {
  readonly attribute `ReadableStream$I? `body$m;
  readonly attribute `boolean$ `bodyUsed$m;
  [`NewObject$] `Promise$&lt;`ArrayBuffer$I&gt; `arrayBuffer$m();
  [`NewObject$] `Promise$&lt;`Blob$I&gt; `blob$m();
  [`NewObject$] `Promise$&lt;`FormData$I&gt; `formData$m();
  [`NewObject$] `Promise$&lt;any&gt; `json$m();
  [`NewObject$] `Promise$&lt;`USVString$&gt; `text$m();
};
</pre>

<p class="note">注記：
~HTMLなど，~network層に依存させたくない内容形式が、ここで公開されることにはならないであろう。
むしろ、~HTML構文解析器~APIが，~streamを受容するようになるであろう。
【<a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2014Jun/thread.html#msg72">参考</a>】
◎
Formats you would not want a network layer to be dependent upon, such as HTML, will likely not be exposed here. Rather, an HTML parser API might accept a stream in due course.
</p>

<div class="p">
<p>
`Body$I ~mixinを実装している各~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`本体@Bd</dt>
	<dd>
~NULL または `本体$。
</dd>

	<dt>`~MIME型@Bd</dt>
	<dd>
`失敗^i または`~MIME型$。
</dd>
</dl>
◎
Objects implementing the Body mixin gain an associated body (null or a body) and a MIME type (failure or a MIME type).
</div>

<p>
`Body$I ~mixinを実装している~objは、その`本体$Bd %本体 が：
◎
↓</p>

<ul>
	<li>
次を満たすとき，
`妨げられている@Bd
という
⇒
［
%本体 ~NEQ ~NULL
］~AND［
%本体 の`~stream$bdは`妨げられている$RS
］
◎
An object implementing the Body mixin is said to be disturbed if its body is non-null and its body’s stream is disturbed.
</li>
	<li>
次を満たすとき，
`~lockされている@Bd
という
⇒
［
%本体 ~NEQ ~NULL
］~AND［
%本体 の`~stream$bdは`~lockされている$Bd
］
◎
An object implementing the Body mixin is said to be locked if its body is non-null and its body’s stream is locked.
</li>
</ul>

<div class="algo">
`body@m
取得子~手続きは
⇒
~RET コレの`本体$Bd %本体 に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %本体 の`~stream$bd
◎
The body getter steps are to return null if this’s body is null; otherwise this’s body’s stream.
</div>

<div class="algo">
`bodyUsed@m
取得子~手続きは
⇒
~RET コレは`妨げられている$Bdならば ~T ／
~ELSE_ ~F
◎
The bodyUsed getter steps are to return true if this is disturbed; otherwise false.
</div>

<div class="algo">
<p>
`~dataを梱包する@
~algoは、所与の
( %~byte列, %型, %~MIME型 )
に対し， %型 に応じて次を走らす：
◎
The package data algorithm, given bytes, type, and a mimeType, switches on type, and runs the associated steps:
</p>

<dl class="switch">
	<dt>`ArrayBuffer^i</dt>
	<dd>
~RET %~byte列 を内容とする新たな `ArrayBuffer$I
◎
Return a new ArrayBuffer whose contents are bytes.
</dd>
	<dd class="note">注記：
`ArrayBuffer^I を割振るときには、 `RangeError$E が投出され得る。
◎
Allocating an ArrayBuffer can throw a RangeError.
</dd>

	<dt>`Blob^i</dt>
	<dd>
~RET 次のようにされた `Blob$I
⇒＃
%~byte列 を内容とする,
`type$mF 属性 ~SET %~MIME型
◎
Return a Blob whose contents are bytes and type attribute is mimeType.
</dd>

	<dt>`FormData^i</dt>
	<dd>
<p>
%~MIME型 の`~essence$に応じて：
◎
↓</p>

		<dl class="switch">
			<dt>
`multipart/form-data^l
◎
If mimeType’s essence is "multipart/form-data", then: 
</dt>
			<dd>
				<ol>
					<li>
<p>
`Returning Values from Forms: multipart/form-data^cite `RFC7578$r
に則って、
( %~MIME型 の `boundary^bl ~parameterの値 )
を与える下で，
%~byte列 を構文解析する
— それにより得られた各 部位 %部位 に対しては、［
%部位 の中の `Content-Disposition^h ~headerが `filename^bl ~parameterを包含するかどうかに応じて，次で与えられる値
］を値とする`~entry$xhrに構文解析するモノトスル：
◎
Parse bytes, using the value of the `boundary` parameter from mimeType, per the rules set forth in Returning Values from Forms: multipart/form-data. [RFC7578]
</p>
						<dl class="switch">
							<dt>包含する場合</dt>
							<dd>
<p>
次のようにされた `File$I ~obj：
</p>
<ul ><li>その内容 ~SET %部位 の内容
</li><li>`name$mF 属性の値 ~SET `filename^bl ~parameterの値
</li><li>`type$mF 属性の値 ~SET %部位 内に `Content-Type$h ~headerが［
あれば その~header値 ／
なければ `text/plain^bl （ `RFC7578$r § 4.4 に定義される既定）
］
</li></ul>

◎
Each part whose `Content-Disposition` header contains a `filename` parameter must be parsed into an entry whose value is a File object whose contents are the contents of the part. The name attribute of the File object must have the value of the `filename` parameter of the part. The type attribute of the File object must have the value of the `Content-Type` header of the part if the part has such header, and `text/plain` (the default defined by [RFC7578] section 4.4) otherwise.
</dd>

							<dt>包含しない場合</dt>
							<dd>
`~BOMはそのままに~UTF-8復号する$( %部位 の内容 ) の結果
◎
Each part whose `Content-Disposition` header does not contain a `filename` parameter must be parsed into an entry whose value is the UTF-8 decoded without BOM content of the part.＼
</dd>
							<dd class="note">注記：
これは、［
`Content-Type$h ~header ／ `charset^bl ~parameter
］の有無やその値に関わらず行われる。
◎
This is done regardless of the presence or the value of a `Content-Type` header and regardless of the presence or the value of a `charset` parameter.
</dd>
						</dl>

<p class="note">注記：
［
`Content-Disposition^h ~headerが `name^bl ~parameterを包含していて,
その値は `_charset_^bl である
］ような部位も、他の部位と同様に構文解析される。
それは符号化法を変更することはない。
◎
A part whose `Content-Disposition` header contains a `name` parameter whose value is `_charset_` is parsed like any other part. It does not change the encoding.
</p>
					</li>
					<li>
~IF［
何らかの事由で，前~段が失敗した
］
⇒
~THROW `TypeError$E
◎
If that fails for some reason, then throw a TypeError.
</li>
					<li>
~RET ［
`~entry$xhrの~list ~SET 構文解析した結果の`~entry$xhrたち
］にされた，新たな `FormData$I ~obj
◎
Return a new FormData object, appending each entry, resulting from the parsing operation, to entries.
</li>
				</ol>

<p class="XXX">課題：
上述は `multipart/form-data^bl に必要なものの~~概略であり、より詳細な構文解析~仕様が書かれることになる。
~~協力を歓迎する。
◎
The above is a rough approximation of what is needed for `multipart/form-data`, a more detailed parsing specification is to be written. Volunteers welcome.
</p>

			</dd>

			<dt>
`application/x-www-form-urlencoded^l
◎
Otherwise, if mimeType’s essence is "application/x-www-form-urlencoded", then:
</dt>
			<dd>
				<ol>
					<li>
%~entryたち ~LET `~form_urlencoded構文解析器$( %~byte列 )
◎
Let entries be the result of parsing bytes.
</li>
					<li>
~IF［
%~entryたち ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If entries is failure, then throw a TypeError.
</li>
					<li>
~ELSE
⇒
~RET 次のようにされた，新たな `FormData$I ~obj
⇒
`~entry$xhrの~list ~SET %~entryたち
◎
Return a new FormData object whose entries are entries.
</li>
				</ol>
			</dd>

			<dt>その他</dt>
			<dd>
~THROW `TypeError$E
◎
Otherwise, throw a TypeError.
</dd>
		</dl>
	</dd>

	<dt>`JSON^i</dt>
	<dd>
~RET `~byte列を~JSONとして構文解析する$( %~byte列 )
◎
Return the result of running parse JSON from bytes on bytes.
</dd>

	<dt>`text^i</dt>
	<dd>
~RET `~UTF-8復号する$( %~byte列 )
◎
Return the result of running UTF-8 decode on bytes.
</dd>
</dl>
</div>

<div class="algo">
<p>
`本体を消費する@
~algoは、所与の
( %~obj, %型 )
に対し，次を走らす：
◎
The consume body algorithm, given an object and type, runs these steps:
</p>
<ol>
	<li>
~IF［
%~obj は`妨げられている$Bd
］~OR［
%~obj は`~lockされている$Bd
］
⇒
~RET `TypeError$E で`却下される~promise$
◎
If object is disturbed or locked, then return a promise rejected with a TypeError.
</li>
	<li>
%~promise ~LET 空な`~byte列$で`解決される~promise$
◎
Let promise be a promise resolved with an empty byte sequence.
</li>
	<li>
<p>
~IF［
%~obj の`本体$Bd ~NEQ ~NULL
］：
◎
If object’s body is non-null, then:
</p>
		<ol>
			<li>
%~stream ~LET %~obj の`本体$Bdの`~stream$bd
◎
Let stream be object’s body’s stream.
</li>
			<li>
%読取器 ~LET %~stream から`読取器を取得する$RS()
⇒
例外が投出されたときは
⇒
~RET その例外で`却下される~promise$
◎
Let reader be the result of getting a reader from stream. If that threw an exception, then return a promise rejected with that exception.
</li>
			<li>
%~promise ~SET
%~stream から`すべての~byte列を読取る$RS( %読取器 )
◎
Set promise to the result of reading all bytes from stream with reader.
</li>
		</ol>
	</li>
	<li>
%手続き ~LET 次を走らす手続き
⇒
~RET `~dataを梱包する$( 所与の最初の引数, %型, %~obj の`~MIME型$Bd )
◎
Let steps be to return the result of package data with the first argument given, type, and object’s MIME type.
</li>
	<li>
~RET %手続き を走らす充足~handlerで %~promise に`反応-$した結果【！`充足-時$】
◎
Return the result of upon fulfillment of promise given steps.
</li>
</ol>
</div>

<div class="algo">
`arrayBuffer()@m
~method~手続きは
⇒
~RET `本体を消費する$( コレ, `ArrayBuffer^i )
◎
The arrayBuffer() method steps are to return the result of running consume body with this and ArrayBuffer.
</div>

<div class="algo">
`blob()@m
~method~手続きは
⇒
~RET `本体を消費する$( コレ, `Blob^i )
◎
The blob() method steps are to return the result of running consume body with this and Blob.
</div>

<div class="algo">
`formData()@m
~method~手続きは
⇒
~RET `本体を消費する$( コレ, `FormData^i )
◎
The formData() method steps are to return the result of running consume body with this and FormData.
</div>

<div class="algo">
`json()@m
~method~手続きは
⇒
~RET `本体を消費する$( コレ, `JSON^i )
◎
The json() method steps are to return the result of running consume body with this and JSON.
</div>

<div class="algo">
`text()@m
~method~手続きは
⇒
~RET `本体を消費する$( コレ, `text^i )
◎
The text() method steps are to return the result of running consume body with this and text.
</div>

		</section>
		<section id="request-class">
<h3 title="Request class">5.4. `Request^I ~class</h3>

<pre class="idl">
typedef (`Request$I or `USVString$) `RequestInfo@I;

[`Exposed$=(Window,Worker)]
interface `Request@I {
  `Request$mc(`RequestInfo$I %input, optional `RequestInit$I %init = {});

  readonly attribute `ByteString$ `method$m;
  readonly attribute `USVString$ `url$m;
  [`SameObject$] readonly attribute `Headers$I `headers$m;

  readonly attribute `RequestDestination$I `destination$m;
  readonly attribute `USVString$ `referrer$m;
  readonly attribute `ReferrerPolicy$I `referrerPolicy$m;
  readonly attribute `RequestMode$I `mode$m;
  readonly attribute `RequestCredentials$I `credentials$m;
  readonly attribute `RequestCache$I `cache$m;
  readonly attribute `RequestRedirect$I `redirect$m;
  readonly attribute `DOMString$ `integrity$m;
  readonly attribute `boolean$ `keepalive$m;
  readonly attribute `boolean$ `isReloadNavigation$m;
  readonly attribute `boolean$ `isHistoryNavigation$m;
  readonly attribute `AbortSignal$I `signal$m;

  [`NewObject$] `Request$I `clone$m();
};
`Request$I includes `Body$I;

dictionary `RequestInit@I {
  `ByteString$ `method@RqI;
  `HeadersInit$I `headers@RqI;
  `BodyInit$I? `body@RqI;
  `USVString$ `referrer@RqI;
  `ReferrerPolicy$I `referrerPolicy@RqI;
  `RequestMode$I `mode@RqI;
  `RequestCredentials$I `credentials@RqI;
  `RequestCache$I `cache@RqI;
  `RequestRedirect$I `redirect@RqI;
  `DOMString$ `integrity@RqI;
  `boolean$ `keepalive@RqI;
  `AbortSignal$I? `signal@RqI;
  any `window@RqI; /* <span class="comment">
~NULL にしか設定できない。
◎
can only be set to null
</span> */
 };

enum `RequestDestination@I {
  "", "audio", "audioworklet", "document", "embed", "font", "frame", "iframe", "image", "manifest", "object", "paintworklet", "report", "script", "sharedworker", "style",  "track", "video", "worker", "xslt"
};
enum `RequestMode@I {
  "navigate", "same-origin", "no-cors", "cors"
};
enum `RequestCredentials@I {
  "omit", "same-origin", "include"
};
enum `RequestCache@I {
  "default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"
};
enum `RequestRedirect@I {
  "follow", "error", "manual"
};
</pre>

<p class="note">注記：
`serviceworker^l が `RequestDestination$I から省略されているのは、~JSからは観測し得ないからである。
それでも，実装は、`行先$rqとして それを~supportする必要がある。
`websocket^l が `RequestMode$I から省略されているのは、~JSからは観測し得ないからである。
◎
"serviceworker" is omitted from RequestDestination as it cannot be observed from JavaScript. Implementations will still need to support it as a destination. "websocket" is omitted from RequestMode as it cannot be used nor observed from JavaScript.
</p>

<p>
各 `Request$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`要請@Rq</dt>
	<dd>
`要請$。
◎
A Request object has an associated request (a request).
</dd>

	<dt>`~Headers@Rq</dt>
	<dd>
~NULL または `Headers$I ~obj
— 初期~時は ~NULL 。
◎
A Request object also has an associated headers (null or a Headers object), initially null.
</dd>

	<dt>`通達@Rq</dt>
	<dd>
`AbortSignal$I ~obj
— 初期~時は 新たな `AbortSignal$I ~obj。
◎
A Request object has an associated signal (an AbortSignal object), initially a new AbortSignal object.
</dd>
</dl>

<p>
`Request$I ~objの`本体$Bdは、その`要請$Rqの`本体$rqである。
◎
A Request object’s body is its request’s body.
</p>

<hr>

<!-- 
`Request@I
-->

<dl class="domintro">
	<dt>%request  = `new Request$m(%input [, %init ])</dt>
	<dd>
新たな `Request$I ~obj %request を返す
— その `url$m ~propは、 %input に応じて［
文字列ならば %input ／
`Request$I ~objであるならば %input の `url$m
］にされる。
◎
Returns a new request whose url property is input if input is a string, and input’s url if input is a Request object.
</dd>
	<dd>
<p>
%init 引数は、~objであり，次に挙げる~propを設定できる：
◎
The init argument is an object whose properties can be set as follows:
</p>

		<dl>
			<dt>`method$RqI</dt>
			<dd>
%request の `method$m を設定する文字列。
◎
A string to set request’s method.
</dd>

			<dt>`headers$RqI</dt>
			<dd>
%request の `headers$m を次のいずれかに設定する
⇒＃
`Headers$I ~obj,
~obj~literal【~JS Object 値】,
それぞれが 2 個の~itemからなる配列たちが成す配列
◎
A Headers object, an object literal, or an array of two-item arrays to set request’s headers.
</dd>

			<dt>`body$RqI</dt>
			<dd>
%request の`本体$rqを設定する［
`BodyInit$I ~obj, または ~NULL
］。
◎
A BodyInit object or null to set request’s body.
</dd>

			<dt>`referrer$RqI</dt>
			<dd>
%request の`~referrer$rqを設定する文字列
— 次のいずれか
⇒＃
同一-生成元~URL,
`about:client^l,
空~文字列
◎
A string whose value is a same-origin URL, "about:client", or the empty string, to set request’s referrer.
</dd>

			<dt>`referrerPolicy$RqI</dt>
			<dd>
%request の `referrerPolicy$m を設定する`~referrer施策$。
◎
A referrer policy to set request’s referrerPolicy.
</dd>

			<dt>`mode$RqI</dt>
			<dd>
%request の `mode$m を設定する文字列
— 要請は次のいずれになるかを指示する
⇒
~CORSを利用する,
同一-生成元~URLに制約される
◎
A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request’s mode.
</dd>

			<dt>`credentials$RqI</dt>
			<dd>
%request の `credentials$m を設定する文字列
— 
要請に伴う資格証は、次のいずれになるかを指示する
⇒＃
常に送信される,
決して送信されない,
同一-生成元~URLに限り送信される
◎
A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request’s credentials.
</dd>

			<dt>`cache$RqI</dt>
			<dd>
%request の `cache$m を設定する文字列
— 要請は~browserの~cacheとどうヤリトリするかを指示する。
◎
A string indicating how the request will interact with the browser’s cache to set request’s cache.
</dd>

			<dt>`redirect$RqI</dt>
			<dd>
%request の `redirect$m を設定する
— %request は~redirectに際し，次のどれにするかを指示する
⇒＃
追従する ／
~errorにする ／
その~redirectを`不透明~redirect絞込み応答$として返す【！ ＊in an opaque fashion】
◎
A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request’s redirect.
</dd>

			<dt>`integrity$RqI</dt>
			<dd>
%request の `integrity$m を設定する
— %request により~fetchされる資源の暗号用~hashを与える。
◎
A cryptographic hash of the resource to be fetched by request. Sets request’s integrity.
</dd>

			<dt>`keepalive$RqI</dt>
			<dd>
%request の `keepalive$m を設定する真偽値。
◎
A boolean to set request’s keepalive.
</dd>

			<dt>`signal$RqI</dt>
			<dd>
%request の `signal$m を設定する `AbortSignal$I 。
◎
An AbortSignal to set request’s signal.
</dd>

			<dt>`window$RqI</dt>
			<dd>
~NULL 以外の値はとり得ない。
%request と `Window$I との結付きを断つために利用される。
◎
Can only be null. Used to disassociate request from any Window.
</dd>
		</dl>
	</dd>

	<dt>%request . `method$m</dt>
	<dd>
%request の~HTTP~methodを返す。
既定では `GET^l 。
◎
Returns request’s HTTP method, which is "GET" by default.
</dd>

	<dt>%request . `url$m</dt>
	<dd>
%request の~URLを文字列として返す。
◎
Returns the URL of request as a string.
</dd>

	<dt>%request . `headers$m</dt>
	<dd>
%request に結付けられている一連の~headerからなる `Headers$I ~objを返す。
この~objには、~UAにより~network層にて追加される~headerは，織り込まれないことに注意
— 例：`Host^l ~headerなど。
◎
Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header.
</dd>

	<dt>%request . `destination$m</dt>
	<dd>
%request により要請される資源の種類を返す
— 例： `document^l ／ `script^l 。
◎
Returns the kind of resource requested by request, e.g., "document" or "script".
</dd>

	<dt>%request . `referrer$m</dt>
	<dd>
<p>
%request の~referrerを返す。
その値は：
</p>

<ul ><li>%init 内に明示的に設定された場合、同一-生成元~URLになり得る。
</li><li>空~文字列は、~referrerなしを指示する。
</li><li>大域【環境？~obj？】の既定の~referrerになるときは、 `about:client^l になる。
</li></ul>

<p>
これは、［
~fetchする間に為される要請の `Referer$h ~header
］の値を決定するときに利用される。
</p>
◎
Returns the referrer of request. Its value can be a same-origin URL if explicitly set in init, the empty string to indicate no referrer, and "about:client" when defaulting to the global’s default. This is used during fetching to determine the value of the `Referer` header of the request being made.
</dd>

	<dt>%request . `referrerPolicy$m</dt>
	<dd>
%request に結付けられている~referrer施策を返す。
これは、~fetchする間に %request の~referrer値を算出するときに利用される。
◎
Returns the referrer policy associated with request. This is used during fetching to compute the value of the request’s referrer.
</dd>

	<dt>%request . `mode$m</dt>
	<dd>
%request に結付けられている`~mode$rqを返す。
それは，文字列であり、要請が［
~CORSを利用する, 
同一-生成元~URLに制約される
］のいずれになるかを指示する。
◎
Returns the mode associated with request, which is a string indicating whether the request will use CORS, or will be restricted to same-origin URLs.
</dd>

	<dt>%request . `credentials$m</dt>
	<dd>
%request に結付けられている`資格証~mode$rqを返す。
それは，文字列であり、送信される要請に，資格証を［
常に伴わせる, 決して伴わせない, 同一-生成元~URLに限り伴わせる
］のいずれになるかを指示する。
◎
Returns the credentials mode associated with request, which is a string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL.
</dd>

	<dt>%request . `cache$m</dt>
	<dd>
%request に結付けられている`~cache~mode$rqを返す。
それは，文字列であり、［
要請を~fetchする際に~browserの~cacheとどうヤリトリするか
］を指示する。
◎
Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser’s cache when fetching.
</dd>

	<dt>%request . `redirect$m</dt>
	<dd>
%request に結付けられている`~redirect~mode$rqを返す。
それは，文字列であり、［
~fetchする間，要請に対する~redirectはどう取扱われるか
］を指示する。
既定では、`要請$は~redirectに追従することになる。
◎
Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.
</dd>

	<dt>%request . `integrity$m</dt>
	<dd>
%request の下位資源~完全性~metadataを返す。
それは、~fetchされる資源の暗号用~hashを与える。
その値は、空白で区切られた
【！multiple】
いくつかの~hashからなる。
`SRI$r
◎
Returns request’s subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]
</dd>

	<dt>%request . `keepalive$m</dt>
	<dd>
%request が［
それを作成した大域~objの外で残存できるかどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request can outlive the global in which it was created.
</dd>

	<dt>%request . `isReloadNavigation$m</dt>
	<dd>
%request が［
~reload~navi用かどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request is for a reload navigation.
</dd>

	<dt>%request . `isHistoryNavigation$m</dt>
	<dd>
%request が［
（前後~pageへの）履歴~navi用かどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request is for a history navigation (a.k.a. back-foward navigation).
</dd>

	<dt>%request . `signal$m</dt>
	<dd>
%request に結付けられている通達を返す。
それは， `AbortSignal$I ~objであり、［
%request は中止されたかどうか, および
その中止-~event~handler
］を指示する。
◎
Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`new Request(input, init)@m
構築子~手続きは：
◎
The new Request(input, init) constructor steps are:
</p>
<ol>
	<li>
%要請 ~LET ~NULL
◎
Let request be null.
</li>
	<li>
%~fallback~mode ~LET ~NULL
◎
Let fallbackMode be null.
</li>
	<li>
%~fallback資格証 ~LET ~NULL
◎
Let fallbackCredentials be null.
</li>
	<li>
%基底~URL ~LET コレに`関連な設定群~obj$の`~API用~基底~URL$enV
◎
Let baseURL be this’s relevant settings object’s API base URL.
</li>
	<li>
%通達 ~LET ~NULL
◎
Let signal be null.
</li>
	<li>
<p>
~IF［
%input は文字列である
］：
◎
If input is a string, then:
</p>
		<ol>
			<li>
%解析済み~URL ~LET `~URL構文解析する$( %input, %基底~URL )
◎
Let parsedURL be the result of parsing input with baseURL.
</li>
			<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
			<li>
~IF［
%解析済み~URL は`資格証を含む$url
］
⇒
~THROW `TypeError$E
◎
If parsedURL includes credentials, then throw a TypeError.
</li>
			<li>
%要請 ~SET 次のようにされた，新たな`要請$
⇒
`~URL$rq ~SET %解析済み~URL
◎
Set request to a new request whose url is parsedURL.
</li>
			<li>
%~fallback~mode ~SET `cors^l
◎
Set fallbackMode to "cors".
</li>
			<li>
%~fallback資格証 ~SET `same-origin^l
◎
Set fallbackCredentials to "same-origin".
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%input は `Request$I ~objである。
◎
Assert: input is a Request object.
</li>
			<li>
%要請 ~SET %input の`要請$Rq
◎
Set request to input’s request.
</li>
			<li>
%通達 ~SET %input の`通達$Rq
◎
Set signal to input’s signal.
</li>
		</ol>
	</li>
	<li>
%生成元 ~LET コレに`関連な設定群~obj$の`生成元$enV
◎
Let origin be this’s relevant settings object’s origin.
</li>
	<li>
%~window ~LET `client^l
◎
Let window be "client".
</li>
	<li>
~IF［
%要請 の`~window$rqは`環境~設定群~obj$である
］~AND［
( %要請 の`~window$rqの`生成元$enV, %生成元 )
は`同一-生成元$である
］
⇒
%~window ~SET %要請 の`~window$rq
◎
If request’s window is an environment settings object and its origin is same origin with origin, then set window to request’s window.
</li>
	<li>
<p>
%init[ "`window$RqI" ] に応じて：
</p>
		<ul class="switch">
			<li>
ε
⇒
何もしない
</li>
			<li>
~NULL
⇒
%~window ~SET `no-window^l
</li>
			<li>
その他
⇒
~THROW `TypeError$E
</li>
		</ul>
◎
If init["window"] exists and is non-null, then throw a TypeError.
◎
If init["window"] exists, then set window to "no-window".
</li>
	<li>
%要請 ~SET 次のように設定された，新たな`要請$
⇒＃
`~URL$rq ~SET %要請 の`現在の~URL$rq,
`~method$rq ~SET %要請 の`~method$rq,
`~header~list$rq ~SET %要請 の`~header~list$rqの複製,
`非安全~要請~flag$rq ~SET ~T,
`~client$rq ~SET コレに`関連な設定群~obj$,
`~window$rq ~SET %~window,
`優先度$rq ~SET %要請 の`優先度$rq,
`生成元$rq ~SET `client^l,
`~referrer$rq ~SET %要請 の`~referrer$rq,
`~referrer施策$rq ~SET %要請 の`~referrer施策$rq,
`~mode$rq ~SET %要請 の`~mode$rq,
`資格証~mode$rq ~SET %要請 の`資格証~mode$rq,
`~cache~mode$rq ~SET %要請 の`~cache~mode$rq,
`~redirect~mode$rq ~SET %要請 の`~redirect~mode$rq,
`完全性~metadata$rq ~SET %要請 の`完全性~metadata$rq,
`~keepalive~flag$rq ~SET %要請 の`~keepalive~flag$rq,
`~reload~navi~flag$rq ~SET %要請 の`~reload~navi~flag$rq,
`履歴~navi~flag$rq ~SET %要請 の`履歴~navi~flag$rq
◎
Set request to a new request with the following properties:
◎
URL
• request’s current URL.
method
• request’s method.
header list
• A copy of request’s header list.
unsafe-request flag
• Set.
client
• This’s relevant settings object.
window
• window.
priority
• request’s priority.
origin
• "client".
referrer
• request’s referrer.
referrer policy
• request’s referrer policy.
mode
• request’s mode.
credentials mode
• request’s credentials mode.
cache mode
• request’s cache mode.
redirect mode
• request’s redirect mode.
integrity metadata
• request’s integrity metadata.
keepalive flag
• request’s keepalive flag.
reload-navigation flag
• request’s reload-navigation flag.
history-navigation flag
• request’s history-navigation flag.
</li>
	<li>
<p>
~IF［
%init は`空$mapでない
］：
◎
If init is not empty, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`~mode$rq ~EQ `navigate^l
］
⇒
%要請 の`~mode$rq ~SET `same-origin^l
◎
If request’s mode is "navigate", then set it to "same-origin".
</li>
			<li>
%要請 の
⇒＃
`~reload~navi~flag$rq ~SET ~F,
`履歴~navi~flag$rq ~SET ~F,
`~referrer$rq ~SET `client^l,
`~referrer施策$rq ~SET 空~文字列
◎
Unset request’s reload-navigation flag.
◎
Unset request’s history-navigation flag.
◎
Set request’s referrer to "client"
◎
Set request’s referrer policy to the empty string.
</li>
		</ol>

<p class="note">注記：
これは、~swが要請
— 例えば，非同一-生成元~stylesheetからの画像 —
を “~redirect” して 改変を加えたときに、元の~source（すなわち，非同一-生成元~stylesheet）から来たのでなく，その~swから来たように現れることを確保するために行われる。
元の~sourceは，~swと同じ種類の要請~すら生成できないかもしれないので、このことは重要になる。
これが行われないと、元の~sourceを信用する~serviceは，悪用されかねない
— そこまで行き着くことは まず無さそうだが。
◎
This is done to ensure that when a service worker "redirects" a request, e.g., from an image in a cross-origin style sheet, and makes modifications, it no longer appears to come from the original source (i.e., the cross-origin style sheet), but instead from the service worker that "redirected" the request. This is important as the original source might not even be able to generate the same kind of requests as the service worker. Services that trust the original source could therefore be exploited were this not done, although that is somewhat farfetched.
</p>

	</li>
	<li>
%~referrer ~LET %init[ "`referrer$RqI" ]
◎
↓</li>
	<li>
<p>
~IF［
%~referrer ~NEQ ε
］：
◎
If init["referrer"] exists, then:
• Let referrer be init["referrer"].
</p>
		<ol>
			<li>
~IF［
%~referrer ~EQ 空~文字列
］
⇒＃
%要請 の`~referrer$rq ~SET `no-referrer^l
◎
If referrer is the empty string, then set request’s referrer to "no-referrer".
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%解析済み~referrer ~LET `~URL構文解析する$( %~referrer, %基底~URL )
◎
Let parsedReferrer be the result of parsing referrer with baseURL.
</li>
					<li>
~IF［
%解析済み~referrer ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedReferrer is failure, then throw a TypeError.
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>

						<ul>
							<li>
<p>
%解析済み~referrer は次をいずれも満たす
</p>

<ul><li>`基底~URL不可用~flag$url ~EQ ~T
</li><li>`~scheme$url ~EQ `about^l
</li><li>`~path$url は 単独の文字列 `client^l からなる
</li></ul>
◎
parsedReferrer’s cannot-be-a-base-URL flag is set, scheme is "about", and path contains a single string "client"
</li>
							<li>
( %解析済み~referrer の`生成元$url, %生成元 )
は`同一-生成元$でない
◎
parsedReferrer’s origin is not same origin with origin
</li>
						</ul>
<p>
…ならば
⇒
%要請 の`~referrer$rq ~SET `client^l
◎
then set request’s referrer to "client".
</p>

					</li>
					<li>
~ELSE
⇒
%要請 の`~referrer$rq ~SET %解析済み~referrer
◎
Otherwise, set request’s referrer to parsedReferrer.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%init[ "`referrerPolicy$RqI" ] ~NEQ ε
］
⇒
%要請 の`~referrer施策$rq ~SET その値
◎
If init["referrerPolicy"] exists, then set request’s referrer policy to it.
</li>
	<li>
%~mode ~LET ［
%init[ "`mode$RqI" ] ~NEQ ε ならば その値 ／
~ELSE_ %~fallback~mode
］
◎
Let mode be init["mode"] if it exists, and fallbackMode otherwise.
</li>
	<li>
~IF［
%~mode ~EQ `navigate^l
］
⇒
~THROW `TypeError$E
◎
If mode is "navigate", then throw a TypeError.
</li>
	<li>
~IF［
%~mode ~NEQ ~NULL
］
⇒
%要請 の`~mode$rq ~SET %~mode
◎
If mode is non-null, set request’s mode to mode.
</li>
	<li>
%資格証 ~LET ［
%init[ "`credentials$RqI" ] ~NEQ ε ならば その値 ／
~ELSE_ %~fallback資格証
］
◎
Let credentials be init["credentials"] if it exists, and fallbackCredentials otherwise.
</li>
	<li>
~IF［
%資格証 ~NEQ ~NULL
］
⇒
%要請 の`資格証~mode$rq ~SET %資格証
◎
If credentials is non-null, set request’s credentials mode to credentials.
</li>
	<li>
~IF［
%init[ "`cache$RqI" ] ~NEQ ε
］
⇒
%要請 の`~cache~mode$rq ~SET その値
◎
If init["cache"] exists, then set request’s cache mode to it.
</li>
	<li>
~IF［
%要請 の`~cache~mode$rq ~EQ `only-if-cached^l
］~AND［
%要請 の`~mode$rq ~NEQ `same-origin^l
］
⇒
~THROW `TypeError$E
◎
If request’s cache mode is "only-if-cached" and request’s mode is not "same-origin", then throw a TypeError.
</li>
	<li>
~IF［
%init[ "`redirect$RqI" ] ~NEQ ε
］
⇒
%要請 の`~redirect~mode$rq ~SET その値
◎
If init["redirect"] exists, then set request’s redirect mode to it.
</li>
	<li>
~IF［
%init[ "`integrity$RqI" ] ~NEQ ε
］
⇒
%要請 の`完全性~metadata$rq ~SET その値
◎
If init["integrity"] exists, then set request’s integrity metadata to it.
</li>
	<li>
%要請 の`~keepalive~flag$rq ~SET ［
%init[ "`keepalive$RqI" ] ~EQ ~T ならば ~T ／
~ELSE_ ~F
］
◎
If init["keepalive"] exists, then set request’s keepalive flag if init["keepalive"] is true, and unset it otherwise.
</li>
	<li>
%~method ~LET %init[ "`method$RqI" ]
◎
↓</li>
	<li>
<p>
~IF［
%~method ~NEQ ε
］：
◎
If init["method"] exists, then:
• Let method be init["method"].
</p>
		<ol>
			<li>
~IF［
%~method は`~method$でない
］~OR［
%~method は`禁止~method$である
］
⇒
~THROW `TypeError$E
◎
If method is not a method or method is a forbidden method, then throw a TypeError.
</li>
			<li>
%要請 の`~method$rq  ~SET `~methodを正規化する$( %~method )
◎
Normalize method.
◎
Set request’s method to method.
</li>
		</ol>
	</li>
	<li>
~IF［
%init[ "`signal$RqI" ] ~NEQ ε
］
⇒
%通達 ~SET その値
◎
If init["signal"] exists, then set signal to it.
</li>
	<li>
コレの`要請$Rq ~SET %要請
◎
Set this’s request to request.
</li>
	<li>
<p>
~IF［
%通達 ~NEQ ~NULL
］
⇒
`通達に追従させる$( コレの`通達$Rq, %通達 )
◎
If signal is not null, then make this’s signal follow signal.
</li>
	<li>
コレの`~Headers$Rq ~SET `新たな~Headers$( `request^l, %要請 の`~header~list$rq )
◎
Set this’s headers to a new Headers object, whose header list is request’s header list, and guard is "request".
</li>
	<li>
<p>
~IF［
コレの`要請$Rqの`~mode$rq ~EQ `no-cors^l
］：
◎
If this’s request’s mode is "no-cors", then:
</p>
		<ol>
			<li>
~IF［
コレの`要請$Rqの`~method$rqは `~CORS安全とされる~method$でない
］
⇒
~THROW `TypeError$E
◎
If this’s request’s method is not a CORS-safelisted method, then throw a TypeError.
</li>
			<li>
コレの`~Headers$Rqの`~guard$Hl  ~SET `request-no-cors^l
◎
Set this’s headers’s guard to "request-no-cors".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%init は`空$mapでない
］：
◎
If init is not empty, then:
</p>

<p class="note">注記：
%headers は，この~mode【 %~mode？ 】では許容されない~headerを包含するかもしれないので、この段で無毒化される。
他の場合、それは以前に無毒化されたか，特権的~APIによる作成-時から改変されてない。
◎
The headers are sanitised as they might contain headers that are not allowed by this mode. Otherwise, they were previously sanitised or are unmodified since creation by a privileged API.
</p>
		<ol>
			<li>
%headers ~LET %init[ "`headers$RqI" ]
◎
↓</li>
			<li>
~IF［
%headers ~EQ ε
］
⇒
%headers ~SET コレの`~Headers$Rqの複製 — `~header~list$Hlも含めて複製する
◎
Let headers be a copy of this’s headers and its associated header list.
◎
If init["headers"] exists, then set headers to init["headers"].
</li>
			<li>
コレの`~Headers$Rqの`~header~list$Hlを空にする
◎
Empty this’s headers’s header list.
</li>
			<li>
~IF［
%headers は `Headers$I ~objである
］
⇒
%headers の`~header~list$Hl内の
~EACH( %~header )
に対し
⇒
コレの`~Headers$Rqに
( %~header の`名前$hd / %~header の`値$hd )
を`付加する$Hl
◎
If headers is a Headers object, then for each header in its header list, append header’s name/header’s value to this’s headers.
</li>
			<li>
~ELSE
⇒
コレの`~Headers$Rqを %headers で`埋める$Hl
◎
Otherwise, fill this’s headers with headers.
</li>
		</ol>
	</li>
	<li>
%入力~本体 ~LET %input に応じて
⇒＃
`Request$I ~objであるならば %input の`要請$Rqの`本体$rq ／
~ELSE_ ~NULL
◎
Let inputBody be input’s request’s body if input is a Request object, and null otherwise.
</li>
	<li>
%本体~member ~LET ［
%init[ "`body$RqI" ] ~NEQ ε ならば その値 ／
~ELSE_ ~NULL
］
◎
↓</li>
	<li>
~IF［［
%本体~member ~NEQ ~NULL
］~OR［
%入力~本体 ~NEQ ~NULL
］］~AND［
%要請 の`~method$rq ~IN { `GET$hm, `HEAD$hm }
］
⇒
~THROW `TypeError$E
◎
If either init["body"] exists and is non-null or inputBody is non-null, and request’s method is `GET` or `HEAD`, then throw a TypeError.
</li>
	<li>
%本体 ~LET %入力~本体
◎
Let body be inputBody.
</li>
	<li>
<p>
~IF［
%本体~member ~NEQ ~NULL
］：
◎
If init["body"] exists and is non-null, then:
</p>
		<ol>
			<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
			<li>
%~keepalive ~LET %init[ "`keepalive$RqI" ] に応じて
⇒＃
~T ならば `~keepalive^i ／
~ELSE_ ε
◎
↓</li>
			<li>
( %本体, %内容~型 ) ~SET `本体と内容~型を抽出する$( %本体~member, %~keepalive )
◎
If init["keepalive"] exists and is true, then set body and Content-Type to the result of extracting init["body"], with keepalive set to true.
◎
Otherwise, set body and Content-Type to the result of extracting init["body"].
</li>
			<li>
~IF［
%内容~型 ~NEQ ~NULL
］~AND［［
コレの`~Headers$Rqの`~header~list$Hl
］内に［
`Content-Type$h を`名前に持つ~header$
］は無い
］
⇒
コレの`~Headers$Rqに
( `Content-Type$h / %内容~型 )
を`付加する$Hl
◎
If Content-Type is non-null and this’s headers’s header list does not contain `Content-Type`, then append `Content-Type`/Content-Type to this’s headers.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%本体 ~NEQ ~NULL
］~AND［
%本体 の`~source$bd ~EQ ~NULL
］：
◎
If body is non-null and body’s source is null, then:
</p>
		<ol>
			<li>
~IF［
コレの`要請$Rqの`~mode$rq ~NIN { `same-origin^l, `cors^l }
］
⇒
~THROW `TypeError$E
◎
If this’s request’s mode is neither "same-origin" nor "cors", then throw a TypeError.
</li>
			<li>
コレの`要請$Rqの`~CORS予行~利用~flag$rq ~SET ~T
◎
Set this’s request’s use-CORS-preflight flag.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力~本体 ~EQ %本体
］~AND［［
%input は`妨げられている$Bd
］~OR［
%input は`~lockされている$Bd
］］
⇒
~THROW `TypeError$E
◎
If inputBody is body and input is disturbed or locked, then throw a TypeError.
</li>
	<li>
<p>
~IF［
%入力~本体 ~EQ %本体
］~AND［
%入力~本体 ~NEQ ~NULL
］：
◎
If inputBody is body and inputBody is non-null, then:
</p>
		<ol>
			<li>
( %ws, %rs ) ~LET `~identity形式変換~stream$の ( `可書~側$, `可読~側$ )
◎
Let ws and rs be the writable side and readable side of an identity transform stream, respectively.
</li>
			<li>
<p>
%~promise ~LET `ReadableStreamPipeTo$A( %入力~本体, %ws, `false^jv, `false^jv, `false^jv, `undefined^jv )
◎
Let promise be the result of calling ReadableStreamPipeTo(inputBody, ws, false, false, false, undefined).
</p>

<p class="note">注記：
これは %入力~本体 の`~stream$bdが，即時に［
`~lockされている$RS, かつ
`妨げられている$RS
］ようにする。
◎
This makes inputBody’s stream locked and disturbed immediately.
</p>
			</li>
			<li>
%~promise.`PromiseIsHandled^sl ~SET `true^jv
◎
Set promise.[[PromiseIsHandled]] to true.
</li>
			<li>
%本体 ~SET 次のようにされた，新たな`本体$
⇒＃
`~stream$bd ~SET %rs；
`~source$bd ~SET %入力~本体 の`~source$bd；
`総~byte数$bd ~SET %入力~本体 の`総~byte数$bd
◎
Set body to a new body whose stream is rs, whose source is inputBody’s source, and whose total bytes is inputBody’s total bytes.
</li>
		</ol>
	</li>
	<li>
コレの`要請$Rqの`本体$rq ~SET %本体
◎
Set this’s request’s body to body.
</li>
	<li>
コレの`~MIME型$Bd ~SET `~header~listから~MIME型を抽出する$( コレの`要請$Rqの`~header~list$rq )
◎
Set this’s MIME type to the result of extracting a MIME type from this’s request’s header list.
</li>
</ol>
</div>

<div class="algo">
`method@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~method$rq
◎
The method getter steps are to return this’s request’s method.
</div>

<div class="algo">
`url@m
取得子~手続きは：は、次の結果を返すモノトスル
⇒
`~URLを直列化する$( コレの`要請$Rqの`~URL$rq )
◎
The url getter steps are to return this’s request’s URL, serialized.
</div>

<div class="algo">
`headers@m
取得子~手続きは
⇒
~RET コレの`~Headers$Rq
◎
The headers getter steps are to return this’s headers.
</div>

<div class="algo">
`destination@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`行先$rq
◎
The destination getter are to return this’s request’s destination.
</div>

<div class="algo">
`referrer@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~referrer$rq %~referrer に応じて
⇒＃
`no-referrer^l ならば空~文字列／
`client^l ならば `about:client^l／
~ELSE_ `~URLを直列化する$( %~referrer )
◎
The referrer getter steps are:
• If this’s request’s referrer is "no-referrer", then return the empty string.
• If this’s request’s referrer is "client", then return "about:client".
• Return this’s request’s referrer, serialized.
</div>

<div class="algo">
`referrerpolicy@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~referrer施策$rq
◎
The referrerPolicy getter steps are to return this’s request’s referrer policy.
</div>

<div class="algo">
`mode@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~mode$rq
◎
The mode getter steps are to return this’s request’s mode.
</div>

<div class="algo">
`credentials@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`資格証~mode$rq
◎
The credentials getter steps are to return this’s request’s credentials mode.
</div>

<div class="algo">
`cache@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~cache~mode$rq
◎
The cache getter steps are to return this’s request’s cache mode.
</div>

<div class="algo">
`redirect@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~redirect~mode$rq
◎
The redirect getter steps are to return this’s request’s redirect mode.
</div>

<div class="algo">
`integrity@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`完全性~metadata$rq
◎
The integrity getter steps are to return this’s request’s integrity metadata.
</div>

<div class="algo">
`keepalive@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~keepalive~flag$rq
◎
The keepalive getter steps are to return true if this’s request’s keepalive flag is set; otherwise false.
</div>

<div class="algo">
`isReloadNavigation@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~reload~navi~flag$rq
◎
The isReloadNavigation getter steps are to return true if this’s request’s reload-navigation flag is set; otherwise false.
</div>

<div class="algo">
`isHistoryNavigation@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`履歴~navi~flag$rq
◎
The isHistoryNavigation getter steps are to return true if this’s request’s history-navigation flag is set; otherwise false.
</div>

<div class="algo">
`signal@m
取得子~手続きは
⇒
~RET コレの`通達$Rq
◎
The signal getter steps are to return this’s signal.
</div>

<div class="algo">
<p>
`clone()@m
~method~手続きは：
◎
The clone() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`妨げられている$Bd
］~OR［
コレは`~lockされている$Bd
］
⇒
~THROW `TypeError$E
◎
If this is disturbed or locked, then throw a TypeError.
</li>
	<li>
%~Request~objの~clone ~LET 新たな `Request$I ~obj
◎
Let clonedRequestObject be a new Request object.
</li>
	<li>
%要請の~clone ~LET `要請を~cloneする$( コレの`要請$Rq )
◎
Let clonedRequest be the result of cloning this’s request.
</li>
	<li>
%~Request~objの~clone の
⇒＃
`要請$Rq ~SET %要請の~clone,
`~Headers$Rq ~SET `新たな~Headers$( コレの`~Headers$Rqの`~guard$Hl, %要請の~clone の`~header~list$Hl )
◎
Set clonedRequestObject’s request to clonedRequest.
◎
Set clonedRequestObject’s headers to a new Headers object with the following properties:
◎
header list
• clonedRequest’s header list.
guard
• This’s headers’s guard.
</li>
	<li>
`通達に追従させる$( %~Request~objの~clone の`通達$Rq, コレの`通達$Rq )
◎
Make clonedRequestObject’s signal follow this’s signal.
</li>
	<li>
~RET %~Request~objの~clone
◎
Return clonedRequestObject.
</li>
</ol>
</div>

		</section>
		<section id="response-class">
<h3 title="Response class">5.5. `Response^I ~class</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `Response@I {
  `Response$mc(optional `BodyInit$I? %body = null, optional `ResponseInit$I %init = {});

  [`NewObject$] static `Response$I `error$m();
  [`NewObject$] static `Response$I `redirect$m(
      `USVString$ %url,
      optional `unsigned short$ %status = 302
  );

  readonly attribute `ResponseType$I `type$m;

  readonly attribute `USVString$ `url$m;
  readonly attribute `boolean$ `redirected$m;
  readonly attribute `unsigned short$ `status$m;
  readonly attribute `boolean$ `ok$m;
  readonly attribute `ByteString$ `statusText$m;
  [`SameObject$] readonly attribute `Headers$I `headers$m;

  [`NewObject$] `Response$I `clone$m();
};
`Response$I includes `Body$I;

dictionary `ResponseInit@I {
  `unsigned short$ `status@RsI = 200;
  `ByteString$ `statusText@RsI = "";
  `HeadersInit$I `headers@RsI;
};

enum `ResponseType@I {
  "basic", "cors", "default", "error", "opaque", "opaqueredirect"
};
</pre>

<!-- 
`Response@I
-->

<p>
各 `Response$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`応答@Rs</dt>
	<dd>
`応答$。
◎
A Response object has an associated response (a response).
</dd>

	<dt>`~Headers@Rs</dt>
	<dd>
~NULL または `Headers$I ~obj
— 初期~時は ~NULL 。
◎
A Response object also has an associated headers (null or a Headers object), initially null.
</dd>
</dl>

<p>
`新たな~Response@( %応答, %~Headers )
という表記は、次のようにされた，新たな `Response$I ~objを表すとする
⇒＃
`応答$Rs ~SET %応答,
`~Headers$Rs ~SET %~Headers
</p>

<p class="trans-note">【
この表記は、簡潔に述べるために，この訳に導入したものである。
】</p>

<p>
`Response$I ~objの`本体$Bdは、その`応答$Rsの`本体$rsである。
◎
A Response object’s body is its response’s body.
</p>

<div class="algo">
<p>
`new Response(body, init)@m
構築子~手続きは：
◎
The new Response(body, init) constructor steps are:
</p>
<ol>
	<li>
~IF［
%init[ "`status$RsI" ] ~NIN { `200^st 〜 `599^st }
］
⇒
~THROW `RangeError$E
◎
If init["status"] is not in the range 200 to 599, inclusive, then throw a RangeError.
</li>
	<li>
~IF［
%init[ "`statusText$RsI" ] は
`reason-phrase$p ~token生成規則に合致しない
］
⇒
~THROW `TypeError$E
◎

If init["statusText"] does not match the reason-phrase token production, then throw a TypeError.
</li>
	<li>
%応答 ~LET 新たな`応答$
◎
↓</li>
	<li>
コレの`応答$Rs ~SET %応答
◎
Set this’s response to a new response.
</li>
	<li>
コレの`~Headers$Rs ~SET `新たな~Headers$( `response^l, %応答 【！r】の`~header~list$rs )
◎
Set this’s headers to a new Headers object, whose header list is r’s response’s header list, and guard is "response".
</li>
	<li>
%応答 の`状態s$rs ~SET %init[ "`status$RsI" ]
◎
Set this’s response’s status to init["status"].
</li>
	<li>
%応答 の`状態s~message$rs ~SET %init[ "`statusText$RsI" ]
◎
Set this’s response’s status message to init["statusText"].
</li>
	<li>
~IF［
%init[ "`headers$RsI" ] ~NEQ ε
］
⇒
コレの`~Headers$Rsを %init[ "`headers$RsI" ] で`埋める$Hl
◎
If init["headers"] exists, then fill this’s headers with init["headers"].
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is non-null, then:
</p>
		<ol>
			<li>
<p>
~IF［
%init[ "`status$RsI" ] は`~null本体~状態s$である
］
⇒
~THROW `TypeError$E
◎
If init["status"] is a null body status, then throw a TypeError.
</p>

<p class="note">注記：
`101$st は、この段には影響しない
— それは、他所におけるその利用に因り，`~null本体~状態s$に含まれているので。
◎
101 is included in null body status due to its use elsewhere. It does not affect this step.
</p>
			</li>
			<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
			<li>
( %応答 の`本体$rs, %内容~型 ) ~SET `本体と内容~型を抽出する$( %body )
◎
Set this’s response’s body and Content-Type to the result of extracting body.
</li>
			<li>
~IF［
%内容~型 ~NEQ ~NULL
］~AND［
%応答 の`~header~list$rs内に［
`Content-Type$h を`名前に持つ~header$
］は無い
］
⇒
%応答 の`~header~list$rsに`~headerを付加する$(
`Content-Type$h / %内容~型
)
◎
If Content-Type is non-null and this’s response’s header list does not contain `Content-Type`, then append `Content-Type`/Content-Type to this’s response’s header list.
</li>
		</ol>
	</li>
	<li>
コレの`~MIME型$Bd ~SET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Set this’s MIME type to the result of extracting a MIME type from this’s response’s header list.
</li>
</ol>
</div>

<div class="algo">
`error()@m
静的~method~手続きは
⇒
~RET `新たな~Response$( 新たな`~network~error$, `新たな~Headers$( `immutable^l ) )
◎
The static error() method steps are:
• Let r be a new Response object, whose response is a new network error.
• Set r’s headers to a new Headers object whose guard is "immutable".
• Return r.
</div>

<div class="algo">
<p>
`redirect(url, status)@m
静的~method~手続きは：
◎
The static redirect(url, status) method steps are:
</p>
<ol>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %url, `現在の設定群~obj$の`~API用~基底~URL$enV )
◎
Let parsedURL be the result of parsing url with current settings object’s API base URL.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
~IF［
%status は `~redirect状態s$でない
］
⇒
~THROW `RangeError$E
◎
If status is not a redirect status, then throw a RangeError.
</li>
	<li>
%応答 ~LET 新たな`応答$
◎
↓</li>
	<li>
%R ~LET `新たな~Response$( %応答, `新たな~Headers$( `immutable^l ) )
◎
Let r be a new Response object, whose response is a new response.
◎
Set r’s headers to a new Headers object whose guard is "immutable".
</li>
	<li>
%応答 の`状態s$rs ~SET %status
◎
Set r’s response’s status to status.
</li>
	<li>
%値 ~LET `同型に符号化する$( `~URLを直列化する$( %解析済み~URL ) )
◎
Let value be parsedURL, serialized and isomorphic encoded.
</li>
	<li>
%応答 の`~header~list$rsに`~headerを付加する$(
`Location$h / %値
)
◎
Append `Location`/value to r’s response’s header list.
</li>
	<li>
~RET %R
◎
Return r.
</li>
</ol>
</div>

<div class="algo">
`type@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`種別$rs
◎
The type getter steps are to return this’s response’s type.
</div>

<div class="algo">
`url@m
取得子~手続きは
⇒
~RET コレの`応答$Rs の`~URL$rs %~url に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `~URLを直列化する$( %~url, `素片は除外する^i ) `URL$r
◎
The url getter steps are to return the empty string if this’s response’s URL is null; otherwise this’s response’s URL, serialized with the exclude-fragment flag set. [URL]
</div>

<div class="algo">
<p>
`redirected@m
取得子~手続きは
⇒
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
コレの`応答$Rsの`~URL~list$rsの`~size$ ~GT 1
◎
The redirected getter steps are to return true if this’s response’s URL list has more than one item; otherwise false.
</p>

<p class="note">注記：
~redirectの結果による`応答$をはじくときは、~APIを通して直に行う
— 例えば
`fetch(url, { redirect:"error" })^c
のように。
こうすれば、安全でないものにもなり得る`応答$が不用意に漏洩されるのを~~防げる。
◎
To filter out responses that are the result of a redirect, do this directly through the API, e.g., fetch(url, { redirect:"error" }). This way a potentially unsafe response cannot accidentally leak.
</p>
</div>

<div class="algo">
`status@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`状態s$rs
◎
The status getter steps are to return this’s response’s status.
</div>

<div class="algo">
`ok@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`状態s$rsに応じて
⇒＃
`~ok状態s$であるならば ~T ／
~ELSE_ ~F
◎
The ok getter steps are to return true if this’s response’s status is an ok status; otherwise false.
</div>

<div class="algo">
`statusText@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`状態s~message$rs
◎
The statusText getter steps are to return this’s response’s status message.
</div>

<div class="algo">
`headers@m
取得子~手続きは
⇒
~RET コレの`~Headers$Rs
◎
The headers getter steps are to return this’s headers.
</div>

<div class="algo">
<p>
`clone()@m
~method~手続きは：
◎
The clone() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`妨げられている$Bd
］~OR［
コレは`~lockされている$Bd
］
⇒
~THROW `TypeError$E
◎
If this is disturbed or locked, then throw a TypeError.
</li>
	<li>
%応答の~clone ~LET `応答を~cloneする$( コレの`応答$Rs )
◎
Let clonedResponseObject be a new Response object.
◎
Let clonedResponse be the result of cloning this’s response.
</li>
	<li>
%~Response~objの~clone ~LET `新たな~Response$( %応答の~clone, `新たな~Headers$( コレの`~Headers$Rsの`~guard$Hl, %応答の~clone の`~header~list$rs ) )
◎
Set clonedResponseObject’s response to clonedResponse.
◎
Set clonedResponseObject’s headers to a new Headers object whose header list is set to clonedResponse’s header list, and guard is this’s headers’s guard.
</li>
	<li>
~RET %~Response~objの~clone
◎
Return clonedResponseObject.
◎
Return clonedResponse.
</li>
</ol>
</div>

		</section>
		<section id="fetch-method">
<h3 title="Fetch method">5.6. `fetch^m ~method</h3>

<pre class="idl">
partial interface mixin `WindowOrWorkerGlobalScope$I {
  [`NewObject$] `Promise$&lt;`Response$I&gt; `fetch$m(
      `RequestInfo$I %input,
      optional `RequestInit$I %init = {}
  );
};
</pre>

<div class="algo">
<p>
`fetch(input, init)@m
~method~手続きは：
◎
The fetch(input, init) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
%~Request~obj ~LET 新たな `Request$I ~obj
◎
↓</li>
	<li>
%~Request~obj 上の `new Request$m 構築子~手続き( %input, %init )
【！構築子の初期~値を呼出した結果】
⇒
例外が投出された場合は
⇒＃
その例外で %~promise を`却下する$；
~RET %~promise
◎
Let requestObject be the result of invoking the initial value of Request as constructor with input and init as arguments. If this throws an exception, reject p with it and return p.
</li>
	<li>
%要請 ~LET %~Request~obj の`要請$Rq
◎
Let request be requestObject’s request.
</li>
	<li>
<p>
~IF［
%~Request~obj の`通達$Rqの`中止-済み~flag$aB ~EQ ~T
］：
◎
If requestObject’s signal’s aborted flag is set, then:
</p>
		<ol>
			<li>
`~fetchを中止する$( %~promise, %要請, ~NULL )
◎
Abort fetch with p, request, and null.
</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</li>
	<li>
~IF［
%要請 の`~client$rqの`大域~obj$enVは `ServiceWorkerGlobalScope$I ~objである
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
◎
If request’s client’s global object is a ServiceWorkerGlobalScope object, then set request’s service-workers mode to "none".
</li>
	<li>
%~Response~obj ~LET 次のようにされた，新たな `Response$I ~obj
⇒
`~Headers$Rs ~SET `新たな~Headers$( `immutable^l )
【 %~Response~obj の`応答$Rsは、後で設定される。】
◎
Let responseObject be a new Response object and a new associated Headers object whose guard is "immutable".
</li>
	<li>
<p>
%局所的に中止された ~LET ~F
◎
Let locallyAborted be false.
</p>

<p class="note">注記：
これは、~fetchの~callと同じ~threadから中止するよう要請されたとき，~promiseを却下する時機を予測-可能にするためにある。
◎
This lets us reject promises with predictable timing, when the request to abort comes from the same thread as the call to fetch.
</p>
	</li>
	<li>
<p>
`通達に~algoを追加する$( %~Request~obj の`通達$Rq, 次を走らす手続き )：
◎
Add the following abort steps to requestObject’s signal:
</p>
		<ol>
			<li>
%局所的に中止された ~SET ~T
◎
Set locallyAborted to true.
</li>
			<li>
`~fetchを中止する$( %~promise, %要請, %~Response~obj )
◎
Abort fetch with p, request, and responseObject.
</li>
			<li>
進行中の~fetchを`終了させる$( `中止する^i )
◎
Terminate the ongoing fetch with the aborted flag set.
</li>
		</ol>
	</li>
	<li>
<p>
この段は`並列的$に走らす：
◎
Run the following in parallel:
</p>

<p>
%要請 を利用して`~fetch$する：
◎
Fetch request.
</p>
		<ul>
			<li>
<p>
`応答を処理する$ときは、所与の
( %応答 )
に対し，次の下位手続きを走らす：
◎
To process response for response, run these substeps:
</p>
				<ol>
					<li>
~IF［
%局所的に中止された ~EQ ~T
］
⇒
~RET
◎
If locallyAborted is true, terminate these substeps.
</li>
					<li>
~IF［
%応答 の`中止~flag$rs ~EQ ~T
］
⇒＃
`~fetchを中止する$( %~promise, %要請, %~Response~obj )；
~RET
◎
If response’s aborted flag is set, then abort fetch with p, request, and responseObject, and terminate these substeps.
</li>
					<li>
~IF［
%応答 は`~network~error$である
］
⇒＃
`TypeError$E で %~promise を`却下する$；
~RET
◎
If response is a network error, then reject p with a TypeError and terminate these substeps.
</li>
					<li>
%~Response~obj の`応答$Rs ~SET %応答
◎
Associate responseObject with response.
</li>
					<li>
%~Response~obj で %~promise を`解決する$
◎
Resolve p with responseObject.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetchを中止する@
ときは、所与の
( %~promise, %要請, %~Response~obj )
に対し、次を走らす：
◎
To abort fetch with a promise, request, and responseObject, run these steps:
</p>
<ol>
	<li>
%~error ~LET `AbortError$E 例外
◎
Let error be an "AbortError" DOMException.
</li>
	<li>
<p>
%~error で %~promise を`却下する$
◎
Reject promise with error.
</p>

<p class="note">注記：
%~promise がすでに充足されていた場合、これは何もしない。
◎
This is a no-op if promise has already fulfilled.
</p>
	</li>
	<li>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqは`読取n可能$RSである
］
⇒
%要請 の`本体$rqを`取消す$RS( %~error )
◎
If request’s body is not null and is readable, then cancel request’s body with error.
</li>
	<li>
~IF［
%~Response~obj ~EQ ~NULL
］
⇒
~RET
◎
If responseObject is null, then return.
</li>
	<li>
%応答 ~LET %~Response~obj の`応答$Rs
◎
Let response be responseObject’s response.
</li>
	<li>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］~AND［
%応答 の`本体$rsは`読取n可能$RSである
］
⇒
%応答 の`本体$rsを`~errorにする$RS( %~error )
◎
If response’s body is not null and is readable, then error response’s body with error.
</li>
</ol>
</div>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">5.7. ~garbage収集</h3>

<p>
~UAは、進行中の~fetchを
— その終了が~scriptを通して観測-可能にならないならば —
`終了させ$てもヨイ。
◎
The user agent may terminate an ongoing fetch if that termination is not observable through script.
</p>

<p class="note">注記：
“~scriptを通して観測-可能にならない”
とは、［
`fetch()$m の引数や返り値を通して観測-可能にならない
］ことを意味する。
~serverとの別の通信-法を通して可能になるものなど，他の仕方は含まれない。
◎
"Observable through script" means observable through fetch()’s arguments and return value. Other ways, such as communicating with the server through a side-channel are not included.
</p>

<p class="note">注記：
~serverは、~garbage収集が~~起きたことを観測できる
— 例えば［
`WebSocket$I ／ `XMLHttpRequest$I
］~objを通してなど。
◎
The server being able to observe garbage collection has precedent, e.g., with WebSocket and XMLHttpRequest objects.
</p>

<div class="example" id="terminate-examples">

<p>
終了は観測され得ないので、~UAは，~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
</pre>

<p>
終了は，~promiseを通して観測され得るので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because the termination can be observed through the promise.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
</pre>

<p>
結付けられている本体は観測-可能にならないので、~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the associated body is not observable.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
  .then( %res =&gt; %res.headers )
</pre>

<p>
終了は観測され得ないので、~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
  .then( %res =&gt; %res.body.getReader().closed )
</pre>

<p>
~promise~obj用に~handlerを登録すれば，終了を観測できるので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because one can observe the termination by registering a handler for the promise object.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
  .then( %res =&gt; %res.body.getReader().closed )
</pre>

<p>
登録された~handlerを介して終了が観測-可能になるので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch as termination would be observable via the registered handler.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
  .then( %res =&gt; {
    %res.body.getReader().closed
      .then(() =&gt; console.log(`~streamは~closeされた！^l))
  })
</pre>
【！stream closed!】
<p>
（上の例が観測-可能にならないことは、組込みの［
~prop, 関数
］
— `body.getReader()$c など —
が上書きされていないことを前提にしている。）
◎
(The above examples of non-observability assume that built-in properties and functions, such as body.getReader(), have not been overwritten.)
</p>

</div>

		</section>
	</section>
	<section id="websocket-protocol">
<h2 title="WebSocket protocol alterations">6. ~WebSocket~protocolの改め</h2>

<div class="note">
<p>注記：
この節は、~WebSocket~protocolの~opening~handshakeに課される~client要件の一部を，~Fetchにて定義される~algoに統合するために置換する。
~CSP, ~cookie, HSTS, その他， Fetch に関係する~protocolは、この仕方で，一箇所に集約して取扱われるようになる。
~RFCがこの文言で更新されるのが理想だが、それは決して容易にはならない。
~HTML標準に定義される~WebSocket~APIは、この文言を利用するように更新された。
`WSP$r `HTML$r
◎
This section replaces part of the WebSocket protocol opening handshake client requirement to integrate it with algorithms defined in Fetch. This way CSP, cookies, HSTS, and other Fetch-related protocols are handled in a single location. Ideally the RFC would be updated with this language, but it is never that easy. The WebSocket API, defined in the HTML Standard, has been updated to use this language. [WSP] [HTML]
</p>

<p>
これは、 `WebSocket Protocol^cite の “~WebSocket接続を確立する” ~algoを，新たなものに置換して~Fetchに統合するような仕方で働く
— “~WebSocket接続を確立する” は、
3 つの~algo［
接続を設定しておく,
~handshake要請を作成して伝送する,
~handshake応答を検証する
］からなる。
その重ね方は、~Fetchによる［
先ず~handshakeを作成し, 次に接続を設定しておいてから、~handshakeを伝送し, ~~最後に応答を検証する
］のとは，異なる。
この改めを読むときは、そのことを念頭に置くこと。
◎
The way this works is by replacing The WebSocket Protocol’s "establish a WebSocket connection" algorithm with a new one that integrates with Fetch. "Establish a WebSocket connection" consists of three algorithms: setting up a connection, creating and transmiting a handshake request, and validating the handshake response. That layering is different from Fetch, which first creates a handshake, then sets up a connection and transmits the handshake, and finally validates the response. Keep that in mind while reading these alterations.
</p>

</div>

		<section id="websocket-connections">
<h3 title="Connections">6.1. 接続</h3>

<div class="algo">
<p>
`~WebSocket接続を得する@
ときは、所与の
( %~url )
に対し，次の手続きを走らす：
◎
To obtain a WebSocket connection, given a url, run these steps:
</p>
<ol>
	<li>
%host ~LET %~url の`~host$url
◎
Let host be url’s host.
</li>
	<li>
%port ~LET %~url の`~port$url
◎
Let port be url’s port.
</li>
	<li>
%secure ~LET ［
%~url の`~scheme$url ~EQ `http^l ならば ~F ／
~ELSE_ ~T
］
◎
Let secure be false, if url’s scheme is "http", and true otherwise.
</li>
	<li>
( %host, %port, %secure )
を与える下で，
WebSocket Protocol <a href="~RFC6455#section-4.1">§ 4.1</a>
の
<a href="~RFC6455#dfn-to-establish">前半の手続き</a>
の段 2 〜 5 に言明されている要件に従って，~WebSocket接続を確立する
`WSP$r
◎
Follow the requirements stated in step 2 to 5, inclusive, of the first set of steps in section 4.1 of The WebSocket Protocol to establish a WebSocket connection. [WSP]
</li>
	<li>
~RET［
接続は確立されたなら それ ／
~ELSE_ `失敗^i
］
◎
If that established a connection, return it, and return failure otherwise.
</li>
</ol>
</div>

<p class="note">注記：
~WebSocket接続は、異なる~propを運ぶ少し異なる~~構成なので，共有できないが、
“普通の” `接続$にごく近いものである。
◎
Although structured a little differently, carrying different properties, and therefore not shareable, a WebSocket connection is very close to identical to an "ordinary" connection.
</p>

		</section>
		<section id="websocket-opening-handshake">
<h3 title="Opening handshake">6.2. ~opening~handshake</h3>

<div class="algo">
<p>
`~WebSocket~protocol~handshakeを確立する@
ときは、所与の
( %~url, %~protocol~list, %~client )
に対し，次の手続きを走らす:
◎
To establish a WebSocket connection, given a url, protocols, and client, run these steps:
</p>
<ol>
	<li>
%要請~URL ~LET %~url の複製
◎
↓</li>
	<li>
<p >
%要請~URL の`~scheme$url ~SET ［
%~url の`~scheme$url ~EQ `ws^l ならば `http^l ／
~ELSE_ `https^l
］
◎
Let requestURL be a copy of url, with its scheme set to "http", if url’s scheme is "ws", and to "https" otherwise.
</p>

<p class="note">注記：
この~schemeの変更-は、`~fetching$に上手く統合するために本質的になる。
例えば HSTS は、こうしないと働かなくなる。
これは、旧来の遺物である
— ~WebSocketを別個の~schemeにする~~本当の理由はない。
`HSTS$r
◎
This change of scheme is essential to integrate well with fetching. E.g., HSTS would not work without it. There is no real reason for WebSocket to have distinct schemes, it’s a legacy artefact. [HSTS]
</p>
	</li>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq ~SET %要請~URL,
`~client$rq ~SET %~client,
`~sw~mode$rq ~SET `none^l,
`~referrer$rq ~SET `no-referrer^l,
`同期~flag$rq ~SET ~T,
`~mode$rq ~SET `websocket^l,
`資格証~mode$rq ~SET `include^l,
`~cache~mode$rq ~SET `no-store^l,
`~redirect~mode$rq ~SET `error^l
◎
Let request be a new request, whose URL is requestURL, client is client, service-workers mode is "none", referrer is "no-referrer", synchronous flag is set, mode is "websocket", credentials mode is "include", cache mode is "no-store", and redirect mode is "error".
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Upgrade$h / `websocket^bl
)
◎
Append `Upgrade`/`websocket` to request’s header list.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Connection$h / `Upgrade^bl
)
◎
Append `Connection`/`Upgrade` to request’s header list.
</li>
	<li>
<p>
%~key値 ~LET `同型に符号化する$( `~forgiving-base64符号化する$( ~randomに選定された 16 ~byteの値 ) )
◎
Let keyValue be a nonce consisting of a randomly selected 16-byte value that has been forgiving-base64-encoded and isomorphic encoded.
</p>

<p class="example" id="example-random-value">
例えば，~randomに選定された値が~byte列［
`01^X `02^X `03^X `04^X `05^X `06^X `07^X `08^X `09^X `0a^X `0b^X `0c^X `0d^X `0e^X `0f^X `10^X
］ならば、
%~key値 は，それを~forgiving-base64符号化した結果
`AQIDBAUGBwgJCgsMDQ4PEC==^l
を同型に符号化した結果
`AQIDBAUGBwgJCgsMDQ4PEC==^bl
になる。
◎
If the randomly selected value was the byte sequence 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, keyValue would be forgiving-base64-encoded to "AQIDBAUGBwgJCgsMDQ4PEC==" and isomorphic encoded to `AQIDBAUGBwgJCgsMDQ4PEC==`. 
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Sec-WebSocket-Key^h / %~key値
)
◎
Append `Sec-WebSocket-Key`/keyValue to request’s header list.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Sec-WebSocket-Version^h / `13^bl
)
◎
Append `Sec-WebSocket-Version`/`13` to request’s header list.
</li>
	<li>
%~protocol~list 内の
~EACH( %~protocol )
に対し
⇒
%要請 の`~header~list$rq内で`~headerを結合する$(
`Sec-WebSocket-Protocol^h / %~protocol
)
◎
For each protocol in protocols, combine `Sec-WebSocket-Protocol`/protocol in request’s header list.
</li>
	<li>
<p>
%permessageDeflate ~LET ~UAにより定義される `permessage-deflate^l 拡張 `~header$`値$hd
`WSP$r
【！ [WSP-Compression] 】
◎
Let permessageDeflate be a user-agent defined "permessage-deflate" extension header value. [WSP]
</p>

<div class="example" id="example-permessage-deflate">
`permessage-deflate; client_max_window_bits^bl
</div>
	</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
`Sec-WebSocket-Extensions^h / %permessageDeflate
)
◎
Append `Sec-WebSocket-Extensions`/permessageDeflate to request’s header list.
</li>
	<li>
%応答 ~LET %要請 を`~fetch$した結果
◎
Let response be the result of fetching request.
</li>
	<li>
~IF［
%応答 は`~network~error$である
］~OR［
%応答 の`状態s$rs ~NEQ `101$st
］
⇒
`~WebSocket接続を失敗させる$
◎
If response is a network error or its status is not 101, fail the WebSocket connection.
</li>
	<li>
<p>
~IF［
%~protocol~list は空でない
］~AND［
`~header~listから値を抽出する$( %応答 の`~header~list$rs, `Sec-WebSocket-Protocol^h ) ~IN { ~NULL, `失敗^i, 空~byte列 }
］
⇒
`~WebSocket接続を失敗させる$
◎
If protocols is not the empty list and extracting header list values given `Sec-WebSocket-Protocol` and response’s header list results in null, failure, or the empty byte sequence, then fail the WebSocket connection.
</p>

<p class="note">注記：
これは、WebSocket Protocol にて定義される，この~headerに対する検査と異なる。
そこでは、~clientから要請されていない下位protocolがある場合しか受持ってなかった。
ここでは、~clientから要請された下位protocolが~serverから承認されていない場合も受持つ。
◎
This is different from the check on this header defined by The WebSocket Protocol. That only covers a subprotocol not requested by the client. This covers a subprotocol requested by the client, but not acknowledged by the server.
</p>
	</li>
	<li>
WebSocket Protocol <a href="~RFC6455#section-4.1">§ 4.1</a>
の後半の手続きの段 2 〜 6 に言明されている要件に従って，
%応答 を検証する
— これは、`~WebSocket接続を失敗させる$か, `~WebSocket接続は確立される$ことになる。
◎
Follow the requirements stated step 2 to step 6, inclusive, of the last set of steps in section 4.1 of The WebSocket Protocol to validate response. This either results in fail the WebSocket connection or the WebSocket connection is established.
</li>
</ol>

<p>
`~WebSocket接続を失敗させる@
【<a href="~RFC6455#dfn-to-fail">参照先</a>】
／
`~WebSocket接続は確立される@
【<a href="~RFC6455#dfn-established">参照先</a>】
は、 WebSocket Protocol にて定義される。
`WSP$r
◎
Fail the WebSocket connection and the WebSocket connection is established are defined by The WebSocket Protocol. [WSP]
</p>

<p class="warning">警告：
~redirectを追わない理由は、~web~browser文脈に深刻な~security問題をもたらすからである。
そのため、この~handshakeは，一般に制約される。
例えば、ある~hostが ある~pathに~WebSocket~serverを立てていたとする。
その~hostが，別の~pathにも
~openな~HTTP~redirect器
【`<a href="https://wiki.suikawiki.org/n/open%20redirector">参考</a>^】
を立てた時点で、~WebSocket~URLを与え得るような どの~scriptも，その~URLの~hostnameが~~正しいことを検査したとしても，~internet上の~~任意の~hostと通信する（したがって秘匿情報を共有し得る）ように騙すことが可能になる。
【！ https://www.ietf.org/mail-archive/web/hybi/current/msg06951.html】
◎
The reason redirects are not followed and this handshake is generally restricted is because it could introduce serious security problems in a web browser context. For example, consider a host with a WebSocket server at one path and an open HTTP redirector at another. Suddenly, any script that can be given a particular WebSocket URL can be tricked into communicating to (and potentially sharing secrets with) any host on the internet, even if the script checks that the URL has the right hostname.
</p>
</div>

		</section>
	</section>
	<section id="data-urls">
<h2 title="data: URLs">7. ~data_URL</h2>

<p>
~data_URLについての規範的でない記述は、 `RFC2397$r を見よ。
この節は、その~RFCの規範的な処理~要件を，配備-済み内容と互換になるよう置換する。
◎
For an informative description of data: URLs, see RFC 2397. This section replaces that RFC’s normative processing requirements to be compatible with deployed content. [RFC2397]
</p>

<div class="p">
<p>
`~data_URL構造体@
は、次のものからなる`構造体$である：
</p>

<dl class="def-list">
	<dt>`~MIME型@dU</dt>
	<dd>
`~MIME型$。
</dd>

	<dt>`本体@dU</dt>
	<dd>
`~byte列$。
</dd>
</dl>

◎
A data: URL struct is a struct that consists of a MIME type (a MIME type) and a body (a byte sequence).
</div>

<div class="algo">
<p>
`~data_URL処理器@
は、所与の
( `~URL$ %~dataURL )
に対し，次の手続きを走らす：
◎
The data: URL processor takes a URL dataURL and then runs these steps:
</p>
<ol>
	<li>
~Assert：
%~dataURL の`~scheme$url ~EQ `data^l
◎
Assert: dataURL’s scheme is "data".
</li>
	<li>
%入力 ~LET `~URLを直列化する$( %~dataURL, `素片は除外する^i )
◎
Let input be the result of running the URL serializer on dataURL with the exclude fragment flag set.
</li>
	<li>
%入力 から頭部を成す文字列 `data:^l を除去する
◎
Remove the leading "data:" string from input.
</li>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position point at the start of input.
</li>
	<li>
%~MIME型 ~LET %入力 内の %位置 から `002C^U `,^smb 以外の`符号位置~並びを収集する$
◎
Let mimeType be the result of collecting a sequence of code points that are not equal to U+002C (,), given position.
</li>
	<li>
<p>
%~MIME型 ~LET `前後の~ASCII空白~列を剥ぐ$( %~MIME型 )
◎
Strip leading and trailing ASCII whitespace from mimeType.
</p>

<p class="note">注記：
これが除去する`符号位置$は、 `0020^U `SPACE^smb に限られる。
◎
This will only remove U+0020 SPACE code points, if any.
</p>
	</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET `失敗^i
◎
If position is past the end of input, then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
%復号-済み本体 ~LET %入力 内の %位置 からすべての`符号位置~並びを収集する$
◎
Let encodedBody be the remainder of input.
</li>
	<li>
%本体 ~LET `文字列を~byte列に~percent-復号する$( %復号-済み本体 )
◎
Let body be the percent-decoding of encodedBody.
</li>
	<li>
<p>
~IF［
%~MIME型 は次の順の並びに合致する
］…
⇒＃
任意の文字列 %S,
`003B^U `;^smb,
0 個~以上の `0020^U `SPACE^smb,
`~ASCII大小無視$で `base64^l に合致する文字列
◎終
…ならば：
◎
If mimeType ends with U+003B (;), followed by zero or more U+0020 SPACE, followed by an ASCII case-insensitive match for "base64", then:
</p>
		<ol>
			<li>
%文字列~本体 ~LET `同型に復号する$( %本体 )
◎
Let stringBody be the isomorphic decode of body.
</li>
			<li>
%本体 ~SET `~forgiving-base64復号する$( %文字列~本体 )
◎
Set body to the forgiving-base64 decode of stringBody.
</li>
			<li>
~IF［
%本体 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If body is failure, then return failure.
</li>
			<li>
%~MIME型 ~SET %S
◎
Remove the last 6 code points from mimeType.
◎
Remove trailing U+0020 SPACE code points from mimeType, if any.
◎
Remove the last U+003B (;) code point from mimeType.
</li>
		</ol>
	</li>
	<li>
~IF［
%~MIME型 の先頭の符号位置 ~EQ `003B^U `;^smb
］
⇒
%~MIME型 ~SET 次を順に連結した結果
⇒＃
`text/plain^l,
%~MIME型
◎
If mimeType starts with U+003B (;), then prepend "text/plain" to mimeType.
</li>
	<li>
%~MIME型~record ~LET `~MIME型を構文解析する$( %~MIME型 )
◎
Let mimeTypeRecord be the result of parsing mimeType.
</li>
	<li>
~IF［
%~MIME型~record ~EQ `失敗^i
］
⇒
%~MIME型~record ~SET `text/plain;charset=US-ASCII^c
◎
If mimeTypeRecord is failure, then set mimeTypeRecord to text/plain;charset=US-ASCII.
</li>
	<li>
~RET 次のようにされた新たな`~data_URL構造体$
⇒＃
`~MIME型$dU ~SET %~MIME型~record,
`本体$dU ~SET %本体
◎
Return a new data: URL struct whose MIME type is mimeTypeRecord and body is body.
</li>
</ol>
</div>

	</section>
	<section id="background-reading">
<h2 title="Background reading">背景情報</h2>

<p>
`この節（および その下位節）は規範的でない。^em
◎
This section and its subsections are informative only.
</p>

		<section id="http-header-layer-division">
<h3 title="HTTP header layer division">~HTTP~header層の~~区分</h3>

<div class="p">
<p>
~fetchingの目的においては、次に挙げる層がある：
</p>
<ol>
	<li>
~API層
⇒
開発者は、この層において~headerを設定できる（概して， `Request$I ~objを通して）。
</li>
	<li>
早期~fetch層（~HTMLの `img^e 要素, ~CSSの `background-image^css ~propなど）
⇒
`Accept$h, `Accept-Language$h は、（概して，~UAにより）この層にて設定される。
</li>
	<li>
~sw層
⇒
~API層と同様に，開発者は、この層において~headerを設定できる。
</li>
	<li>
~network＆~cache層
⇒
`Accept-Encoding$h, `Host$h, `Referer$h など，~UAにより制御される他のほとんどの~headerは、この層において設定される。
</li>
</ol>

<p>
`禁止~header名$については、開発者が制御できる部分はほとんどないが，
`Accept$h を制御したり, `Referer$h を拘束する／省略させる手段【`~referrer施策$】はある。
</p>

◎
For the purposes of fetching, there is an API layer (HTML’s img, CSS' background-image), early fetch layer, service worker layer, and network &amp; cache layer. `Accept` and `Accept-Language` are set in the early fetch layer (typically by the user agent). Most other headers controlled by the user agent, such as `Accept-Encoding`, `Host`, and `Referer`, are set in the network &amp; cache layer. Developers can set headers either at the API layer or in the service worker layer (typically through a Request object). Developers have almost no control over forbidden headers, but can control `Accept` and have the means to constrain and omit `Referer` for instance.
</div>

		</section>
		<section id="atomic-http-redirect-handling">
<h3 title="Atomic HTTP redirect handling">~HTTP~redirectの不可分な取扱い</h3>

<p>
~redirect（`応答$のうち，［
その`状態s$rs, または
その`内部~応答$の`状態s$rs
］が `~redirect状態s$であるもの）は、~APIには公開されない。
仮に~redirectを公開したなら，~XSS攻撃を通して情報が漏洩されることになる。
◎
Redirects (a response whose status or internal response’s (if any) status is a redirect status) are not exposed to APIs. Exposing redirects might leak information not otherwise available through a cross-site scripting attack.
</p>

<p class="example" id="example-xss-redirect">
［
`HttpOnly^bl 付きの `Cookie$h
］が含まれる~URL（例えば
`https://example.org/auth^s
）への~fetchが，秘匿情報を包含する~URL（例えば
`https://other-origin.invalid/<em>4af955781ea1c84a3b11</em>^s
）への~redirectになることもある。
仮に~redirectが公開されたなら、この秘匿情報は，~XSS攻撃により入手されることになる。
◎
A fetch to https://example.org/auth that includes a Cookie marked HttpOnly could result in a redirect to https://other-origin.invalid/4af955781ea1c84a3b11. This new URL contains a secret. If we expose redirects that secret would be available through a cross-site scripting attack.
</p>

		</section>
		<section id="basic-safe-cors-protocol-setup">
<h3 title="Basic safe CORS protocol setup">安全な~CORS~protocolを設定しておくための基本</h3>

<p>
IP 認証や~firewallを通して~dataが保護されている資源（不幸なことに，未だに ありふれている）に対する`~CORS~protocol$の利用は、<strong>安全でない</strong>。
（`~CORS~protocol$を考案する必要が生じた理由は、それである。）
◎
For resources where data is protected through IP authentication or a firewall (unfortunately relatively common still), using the CORS protocol is unsafe. (This is the reason why the CORS protocol had to be invented.)
</p>

<p>
しかしながら、次の`~header$を利用している場合は<strong>安全である</strong>：
【！otherwise】
◎
However, otherwise using the following header is safe:
</p>

<pre class="lang-http">
Access-Control-Allow-Origin: *
</pre>

<p>
資源が~cookieや~HTTP認証に基づく追加的な情報を公開するときでも、上の`~header$の利用は，それを露呈させない。
これは、 curl や wget などにより すでに共有されているかのごとく，資源を
`XMLHttpRequest$I
などの~APIと共有する。
◎
Even if a resource exposes additional information based on cookie or HTTP authentication, using the above header will not reveal it. It will share the resource with APIs such as XMLHttpRequest, much like it is already shared with curl and wget.
</p>

<p>
したがって，言い換えれば、（ curl や wget などを利用して）~webに接続している任意の機器からは~accessし得ないような資源においては、上述の`~header$は含まれない。
~accessし得る場合については，その様にすること【！？】は全く妥当である。
◎
Thus in other words, if a resource cannot be accessed from a random device connected to the web using curl and wget the aforementioned header is not to be included. If it can be accessed however, it is perfectly fine to do so.
</p>

		</section>
		<section id="cors-protocol-and-http-caches">
<h3 title="CORS protocol and HTTP caches">~CORS~protocolと~HTTP~cache</h3>

<p>
`~CORS~protocol$の要件が，［
`Access-Control-Allow-Origin$hを［
`*^bl ／ 静的な`生成元$
］に設定する
］より複雑なものである場合、
`Vary$h を利用することになる。
`HTML$r
`HTTP$r
`HTTP-SEMANTICS$r
`HTTP-COND$r
`HTTP-CACHING$r
`HTTP-AUTH$r
◎
If CORS protocol requirements are more complicated than setting `Access-Control-Allow-Origin` to * or a static origin, `Vary` is to be used. [HTML] [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</p>

<div class="example" id="example-vary-origin">
<pre class="lang-http">
Vary: Origin
</pre>
</div>

<p>
~serverは、ある資源において［
その資源への要請が`~CORS要請$である場合に限り，応答~内に
`Access-Control-Allow-Origin$h を送信する
］よう環境設定されているとする。
このとき、 `Vary$h が`利用されない^emと何が起こるか考える。
~UAが その資源への非`~CORS要請$に対する応答を受信したとき（例えば、`~navi要請$の結果として）、~UAは，
`Access-Control-Allow-Origin$h を欠く応答
— “非~CORS応答” —
を~cacheすることになる。
後に，~UAが同じ資源への`~CORS要請$に遭遇した場合にも、この “非~CORS応答” を利用することになる。
◎
In particular, consider what happens if `Vary` is not used and a server is configured to send `Access-Control-Allow-Origin` for a certain resource only in response to a CORS request. When a user agent receives a response to a non-CORS request for that resource (for example, as the result of a navigation request), the response will lack `Access-Control-Allow-Origin` and the user agent will cache that response. Then, if the user agent subsequently encounters a CORS request for the resource, it will use that cached response from the previous non-CORS request, without `Access-Control-Allow-Origin`.
</p>

<p>
同じ局面で `Vary: Origin^bl を利用した場合、
`Access-Control-Allow-Origin$h を含む応答を~UAに`~fetch$させ，~cacheされた “非~CORS応答” が利用されることはなくなる。
◎
But if `Vary: Origin` is used in the same scenario described above, it will cause the user agent to fetch a response that includes `Access-Control-Allow-Origin`, rather than using the cached response from the previous non-CORS request that lacks `Access-Control-Allow-Origin`.
</p>

<p>
しかしながら、ある資源に対し，
`Access-Control-Allow-Origin$h を［
`*^bl ／ 静的な`生成元$
］に設定する場合、その資源~用の応答~内には，常に
— 非`~CORS要請$に対しても，`~CORS要請$と同じく —
`Access-Control-Allow-Origin$h を送信するよう，~serverを環境設定して、
`Vary$h は利用しないこと。
◎
However, if `Access-Control-Allow-Origin` is set to * or a static origin for a particular resource, then configure the server to always send `Access-Control-Allow-Origin` in responses for the resource — for non-CORS requests as well as CORS requests — and do not use `Vary`.
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の策定に貢献された次の方々に感謝する：
</p>

`_acks1@

	</section>
</main></div>

<div hidden>

<div lang="en-x-a0" id="_acks1">
<p>
Thanks to

Adam Barth,
Adam Lavin,
Alan Jeffrey,
Alexey Proskuryakov,
Andrés Gutiérrez,
Andrew Sutherland,
Ángel González,
Anssi Kostiainen,
Arkadiusz Michalski,
Arne Johannessen,
Artem Skoretskiy,
Arthur Barstow,
Asanka Herath,
Axel Rauschmayer,
Ben Kelly,
Benjamin Gruenbaum,
Benjamin Hawkes-Lewis,
Bert Bos,
Björn Höhrmann,
Boris Zbarsky,
Brad Hill,
Brad Porter,
Bryan Smith,
Caitlin Potter,
Cameron McCormack,
Chris Needham,
Chris Rebert,
Clement Pellerin,
Collin Jackson,
Daniel Robertson,
Daniel Veditz,
Dave Tapuska,
David Benjamin,
David Håsäther,
David Orchard,
Dean Jackson,
Devdatta Akhawe,
Domenic Denicola,
Dominic Farolino,
Dominique Hazaël-Massieux,
Doug Turner,
Douglas Creager,
Eero Häkkinen,
Ehsan Akhgari,
Emily Stark,
Eric Lawrence,
François Marier,
Frank Ellerman,
Frederick Hirsch,
Gary Blackwood,
Gavin Carothers,
Glenn Maynard,
Graham Klyne,
Gregory Terzian,
Hal Lockhart,
Hallvord R. M. Steen,
Harris Hancock,
Henri Sivonen,
Henry Story,
Hiroshige Hayashizaki,
Honza Bambas,
Ian Hickson,
Ilya Grigorik,
isonmad,
Jake Archibald,
James Graham,
Janusz Majnert,
Jeena Lee,
Jeff Carpenter,
Jeff Hodges,
Jeffrey Yasskin,
Jesse M. Heines,
Jianjun Chen,
Jinho Bang,
Jochen Eisinger,
John Wilander,
Jonas Sicking,
Jonathan Kingston,
Jonathan Watt,
<span lang="ko">최종찬</span> (Jongchan Choi),
Jordan Stephens,
Jörn Zaefferer,
Joseph Pecoraro,
Josh Matthews,
Julian Krispel-Samsel,
Julian Reschke,
<span lang="ko">송정기</span> (Jungkee Song),
Jussi Kalliokoski,
Jxck,
Kagami Sascha Rosylight,
Keith Yeung,
Kenji Baheux,
Lachlan Hunt,
Larry Masinter,
Liam Brummitt,
Louis Ryan,
Lucas Gonze,
Łukasz Anforowicz,
<span lang="zh">呂康豪</span> (Kang-Hao Lu),
Maciej Stachowiak,
Malisa,
Manfred Stock,
Manish Goregaokar,
Marc Silbey,
Marcos Caceres,
Marijn Kruisselbrink,
Mark Nottingham,
Mark S. Miller,
Martin Dürst,
Martin Thomson,
Matt Andrews,
Matt Falkenhagen,
Matt Oshry,
Matt Seddon,
Matt Womer,
Mhano Harkness,
Michael Ficarra,
Michael Kohler,
Michael™ Smith,
Mike Pennisi,
Mike West,
Mohamed Zergaoui,
Mohammed Zubair Ahmed,
Moritz Kneilmann,
Ms2ger,
Nico Schlömer,
Nicolás Peña Moreno,
Nikhil Marathe,
Nikki Bee,
Nikunj Mehta,
Odin Hørthe Omdal,
Ondřej Žára,
O. Opsec,
Perry Jiang,
Philip Jägenstedt,
R. Auburn,
Raphael Kubo da Costa,
Rondinelly,
Rory Hewitt,
Ryan Sleevi,
Sébastien Cevey,
Sendil Kumar N,
Shao-xuan Kang,
Sharath Udupa,
Shivakumar Jagalur Matt,
Shivani Sharma,
Sigbjørn Finne,
Simon Pieters,
Simon Sapin,
Srirama Chandra Sekhar Mogali,
Stephan Paul,
Steven Salat,
Sunava Dutta,
Surya Ismail,
Takashi Toyoshima,
<span lang="ja">吉野剛史</span> (Takeshi Yoshino),
Thomas Roessler,
Thomas Steiner,
Thomas Wisniewski,
Tiancheng "Timothy" Gu,
Tobie Langel,
Tom Schuster,
Tomás Aparicio,
<span lang="ja">保呂毅</span> (Tsuyoshi Horo),
Tyler Close,
Ujjwal Sharma,
Vignesh Shanmugam,
Vladimir Dzhuvinov,
Wayne Carr,
Xabier Rodríguez,
Yehuda Katz,
Yoav Weiss,
Youenn Fablet,
<span lang="ja">平野裕</span> (Yutaka Hirano), and
Zhenbin Xu

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft).
This work is licensed under a
<a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.
</p>

</div>
</div>
