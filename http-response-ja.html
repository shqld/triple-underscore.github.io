<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Semantics — response code, response header（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP Semantics
trans_update:2020-08-25
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
abbr_url:HTTPrs
spec_status:IETFID
no_original_dfn:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls
field.date:HTTP/Headers/Date
field.location:HTTP/Headers/Location
field.retry-after:HTTP/Headers/Retry-After
field.vary:HTTP/Headers/Vary
field.last-modified:HTTP/Headers/Last-Modified
field.etag:HTTP/Headers/ETag
field.www-authenticate:HTTP/Headers/WWW-Authenticate
field.proxy-authenticate:HTTP/Headers/Proxy-Authenticate
	field.authentication-info:HTTP/Headers/Authentication-Info
	field.proxy-authentication-info:HTTP/Headers/Proxy-Authentication-Info
field.accept-ranges:HTTP/Headers/Accept-Ranges
field.allow:HTTP/Headers/Allow
field.server:HTTP/Headers/Server

status.codes:HTTP/Status
status.100:HTTP/Status/100
status.101:HTTP/Status/101
status.200:HTTP/Status/200
status.201:HTTP/Status/201
status.202:HTTP/Status/202
status.203:HTTP/Status/203
status.204:HTTP/Status/204
status.205:HTTP/Status/205
status.206:HTTP/Status/206
status.300:HTTP/Status/300
status.301:HTTP/Status/301
status.302:HTTP/Status/302
status.303:HTTP/Status/303
status.304:HTTP/Status/304
status.305:HTTP/Status/305
status.306:HTTP/Status/306
status.307:HTTP/Status/307
status.308:HTTP/Status/308
status.400:HTTP/Status/400
status.401:HTTP/Status/401
status.402:HTTP/Status/402
status.403:HTTP/Status/403
status.404:HTTP/Status/404
status.405:HTTP/Status/405
status.406:HTTP/Status/406
status.407:HTTP/Status/407
status.408:HTTP/Status/408
status.409:HTTP/Status/409
status.410:HTTP/Status/410
status.411:HTTP/Status/411
status.412:HTTP/Status/412
status.413:HTTP/Status/413
status.414:HTTP/Status/414
status.415:HTTP/Status/415
status.416:HTTP/Status/416
status.417:HTTP/Status/417
status.418:HTTP/Status/418
status.422:HTTP/Status/422
status.426:HTTP/Status/426
status.500:HTTP/Status/500
status.501:HTTP/Status/501
status.502:HTTP/Status/502
status.503:HTTP/Status/503
status.504:HTTP/Status/504
status.505:HTTP/Status/505

●●link_map

h.Digest:https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#digest
h.Origin:~FETCH#http-origin
	h.Origin:~RFCx/rfc6454#section-4

p.Accept-Ranges:~HTTPrs#p.Accept-Ranges
p.Allow:~HTTPrs#p.Allow
p.Authentication-Info:~HTTPrs#p.Authentication-Info
p.Date:~HTTPrs#p.Date
p.ETag:~HTTPrs#p.ETag
p.Last-Modified:~HTTPrs#p.Last-Modified
p.Location:~HTTPrs#p.Location
p.Proxy-Authenticate:~HTTPrs#p.Proxy-Authenticate
p.Proxy-Authentication-Info:~HTTPrs#p.Proxy-Authentication-Info
p.Retry-After:~HTTPrs#p.Retry-After
p.Server:~HTTPrs#p.Server
p.Vary:~HTTPrs#p.Vary
p.WWW-Authenticate:~HTTPrs#p.WWW-Authenticate

c.none:~HTTPrs#range-none
	p.orig-date:~RFCx/rfc5322#section-3.6.1

強い:~HTTPrs#strong-validator
弱い:~HTTPrs#weak-validator

不透明:#opaque
評価-:~HTTPrq#evaluation
形式変換ng~proxy:~HTTPsem#transforming-proxy
~cache鮮度:~HTTPcache#expiration.model
空~行l:~HTTPmsg#empty-line
条件付き要請:~HTTPrq#preconditions

cite.~HTTP状態s~code~registry:~IANA-a/http-status-codes

r.RFC2324:~HTTPsem#RFC2324
r.RFC4918:~HTTPsem#RFC4918
r.RFC5322:~HTTPsem#RFC5322
r.RFC5905:~HTTPsem#RFC5905
r.RFC7231:~HTTPsem#RFC7231
r.RFC7538:~HTTPsem#RFC7538
r.RFC8288:~HTTPsem#RFC8288
r.Caching:~HTTPsem#Caching

	●§

4.2:~HTTPsem#protocol.version
5.6:~HTTPsem#trailer.fields
6.8:~HTTPsem#field.connection
7.3.2:~HTTPsem#identifying.payload
9.4:~HTTPrq#request.conneg
9.5.1:~HTTPrq#challenge.and.response
10.7:~HTTPrs#status.code.extensibility
11.2:HTTPrs#response.validator
	11.4.1:~HTTPrs#status.300

Caching/4.1:~HTTPcache#caching.negotiated.responses
Caching/4.2.2:~HTTPcache#heuristic.freshness
Caching/4.3.4:~HTTPcache#freshening.responses

RFC7231/B:~RFC7231#appendix-B
RFC7538/4:~RFC7538#section-4


●●section_map

●●words_table1

●●words_table

	●仕様
理想的:ideal:~
自己決定的:self-determined:~
等価性:equivalency:~
裁量:discretion:~
通告-:advise:~
過度:excessive:~
管轄:administrative domain:~
直交的:orthogonal:~
変種:variant:~
編集:editing:~
指示書き:instruction:~
指示命令:instruction:~
満足可能:satisfiable:~
scale::::スケール
	~scale能:scalability
信頼性:reliability:~
木目細かな:fine-grainedな:~
介入-:intervene:~

	〜に関わる:What matters to〜
	~~悪影響:adverse impact
	~~委ね:left to
	陥った:descended into
	もちろん:obvious
	あろうとし続ける:tries to remain
	たとえ:albeit
	~~過度:Overly
	~~誤った:erroneous
	~~間違い:wrong
	~~困難でない:feasible
	~~困難でない:unless not feasible
	~~困難:unfeasible
	~~勧める:advised to
	~~記述するもの:descriptive
	~~正しくない:malformed
	どっちつかず:noncommittal

	ついて~~合意がとれなかった:disagreement over
	~~誤認を誘うもの:deceptive
	~~注意して行う:done with care
	鶏と卵:chicken-and-egg
	事実がなかったと:were not for the fact
	~~理由:because
	~~同類の:sibling
	~~観点:considerations
	~~支持:support
	~~効率が落ちる:less efficiently
	用心:guard
	から見て:perspective
	もの:flavor
	対象に:over
	課す:impose
	~~最大の:best
	あまり〜でない:far less
	好ましい:preferable
	注記-:note
	許容する必要がある:cannot disallow
	~~支配的:prevailing

	●未分類
変動:variance:~
透過性:transparency::~
拡げる:expandする:~
	結合-法:combining
	:refer
間隙:gap:~
和集合:union:~
連続的:continuous:~
完結:finalization:~
	増やす:increase
下位製品:subproduct:~
製品:product:~
分解能:resolution:~
整形式:well-formed:~
枯渇-:exhaust:~
	枯渇-:exhaustion of
循環的:cyclical:~
耐衝突:collision-resistant:~
無限loop:black hole::無限ループ
	最後に改変された:last-modified
traversal:
real-time:::リアルタイム
notepad::::ノートパッド
時間帯:time zone:~

	査定:assessment of
辿る:traverseする:~
構文上は:syntacticには::~
変動-:vary::~
変動:variance::~
発行i:issue:発行
一括的:batch-oriented:~

	秒:seconds
	秒単位:every second／single second／one-second
	秒単位より細かい:sub-second
	定まる秒~数の間:during the second covered by

	●他の語（言い換え
	先頭部分:prefix
	単独の部位:single-part
	認証~scheme:authentication-scheme
	継続-中:continuing
	~linkし直す:re-link
	視野を絞る:identify the scope
	組で:together
	再~提出-:resubmit
	分かれる:split
	~link編集:link-editing
	計算し直す:recalculate
	~~遠い:distant
	1 個の:exactly one
	~~相対的:against
	次に挙げるものなど:including (but not limited to)
	検証-用:validating

	●他の語
	指す:point to
	短か過ぎる:too short
	~escapeを~~解除:unescaping
	~~現在時:current instance
	~~見かけ上:apparently
	-:located
	通過-:passed through
	~~部署:office and regional
	~~風刺-:lampoon
	~hypertext:hypertext note

	~~細切れにされた:small disjoint
	~~細切れ:small
	~~若い:younger
	徐々に:gradually
	分間:minutes
	日に一度だけ:once per day
	~~適量:appropriate amount
	代えて:supplant
	内に置かれ:place
	臨時の販促:limited-time, promotional
	~~確定していない:might or might not
	するとき／しないとき:might or might not
	~~過去の:earlier
	~~過去:before
	~~消失した:gone

	他方の:one of the two
	離れて他へ:away from
	いつまでも:any length of time
	ときには:occasional
	その時々on occasion
	~~直前:just before
	直後:immediately after
	個々人:individual
	より広い:larger
	とは限らない:not all
	いつまでか:how long

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP Semantics</a>
の
§ 10. Response Status Codes,
§ 11. Response Header Fields
を日本語に翻訳したものです。
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP 意味論 — 応答コードと応答ヘッダ</h1>

	</hgroup>
</header>

<div id="MAIN" hidden>

<p class="trans-note">【
この~pageでは、
<a href="~HTTPsem">~HTTP意味論</a>
を成す内容のうち，§ 10, § 11 のみを述べる。
仕様の~metadata情報は、その~pageを参照されたし。
】</p>

<main id="MAIN0">

	<section id="status.codes">
<h2 title="Response Status Codes">10. 応答~状態s~code</h2>

<p>
（応答の）
`状態s~code^dfn
（ `status-code$p ）は、 3 桁の整数~codeであり，［
要請を解して それを満足しようと試みた結果
］を与える。
◎
The (response) status code is a three-digit integer code giving the result of the attempt to understand and satisfy the request.
</p>

<p>
~HTTP状態s~codeは、拡張できる。
~HTTP`~client$には、［
登録-済みな状態s~codeすべての意味を解する
］ことは要求されない
— もちろん、解する方が望ましいが。
しかしながら，`~client$は、［
最初の桁により指示される，どの［
状態s~codeの`応答class$
］］に対しても，それを解した上で，認識できない状態s~codeを［
その`応答class$の状態s~code `x00^st0 に等価である
］ものとして，扱わなければナラナイ。
◎
HTTP status codes are extensible. HTTP clients are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, a client MUST understand the class of any status code, as indicated by the first digit, and treat an unrecognized status code as being equivalent to the x00 status code of that class.
</p>

<p>
例えば，~clientが［
認識できない状態s~code `471^st0
］を受信したときは、［
その要請に何か~~間違いがある
］ものと見做した上で，［
応答を `400$stを受信したかのように扱う
］ことができる。
応答~messageは、通例的に，その状態sを説明する`表現$を包含することになる。
◎
For example, if an unrecognized status code of 471 is received by a client, the client can assume that there was something wrong with its request and treat the response as if it had received a 400 (Bad Request) status code. The response message will usually contain a representation that explains the status.
</p>

<p>
`状態s~code$の最初の桁は、応答の
`応答class@
を定義する。
下位 2 桁には、分類上の役割はない。
`応答class$には、次に挙げる 5 種がある：
◎
The first digit of the status code defines the class of response. The last two digits do not have any categorization role. There are five values for the first digit:
</p>

<dl>
	<dt>`1xx$st</dt>
	<dd>
要請は受信され、その処理nは継続-中にある。
◎
The request was received, continuing process
</dd>

	<dt>`2xx$st</dt>
	<dd>
要請は、成功裡に［
受信され,
解され,
受容された
］。
◎
The request was successfully received, understood, and accepted
</dd>

	<dt>`3xx$st</dt>
	<dd>
要請を完了するためには、更なる動作がとられる必要がある。
◎
Further action needs to be taken in order to complete the request
</dd>

	<dt>`4xx$st</dt>
	<dd>
要請は、不良な構文を包含しているか, または履行できない。
◎
The request contains bad syntax or cannot be fulfilled
</dd>

	<dt>`5xx$st</dt>
	<dd>
要請は ~~見かけ上は妥当であるが、`~server$はその履行-に失敗した。
◎
The server failed to fulfill an apparently valid request
</dd>
</dl>

<p id="final-interim">
同じ要請に対しては、複数個の応答
— 0 個以上の`暫定-応答$, それらに後続する 1 個の`最終-応答$ —
が結付けられ得る。
`応答class$ `1xx$st に属する応答は，
`暫定-応答@
とされ、他の`応答class$に属する応答は，
`最終-応答@
とされる。
◎
A single request can have multiple associated responses: zero or more interim (non-final) responses with status codes in the "informational" (1xx) range, followed by exactly one final response with a status code in one of the other ranges.
</p>

		<section id="overview.of.status.codes">
<h3 title="Overview of Status Codes">10.1. 状態s~codeの概観</h3>

<p>
下に挙げる`状態s~code$は、この仕様にて定義される。
括弧内に挙げる各種
`事由~句^dfn
（ `reason-phrase$p ）は、推奨に過ぎない
— それらは、~protocolに影響することなく，局所的な等価~物に置換できる。
◎
The status codes listed below are defined in this specification. The reason phrases listed here are only recommendations — they can be replaced by local equivalents without affecting the protocol.
</p>

<p>
`経験的に~cache可能$であるものと定義されている状態s~code（例： この仕様では
`200$st0,
`203$st0,
`204$st0,
`206$st0,
`300$st0,
`301$st0,
`308$st0,
`404$st0,
`405$st0,
`410$st0,
`414$st0,
`501$st0
）を伴う応答は、［
~method定義／明示的な~cache制御
］から指示されない限り，［
経験的な失効を伴う~cache
］により再利用できる（ `Caching/4.2.2$sec ）。
他のすべての状態s~codeは、経験的に~cache可能でない。
◎
Responses with status codes that are defined as heuristically cacheable (e.g., 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, and 501 in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [Caching]; all other status codes are not heuristically cacheable.
</p>

<div>
<ul><li>`100$st
</li><li>`101$st
</li><li>`200$st
</li><li>`201$st
</li><li>`202$st
</li><li>`203$st
</li><li>`204$st
</li><li>`205$st
</li><li>`206$st
</li><li>`300$st
</li><li>`301$st
</li><li>`302$st
</li><li>`303$st
</li><li>`304$st
</li><li>`305$st
</li><li>`306$st
</li><li>`307$st
</li><li>`308$st
</li><li>`400$st
</li><li>`401$st
</li><li>`402$st
</li><li>`403$st
</li><li>`404$st
</li><li>`405$st
</li><li>`406$st
</li><li>`407$st
</li><li>`408$st
</li><li>`409$st
</li><li>`410$st
</li><li>`411$st
</li><li>`412$st
</li><li>`413$st
</li><li>`414$st
</li><li>`415$st
</li><li>`416$st
</li><li>`417$st
</li><li>`418$st
</li><li>`422$st
</li><li>`426$st
</li><li>`500$st
</li><li>`501$st
</li><li>`502$st
</li><li>`503$st
</li><li>`504$st
</li><li>`505$st
</li></ul>
◎
Table 18
Value 	Description 	Ref.
100 	Continue 	10.2.1
101 	Switching Protocols 	10.2.2
200 	OK 	10.3.1
201 	Created 	10.3.2
202 	Accepted 	10.3.3
203 	Non-Authoritative Information 	10.3.4
204 	No Content 	10.3.5
205 	Reset Content 	10.3.6
206 	Partial Content 	10.3.7
300 	Multiple Choices 	10.4.1
301 	Moved Permanently 	10.4.2
302 	Found 	10.4.3
303 	See Other 	10.4.4
304 	Not Modified 	10.4.5
305 	Use Proxy 	10.4.6
306 	(Unused) 	10.4.7
307 	Temporary Redirect 	10.4.8
308 	Permanent Redirect 	10.4.9
400 	Bad Request 	10.5.1
401 	Unauthorized 	10.5.2
402 	Payment Required 	10.5.3
403 	Forbidden 	10.5.4
404 	Not Found 	10.5.5
405 	Method Not Allowed 	10.5.6
406 	Not Acceptable 	10.5.7
407 	Proxy Authentication Required 	10.5.8
408 	Request Timeout 	10.5.9
409 	Conflict 	10.5.10
410 	Gone 	10.5.11
411 	Length Required 	10.5.12
412 	Precondition Failed 	10.5.13
413 	Payload Too Large 	10.5.14
414 	URI Too Long 	10.5.15
415 	Unsupported Media Type 	10.5.16
416 	Range Not Satisfiable 	10.5.17
417 	Expectation Failed 	10.5.18
418 	(Unused) 	10.5.19
422 	Unprocessable Payload 	10.5.20
426 	Upgrade Required 	10.5.21
500 	Internal Server Error 	10.6.1
501 	Not Implemented 	10.6.2
502 	Bad Gateway 	10.6.3
503 	Service Unavailable 	10.6.4
504 	Gateway Timeout 	10.6.5
505 	HTTP Version Not Supported 	10.6.6
</div>

<p>
この~listは、網羅的ではないことに注意
— 他の仕様にて定義される拡張~状態s~code（ `10.7$sec ）は、含まれていない。
◎
Note that this list is not exhaustive — it does not include extension status codes defined in other specifications (Section 10.7).
</p>

		</section>
		<section id="status.1xx">
<h3 title="Informational 1xx">10.2. `1xx^st</h3>

<p>
`応答class$ `1xx^st に属する`状態s~code$は、`暫定-応答$を指示する
— すなわち、［
要請された動作, および
その`最終-応答$の送信
］を完了するに先立って，［
通信-中の接続~状態sや, 要請の進捗状況
］を~~伝えるためにある。
`1xx^st0 応答は、`~header節$が終端するに伴い終了する【したがって、`~message本体$を包含できない】。
~HTTP10は，この応答classの状態s~codeを定義しないので、`~server$は，~HTTP10~clientに対しては `1xx^st0 応答を送信してはナラナイ。
◎
The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. 1xx responses are terminated by the end of the header section. Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.
</p>

<p>
`~client$は、`最終-応答$に先立って受信した［
1 個以上の `1xx^st0 応答
］を
— 自身が予期していないとしても —
構文解析できなければナラナイ。
`~UA$は、予期していない `1xx^st0 応答を無視してもヨイ。
◎
A client MUST be able to parse one or more 1xx responses received prior to a final response, even if the client does not expect one. A user agent MAY ignore unexpected 1xx responses.
</p>

<p>
`~proxy$は、自身が `1xx^st0 応答の生成を要請した場合を除き，
`1xx^st0 応答を回送しなければナラナイ。
例えば，~proxyが要請を回送するときに［
`100-continue$c `期待$を内包する `Expect$h 【！`Expect: 100-continue^c】
］を追加した場合には、対応する `100^st 応答（たち）を回送する必要はない。
◎
A proxy MUST forward 1xx responses unless the proxy itself requested the generation of the 1xx response. For example, if a proxy adds an "Expect: 100-continue" field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s).
</p>
			<section id="status.100">
<h4>10.2.1. `100^st</h4>

<p>
状態s~code `100^stは、［
要請の初期~部分が受信され，まだ，~serverにより却下されていない
］ことを指示する。
~serverは、［
要請を全部的に受信して, それに動作した後に，`最終-応答$を送信する
］ことを意図している。
◎
The 100 (Continue) status code indicates that the initial part of a request has been received and has not yet been rejected by the server. The server intends to send a final response after the request has been fully received and acted upon.
</p>

<p>
［
`100-continue$c `期待$を内包する `Expect$h ~header
］を包含する要請に対する `100^st0 応答は、［
~serverが要請`~payload本体$の受信を望んでいる
］ことを指示する
— `~client$は、要請の送信を継続する~OUGHT —
`100^st0 応答は破棄して。
この`暫定-応答$が，そうでない要請に対するものであれば、`~client$は，単純にそれを破棄できる。
◎
When the request contains an Expect header field that includes a 100-continue expectation, the 100 response indicates that the server wishes to receive the request payload body, as described in Section 9.1.1. The client ought to continue sending the request and discard the 100 response.
◎
If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response.
</p>

			</section>
			<section id="status.101">
<h4>10.2.2. `101^st</h4>

<p>
状態s~code `101^stは、［
`~server$は，`~client$の要請を解したこと、この接続に利用されている応用~protocolを変更するために， `Upgrade$h ~header を介して要請に準拠する用意があること
］を指示する。
`~server$は、 `101^st0 応答~内に，次を指示する `Upgrade$h ~headerを`生成し$なければナラナイ
⇒
その応答を終了させる`空~行l$の直後から切替わることになる，~protocol（たち）
◎
The 101 (Switching Protocols) status code indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field (Section 6.7), for a change in the application protocol being used on this connection. The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be switched to immediately after the empty line that terminates the 101 response.
</p>

【！ `101^st0 は HTTP/2 では~supportされないので、この節の一部の記述は `Messaging$r の用語に基づいている。】

<p>
~serverが~protocolの切替に同意するのは、その方が有利なときに限られるものと見做されている。
例えば、［
より新しい~versionの~HTTPへの切替
］は，より古い~versionより有利であろうし、［
~real-time, 同期的~protocolへの切替
］は，そのような特能を利用する資源を送達するときに有利になるであろう。
◎
It is assumed that the server will only agree to switch protocols when it is advantageous to do so. For example, switching to a newer version of HTTP might be advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.
</p>

			</section>
		</section>
		<section id="status.2xx">
<h3 title="Successful 2xx">10.3. `2xx^st</h3>

<p>
`応答class$ `2xx^st に属する`状態s~code$は、`~client$の要請が，成功裡に［
受信され, 解され, 受容された
］ことを指示する。
◎
The 2xx (Successful) class of status code indicates that the client's request was successfully received, understood, and accepted.
</p>
			<section id="status.200">
<h4>10.3.1. `200^st</h4>

<p>
状態s~code `200^stは、［
要請は成功した
］ことを指示する。
`200^st0 応答~内に送信される~payloadは、`要請~method$に依存する。
この仕様が定義する~methodに対しては、~payloadに意図される意味は，次の様に要約できる：
◎
The 200 (OK) status code indicates that the request has succeeded. The payload sent in a 200 response depends on the request method. For the methods defined by this specification, the intended meaning of the payload can be summarized as:
</p>

<table>
<tbody><tr><th>`GET$m
<td>
`~target資源$の`表現$。
◎
a representation of the target resource;

<tr><th>`HEAD$m
<td>
`表現~data$は伴わないことを除いて、 `GET$m のときと同じ表現。
◎
the same representation as GET, but without the representation data;
<tr><th>`POST$m
<td>
［
動作の状態s,
または動作により得された結果
］の`表現$。
◎
a representation of the status of, or results obtained from, the action;
<tr><th>`PUT$m, `DELETE$m
<td>
［
動作の状態s
］の`表現$。
◎
a representation of the status of the action;
<tr><th>`OPTIONS$m
<td>
各種~通信~optionの`表現$。
◎
a representation of the communications options;

<tr><th>`TRACE$m
<td>
［
終端~serverにより受信された時点での，要請~message
］の`表現$。
◎
a representation of the request message as received by the end server.
</tbody>
</table>

<p>
`CONNECT$m に対する応答は別として、
`200^st0 応答は，常に~payloadを持つ
— `生成元~server$は、長さ 0 の`~payload本体$を`生成し$てもヨイが。
~payloadが欲されていない場合、生成元~serverは代わりに
`204$st を送信する~OUGHT。
`CONNECT$m に対しては，~payloadは許容されない
— その成功裡な結果は、`~tunnel$であり，
`200^st0 応答の`~header節$の直後から始まるので。
◎
Aside from responses to CONNECT, a 200 response always has a payload, though an origin server MAY generate a payload body of zero length. If no payload is desired, an origin server ought to send 204 (No Content) instead. For CONNECT, no payload is allowed because the successful result is a tunnel, which begins immediately after the 200 response header section.
</p>

<p>
`200^st0 応答は、`経験的に~cache可能$である。
◎
A 200 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.201">
<h4>10.3.2. `201^st</h4>

<p>
状態s~code `201^stは、［
要請は履行され，その結果 1 個以上の新たな`資源$が作成されている
］ことを指示する。
［
要請により作成された`首な資源$
］は、［
応答~内に `Location$h ~headerが受信されたならば その値 ／
他の場合は`~target~URI$
］により識別される。
◎
The 201 (Created) status code indicates that the request has been fulfilled and has resulted in one or more new resources being created. The primary resource created by the request is identified by either a Location header field in the response or, if no Location field is received, by the target URI.
</p>

<p>
`201^st0 応答の~payloadは、概して，作成された`資源$（たち）を述べ, それらへ~linkする。
`201^st0 応答~内の［
`ETag$h や `Last-Modified$h などの`検証子~header$
］の意味と目的についての論点は、`11.2$sec を見よ。
◎
The 201 response payload typically describes and links to the resource(s) created. See Section 11.2 for a discussion of the meaning and purpose of validator header fields, such as ETag and Last-Modified, in a 201 response.
</p>

			</section>
			<section id="status.202">
<h4>10.3.3. `202^st</h4>

<p>
状態s~code `202^stは、［
要請は処理~用に受容されたが，処理はまだ完了していない
］ことを指示する。
最終的に要請が動作するかどうかは、実際の処理に入るときに許容されなくなることもあるので，~~確定していない。
~HTTPには、［
非同期的な演算から【その進捗や完了を指示する】状態s~codeを送信し直す
］ような便宜性はない。
◎
The 202 (Accepted) status code indicates that the request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility in HTTP for re-sending a status code from an asynchronous operation.
</p>

<p>
`202^st0 応答は、意図的にどっちつかず（ `noncommittal^en ）にされている。
その目的は、`~server$が，何らかの処理n（たぶん，日に一度だけ稼働する一括的な処理n）用の要請を
— その処理の完了まで~serverへの接続を持続するよう，`~UA$に要求することなく —
受容できるようにすることにある。
この応答に伴って送信される`表現$は、要請の現在の状態sを述べることに加え，［
利用者に 要請がいつ履行されるかの見積もりを供せるような，状態s監視器
］を指す（または埋込む）~OUGHT。
◎
The 202 response is intentionally noncommittal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The representation sent with this response ought to describe the request's current status and point to (or embed) a status monitor that can provide the user with an estimate of when the request will be fulfilled.
</p>

			</section>
			<section id="status.203">
<h4>10.3.4. `203^st</h4>

<p>
状態s~code `203^stは、［
要請は成功したが、同封された~payloadは，【！5.7.2$sec】`形式変換ng~proxy$により［
生成元~serverの `200^st 応答のそれ
］から改変されている
］ことを指示する。
この状態s~codeにより、`形式変換$を適用した~proxyは，その旨を受信者たちに通知できるようになる
— その知識は、内容に関する今後の裁定に影響iするかもしれない。
例えば，［
内容に対する，未来の`~cache検証~要請$
］が適用-可能になるのは、同じ要請~経路に沿うもの（同じ~proxyたちを通して）に限られるようになり得る。
◎
The 203 (Non-Authoritative Information) status code indicates that the request was successful but the enclosed payload has been modified from that of the origin server's 200 (OK) response by a transforming proxy (Section 6.6.2). This status code allows the proxy to notify recipients when a transformation has been applied, since that knowledge might impact later decisions regarding the content. For example, future cache validation requests for the content might only be applicable along the same request path (through the same proxies).
</p>

<p>
`203^st0 応答は、［［
どの状態s~codeを伴う応答にも適用-可能である利点
］がある， `Warning$h ~code `214^c
］に類似する。
◎
The 203 response is similar to the Warning code of 214 Transformation Applied (Section 5.5 of [Caching]), which has the advantage of being applicable to responses with any status code.
</p>

<p>
`203^st0 応答は、`経験的に~cache可能$である。
◎
A 203 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.204">
<h4>10.3.5. `204^st</h4>

<p>
状態s~code `204^stは、［
`~server$は、要請を成功裡に履行した
］こと, および［
その応答`~payload本体$~内に送信する追加的な内容は無い
］ことを指示する。
`応答~header$内の~metadataは、`~target資源$, および［
要請された動作が適用された後に`選定された表現$
］を指す。
◎
The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body. Metadata in the response header fields refer to the target resource and its selected representation after the requested action was applied.
</p>

<p>
例えば、
`PUT$m 要請に対する応答~内に `204^st0が受信され，応答が `ETag$h ~fieldを包含する場合、
`PUT$m は成功していて，
`ETag$h `~field値$が［
その`~target資源$の新たな`表現$用の `entity-tag$p
］を包含する。
◎
For example, if a 204 status code is received in response to a PUT request and the response contains an ETag field, then the PUT was successful and the ETag field value contains the entity-tag for the new representation of that target resource.
</p>

<p>
`204^st0 応答により、`~server$は，`~UA$に向けて［［
~UAは，自身の現在の “文書~view” （もしあれば）から離れて他へ辿る必要はない
］ことを含意しつつ，動作が`~target資源$に成功裡に適用された
］ことを指示できるようになる。
`~server$は、［
~UAが、自身の~interfaceに則って，利用者に何らかの成功の指示を供した上で、［
応答~内の新たな／更新された~metadata
］を，~UAにて作動中の表現に適用することになる
］ものと見做している。
◎
The 204 response allows a server to indicate that the action has been successfully applied to the target resource, while implying that the user agent does not need to traverse away from its current "document view" (if any). The server assumes that the user agent will provide some indication of the success to its user, in accord with its own interface, and apply any new or updated metadata in the response to its active representation.
</p>

<p>
例えば， `204^st0は、［
“保存” 動作に対応する文書~編集~interface
］と伴に共通的に利用され，［
保存-中の文書が，利用者による編集~用に可用であり続ける
］ようにする。
それはまた、分散型の~version制御~systemの中など，［
自動化~data転送が主流になると期待される~interface
］と伴に利用されることも多い。
◎
For example, a 204 status code is commonly used with document editing interfaces corresponding to a "save" action, such that the document being saved remains available to the user for editing. It is also frequently used with interfaces that expect automated data transfers to be prevalent, such as within distributed version control systems.
</p>

<p>
`204^st0 応答は、`~message本体$を包含できない。
そのため、`~header節$が終端するに伴い【！＊の後の最初の`空~行l$で】終了する。
◎
A 204 response is terminated by the first empty line after the header fields because it cannot contain a message body.
</p>

<p>
`204^st0 応答は、`経験的に~cache可能$である。
◎
A 204 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.205">
<h4>10.3.6. `205^st</h4>

<p>
状態s~code `205^stは、［
`~server$は，要請を履行した
］こと, および［
`~UA$は，［
要請を送信させた “文書~view”
］を［
その，`生成元~server$から受信された元の状態に設定し直す
］よう欲している
］ことを指示する。
◎
The 205 (Reset Content) status code indicates that the server has fulfilled the request and desires that the user agent reset the "document view", which caused the request to be sent, to its original state as received from the origin server.
</p>

<p>
この応答は、［
次のような共通的な~data手入力の利用事例
］を~supportすることが意図されている
⇒
［［
~data手入力（~form, ~notepad, ~canvas, 等々）を~supportする内容
］を受信した利用者が，その場で手入力したり操作した~data
］が，要請にて提出されたとき、利用者が別の入力~動作に容易に取り掛かれるよう，次回の手入力~用に，~data手入力の仕組みを設定し直す。
◎
This response is intended to support a common data entry use case where the user receives content that supports data entry (a form, notepad, canvas, etc.), enters or manipulates data in that space, causes the entered data to be submitted in a request, and then the data entry mechanism is reset for the next entry so that the user can easily initiate another input action.
</p>

<p>
状態s~code `205^st0は，［
追加的な内容は供されない
］ことを含意するので、`~server$は，
`205^st0 応答~内に~payloadを`生成し$てはナラナイ。
◎
Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate a payload in a 205 response.
</p>

			</section>
			<section id="status.206">
<h4 title="206 Partial Content">10.3.7. `206^st</h4>

<p>
`状態s~code$ `206$st
— `部分的な応答^dfn —
は、［
~serverは、［
`選定された表現$を成す， 1 個~以上の部位t
］を転送することにより，`~target資源$に対する`範囲~要請$を成功裡に履行している
］ことを指示する。
◎
The 206 (Partial Content) status code indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation.
</p>

<p>
`206^st0 応答を`生成する$`~server$は、以下の下位節にて要求されるものに加えて，次に挙げる~headerのうち［
同じ要請に対する `200$st 応答~内に送信されることになるもの
］を`生成し$なければナラナイ
⇒＃
`Date$h,
`Cache-Control$h ,
`ETag$h,
`Expires$h,
`Content-Location$h,
`Vary$h
◎
When a 206 response is generated, the server MUST generate the following header fields, in addition to those required in the subsections below, if the field would have been sent in a 200 (OK) response to the same request: Date, Cache-Control, ETag, Expires, Content-Location, and Vary.
</p>

<p>
`206^st0 応答~内に在る `Content-Length$h ~fieldは、当の応答の`~message本体$を成す~octetの個数を指示する
— それは、通例的には，`選定された表現$の完全な長さにはならない。
各 `Content-Range$h ~fieldが，選定された表現の完全な長さについての情報を内包する。
◎
A Content-Length field present in a 206 response indicates the number of octets in the body of this message, which is usually not the complete length of the selected representation. Each Content-Range field includes information about the selected representation's complete length.
</p>

<div class="p">
<p>
`送信者$は、
`If-Range$h ~headerを伴う要請に対する応答に
◎
↓</p>
<ul>
	<li>
`206$st0 を`生成する$ときは
⇒
［
要求されるものを超える，他の`表現~header$
］は、`生成する$ベキでない
— ~clientは，それらの~headerたちを包含するような先立つ応答をすでに持っているものと解されるので。
◎
If a 206 is generated in response to a request with an If-Range header field, the sender SHOULD NOT generate other representation header fields beyond those required, because the client is understood to already have a prior response containing those header fields.＼
</li>
	<li>
他の場合
⇒
［
同じ要請に対する `200$st 応答~内に送信されることになる
］ような，すべての`表現~header$を`生成し$なければナラナイ。
◎
Otherwise, the sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.
</li>
</ul>
</div>

<p>
`206$st0 応答は、`経験的に~cache可能$である
— 明示的な~cache制御により指示されない限り（ `Caching/4.2.2$sec を見よ）。
◎
A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

				<section id="partial.single">
<h5 title="Single Part">10.3.7.1. 単独の部位t</h5>

<p>
`206^st0 応答を`生成し$ている`~server$は、単独の部位tを転送している場合、［
`選定された表現$のどの範囲が同封されたか, および
範囲を成す~payload
］を述べる `Content-Range$h ~headerを`生成し$なければナラナイ。
◎
If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a payload consisting of the range.＼
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Range: bytes 21010-47021/47022
Content-Length: 26012
Content-Type: image/gif

... 26012 bytes of partial image data ...
</pre>
</div>

				</section>
				<section id="partial.multipart">
<h5 title="Multiple Parts">10.3.7.2. 複数の部位t</h5>
<p>
`206^st0 応答を`生成し$ている`~server$は、複数の部位tを転送している場合は，
"`multipart/byteranges$c" ~payload, および［
"`multipart/byteranges$c" ~MIME型とそれに要求される `boundary^c ~parameter
］を包含する `Content-Type$h ~headerを`生成し$なければナラナイ。
単独の部位tによる応答との混同を避けるため、この応答の~HTTP`~header節$内には， `Content-Range$h ~headerを`生成し$てはナラナイ（この~headerは、以下に述べるように，各~部位tごとに送信することになる）。
◎
If multiple parts are being transferred, the server generating the 206 response MUST generate a "multipart/byteranges" payload, as defined in Section 7.3.5, and a Content-Type header field containing the multipart/byteranges media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).
</p>

<p>
`複部位$による~payload内の各~本体~部位tの~header区画の中では、その本体~部位t内に同封されている範囲に対応する， `Content-Range$h ~headerを`生成し$なければナラナイ。
`選定される表現$が，［
`200$st 応答においては `Content-Type$h ~headerを持つことになる
］ならば、その同じ `Content-Type$h ~headerを，各~本体~部位t内の~header区画~内に`生成する$ベキである。
◎
Within the header area of each body part in the multipart payload, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type field in the header area of each body part.＼
</p>

<div class="example">
<p>
例えば：
【この例では、 `THIS_STRING_SEPARATES^c が各 部位tを分離する境界を成す】
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Wed, 15 Nov 1995 06:25:24 GMT
Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
Content-Length: 1741
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...the first range...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
`~server$は、複数の範囲が要請されたときは、それらの範囲のうち［
重合するもの, あるいは
複数~部位tの送信による~overheadより小さな間隙で分離されるもの
］を合体してもヨイ
— 対応する `range-spec$p が，受信された `Range$h ~header内に出現する順序に関わらず。
"`multipart/byteranges$c" ~payloadの各~部位t間の 代表的な~overheadは， 80 ~byte程度なので、~~細切れにされた多数の部位tを転送するのは，［
`選定された表現$の~MIME型, および
選ばれた `boundary^c ~parameterの長さ
］に依存して、`選定された表現$ ~~全体を転送するより非~効率的になり得る。
◎
When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between parts of a multipart/byteranges payload is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.
</p>

<p>
`~server$は、単独の範囲に対する要請に対し，`複部位$応答を`生成し$てはナラナイ
— 複数の部位tを要請しなかった~clientは，`複部位$応答を~supportしないかもしれないので。
しかしながら，`~server$は、複数の範囲が要請されていて, かつ［
唯一の範囲が`満足可能$として見出された, または
合体した後に 1 個の範囲のみ残った
］ならば、単独の本体~部位tのみを伴う
"`multipart/byteranges$c" ~payloadを`生成し$てもヨイ。
"`multipart/byteranges$c" 応答を処理できない`~client$は、複数の範囲を依頼する要請を`生成し$てはナラナイ。
◎
A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a multipart/byteranges payload with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a multipart/byteranges response MUST NOT generate a request that asks for multiple ranges.
</p>

<p>
`~server$は、`複部位$応答の~payloadを生成するときには，受信された `Range$h ~header内に出現する対応する `range-spec$p と同じ順序で，各~部位tを送信するベキである
— 範囲たちのうち［
`満足可能$でないと判断される／他の範囲に合体される
］ものは除外した上で。
`複部位$応答を受信した`~client$は、各~本体~部位t内に在る `Content-Range$h ~headerを検分して，その本体~部位t内にどの範囲が包含されているかを決定しなければナラナイ
— ~clientは、自身が要請したものと同じ［
範囲たち／順序
］の受信に依拠できない。
◎
When a multipart response payload is generated, the server SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.
</p>

				</section>
				<section id="combining.byte.ranges">
<h5 title="Combining Parts">10.3.7.3. 範囲の結合-法</h5>

<p>
応答は、［
接続が尚早に~closeされた, または
要請が 1 個~以上の `Range$h 指定を利用した
］場合に，表現の部分範囲のみを転送し得る。
その種の転送が何度か行われたなら、~clientは，同じ表現のいくつかの範囲を受信することになるであろう。
これらの各~範囲を安全に結合できるのは、それらが揃って同じ`強い検証子$を持つ場合に限られる。
◎
A response might transfer only a subrange of a representation if the connection closed prematurely or if the request used one or more Range specifications. After several such transfers, a client might have received several ranges of the same representation. These ranges can only be safely combined if they all have in common the same strong validator (Section 11.2.1).
</p>

<p>
`~target資源$に対する何度かの `GET$m 要請に対し，複数の`部分的$（または`不完全$）な応答を受信した`~client$は、［
最も近過去に受信された応答（以下 `R^V と記す）が`強い検証子$を持つ
］ならば，［
`R^V 以外の，~cacheに格納-済みな応答のうち，同じ強い検証子を持つものたち
【のうち，いくつか？すべて？】
の集合（以下， `S^V と記す）
］とを，より大きな連続的な範囲に結合してもヨイ（結合した結果の応答を，以下 `C^V と記す）。

◎
A client that has received multiple partial responses to GET requests on a target resource MAY combine those responses into a larger continuous range if they share the same strong validator.
</p>
<ul class="switch">
	<li>
`R^V は `200$st 応答である場合
⇒
`R^V の~headerたちを `C^V に利用し、また，
`S^V 内の応答たちの~headerも置換する。
◎
If the most recent response is an incomplete 200 (OK) response, then the header fields of that response are used for any combined response and replace those of the matching stored responses.
</li>
	<li>
`R^V は `206$st 応答であるが， `S^V 内に `200$st0 応答がある場合
⇒
`C^V の~headerたちは，それらのうち最も近過去の `200^st0 応答の~headerたちからなる。
◎
If the most recent response is a 206 (Partial Content) response and at least one of the matching stored responses is a 200 (OK), then the combined response header fields consist of the most recent 200 response's header fields.＼
</li>
	<li>
`R^V も, `S^V 内のどの応答も， `206$st0 応答である場合
⇒
`S^V 内の最も近過去の~headerたちを伴う応答が， `C^V の~headerたちの~sourceとして利用される
— ただし，~clientは、 `Content-Range$h は別として，［
`R^V 内に供された，他の~headerたち
］を利用して，［［
`S^V 内の各 応答
］内の対応する~headerたちすべての~instance
］を置換しなければナラナイ。
◎
If all of the matching stored responses are 206 responses, then the stored response with the most recent header fields is used as the source of header fields for the combined response, except that the client MUST use other header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.
</li>
</ul>

<div class="p">
<p>
`C^V の`~message本体$は、［
`R^V, および［
`S^V 内の各 応答
］］による，いくつかの［
部分的~範囲の内容
］からなる和集合になる。
`~client$は、その和集合が：
◎
The combined response message body consists of the union of partial content ranges in the new response and each of the selected responses. If the union consists of＼
</p>
<ul class="switch">
	<li>
表現~~全体を成す場合
⇒
`C^V を，それが`完全$な `200$st 応答であるかのように処理しなければナラナイ
— 完全な長さを反映する， `Content-Length$h ~headerも含め。
◎
the entire range of the representation, then the client MUST process the combined response as if it were a complete 200 (OK) response, including a Content-Length header field that reflects the complete length.＼
</li>
	<li>
<p>
他の場合、和集合を成している各［
連続的な範囲たち
］を，次のいずれかとして処理しなければナラナイ：
◎
Otherwise, the client MUST process the set of continuous ranges as one of the following:＼
</p>

		<ul>
			<li>
`C^V が表現の先頭部分を成す場合に限り、`不完全$な `200$st 応答
◎
an incomplete 200 (OK) response if the combined response is a prefix of the representation,＼
</li>
			<li>
"`multipart/byteranges$c" 本体を包含している単独の `206$st 応答
◎
a single 206 (Partial Content) response containing a multipart/byteranges body, or＼
</li>
			<li>
それぞれが，［
`Content-Range$h ~headerにより指示される 1 個の連続的な範囲
］を伴うような、複数の `206$st 応答。
◎
multiple 206 (Partial Content) responses, each with one continuous range that is indicated by a Content-Range header field.
</li>
		</ul>
	</li>
</ul>
</div>

				</section>
			</section>
		</section>
		<section id="status.3xx">
<h3 title="Redirection 3xx">10.4. `3xx^st</h3>

<p>
`応答class$ `3xx^st に属する`状態s~code$は、［
要請が履行されるためには、~UAは，更なる動作をとる必要がある
］ことを指示する。
~redirectは、次に挙げる種別に分けられる：
◎
The 3xx (Redirection) class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request. There are several types of redirects:
</p>
<ul>
	<li>
［
当の`資源$は、 `Location$h ~fieldが供する，異なる~URIにて可用かもしれない
］ことを指示するもの
⇒＃
`301$st,
`302$st,
`307$st,
`308$st
◎
Redirects that indicate this resource might be available at a different URI, as provided by the Location field, as in the status codes 301 (Moved Permanently), 302 (Found), 307 (Temporary Redirect), and 308 (Permanent Redirect).
</li>
	<li>
何個かの合致した`資源$からなる選択肢を提供するもの
— それぞれが当の`資源$を表現する能力を有するような
⇒
`300$st
◎
Redirection that offers a choice among matching resources capable of representing this resource, as in the 300 (Multiple Choices) status code.
</li>
	<li>
［
`Location$h ~fieldにより識別され，要請に対する間接的な応答を表現し得る
］ような，異なる`資源$への~redirection
⇒
`303$st
◎
Redirection to a different resource, identified by the Location field, that can represent an indirect response to the request, as in the 303 (See Other) status code.
</li>
	<li>
以前に格納-済みな結果への~redirection
⇒
`304$st
◎
Redirection to a previously stored result, as in the 304 (Not Modified) status code.
</li>
</ul>

<p>
応答に `Location$h ~headerが供されている場合、`~UA$は
— その特定の状態s~codeを解せないときでも —
その`~field値$により参照される`~URI$へ向けて，要請を自動的に~redirectして
【 “~directし直して” 】
もヨイ。
自動~redirectionは、［
`安全$であると既知でない~methodに対しては、利用者は，その~redirectを望まないこともある
］ので，~~注意して行う必要がある。
◎
If a Location header field (Section 11.1.2) is provided, the user agent MAY automatically redirect its request to the URI referenced by the Location field value, even if the specific status code is not understood. Automatic redirection needs to be done with care for methods not known to be safe, as defined in Section 8.2.1, since the user might not wish to redirect an unsafe request.
</p>

<p>
`~UA$は，~redirectされた要請に対し自動的に追従するときは、［
元の要請~messageに，次に挙げる改変を加えた結果の要請
］を送信し直すベキである：
◎
When automatically following a redirected request, the user agent SHOULD resend the original request message with the following modifications:
</p>
<ol>
	<li>
`~target~URI$を次に置換する
⇒
［
~redirection応答の `Location$h ~header`~field値$が参照している~URI
］を［
元の要請の`~target~URI$
］に相対的に解決した結果
◎
Replace the target URI with the URI referenced by the redirection response's Location header field value after resolving it relative to the original request's target URI.
</li>
	<li>
<p>
当の実装により自動的に生成された~headerを除去して、それらを新たな要請に適切な，更新された値で置換する
— 次に挙げるものが含まれる：
◎
Remove header fields that were automatically generated by the implementation, replacing them with updated values as appropriate to the new request. This includes:
</p>
		<ul>
			<li>
接続に特有な~header（ `6.8$sec ）
◎
Connection-specific header fields (see Section 6.8),
</li>
			<li>
~clientの~proxy環境設定に特有な~header
— 次に挙げるものなど
⇒＃
`Proxy-Authorization$h
◎
Header fields specific to the client's proxy configuration, including (but not limited to) Proxy-Authorization,
</li>
			<li>
生成元に特有な~header
— 次に挙げるものなど
⇒＃
`Host$h
◎
Origin-specific header fields (if any), including (but not limited to) Host,
</li>
			<li>
実装の~cacheにより追加された検証-用~header（例：
`If-None-Match$h,
`If-Modified-Since$h
）
◎
Validating header fields that were added by the implementation's cache (e.g., If-None-Match, If-Modified-Since),
</li>
			<li>
資源に特有な~header
— 次に挙げるものなど
⇒＃
`Referer$h,
`Origin$h,
`Authorization$h,
`Cookie$h
◎
Resource-specific header fields, including (but not limited to) Referer, Origin, Authorization, and Cookie.
</li>
		</ul>
	</li>
	<li>
~securityの含意が在る所では、実装により自動的に生成されたものでない~header（すなわち、~callしている文脈により要請~内に追加されたもの）を除去することも，考慮する
— 次に挙げるものなど
⇒＃
`Authorization$h,
`Cookie$h
◎
Consider removing header fields that were not automatically generated by the implementation (i.e., those present in the request because they were added by the calling context) where there are security implications; this includes but is not limited to Authorization and Cookie.
</li>
	<li>
適用-可能なら、~redirectしている`状態s~code$の意味論に則って，当の要請~methodを変更する
◎
Change the request method according to the redirecting status code's semantics, if applicable.
</li>
	<li>
当の要請~methodを［
`GET$m ／ `HEAD$m
］に変更したならば、内容に特有な~headerを除去する
— 次に挙げるものなど
⇒＃
`Content-Encoding$h,
`Content-Language$h,
`Content-Location$h,
`Content-Type$h,
`Content-Length$h,
`Digest$h,
`ETag$h,
`Last-Modified$h
◎
If the request method has been changed to GET or HEAD, remove content-specific header fields, including (but not limited to) Content-Encoding, Content-Language, Content-Location, Content-Type, Content-Length, Digest, ETag, Last-Modified.
</li>
</ol>

<p class="note">注記：
~HTTP10においては、［
`301$st, `302$st
］のみが，この節の冒頭にて最初に挙げた種別の~redirect用として定義された（ `RFC1945/9.3$sec ）。
早期の~UAは、~redirect~targetに~methodを適用するときに，~methodを［
元の要請と同じにするもの, `GET$m に書換えるもの
］に分かれる。
~HTTPは，~~元々は［
`301$st0, `302$st に対しては前者の意味論
］に, ［
`303$st に対しては後者の意味論
］に合致するように定義されていたが、~~支配的な実施から［
`301$st0, `302$st0 に対しても後者の意味論
］になるように徐々に収束してきた。
`~HTTP11$の最初の改訂には、そのような実施の分岐に影響iされないものとして，
`302$st0 の前者の意味論を指示する `307$st が追加された。
10 年が経過した今でも、ほとんどの~UAは， `301$st0 ／ `302$st0 に対しては，依然として~methodを書換えている。
同じ理由で、後に `308$st が `301^st0 に合致するよう `RFC7538$r に追加された。
したがって，その挙動は、元の要請が `POST$m であるときには， `RFC7231$r により適合tとされた。
◎
Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and 302 (Found) were defined for the first type of redirect ([RFC1945], Section 9.3). Early user agents split on whether the method applied to the redirect target would be the same as the original request or would be rewritten as GET. Although HTTP originally defined the former semantics for 301 and 302 (to match its original implementation at CERN), and defined 303 (See Other) to match the latter semantics, prevailing practice gradually converged on the latter semantics for 301 and 302 as well. The first revision of HTTP/1.1 added 307 (Temporary Redirect) to indicate the former semantics of 302 without being impacted by divergent practice. For the same reason, 308 (Permanent Redirect) was later on added in [RFC7538] to match 301. Over 10 years later, most user agents still do method rewriting for 301 and 302; therefore, [RFC7231] made that behavior conformant when the original request is POST.
</p>

<p>
`~client$は、循環的な~redirection（すなわち， “無限” ~redirection~loop）を検出して，介入するベキである。
◎
A client SHOULD detect and intervene in cyclical redirections (i.e., "infinite" redirection loops).
</p>

<p class="note">注記：
この仕様の~~過去の~versionでは、~redirection回数として最大 5 回までが推奨されていた（ `RFC2068/10.3$sec ）。
内容~開発者は、そのような固定的な制限を実装する~clientもあり得ることを，自覚しておく必要がある。
◎
Note: An earlier version of this specification recommended a maximum of five redirections ([RFC2068], Section 10.3). Content developers need to be aware that some clients might implement such a fixed limitation.
</p>

			<section id="status.300">
<h4>10.4.1. `300^st</h4>

<p>
状態s~code `300^stは、［
`~target資源$には複数の`表現$が有り，そのそれぞれが［
自前の，より特定な識別子
］を伴う
］こと，および［
それらの代替についての情報が供されていて、利用者（または~UA）は，［
それらの識別子のうち 1 個以上のものへ，要請を~redirectする
］ことにより，選好する表現を選定できる
］ことを指示する。
言い換えれば、`~server$は，［
`~UA$が、`~reactive折衝$に携わって，自身の必要性に最も適切な表現（たち）を選定する
］よう欲している。
◎
The 300 (Multiple Choices) status code indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers. In other words, the server desires that the user agent engage in reactive negotiation to select the most appropriate representation(s) for its needs (Section 7.4).
</p>

<p>
`~server$は、それらの選択肢のうち 選好するものがあるならば，［
その選択肢の~URI参照を包含する `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その `Location$h `~field値$を，自動~redirectionに利用してもヨイ。
◎
If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference. The user agent MAY use the Location field value for automatic redirection.
</p>

<p>
`要請~method$は `HEAD$m でない場合、`~server$は， `300^st0 応答~内に［［
利用者／~UA
］が最も選好するものを選べるような，`表現~metadata$と~URI参照（たち）からなる~list
］を包含する~payloadを`生成する$ベキである。
`~UA$は、供された`~MIME型$を解するならば，その~listから自動的に選定してもヨイ。
［
自動~選定~用の特定の形式
］は、この仕様では，定義されない
— ~HTTPは、~payloadの定義に直交的であろうとし続けるので。
実施においては、`表現$は，［
共有されている 設計や`内容~折衝$により決定され，~UAに受容-可能と予見される，何らかの容易に構文解析できる形式
］か, あるいは［
何らかの共通的に受容される~hypertext形式
］により，供される。
◎
For request methods other than HEAD, the server SHOULD generate a payload in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred. The user agent MAY make a selection from that list automatically if it understands the provided media type. A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its payloads. In practice, the representation is provided in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation, or in some commonly accepted hypertext format.
</p>

<p>
`300^st0 応答は、`経験的に~cache可能$である。
◎
A 300 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

<p class="note">注記：
`300^st0 用の元の提案では、 `URI^h ~headerを［［
`200$st0 ／ `300^st0 ／ `406$st0
］応答に利用でき，［
`HEAD$m ~methodに対する応答~内に転送される，代替~表現の~list
］を供するもの
］として，定義していた。
しかしながら，［
配備の欠如と，構文について~~合意が得られなかった
］ため、［
`URI^h, および後続して提案された `Alternates^h
］は，この仕様から落とされることになった。
配備については鶏と卵の問題であるが、
`Link$h ~header `RFC8288$r の`~field値$として
— その~memberたちに関係性 "`alternate^c" 【 “代替する” 】を伴わせて —
~listを通信することはアリである。
◎
Note: The original proposal for the 300 status code defined the URI header field as providing a list of alternative representations, such that it would be usable for 200, 300, and 406 responses and be transferred in responses to the HEAD method. However, lack of deployment and disagreement over syntax led to both URI and Alternates (a subsequent proposal) being dropped from this specification. It is possible to communicate the list as a Link header field value [RFC8288] whose members have a relationship of "alternate", though deployment is a chicken-and-egg problem.
</p>

			</section>
			<section id="status.301">
<h4>10.4.2. `301^st</h4>

<p>
状態s~code `301^stは、［
`~target資源$に，新たな恒久的~URIがアテガわれていて、この資源への未来の参照は，同封された いずれかの~URIを利用する~OUGHT
］ことを指示する。
~link編集~能力を備えている`~client$は、アリな所では，`~target~URI$への参照を［
~serverから送信されてきた，1 個以上の新たな参照
］へ自動的に~linkし直す~OUGHT。
◎
The 301 (Moved Permanently) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs. Clients with link-editing capabilities ought to automatically re-link references to the target URI to one or more of the new references sent by the server, where possible.
</p>

<p>
`~server$は、応答~内に，［［
新たな恒久的~URIとして選好される，~URI参照
］を包含する， `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
新たな~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>

<p class="note">注記：
歴史的な理由から、~UAは，後続の要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、代わりに `308$st を利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 308 (Permanent Redirect) status code can be used instead.
</p>

<p>
`301^st0 応答は、`経験的に~cache可能$である。
◎
A 301 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.302">
<h4>10.4.3. `302^st</h4>

<p>
状態s~code `302^stは、［
`~target資源$が，一時的に，異なる~URIの下に居る
］ことを指示する。
~redirectionは，その時々で改められ得るので、`~client$は，未来の要請には`~target~URI$を利用し続ける~OUGHT。
◎
The 302 (Found) status code indicates that the target resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client ought to continue to use the target URI for future requests.
</p>

<p>
`~server$は、応答~内に，［［
その異なる~URI用の~URI参照
］を包含する `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

<p class="note">注記：
歴史的な理由から、`~UA$は，後続の要請~用の`要請~method$を
`POST$m から `GET$m へ変更してもヨイ。
この挙動が欲されない場合、代わりに `307$stを利用できる。
◎
Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 307 (Temporary Redirect) status code can be used instead.
</p>

			</section>
			<section id="status.303">
<h4>10.4.4. `303^st</h4>

<p>
状態s~code `303^stは、［
~serverが，~UAを［
`Location$h ~header内の~URIにより指示される，異なる`資源$
］へ~redirectしている
］ことを指示する
— その意図は、［
元の要請に対する間接的な応答を供する
］ことである。
`~UA$は、［
その~URIを~targetする検索取得~要請（ ~HTTPを利用しているなら `GET$m または `HEAD$m 要請）
］を遂行できる
— それは、［
元の要請に対する回答として最終的な結果を呈示する
］ために，また~redirectされ得る。
`Location$h ~header内の新たな~URIは、`~target~URI$に等価なものとは見なされないことに注意。
◎
The 303 (See Other) status code indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field, which is intended to provide an indirect response to the original request. A user agent can perform a retrieval request targeting that URI (a GET or HEAD request if using HTTP), which might also be redirected, and present the eventual result as an answer to the original request. Note that the new URI in the Location header field is not considered equivalent to the target URI.
</p>

<p>
この状態s~codeは、どの~HTTP~methodにも適用-可能である。
これは首に、［
`POST$m 動作の出力により，`~UA$を選定された`資源$へ~redirectできるようにする
］ために利用される
— そうすることにより、［
~formにおける `POST$m 応答に対応する情報
］は、元の要請からは独立に, ［
別々に［
識別する／~bookmarkする／~cacheする
］ことができる形
］で，供されるようになる。
◎
This status code is applicable to any HTTP method. It is primarily used to allow the output of a POST action to redirect the user agent to a selected resource, since doing so provides the information corresponding to the POST response in a form that can be separately identified, bookmarked, and cached, independent of the original request.
</p>

<p>
`GET$m 要請に対する `303^st0 応答は、［
`生成元~server$は［
~serverにより~HTTP越しに転送できるような［
`~target資源$の`表現$
］を持たないが、
`Location$h `~field値$は［
元の~target資源 `A^V を~~記述するものである，資源 `B^V
］を指している
］ことを指示する
— その資源 `B^V への検索取得~要請を為した結果が、資源 `A^V を表現することを含意することなく，受信者に有用な表現になり得るような。
［
何を表現し得るか？ ／
どのような表現であれば必要十分になるか？ ／
何が有用な~~記述になり得るか？
］に対する回答は、~HTTPの視野から外れることに注意。
◎
A 303 response to a GET request indicates that the origin server does not have a representation of the target resource that can be transferred by the server over HTTP. However, the Location field value refers to a resource that is descriptive of the target resource, such that making a retrieval request on that other resource might result in a representation that is useful to recipients without implying that it represents the original target resource. Note that answers to the questions of what can be represented, what representations are adequate, and what might be a useful description are outside the scope of HTTP.
</p>

<p>
`HEAD$m 要請に対する応答を除いて、［
`303^st0 応答の`表現$
］は、［［
`Location$h ~header内に供されたものと同じ~URI参照
］への~hyperlinkを伴う，短い~hypertext
］を包含する~OUGHT。
◎
Except for responses to a HEAD request, the representation of a 303 response ought to contain a short hypertext note with a hyperlink to the same URI reference provided in the Location header field.
</p>

			</section>
			<section id="status.304">
<h4>10.4.5. `304^st</h4>

<p>
`状態s~code$ `304$st は、条件付き［
`GET$m ／ `HEAD$m
］要請が受信されたこと, および［
仮に［
その条件が偽に`評価-$される事実がなかった
］とするならば， `200$st で応答することになる
］ことを指示する。
言い換えれば、~serverにとっては，`~target資源$の`表現$を転送する必要はない
— 何故なら，そのような要請は、［
その要請を条件付きにした~clientが，妥当な表現をすでに持っている
］ことを指示するので。
すなわち，~serverは、［
~clientに格納-済みな その表現を，
`200$st 応答の`~payload$であったかのように用立ててもらう
］べく，~clientを~redirectしている。
◎
The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response.
</p>

<p>
`304$st 応答を`生成する$~serverは、次に挙げる~headerのうち［
同じ要請に対し `200$st 応答にて送信されることになるもの
］すべてを`生成し$なければナラナイ
⇒＃
`Cache-Control$h,
`Content-Location$h,
`Date$h,
`ETag$h,
`Expires$h,
`Vary$h
◎
The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.
</p>

<p>
`304$st0 応答の目標は，［
受信者がすでに 1 個以上の~cache済み`表現$を有するときに，転送する情報を最小限にする
］ことなので、送信者は，上に挙げた~field以外の`表現~metadata$を`生成する$ベキでない
— その種の~metadataが~cache更新を手引きする目的で存在するのでない限り（例：
`Last-Modified$h は、応答が `ETag$h ~fieldを持たない場合には，有用になり得る）。
◎
Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).
</p>

<p>
`304$st0 応答を受信した~cacheに課される要件は、
`Caching/4.3.4$sec
にて定義される。
`条件付き要請$が`外方$にある`~client$
— 自前の~cacheを備え，共用~proxyに向けて条件付き `GET$m を送信する~UAなど —
により出生された場合、`~proxy$は，
`304$st0 応答を その~clientに向けて回送するベキである。
◎
Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [Caching]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.
</p>

<p>
`304$st0 応答は、`~message本体$【！`message-body$p 】を包含できない
— それは常に、`~header節$が終端するに伴い【！それを終わらせる最初の`空~行l$で】終了する。
◎
A 304 response cannot contain a message-body; it is always terminated by the first empty line after the header fields.
</p>

			</section>
			<section id="status.305">
<h4>10.4.6. `305^st</h4>

<p>
状態s~code `305^stは，この仕様の以前の~versionにて定義されていたが、今や非推奨にされた（ `RFC7231/B$sec ）。
◎
The 305 (Use Proxy) status code was defined in a previous version of this specification and is now deprecated (Appendix B of [RFC7231]).
</p>

			</section>
			<section id="status.306">
<h4>10.4.7. `306^st0 （未使用）</h4>

<p>
状態s~code `306^st0は，この仕様の以前の~versionにて定義されていたが、もはや利用されず，この~codeは予約-済みにされた。
◎
The 306 status code was defined in a previous version of this specification, is no longer used, and the code is reserved.
</p>

			</section>
			<section id="status.307">
<h4>10.4.8. `307^st</h4>

<p>
状態s~code `307^stは、［
`~target資源$が，一時的に異なる~URIの下に居る
］ことに加えて, ［
`~UA$は、［
その~URIへの自動~redirectionを遂行する
］ときに，`要請~method$を変更してはナラナイ
］ことを指示する。
~redirectionは，時間とともに変化し得るので、`~client$は，未来の要請にも 元の`~target~URI$を利用し続ける~OUGHT。
◎
The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI. Since the redirection can change over time, the client ought to continue using the original target URI for future requests.
</p>

<p>
`~server$は、応答~内に，［
その異なる~URI用の~URI参照を包含する， `Location$h ~header
］を`生成する$ベキである。
`~UA$は、その`~field値$を自動~redirectionに利用してもヨイ。
~serverの応答~payloadは、通例的に，［
その異なる~URI（たち）への~hyperlinkを伴う，短い~hypertext
］を包含する。
◎
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the different URI(s).
</p>

			</section>
			<section id="status.308">
<h4>10.4.9. `308^st</h4>

<p>
`状態s~code$ `308^st は、［
`~target資源$には，新たな恒久的~URIがアテガわれていて、この資源への未来の参照は，同封された いずれかの~URIを利用する~OUGHT
］ことを指示する。
~link編集~能力を備えている`~client$は、アリな所では，［
`~target~URI$への参照
］を［
`~server$から送信されてきた，1 個以上の新たな参照
］へ自動的に~linkし直す~OUGHT。
◎
The 308 (Permanent Redirect) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs. Clients with link editing capabilities ought to automatically re-link references to the target URI to one or more of the new references sent by the server, where possible.
</p>

<p>
`~server$は、応答~内に［
新たな恒久的~URI用に選好される~URI参照を包含している `Location$h ~header
］を生成するベキである。
`~UA$は、 `Location^h `~field値$を自動的~redirection用に利用してもヨイ。
~serverの応答`~payload$は、通例的に新たな~URI（たち）への~hyperlinkを伴う短い~hypertextを包含する。
◎
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response payload usually contains a short hypertext note with a hyperlink to the new URI(s).
</p>

<p>
`308^st0 応答は、`経験的に~cache可能$である。
◎
A 308 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

<p class="note">注記：
この状態s~codeは~~同類の~codeよりもずっと~~若い（ 2014 年 6 月）ので、どこでも認識されるとは限らない。
配備~上の考慮点については、 `RFC7538/4$sec を見よ。
◎
Note: This status code is much younger (June 2014) than its sibling codes, and thus might not be recognized everywhere. See Section 4 of [RFC7538] for deployment considerations.
</p>

			</section>
		</section>
		<section id="status.4xx">
<h3 title="Client Error 4xx">10.5. `4xx^st</h3>

<p>
`応答class$ `4xx^st に属する`状態s~code$は、［
~clientによる~errorに見える
］ことを指示する。
`HEAD$m 要請に対し応答するときを除いて、`~server$は，［［
その~error状況の説明，および
その条態は［
一時的, 恒久的
］のどちらなのか
］を包含している`表現$
］を送信するベキである。
これらの状態s~codeは、どの`要請~method$にも適用-可能である。
`~UA$は、内包された どの表現も，利用者に表示するベキである。
◎
The 4xx (Client Error) class of status code indicates that the client seems to have erred. Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents SHOULD display any included representation to the user.
</p>

			<section id="status.400">
<h4>10.5.1. `400^st</h4>

<p>
状態s~code `400^stは、［
~serverは、~client~errorに知覚される何かに因り，要請を処理できない／するつもりがない
］ことを指示する（例：
要請の構文が~~正しくない ／
要請~message~frame法が妥当でない ／
要請の~route法が~~誤認を誘うものである，など）。
◎
The 400 (Bad Request) status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).
</p>

			</section>
			<section id="status.401">
<h4>10.5.2. `401^st</h4>

<p>
状態s~code `401^st は、［
要請は、`~target資源$用の妥当な認証 `資格証$を欠如するために，まだ適用されていない
］ことを指示する。
`~server$が `401^st0 応答を`生成する$ときは、［
~target資源に適用-可能な `challenge$p を， 1 個~以上は包含する
］ような， `WWW-Authenticate$h ~headerを送信しなければナラナイ。
◎
The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource. The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.3.1) containing at least one challenge applicable to the target resource.
</p>

<div class="p">
<p>
要請が認証 `資格証$を内包していた場合、 `401^st0 応答は，［
その`資格証$に対する権限付与は，拒否された
］ことを指示する。
`~UA$は，その応答に対し：
◎
If the request included authentication credentials, then the 401 response indicates that authorization has been refused for those credentials.＼
</p>
<ul>
	<li>
［
新たな, または他の値に置換された `Authorization$h ~header
］を伴わせた上で，要請を繰返してもヨイ。
◎
The user agent MAY repeat the request with a new or replaced Authorization header field (Section 9.5.3).＼
</li>
	<li>
［
その `401^st0 応答が，それに先立つ応答と同じ `challenge$p を包含する
］, かつ［
~UAは，認証をすでに 1 回は試みていた
］場合、同封された表現を利用者に呈示するベキである
— それは、通例的に，関連な診断~情報を包含するので。
◎
If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information.
</li>
</ul>
</div>

			</section>
			<section id="status.402">
<h4>10.5.3. `402^st</h4>

<p>
状態s~code `402^stは、将来~利用のために予約-済みにされる。
◎
The 402 (Payment Required) status code is reserved for future use.
</p>

			</section>
			<section id="status.403">
<h4>10.5.4. `403^st</h4>

<p>
状態s~code `403^stは、［
~serverは、要請を解したが，その履行-を拒否している
］ことを指示する。
`~server$は、要請が何故 禁止されたか 公にしたいと望むならば，［
その事由を，応答の~payload（もしあれば）内に述べる
］ことができる。
◎
The 403 (Forbidden) status code indicates that the server understood the request but refuses to fulfill it. A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).
</p>

<p>
［
要請~内に認証用の`資格証$が供されていた
］場合、~serverは，［
それは，~accessを是認するには足らない
］と見なしている。
`~client$は、［
同じ資格証を伴わせた要請
］を，自動的に繰返すベキでない。
~clientは、［
新たな／異なる
］資格証を伴わせるのであれば，要請を繰返してもヨイ。
しかしながら、資格証に無関係な理由により，要請が禁止されることもある。
◎
If authentication credentials were provided in the request, the server considers them insufficient to grant access. The client SHOULD NOT automatically repeat the request with the same credentials. The client MAY repeat the request with new or different credentials. However, a request might be forbidden for reasons unrelated to the credentials.
</p>

<p>
`生成元~server$は、禁止された`~target資源$の現在の存在を “隠し” たいと望むときは，代わりに［
`404$st
］で応答してもヨイ。
◎
An origin server that wishes to "hide" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).
</p>

			</section>
			<section id="status.404">
<h4>10.5.5. `404^st</h4>
<p>
状態s~code `404^stは、［
`生成元~server$は、［
`~target資源$用に現在の`表現$を見出せなかった
］か, ［
~target資源が存在することを開示する用意はない
］］ことを指示する。
`404^st0は、［
この，表現の欠如は、［
一時的, 恒久的
］のどちらなのか
］は，指示しない。
`生成元~server$が，その条態は恒久的になる見込みが高いことを
— 大概は何らかの環境設定し得る手段を通して —
知る場合、 `404^st0よりも`410$stが選好される。
◎
The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists. A 404 status code does not indicate whether this lack of representation is temporary or permanent; the 410 (Gone) status code is preferred over 404 if the origin server knows, presumably through some configurable means, that the condition is likely to be permanent.
</p>

<p>
`404^st0 応答は、`経験的に~cache可能$である。
◎
A 404 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.405">
<h4>10.5.6. `405^st</h4>
<p>
状態s~code `405^stは、［
【！`request-line$p 内に】
受信した~methodは、`生成元~server$に既知ではあるが，`~target資源$においては~supportされない
］ことを指示する。
`生成元~server$は、 `405^st0 応答~内に［［
~target資源にて現在~supportされる~method
］の~listを包含する， `Allow$h ~header
］を`生成し$なければナラナイ。
◎
The 405 (Method Not Allowed) status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource. The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.
</p>

<p>
`405^st0 応答は、`経験的に~cache可能$である。
◎
A 405 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.406">
<h4>10.5.7. `406^st</h4>
<p>
状態s~code `406^stは、［
`~target資源$には，［
要請~内に受信された`~proactive折衝~header$に則って，~UAに受容-可能になる
］ような現在の`表現$は無い
］ことに加えて，［
~serverは、既定の表現を給する用意はない
］ことを指示する。
◎
The 406 (Not Acceptable) status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request (Section 9.4), and the server is unwilling to supply a default representation.
</p>

<p>
`~server$は、［［［
利用者／~UA
］が，最も適切なものを選べる
］ような［
可用な表現~特性の~list
］と，そのそれぞれに対応する資源~識別子
］を包含する~payloadを`生成する$ベキである。
`~UA$は、その~listから［
最も適切な選択肢
］を自動的に選定してもヨイ。
しかしながら，状態s~code `300$st にて述べたように、この仕様は，そのような自動~選定~用の どのような標準も，定義しない。
◎
The server SHOULD generate a payload containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate. A user agent MAY automatically select the most appropriate choice from that list. However, this specification does not define any standard for such automatic selection, as described in Section 10.4.1.
</p>

			</section>
			<section id="status.407">
<h4>10.5.8. `407^st</h4>

<div class="p">
<p>
状態s~code `407^st は、
`401$stに類似するが，［
`~client$は、【！＊】この要請~用に`~proxy$を利用するためには，認証が必要である
］ことを指示する：
◎
The 407 (Proxy Authentication Required) status code is similar to 401 (Unauthorized), but it indicates that the client needs to authenticate itself in order to use a proxy for this request.＼
</p>
<ul>
	<li>
`~proxy$は、当の要請~用に
`Proxy-Authenticate$h ~headerを
— 自身に適用-可能な `challenge$p を包含して —
送信しなければナラナイ。
◎
The proxy MUST send a Proxy-Authenticate header field (Section 11.3.2) containing a challenge applicable to that proxy for the request.＼
</li>
	<li>
`~client$は、［
新たな, または他の値に置換された，
`Proxy-Authorization$h ~header
］を伴わせた上で，要請を繰返してもヨイ。
◎
The client MAY repeat the request with a new or replaced Proxy-Authorization header field (Section 9.5.4).
</li>
</ul>
</div>
			</section>
			<section id="status.408">
<h4>10.5.9. `408^st</h4>

<p>
状態s~code `408^stは、［
~serverは、待機するよう準備された時間~内に，要請~messageを`完全$に受信しなかった
］ことを指示する。
`~client$は、応答待ち要請があれば，その要請を新たな接続~上にて繰返してもヨイ。
◎
The 408 (Request Timeout) status code indicates that the server did not receive a complete request message within the time that it was prepared to wait. If the client has an outstanding request in transit, the client MAY repeat that request on a new connection.
</p>

			</section>
			<section id="status.409">
<h4>10.5.10. `409^st</h4>

<p>
状態s~code `409^stは、［［
`~target資源$の現在の状態との競合
］に因り，要請を完了できなかった
］ことを指示する。
この~codeは、［
利用者は、競合を解決して，要請を再~提出し得る
］ような状況で利用される。
`~server$は、［
利用者が競合の源を認識するに十分な情報
］を内包する~payloadを，`生成する$ベキである。
◎
The 409 (Conflict) status code indicates that the request could not be completed due to a conflict with the current state of the target resource. This code is used in situations where the user might be able to resolve the conflict and resubmit the request. The server SHOULD generate a payload that includes enough information for a user to recognize the source of the conflict.
</p>

<p>
競合は、［
`PUT$m 要請に対する応答
］で生じる見込みが最も高い。
例えば，`生成元~server$は、~version法が利用されている下で［
`PUT$m している`表現$が，［
~~以前に（第三者主体からの）要請により~~行われたもの
］と競合するような，資源への変更を含む
］場合に，［
要請を完了できないことを指示する `409^st0 応答
］を利用し得る。
この事例では、応答の`表現$は，［
改訂~履歴に基づいて相違点を併合するために有用になる情報
］を包含することになる見込みが高い。
◎
Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the representation being PUT included changes to a resource that conflict with those made by an earlier (third-party) request, the origin server might use a 409 response to indicate that it can't complete the request. In this case, the response representation would likely contain information useful for merging the differences based on the revision history.
</p>

			</section>
			<section id="status.410">
<h4>10.5.11. `410^st</h4>

<p>
状態s~code `410^stは、［
`~target資源$への~accessが，`生成元~server$にて もはや可用でなく、その条態が恒久的になる見込みが高い
］ことを指示する。
`生成元~server$は、条態が恒久的になるかどうかについて判らない場合は，代わりに `404$stを利用する~OUGHT。
◎
The 410 (Gone) status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent. If the origin server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) ought to be used instead.
</p>

<p>
`410^st0 応答は、首に，~web保守の~taskを支援するために意図されており、`受信者$に向けて，［
資源は意図的に可用でなくされ，~server所有者が［
その資源への遠隔~linkは除去される
］ことを欲している
］ことを通知する。
そのような~eventは、臨時の販促~serviceや, ［
個々人に所属する資源が，もはや `生成元~server$の~siteに結付けられなくなったとき
］に，共通的にある。
恒久的に可用でない資源すべてを，［
“~~消失した” ものと~markしたり，その~markをいつまでも保つ
］ことは、必要とされない
— それは、~server所有者の裁量に~~委ねられる。
◎
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer associated with the origin server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time — that is left to the discretion of the server owner.
</p>

<p>
`410^st0 応答は、`経験的に~cache可能$である。
◎
A 410 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.411">
<h4>10.5.12. `411^st</h4>

<p>
状態s~code `411^stは、［
~serverは、 `Content-Length$h が定義されてない要請の受容-を拒否した
］ことを指示する。
`~client$は、要請~message内に［
`~message本体$の長さを包含する，妥当な `Content-Length$h ~header
］を追加した上で，要請を繰返してもヨイ。
◎
The 411 (Length Required) status code indicates that the server refuses to accept the request without a defined Content-Length (Section 7.2.4). The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message body in the request message.
</p>

			</section>
			<section id="status.412">
<h4>10.5.13. `412^st</h4>

<p>
`状態s~code$ `412$st は、［
各種~要請~headerにて与えられた条件のうち 1 つ以上が，~server上で~testされたときに偽に`評価-$された
］ことを指示する。
この応答~状態s~codeにより、~clientは，現在の`資源$の状態（資源の現在の`表現$と~metadata）に対し，`事前条件$を設置できるようになる
— したがって、`~target資源$が期待されない状態にある場合には，`要請~method$は適用されなくなる。
◎
The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server. This response status code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.
</p>

			</section>
			<section id="status.413">
<h4>10.5.14. `413^st</h4>

<p>
状態s~code `413^stは、［
要請の~payloadが，~serverが［
処理できる／処理する用意がある
］ものより巨大なため、~serverは 要請を処理するのを拒否している
］ことを指示する。
`~server$は、利用-中の~protocol~versionが許容するならば，要請を終了してもヨイ
— 他の場合、接続を~closeしてもヨイ。
◎
The 413 (Payload Too Large) status code indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process. The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.
</p>

<p>
条態が一時的である場合，`~server$は、
`Retry-After$h ~headerを`生成し$て，条態が一時的であること, および~clientが いつ再び試行してよいかを指示するベキである。
◎
If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.
</p>

			</section>
			<section id="status.414">
<h4>10.5.15. `414^st</h4>

<div class="p">
<p>
状態s~code `414^stは、［
`~target~URI$は，~serverが解釈する用意がある~~長さより長いため、~serverは，要請に対する~serviceを拒否している
］ことを指示する。
この稀な条態が生じるのは、ほぼ，次のときに限られる：
◎
The 414 (URI Too Long) status code indicates that the server is refusing to service the request because the target URI is longer than the server is willing to interpret. This rare condition is only likely to occur＼
</p>
<ul>
	<li>
~clientが `POST$m 要請を，不適正に，長い `query$p 情報を伴う `GET$m 要請に変換した。
◎
when a client has improperly converted a POST request to a GET request with long query information,＼
</li>
	<li>
~clientが~redirectionの “無限loop” に陥った（例：
~URI接頭辞の~redirect先が，接頭辞~自身に接尾辞を付加したものになっている）。
◎
when the client has descended into a "black hole" of redirection (e.g., a redirected URI prefix that points to a suffix of itself) or＼
</li>
	<li>
~clientが~~可能性のある~securityの穴を悪用しようと，~serverを攻撃している。
◎
when the server is under attack by a client attempting to exploit potential security holes.
</li>
</ul>
</div>

<p>
`414^st0 応答は、`経験的に~cache可能$である。
◎
A 414 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.415">
<h4>10.5.16. `415^st</h4>

<p>
状態s~code `415^stは、［
`~target資源$上では，［
要請の~payloadは，要請の~methodにより~supportされる形式ではない
］ため、`生成元~server$は 要請に対する~serviceを拒否している
］ことを指示する。
◎
The 415 (Unsupported Media Type) status code indicates that the origin server is refusing to service the request because the payload is in a format not supported by this method on the target resource.
</p>

<p>
形式の問題は、［
要請が指示した
`Content-Type$h ／ `Content-Encoding$h
］に因ることも, ［
要請の~dataを直に検分した結果
］に因ることもある。
◎
The format problem might be due to the request's indicated Content-Type or Content-Encoding, or as a result of inspecting the data directly.
</p>

<p>
当の問題が，~supportされない`内容~符号法$によるものである場合、
`Accept-Encoding$h 応答~headerを利用して，どの`内容~符号法$が（もし在れば）要請~内に受容されるかを指示する~OUGHT。
◎
If the problem was caused by an unsupported content coding, the Accept-Encoding response header field (Section 9.4.3) ought to be used to indicate what (if any) content codings would have been accepted in the request.
</p>

<p>
他方，~supportされない`~MIME型$によるものである場合、
`Accept$h 応答~headerを利用して，どの~MIME型が要請~内に受容されるかを指示できる。
◎
On the other hand, if the cause was an unsupported media type, the Accept response header field (Section 9.4.1) can be used to indicate what media types would have been accepted in the request.
</p>

			</section>
			<section id="status.416">
<h4>10.5.17. `416^st</h4>

<p>
`状態s~code$ `416$st は、要請の `Range$h ~header にて要請された範囲の集合は，次のいずれかに該当するため却下されたことを指示する
⇒＃
`満足可能$な範囲は無い／
過度に［~~細切れであるか重合している］（~DoS攻撃にもなり得る）
◎
The 416 (Range Not Satisfiable) status code indicates that the set of ranges in the request's Range header field (Section 9.3) has been rejected either because none of the requested ranges are satisfiable or because the client has requested an excessive number of small or overlapping ranges (a potential denial of service attack).
</p>

<p>
各 `範囲~単位$が、その単位による範囲~集合が
`満足可能@
になるためには何が要求されるかを定義する。
例えば，`~byte範囲$secは、何をもって~byte範囲の集合は満足可能とされるかを定義する。
◎
Each range unit defines what is required for its own range sets to be satisfiable. For example, Section 7.1.4.2 defines what makes a bytes range set satisfiable.
</p>

<p>
`送信者$は、この`状態s~code$を［
`~byte範囲$の要請に対する応答
］内に`生成する$ときは，［
`選定された表現$の現在の長さ
］を指定する `Content-Range$h ~headerを`生成する$ベキである。
◎
When this status code is generated in response to a byte-range request, the sender SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 7.3.4).
</p>

<div class="example">

<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
HTTP/1.1 416 Range Not Satisfiable
Date: Fri, 20 Jan 2012 15:41:54 GMT
Content-Range: bytes */47022
</pre>
</div>

<p class="note">注記：
~serverが `Range$h を無視するのは自由なので、多くの実装は
`200$st 応答において，`選定された表現$ ~~全体で応答する。
その~~理由の一部は、ほとんどの~clientが，（たとえ~~効率が落ちるとしても）
`200$st を受信して~taskを完了するように準備されているためであり、また，~clientには［
`完全$な表現を受信するまで，妥当でない部分的~要請【`範囲~要請$】を為すのを停止しない
］ものもあるためである。
したがって，~clientは、それが最も適切になるときでも，
`416$st 応答の受信には依存できない。
◎
Note: Because servers are free to ignore Range, many implementations will respond with the entire selected representation in a 200 (OK) response. That is partly because most clients are prepared to receive a 200 (OK) to complete the task (albeit less efficiently) and partly because clients might not stop making an invalid partial request until they have received a complete representation. Thus, clients cannot depend on receiving a 416 (Range Not Satisfiable) response even when it is most appropriate.
</p>

			</section>
			<section id="status.417">
<h4>10.5.18. `417^st</h4>

<p>
状態s~code `417^stは、［
`内方$にある いずれかの~serverにて，［
要請の `Expect$h ~header内に与えられた期待
］に応えられなかった
］ことを指示する。
◎
The 417 (Expectation Failed) status code indicates that the expectation given in the request's Expect header field (Section 9.1.1) could not be met by at least one of the inbound servers.
</p>

			</section>
			<section id="status.418">
<h4>10.5.19. `418^st0 （利用されない）</h4>

<p>
`RFC2324$r は、~HTTPを濫用する様々な仕方を~~風刺した `April 1^en RFC であった。
そのような濫用の一つは、応用に特有な `418^st0 状態s~codeの定義であった。
年月を経て、この状態s~codeは “`Easter Egg^en” として広範に実装されており，実質的にこの利用に消費されている。
◎
[RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code. In the intervening years, this status code has been widely implemented as an "Easter Egg", and therefore is effectively consumed by this use.
</p>

<p>
したがって，状態s~code `418^st0 は、~IANA
`~HTTP状態s~code~registry$cite
にて予約される。
すなわち、現時点では，この状態s~codeには，他の応用はアテガえないことを指示する。
将来の状況下で，その利用が要求された場合（例： `4xx^st0 状態s~codeが枯渇した）、別の利用が再びアテガわれ得る。
◎
Therefore, the 418 status code is reserved in the IANA HTTP Status Code Registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use.
</p>

			</section>
			<section id="status.422">
<h4>10.5.20. `422^st</h4>

<p>
状態s~code `422^st0 は、［
~serverは、要請~payloadの内容~型を解した（よって，状態s~code `415$st は適切でない）, かつ
要請~payloadの構文は正しいが、それが包含する指示書きは処理-不能である
］ことを指示する。
この状態s~codeは、例えば，~XML要請~payloadの内容は整形式である（すなわち、構文上は正しい）が，意味論的には~~誤った~XML指示命令である場合に生じる。
◎
The 422 (Unprocessable Payload) status code indicates that the server understands the content type of the request payload (hence a 415 (Unsupported Media Type) status code is inappropriate), and the syntax of the request payload is correct, but was unable to process the contained instructions. For example, this status code can be sent if an XML request payload contains well-formed (i.e., syntactically correct), but semantically erroneous XML instructions.
</p>

			</section>
			<section id="status.426">
<h4>10.5.21. `426^st</h4>

<p>
状態s~code `426^stは、［
~serverは、［
現在の~protocolの下では，要請の遂行-を拒否した
］が，［
~clientが異なる~protocolに昇格した後には，そうする用意がある
］であろう
］ことを指示する。
`~server$は、 `426^st0 応答~内に［
要求される~protocol（たち）を指示する， `Upgrade$h ~header
］を送信しなければナラナイ。
◎
The 426 (Upgrade Required) status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 6.7).
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
HTTP/1.1 426 Upgrade Required
Upgrade: HTTP/3.0
Connection: Upgrade
Content-Length: 53
Content-Type: text/plain

This service requires use of the HTTP/3.0 protocol.
【この~serviceには HTTP/3.0 ~protocolの利用が要求されます。】
</pre>
</div>

			</section>
		</section>
		<section id="status.5xx">
<h3 title="Server Error 5xx">10.6. `5xx^st</h3>

<p>
`応答class$ `5xx^st に属する`状態s~code$は、［
~serverは、自身の~errorを自覚したか，要請された~methodを遂行する能力を備えていない
］ことを指示する。
【！ 複製】
`HEAD$m 要請に対し応答するときを除いて、`~server$は，［［
その~error状況の説明，および
その条態は［
一時的, 恒久的
］のどちらなのか
］を包含している`表現$
］を送信するベキである。
`~UA$は、内包された表現があれば，それを利用者に表示するベキである。
これらの状態s~codeは、どの`要請~method$にも適用-可能である。
◎
The 5xx (Server Error) class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method. Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. A user agent SHOULD display any included representation to the user. These response codes are applicable to any request method.
</p>

			<section id="status.500">
<h4>10.6.1. `500^st</h4>

<p>
状態s~code `500^stは、［
~serverは、予期しない条態に遭遇して，要請を履行できなくなった
］ことを指示する。
◎
The 500 (Internal Server Error) status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.
</p>

			</section>
			<section id="status.501">
<h4>10.6.2. `501^st</h4>

<p>
状態s~code `501^stは、［
~serverは、要請を履行するために要求される機能性を~supportしない
］ことを指示する。
これは、［
~serverは、`要請~method$を認識せず，どの資源も それを~supportする能力を備えていない
］ときに適切な応答になる。
◎
The 501 (Not Implemented) status code indicates that the server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
</p>

<p>
`501^st0 応答は、`経験的に~cache可能$である。
◎
A 501 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [Caching]).
</p>

			</section>
			<section id="status.502">
<h4>10.6.3. `502^st</h4>

<p>
状態s~code `502^stは、［［
`~gateway$／`~proxy$
］として動作している~serverが、要請を履行しようと試みているときに，自身が~accessした`内方$にある~serverから妥当でない応答を受信した
］ことを指示する。
◎
The 502 (Bad Gateway) status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.
</p>

			</section>
			<section id="status.503">
<h4>10.6.4. `503^st</h4>

<p>
状態s~code `503^stは、［
~serverは、［
いくばくかの遅延~後に軽減される見込みが高いような，一時的な過負荷 または~scheduleされた保守
］に因り，現在 要請を取扱えない
］ことを指示する。
`~server$は、 `Retry-After$h ~headerを送信して，［
~clientが要請を再試行する前に待機する，適量な時間
］を示唆してもヨイ。
◎
The 503 (Service Unavailable) status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. The server MAY send a Retry-After header field (Section 11.1.3) to suggest an appropriate amount of time for the client to wait before retrying the request.
</p>

<p class="note">注記：
状態s~code `503^st0の存在は、［
過負荷~時には，その利用が~serverに要求される
］ことを含意するわけではない。
単純に接続を拒否する~serverもあり得る。
◎
Note: The existence of the 503 status code does not imply that a server has to use it when becoming overloaded. Some servers might simply refuse the connection.
</p>

			</section>
			<section id="status.504">
<h4>10.6.5. `504^st</h4>

<p>
状態s~code `504^stは、［［
`~gateway$／`~proxy$
］として動作している~serverが，［
要請を完了するために~accessする必要がある，`上流$~server
］から適時に応答を受信できなかった
］ことを指示する。
◎
The 504 (Gateway Timeout) status code indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.
</p>

			</section>
			<section id="status.505">
<h4>10.6.6. `505^st</h4>

<p>
状態s~code `505^stは、［
~serverは、［
要請~message内に利用された~HTTP`~major~version$
］を~supportしない／~supportを拒否した
］ことを指示する。
~serverは、［
~clientと同じ`~major~version$を利用するどの要請も，この~error~message以外では 完了できない／する用意はない
］ことを指示している（ `4.2$sec を見よ）。
`~server$は、 `505^st0 応答に対しては，［
その~versionが何故~supportされないか, および
自身が~supportする他の~protocol
］について述べる`表現$を`生成する$ベキである。
◎
The 505 (HTTP Version Not Supported) status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 4.2, other than with this error message. The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.
</p>

			</section>
		</section>
		<section id="status.code.extensibility">
<h3 title="Status Code Extensibility">10.7. 状態s~codeの拡張能</h3>

<p>
この仕様の視野から外れる追加的な`状態s~code$も，~HTTPにおける利用~用に指定されている。
そのような状態s~codeは、すべて
`~HTTP状態s~code~registry$cite
の中に登録される~OUGHT。
◎
Additional status codes, outside the scope of this specification, have been specified for use in HTTP. All such status codes ought to be registered within the "Hypertext Transfer Protocol (HTTP) Status Code Registry".
</p>

			<section id="status.code.registry">
<h4 title="Status Code Registry">10.7.1. 状態s~code~registry</h4>

<p>
`状態s~code$番号は、
`~HTTP状態s~code~registry$cite
にて保守され，そこに登録される。
◎
The "Hypertext Transfer Protocol (HTTP) Status Code Registry", maintained by IANA at &lt;https://www.iana.org/assignments/http-status-codes&gt;, registers status code numbers.
</p>

<p>
登録は、次の~fieldを内包しなければナラナイ：
◎
A registration MUST include the following fields:
</p>
<ul>
	<li>
`状態s~code$（ 3 桁）
◎
• Status Code (3 digits)
</li>
	<li>
短い説明d
◎
• Short Description
</li>
	<li>
仕様~textへの~pointer
◎
• Pointer to specification text
</li>
</ul>

<p>
~HTTP状態s~code名前空間に追加される値は、
`IETF による考査$を要する。
◎
Values to be added to the HTTP status code namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

			</section>
			<section id="considerations.for.new.status.codes">
<h4 title="Considerations for New Status Codes">10.7.2. 新たな状態s~codeに対する考慮点</h4>

<p>
［
現在の状態s~codeにより定義されない応答~用の意味論
］を表出することが必要とされるときは、新たな状態s~codeを登録できる。
`状態s~code$は、汎用である
— すなわち，それらは、特定0の［
`~MIME型$／資源の種類／~HTTPの応用
］のみならず，どの資源にも適用-可能になり得る。
そのようなわけで、新たな状態s~codeは，［
単独の応用
］に特有でない文書に登録されることが選好される。
◎
When it is necessary to express semantics for a response that are not defined by current status codes, a new status code can be registered. Status codes are generic; they are potentially applicable to any resource, not just one particular media type, kind of resource, or application of HTTP. As such, it is preferred that new status codes be registered in a document that isn't specific to a single application.
</p>

<p>
新たな`状態s~code$は、定義-済みな いずれかの`応答class$に入ることが要求される。
既存の構文解析器が，応答~messageを処理できるようにするため、新たな状態s~codeは，~payloadを許容する必要がある
— `~payload本体$を長さ 0 に義務化することはできるが。
◎
New status codes are required to fall under one of the categories defined in Section 10. To allow existing parsers to process the response message, new status codes cannot disallow a payload, although they can mandate a zero-length payload body.
</p>

<p>
［
まだ広範に配備されてない，新たな状態s~code
］用の提案は、［
登録されることになる明瞭な合意が得られる
］まで，［
~code用に特定の番号を割振ることを避ける
］~OUGHT
— 早期の草案は、代わりに，［
提案される状態s~codeの`応答class$
］を，尚早に番号を消費することなく指示する［
"`4NN^c" や, "`3N0^c" 〜 "`3N9^c" などの表記法
］を利用できる。
◎
Proposals for new status codes that are not yet widely deployed ought to avoid allocating a specific number for the code until there is clear consensus that it will be registered; instead, early drafts can use a notation such as "4NN", or "3N0" .. "3N9", to indicate the class of the proposed status code(s) without consuming a number prematurely.
</p>

<p>
新たな`状態s~code$の定義は、以下について［
説明する／指定する
］~OUGHT：
◎
↓</p>
<ul>
	<li>
要請が［
その状態s~codeを包含する応答を~~生じさせる
］ための条件（例： `要請~header$や~methodの組合nなど）。
◎
The definition of a new status code ought to explain the request conditions that would cause a response containing that status code (e.g., combinations of request header fields and/or method(s)) along with＼
</li>
	<li>
`応答~header$との依存関係
— 例えば，その状態s~codeを応答に利用するときに
⇒＃
要求される~fieldは何か？／
どの~fieldが意味論を改変し得るか？／
意味論が更に精緻化される~fieldは何か？
◎
any dependencies on response header fields (e.g., what fields are required, what fields can modify the semantics, and what field semantics are further refined when used with the new status code).
</li>
	<li>
既定では、状態s~codeは，それが生じた応答に対応する要請に限り適用される。
状態s~codeの適用能が，より広い視野
— 例えば，当の資源へのすべての要請／~serverへのすべての要請 —
に及ぶ場合、そのことを明示的に指定しなければならない。
そうする場合、新たな状態s~codeを解さない~clientもあるかもしれないので，［
すべての~clientに対し，より広い視野にも一貫して適用されるものと期待できる
］とは限らないことを注記するべきである。
◎
By default, a status code applies only to the request corresponding to the response it occurs within. If a status code applies to a larger scope of applicability — for example, all requests to the resource in question, or all requests to a server — this must be explicitly specified. When doing so, it should be noted that not all clients can be expected to consistently apply a larger scope, because they might not understand the new status code.
</li>
	<li>
<p>
~cache可能であるかどうか。
◎
The definition of a new status code ought to specify whether or not it is cacheable.＼
</p>

<p>
状態s~codeが何であれ、明示的な`鮮度~情報$を伴う応答は，~cacheできることに注意
— しかしながら，［
~cache可能として定義された状態s~code
］を伴う応答は、明示的な`鮮度~情報$が無くても~cacheすることが許容される。
同様に，状態s~codeの定義は、~cacheの挙動に拘束を設置できる。
更なる情報は `Caching$r を見よ。
◎
Note that all status codes can be cached if the response they occur in has explicit freshness information; however, status codes that are defined as being cacheable are allowed to be cached without explicit freshness information. Likewise, the definition of a status code can place constraints upon cache behavior. See [Caching] for more information.
</p>
	</li>
	<li>
~payloadには、識別される資源（ `7.3.2$sec ）への何らかの結付けが含意されるかどうか。
◎
Finally, the definition of a new status code ought to indicate whether the payload has any implied association with an identified resource (Section 7.3.2).
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="response.header.fields">
<h2 title="Response Header Fields">11. 応答~header</h2>

<p>
`応答~header^dfn
により、~serverは［
`状態s~code$を超える，応答についての追加的な情報
］を渡せるようになる。
これらの~headerは、［
~server／`~target資源$への更なる~access／関係する資源
］についての情報を与える。
◎
The response header fields allow the server to pass additional information about the response beyond the status code. These header fields give information about the server, about further access to the target resource, or about related resources.
</p>

<p>
各種 `応答~header$は，それ自身に定義される意味を持つが、一般に，精確な意味論は［
`要請~method$や`応答~状態s~code$の意味論
］により更に精緻化され得る。
◎
Although each response header field has a defined meaning, in general, the precise semantics might be further refined by the semantics of the request method and/or response status code.
</p>

		<section id="response.control.data">
<h3 title="Control Data">11.1. 制御~data</h3>

<p>
次に挙げる`応答~header$は、［
状態s~codeを補足する ／
~cachingを指令する ／
~clientに次へ行く所を指図する
］ような
`制御~data^dfn
を給せる：
◎
Response header fields can supply control data that supplements the status code, directs caching, or instructs the client where to go next.
</p>

<div>
<ul ><li>`Age$h `Caching$r
</li><li>`Cache-Control$h `Caching$r
</li><li>`Expires$h `Caching$r
</li><li>`Date$h
</li><li>`Location$h
</li><li>`Retry-After$h
</li><li>`Vary$h
</li><li>`Warning$h `Caching$r
</li></ul>
◎
Table 19
Field Name 	Ref.
Age 	Section 5.1 of [Caching]
Cache-Control 	Section 5.2 of [Caching]
Expires 	Section 5.3 of [Caching]
Date 	11.1.1
Location 	11.1.2
Retry-After 	11.1.3
Vary 	11.1.4
Warning 	Section 5.5 of [Caching]
</div>

			<section id="field.date">
<h4>11.1.1. `Date^h</h4>

<p>
`Date^h ~headerは、~messageが
<dfn id="origination-date">出生した日付時刻</dfn>
を表現する
— その意味論は、 `RFC5322/3.6.1$sec に定義される `Origination Date Field^en （ `orig-date^p ）と同じである。
その`~field値$は：
◎
The "Date" header field represents the date and time at which the message was originated, having the same semantics as the Origination Date Field (orig-date) defined in Section 3.6.1 of [RFC5322]. The field value is an HTTP-date, as defined in Section 5.4.1.5.
</p>

<pre class="bnf">
`Date@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Date: Tue, 15 Nov 1994 08:12:31 GMT
</pre>
</div>

<p>
`送信者$は、 `Date^h ~headerを`生成する$ときは，その~header値として［
~message生成の日付時刻に可用な，最良な近似
］を`生成する$ベキである。
理論~上は、日時は，~payloadが`生成され$る~~直前の瞬間を表現する~OUGHT。
実施~上は、日時は，~message出生時の間の任意の時点に`生成され$得る。
◎
When a Date header field is generated, the sender SHOULD generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before the payload is generated. In practice, the date can be generated at any time during message origination.
</p>

<p>
`時計@
— ~UTCによる~~現在時の適度な近似を供する時計 —
を備えていない`生成元~server$は、
`Date^h ~headerを送信してはナラナイ。
生成元~serverは、`応答~状態s~code$の`応答class$が［
`1xx$st ／ `5xx$st
］である場合， `Date^h ~headerを送信してもヨイ
— 他のすべての事例では， `Date^h ~headerを送信しなければナラナイ。
◎
An origin server MUST NOT send a Date header field if it does not have a clock capable of providing a reasonable approximation of the current instance in Coordinated Universal Time. An origin server MAY send a Date header field if the response is in the 1xx (Informational) or 5xx (Server Error) class of status codes. An origin server MUST send a Date header field in all other cases.
</p>

<p>
`時計$を備えている`受信者$が，［
`Date^h ~headerを伴わない応答~messageを受信した
］ときは、それを［
~cacheする／下流へ回送する
］ときには，受信した時刻を記録して，~messageの`~header節$に［
対応する `Date^h ~header
］付加しなければナラナイ。
◎
A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.
</p>

<p>
`~UA$は、要請~内に `Date^h ~headerを送信してもヨイ
— 一般には，~serverにとって有用な情報を伝達するものと予見される場合に限られるが。
例えば，~HTTPの~customな応用は、［
~serverが、利用者からの要請の解釈を，~UAと~serverにおける時計の相違に基づいて調整する
］ことが予期される場合には， `Date^h を伝達することもあろう。
◎
A user agent MAY send a Date header field in a request, though generally will not do so unless it is believed to convey useful information to the server. For example, custom applications of HTTP might convey a Date if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks.
</p>

			</section>
			<section id="field.location">
<h4>11.1.2. `Location^h</h4>

<p>
`Location^h ~headerは、［
応答に関係する特定の資源を指す
］ために，一部の応答~内にて利用される。
関係性の型は、［
`要請~method$, `状態s~code$
］の意味論の組合nで定義される。
◎
The "Location" header field is used in some responses to refer to a specific resource in relation to the response. The type of relationship is defined by the combination of request method and status code semantics.
</p>

<pre class="bnf">
`Location@p
    = `URI-reference$p
</pre>

<p>
`~field値$は、単独の `URI-reference$p からなる。
値が相対~参照（ `RFC3986/4.2$sec ）の形をとる場合、最終-値は，`~target~URI$に~~相対的に解決することで算出される（ `RFC3986/5$sec ）。
◎
The field value consists of a single URI-reference. When it has the form of a relative reference ([RFC3986], Section 4.2), the final value is computed by resolving it against the target URI ([RFC3986], Section 5).
</p>

<p>
`Location^h 値は、
`201$st 応答に対しては［
要請により作成された
`首な資源@
］を指す ／
`3xx$st 応答に対しては，［
要請を自動的に~redirectするときに選好される`~target資源$
］を指す。
◎
For 201 (Created) responses, the Location value refers to the primary resource created by the request. For 3xx (Redirection) responses, the Location value refers to the preferred target resource for automatically redirecting the request.
</p>

<p>
`3xx$st 応答~内に供される `Location^h 値に 素片~成分（ `fragment$p ）がない場合、`~UA$は，~redirectionを［
その値は、［
`~target~URI$を`生成する$ときに利用した~URI参照
］の素片~成分を継承している
］かのように処理しなければナラナイ（すなわち，~redirectionは、元の参照に素片があるならば，それを継承する）。
◎
If the Location value provided in a 3xx (Redirection) response does not have a fragment component, a user agent MUST process the redirection as if the value inherits the fragment component of the URI reference used to generate the target URI (i.e., the redirection inherits the original reference's fragment, if any).
</p>

<div class="example">
<p>
例えば、［
~URI参照 "`http://www.example.org/~tim^c" に対し`生成され$た `GET$m 要請
］の結果が，次の~headerを包含する `303$st 応答になるならば：
◎
For example, a GET request generated for the URI reference "http://www.example.org/~tim" might result in a 303 (See Other) response containing the header field:
</p>

<pre class="lang-http">
Location: /People.html#tim
</pre>

<p>
これは、~UAが
"`http://www.example.org/People.html#tim^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.org/People.html#tim"
</p>

<p>
同様に、［
~URI参照 "`http://www.example.org/index.html#larry^c" に対し`生成され$た `GET$m 要請
］の結果が，次の~headerを包含する `301$st 応答になるならば：
◎
Likewise, a GET request generated for the URI reference "http://www.example.org/index.html#larry" might result in a 301 (Moved Permanently) response containing the header field:
</p>

<pre class="lang-http">
Location: http://www.example.net/index.html
</pre>

<p>
これは、~UAが，元の`素片~識別子$を保全して
"`http://www.example.net/index.html#larry^c"
へ~redirectすることを示唆する。
◎
which suggests that the user agent redirect to "http://www.example.net/index.html#larry", preserving the original fragment identifier.
</p>
</div>

<p>
`Location^h 値~内の素片~識別子が，適切でなくなる状況もある：
例えば，［
`201$st 応答~内の `Location^h ~header
］は、［
作成された資源に特有な~URI
］を供するものと仮定されることになる。
◎
There are circumstances in which a fragment identifier in a Location value would not be appropriate. For example, the Location header field in a 201 (Created) response is supposed to provide a URI that is specific to the created resource.
</p>

<p class="note">注記：
一部の`受信者$は、［
`Location^h ~fieldの~URI参照が妥当でない
］ときに，その回復を試みる。
この仕様は，そのような処理を義務化したり定義しないが、堅牢性の~~目的で，それを許容する。
`Location^h の`~field値$は、~memberの~listを許容し得ない
— ~list分離子である~commaは、 `URI-reference$p の中でも妥当な~data文字なので。
複数個の `Location$h ~fieldを伴う妥当でない~messageが送信された場合、当の経路~上の ある`受信者$は，それらの`~field行l$を 1 個に`結合-$するかもしれない。
その状況から妥当な `Location^h ~field値を回復するのは、困難であり，各 実装~間で相互運用可能にならない。
◎
Note: Some recipients attempt to recover from Location fields that are not valid URI references. This specification does not mandate or define such processing, but does allow it for the sake of robustness. A Location field value cannot allow a list of members because the comma list separator is a valid data character within a URI-reference. If an invalid message is sent with multiple Location field instances, a recipient along the path might combine the field instances into one value. Recovery of a valid Location field value from that situation is difficult and not interoperable across implementations.
</p>

<p class="note">注記：
`Content-Location$h ~headerは、それが［
同封された`表現$に対応する最も特定な資源
］を指す点で， `Location^h から相違する。
したがって、応答が［
`Location^h, `Content-Location$h
］両~headerを包含することもアリである。
◎
Note: The Content-Location header field (Section 7.2.5) differs from Location in that the Content-Location refers to the most specific resource corresponding to the enclosed representation. It is therefore possible for a response to contain both the Location and Content-Location header fields.
</p>

			</section>
			<section id="field.retry-after">
<h4>11.1.3. `Retry-After^h</h4>

<p>
~serverは、［
~UAが後継の要請を為す前に，どのくらい長く待機する~OUGHT
］かを指示するために， `Retry-After^h ~headerを送信する。
［
`503$st 応答に伴って送信されてきた `Retry-After^h
］は、［
当の~serviceが~clientに可用でないと予期されるのは、いつまでか
］を指示する。
［
`3xx$st 応答に伴って送信されてきた `Retry-After^h
］は、［
~redirect要請を発行iする前に，~UAに待機するよう依頼する最短な時間
］を指示する。
◎
Servers send the "Retry-After" header field to indicate how long the user agent ought to wait before making a follow-up request. When sent with a 503 (Service Unavailable) response, Retry-After indicates how long the service is expected to be unavailable to the client. When sent with any 3xx (Redirection) response, Retry-After indicates the minimum time that the user agent is asked to wait before issuing the redirected request.
</p>

<p>
この~fieldの値は、
【可用になるであろう日時を与える】 `HTTP-date$p, または
応答を受信してからの遅延~秒数【を与える `delay-seconds$p 】をとる。
◎
The value of this field can be either an HTTP-date or a number of seconds to delay after the response is received.
</p>

<pre class="bnf">
`Retry-After@p
    = `HTTP-date$p
    / `delay-seconds$p
</pre>

<p>
`delay-seconds$p 値は、秒数を表現する負でない~decimal整数である。
◎
A delay-seconds value is a non-negative decimal integer, representing time in seconds.
</p>

<pre class="bnf">
`delay-seconds@p
    = 1*`DIGIT$P
</pre>

<div class="example">
<p>
その利用~例：
◎
Two examples of its use are
</p>

<pre class="lang-http">
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
</pre>

<p>
後者の遅延は 2 分間になる。
◎
In the latter example, the delay is 2 minutes.
</p>
</div>

			</section>
			<section id="field.vary">
<h4>11.1.4. `Vary^h</h4>

<p>
応答~内の `Vary^h ~headerは、［
~method／`~target~URI$
］の他に，要請~messageのどの部分が［
`生成元~server$による，この応答を選定して表現する処理n
］に波及し得た（し得る）かを述べる。
◎
The "Vary" header field in a response describes what parts of a request message, aside from the method and target URI, might influence the origin server's process for selecting and representing this response.
</p>

<pre class="bnf">
`Vary@p
    = #( "*" / `field-name$p )
</pre>

<p>
`Vary^h `~field値$は、~listであり，この応答~用の`表現$を選定する役割を担い得た要請~field名からなる
— これらは
`選定用~header@
と呼ばれる。
選定用~headerになり得るものは、この仕様が定義するものに制限されない。
◎
A Vary field value is a list of request field names, known as the selecting header fields, that might have a role in selecting the representation for this response. Potential selecting header fields are not limited to those defined by this specification.
</p>

<p>
この~listが "`*^c" を包含する場合、要請の他の側面
— 場合によっては、~message構文の外側の要素も含む（例：~clientの~network~address） —
が，応答の`表現$を選定する役割を担い得ることを通達する。
`受信者$は、この応答が今後の【以前の要請と一致する】要請にも適切になるかどうかを
— 要請を`生成元~server$に回送しない限り —
決定できないことになる。
`~proxy$は、 `Vary^h の`~field値$内に "`*^c" を`生成し$てはナラナイ。
◎
If the list contains "*", it signals that other aspects of the request might play a role in selecting the response representation, possibly including elements outside the message syntax (e.g., the client's network address). A recipient will not be able to determine whether this response is appropriate for a later request without forwarding the request to the origin server. A proxy MUST NOT generate "*" in a Vary field value.
</p>

<div class="example">
<p>
例えば，次を包含する応答は：
◎
For example, a response that contains
</p>

<pre class="lang-http">
Vary: accept-encoding, accept-language
</pre>

<p>
次を指示する
⇒
`生成元~server$は、この応答~用の内容を選ぶ決定要因として，要請の［
`Accept-Encoding$h, `Accept-Language$h
］~field（または それらの欠如）を利用したかもしれない
◎
indicates that the origin server might have used the request's Accept-Encoding and Accept-Language fields (or lack thereof) as determining factors while choosing the content for this response.
</p>
</div>

<p>
`生成元~server$が［
`~field名$の~listを伴う `Vary^h
］を送信する目的には、次の 2 つがあり得る：
◎
An origin server might send Vary with a list of fields for two purposes:
</p>
<ul>
	<li>
<p>
~cache受信者たちに，次のことを伝える
⇒
今後の要請において、その要請が［
~listされた~fieldについて，元の要請と同じ値をとる（ `Caching/4.1$sec ）
］のでない限り，この応答を その要請を満足するために利用してはナラナイ。
</p>
<p>
言い換えれば `Vary^h は、［
新たな要請が，格納-済みな~cache~entryに合致する
］ために要求される~cache~keyを拡げる。
</p>
◎
To inform cache recipients that they MUST NOT use this response to satisfy a later request unless the later request has the same values for the listed fields as the original request (Section 4.1 of [Caching]). In other words, Vary expands the cache key required to match a new request to the stored cache entry.
</li>
	<li>
~UA受信者に，次のことを伝える
⇒
この応答は，`内容~折衝の~subject$であり、~listされたいずれかの~header内に 追加的な~parameterが供される場合（`~proactive折衝$）には，後続の要請に対し異なる`表現$が送信され得る。
◎
To inform user agent recipients that this response is subject to content negotiation (Section 9.4) and that a different representation might be sent in a subsequent request if additional parameters are provided in the listed header fields (proactive negotiation).
</li>
</ul>

<p>
`生成元~server$は、［
自身による，`表現$を選定する~algo
］が［
要請~messageの，~methodや`~target~URI$以外の側面
］に基づいて変動するときには， `Vary^h ~headerを送信するベキである
— ただし，その変動が `cross^en し得ないとき 【次の最初の例】, あるいは［
生成元~serverは、~cache透過性を防止するように，故意に環境設定されている
］ときは除く
— 例えば：
◎
An origin server SHOULD send a Vary header field when its algorithm for selecting a representation varies based on aspects of the request message other than the method and target URI, unless the variance cannot be crossed or the origin server has been deliberately configured to prevent cache transparency. For example,＼
</p>
<ul>
	<li>
`~field名$ `Authorization$h は、［
その定義により，複数~利用者にまたがる再利用が拘束される
］ことから， `Vary^h 内に送信する必要はない。
◎
there is no need to send the Authorization field name in Vary because reuse across users is constrained by the field definition (Section 9.5.3).＼
</li>
	<li>
同様に，生成元~serverは、［
変動よりも， `Vary^h による~cachingの処理能~costへの影響iの方が，有意である
］と見なす場合は，［
`Vary^h に代えて， `Cache-Control$h 応答~指令を利用する
］かもしれない。
◎
Likewise, an origin server might use Cache-Control response directives (Section 5.2 of [Caching]) to supplant Vary if it considers the variance less significant than the performance cost of Vary's impact on caching.
</li>
</ul>

			</section>
		</section>
		<section id="response.validator">
<h3 title="Validators">11.2. 検証子</h3>
<p>
下に挙げる
`検証子~header^dfn
は、［
`選定された表現$についての~metadata
］を伝達する。
◎
Validator header fields convey metadata about the selected representation (Section 7).＼
</p>

<p>
［
`安全$な要請に対する応答
］内の検証子~fieldは、［
応答の取扱い中に，`生成元~server$により選ばれ, `選定された表現$
］について述べる。
`状態s~code$の意味論に依存して、必ずしも［
所与の応答において`選定された表現$が，その応答の~payloadに同封されている表現と同じになる
］とは限らないことに注意。
◎
In responses to safe requests, validator fields describe the selected representation chosen by the origin server while handling the response. Note that, depending on the status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response payload.
</p>

<p>
［
状態変更 要請に対する成功裡な応答
］内の検証子~fieldは、［
その要請を処理した結果
］として，［［
それに先立って`選定された表現$
］を置換する，新たな`表現$
］について述べる。
◎
In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior selected representation as a result of processing the request.
</p>

<p>
例えば，［
`201$st 応答~内の `ETag$h ~field
］は、 “`更新喪失$” 問題を防止するため，［
新たに作成された資源の表現~用の `entity-tag$p
］を通信して、それを今後の`条件付き要請$内に利用できるようにする。
◎
For example, an ETag field in a 201 (Created) response communicates the entity-tag of the newly created resource's representation, so that it can be used in later conditional requests to prevent the "lost update" problem Section 9.2.
</p>

<div>
<ul><li>`ETag$h
</li><li>`Last-Modified$h
</li></ul>
◎
Table 20
Field Name 	Ref.
ETag 	11.2.3
Last-Modified 	11.2.2
</div>

<p>
この仕様は、［
`資源$の状態を観測する, および
`事前条件$を~testする
］ために共通的に利用される， 2 種の形の~metadata［
`改変~日時$,
`不透明$な `entity-tag$p
］を定義する。
`資源$の状態を反映する追加的な~metadataも，~HTTPの様々な拡張により定義されている
— この仕様の視野を超える
WebDAV（ `Web Distributed Authoring and Versioning^en, `RFC4918$r ）など。
`事前条件$の中で利用される資源~metadata値は、
`検証子^dfn
と呼ばれる。
◎
This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (Section 11.2.2) and opaque entity tags (Section 11.2.3). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, [RFC4918]), that are beyond the scope of this specification. A resource metadata value is referred to as a "validator" when it is used within a precondition.
</p>

			<section id="weak.and.strong.validators">
<h4 title="Weak versus Strong">11.2.1. 弱い vs. 強い</h4>

<p>
検証子には、強いものと, 弱いものがある。
`弱い検証子$は，容易に生成できるが、比較~~用途には，あまり有用でない。
`強い検証子$は，比較~~用途に理想的であるが、効率的に生成するのは，とても困難にも（ときには不可能にも）なり得る。
~HTTPは、［
すべての形の`資源$に，同じ強さの検証子を固守する
］ことを課すのではなく，［
利用~中にある検証子の型を公開する
］こと, および［
`弱い検証子$を いつどこで`事前条件$に利用できるか
］についての制約を課す。
◎
Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.
</p>

<p>
`強い検証子@
とは、［
`表現~data$が変化する度に値が変化する，`表現~metadata$
］であって，［
`GET$m  に対する `200$st 応答
］の`~payload本体$にて観測-可能になるものである。
◎
A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a 200 (OK) response to GET.
</p>

<p>
`強い検証子$は、`表現~data$の変化-以外の理由
— `表現~metadata$の意味論的に有意な部分（例： `Content-Type$h ）が変更された，など —
から変化することもあるが、`生成元~server$にとって~~最大の関心~事は，［［
遠隔~cacheや著作~toolにより保持されている，格納-済み応答
］を無効化させる必要がある
］ときにのみ，値を変更することである。
◎
A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.
</p>

<p>
~cache~entryは、その失効~時機に関わらず，~~任意の期間 持続し続け得る。
したがって~cacheは、［
~~遠い過去に得された検証子を利用している~entry
］を検証しようと試みることもある。
`強い検証子$は、［
ある特定の`資源$に結付けられた，すべての`表現$のすべての~version
］間で，時経過にわたり一意になる。
しかしながら、［
互いに異なる資源
］の表現~間にわたる一意性については，含意されない（すなわち、同じ`強い検証子$が，同~時に複数の資源の表現から利用~中になり得るが、それらの表現が等価であることは含意されない）。
◎
Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).
</p>

<p>
実施においては、種々の`強い検証子$が利用されている。
厳密な改訂~制御に基づくものが最良である
— 表現に対する各~変更に際して，［
表現が `GET$m から~access可能にされる前
］に，常に，一意な~node名と改訂~識別子がアテガわれるような。
［
応答~headerが送信されるに先立って，~dataが可用である
］下では，耐衝突~hash関数を`表現~data$に適用して得られる~digestでも足り、検証~要請が受信される度に計算し直す必要はない。
<span id="_errata-5236-1">
ただし、`資源$が［
~metadataにおいてのみ相違するような，別個な`表現$を持つ
］場合（`内容~折衝$の対象になる`~MIME型$のうち ~~複数のものが，同じ~data形式を共有するときに生じ得る）には、`生成元~server$は，それらの表現どうしを判別するための追加的な情報を，検証子に組入れる必要がある。</span>
◎
There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.
</p>

<div class="p">
<p>
対照的に，
`弱い検証子@
は、`表現~data$が変化しても変化しない場合もあるような，`表現~metadata$である。
この弱さは、次のいずれかに因り得る：
◎
In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to＼
</p>
<ul>
	<li>
`時計$の分解能などの，値が計算される方法における制限。
◎
limitations in how the value is calculated, such as clock resolution,＼
</li>
	<li>
`資源$にアリなすべての`表現$ 間での一意性を，確保できないとき。
◎
an inability to ensure uniqueness for all possible representations of the resource, or＼
</li>
	<li>
資源~所有者は、`表現$ 間で一意な~data列ではなく，何らかの自己決定的な等価性に基づいて、`表現$たちを いくつかの集合に~group化することを欲しているとき。
◎
a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.＼
</li>
</ul>

<p>
`生成元~server$は、［
先立つ`表現$たちが現在の`表現$の代用として受容-可能でない
］と見なす度に，`弱い$ `entity-tag$p を変更するベキである。
言い換えれば、~cacheの中の古い応答を無効化させたく求める度に，変更する~OUGHT。
◎
An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.
</p>
</div>

<p>
例えば、［
動的な測定法に基づいて 内容が秒単位で変化するような，天気~予報の表現
］は、同じ`弱い検証子$により，（`生成元~server$から見て）等価な表現の集合に~group化されるかもしれない
— ~cache済み表現が、（たぶん，~server負荷や天気の質に基づいて動的に調整されるような）適度な期間，有効であり続けられるようにするために。
同様に、表現の改変~時刻が秒単位の分解能で定義されていて，その表現が 1 秒~間に 2 回~改変され，それらの改変の合間に検索取得され得る場合には、`弱い検証子$になることがある。
◎
For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.
</p>

<p>
同様に、検証子は、所与の`資源$の~~複数の`表現$間で同~時に共有されているならば，`弱い$ものになる
— それらの`表現~data$が一致しない限り。
例えば、`生成元~server$が，［
`gzip$c `内容~符号法$が適用された表現
］に対し［
内容~符号法を伴わない表現のときと同じ`検証子$
］を送信する場合、それは`弱い検証子$になる。
しかしながら，複数の`表現$が，同じ`強い検証子$を同時に共有することもある
— 同じ`表現~data$に対し，複数の異なる`~MIME型$が可用であるときなど、それらが`表現~metadata$においてのみ相違する場合には。
【！ https://www.rfc-editor.org/errata/eid5162】
◎
Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.
</p>

<p>
`強い検証子$は、どの`条件付き要請$にも利用できる
— ［
`~cache検証$,
`部分的$な内容~範囲,
“`更新喪失$” 回避法
］も含め。
`弱い検証子$を利用できるのは、［
~clientが以前に得した`表現~data$との正確な同等性を要求しないとき
］に限られる
— ~cache~entryを検証するときや，近過去の変更に対しては~web~traversalを制限するときなど。
◎
Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.
</p>

			</section>
			<section id="field.last-modified">
<h4>11.2.2. `Last-Modified^h</h4>

<p>
応答~内の `Last-Modified$h ~headerは、`生成元~server$が要請の取扱いから結論に至った，
`改変~日時@
— `選定された表現$が最後に改変された日付時刻 —
を指示する時刻印を供する。
◎
The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.
</p>

<pre class="bnf">
`Last-Modified@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of its use is
</p>

<pre class="lang-http">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre>
</div>

				<section id="lastmod.generation">
<h5 title="Generation">11.2.2.1. 生成</h5>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
その最後の`改変~日時$を，適度かつ一貫するように決定できる
］ならば、
`Last-Modified$h を送信するベキである
— `条件付き要請$における その利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する有意な要因になり得るので。
◎
An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([Caching]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability.
</p>

<p>
表現は概して、資源~interfaceの背後にある多くの部分の総和である。
最後に改変された時刻は、通例的に［
それらの部分のどれかが変更された，最も近過去の時刻
］になる。
所与の任意の`資源$に対し，その値が決定される方法は、実装の詳細であり，この仕様の視野を超える。
~HTTPに関わるのは、
`Last-Modified$h ~headerの受信者たちが［
`条件付き要請$を為す ／
局所的に~cacheされた応答の有効性を~testする
］ために，その値をどう利用できるかである。
◎
A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification. What matters to HTTP is how recipients of the Last-Modified header field can use its value to make conditional requests and test the validity of locally cached responses.
</p>

<p>
`生成元~server$は、［［
自身が応答に対し `Date$h `~field値$を生成する時刻
］にアリな限り近い，`表現$の `Last-Modified$h 値
］を得するベキである。
これにより、受信者は，表現の改変 時刻を正確aに査定できるようになる
— とりわけ，表現の変化が［
応答が`生成され$た時刻
］に近い場合に。
◎
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.
</p>

<p>
`時計$を備える`生成元~server$は、［
~serverによる~message出生時の時刻（ `Date$h ）より後の， `Last-Modified$h 日時
］を送信してはナラナイ。
最後の改変~時刻が，［［
生成元~serverの`時計$に則って，ある未来の時刻に評価される
］ような実装に特有な~metadata
］から導出される場合、`生成元~server$は，その値を~message出生時の日時に置換しなければナラナイ。
未来の`改変~日時$は、`~cache検証$に~~悪影響があるので。
◎
An origin server with a clock MUST NOT send a Last-Modified date that is later than the server's time of message origination (Date). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.
</p>

<p>
`時計$を備えていない`生成元~server$は、応答に `Last-Modified$h 値をアテガってはナラナイ
— その値が、依拠-可能な`時計$を備える他の~systemや利用者により，`資源$に結付けられていない限り。
◎
An origin server without a clock MUST NOT assign Last-Modified values to a response unless these values were associated with the resource by some other system or user with a reliable clock.
</p>

				</section>
				<section id="lastmod.comparison">
<h5 title="Comparison">11.2.2.2. 比較</h5>

<p>
要請~内の検証子として利用される，応答~内の `Last-Modified$h 時刻（以下 `V^V ）は、次のいずれかの規則を利用して`強い検証子$であることが演繹できない限り，暗黙的に`弱い検証子$になる（以下における `表現^V は、その検証子に結付けられている`表現$を指す）：
◎
A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
</p>
<ul>
	<li>
<p>
`生成元~server$が、検証子 `V^V を， `表現^V に対する実際の現在の検証子と比較しているとき：
◎
The validator is being compared by an origin server to the actual current validator for the representation and,
</p>
		<ul>
			<li>
［
`V^V から定まる秒~数の間、 `表現^V が，2 回~以上†変化しない
］ことを、その生成元~serverが依拠-可能に知り得る。
【† twice — “もう 1 回” の意味？】
◎
That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator.
</li>
		</ul>
	</li>
	<li>
<p>
~clientが、 `表現^V に対する~cache~entryを持っているので，検証子 `V^V を［
`If-Modified-Since$h ／
`If-Unmodified-Since$h ／
`If-Range$h
］~header内に利用しつつあるとき：
◎
or
◎
The validator is about to be used by a client in an If-Modified-Since, If-Unmodified-Since, or If-Range header field, because the client has a cache entry for the associated representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値を内包する
］，かつ
◎
That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^V は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
	<li>
<p>
中継~cacheが、検証子 `V^V を，［
自身の~cache~entry内に格納-済みな， `表現^V 用の検証子
］と比較しているとき：
◎
or
◎
The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値
］を内包する，かつ
◎
That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^V は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
</ul>

<!-- 
上述から、同じ応答~内の検証子に対する
強い／弱い
の定義は、~server／~client／中継~cacheの間で異なり得ることになる。
-->

<p>
この演繹-法は、［
異なる 2 個の応答が，同じ秒の間に`生成元~server$から送信されたが、両者とも同じ `Last-Modified$h 時刻を持っていた場合には、少なくとも一方の応答は，その
`Last-Modified$h 時刻に等しい `Date$h 値を持つことになる
］という事実に依拠する。
恣意的な 60 秒の上限は、
`Date$h ＆ `Last-Modified$h 値が［
異なる`時計$, あるいは
応答を準備する間にずれた時刻
］から`生成され$る可能性に対する用心である。
実装は、 60 秒では短か過ぎると予見される場合は，より大きい値を利用してもヨイ。
◎
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
</p>

				</section>
			</section>
			<section id="field.etag">
<h4>11.2.3. `Etag^h</h4>

<p>
応答~内の `ETag$h ~fieldは、要請の取扱いから結論に至った，［
`選定された表現$用の現在の `entity-tag$p
］を供する。
`entity-tag$p は、同じ`資源$による複数の`表現$を相違化するための，`不透明$な検証子である。
それら複数の表現が何に因るのか
—［
`資源$の状態が時間とともに変化したことによるのか，
`内容~折衝$により同~時に複数の表現が妥当になったことによるのか
］, あるいはこの両者によるのか —
に関わらず。
`entity-tag$p の主部は，引用符で括られた`不透明$な文字列（ `opaque-tag$p ）であり、`弱い検証子$であるときは，それを指示する `weak$p 接頭辞も付与される：
◎
The "ETag" field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request. An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
</p>

<pre class="bnf">
`ETag@p
    = `entity-tag$p

`entity-tag@p
    = [ `weak$p ] `opaque-tag$p
`weak@p
    = ~Ps"W/"
`opaque-tag@p
    = `DQUOTE$P *`etagc$p `DQUOTE$P
`etagc@p
    = `21^X
    / `23-7E^X
    / `obs-text$p
    ; <span class="comment">
`DQUOTE^P を除く `VCHAR^P, および `obs-text^p
◎
VCHAR except double quotes, plus obs-text
</span>
</pre>

<p class="note">注記：
`opaque-tag$p は、以前には
`quoted-string$p （ `RFC2616/3.11$sec ）として定義されていた。
そのため、受信者の中には，~backslash~escapeを~~解除しようとするものもある。
したがって，~serverは、
`entity-tag$p 内では~backslash文字を避ける~OUGHT。
◎
Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], Section 3.11); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.
</p>

<div class="p">
<p>
次のいずれかの状況では、
`entity-tag$p は，検証において`改変~日時$よりも依拠-可能になり得る：
◎
An entity-tag can be more reliable for validation than a modification date in situations＼
</p>
<ul>
	<li>
`改変~日時$を格納しにくい不都合がある。
◎
where it is inconvenient to store modification dates,＼
</li>
	<li>
~HTTP日時~値の秒単位の分解能では足らない。
◎
where the one-second resolution of HTTP date values is not sufficient, or＼
</li>
	<li>
`改変~日時$が一貫して保守されていない。
◎
where modification dates are not consistently maintained.
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre>
</div>

<p>
`entity-tag$p は、`弱い検証子$にも, `強い検証子$（これが既定）にも，なり得る。
`表現$に `entity-tag$p を供する`生成元~server$は、［
その代の `entity-tag$p が，`強い検証子$の特性すべてを満足する
］のではない場合には、
`entity-tag$p に `weak$p 接頭辞（ "`W/^c", 文字大小区別）を与えて，`弱い検証子$として~markしなければナラナイ。
◎
An entity-tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (Section 11.2.1), then the origin server MUST mark the entity-tag as weak by prefixing its opaque value with "W/" (case-sensitive).
</p>

<p>
送信者は、 `Etag^h ~fieldを`~trailer節$内に送信してもヨイ（ `5.6$sec を見よ）。
しかしながら，`~trailer$は無視されることが多いので、
`Etag^h は
— `entity-tag$p が~message本体の送信-中に生成されていない限り —
`~header$として送信する方が好ましい。
◎
A sender MAY send the Etag field in a trailer section (see Section 5.6). However, since trailers are often ignored, it is preferable to send Etag as a header field unless the entity-tag is generated while sending the message body.
</p>

				<section id="entity.tag.generation">
<h5 title="Generation">11.2.3.1. 生成</h5>

<div class="p">
<p>
`entity-tag$p の背後にある原理は、次の 2 点にある：
◎
The principle behind entity-tags is that＼
</p>
<ul>
	<li>
`資源$に対し最も正確aかつ効率的な検証の仕組みを選定するような，資源の実装を十分良く知るのは、~service作者のみである。
◎
only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that＼
</li>
	<li>
そのようなどの仕組みも、比較を容易にするために，単純な~octet列に対応付けれる。
◎
any such mechanism can be mapped to a simple sequence of octets for easy comparison.＼
</li>
</ul>

<p>
値は
`不透明@
なので、~clientは，各 `entity-tag$p がどう構築されたかを自覚する必要はない。
◎
Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed.
</p>
</div>

<p>
例えば、［
どの変化にも適用される，実装に特有な~version法
］を備える`資源$は、内部~改訂~番号を利用するかもしれない
— たぶん，互いの`表現$を正確aに相違化するため，`内容~折衝$用の変動~識別子と組合されるような。
［
表現~内容の耐衝突~hash ／
様々な~file属性の組合n ／
分解能が秒単位より細かい改変~時刻印
］を利用する実装もあり得る。
◎
For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.
</p>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
変化の検出を，適度かつ一貫するように決定できる
］ならば、
`ETag$h を送信するベキである
— `条件付き要請$における `entity-tag$p の利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する有意な要因になり得るので。
◎
An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([Caching]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability.
</p>

				</section>
				<section id="entity.tag.comparison">
<h5 title="Comparison">11.2.3.2. 比較</h5>

<p>
`entity-tag$p を比較するとき、その文脈において`弱い検証子$の利用が許容されるかどうかに依存して、次のいずれかの関数が用いられる：
◎
There are two entity-tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:
</p>

<dl>
	<dt>`強い比較~関数@</dt>
	<dd>
2 つの `entity-tag$p は、［
ともに`弱い検証子$でない, かつ
互いの `opaque-tag$p は各~文字ごとに合致する
］ならば，等価とされる。
◎
Strong comparison: two entity-tags are equivalent if both are not weak and their opaque-tags match character-by-character.
</dd>

	<dt>`弱い比較~関数@</dt>
	<dd>
2 つの `entity-tag$p は、`弱い$かどうかに関わらず，［
互いの `opaque-tag$p は各~文字ごとに合致する
］ならば，等価とされる。
◎
Weak comparison: two entity-tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as "weak".
</dd>
</dl>

<p>
各種［
2 つの `entity-tag$p
］例に対する，両~比較~関数の結果を下に示す:
◎
The example below shows the results for a set of entity-tag pairs and both the weak and strong comparison function results:
</p>

<div >
<table><thead><tr><td>`ETag$p （ 1 個目）
<td>`ETag^p （ 2 個目）
<td>`強い比較~関数$
<td>`弱い比較~関数$
</thead>

<tbody><tr><td>`W/"1"^c
<td>`W/"1"^c
<td>合致しない
<td>合致する

<tr><td>`W/"1"^c
<td>`W/"2"^c
<td>合致しない
<td>合致しない

<tr><td>`W/"1"^c
<td>`"1"^c
<td>合致しない
<td>合致する

<tr><td>`"1"^c
<td>`"1"^c
<td>合致する
<td>合致する

</tbody></table>
◎
Table 21
ETag 1 	ETag 2 	Strong Comparison 	Weak Comparison
W/"1" 	W/"1" 	no match 	match
W/"1" 	W/"2" 	no match 	no match
W/"1" 	"1" 	no match 	match
"1" 	"1" 	match 	match
</div>

				</section>
				<section id="example.entity.tag.vs.conneg">
<h5 title="Example: Entity-Tags Varying on Content-Negotiated Resources">11.2.3.3. 内容~折衝された資源により `entity-tag^p が様々になる例</h5>

<p>
`資源$が`内容~折衝の~subject$であって，
`GET$m 要請に対する応答~内に送信される`表現$が
`Accept-Encoding$h 要請~headerに基づいて様々になるときを考える。
◎
Consider a resource that is subject to content negotiation (Section 7.4), and where the representations sent in response to a GET request vary based on the Accept-Encoding request header field (Section 9.4.3):
</p>

<div class="example">
<p>
&gt;&gt; 要請：
◎
&gt;&gt; Request:
</p>

<pre class="lang-http">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
</pre>

<p>
この事例では、応答は
`gzip$c `内容~符号法$を利用するとき／しないときがあるとする。
利用しない場合の応答は、次の様な~~形になる：
◎
In this case, the response might or might not use the gzip content coding. If it does not, the response might look like:
</p>

<p>
&gt;&gt; 応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</pre>

<p>
代替~表現が `gzip^c `内容~符号法$を利用するときは：
◎
An alternative representation that does use gzip content coding would be:
</p>

<p>
&gt;&gt;
応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

`…~binary~data…^com
</pre>
</div>

<p class="note">注記：
`内容~符号法$は`表現~data$の~propertyであり、~cache更新や`範囲~要請$の間に競合が起きないようにするため、［
内容が符号化された`表現$,
されていない`表現$
］に対する`強い$ `entity-tag$p は，互いに別個なものになる。
対照的に，`転送~符号法$は、~message転送の間に限り適用されるので，別個な `entity-tag$p にはならない。
◎
Note: Content codings are a property of the representation data, so a strong entity-tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (Section 7 of [Messaging]) apply only during message transfer and do not result in distinct entity-tags.
</p>

				</section>
			</section>
			<section id="when.to.use.entity.tags.and.last-modified.dates">
<h4 title="When to Use Entity-Tags and Last-Modified Dates">11.2.4. `entity-tag^p と `Last-Modified^h  日時 をいつ利用するか</h4>

<p>
`GET$m ／ `HEAD$m に対し， `200$st で応答する`生成元~server$は：
◎
In 200 (OK) responses to GET or HEAD, an origin server:
</p>
<ul>
	<li>
`entity-tag$p 検証子を送信するベキである
— その生成-が~~困難でない限り。
◎
SHOULD send an entity-tag validator unless it is not feasible to generate one.
</li>
	<li>
`強い$ `entity-tag$p の代わりに `弱い$ `entity-tag$p を送信してもヨイ
— 処理能の~~観点から弱い `entity-tag$p の利用が~~支持される, あるいは
強い `entity-tag$p の送信が~~困難ならば。
◎
MAY send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag.
</li>
	<li>
`Last-Modified$h 値を送信するベキである
— その送信が~~困難でなければ。
◎
SHOULD send a Last-Modified value if it is feasible to send one.
</li>
</ul>

<p>
言い換えれば，`生成元~server$に選好される挙動は、検索取得~要請に対する成功裡な応答において，［
`強い$ `entity-tag$p, `Last-Modified$h 値
］の両者を送信することである。
◎
In other words, the preferred behavior for an origin server is to send both a strong entity-tag and a Last-Modified value in successful responses to a retrieval request.
</p>

<p>
`~client$は：
◎
A client:
</p>
<ul>
	<li>
`生成元~server$から `entity-tag$p が供されていた場合：
（ `If-Match$h ／ `If-None-Match$h を利用する）どの`~cache検証~要請$ 内にも，その `entity-tag$p を送信しなければナラナイ。
◎
MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server.
</li>
	<li>
`生成元~server$から `Last-Modified$h 値のみが供されていた場合：
（ `If-Modified-Since$h を利用する）非~部分範囲 `~cache検証~要請$ 内に，`Last-Modified$h 値を送信するベキである。
◎
SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
</li>
	<li>
~HTTP10`生成元~server$から `Last-Modified$h 値のみが供されていた場合：
（ `If-Unmodified-Since$h を利用する）部分範囲 `~cache検証~要請$ 内に
`Last-Modified$h 値を送信してもヨイ。
困難な事例【？】では、~UAは、これを不能化する仕方を供するベキである。
◎
MAY send the Last-Modified value in subrange cache validation requests (using If-Unmodified-Since) if only a Last-Modified value has been provided by an HTTP/1.0 origin server. The user agent SHOULD provide a way to disable this, in case of difficulty.
</li>
	<li>
`生成元~server$から［
`entity-tag$p, `Last-Modified$h 値
］の両者が供されていた場合：
`~cache検証~要請$ 内に，両~検証子とも送信するベキである。
これにより、［
~HTTP10, ~HTTP11
］~cacheのいずれも，適切に応答できるようになる。
◎
SHOULD send both validators in cache validation requests if both an entity-tag and a Last-Modified value have been provided by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.
</li>
</ul>

			</section>
		</section>
		<section id="response.auth">
<h3 title="Authentication Challenges">11.3. 認証~challenge</h3>

<p>
認証~challengeは、［
未来の要請において認証用の`資格証$を供する仕組みとして，~clientに可用になるもの
］を指示する
⇒＃
`WWW-Authenticate$h,
`Proxy-Authenticate$h
◎
Authentication challenges indicate what mechanisms are available for the client to provide authentication credentials in future requests.
◎
Table 22
Field Name 	Ref.
• WWW-Authenticate 	11.3.1
• Proxy-Authenticate 	11.3.2
</p>

<p>
さらに，次に挙げる応答~headerは、［
`~client$の認証`資格証$が受容されたなら，情報を返す必要がある
］ような`認証~scheme$の利用~用に定義される
⇒＃
`Authentication-Info$h,
`Proxy-Authentication-Info$h
◎
Furthermore, the "Authentication-Info" and "Proxy-Authentication-Info" response header fields are defined for use in authentication schemes that need to return information once the client's authentication credentials have been accepted.
◎
Table 23
Field Name 	Ref.
Authentication-Info 	11.3.3
Proxy-Authentication-Info 	11.3.4
</p>

			<section id="field.www-authenticate">
<h4>11.3.1. `WWW-Authenticate^h</h4>

<p>
`WWW-Authenticate^h ~headerは、`~target資源$に適用-可能な［
`認証~scheme$たち, および
`認証~parameter$たち
］を指示する。
◎
The "WWW-Authenticate" header field indicates the authentication scheme(s) and parameters applicable to the target resource.
</p>

<pre class="bnf">
`WWW-Authenticate@p
    = #`challenge$p
</pre>

<p>
`401$st 応答を`生成する$`~server$は、［
 1 個~以上の `challenge$p を包含する，
`WWW-Authenticate$h ~header
］を送信しなければナラナイ。
~serverは、他の応答~message内にも，
`WWW-Authenticate$h ~headerを`生成し$てもヨイ
— 【後の要請に】 `資格証$（または異なる`資格証$）を給することが，対する応答に影響し得ることを指示するために。
◎
A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge. A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.
</p>

<p>
応答を回送している`~proxy$は、その応答~内のどの
`WWW-Authenticate$h ~fieldも，改変してはナラナイ。
◎
A proxy forwarding a response MUST NOT modify any WWW-Authenticate fields in that response.
</p>

<p>
`~UA$には、`~field値$を構文解析するときに，特別に~careすることを~~勧める
— それは，複数個の `challenge$p を包含するかもしれず、各 `challenge$p も，何個かの`認証~parameter$からなる~comma区切りの~listを包含し得るので。
更には、~header自体も複数~回 生じ得る。
◎
User agents are advised to take special care in parsing the field value, as it might contain more than one challenge, and each challenge can contain a comma-separated list of authentication parameters. Furthermore, the header field itself can occur multiple times.
</p>

<div class="example">
<p>
一例として：
◎
For instance:
</p>

<pre class="lang-http">
WWW-Authenticate: Newauth realm="apps", type=1, title="Login to \"apps\"", Basic realm="simple"
</pre>

<div class="p">
<p>
この~headerは、 2 個の `challenge$p を包含する：
◎
This header field contains two challenges;＼
</p>
<ul>
	<li>
`Newauth^c ~scheme用の `realm$c 値 "`apps^c" を伴い，追加的な~parameter `type^c, `title^c も伴うもの。
◎
one for the "Newauth" scheme with a realm value of "apps", and two additional parameters "type" and "title", and＼
</li>
	<li>
`Basic^c ~scheme用の `realm$c 値 "`simple^c" を伴うもの。
◎
another one for the "Basic" scheme with a realm value of "simple".
</li>
</ul>
</div>
</div>

<p>
しかしながら、一部の~UAは，この形を認識しない。
結果として，
`WWW-Authenticate^h の`~field値$を同じ`~field行l$に複数個の~memberを伴わせて送信するのは、相互運用可能にならないかもしれない。
◎
Some user agents do not recognise this form, however. As a result, sending a WWW-Authenticate field value with more than one member on the same field line might not be interoperable.
</p>

<p class="note">注記：
`challenge$p 文法~生成規則も~list構文を利用する。
したがって、［
~comma, 空白, ~comma
］の並びは、［
先行している `challenge$p に適用するもの
］としても, あるいは［
`challenge$p の~listにおける，空~entry
］にも，見なし得る。
この多義性は、実施においては 当の~headerの`~field値$の意味論には影響しないので，無害である。
◎
Note: The challenge grammar production uses the list syntax as well. Therefore, a sequence of comma, whitespace, and comma can be considered either as applying to the preceding challenge, or to be an empty entry in the list of challenges. In practice, this ambiguity does not affect the semantics of the header field value and thus is harmless.
</p>

			</section>
			<section id="field.proxy-authenticate">
<h4>11.3.2. `Proxy-Authenticate^h</h4>

<p>
`Proxy-Authenticate^h ~headerは、
1 個~以上の `challenge$p からなる
— 各 `challenge^p は、【！＊】この要請~用に`~proxy$に適用-可能な［
`認証~scheme$, `認証~parameter$たち
］を指示する。
`~proxy$は、自身が`生成する$各 `407$st 応答~内に，
1 個~以上の `Proxy-Authenticate$h ~headerを送信しなければナラナイ。
◎
The "Proxy-Authenticate" header field consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this request. A proxy MUST send at least one Proxy-Authenticate header field in each 407 (Proxy Authentication Required) response that it generates.
</p>

<pre class="bnf">
`Proxy-Authenticate@p
    = #`challenge$p
</pre>

<p>
`WWW-Authenticate$h とは違って，
`Proxy-Authenticate$h ~headerは、［
応答`連鎖$の`外方$にある次の`~client$
］のみに適用される
— 当の`~proxy$を選んだ`~client$のみが，認証に必要とされる`資格証$を持つ見込みが高いので。
しかしながら、同じ管轄の中で複数の`~proxy$が利用されるとき
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
`~UA$により`生成され$た`資格証$が，消費されるまで階層を通過することは、共通的にある。
よって，そのような環境設定では、各~proxyは同じ `challenge$p 集合を送信することになり， `Proxy-Authenticate$h が回送されているかのように出現することになる。
◎
Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authenticate is being forwarded because each proxy will send the same challenge set.
</p>

<p>注記：
`WWW-Authenticate$h ~headerの構文解析についての考慮点は、この~fieldにも適用される。
◎
Note that the parsing considerations for WWW-Authenticate apply to this header field as well; see Section 11.3.1 for details.
</p>

			</section>
			<section id="field.authentication-info">
<h4>11.3.3. `Authentication-Info^h</h4>

<p>
~HTTP`認証~scheme$では、`~client$の認証`資格証$が受容された後に，
`Authentication-Info^h 応答~headerを利用して情報を通信できる。
この情報は~serverからの【認証の】完結~messageを内包し得る（例：~server認証を包含し得る）。
◎
HTTP authentication schemes can use the Authentication-Info response header field to communicate information after the client's authentication credentials have been accepted. This information can include a finalization message from the server (e.g., it can contain the server authentication).
</p>

<p>
その`~field値$は、 `auth-param$p 構文を利用する，一連の［
~parameter（名前, 値が成す~pair）
］からなる~listである。
この仕様は、汎用な形式のみを述べる
— 個々の~parameterは、 `Authentication-Info^h を利用している`認証~scheme$が定義することになる。
一例として、 `Digest^c 認証~schemeは， `RFC7616/3.5$sec にて複数の~parameterを定義する。
◎
The field value is a list of parameters (name/value pairs), using the "auth-param" syntax defined in Section 9.5.1. This specification only describes the generic format; authentication schemes using Authentication-Info will define the individual parameters. The "Digest" Authentication Scheme, for instance, defines multiple parameters in Section 3.5 of [RFC7616].
</p>

<pre class="bnf">
`Authentication-Info@p
    = #`auth-param$p
</pre>

<p>
`Authentication-Info^h ~headerは、`要請~method$や`状態s~code$から独立に，どの~HTTP応答にも利用できる。
その意味論は、［
対応する要請の `Authorization$h ~headerにより指示される，`認証~scheme$
］により定義される。
◎
The Authentication-Info header field can be used in any HTTP response, independently of request method and status code. Its semantics are defined by the authentication scheme indicated by the Authorization header field (Section 9.5.3) of the corresponding request.
</p>

<p>
応答を回送している`~proxy$には、どの仕方であろうと，`~field値$を改変することは許容されない。
◎
A proxy forwarding a response is not allowed to modify the field value in any way.
</p>

<p>
`Authentication-Info^h は、`認証~scheme$が明示的に許容するときには，`~trailer$として送信され得る（ `5.6$sec ）。
◎
Authentication-Info can be sent as a trailer field (Section 5.6) when the authentication scheme explicitly allows this.
</p>

				<section id="n-parameter-value-format">
<h5 title="Parameter Value Format">11.3.3.1. ~parameter値の形式</h5>

<p>
~parameterの値は、 "`token$p" としても "`quoted-string$p" としても表出できる。
◎
Parameter values can be expressed either as "token" or as "quoted-string" (Section 5.4.1).
</p>

<p>
`認証~scheme$定義は、［
`送信者$, `受信者$
］の両者に，両~表記法を許容する必要がある。
これにより，受信者は、利用~中の認証~schemeとは独立に，汎用な構文解析~componentを利用できるようになる。
◎
Authentication scheme definitions need to allow both notations, both for senders and recipients. This allows recipients to use generic parsing components, independent of the authentication scheme in use.
</p>

<p>
後方-互換性のため、認証~scheme定義は，送信者~用の形式を 2 つの変種の片方に制約できる。
これは、［
配備された実装が、他方の形式に遭遇したときは失敗する
］ことが既知であるとき，重要になり得る。
◎
For backwards compatibility, authentication scheme definitions can restrict the format for senders to one of the two variants. This can be important when it is known that deployed implementations will fail when encountering one of the two formats.
</p>

				</section>
			</section>
			<section id="field.proxy-authentication-info">
<h4>11.3.4. `Proxy-Authentication-Info^h</h4>

<p>
`Proxy-Authentication-Info^h 応答~headerは、［
~proxy認証（ `9.5.1$sec ）に適用されること
］, および［
その意味論は、対応する要請の `Proxy-Authorization$h ~headerに指示される`認証~scheme$により定義されること
］を除き， `Authentication-Info$h に等価である：
◎
The Proxy-Authentication-Info response header field is equivalent to Authentication-Info, except that it applies to proxy authentication (Section 9.5.1) and its semantics are defined by the authentication scheme indicated by the Proxy-Authorization header field (Section 9.5.4) of the corresponding request:
</p>

<pre class="bnf">
`Proxy-Authentication-Info@p
    = #`auth-param$p
</pre>

<p>
しかしながら， `Authentication-Info$h と違って、
`Proxy-Authentication-Info^h ~headerが適用されるのは，応答`連鎖$上の`外方$にある次の`~client$に限られる。
何故なら、認証に必要とされる`資格証$を有するのは，所与の`~proxy$を選んだ~clientに限られる見込みが高いので。
しかしながら，同じ管轄の中で複数の~proxyが利用されるとき
— 巨大~企業~networkの中の，各~~部署の~caching~proxyなど —
`~UA$により`生成され$た資格証が，消費されるまで階層を通過することは、共通的にある。
よって，そのような環境設定においては、各~proxyが同じ`~field値$を送信するため，
`Proxy-Authentication-Info^h が回送されているかのように出現することになる。
◎
However, unlike Authentication-Info, the Proxy-Authentication-Info header field applies only to the next outbound client on the response chain. This is because only the client that chose a given proxy is likely to have the credentials necessary for authentication. However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed. Hence, in such a configuration, it will appear as if Proxy-Authentication-Info is being forwarded because each proxy will send the same field value.
</p>

			</section>
		</section>
		<section id="response.context">
<h3 title="Response Context">11.4. 応答~文脈</h3>

<p>
残りの`応答~header$は、今後の要請にあり得る利用のために，［
`~target資源$についての更なる情報
］を供する
⇒＃
`Accept-Ranges$h,
`Allow$h,
`Server$h
◎
The remaining response header fields provide more information about the target resource for potential use in later requests.
◎
Table 24
• Field Name 	Ref.
• Accept-Ranges 	11.4.1
• Allow 	11.4.2
• Server 	11.4.3
</p>

			<section id="field.accept-ranges">
<h4>11.4.1. `Accept-Ranges^h</h4>

<p>
`Accept-Ranges$h ~headerにより、`~server$は，［
`~target資源$に対する`範囲~要請$を~supportする
］ことを指示できるようになる。
◎
The "Accept-Ranges" header field allows a server to indicate that it supports range requests for the target resource.
</p>

<pre class="bnf">
`Accept-Ranges@p
    = `acceptable-ranges$p
`acceptable-ranges@p
    = 1#`range-unit$p
    / "`none$c"
</pre>

<p>
`生成元~server$は、所与の`~target資源$に対する`~byte範囲$の要請を~supportするならば、~supportする`範囲~単位$を指示するために，次を送信してもヨイ：
◎
An origin server that supports byte-range requests for a given target resource MAY send
</p>

<pre class="lang-http">
Accept-Ranges: bytes
</pre>

<p>
`~client$は、この~headerを受信していなくても，当の資源に対し `範囲~要請$を`生成し$てもヨイ。
◎
to indicate what range units are supported. A client MAY generate range requests without having received this header field for the resource involved. Range units are defined in Section 7.1.4.
</p>

<p>
`~target資源$に対し，いかなる`範囲~要請$も~supportしない`~server$は、
"`none@c"
を送信してもヨイ：
◎
A server that does not support any kind of range request for the target resource MAY send
</p>

<pre class="lang-http">
Accept-Ranges: none
</pre>

<p>
これは、範囲~要請を試みないよう，~clientに通告する。
◎
to advise the client not to attempt a range request.
</p>

			</section>
			<section id="field.allow">
<h4>11.4.2. `Allow^h</h4>

<p>
`Allow^h ~headerは、［
`~target資源$が~supportするものとして広告される，~methodの集合
］を~listする。
この~fieldの目的は、［
資源に結付けられている妥当な`要請~method$
］を，`受信者$に厳密に伝えることである。
◎
The "Allow" header field lists the set of methods advertised as supported by the target resource. The purpose of this field is strictly to inform the recipient of valid request methods associated with the resource.
</p>

<pre class="bnf">
`Allow@p
    = #`method$p
</pre>

<div class="example">
<p>
利用~例：
◎
Example of use:
</p>

<pre class="lang-http">
Allow: GET, HEAD, PUT
</pre>
</div>

<p>
許容される~methodの実際の集合は、各~要請の時点で，`生成元~server$により定義される。
`生成元~server$は、 `405$st 応答~内には， `Allow^h ~fieldを`生成し$なければナラナイ。
また、他のどの応答~内にも`生成し$てもヨイ。
値が空な `Allow^h ~fieldは、［
資源がどの~methodも許容しない
］ことを指示する
— それは、［
資源が環境設定により一時的に不能化されている
］場合に `405$st0 応答~内に生じ得る。
◎
The actual set of allowed methods is defined by the origin server at the time of each request. An origin server MUST generate an Allow field in a 405 (Method Not Allowed) response and MAY do so in any other response. An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration.
</p>

<p>
`~proxy$は、 `Allow^h ~fieldを改変してはナラナイ
— 汎用~message取扱い規則に則って取扱うときは、値の中に指示された すべての~methodを解する必要はない。
◎
A proxy MUST NOT modify the Allow header field — it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.
</p>

			</section>
			<section id="field.server">
<h4>11.4.3. `Server^h</h4>

<div class="p">
<p>
`Server^h ~headerは、［
`生成元~server$が，要請を取扱うために利用している~software
］についての情報を包含する
— それは、次のために，~clientに利用されることが多い：
◎
The "Server" header field contains information about the software used by the origin server to handle the request, which is often used by clients＼
</p>
<ul>
	<li>
報告された相互運用能の問題の視野を絞るための補助。
◎
to help identify the scope of reported interoperability problems,＼
</li>
	<li>
特定0の~server制限を避けるために，対処する／要請を仕立上げる
◎
to work around or tailor requests to avoid particular server limitations, and＼
</li>
	<li>
［
~server／~OS
］の利用に関する分析。
◎
for analytics regarding server or operating system use.＼
</li>
</ul>

<p>
`生成元~server$は、自身の応答~内に `Server^h ~fieldを`生成し$てもヨイ。
◎
An origin server MAY generate a Server field in its responses.
</p>
</div>

<pre class="bnf">
`Server@p
    = `product$p *( `RWS$p ( `product$p / `comment$p ) )
</pre>

<p>
`Server^h `~field値$は、 1 個~以上の［
`製品~識別子$と,
後続する 0 個以上の `comment$p
］からなる。
それらは組で，［
生成元~server~software, および その有意な下位製品
］を識別する。
慣行により，製品~識別子は、生成元~server~softwareを識別するために［
それらの有意度の降順
］で~listされる。
各 `製品~識別子$は、それに定義されるように，名前, および~version（省略可）からなる。
◎
The Server field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.4.1.3), which together identify the origin server software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the origin server software. Each product identifier consists of a name and optional version, as defined in Section 9.6.3.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>

<pre class="lang-http">
Server: CERN/3.0 libwww/2.17
</pre>
</div>

<p>
`生成元~server$は、［
不必要に木目細かな詳細を包含する `Server^h ~field
］を`生成する$ベキでない。
また、［
第三者主体による下位製品の追加
］を制限するベキである。
~~過度に長く詳細な `Server^h `~field値$は、応答の待時間を増やす。
また，内部~実装の詳細を露呈する~~可能性もあるので、攻撃者にとっては，（少しばかり）既知な~securityの穴を見出して悪用し易くなる。
◎
An origin server SHOULD NOT generate a Server field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties. Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.
</p>

			</section>
		</section>
	</section>
</main></div>
