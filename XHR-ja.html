<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>XMLHttpRequest Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
.critical {
    margin: 1em;
    border: thick double #F00;
    padding: 1em;
    background: none repeat scroll 0% 0% #FFC;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = () => {
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'lb':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:XMLHttpRequest
spec_date:2020-08-18
trans_update:2020-08-28
source_checked:181001
original_url:https://xhr.spec.whatwg.org/
spec_status:LS
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,storage,security
copyright:,whatwg
trans_1st_pub:2012-10-25


●●class_map
e:element
a:attr
et:event-type
E:error
sc:scheme
AO:abstract
hm:method
X:hex-value

●●tag_map
I:code
m:code
mb:code
c:code
e:code
a:code
et:code
E:code
hm:code
v:var
i:i
AO:span
X:span

●●words_table1

open_async:open
type0:type
send:<code>send()</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code>

●●words_table

	●データ／型／IDL／演算
arraybuffer::::配列バッファ
blob:
scalar::::スカラー
chunk::::チャンク

数-:numeric:~
昇順:ascending order:~


	●構文
	MIME:mime
backtick::::バッククォート
予走査:prescan::~
charset:
	charset:::文字集合:文字セット
確定的:definite:~
名前空間整形式:namespace well formedness:名前空間 整形式
	settings object

	●一般処理／event
	発火-法:firing

進行中の:ongoing:~
終了-:terminate::~
時間切れ:timed out::~
	時間~切れ:preset time expiring
時間:time:~
経過-:pass:~
省略可:optional:~
	＊optional:::オプション
	-:fallback

	●状態値
unsent:
opened:
headers-received:headers received
loading:
done:

	●XHR／network
予行:preflight::~::プリフライト
伝送量:transmitted::~
本体終端:end-of-body:body 終端:~::ボディ終端
username::::ユーザ名
password::::パスワード
活動:activity::~
非安全:unsafe::~
結合-:combine::~
	結合-済み:combined
最終:final::~
filename:::file 名:ファイル名
内容型:content type::~
開いて:openして::~
	load:::
読取る:readする::読み取る
読取:read::読み取り
読取器:reader::読み取り器::リーダ

	headers::::ヘッダリスト
	~network用:networking
	受信-済み:received
	伝送-済み:transmitted

	●仕様
opt-in::::オプトイン
末端利用者:end user:~:::エンドユーザ
節:section:~
要覧:summary:~
中止:aborted::~
	中止-済み:aborted
壊さな:breakしな:~
移管-:move:~
併合-:merge:~
観点:perspective:~
	experiment
過程:process:~
警告-:warn:~
許容list:allowlist:許容 list::許容リスト
精巧:elaborate:~

	typographic
	specification
	旧来のものでない:non-legacy
	施策により制御され:policy-controlled
	~~機能:working
	用例:example
	自由:free
	引用:
	当初:
	成果:
	関心のある主体:interested parties
	固有の仔細:specific scenarios
	何の効果もない:has no effect

	全般:Throughout
	不具合が生じた:went wrong
	間違った:wrong
	~~互換性
	調べる:check
	~~調整:tune
	~~問題に馴染みのある人達の意見を汲む:ensure input from people familiar with the subject
	何年も:many years
	メーリングリスト
	リンク付きで:cross-linked
	一覧:table
	可能
	同様
	同類
	経緯
	~~規定:set forth

	●未分類（動詞
割振る:allocateする:割り振る
絞込まれ:filterされ::絞り込まれ
	interaction
集める:gatherする:~
	壊-:breaking
露呈-:reveal:~
	追従-済:have been followed
	過ぎた:passed
	対応
	得る:yield
	出現
	進行:be ongoing
	開始:start, initiate, begin:

	●未分類

担当の:responsible::~

排他的:mutually exclusive:~
	-:relative
	-:variable
milli::::ミリ
	ミリ秒:millisecond
	単位/数
	括弧内
	単位
	範囲:range
	計測:measure
	際限のない:infinite

	●指示語
	無
	〜の後:after
	一連
	一部
	以下
	以上
	各種
	唯一
	全体:
	回
	個
	時点
	最終的
	時機:when
	回数:times
	場合
	重ねて:twice
	非:non


●●original_id_map

dom-formdata-iterable:
	handle-response-end-of-body:handle-response-end-of-file

●●mdn_urls
formdata:API/FormData
formdataentryvalue:API/FormDataEntryValue
progressevent:API/ProgressEvent
xmlhttprequest:API/XMLHttpRequest
xmlhttprequesteventtarget:API/XMLHttpRequestEventTarget
xmlhttprequestresponsetype:API/XMLHttpRequestResponseType
	xmlhttprequestupload:API/XMLHttpRequestUpload
	progresseventinit:API/ProgressEventInit

event-xhr-abort:API/XMLHttpRequest/abort_event
event-xhr-error:API/XMLHttpRequest/error_event
event-xhr-load:API/XMLHttpRequest/load_event
event-xhr-loadend:API/XMLHttpRequest/loadend_event
event-xhr-loadstart:API/XMLHttpRequest/loadstart_event
event-xhr-progress:API/XMLHttpRequest/progress_event
event-xhr-timeout:API/XMLHttpRequest/timeout_event
	event-xhr-readystatechange:API/？/readystatechange_event

●●link_map



Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject

E.AbortError:~WEBIDL#aborterror
E.SyntaxError:~WEBIDL#syntaxerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TimeoutError:~WEBIDL#timeouterror
E.NetworkError:~WEBIDL#networkerror

USVString:~WEBIDL#idl-USVString
I.USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
DOMString:~WEBIDL#idl-DOMString
undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
unsigned long long:~WEBIDL#idl-unsigned-long-long

I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.FormData:#formdata
I.FormDataEntryValue:#formdataentryvalue
I.ProgressEvent:#progressevent
I.ProgressEventInit:#progresseventinit
I.XMLHttpRequest:#xmlhttprequest
I.XMLHttpRequestEventTarget:#xmlhttprequesteventtarget
I.XMLHttpRequestResponseType:#xmlhttprequestresponsetype
I.XMLHttpRequestUpload:#xmlhttprequestupload
I.XMLHttpRequestBodyInit:~FETCH#typedefdef-xmlhttprequestbodyinit
I.Window:~WINDOW#window
I.HTMLFormElement:~HEforms#htmlformelement


I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array


m.new XMLHttpRequest:#dom-xmlhttprequest
m.new FormData:#dom-formdata
mc.ProgressEvent:#dom-progressevent-progressevent
m.ProgressEvent:#dom-progressevent-progressevent

m.DONE:#dom-xmlhttprequest-done
m.HEADERS_RECEIVED:#dom-xmlhttprequest-headers_received
m.LOADING:#dom-xmlhttprequest-loading
m.OPENED:#dom-xmlhttprequest-opened
m.UNSENT:#dom-xmlhttprequest-unsent

m.onabort:#handler-xhr-ononabort
m.onerror:#handler-xhr-ononerror
m.onload:#handler-xhr-ononload
m.onloadend:#handler-xhr-ononloadend
m.onloadstart:#handler-xhr-ononloadstart
m.onprogress:#handler-xhr-ononprogress
m.onreadystatechange:#handler-xhr-ononreadystatechange
m.ontimeout:#handler-xhr-onontimeout

m.abort:#dom-xmlhttprequest-abort
m.timeout:#dom-xmlhttprequest-timeout
m.type:~DOM4#dom-event-type
m.~type0:~FILEAPI#dfn-type
m.append:#dom-formdata-append
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.delete:#dom-formdata-delete
m.get:#dom-formdata-get
m.getAll:#dom-formdata-getall
m.getAllResponseHeaders:#dom-xmlhttprequest-getallresponseheaders
m.getResponseHeader:#dom-xmlhttprequest-getresponseheader
m.has:#dom-formdata-has
m.iterable:#dom-formdata-iterable
m.lengthComputable:#dom-progressevent-lengthcomputable
m.loaded:#dom-progressevent-loaded
m.name:~FILEAPI#dfn-name
m.open:#dom-xmlhttprequest-open
m.~open_async:#dom-xmlhttprequest-open-method-url-async-username-password
m.overrideMimeType:#dom-xmlhttprequest-overridemimetype
m.readyState:#dom-xmlhttprequest-readystate
m.response:#dom-xmlhttprequest-response
m.responseText:#dom-xmlhttprequest-responsetext
m.responseType:#dom-xmlhttprequest-responsetype
m.responseURL:#dom-xmlhttprequest-responseurl
m.responseXML:#dom-xmlhttprequest-responsexml
m.send:#dom-xmlhttprequest-send
m.set:#dom-formdata-set
m.setRequestHeader:#dom-xmlhttprequest-setrequestheader
m.status:#dom-xmlhttprequest-status
m.statusText:#dom-xmlhttprequest-statustext
m.total:#dom-progressevent-total
m.upload:#dom-xmlhttprequest-upload
m.withCredentials:#dom-xmlhttprequest-withcredentials

mb.lengthComputable:#dom-progresseventinit-lengthcomputable
mb.loaded:#dom-progresseventinit-loaded
mb.total:#dom-progresseventinit-total

	l.#dom-xmlhttprequestresponsetype
l.arraybuffer:#dom-xmlhttprequestresponsetype-arraybuffer
l.blob:#dom-xmlhttprequestresponsetype-blob
l.document:#dom-xmlhttprequestresponsetype-document
l.json:#dom-xmlhttprequestresponsetype-json
l.text:#dom-xmlhttprequestresponsetype-text

l.sync-xhr:#sync-xhr

et.abort:#event-xhr-abort
et.progress:#event-xhr-progress
et.error:#event-xhr-error
et.load:#event-xhr-load
et.loadend:#event-xhr-loadend
et.loadstart:#event-xhr-loadstart
et.readystatechange:#event-xhr-readystatechange
et.timeout:#event-xhr-timeout

e.progress:~HEforms#the-progress-element

h.Content-Type:~HTTPsem#field.content-type
hm.GET:~HTTPrq#GET
hm.HEAD:~HTTPrq#HEAD

	XHR obj prop:
要請~method:#request-method
要請~URL:#request-url
作者~要請~header~list:#author-request-headers
要請~本体:#request-body
同期~flag:#synchronous-flag
~upload完了-~flag:#upload-complete-flag
~upload~listener~flag:#upload-listener-flag
時間切れ~flag:#timed-out-flag
応答~obj:#response-object
応答:#response
要請:#request
受信した~byte列:#received-bytes


応答~MIME型:#response-mime-type
上書き~MIME型:#override-mime-type
最終~MIME型:#final-mime-type
上書き~charset:#override-charset
最終~charset:#final-charset

~JSON応答:#json-response
~arraybuffer応答:#arraybuffer-response
~blob応答:#blob-response
文書~応答:#document-response
~text応答:#text-response

進捗~eventを発火する:#concept-event-fire-progress

fe.~entry~list:#concept-formdata-entry-list
fe.~entry:#concept-formdata-entry
fe.名前:#concept-formdata-entry-name
fe.値:#concept-formdata-entry-value
~entryを作成する:#create-an-entry

要請~error手続きを走らす:#request-error-steps
~errorを取扱う:#handle-errors
本体終端を取扱う:#handle-response-end-of-body

~upload~obj:#_concept-xmlhttprequest-upload-object
状態:#concept-xmlhttprequest-state
~send~flag:#send-flag

	＊:#legacy-uppercased-byte-less-than

	●用語（外部
応答を処理する:~FETCH#process-response
要請の本体を処理する:~FETCH#process-request-body
要請の本体終端を処理する:~FETCH#process-request-end-of-body

RS.読取器を取得する:~FETCH#concept-get-reader
RS.すべての~byte列を読取る:~FETCH#concept-read-all-bytes-from-readablestream
RS.~chunkを読取る:~FETCH#concept-read-chunk-from-readablestream

~CORS予行~要請:~FETCH#cors-preflight-request

~fetchを終了-:~FETCH#concept-fetch-terminate
~fetchを終了させる:~FETCH#concept-fetch-terminate
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
本体と内容~型を抽出する:~FETCH#concept-bodyinit-extract
~header~listから~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
~method:~FETCH#concept-method
禁止~method:~FETCH#forbidden-method
禁止~header名:~FETCH#forbidden-header-name
hd.名前:~FETCH#concept-header-name
hd.値:~FETCH#concept-header-value
値を正規化する:~FETCH#concept-header-value-normalize
~header~listから値を取得する:~FETCH#concept-header-list-get
~header:~FETCH#concept-header
~header~list:~FETCH#concept-header-list
~headerを設定する:~FETCH#concept-header-list-set
~headerを付加する:~FETCH#concept-header-list-append
~headerを結合する:~FETCH#concept-header-list-combine
~header~listを~sortして結合する:~FETCH#concept-header-list-sort-and-combine
~network~error:~FETCH#concept-network-error
~methodを正規化する:~FETCH#concept-method-normalize

rq.要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.本体:~FETCH#concept-request-body
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.生成元:~FETCH#concept-request-origin
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.同期~flag:~FETCH#synchronous-flag
rq.非安全~要請~flag:~FETCH#unsafe-request-flag
rq.~CORS予行~利用~flag:~FETCH#use-cors-preflight-flag
rq.~done~flag:~FETCH#done-flag

rs.中止~flag:~FETCH#concept-response-aborted
rs.応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.状態s~message:~FETCH#concept-response-status-message

名前に持つ~header:~FETCH#_headers-of-name
	#header-list-contains
~CORS~protocol:~FETCH#cors-protocol
~stream:~FETCH#concept-body-stream
伝送-済み~byte数:~FETCH#concept-body-transmitted
総~byte数:~FETCH#concept-body-total-bytes
~errorした:~FETCH#concept-readablestream-errored
資格証:~FETCH#credentials

~byte文字大小無視:~INFRA#byte-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
~byte列を~JSONとして構文解析する:~INFRA#parse-json-from-bytes
~byte大文字~化する:~INFRA#byte-uppercase
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
小なり~algo:~INFRA#_less-than-algorithm
未満の~byte列:~INFRA#byte-less-than

~list:~INFRA#list
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
置換する:~INFRA#list-replace
~scalar値~文字列に変換する:~INFRA#javascript-string-convert

~event:~DOM4#concept-event
~event~listener:~DOM4#concept-event-listener
~eventを発火する:~DOM4#concept-event-fire
内容型:~DOM4#concept-document-content-type
~URL:~DOM4#concept-document-url
投出:~DOM4#concept-throw
配送-:~DOM4#concept-event-dispatch
符号化法:~DOM4#concept-document-encoding
文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
doc.種別:~DOM4#concept-document-type
doc.生成元:~DOM4#concept-document-origin

~UTF-8:~ENCODING#utf-8
~UTF-8符号化-:~ENCODING#utf-8-encode
~UTF-8符号化する:~ENCODING#utf-8-encode
~error:~ENCODING#error
~Unicodeに復号する:~ENCODING#decode
~labelから符号化法を取得する:~ENCODING#concept-encoding-get

反復される値~pairたち:~WEBIDL#dfn-value-pairs-to-iterate-over
~interface~obj:~WEBIDLjs#dfn-interface-object

~URLを直列化する:~URL1#concept-url-serializer
~URL構文解析する:~URL1#concept-url-parser
~host:~URL1#concept-url-host
	~username:~URL1#concept-url-username
	~password:~URL1#concept-url-password
	I.URL:~URL1#url
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
資格証を含む:~URL1#include-credentials

	HTML

特能の利用は許容されて:~HEembed#allowed-to-use

enV.生成元:~WAPI#concept-settings-object-origin
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
~event~handler:~WAPI#event-handlers
~event~handler ~event型:~WAPI#event-handler-event-type
~network用~task源:~WAPI#networking-task-source
関連な設定群~obj:~WAPI#relevant-settings-object-for-a-global-object
enV.担当の文書:~WAPI#responsible-document
enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding
現在の大域~obj:~WAPI#current-global-object

全部的に作動中:~BROWSERS#fully-active
生成元:~ORIGIN#origin
同一-生成元:~ORIGIN#same-origin
~entry~listを構築する:~HTMLforms#constructing-the-form-data-set
並列的:~HTMLINFRA#in-parallel

施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature
既定の許容list:~PERMISSIONS-POLICY#default-allowlist

~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type
~byte列から~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type-from-bytes
~MIME型を~byte列に直列化する:~MIMESNIFF#serialize-a-mime-type-to-bytes
~parameter~map:~MIMESNIFF#parameters

素片を直列化する:~DOM-Parsing#dfn-fragment-serializing-algorithm


●●ref_normative

[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[DOMPS]
    Travis Leithead. DOM Parsing and Serialization. URL: https://w3c.github.io/DOM-Parsing/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.es/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FEATURE-POLICY]
    Ian Clelland. Permissions Policy. URL: https://w3c.github.io/webappsec-permissions-policy/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FILEAPI]
    Marijn Kruisselbrink; Arun Ranganathan. File API. URL: https://w3c.github.io/FileAPI/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Boris Zbarsky. Web IDL. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml/ 
[XMLNS]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names/ 

●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.whatwg.org/">WHATWG</a>
による
<a href="~SPEC_URL">XMLHttpRequest Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/xhr">GitHub whatwg/xhr</a> (<a href="https://github.com/whatwg/xhr/issues/new">new issue</a>, <a href="https://github.com/whatwg/xhr/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	https://github.com/whatwg/xhr/commits
	<a href="https://xhr.spec.whatwg.org/commit-snapshots/59eb1d90783e6e170da624bdb9bb37d9c61b55ca/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/xhrstandard">@xhrstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/xhr">web-platform-tests xhr/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/xhr">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>

<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgc3Ryb2tlLXdpZHRoPSIxMCIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgZD0iTTE3LDY2QzIxLDYzLDQzLDc2LDM3LDY4TTMzLDc1YTgsOCwwLDAsMTYsOE01MCw4NEM2OCw0OSw1Nyw5MCw2Myw3Nyw2Niw1OCw3NSw4Nyw3MSw2OSw2OCw2Miw3NCw2NSw3OCw2Nk02NSw2MkM1Nyw2NCw2NCw3MSw2Nyw2NE00Nyw2MEw0Myw2OSw0NCw2OSw1MSw2Nk01MCw1MkM0Nyw2MCw1Myw1NCw1Miw2MCw1MCw2OCw2Miw2MCw1Nyw2Miw1OCw1NCw2NSw2MCw1OSw1NCw0OCw0MiwyMCwyNSwyOSwzN00yOSw0MEMyMyw1MCwyNyw0NywyOSw0OE0zMywzN0MyOCw0MiwzNywzOCwzNSw0MiwzNCw0NCwzMCwzOCwzMiw0OCwzMSw1MCwzNiw1MiwyOCw1ME0zMiw1M0wyOCw1Mk0zMCw1M0MyOCw1NSwyNSw1NywzMCw2MSwzMiw2MiwzMiw2NSwzOCw2Miw0MCw2MSw0Myw2Myw0NCw1Nyw0NCw1Niw0OCw1Miw0NCw0OEw0NSw0NSw0MSw0Miw0MCw0Myw0MSw0NywzOSw1MCwzNSw1MU0zMiwzMUM0MywzMCw1MCwxNiw2NCwyM000MywzN0M1NCwyOCw0OSw1Niw2OSw0OCw4Miw0MCw3OCwyMSw2OCwyMEw2OCwyNkM3MiwyOSw3MiwyOSw3MiwzMyIvPgo8L3N2Zz4K"
></a>
	<hgroup>
<h1 id="title">XMLHttpRequest</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
XMLHttpRequest Standard は、~clientと~server間の~data転送~用の，~client側の~script機能性を供する~APIを定義する。
◎
The XMLHttpRequest Standard defines an API that provides scripted client functionality for transferring data between a client and a server.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`XMLHttpRequest$I ~objは、`~fetching$（~~資源取得）用の~APIである。
◎
The XMLHttpRequest object is an API for fetching resources.
</p>

<p>
`XMLHttpRequest$I という名前は歴史的なものであり、
【 “XML” の部分は】
その機能性と何ら関わりは無い。
◎
The name XMLHttpRequest is historical and has no bearing on its functionality.
</p>

<div class="example" id="example-xhr">

<p>
~network越しに~fetchされた~XML文書の~dataに対し何かを行う，単純な~code：
◎
Some simple code to do something with data from an XML document fetched over the network:
</p>

<pre class="lang-js">
function processData(%data) {
  /* <span class="comment">
~dataを~~処理する
◎
taking care of data
</span> */
}

function handler() {
  if(this.status == 200 &amp;&amp;
    this.responseXML != null &amp;&amp;
    this.responseXML.getElementById('test').textContent) {
    /* <span class="comment">
成功！
◎
success!
</span> */
    processData(this.responseXML.getElementById('test').textContent);
  } else {
    /* <span class="comment">
何らかの不具合が生じている
◎
something went wrong
</span> */
    …
  }
}

var %client = new XMLHttpRequest();
%client.onload = handler;
%client.open("GET", "unicorn.xml");
%client.send();
</pre>

<p>
単に~serverに~messageを残す：
◎
If you just want to log a message to the server:
</p>

<pre class="lang-js">
function log(%message) {
  var %client = new XMLHttpRequest();
  %client.open("POST", "/log");
  %client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
  %client.send(%message);
}
</pre>

<p>
あるいは、~serverにある文書の状態sを調べる：
◎
Or if you want to check the status of a document on the server:
</p>

<pre class="lang-js">
function fetchStatus(%address) {
  var %client = new XMLHttpRequest();
  %client.onload = function() {
    /* <span class="comment">
~network~errorが生じている場合、依拠-可能な結果は得られないであろう。
◎
in case of network errors this might not give reliable results
</span> */
    returnStatus(this.status);
  }
  %client.open("HEAD", %address);
  %client.send();
}
</pre>

</div>

		<section id="specification-history">
<h3 title="Specification history">1.1. 仕様の歴史</h3>

<p>
`XMLHttpRequest$I ~objは、当初は WHATWG による， HTML の（何年も前の、 Microsoft による実装に基づく）成果として定義された。
それは 2006 年には W3C に移管された。
`XMLHttpRequest$I に対する拡張（すなわち、進捗~event, 非同一-生成元（ cross-origin ）要請）は、 2011 年の終わりまでは別の草案（ XMLHttpRequest Level 2 ）の下で開発されていたが、その時点でこの 2 つの草案は `XMLHttpRequest$I に併合され，標準の観点から再び一つになった。
2012 年の終わりに，また WHATWG の下に移管されることとなった。
◎
The XMLHttpRequest object was initially defined as part of the WHATWG’s HTML effort. (Based on Microsoft’s implementation many years prior.) It moved to the W3C in 2006. Extensions (e.g. progress events and cross-origin requests) to XMLHttpRequest were developed in a separate draft (XMLHttpRequest Level 2) until end of 2011, at which point the two drafts were merged and XMLHttpRequest became a single entity again from a standards perspective. End of 2012 it moved back to the WHATWG.
</p>

<p>
現在の草案までに至る経緯は、次のメーリングリストにて見られる：
◎
Discussion that led to the current draft can be found in the following mailing list
archives:
</p>

<ul><li><a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/">whatwg@whatwg.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapi/">public-webapi@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-appformats/">public-appformats@w3.org</a>
</li></ul>

		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p>
【この節の内容は `INFRA^r の<a href="~INFRA#conformance">適合性</a>節に~~移譲する。】
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this specification are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

		<section id="extensibility">
<h3 title="Extensibility">2.1. 拡張能</h3>

<p>
~UA, Working Group, その他の関心のある主体には、［
新たな特能については、 WHATWG ~communityの場で論を交わす
］ことが<em>強く奨励される</em>。
◎
User agents, Working Groups, and other interested parties are strongly encouraged to discuss new features with the WHATWG community.
</p>

		</section>
	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は、全体を通して，次に挙げる仕様による各種用語を利用し, リンク付きで引用する
⇒
`DOM$r
`DOMPS$r
`ENCODING$r
`FEATURE-POLICY$r
`FETCH$r
`FILEAPI$r
`HTML$r
`HTTP$r
`URL$r
`WEBIDL$r
`XML$r
`XMLNS$r
◎
This specification uses terminology, cross-linked throughout, from DOM, DOM Parsing and Serialization, Encoding, Feature Policy, Fetch, File API, HTML, HTTP, URL, Web IDL, and XML.
◎
[DOM] [DOMPS] [ENCODING] [FEATURE-POLICY] [FETCH] [FILEAPI] [HTML] [HTTP] [URL] [WEBIDL] [XML] [XMLNS]
</p>

<p>
また、 `HTML$r と同じ typographic 規約を利用する。
◎
It uses the typographic conventions from HTML. [HTML]
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
~backtick（ "<code>`</code>" ）で括られた~literalは、文字列ではなく，
<a href="~INFRA#byte-sequence">~byte列</a>を表現する。
</p>

	</section>
	<section id="interface-xmlhttprequest">
<h2 title="Interface XMLHttpRequest">4. ~interface `XMLHttpRequest^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestEventTarget@I : `EventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `ontimeout$m;
  attribute `EventHandler$I `onloadend$m;
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestUpload@I : `XMLHttpRequestEventTarget$I {
};

enum `XMLHttpRequestResponseType@I {
  <dfn id="#dom-xmlhttprequestresponsetype">""</dfn>,
  `arraybuffer@l,
  `blob@l,
  `document@l,
  `json@l,
  `text@l
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequest@I : `XMLHttpRequestEventTarget$I {
  `XMLHttpRequest$mc();

  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onreadystatechange$m;

  // <span class="comment">`状態$</span>
  const `unsigned short$ `UNSENT$m = 0;
  const `unsigned short$ `OPENED$m = 1;
  const `unsigned short$ `HEADERS_RECEIVED$m = 2;
  const `unsigned short$ `LOADING$m = 3;
  const `unsigned short$ `DONE$m = 4;
  readonly attribute `unsigned short$ `readyState$m;

  // <span class="comment">`要請$</span>
  `undefined$ `open$m(`ByteString$ %method, `USVString$ %url);
  `undefined$ `~open_async$m(
      `ByteString$ %method,
      `USVString$ %url,
      `boolean$ %async,
      optional `USVString$? %username = null,
      optional `USVString$? %password = null
  );
  `undefined$ `setRequestHeader$m(`ByteString$ %name, `ByteString$ %value);
           attribute `unsigned long$ `timeout$m;
           attribute `boolean$ `withCredentials$m;
  [`SameObject$] readonly attribute `XMLHttpRequestUpload$I `upload$m;
  `undefined$ `send$m(optional (`Document$I or `XMLHttpRequestBodyInit$I)? %body = null);
  `undefined$ `abort$m();

  // <span class="comment">`応答$</span>
  readonly attribute `USVString$ `responseURL$m;
  readonly attribute `unsigned short$ `status$m;
  readonly attribute `ByteString$ `statusText$m;
  `ByteString$? `getResponseHeader$m(`ByteString$ %name);
  `ByteString$ `getAllResponseHeaders$m();
  `undefined$ `overrideMimeType$m(`DOMString$ %mime);
           attribute `XMLHttpRequestResponseType$I `responseType$m;
  readonly attribute any `response$m;
  readonly attribute `USVString$ `responseText$m;
  [`Exposed$=Window] readonly attribute `Document$I? `responseXML$m;
};
</pre>

<p>
各 `XMLHttpRequest$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~upload~obj@</dt>
	<dd>
`XMLHttpRequestUpload$I ~obj
◎
An XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</dd>
	<dd class="trans-note">【
この用語は、何を指しているか明確化するために，この訳に導入している（原文では、単に “the `XMLHttpRequestUpload^I ~obj” ）
】</dd>

	<dt>`状態@</dt>
	<dd>
次のいずれか
⇒
`~unsent^i （初期~値）,
`~opened^i,
`~headers-received^i,
`~loading^i,
`~done^i
◎
An XMLHttpRequest object has an associated state, which is one of unsent, opened, headers received, loading, and done. Unless stated otherwise it is unsent.
</dd>

	<dt>`~send~flag@</dt>
	<dd>
他が言明されない限り， ~F をとる。
◎
An XMLHttpRequest object has an associated send() flag. Unless stated otherwise it is unset.
</dd>
</dl>

		<section id="constructors">
<h3 title="Constructors">4.1. 構築子</h3>

<dl class="domintro">
	<dt>%client = `new XMLHttpRequest()$m</dt>
	<dd>
新たな `XMLHttpRequest$I ~objを返す。
◎
Returns a new XMLHttpRequest object.
</dd>
</dl>

<div class="algo">
`new XMLHttpRequest()@m
構築子~手続きは、何もしない。
◎
The XMLHttpRequest() constructor, when invoked, must return a new XMLHttpRequest object.
</div>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">4.2. ~garbage収集</h3>

<div class="p">
<p>
`XMLHttpRequest$I ~objは、次をいずれも満たしている間は，~garbage収集されないモノトスル：
</p>

<ul>
	<li>
<p>
次のいずれかを満たしている：
</p>
		<ul>
			<li>
［
`状態$ ~EQ `~opened^i
］~AND［
`~send~flag$ ~EQ ~T
］
</li>
			<li>
`状態$ ~IN { `~headers-received^i, `~loading^i }
</li>
		</ul>
	</li>
	<li>
次に挙げるいずれかの~event型に対する`~event~listener$が登録されている
⇒
`readystatechange$et,
`progress$et,
`abort$et,
`error$et,
`load$et,
`timeout$et,
`loadend$et
</li>
</ul>
◎
An XMLHttpRequest object must not be garbage collected if its state is either opened with the send() flag set, headers received, or loading, and it has one or more event listeners registered whose type is one of readystatechange, progress, abort, error, load, timeout, and loadend.
</div>

<p>
`XMLHttpRequest$I ~objが，その接続がまだ開いているにも関わらず~garbage収集された場合、~UAは，~objが演算している進行中の`~fetchを終了-$させるモノトスル。
◎
If an XMLHttpRequest object is garbage collected while its connection is still open, the user agent must terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

		</section>
		<section id="event-handlers">
<h3 title="Event handlers">4.3. ~event~handler</h3>

<p>
`XMLHttpRequestEventTarget$I を継承する~interfaceを実装する~objは、次の`~event~handler$（およびそれらに対応する`~event~handler ~event型$）を属性として~supportするモノトスル。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on objects implementing an interface that inherits from XMLHttpRequestEventTarget as attributes:
</p>

<table><thead>
<tr><th>`~event~handler$
◎
event handler
<th>`~event~handler ~event型$
◎
event handler event type
</thead><tbody>

<tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`ontimeout@m
<td>`timeout$et

<tr><td>`onloadend@m
<td>`loadend$et

</tbody></table>

<p>
`XMLHttpRequest$I ~objにおいては、次の`~event~handler$（および対応する
`~event~handler ~event型$）も属性として~supportするモノトスル：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported as attribute solely by the XMLHttpRequest object:
</p>

<table><thead>
<tr><th>`~event~handler$
◎
event handler
<th>`~event~handler ~event型$
◎
event handler event type
</thead><tbody>

<tr><td>`onreadystatechange@m
<td>`readystatechange$et

</tbody></table>

		</section>
		<section id="states">
<h3 title="States">4.4. 状態</h3>

<dl class="domintro">
	<dt>%client . `readyState$m</dt>
	<dd>
`状態$を返す。
◎
Returns client’s state.
</dd>
</dl>

<div class="algo">
<p>
`readyState@m
取得子~手続きは、コレの`状態$が下の表の 1 列目のいずれであるかに応じて，同じ行の 2 列目に示される値を返す：
◎
The readyState attribute’s getter must return the value from the table below in the cell of the second column, from the row where the value in the cell in the first column is context object’s state:
</p>

<table><thead>
<tr><th>`状態$
<th>値（数-値）
<th>記述
</thead><tbody>

<tr><td>`~unsent^i
<td>`UNSENT@m （ 0 ）
<td>
~objは構築-済みである。
◎
The object has been constructed.

<tr><td>`~opened^i
<td>`OPENED@m （ 1 ）
<td>
`open()$m ~methodは成功裡に呼出された。
この状態~下では、
`setRequestHeader$m を利用して要請~headerを設定でき，
`send$m ~methodを利用して~fetchを起動できる。
◎
The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method.

<tr><td>`~headers-received^i
<td>`HEADERS_RECEIVED@m （ 2 ）
<td>
すべての~redirect（もしあれば）は追従-済みであり，かつ
`応答$のすべての~HTTP~headerは受信-済みである。
◎
All redirects (if any) have been followed and all HTTP headers of the response have been received.

<tr><td>`~loading^i
<td>`LOADING@m （ 3 ）
<td>
`応答$の`本体$rsの受信-中にある。
◎
The response’s body is being received.

<tr><td>`~done^i
<td>`DONE@m （ 4 ）
<td>
~data転送が完了しているか, または転送~中に何らかの不具合が生じた（例えば，際限のない~redirect）。
◎
The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects).

</tbody></table>
</div>

		</section>
		<section id="request">
<h3 title="Request">4.5. 要請</h3>

<div>

<p>
各 `XMLHttpRequest$I ~objの要請には、次の概念が結付けられる
— 初期~時には、括弧内に示す値をとるとする（無いものは他所で設定される）：
</p>

<ul ><li>`要請~method@<!-- FETCH.concept-method -->
</li><li>`要請~URL@<!-- .concept-url？ -->
</li><li>`作者~要請~header~list@
— `~header~list$（空）
</li><li>`要請~本体@（ ~NULL ）
</li><li>`同期~flag@（ ~F ）
</li><li>`~upload完了-~flag@（ ~F ）
</li><li>`~upload~listener~flag@（ ~F ）
</li><li>`時間切れ~flag@（ ~F ）
</li></ul>

◎
Each XMLHttpRequest object has the following request-associated concepts: request method, request URL, author request headers, request body, synchronous flag, upload complete flag, upload listener flag, and timed out flag. 
◎
The author request headers is an initially empty header list.
◎
The request body is initially null.
◎
The synchronous flag, upload complete flag, upload listener flag and timed out flag are initially unset.
</div>

<p class="note" id="event-listeners-and-preflight">注記：
`XMLHttpRequestUpload$I ~obj上に 1 個~以上の~event~listenerを登録すると，`~CORS予行~要請$が発行されることになる。
（~event~listenerが登録されると`~upload~listener~flag$は ~T になり，それにより`~CORS予行~利用~flag$rqも ~T になるので。）
◎
Registering one or more event listeners on an XMLHttpRequestUpload object will result in a CORS-preflight request. (That is because registering an event listener causes the upload listener flag to be set, which in turn causes the use-CORS-preflight flag to be set.)
</p>

			<section id="the-open()-method">
<h4 title="The open() method">4.5.1. `open()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `open$m(%method, %url [, %async = true [, %username = null [, %password = null]]])</dt>
	<dd>
`要請~method$, `要請~URL$, `同期~flag$
を設定する。
◎
Sets the request method, request URL, and synchronous flag.
</dd>
	<dd>
%method が妥当な~HTTP~methodでない，あるいは %url を構文解析できない場合、 `SyntaxError$E 例外が投出される。
◎
Throws a "SyntaxError" DOMException if either method is not a valid HTTP method or url cannot be parsed.
</dd>
	<dd>
%method が
`CONNECT^h, `TRACE^h, `TRACK^h
のいずれかに文字大小無視で合致する場合、 `SecurityError$E 例外が投出される。
◎
Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
</dd>
	<dd>
<p>
次がいずれも満たされる場合、 `InvalidAccessError$E 例外が投出される：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`現在の大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li></ul>

◎
Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
</dd>
</dl>

<p class="critical" id="sync-warning">
~worker以外での同期的 `XMLHttpRequest$I は、末端利用者をひどく待たせることになりかねないので， Web ~platformから除去されつつある過程にある（何年もかかるであろう）。
開発者は、［
`現在の大域~obj$は `Window$I ~objである
］場合には， %async 引数に ~F を渡してはナラナイ。
~UA には、開発者~用~toolにおいて，その種の用法に対し警告することが強く奨励される
— 
それが生じたときに，
`InvalidAccessError$E 例外を`投出$するように、試験的に実装してもよい。
◎
Synchronous XMLHttpRequest outside of workers is in the process of being removed from the web platform as it has detrimental effects to the end user’s experience. (This is a long process that takes many years.) Developers must not pass false for the async argument when current global object is a Window object. User agents are strongly encouraged to warn about such usage in developer tools and may experiment with throwing an "InvalidAccessError" DOMException when it occurs.
</p>

<div class="algo">
<p>
`open(method, url)@m
／
`~open_async(method, url, async, username, password)@m
~method手続きは：
◎
The open(method, url) and open(method, url, async, username, password) methods, when invoked, must run these steps: 
</p>

<ol>
	<li>
%設定群~obj ~LET コレに`関連な設定群~obj$
◎
Let settingsObject be context object’s relevant settings object.
</li>
	<li>
~IF［
%設定群~obj には`担当の文書$enVがあって，それは`全部的に作動中$ではない
］
⇒
~THROW `InvalidStateError$E
◎
If settingsObject has a responsible document and it is not fully active, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%method は`~method$でない
］
⇒
~THROW `SyntaxError$E
◎
If method is not a method, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%method は`禁止~method$である
］
⇒
~THROW `SecurityError$E
◎
If method is a forbidden method, then throw a "SecurityError" DOMException.
</li>
	<li>
%method ~SET `~methodを正規化する$( %method )
◎
Normalize method.
</li>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %url, %設定群~obj の`~API用~URL文字~符号化法$enV )
◎
Let parsedURL be the result of parsing url with settingsObject’s API base URL and settingsObject’s API URL character encoding.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
<p>
~IF［
%async ~EQ ε
］
⇒
( %async, %username, %password ) ~SET ( true, ~NULL, ~NULL )
◎
If the async argument is omitted, set async to true, and set username and password to null.
</p>

<p class="note">注記：
あいにく，旧来の内容と~~互換性を得るため、 %async 引数に `undefined^c が渡された場合と省略された場合とを，同じに扱うわけにはいかない。
◎
Unfortunately legacy content prevents treating the async argument being undefined identical from it being omitted.
</p>
	</li>
	<li>
<p>
~IF［
%解析済み~URL の`~host$ ~NEQ ~NULL
］：
◎
If parsedURL’s host is non-null, then: 
</p>
		<ol>
			<li>
~IF［
%username ~NEQ ~NULL
］
⇒
`~URLの~usernameを設定する$( %解析済み~URL, %username )
◎
If the username argument is not null, set the username given parsedURL and username.
</li>
			<li>
~IF［
%password ~NEQ ~NULL
］
⇒
`~URLの~passwordを設定する$( %解析済み~URL, %password )
◎
If the password argument is not null, set the password given parsedURL and password.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次がいずれも満たされる
］…：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`現在の大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li></ul>

<p>
…ならば
⇒
~THROW `InvalidAccessError$E
</p>

◎
If async is false, current global object is a Window object, and the timeout attribute value is not zero or the responseType attribute value is not the empty string, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
<p>
コレが演算している進行中の`~fetchを終了させる$
◎
Terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

<p class="note">注記：
この時点から，`~fetching$を進行させられるようになる。
◎
A fetch can be ongoing at this point.
</p>
	</li>
	<li>
<p>
コレの
⇒＃
`~send~flag$ ~SET ~F,
`~upload~listener~flag$ ~SET ~F,
`要請~method$ ~SET %method,
`要請~URL$ ~SET %解析済み~URL,
`同期~flag$ ~SET ［ %async ~EQ ~F ならば ~T ／ ~ELSE_ ~F ］,
`応答$ ~SET `~network~error$,
`受信した~byte列$ ~SET 空~byte列,
`応答~obj$ ~SET ~NULL
◎
Set variables associated with the object as follows:
• Unset the send() flag and upload listener flag.
• Set request method to method.
• Set request URL to parsedURL.
• Set the synchronous flag, if async is false, and unset the synchronous flag otherwise.
• Empty author request headers.
• Set response to a network error.
• Set received bytes to the empty byte sequence.
• Set response object to null.
</p>

<p class="note">注記：
`上書き~MIME型$は、ここでは上書きされない
— `open()^m ~methodより前に `overrideMimeType()$m ~methodが呼出されることもあるので。
◎
Override MIME type is not overridden here as the overrideMimeType() method can be invoked before the open() method.
</p>

	</li>
	<li>
コレの`作者~要請~header~list$を空にする
◎
↑</li>
	<li>
<p>
~IF［
コレの`状態$ ~NEQ `~opened^i
］：
◎
If the state is not opened, then:
</p>
		<ol>
			<li>
コレの`状態$ ~SET `~opened^i
◎
Set state to opened.
</li>
			<li>
コレに向けて，名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</li>
		</ol>
	</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there are two open() methods defined is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

			</section>
			<section id="the-setrequestheader()-method">
<h4 title="The setRequestHeader() method">4.5.2. `setRequestHeader()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `setRequestHeader(name, value)$m</dt>
	<dd>
<p>
`作者~要請~header~list$の中で，所与の %name の`~header$に %value を結合する
◎
Combines a header in author request headers.
</dd>
	<dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~T
の場合、 `InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
	<dd>
%name が~header名でなかったり,
%value が~header値でなかった場合、
`SyntaxError$E 例外が投出される。
◎
Throws a "SyntaxError" DOMException if name is not a header name or if value is not a header value.
</dd>
</dl>

<div class="algo">
<p>
`setRequestHeader(name, value)@m
~method手続きは：
◎
The setRequestHeader(name, value) method must run these steps:
</p>
<ol>
	<li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError$E
◎
If state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
`~send~flag$ ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If the send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
%value ~SET `値を正規化する$( %value )
◎
Normalize value.
</li>
	<li>
<p>
~IF［
%name は`名前$hdでない
］~OR［
%value は`値$hdでない
］
⇒
~THROW `SyntaxError$E
◎
If name is not a name or value is not a value, then throw a "SyntaxError" DOMException.
</p>

<p class="note">注記：
空~byte列は空な`~header$ `値$hdを表現する。
◎
An empty byte sequence represents an empty header value.
</p>
	</li>
	<li>
~IF［
%name は`禁止~header名$である
］
⇒
~RET
◎
Terminate these steps if name is a forbidden header name.
</li>
	<li>
`作者~要請~header~list$内で`~headerを結合する$( %name / %value )
◎
Combine name/value in author request headers.
</li>
</ol>
</div>

<div class="example" id="example-setting-header-twice">

<p>
同じ~headerを重ねて設定した場合に何が起こるかデモるための，単純な~code：
◎
Some simple code demonstrating what happens when setting the same header twice:
◎
// The following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open('GET', 'demo.cgi');
%client.setRequestHeader('X-Test', 'one');
%client.setRequestHeader('X-Test', 'two');
%client.send();
</pre>

<p>
この~scriptによる結果、次の~headerが送信される：
◎
// …results in the following header being sent:
</p>

<pre class="lang-http">
X-Test: one, two
</pre>
</div>

			</section>
			<section id="the-timeout-attribute">
<h4 title="The timeout attribute">4.5.3. `timeout^m 属性</h4>

<dl class="domintro">
	<dt>%client . `timeout$m</dt>
	<dd>
時間を~milli秒~単位で設定できる。
0 でない値に設定された場合、所与の時間が経過した時点で，`~fetching$は終了させられる。
その時点で要請がまだ完了していない場合、`同期~flag$が ~F の下では，
`timeout$et ~eventが`配送-$され、他の場合（ ~T の下での `send()$m ~methodに対しては），
`TimeoutError$E 例外が`投出$されることになる。
◎
Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
</dd>
	<dd>
設定子は、［
`同期~flag$ ~EQ ~T
］, かつ［
`現在の大域~obj$は `Window$I ~objである
］ならば，
`InvalidAccessError$E 例外が投出される。
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
</dd>
</dl>

<div class="algo">
`timeout@m
取得子~手続きは、最後に設定された値を返す。
◎
The timeout attribute must return its value.＼
</div>

<p>
`timeout$m 属性は、初期~時には 0 に設定されるモノトスル。
◎
Initially its value must be zero.
</p>

<div class="algo">
<p>
`timeout$m 設定子~手続きは：
◎
Setting the timeout attribute must run these steps:
</p>
<ol>
	<li>
~IF［
`現在の大域~obj$は `Window$I ~objである
］~AND［
`同期~flag$ ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If current global object is a Window object and the synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
この属性の値 ~SET 新たな値
◎
Set its value to the new value.
</li>
</ol>

<p class="note">注記：
これにより，`~fetching$が進捗~中にある間でも、 `timeout$m 属性を設定-可能になる。
設定しても、計測の起点（ `~fetching$が開始された時点）が改められることはない。
◎
This implies that the timeout attribute can be set while fetching is in progress. If that occurs it will still be measured relative to the start of fetching.
</p>
</div>

			</section>
			<section id="the-withcredentials-attribute">
<h4 title="The withCredentials attribute">4.5.4. `withCredentials^m 属性</h4>

<dl class="domintro">
	<dt>%client . `withCredentials$m</dt>
	<dd>
`資格証$が非同一-生成元~要請に含められることになるときは ~T。
非同一-生成元~要請から除外され，その応答における~cookieは無視されることになるときは ~F。
初期~時は ~F 。
◎
True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
</dd>
	<dd>
設定子は、`状態$が `~unsent^i でも `~opened^i でもない, または
`~send~flag$ ~EQ ~T
ならば， `InvalidStateError$E 例外が投出される。
◎
When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
</dd>
</dl>

<div class="algo">
`withCredentials@m
取得子~手続きは、最後に設定された値を返す。
◎
The withCredentials attribute must return its value.＼
</div>

<p>
`withCredentials$m 属性は、初期~時には ~F に設定されるモノトスル。
◎
Initially its value must be false.
</p>

<div class="algo">
<p>
`withCredentials$m 設定子~手続きは：
◎
Setting the withCredentials attribute must run these steps:
</p>
		<ol>
			<li>
~IF［
`状態$ ~NIN
{ `~unsent^i, `~opened^i }
］
⇒
~THROW `InvalidStateError$E
◎
If state is not unsent or opened, then throw an "InvalidStateError" DOMException.
</li>
			<li>
~IF［
`~send~flag$ ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If the send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
			<li>
この属性の値 ~SET 所与の値
◎
Set the withCredentials attribute’s value to the given value.
</li>
		</ol>
</div>

<p class="note">注記：
`withCredentials$m 属性は、`同一-生成元$の`~fetching$においては、何の効果もない。
◎
The withCredentials attribute has no effect when fetching same-origin resources.
</p>

			</section>
			<section id="the-upload-attribute">
<h4 title="The upload attribute">4.5.5. `upload^m 属性</h4>

<dl class="domintro">
	<dt>%client . `upload$m</dt>
	<dd>
結付けられている `XMLHttpRequestUpload$I ~objを返す。
これを利用すれば、~serverへ向けて~dataが転送されるときに，伝送~情報を集めることができる。
◎
Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
</dd>
</dl>

<div class="algo">
`upload@m
取得子~手続きは
⇒
~RET コレの`~upload~obj$
◎
The upload attribute must return the associated XMLHttpRequestUpload object.
◎
As indicated earlier, each XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</div>

			</section>
			<section id="the-send()-method">
<h4 title="The send() method">4.5.6. `send()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `send$m([%body = null])</dt>
	<dd>
要請を起動させる。
%body 引数は、`要請~本体$を供する（もしあれば）。
`要請~method$が `GET$hm や `HEAD$hm の場合、この引数は無視される。
◎
Initiates the request. The body argument provides the request body, if any, and is ignored if the request method is GET or HEAD.
</dd>
	<dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~T
の場合、 `InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
</dd>
</dl>

<div class="algorithm">
<p>
`send(body)@m
~method手続きは：
◎
The send(body) method must run these steps:
</p>
<ol>
	<li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError$E
◎
If state is not opened, then throw an "InvalidStateError" DOMException.
</li>
	<li><!-- copy -->
~IF［
`~send~flag$ ~EQ ~T
］
⇒
~THROW `InvalidStateError$E
◎
If the send() flag is set, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
`要請~method$ ~IN
{ `GET$hm, `HEAD$hm }
］
⇒
%body ~SET ~NULL
◎
If the request method is GET or HEAD, set body to null.
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is not null, then:
</p>
		<ol>
			<li>
%抽出された内容~型 ~LET ~NULL
◎
Let extractedContentType be null.
</li>
			<li>
~IF［
%body は `Document$I である
］
⇒
`要請~本体$ ~SET `~UTF-8符号化する$( `~scalar値~文字列に変換する$( `素片を直列化する$( %body ) ) )
◎
If body is a Document, then set request body to body, serialized, converted to Unicode, and UTF-8 encoded.
</li>
			<li>
~ELSE
⇒
( `要請~本体$, %抽出された内容~型 ) ~SET `本体と内容~型を抽出する$( %body )
◎
Otherwise, set request body and extractedContentType to the result of extracting body.
</li>
			<li>
%作者~内容~型 ~LET `作者~要請~header~list$内に `Content-Type^h を`名前に持つ~header$は［
在るならば それ／
無いならば ~NULL
］
◎
↓</li>
			<li>
<p>
~IF［
%作者~内容~型 ~NEQ ~NULL
］：
◎
If author request headers contains `Content-Type`, then:
</p>
				<ol>
					<li>
<p>
~IF［
%body は［
`Document$I ／ `USVString$I
］である
］：
◎
If body is a Document or a USVString, then:
</p>
						<ol>
							<li>
%内容~型~record ~LET `~byte列から~MIME型を構文解析する$( %作者~内容~型 の`値$hd )
◎
Let originalAuthorContentType be the value of the header whose name is a byte-case-insensitive match for `Content-Type` in author request headers.
◎
Let contentTypeRecord be the result of parsing originalAuthorContentType.
</li>
							<li>
<p>
~IF［
%内容~型~record ~NEQ 失敗
］：
◎
If contentTypeRecord is not failure,＼
</p>
								<ol>
									<li>
%~parameter~map ~LET %内容~型~record の`~parameter~map$
◎
↓</li>
									<li>
<p>
~IF［
%~parameter~map[ `charset^l ] ~NEQ ε
］~AND［
%~parameter~map[ `charset^l ] は`~ASCII大小無視$で `UTF-8^l に合致しない
］：
◎
contentTypeRecord’s parameters["charset"] exists, and parameters["charset"] is not an ASCII case-insensitive match for "UTF-8", then:
</p>
										<ol>
											<li>
%~parameter~map[ `charset^l ] ~SET `UTF-8^l
◎
Set contentTypeRecord’s parameters["charset"] to "UTF-8".
</li>
											<li>
`作者~要請~header~list$内で`~headerを設定する$( `Content-Type^h / `~MIME型を~byte列に直列化する$( %内容~型~record ) )
◎
Let newContentTypeSerialized be the result of serializing contentTypeRecord.
◎
Set `Content-Type`/newContentTypeSerialized in author request headers.
</li>
										</ol>
									</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise:
</p>
				<ol>
					<li>
%内容~型 ~LET 次で与えられる値
⇒＃
%body は`~HTML文書$であるならば `text/html;charset=UTF-8^lb ／
~ELSE_ %body は`~XML文書$であるならば `application/xml;charset=UTF-8^lb ／
~ELSE_ %抽出された内容~型
◎
If body is an HTML document, set `Content-Type`/`text/html;charset=UTF-8` in author request headers.
◎
Otherwise, if body is an XML document, set `Content-Type`/`application/xml;charset=UTF-8` in author request headers.
◎
Otherwise, if extractedContentType is not null, set `Content-Type`/extractedContentType in author request headers.
</li>
					<li>
~IF［
%内容~型 ~NEQ ~NULL
］
⇒
`作者~要請~header~list$内で`~headerを設定する$( `Content-Type^h / %内容~型 )
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
コレの`~upload~obj$に登録されている~event~listenerは在る
］
⇒
`~upload~listener~flag$ ~SET ~T
◎
If one or more event listeners are registered on the associated XMLHttpRequestUpload object, then set upload listener flag.
</li>
	<li>
<p>
%要請 ~LET 次に従って初期化された新たな`要請$rq：
◎
Let req be a new request, initialized as follows:
</p>
		<ul>
			<li>
`~method$rq~SET `要請~method$
◎
method
• request method
</li>
			<li>
`~URL$rq ~SET `要請~URL$
◎
url
• request URL
</li>
			<li>
`~header~list$rq ~SET `作者~要請~header~list$
◎
header list
• author request headers
</li>
			<li>
`非安全~要請~flag$rq ~SET ~T
◎
unsafe-request flag
• Set.
</li>
			<li>
`本体$rq ~SET `要請~本体$
◎
body
• request body
</li>
			<li>
`~client$rq ~SET コレに`関連な設定群~obj$
◎
client
• context object’s relevant settings object
</li>
			<li>
`同期~flag$rq ~SET `同期~flag$
◎
synchronous flag
• Set if the synchronous flag is set.
</li>
			<li>
`~mode$rq ~SET `cors^l
◎
mode
• "cors"
</li>
			<li>
`~CORS予行~利用~flag$rq ~SET `~upload~listener~flag$
◎
use-CORS-preflight flag
• Set if upload listener flag is set.
</li>
			<li>
`資格証~mode$rq ~SET ［
`withCredentials$m 属性 ~EQ ~T
ならば `include^l ／
~ELSE_ `same-origin^l
］
◎
credentials mode
• If the withCredentials attribute value is true, "include", and "same-origin" otherwise.
</li>
			<li>
`~URL資格証~利用~flag$rq ~SET ［
`要請~URL$は`資格証を含む$ならば ~T ／
~ELSE_ ~F
］
<!-- ＊ “資格証を含む” により等価な記述に簡素化
原文 is non-null は is not empty string の誤記（更新漏れ）と見受けられる。
-->
◎
use-URL-credentials flag
• Set if either request URL’s username is not the empty string or request URL’s password is non-null.
</li>
		</ul>
	</li>
	<li>
`~upload完了-~flag$ ~SET %要請 の`本体$rqに応じて
⇒
~NULL ならば ~T ／
~ELSE_ ~F
◎
Unset the upload complete flag.
◎
Unset the timed out flag.
◎
If req’s body is null, set the upload complete flag.
</li>
	<li>
`時間切れ~flag$ ~SET ~F
◎
↑</li>
	<li>
`~send~flag$ ~SET ~T
◎
Set the send() flag.
</li>
	<li>
<p>
~IF［
`同期~flag$ ~EQ ~F
］：
◎
If the synchronous flag is unset, then:
</p>
		<ol>
			<li>
コレに向けて名前 `loadstart$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadstart at this with 0 and 0.
</li>
			<li>
~IF［
`~upload完了-~flag$ ~EQ ~F
］~AND［
`~upload~listener~flag$ ~EQ ~T
］
⇒
コレの`~upload~obj$に向けて，名前 `loadstart$et の`進捗~eventを発火する$( 0, %要請 の`本体$rqの`総~byte数$ )
◎
If the upload complete flag is unset and upload listener flag is set, then fire a progress event named loadstart at this’s XMLHttpRequestUpload object with 0 and req’s body’s total bytes.
</li>
			<li>
~IF［
`状態$ ~NEQ `~opened^i
］~OR［
`~send~flag$ ~EQ ~F
］
⇒
~RET
◎
If state is not opened or the send() flag is unset, then return.
</li>
			<li>
<p>
%要請 を`~fetch$する
— それにより`~network用~task源$から`~queueされ$た`~task$は、以下に従って取扱う
◎
Fetch req. Handle the tasks queued on the networking task source per below.
</p>

<div class="algorithm">
<p>
次の下位手続きを`並列的$に走らす：
◎
Run these steps in parallel:
</p>
				<ol>
					<li>
<p>
次のいずれかが満たされるまで待機する：
◎
↓</p>
						<ul>
							<li>
%要請 の`~done~flag$rq ~EQ ~T
◎
Wait until either req’s done flag is set or
</li>
							<li>
この下位手続きを開始してから経過した秒数 ~GT `timeout$m 属性~値 ~GT 0
◎
the timeout attribute value number of milliseconds has passed since these steps started
◎
while timeout attribute value is not zero.
</li>
						</ul>
					</li>
					<li>
<p>
~IF［
%要請 の`~done~flag$rq ~EQ ~F
］：
</p>
<ol><li>`時間切れ~flag$ ~SET ~T
</li><li>この`~fetchを終了させる$
</li></ol>
◎
If req’s done flag is unset, then set the timed out flag and terminate fetching.
</li>
				</ol>
</div>

<p>
【以下に定義される各種 下位手続き（ “〜を処理する” ）は、`~fetching$の中で~queueされる~taskになる（これらは，非同期的に呼出される callback である）。】
</p>

<div class="algorithm">
<p>
`要請の本体を処理する$ときは、所与の
( %要請 )
に対し，次の下位手続きを走らす：
◎
To process request body for request, run these steps:
</p>

<ol>
	<li>
~IF［
この手続きが最後に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, terminate these steps.
</li>
	<li>
~IF［
`~upload~listener~flag$ ~EQ ~T
］
⇒
コレの`~upload~obj$に向けて，名前 `progress$et の`進捗~eventを発火する$( %要請 の`本体$rqの`伝送-済み~byte数$, %要請 の`本体$rqの`総~byte数$ )
◎
If upload listener flag is set, then fire a progress event named progress at this’s XMLHttpRequestUpload object with request’s body’s transmitted bytes and request’s body’s total bytes.
</li>
</ol>

<p class="note">注記：
この下位手続きは、新たな~byteが伝送されたときに限り，呼出される。
◎
These steps are only invoked when new bytes are transmitted.
</p>
</div>

<div class="algorithm">
<p>
`要請の本体終端を処理する$ときは、所与の
( %要請 )
に対し，次の下位手続きを走らす：
◎
To process request end-of-body for request, run these steps:
</p>
				<ol>
					<li>
`~upload完了-~flag$ ~SET ~T
◎
Set the upload complete flag.
</li>
					<li>
~IF［
`~upload~listener~flag$ ~EQ ~T
］
⇒
~RET
◎
If upload listener flag is unset, then terminate these steps.
</li>
					<li>
%伝送量 ~LET
%要請 の`本体$rqの`伝送-済み~byte数$ 
◎
Let transmitted be request’s body’s transmitted bytes.
</li>
					<li>
%長さ ~LET
%要請 の`本体$rqの`総~byte数$
◎
Let length be request’s body’s total bytes.
</li>
					<li>
コレの`~upload~obj$に向けて，名前 `progress$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named progress at this’s XMLHttpRequestUpload object with transmitted and length.
</li>
					<li>
コレの`~upload~obj$に向けて，名前 `load$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named load at this’s XMLHttpRequestUpload object with transmitted and length.
</li>
					<li>
コレの`~upload~obj$に向けて，名前 `loadend$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named loadend at this’s XMLHttpRequestUpload object with transmitted and length.
</li>
				</ol>
</div>

<div class="algorithm">
<p>
`応答を処理する$ときは、所与の
( %応答 )
に対し，次の下位手続きを走らす：
◎
To process response for response, run these steps:
</p>
				<ol>
					<li>
`応答$ ~SET %応答
◎
Set response to response.
</li>
					<li>
%応答 の`~errorを取扱う$
◎
Handle errors for response.
</li>
					<li>
~IF［
`応答$ は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>
					<li>
`状態$ ~SET `~headers-received^i
◎
Set state to headers received.
</li>
					<li>
コレに向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</li>
					<li>
~IF［
`状態$ ~NEQ `~headers-received^i
］
⇒
~RET
◎
If state is not headers received, then return.
</li>
					<li>
%本体 ~LET %応答 の`本体$rs
◎
↓</li>
					<li>
<p>
~IF［
%本体 ~EQ ~NULL
］：
</p>
<ol><li>%応答 の`本体終端を取扱う$
</li><li>~RET
</li></ol>
◎
If response’s body is null, then run handle response end-of-body and return.
</li>
					<li>
<p>
%読取器 ~LET %本体 の`~stream$から`読取器を取得する$RS()
◎
Let reader be the result of getting a reader from response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
					</li>
					<li>
<p>
%読取 ~LET %本体 の`~stream$から`~chunkを読取る$RS( %読取器, 【必要な引数が足りない】 )
◎
Let read be the result of reading a chunk from response’s body’s stream with reader.
</p>

						<ul>
							<li>
<div class="p">
<p>
%読取 が次の両者を満たす~obj：
</p>

<ul ><li>`done^c ~prop ~EQ ~F
</li><li>`value^c ~propは `Uint8Array$I ~objである
</li></ul>

<p>
で充足されたときは
⇒
次の下位手続き(A) を走らせた上で、この段を再度~走らす
</p>

◎
When read is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, run these steps and then run this step again: 
</div>

<p>
下位手続き(A)：
</p>
							<ol>
								<li>
`受信した~byte列$に `value^c ~propを付加する
◎
Append the value property to received bytes.
</li>
								<li>
~IF［
下位手続き(A) が前回に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these steps were last invoked, then terminate these steps.
</li>
								<li>
~IF［
`状態$ ~EQ `~headers-received^i
］
⇒
`状態$ ~SET `~loading^i
◎
If state is headers received, then set state to loading.
</li>
								<li>
<p>
コレに向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</p>
<p class="note">注記：
`readystatechange$et が状態~変化なしでも余分に発火されるのは、
Web 互換性の理由による。
◎
Web compatibility is the reason readystatechange fires more often than state changes.
</p>
								</li>
								<li>
コレに向けて名前 `progress$et の`進捗~eventを発火する$( %本体 の`伝送-済み~byte数$, %本体 の`総~byte数$ )
◎
Fire a progress event named progress at this with response’s body’s transmitted bytes and response’s body’s total bytes.
</li>
							</ol>
<p class="note">注記：
下位手続き(A) は、新たな~byte列が伝送されたときに限り，呼出される。
◎
These steps are only invoked when new bytes are transmitted.
</p>
						</li>
						<li>
%読取 が［
`done^c ~prop ~EQ ~T
］なる~objで充足されたときは
⇒
%応答 の`本体終端を取扱う$
◎
When read is fulfilled with an object whose done property is true, run handle response end-of-body for response.
</li>
						<li>
%読取 が例外で却下されたときは
⇒
%応答 の`~errorを取扱う$
◎
When read is rejected with an exception, run handle errors for response.
</li>
					</ul>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
（ `同期~flag$ ~EQ ~T ）：
◎
Otherwise, if the synchronous flag is set, then:
</p>
		<ol>
			<li>
~IF［
コレに`関連な設定群~obj$には`担当の文書$enVがあって，それには
`sync-xhr$l `特能の利用は許容されて$いない
］
⇒＃
`~network~error$ の`本体終端を取扱う$；
~RET
◎
If context object’s relevant settings object has a responsible document which is not allowed to use the "sync-xhr" feature, then run handle response end-of-body for a network error and return.
</li>
			<li>
<p>
%応答 ~LET %要請 を`~fetch$した結果
◎
Let response be the result of fetching req.
</p>

<div class="p">
<p>
~IF［
`timeout$m 属性~値 %timeout ~NEQ 0
］~AND［
この`~fetching$は %timeout ~milli秒内に返らなかった
］：
</p>
<ol><li>`時間切れ~flag$ ~SET ~T
</li><li>この`~fetchを終了させる$
</li></ol>

◎
If the timeout attribute value is not zero, then set the timed out flag and terminate fetching if it has not returned within the amount of milliseconds from the timeout.
</div>

			</li>
			<li>
<p>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］
◎
If response’s body is null, then run handle response end-of-body and return.
</p>
				<ol>
					<li>
<p>
%読取器 ~LET %応答 の`本体$rsの`~stream$から`読取器を取得する$RS()
◎
Let reader be the result of getting a reader from response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
			</li>
					<li>
%promise ~LET %応答 の`本体$rsの`~stream$から `すべての~byte列を読取る$RS( %読取器 )
◎
Let promise be the result of reading all bytes from response’s body’s stream with reader.
</li>
					<li>
%promise が充足されるか却下されるまで待機する
⇒
%promise が %~byte列 で充足されたときは
⇒
`受信した~byte列$に %~byte列 を付加する
◎
Wait for promise to be fulfilled or rejected.
◎
• If promise is fulfilled with bytes, then append bytes to received bytes.
</li>
				</ol>
			</li>
			<li>
%応答 の`本体終端を取扱う$
◎
Run handle response end-of-body for response.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="trans-note">【
以下の~algoに現れるコレは、それを呼出している文脈におけるコレを指す。
】</p>

<div class="algorithm">
<p>
%応答 の
`本体終端を取扱う@
ときは、次を走らす：
◎
To handle response end-of-body for response, run these steps:
</p>

<ol>
	<li>
~IF［
`同期~flag$ ~EQ ~T
］
⇒
`応答$ ~SET %応答
◎
If the synchronous flag is set, set response to response.
</li>
	<li>
%応答 の`~errorを取扱う$
◎
Handle errors for response.
</li>
	<li>
~IF［
`応答$は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>
	<li>
~IF［
`同期~flag$ ~EQ ~F
］
⇒
%応答 を利用して`応答$の`本体$rsを更新する
◎
If the synchronous flag is unset, update response’s body using response.
</li>
	<li>
%伝送量 ~LET %応答 の`本体$rsの`伝送-済み~byte数$
◎
Let transmitted be response’s body’s transmitted bytes.
</li>
	<li>
%長さ ~LET %応答 の`本体$rsの`総~byte数$
◎
Let length be response’s body’s total bytes.
</li>
	<li>
~IF［
`同期~flag$ ~EQ ~F
］
⇒
コレに向けて名前 `progress$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
If the synchronous flag is unset, fire a progress event named progress at this with transmitted and length.
</li>
	<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
	<li>
`~send~flag$ ~SET ~F
◎
Unset the send() flag.
</li>
	<li>
コレに向けて名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange at this.
</li>
	<li>
コレに向けて名前 `load$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named load at this with transmitted and length.
</li>
	<li>
コレに向けて名前 `loadend$et の`進捗~eventを発火する$( %伝送量, %長さ )
◎
Fire a progress event named loadend at this with transmitted and length.
</li>
</ol>
</div>

<div class="algorithm">
<p>
%応答 の
`~errorを取扱う@
ときは、次を走らす：
◎
To handle errors for response run these steps:
</p>

<ol>
	<li>
~IF［
`~send~flag$ ~EQ ~F
］
⇒
~RET
◎
If the send() flag is unset, return.
</li>
	<li>
~IF［
`時間切れ~flag$ ~EQ ~T
］
⇒
`要請~error手続きを走らす$( `timeout$et, `TimeoutError$E )
◎
If the timed out flag is set, then run the request error steps for event timeout and exception "TimeoutError" DOMException.
</li>
	<li>
~IF［
%応答 は`~network~error$である
］
⇒
`要請~error手続きを走らす$( `error$et, `NetworkError$E )
◎
If response is a network error, then run the request error steps for event error and exception "NetworkError" DOMException.
</li>
	<li>
<p>
~ELIF［
%応答 の`本体$rsの`~stream$は`~errorした$
］：
◎
Otherwise, if response’s body’s stream is errored, then:
</p>
		<ol>
			<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
			<li>
`~send~flag$ ~SET ~F
◎
Unset the send() flag.
</li>
			<li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%応答 の`中止~flag$rs ~EQ ~T
］
⇒
`要請~error手続きを走らす$( `abort$et, `AbortError$E )
◎
Otherwise, if response’s aborted flag is set, then run the request error steps for event abort and exception "AbortError" DOMException.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`要請~error手続きを走らす@
ときは、所与の
( %~event名 , %例外 （省略可）)
に対し，次を走らす：
◎
The request error steps for event event and optionally an exception exception are:
</p>

<ol>
	<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
	<li>
`~send~flag$ ~SET ~F
◎
Unset the send() flag.
</li>
	<li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
	<li>
<p>
~IF［
`同期~flag$ ~EQ ~T
］
⇒
~THROW %例外
◎
If the synchronous flag is set, throw an exception exception.
</p>

<p class="trans-note">【
この場合に、 %例外 が省略されて呼出されることはない。
】</p>
	</li>
	<li>
<p>
コレに向けて名前 `readystatechange$et の`~eventを発火する$ 
◎
Fire an event named readystatechange at this.
</p>

<p class="note">注記：
この時点で明らかに
`同期~flag$ ~EQ ~F
◎
At this point it is clear that the synchronous flag is unset.
</p>
	</li>
	<li>
<p>
~IF［
`~upload完了-~flag$ ~EQ ~F
］：
◎
If the upload complete flag is unset, then:
</p>
		<ol>
			<li>
`~upload完了-~flag$ ~SET ~T
◎
Set the upload complete flag.
</li>
			<li>
<p>
~IF［
`~upload~listener~flag$ ~EQ ~T
］：
◎
If the upload listener flag is set, then:
</p>
				<ol>
					<li>
コレの`~upload~obj$に向けて，名前 %~event名 の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named event at this’s XMLHttpRequestUpload object with 0 and 0.
</li>
					<li>
コレの`~upload~obj$に向けて，名前 `loadend$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadend at this’s XMLHttpRequestUpload object with 0 and 0.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
コレに向けて名前 %~event名 の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named event at this with 0 and 0.
</li>
	<li>
コレに向けて名前 `loadend$et の`進捗~eventを発火する$( 0, 0 )
◎
Fire a progress event named loadend at this with 0 and 0.
</li>
</ol>
</div>

			</section>
			<section id="the-abort()-method">
<h4 title="The abort() method">4.5.7. `abort()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `abort()$m</dt>
	<dd>
~network活動をすべて取消す。
◎
Cancels any network activity.
</dd>
</dl>

<div class="algo">
<p>
`abort()@m
~method手続きは：
◎
The abort() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
進行中の`~fetchを終了させる$( `中止する^i )
◎
Terminate the ongoing fetch with the aborted flag set.
</li>
			<li>
~IF［［
`状態$ ~EQ `~opened^i
］~AND［
`~send~flag$ ~EQ ~T
］］~OR［
`状態$ ~IN
{ `~headers-received^i, `~loading^i }
］
⇒
`要請~error手続きを走らす$( `abort$et )
◎
If state is either opened with the send() flag set, headers received, or loading, run the request error steps for event abort.
</li>
			<li>
<div class="p">
<p>
~IF［
`状態$ ~EQ `~done^i
］：
</p>

<ol><li>`状態$ ~SET `~unsent^i
</li><li>`応答$ ~SET `~network~error$
</li></ol>
◎
If state is done, then set state to unsent and response to a network error.
</div>

<p class="note">注記：
いかなる `readystatechange$et ~eventも配送されない。
◎
No readystatechange event is dispatched.
</p>
			</li>
		</ol>
</div>

			</section>
		</section>
		<section id="xmlhttprequest-response">
<h3 title="Response">4.6. 応答</h3>

<p>
各 `XMLHttpRequest$I には，次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`応答@</dt>
	<dd>
`応答$rs。
他が言明されない限り，`~network~error$とする。
◎
An XMLHttpRequest has an associated response. Unless stated otherwise it is a network error.
</dd>

	<dt>`受信した~byte列@</dt>
	<dd>
~byte列。
他が言明されない限り，空~byte列とする。
◎
An XMLHttpRequest also has an associated received bytes (a byte sequence). Unless stated otherwise it is the empty byte sequence.
</dd>
</dl>

			<section id="the-responseurl-attribute">
<h4 title="The responseURL attribute">4.6.1. `responseURL^m 属性</h4>

<div class="algo">
<p>
`responseURL@m
取得子~手続きは：
</p>
<ol>
	<li>
%url ~LET `応答$の`~URL$rs
</li>
	<li>
~IF［
%url ~EQ ~NULL
］
⇒
~RET 空~文字列
</li>
	<li>
~RET `~URLを直列化する$( %url, `素片は除外する^i )
</li>
</ol>
◎
The responseURL attribute must return the empty string if response’s url is null and its serialization with the exclude fragment flag set otherwise.
</div>

			</section>
			<section id="the-status-attribute">
<h4 title="The status attribute">4.6.2. `status^m 属性</h4>

<div class="algo">
`status@m
取得子~手続きは
⇒
~RET `応答$の`状態s$rs
◎
The status attribute must return the response’s status.
</div>

			</section>
			<section id="the-statustext-attribute">
<h4 title="The statusText attribute">4.6.3. `statusText^m 属性</h4>

<div class="algo">
`statusText@m
取得子~手続きは
⇒
~RET `応答$の`状態s~message$rs
◎
The statusText attribute must return the response’s status message.
</div>

			</section>
			<section id="the-getresponseheader()-method">
<h4 title="The getResponseHeader() method">4.6.4. `getResponseHeader()^m ~method</h4>

<div class="algo">
<p>
`getResponseHeader(name)@m
~method手続きは
⇒
~RET `~header~listから値を取得する$( `応答$の`~header~list$rs, %名前 )
◎
The getResponseHeader(name) method, when invoked, must return the result of getting name from response’s header list 
</p>

<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters response’s header list. [FETCH]
</p>
</div>

<div class="example" id="example-getresponseheader">

<p>
次の~scriptにおいては：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "unicorns-are-awesome.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(%client.getResponseHeader("Content-Type"));
  }
}
</pre>

<p>
`print()^c 関数は、次と同様の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
text/plain; charset=UTF-8
</pre>

</div>

			</section>
			<section id="the-getallresponseheaders()-method">
<h4 title="The getAllResponseHeaders() method">4.6.5. `getAllResponseHeaders()^m ~method</h4>

<div class="algo">
<p>
`getAllResponseHeaders()@m
~method手続きは：
◎
A byte sequence a is legacy-uppercased-byte less than a byte sequence b if the following steps return true:
• Let A be a, byte-uppercased.
• Let B be b, byte-uppercased.
• Return A is byte less than B.
↓
◎
The getAllResponseHeaders() method, when invoked, must run these steps:
</p>
<ol>
	<li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>
	<li>
%初期~header~list ~LET `~header~listを~sortして結合する$( `応答$の`~header~list$rs )
◎
Let initialHeaders be the result of running sort and combine with response’s header list.
</li>
<li>
<p>
%~header~list ~LET `~listを昇順に~sortする$( %初期~header~list, 次に与える`小なり~algo$ )
◎
Let headers be the result of sorting initialHeaders in ascending order, with＼
</p>

<p id="legacy-uppercased-byte-less-than">
この小なり~algoは、所与の 2 つの~header ( %a, %b ) に対し，［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
`~byte大文字~化する$( %a の`名前$hd )
は
`~byte大文字~化する$( %b の`名前$hd )
`未満の~byte列$である
◎
a being less than b if a’s name is legacy-uppercased-byte less than b’s name.
（↑）
</p>

<p class="note">注記：
あいにく，この段は、配備-済み内容との互換性を得るため必要になる。
◎
Unfortunately, this is needed for compatibility with deployed content.
</p>
	</li>
	<li>
<p>
%~header~list 内の~EACH( %~header ) に対し
⇒
%出力 に次を順に付加する
⇒＃
%~header の`名前$hd,
~byte対 `3A^X `20^X,
%~header の`値$hd,
~byte対 `0D^X `0A^X
◎
For each header in headers, append header’s name, followed by a 0x3A 0x20 byte pair, followed by header’s value, followed by a 0x0D 0x0A byte pair, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters response’s header list. [FETCH]
</p>

</div>

<div class="example" id="example-getresponseheaders">

<p>
次の~scriptに対し：
◎
For the following script:
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest();
%client.open("GET", "narwhals-too.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(this.getAllResponseHeaders());
  }
}
</pre>

<p><!-- copy -->
`print()^c 関数は、次と同類の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre class="lang-http">
connection: Keep-Alive
content-type: text/plain; charset=utf-8
date: Sun, 24 Oct 2004 04:58:38 GMT
keep-alive: timeout=15, max=99
server: Apache/1.3.31 (Unix)
transfer-encoding: chunked
</pre>

</div>

			</section>
			<section id="response-body">
<h4 title="Response body">4.6.6. 応答~本体</h4>

<div class="algorithm">
<p>
`応答~MIME型@
は、次を走らせた結果で与えられる：
◎
The response MIME type is the result of running these steps:
</p>

<ol>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( `応答$の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
~RET ［
%~MIME型 ~EQ `失敗^i ならば `text/xml^lb ／
~ELSE_ %~MIME型
］
◎
If mimeType is failure, then set mimeType to text/xml.
◎
Return mimeType.
</li>
</ol>
</div>

<p>
`上書き~MIME型@
は、初期~時は ~NULL とする
— それは、 `overrideMimeType()$m を呼出したときに，非 ~NULL にされ得る。
◎
The override MIME type is initially null and can get a value when overrideMimeType() is invoked.＼
</p>

<div class="algorithm">
<p>
`最終~MIME型@
は、［
`上書き~MIME型$ ~NEQ ~NULL ならば それ ／
~ELSE_ `応答~MIME型$
］を返す。
◎
The final MIME type is the override MIME type unless that is null in which case it is the response MIME type.
</p>
</div>

<div class="algorithm">
<p>
`最終~charset@
は、次の手続きが返す値である：
◎
The final charset is the return value of these steps:
</p>

<ol>
	<li>
%~label ~LET ［
`上書き~MIME型$の`~parameter~map$[ `charset^l ] ~NEQ ε ならば それ ／
~ELSE_ `応答~MIME型$の`~parameter~map$[ `charset^l ]
］
◎
Let label be null.
◎
If response MIME type’s parameters["charset"] exists, then set label to it.
◎
If override MIME type’s parameters["charset"] exists, then set label to it.
</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
~RET ~NULL
◎
If label is null, then return null.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%符号化法 ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If encoding is failure, then return null.
</li>
	<li>
~RET %符号化法
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
上の手続きが`最終~MIME型$を利用しないのは、意図的である
— そうすると間違った結果を得ることになるので。
◎
The above steps intentionally do not use the final MIME type as it would yield the wrong result.
</p>
</div>

<hr>

<p>
各 `XMLHttpRequest$I ~objには、
`応答~obj@
が結付けられる
— それは、［
~obj, `失敗^i, ~NULL
］のいずれかをとり，他が言明されない限り ~NULL とする。
◎
An XMLHttpRequest object has an associated response object (an object, failure, or null). Unless stated otherwise it is null.
</p>

<hr>

<div class="algorithm">
<p>
`~arraybuffer応答@
は、次の手続きが返す値である：
◎
An arraybuffer response is the return value of these steps:
</p>

<ol>
	<li>
<div class="p">
<p>
`応答~obj$ ~SET `受信した~byte列$を表現する，新たな `ArrayBuffer$I ~obj
— ただし、例外が投出された場合は：
</p>

<ol ><li>`応答~obj$ ~SET `失敗^i
</li><li>~RET ~NULL
</li></ol>

◎
Set response object to a new ArrayBuffer object representing received bytes. If this throws an exception, then set response object to failure and return null. 
</div>

<p class="note">注記：
`ArrayBuffer$I ~objを割振ることの成功-は、保証されない。
`ECMASCRIPT$r
◎
Allocating an ArrayBuffer object is not guaranteed to succeed. [ECMASCRIPT]
</p>
	</li>
	<li>
~RET `応答~obj$
◎
Return response object.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~blob応答@
は、次の手続きが返す値である：
◎
A blob response is the return value of these steps:
</p>

<ol>
	<li>
`応答~obj$ ~SET `受信した~byte列$を表現する，次のようにされた新たな `Blob$I ~obj
⇒
`~type0$m ~SET `最終~MIME型$
◎
Set response object to a new Blob object representing received bytes with type set to the final MIME type.
</li>
	<li>
~RET `応答~obj$
◎
Return response object.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`文書~応答@
は、次の手続きが返す値（`文書$, または ~NULL ）である：
◎
A document response is the return value of these steps:
</p>

<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response’s body is null, then return null.
</li>
	<li>
~IF［
`最終~MIME型$は、`~HTML~MIME型$でも, `~XML~MIME型$でもない
］
⇒
~RET ~NULL
◎
If the final MIME type is not an HTML MIME type or an XML MIME type, then return null.
</li>
	<li>
<p>
~IF［
`responseType$m ~EQ 空~文字列
］~AND［
`最終~MIME型$は`~HTML~MIME型$である
］
⇒
~RET ~NULL
◎
If responseType is the empty string and the final MIME type is an HTML MIME type, then return null.
</p>

<p class="note">注記：
旧来の内容を壊さないようにするため、ここでは
`responseType$m は `document^l に制約される。
◎
This is restricted to responseType being "document" in order to prevent breaking legacy content.
</p>
	</li>
	<li>
<p>
~IF［
`最終~MIME型$は`~HTML~MIME型$である
］：
◎
If the final MIME type is an HTML MIME type, then:
</p>
		<ol>
			<li>
%charset ~LET ［
`最終~charset$ ~NEQ ~NULL ならば それ ／
~ELSE_ ［
`受信した~byte列$の最初の 1024 ~byteを
<a href="~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding">予走査して</a>
成功裡に結果を得られた
］ならば その結果 ／ 
~ELSE_ `~UTF-8$
］
◎
Let charset be the final charset.
◎
If charset is null, prescan the first 1024 bytes of received bytes and if that does not terminate unsuccessfully then let charset be the return value.
◎
If charset is null, then set charset to UTF-8.
</li>
			<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
~HTML標準の~HTML構文解析に~~規定される規則に従って，［
~scriptは不能化する,
<a href="~HTMLparsing#a-known-definite-encoding">既知かつ確定的な符号化法</a>として 
%charset を与える
］下で，`受信した~byte列$を構文解析した結果
`HTML$r
◎
Let document be a document that represents the result parsing received bytes following the rules set forth in the HTML Standard for an HTML parser with scripting disabled and a known definite encoding charset. [HTML]
</li>
			<li>
%文書 の`種別$doc ~SET `html^l
◎
Flag document as an HTML document.
</li>
		</ol>
	</li>
	<li>
<div>
<p>
~ELSE：
</p>
		<ol>
			<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
<a href="~HTMLxml#xml-scripting-support-disabled">~XML~script~supportを不能化する</a>下で，`受信した~byte列$を
<a href="~HTMLxml#xml-parser">~XML構文解析器</a>
にかけた結果
`HTML$r
</li>
			<li>
~IF［
前~段にて
構文解析に失敗した（例：未~supportな文字~符号化法, 名前空間整形式~error, 等々）
］
⇒
~RET ~NULL
</li>
		</ol>
◎
Otherwise, let document be a document that represents the result of running the XML parser with XML scripting support disabled on received bytes. If that fails (unsupported character encoding, namespace well-formedness error, etc.), then return null. [HTML]
</div>

<p class="note">注記：
文書から参照されている資源は読込まれず,
文書に結付けられている XSLT は適用されない。
◎
Resources referenced will not be loaded and no associated XSLT will be applied.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
%文書 の
⇒＃
`符号化法$ ~SET %charset,
`内容型$ ~SET `最終~MIME型$,
`~URL$ ~SET `応答$の`~URL$rs,
`生成元$doc ~SET コレに`関連な設定群~obj$の`生成元$enV
◎
Set document’s encoding to charset.
◎
Set document’s content type to the final MIME type.
◎
Set document’s URL to response’s url.
◎
Set document’s origin to context object’s relevant settings object’s origin.
</li>
	<li>
`応答~obj$ ~SET %文書
◎
Set response object to document and return it.
</li>
	<li>
~RET %文書
◎
↑</li>
</ol>
</div>

<div class="algorithm">
<p>
`~JSON応答@
は、次の手続きが返す値である：
◎
A JSON response is the return value of these steps:
</p>

<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response’s body is null, then return null.
</li>
	<li>
<p>
%~JSON~obj ~LET
`~byte列を~JSONとして構文解析する$( `受信した~byte列$ )
</p>

<p>
例外が投出されたときは
⇒
~RET ~NULL
</p>
◎
Let jsonObject be the result of running parse JSON from bytes on received bytes. If that threw an exception, then return null.
</li>
	<li>
`応答~obj$ ~SET %~JSON~obj
◎
Set response object to jsonObject and return it.
</li>
	<li>
~RET %~JSON~obj
◎
↑</li>
</ol>
</div>

<div class="algorithm">
<p>
`~text応答@
は、次の手続きが返す値である：
◎
A text response is the return value of these steps:
</p>

<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If response’s body is null, then return the empty string.
</li>
	<li>
%charset ~LET
`最終~charset$
◎
Let charset be the final charset.
</li>
	<li>
<p>
~IF［
`responseType$m ~EQ 空~文字列
］~AND［
%charset ~EQ ~NULL
］~AND［
`最終~MIME型$は`~XML~MIME型$である
］
⇒
%charset ~LET
~XML仕様に~~規定される規則に従って決定される符号化法
`XML$r
`XMLNS$r
◎
If responseType is the empty string, charset is null, and the final MIME type is an XML MIME type, then use the rules set forth in the XML specifications to determine the encoding. Let charset be the determined encoding. [XML] [XMLNS] 
</p>

<p class="note">注記：
旧来のものでない `responseType$m 値 `text^l を単純なままに保つため、ここでは `responseType$m は空~文字列に制約される。
◎
This is restricted to responseType being the empty string to keep the non-legacy responseType value "text" simple.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL 
］
⇒
%charset ~SET `~UTF-8$
◎
If charset is null, then set charset to UTF-8.
</li>
	<li>
~RET `~Unicodeに復号する$( `受信した~byte列$, %charset )
◎
Return the result of running decode on received bytes using fallback encoding charset.
</li>
</ol>
</div>

<p class="note">注記：
作者には、資源を符号化する際には，常に`~UTF-8$ を利用することが強く奨励される。
◎
Authors are strongly encouraged to always encode their resources using UTF-8.
</p>

			</section>
			<section id="the-overridemimetype()-method">
<h4 title="The overrideMimeType() method">4.6.7. `overrideMimeType()^m ~method</h4>

<dl class="domintro">
	<dt>%client . `overrideMimeType(mime)$m</dt>
	<dd>
`応答$の `Content-Type$h ~header値が %mime であったかのように動作する。
（実際に~headerを変更するわけではないが。）
◎
Acts as if the `Content-Type` header value for response is mime. (It does not actually change the header though.)
</dd>
	<dd>
`状態$ ~IN { `~loading^i, `~done^i } の場合、
`InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if state is loading or done.
</dd>
</dl>

<div class="algo">
<p>
`overrideMimeType(mime)@m
~method手続きは：
◎
The overrideMimeType(mime) method, when invoked, must run these steps:
</p>
<ol>
	<li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError$E
◎
If state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
`上書き~MIME型$ ~SET `~MIME型を構文解析する$( %mime )
◎
Set override MIME type to the result of parsing mime.
</li>
	<li>
~IF［
`上書き~MIME型$ ~EQ `失敗^i
］
⇒
`上書き~MIME型$ ~SET `application/octet-stream^lb
◎
If override MIME type is failure, then set override MIME type to application/octet-stream.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetype-attribute">
<h4 title="The responseType attribute">4.6.8. `responseType^m 属性</h4>

<dl class="domintro">

	<dt>%client . `responseType$m [ = %value ]</dt>
	<dd>
応答の種別を返す。
◎
Returns the response type.
</dd>
	<dd>
設定して、応答の種別を変更できる。
値は次のいずれか
⇒
空~文字列 （既定）,
`arraybuffer^l,
`blob^l,
`document^l,
`json^l,
`text^l
◎
Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
</dd>
	<dd>
<p>
設定子においては：
◎
↓</p>
		<ul>
			<li>
`現在の大域~obj$は `Window$I ~objでない場合、
`document^l に設定しても無視される。
◎
When set: setting to "document" is ignored if current global object is not a Window object.
</li>
			<li>
`状態$ ~IN { `~loading^i, `~done^i } の場合、
`InvalidStateError$E 例外が投出される。
◎
When set: throws an "InvalidStateError" DOMException if state is loading or done.
</li>
			<li>
`同期~flag$ ~EQ ~T, かつ
`現在の大域~obj$は `Window$I ~objである場合、
`InvalidAccessError$E 例外が投出される。
◎
When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
</li>
		</ul>
	</dd>
</dl>

<div class="algo">
`responseType@m
取得子~手続きは、最後に設定された値を返す。
◎
The responseType attribute must return its value.＼
</div>

<p>
`responseType$m 属性は、初期~時には空~文字列に設定されるモノトスル。
◎
Initially its value must be the empty string.
</p>

<div class="algo">
<p>
`responseType$m 設定子~手続きは：
◎
Setting the responseType attribute must run these steps:
</p>
<ol>
	<li>
%W ~LET ［
`現在の大域~obj$は `Window$I ~objであるならば ~T ／
~ELSE_ ~F
］
◎
↓</li>
	<li>
~IF［
%W ~EQ ~F
］~AND［
所与の値 ~EQ `document^l
］
⇒
~RET
◎
If current global object is not a Window object and the given value is "document", terminate these steps.
</li>
	<li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError$E
◎
If state is loading or done, then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%W ~EQ ~T
］~AND［
`同期~flag$ ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If current global object is a Window object and the synchronous flag is set, then throw an "InvalidAccessError" DOMException.
</li>
	<li>
この属性の値 ~SET 所与の値
◎
Set the responseType attribute’s value to the given value.
</li>
</ol>
</div>

			</section>
			<section id="the-response-attribute">
<h4 title="The response attribute">4.6.9. `response^m 属性</h4>

<dl class="domintro">
	<dt>%client . `response$m</dt>
	<dd>
`応答$の`本体$rsを返す。
◎
Returns the response’s body.
</dd>
</dl>

<div class="algo">
<p>
`response@m
取得子~手続きは：
◎
The response attribute must return the result of running these steps:
</p>
<ol>
	<li>
%応答~種別 ~LET コレの `responseType$m の値
◎
↓</li>
	<li>
~IF［
%応答~種別 ~IN { 空~文字列, `text^l }
］
⇒
~RET［
`状態$ ~NIN { `~loading^i, `~done^i } ならば空~文字列 ／
~ELSE_ `~text応答$
］
◎
If responseType is the empty string or "text"
◎
• If state is not loading or done, return the empty string.
◎
• Return the text response.
</li>
	<li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
Otherwise
◎
If state is not done, return null.
</li>
	<li>
~IF［
`応答~obj$ ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If response object is failure, then return null.
</li>
	<li>
~IF［
`応答~obj$ ~NEQ ~NULL
］
⇒
~RET `応答~obj$
◎
If response object is non-null, then return it.
</li>
	<li>
~RET %応答~種別 に応じて
⇒＃
`arraybuffer^l ならば`~arraybuffer応答$ ／
`blob^l ならば`~blob応答$ ／
`document^l ならば`文書~応答$ ／
`json^l ならば`~JSON応答$
◎
If responseType is "arraybuffer"
• Return the arraybuffer response.
If responseType is "blob"
• Return the blob response.
If responseType is "document"
• Return the document response.
If responseType is "json"
• Return the JSON response.
</li>
</ol>
</div>

			</section>
			<section id="the-responsetext-attribute">
<h4 title="The responseText attribute">4.6.10. `responseText^m 属性</h4>

<dl class="domintro">
	<dt>%client . `responseText$m</dt>
	<dd>
`~text応答$を返す。
◎
Returns the text response.
</dd>
	<dd>
`responseType$m ~NEQ 空~文字列, かつ ~NEQ `text^l の場合、
`InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".
</dd>
</dl>

<div class="algo">
<p>
`responseText@m
取得子~手続きは：
◎
The responseText attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレの `responseType$m の値 ~NIN { 空~文字列, `text^l }
］
⇒
~THROW `InvalidStateError$E
◎
If responseType is not the empty string or "text", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~RET［
`状態$ ~NIN { `~loading^i, `~done^i } ならば空~文字列 ／
~ELSE_ `~text応答$
］
◎
If state is not loading or done, then return the empty string.
◎
Return the text response.
</li>
</ol>
</div>

			</section>
			<section id="the-responsexml-attribute">
<h4 title="The responseXML attribute">4.6.11. `responseXML^m 属性</h4>

<dl class="domintro">
	<dt>%client . `responseXML$m</dt>
	<dd>
`文書~応答$
を返す。
◎
Returns the document response.
</dd>
	<dd>
`responseType$m 値が
空~文字列でも `document^l でもない場合、
`InvalidStateError$E 例外が投出される。
◎
Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".
</dd>
</dl>

<div class="algo">
<p>
`responseXML@m
取得子~手続きは：
◎
The responseXML attribute must return the result of running these steps:
</p>
<ol>
	<li>
~IF［
コレの `responseType$m 値 ~NIN  { 空~文字列, `document^l }
］
⇒
~THROW `InvalidStateError$E
◎
If responseType is not the empty string or "document", then throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
If state is not done, return null.
</li>
	<li>
~Assert：
`応答~obj$ ~NEQ `失敗^i
◎
Assert: response object is not failure.
</li>
	<li>
~IF［
`応答~obj$ ~NEQ ~NULL
］
⇒
~RET `応答~obj$
◎
If response object is non-null, then return it.
</li>
	<li>
~RET `文書~応答$
◎
Return the document response.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="events">
<h3 title="Events summary">4.7. ~event要覧</h3>

~INFORMATIVE

<p>
以下の~eventが［
`XMLHttpRequest$I ／ `XMLHttpRequestUpload$I
］~objに向けて配送される：
◎
The following events are dispatched on XMLHttpRequest or XMLHttpRequestUpload objects:
</p>

<table><thead>
<tr><th>~event名
◎
Event name
<th>~interface
◎
Interface
<th>配送-時機
◎
Dispatched when…
</thead><tbody>

<tr><td>`readystatechange@et
<td>`Event$I
<td>
`readyState$m 属性の値が変化したとき。
ただし， `UNSENT$m に変化したときは除く。
◎
The readyState attribute changes value, except when it changes to UNSENT.

<tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
~fetchが起動されたとき。
◎
The fetch initiates.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
~dataを伝送-中のとき。
◎
Transmitting data.

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
~fetchが中止されたとき。
例えば， `abort()$m ~methodの呼出ngなど。
◎
When the fetch has been aborted. For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
~fetchに失敗したとき。
◎
The fetch failed.

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
~fetchに成功したとき。
◎
The fetch succeeded.

<tr><td>`timeout@et
<td>`ProgressEvent$I
<td>
~fetchが完了する前に `timeout$m に指定される時間を過ぎたとき。
◎
The author specified timeout has passed before the fetch completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
~fetchが完了したとき（成功, 失敗, いずれに関わらず）。
◎
The fetch completed (success or failure).

</tbody>
</table>

		</section>
		<section id="feature-policy-integration">
<h3 title="Feature Policy Integration">4.8. 許可~施策【！特能~施策】の統合</h3>

<p>
この仕様は、［
文字列
`sync-xhr@l
で識別される，`施策により制御される特能$
］を定義する。
その`既定の許容list$は `*^c とする。
◎
This specification defines a policy-controlled feature identified by the string "sync-xhr". Its default allowlist is *.
</p>

		</section>
	</section>
	<section id="interface-formdata">
<h2 title="Interface FormData">5. ~interface `FormData^I</h2>

<pre class="idl">
typedef (`File$I or `USVString$) `FormDataEntryValue@I;

[`Exposed$=(Window,Worker)]
interface `FormData@I {
  `FormData$mc(optional `HTMLFormElement$I %form);

  `undefined$ `append$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `append$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `undefined$ `delete$m(`USVString$ %name);
  `FormDataEntryValue$I? `get$m(`USVString$ %name);
  sequence&lt;`FormDataEntryValue$I&gt; `getAll$m(`USVString$ %name);
  `boolean$ `has$m(`USVString$ %name);
  `undefined$ `set$m(`USVString$ %name, `USVString$ %value);
  `undefined$ `set$m(`USVString$ %name, `Blob$I %value, optional `USVString$ %filename);
  `iterable$m&lt;`USVString$, `FormDataEntryValue$I&gt;;
};</pre>

<p>
各 `FormData$I ~objには、
`~entry~list@fe
が結付けられる
— それは、何個かの`~entry$feからなる`~list$であり，初期~時には空とする。
◎
Each FormData object has an associated entry list (a list of entries). It is initially the empty list.
</p>

<p>
各
`~entry@fe
は、
`名前@fe,
`値@fe
からなる。
◎
An entry consists of a name and a value.
</p>

<p>
他の~algoとヤリトリする目的においては、`~entry$feの~filenameは［
`~entry$feの`値$feが `File$I ~objであるならば その `name$m 属性~値 ／
~ELSE_ 空~文字列
］とする。
◎
For the purposes of interaction with other algorithms, an entry’s filename is the empty string if value is not a File object, and otherwise its filename is the value of entry’s value’s name attribute.
</p>

<div class="algorithm">
<p>
`~entryを作成する@
ときは、所与の
( %名前, %値, %~filename （省略-時は ε ）)
に対し，次を走らす：
◎
To create an entry for name, value, and optionally a filename, run these steps:
</p>

<ol>
	<li>
%~entry ~LET 新たな`~entry$fe
◎
Let entry be a new entry.
</li>
	<li>
%~entry の`名前$fe ~SET %名前
◎
Set entry’s name to name.
</li>
	<li>
<p>
~IF［
%値 は `Blob$I ~objである
］~AND［［
%値 は `File$I ~objでない
］~OR［
%~filename ~NEQ ε
］］：
</p>
		<ol>
			<li>
%値 ~SET  %値 と同じ~byte列を表現する新たな `File$I ~obj
</li>
			<li>
%値 の `name$m 属性~値 ~SET ［
%~filename ~NEQ ε ならば %~filename ／
~ELSE_ `blob^l
］
</li>
		</ol>

◎
If value is a Blob object and not a File object, then set value to a new File object, representing the same bytes, whose name attribute value is "blob".
◎
If value is (now) a File object and filename is given, then set value to a new File object, representing the same bytes, whose name attribute value is filename.
</li>
	<li>
%~entry の`値$fe ~SET %値
◎
Set entry’s value to value.
</li>
	<li>
~RET %~entry
◎
Return entry.
</li>
</ol>
</div>

<div class="algo">
<p>
`new FormData(form)@m
構築子~手続きは：
◎
The FormData(form) constructor must run these steps:
• Let fd be a new FormData object.
</p>
<ol>
	<li>
~IF［
%form ~EQ ε
］
⇒
~RET
◎
If form is given, then:
</li>
	<li>
%~list ~LET `~entry~listを構築する$( %form )
◎
Let list be the result of constructing the entry list for form.
</li>
	<li>
~IF［
%~list ~EQ ~NULL
］
⇒
~THROW `InvalidStateError$E
◎
If list is null, then throw an "InvalidStateError" DOMException.
</li>
	<li>
コレの`~entry~list$fe ~SET ~SET %~list
◎
Set fd’s entry list to list.
◎
Return fd.
</li>
</ol>
</div>

<div class="algo">
<p>
`append(name, value, filename)@m
~method手続きは：
◎
The append(name, value) and append(name, blobValue, filename) methods, when invoked, must run these steps: 
◎
Let value be value if given, and blobValue otherwise.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
コレの`~entry~list$feに %~entry を`付加する$
◎
Append entry to the context object’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<div class="algo">
`delete(name)@m
~method手続きは
⇒
コレの`~entry~list$feから 次を満たす`~entry$feをすべて`除去する$
⇒
`名前$fe ~EQ %name
◎
The delete(name) method, when invoked, must remove all entries whose name is name from the context object’s entry list.
</div>

<div class="algo">
`get(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内に 次を満たす`~entry$feは［
在るならば それらのうち最初のものの`値$fe ／
無いならば ~NULL
］
⇒
`名前$fe ~EQ %name
◎
The get(name) method, when invoked, must return the value of the first entry whose name is name from the context object’s entry list, and null otherwise.
</div>

<div class="algo">
`getAll(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内の［
次を満たす`~entry$feすべての`値$fe
］からなる同順の~list（無ければ空~list）
⇒
`名前$fe ~EQ %name
◎
The getAll(name) method, when invoked, must return the values of all entries whose name is name, in order, from the context object’s entry list, and the empty list otherwise.
</div>

<div class="algo">
`has(name)@m
~method手続きは
⇒
~RET コレの`~entry~list$fe内に 次を満たす`~entry$feは［
在るならば ~T ／
無いならば ~F
］
⇒
`名前$fe ~EQ %name
◎
The has(name) method, when invoked, must return true if there is an entry whose name is name in the context object’s entry list, and false otherwise.
</div>

<div class="algo">
<p>
`set(name, value, filename)@m
~method手続きは：
◎
The set(name, value) and set(name, blobValue, filename) methods, when invoked, must run these steps:
◎
Let value be value if given, and blobValue otherwise.
</p>
<ol>
	<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
	<li>
<p>
~IF［
コレの`~entry~list$fe内に次を満たす`~entry$feは在る
］…
⇒
`名前$fe ~EQ %name
</p>

<p>
…ならば
⇒
該当する`~entry$feのうち
⇒＃
最初のものは %~entry に`置換する$,
他のものはすべて`除去する$
</p>
◎
If there are any entries in the context object’s entry list whose name is name, then replace the first such entry with entry and remove the others.
</li>
	<li>
~ELSE
⇒
コレの`~entry~list$feに %~entry を`付加する$
◎
Otherwise, append entry to the context object’s entry list.
</li>
</ol>

<p>
◎
（和訳には不要なメタ情報）
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>
</div>

<p>
`iterable@m
における`反復される値~pairたち$を成す各~pairを成す
( ~key, 値 )
は、コレの`~entry~list$feを成す各`~entry$feの
( `名前$fe, `値$fe )
で与えられるとする。
◎
The value pairs to iterate over are the context object’s entry list’s entries with the key being the name and the value being the value.
</p>

	</section>
	<section id="interface-progressevent">
<h2 title="Interface ProgressEvent">6. ~interface `ProgressEvent^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `ProgressEvent@I : `Event$I {
  `ProgressEvent@mc(`DOMString$ %type, optional `ProgressEventInit$I %eventInitDict = {});

  readonly attribute `boolean$ `lengthComputable$m;
  readonly attribute `unsigned long long$ `loaded$m;
  readonly attribute `unsigned long long$ `total$m;
};

dictionary `ProgressEventInit@I : `EventInit$I {
  `boolean$ `lengthComputable@mb = false;
  `unsigned long long$ `loaded@mb = 0;
  `unsigned long long$ `total@mb = 0;
};</pre>

<p>
`ProgressEvent$I ~interfaceを利用する`~event$は、何らかの進捗を指示する。
◎
Events using the ProgressEvent interface indicate some kind of progression.
</p>

<div class="algo">
`lengthComputable@m,
`loaded@m,
`total@m
取得子~手続きは、いずれも，各自の初期化-時の値を返す。
◎
The lengthComputable, loaded, and total attributes must return the value they were initialized to.
</div>

		<section id="firing-events-using-the-progressevent-interface">
<h3 title="Firing events using the ProgressEvent interface">6.1. `ProgressEvent^I ~interfaceを利用する~eventの発火-法</h3>

<p>
%target に向けて，名前 %e の
`進捗~eventを発火する@
ときは、所与の
( %伝送量, %長さ )
に対し
⇒
%target に向けて，名前 %e の`~eventを発火する$
— `ProgressEvent$I を利用し，次のように初期化して
⇒＃
`loaded$m 属性~値 ~SET %伝送量,
`lengthComputable$m 属性~値 ~SET ［ %長さ ~NEQ 0 ならば ~T ／ ~ELSE_ ~F ］,
`total$m 属性~値 ~SET %長さ
◎
To fire a progress event named e at target, given transmitted and length, means to fire an event named e at target, using ProgressEvent, with the loaded attribute initialized to transmitted, and if length is not 0, with the lengthComputable attribute initialized to true and the total attribute initialized to length.
</p>

		</section>
		<section id="suggested-names-for-events-using-the-progressevent-interface">
<h3 title="Suggested names for events using the ProgressEvent interface">6.2. `ProgressEvent^I ~interfaceを利用する~eventに示唆される名前</h3>

~INFORMATIVE

<p>
`ProgressEvent$I ~interfaceを利用する`~event$に示唆される， `type$m 属性の値を、下の一覧に要約する。
仕様の編集者が，その仕様に固有の仔細に応じて~~調整することは自由であるが、~~問題に馴染みのある人達からの~~意見を汲むために，その用法について WHATWG ~communityにて論を交わすことが強く奨励される。
◎
The suggested type attribute values for use with events using the ProgressEvent interface are summarized in the table below. Specification editors are free to tune the details to their specific scenarios, though are strongly encouraged to discuss their usage with the WHATWG community to ensure input from people familiar with the subject.
</p>

<table><thead>
<tr><th>`type$m
◎
type attribute value
<th>記述
◎
Description
<th>回数
◎
Times
<th>時機
◎
When
</thead><tbody>

<tr><th>`loadstart$et
<td>
進捗が~~開始された。
◎
Progress has begun.
<td>1 回
◎
Once.
<td>最初。
◎
First.

<tr><th>`progress$et
<td>
進捗~中。
◎
In progress.
<td>1 回以上
◎
Once or more.
<td>
`loadstart$et が`配送-$された後。
◎
After loadstart has been dispatched.

<tr><th>`error$et
<td>進捗に失敗した。
◎
Progression failed.
<td rowspan="4" style="min-width:6em;">
高々 1 回<br>
（排他的）
◎
Zero or once (mutually exclusive).
<td rowspan="4">
最後の `progress$et が`配送-$された後。
◎
After the last progress has been dispatched.

<tr><th>`abort$et
<td>進捗は終了された。
◎
Progression is terminated.

<tr><th>`timeout$et
<td>
進捗は時間~切れに因り終了された。
◎
Progression is terminated due to preset time expiring.

<tr><th>`load$et
<td>進捗は成功裡に終わった。
◎
Progression is successful.

<tr><th>`loadend$et
<td>進捗は停止された。
◎
Progress has stopped.
<td>1 回
◎
Once.
<td>
`error$et, `abort$et, `timeout$et, `load$et のいずれかが`配送-$された後。
◎
After one of error, abort, timeout or load has been dispatched.

</tbody></table>

<p>
~event型
`error$et, `abort$et, `timeout$et, `load$et
は、互いに排他的である。
<!-- 
【これら 4 種のいずれかは 1 回 生じる】
 -->
◎
The error, abort, timeout, and load event types are mutually exclusive.
</p>

<p>
Web ~platform全般に渡り，~event型
`error$et, `abort$et, `timeout$et, `load$et
の `bubbles$m および `cancelable$m 属性は、 ~F に初期化される。
従って，一貫性を保つため、 `ProgressEvent$I ~interfaceを利用するすべての`~event$も同様にすることが示唆される。
◎
Throughout the web platform the error, abort, timeout and load event types have their bubbles and cancelable attributes initialized to false, so it is suggested that for consistency all events using the ProgressEvent interface do the same.
</p>

		</section>
		<section id="security-considerations">
<h3 title="Security considerations">6.3. ~security上の考慮点</h3>

<p>
非同一-生成元~要請に対しては、例えば 
Fetch 標準にて定義される`~CORS~protocol$
などの，ある種の~opt-inが、 `ProgressEvent$I ~interfaceを利用する`~event$が`配送-$される前に利用される必要がある。
そうすると、他では得せない情報（例：~size）まで露呈されるので。
`FETCH$r
◎
For cross-origin requests some kind of opt-in, e.g. the CORS protocol defined in the Fetch Standard, has to be used before events using the ProgressEvent interface are dispatched as information (e.g. size) would be revealed that cannot be obtained otherwise. [FETCH]
</p>

		</section>
		<section id="example">
<h3 title="Example">6.4. 用例</h3>

<div class="example" id="example-progress-events">

<p>
次の例では、 `XMLHttpRequest$I に，前~節にて定義された概念が組合され、`~fetching$の過程の表示に~HTML `progress$e 要素が利用される。
◎
In this example XMLHttpRequest, combined with concepts defined in the sections before, and the HTML progress element are used together to display the process of fetching a resource.
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;title&gt;Waiting for Magical Unicorns&lt;/title&gt;
&lt;progress id=p&gt;&lt;/progress&gt;
&lt;script&gt;
  var %progressBar = document.getElementById("p"),
      %client = new XMLHttpRequest()
  %client.open("GET", "magical-unicorns")
  %client.onprogress = function(%pe) {
    if(%pe.lengthComputable) {
      %progressBar.max = %pe.total
      %progressBar.value = %pe.loaded
    }
  }
  %client.onloadend = function(%pe) {
    %progressBar.value = %pe.loaded
  }
  %client.send()
&lt;/script&gt;
</pre>

<p>
もちろん，全部的に~~機能する~codeは、より精巧かつ，~network~errorや末端利用者からの終了-要請など，より多くの局面に対応するものになるだろうが。
◎
Fully working code would of course be more elaborate and deal with more scenarios, such as network errors or the end user terminating the request.
</p>

</div>

		</section>
	</section>
	<section id="acknowledgments">
<h2>謝辞</h2>

<p>
この標準に貢献された、次の方々に感謝する：
</p>

<p lang="en-x-a0">
Thanks to

Addison Phillips,
Adrian Bateman,
Ahmed Kamel,
Alan Thomas,
Alex Hopmann,
Alex Vincent,
Alexey Proskuryakov,
Ali Alabbas,
Andrea Marchesini,
Asbjørn Ulsberg,
Bertrand Guay-Paquet,
Björn Höhrmann,
Boris Zbarsky,
Caitlin Potter,
Cameron McCormack,
白丞祐 (Cheng-You Bai),
Chris Marrin,
Christophe Jolif,
Charles McCathieNevile,
Dan Winship,
David Andersson,
David Flanagan,
David Håsäther,
David Levin,
Dean Jackson,
Denis Sureau,
Domenic Denicola,
Dominik Röttsches,
Doug Schepers,
Douglas Livingstone,
Elliott Sprehn,
Elliotte Harold,
Eric Lawrence,
Eric Uhrhane,
Erik Arvidsson,
Erik Dahlström,
Feras Moussa,
Gideon Cohn,
Glenn Adams,
Gorm Haug Eriksen,
Gregory Terzian,
Håkon Wium Lie,
Hallvord R. M. Steen,
Henri Sivonen,
Hiroshige Hayashizaki,
Huub Schaeks,
Ian Clelland,
Ian Davis,
Ian Hickson,
Ivan Herman,
Jake Archibald,
Jared Jacobs,
Jarred Nicholls,
Jeff Walden,
Jens Lindström,
Jim Deegan,
Jim Ley,
Joe Farro,
Jonas Sicking,
Julian Reschke,
송정기 (Jungkee Song),
呂康豪 (Kang-Hao Lu),
Karl Dubost,
Keith Yeung,
田村健人 (Kent TAMURA),
Lachlan Hunt,
Maciej Stachowiak,
Magnus Kristiansen,
Manish Goregaokar,
Marc Hadley,
Marcos Caceres,
Mark Baker,
Mark Birbeck,
Mark Nottingham,
Mark S. Miller,
Martin Hassman,
Mike Pennisi,
Mohamed Zergaoui,
Ms2ger,
Odin Hørthe Omdal,
Olli Pettay,
Pawel Glowacki,
Peter Michaux,
Philip Jägenstedt,
Philip Taylor,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Ryo Onodera,
Sam Sneddon,
Sergiu Dumitriu,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Stewart Brodie,
Sunava Dutta,
Takeshi Kurosawa,
Takeshi Yoshino,
Thomas Roessler,
Thomas Wisniewski,
Tom Magliery,
Travis Leithead,
triple-underscore,
Yaron Tausky,
Yehuda Katz,
Youenn Fablet, and
Zhenbin Xu

for their contributions to this standard.
</p>

<p>
Windows Internet Explorer にて初めて実装し、`XMLHttpRequest^I ~interfaceを最初に広めた Microsoft の開発者たちに特別な謝意を。
◎
Special thanks to the Microsoft employees who first implemented the XMLHttpRequest interface, which was first widely deployed by the Windows Internet Explorer browser.
</p>

<p>
HTML Standard （ Web Applications 1.0 ）にて、この仕様の初期~versionを草案~化された Ian Hickson 氏に特別な謝意を。
`HTML$r
◎
Special thanks to Ian Hickson for drafting an initial version of this specification in
the HTML Standard (then Web Applications 1.0). [HTML]
</p>

<p>
<a href="https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/svgudom.html">SVG Micro DOM</a>
の一部として、元々の `ProgressEvent^I ~classの草案を作成した W3C SVG WG に特別な謝意を。
◎
Special thanks to the W3C SVG WG for drafting the original ProgressEvent class as part of the SVG Micro DOM.
</p>

<p lang="en-x-a0">
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p lang="en-x-a0">
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.
</p>

	</section>
</main></div>
