<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS におけるカスケード法と継承 — CSS Cascading and Inheritance Level 4 （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<style>
samp {
	white-space: nowrap;
}

#_samples_matrix tr > * {
	vertical-align: top;
}

#_samples_matrix tr > *:nth-child(3) > * {
	display: inline-block;
	width: 0;
	white-space: nowrap;
}

#_samples_matrix tr > *:nth-child(n+4) {
	padding: 2em 0.2em 0;
	/* border-left: solid #EEE 1px; */
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%\w+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Cascading and Inheritance Level 4
spec_date:2020-09-10
trans_update:2020-09-12
source_checked:180621
page_state_key:CSS
original_url:https://drafts.csswg.org/css-cascade-4/
	original_url: 'https://www.w3.org/TR/css-cascade-4/'
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2020,permissive
trans_1st_pub:2012-07-07


●●class_map
p:property
at:at-rule
f:func
ps:pseudo
css:css
u:unit
v:value
t:type
P:production
e:element
a:attr

●●tag_map
p:code
v:code
f:code
at:code
ps:code
t:var
P:code
css:code
u:code
e:code
a:code
m:code
I:code
c:code
V:var
em:em

●●original_id_map

●●mdn_urls
propdef-all:CSS/all
at-ruledef-import:CSS/@import

●●words_table1


●●words_table

	●cascade
import:
important:
default::::デフォルト
	~default法:defaulting
cascaded::::カスケード
	~cascade法:cascading
	非略式:longhand::~

全域:wide::~
出現順序:order of appearance:~
順序関係:ordering:~
継承法:inheritance::~
宣言d:declared::宣言
絞込み:filtering::絞り込み
優先順位:precedence:~

	優先: win/takes precedence over/order of priority
	最優先:winning
	~~選定-:win/choose
	優先-
	優先度

巻戻し:rolling back::~
巻戻す:roll backする::~

出自:origin::~
詳細度:specificity::~

別名n:name alias::別名
別名化:aliasing::~
別名化-:alias::~

	適用-対象:applies to
	〜に算出される:computed
	~styleの算出d値:computed style

	●layout
flex:
駒:item:::アイテム
分断:break::~

	●CSS
CSSOM:
条件付き:conditional::~
無条件:unconditional::~
定義表:definition table:~
単位:unit::~
背景:background::~
色:color::~
呈示用:presentational:呈示
	欄:line

	~animateされた:animated
	媒体:medium

	●構文
区切子:delimiter::~
展開-:expand::~
展開:expansion::~
連結-:concatenate::~
丸括弧:parentheses:~
	接頭辞~付き:-prefixed

	●fetch／保安
Content-Type:
request::::リクエスト
	資源:file
自由:free:~
推定-:infer:~

	●仕様
競合:conflict:~
中核的:core:~
均衡:balance:~
透過的:transparent:~
可用性:availability:~
些末:trivial:~
理論的:theoretical:~
不注意:careless:~
不知に:inadvertentに:知らずに
適応-:accommodate:~
拡げる:expandする:~
依存性:dependencies:~
放棄-:abandon:~
響かす:impactする:~
吹飛:吹き飛
	吹飛ばす:blow away
黙示-:imply:~

	Level
	力の均衡:balance of power
	~化:ize
	どちらが〜されようが:regardless of whether
	〜な限り:as far as
	特能~support:feature-support
	個々の:particular
	:Incorporation of
	~~省ける:dropping
	こともある:may
	同様:like／similar
	同じく:As with
	同じに:
	重み:weight
	-:関わらず
	関係にある:relationship
	一括して:-
	一方で:but／:while／:whereas
	~~仕組み:By way of
	別として:-
	根底をなす:fundamental
	単に:simply
	段階
	意味
	意味的に:in meaning
	どうにかして:somehow
	手による:-
	の際に:in preparation for
	~~字義通りの~~意味:where it comes from
	ある:available
	ことになり得る:potentially
	可能になる:enable
	点で:in terms of
	加えて:furthermore
	であっても:nonetheless
	原則として:in principle
	に依存させ:–dependent
	expectations
	~~考慮:attempts to create
	考慮-:considerations in mind
	選ぶ:choose
	選ばれ:chosen
	選ばれ:-
	施した:made
	書き直せ:rewritten
	知れる:learned
	~~避け:-
	~~除外-:not qualified
	仕上げる:make
	仕立てる:be made
	記され:written
	要する:need
	記す:writing
	機能-:function
	課す:place
	調べれ:probing
	ほぼ違わない:almost exactly like

	●未分類
shadow:
light:
encapsulation::::カプセル化
平坦:flat::~
変形-:transform::~
翻訳-:translate:~
獲得-:acquire:~
近似-:approximate:~
稼働中:running 時:~
乗算-:multiply:~
代用-:substitute::~
accessor::::アクセス子
基準:reference:~
視覚系:visual:~
italic:
偽:false:~
携帯:handheld:~
推移的:transitive:~
入する:enterする:入る
仮想の:fictional:~

	-:slotted
	^en:case-mapping
	属-:belong／
	組み替え:manipulation
	括られ:wrapped
	持-
	挙げ:-
	指して:refer／to
	合間に〜挟まれ:intercepted
	置き換わる:result of putting
	取り込:import
	取り込:draw
	取り消:erasing
	増やす:increases
	戻す:-
	消失した:missing
	せずに済ませ:avoid
	満たす:satisfy
	現れ:appear
	現れ:-
	終えた:has
	経て:result of
	経る:process
	絞られ:-
	絞り:-
	絞る:-
	総称-:-
	置かれ:placed
	出現-:occurring
	呼ばれ:-
	及ぼし
	specification
	備える:possess
	その場で:in place
	場所:place
	そのまま:literally
	文字列そのまま:bare string
	白紙状態:blank slate
	準備が整った:ready
	主要な:major
	重い, あるいは並列化し難い:expensive or hard-to-parallelize operations
	比較照合-:collate:~
	整数幅の画素境界:borders with integer pixel widths
	行:line
	orphan 行数:how many orphan lines
	表:table
	行:line
	高
	高い:higher
	高いものから順に:in descending order
	~~導出-:-
	源とする:sourced form
	混ぜ合わせる:blend

	●指示語
古い:old:~
	外の
	多い
	多く
	左右-
	当該の
	大元の:originating
	後続-:follow
	後続の:-
	後述の:see below
	対象:target
	対象に:targetted by
	地点:at the point
	大きな:large
	最後:Finally
	最終的:final
	一連の:a set of／-
	一度だけ:only once
	の一つに:one of
	一切の:no
	こともある:sometimes
	以下
	以前:earlier
	以外
	個
	個以上
	各種:-
	種:-
	他方:-
	無い
	章:chapter
	節:section
	組
	より新しい:newer
	新たに:New in
	先行-:precede
	先頭に置かれ:placed at the start
	逆に:opposite
	逆に:invert
	当該:this
	間の
	~~仕組みを通して:By way of
	並び
	付け
	同時
	同順
	しばらくの間:for a while
	の下で:on par with
	時点:time
	それ以外の点では:They otherwise
	低い
	与え
	年
	幅
	応じて
	更に
	語
	限-
	引数:value

	●訳注
	原則的
	付記-
	捉えら
	連鎖的
	開始時
	補間
	変わらない
	全般
	共通
	句
	委譲
	考えら
	思われる
	本来は
	旨を
	曖昧に
	見られ
	見受け
	受け持つ:-
	誤解
	高次の
	限定-
	関連の
	意図的に
	概念
	概念的
	細分化-
	判断-
	辿った
	逆転-
	織り込んだ
	行われ
	処理規則
	言い換えれば
	要因
	参考
	発行時点
	役割
	少ない
	何が
	中間
	有無
	末端の
	所では
	順位
	順位付け


●●link_map



at.import:#at-ruledef-import
at.supports:~CSSCOND#at-ruledef-supports
at.media:~CSSCOND#at-ruledef-media
at.charset:~CSSSYN#at-ruledef-charset
at.namespace:~CSSNS#at-ruledef-namespace

pe.before:~CSSPSEUDO#selectordef-before
pe.after:~CSSPSEUDO#selectordef-after

p.all:#propdef-all

p.flex:~CSSFLEX#propdef-flex
p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.background-image:~CSSBG#propdef-background-image
p.border:~CSSBG#propdef-border
p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.border-image:~CSSBG#propdef-border-image
p.border-width:~CSSBG#propdef-border-width

p.break-before:~CSSBREAK#propdef-break-before
p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.orphans:~CSSBREAK#propdef-orphans

p.font-family:~CSSFONT#propdef-font-family
p.font-size-adjust:~CSSFONT#propdef-font-size-adjust
	~CSSWG/css-fonts-4
p.font-size:~CSSFONT#propdef-font-size
p.font-style:~CSSFONT#propdef-font-style
p.font-variant:~CSSFONT#propdef-font-variant
p.font-weight:~CSSFONT#propdef-font-weight
p.font:~CSSFONT#propdef-font

p.list-style-position:~CSSLIST#propdef-list-style-position
p.text-align:~CSSTEXT#propdef-text-align
p.text-indent:~CSSTEXT#propdef-text-indent

p.direction:~CSSWM#propdef-direction
	~TR/css3-writing-modes/#direction0
p.unicode-bidi:~CSSWM#propdef-unicode-bidi
	~TR/css3-writing-modes/#unicode-bidi0

p.height:~CSS2VISUDET#propdef-height
p.line-height:~CSS2VISUDET#propdef-line-height
p.page-break-after:~CSS22/page.html#propdef-page-break-after
p.width:~CSS2VISUDET#propdef-width
p.display:~CSSDISP#propdef-display
	~CSS2VISUREN#propdef-display
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y


v.initial:#valdef-all-initial
v.inherit:#valdef-all-inherit
v.unset:#valdef-all-unset
v.revert:#valdef-all-revert

v.handheld:~MQ5#valdef-media-handheld
	~CSS22/media.html#media-types

f.url:~CSSVAL#funcdef-url

t.url:~CSSVAL#url-value
t.string:~CSSVAL#string-value
t.media-query-list:~MQ5#typedef-media-query-list
t.media-query:#typedef-media-query
	t.media-query:~MQ5#typedef-media-query
t.supports-condition:#typedef-supports-condition
	t.supports-condition:~CSSCOND#typedef-supports-condition
t.declaration:#typedef-declaration

t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident-token:~CSSSYN#typedef-ident-token
t.delim-token:~CSSSYN#typedef-delim-token

P.supports_condition:~TR/css3-conditional/#supports_condition
	~CSSCOND#typedef-supports-condition
P.supports_declaration_condition:~TR/css3-conditional/#supports_declaration_condition
P.media_query_list:~TR/css3-mediaqueries/#syntax
	~MQ5#typedef-media-query-list
P.declaration:~CSS22/syndata.html#tokenization


u.em:~CSSVAL#em
u.ex:~CSSVAL#ex
u.vh:~CSSVAL#vh
u.vw:~CSSVAL#vw

css.!important:#importance

e.s:~HEtextlevel#the-s-element
a.dir:~HTMLdom#the-dir-attribute
e.slot:~HEscripting#the-slot-element

c.getComputedStyle():~CSSOM1#dom-window-getcomputedstyle


	●用語
~important:#important
~importantな宣言:#important
通常の宣言:#normal
~import条件:#import-conditions
~default法:#defaulting
	下の表:#stages-examples
~cascadeの出力:#output-of-the-cascade
~cascade:#cascade
~cascade法:#cascading
~cascaded値:#cascaded-value
略式~prop:#shorthand-property
下位prop:#longhand
設定し直すのみ:#reset-only-sub-property
旧来の別名n:#legacy-name-alias
旧来の略式~prop:#legacy-shorthand

継承:#inheritance
継承d~prop:#inherited-property
継承d値:#inherited-value
初期~値:#initial-value
算出d値:#computed-value
使用~値:#used-value
指定d値:#specified-value
実際の値:#actual-value
宣言d値:#declared-value

適用-対象:#applies-to
要素に適用され:#_applied-to

出自と重要度:#cascade-origin
文脈:#cascade-context
~encapsulation文脈:#encapsulation-contexts
詳細度:#cascade-specificity
出現順序:#cascade-order

出自:#origin
~UA出自:#cascade-origin-ua
作者~出自:#cascade-origin-author
利用者~出自:#cascade-origin-user
~animation出自:#cascade-origin-animation
遷移~出自:#cascade-origin-transition

	●用語（CSS
~CSS全域~keyword:~CSSVAL#common-keywords
~style属性:~CSSSTYLEATTR#style-attribute0
~supportする:~CSSCOND#support-definition
媒体~query:~MQ5#media-query
条件付き~group規則:~CSSCOND#conditional-group-rule

表示~型:~CSSDISP#display-type
匿名~box:~CSSDISP#anonymous
~box~tree:~CSSDISP#box-tree
~text~node:~CSSDISP#text-nodes
要素:~CSSDISP#elements

環境~符号化法:~CSSSYN#environment-encoding
~custom~prop:~CSSVAR#custom-property
解決d値:~CSSOM1#resolved-values
仮想の~tag列:~CSSPSEUDO#fictional-tag-sequence

~tree文脈:~CSSSCOPING#tree-context
平坦~化された要素~tree:~CSSSCOPING#flat-tree

~flex駒:~CSSFLEX#flex-item

	~CSS2VISUREN#box-gen
	~CSSWM#text-direction
	~SELECTORS4#specificity
	CSSImportRule.styleSheet
	~HTMLurl#content-type
	~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints
	~SVG11/styling.html#UsingPresentationAttributes


	●用語（他
~DOM~tree:~DOM4#concept-tree
~shadow~tree:~DOM4#concept-shadow-tree
~light~tree:~DOM4#concept-light-tree
~shadowも含む~tree順序:~DOM4#concept-shadow-including-tree-order
過去互換~mode:~DOM4#concept-document-quirks

~Content-Type~metadata:~HTMLurl#content-type
同一-生成元:~ORIGIN#same-origin
呈示~属性:~SVGstyling#TermPresentationAttribute
	~SVG11/styling.html#UsingPresentationAttributes

疑似要素:~SELECTORS4#pseudo-element


●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 4 December 2018. CR. URL: https://www.w3.org/TR/css-break-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 4. 13 November 2019. WD. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. CSS Lists Module Level 3. 9 July 2020. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 25 February 2019. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. CSS Scoping Module Level 1. 3 April 2014. WD. URL: https://www.w3.org/TR/css-scoping-1/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 29 April 2020. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-TRANSITIONS-1]
    David Baron; et al. CSS Transitions. 11 October 2018. WD. URL: https://www.w3.org/TR/css-transitions-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 10 December 2019. REC. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-CONDITIONAL]
    David Baron. CSS Conditional Rules Module Level 3. 4 April 2013. CR. URL: https://www.w3.org/TR/css3-conditional/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 21 July 2020. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[MEDIAQUERIES-5]
    Dean Jackson; Florian Rivoal; Tab Atkins Jr.. Media Queries Level 5. 31 July 2020. WD. URL: https://www.w3.org/TR/mediaqueries-5/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●ref_informative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. CSS Box Alignment Module Level 3. 21 April 2020. WD. URL: https://www.w3.org/TR/css-align-3/ 
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 November 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. CSS Flexible Box Layout Module Level 1. 19 November 2018. CR. URL: https://www.w3.org/TR/css-flexbox-1/ 
[CSS-PAGE-3]
    Elika Etemad; Simon Sapin. CSS Paged Media Module Level 3. 18 October 2018. WD. URL: https://www.w3.org/TR/css-page-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより公開された
<a href="~SPEC_URL">CSS Cascading and Inheritance Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-cascade-4/

編集者草案
	https://drafts.csswg.org/css-cascade/

以前のバージョン
	https://www.w3.org/TR/2020/WD-css-cascade-4-20200818/
	https://www.w3.org/TR/2018/CR-css-cascade-4-20180828/
	https://www.w3.org/TR/2016/CR-css-cascade-4-20160114/
	https://www.w3.org/TR/2015/WD-css-cascade-4-20150908/
	https://www.w3.org/TR/2015/WD-css-cascade-4-20150421/
	https://www.w3.org/TR/2013/WD-css-cascade-3-20130730/
	https://www.w3.org/TR/2013/WD-css3-cascade-20130103/
	https://www.w3.org/TR/2005/WD-css3-cascade-20051215/

最新の課題
	<a href="https://drafts.csswg.org/css-cascade/issues">Disposition of Comments</a>
	<a href="https://github.com/w3c/csswg-drafts/labels/css-cascade-4">GitHub</a>

編集
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/master/css-cascade-4/Overview.bs
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/css-cascade-4

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">CSS におけるカスケード法と継承 — CSS Cascading and Inheritance Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、~style規則を比較照合する方法, および
すべての要素の すべての~CSS~propに値をどうアテガうか、について述べる。
値は、`~cascade法$, および継承の~~仕組みを通して，すべての要素の すべての~propに伝播される。
◎
This CSS module describes how to collate style rules and assign values to all properties on all elements. By way of cascading and inheritance, values are propagated for all properties on all elements.
</p>

<p>
この~levelにて新たに定義されるものは、
`revert$v ~keyword, および［
`import$at 規則~用の `supports-condition$t
］である。
◎
New in this level are the revert keyword and &lt;supports-condition&gt; for the @import rule.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
`この節では、発行時点における…^em
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
最後の草案からの主要な変更点については、<a href="#changes">§ 変更点</a>に。
◎
For changes since the last draft, see the Changes section.
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの根底をなす設計原則の一つに`~cascade法$（ ~cascade処理規則, `cascading^en ）がある。
これにより、複数の~stylesheetを文書の呈示に波及させれるようになる。
同じ ［要素, ~prop］ の組合nに対し，複数の宣言が与えられている下での値の競合は、どうにかして解決する必要がある。
◎
One of the fundamental design principles of CSS is cascading, which allows several style sheets to influence the presentation of a document. When different declarations try to set a value for the same element/property combination, the conflicts must somehow be resolved.
</p>

<p>
逆に、 ［要素, ~prop］ の組合nに値を設定する宣言が無い場合についても，解決される必要がある。
この場合、値は，`継承$や~propの`初期~値$を通して見出される。
◎
The opposite problem arises when no declarations try to set a the value for an element/property combination. In this case, a value is be found by way of inheritance or by looking at the property’s initial value.
</p>

<p>
`~cascade法$と`~default法$を経ることにより，入力に与えられた一連の宣言から、各~要素の各~prop用の`指定d値$が出力される。
◎
The cascading and defaulting process takes a set of declarations as input, and outputs a specified value for each property on each element.
</p>

<p>
この仕様は、文書~内のすべての要素の すべての~propについて，それぞれの指定d値を見出すための規則を述べる。
~page文脈およびその~margin~boxの下で，指定d値を見出すための規則は、
`css-page-3$r にて述べられる。
◎
The rules for finding the specified value for all properties on all elements in the document are described in this specification. The rules for finding the specified values in the page context and its margin boxes are described in [css-page-3].
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
`この節は規範的である。^em
◎
This section is normative.
</p>

<p>
この~moduleは、
`CSS2$r § 6 に定義される［
~prop値のアテガわれ方, ~cascade法, 継承
］用の規則を置換して，それらを拡張する。
◎
This module replaces and extends the rules for assigning property values, cascading, and inheritance defined in [CSS2] chapter 6.
</p>

<p>
他の~CSS~moduleは、ここに定義される構文と特能の一部の定義を拡げるかもしれない。
例えば Media Queries Level 4 仕様は、この~moduleと組合せる下で，この仕様に利用される `media-query$t 値~型の定義を拡げる
◎
Other CSS modules may expand the definitions of some of the syntax and features defined here. For example, the Media Queries Level 4 specification, when combined with this module, expands the definition of the &lt;media-query&gt; value type as used in this specification.
</p>

<p>
この仕様の目的においては、`~text~node$は、それに結付けられている`要素$の子~要素であり，~propたちの全部的な集合を備えているものとする。
~text~nodeは 選択子の対象になれないので、その算出d値すべては，`~default法$を通してアテガわれる。
◎
For the purpose of this specification, text nodes are treated as element children of their associated element, and possess the full set of properties; since they cannot be targetted by selectors all of their computed values are assigned by defaulting.
</p>

		</section>
	</section>
	<section id="at-import">
<h2 title="Importing Style Sheets: the @import rule">2. ~stylesheetの~import法： `import^at 規則</h2>

<p>
`import@at
規則により，利用者は 他の~stylesheetから~style規則を~import（取り込む）できるようになる。
`import$at 規則が妥当な~stylesheetを指しているならば、
~UAは、次の 2 つの例外を除き，
`import$at 規則の場所にその内容が記されていたかのように扱うモノトスル：
◎
The @import rule allows users to import style rules from other style sheets. If an @import rule refers to a valid stylesheet, user agents must treat the contents of the stylesheet as if they were written in place of the @import rule, with two exceptions:
</p>
<ul>
	<li>
ある特能（ `namespace$at 規則など）が，［
適用されるのは特定0の~stylesheetに限られ，~importされたそれには適用されない
］ものと明示的に定義している場合、それは~importされた~stylesheetには適用されない。
◎
If a feature (such as the @namespace rule) explicitly defines that it only applies to a particular stylesheet, and not any imported ones, then it doesn’t apply to the imported stylesheet.
</li>
	<li>
ある特能が，~stylesheet内の複数の構成子どうしの順序に依拠する場合（ `namespace$at 規則には， `import$at 以外の規則は先行してはならないとする要件など）、それが適用されるのは，同じ~stylesheet内の構成子どうしに限られる。
◎
If a feature relies on the relative ordering of two or more constructs in a stylesheet (such as the requirement that @namespace rules must not have any other rules other than @import preceding it), it only applies between constructs in the same stylesheet.
</li>
</ul>

<p class="example">
例えば，［
~importされた~stylesheet内の~style規則
］の中の各~宣言は、それを~importした~stylesheetの中の `import$at の地点に 当の~style規則がそのまま記されたかのように，~cascadeとヤリトリする。
◎
For example, declarations in style rules from imported stylesheets interact with the cascade as if they were written literally into the stylesheet at the point of the @import.
</p>

<p>
~stylesheet内では、
`import$at 規則は，（ `charset$at は無視して）他のすべての妥当な［
~at-rule／~style規則
］より先行していなければナラナイ。
さもなければ `import$at 規則は無効とされる。
`import$at の構文は次で与えられる：
◎
Any @import rules must precede all other valid at-rules and style rules in a style sheet (ignoring @charset), or else the @import rule is invalid. The syntax of @import is:
</p>

<pre class="prod">
@import [ `url$t | `string$t ]
   [ supports( [ `supports-condition$t | `declaration$t ] ) ]?
   `media-query-list$t? ;
</pre>

<p>
`url$t ／ `string$t
は、~importされることになる~stylesheetの~URLを与える。
`~import条件@
と総称される，省略可能な［
<span class="prod">[ `supports-condition$t | `declaration$t ]</span> ／
`media-query-list$t
］は、当の~stylesheetが どのような条件の下で適用されるかを言明する。
◎
where the &lt;url&gt; or &lt;string&gt; gives the URL of the style sheet to be imported, and the optional [&lt;supports-condition&gt;|&lt;declaration&gt;] and &lt;media-query-list&gt; (collectively, the import conditions ) state the conditions under which it applies.
</p>

<div class="example">
<p>
次の
<a href="#conditional-import">条件付き `import^at 規則</a>
は、~UAが
<code class="css">`display$p: `flex^v</code>
を`~supportする$場合に限り，~stylesheetを読込むことに加え、
<a href="~MQ5#width">表示域~横幅</a>が `400px^v
<a href="~MQ5#mq-min-max">以下</a>の携帯~機器【 `handheld$v 】に限り，~stylesheetを適用する：
◎
The following conditional @import rule only loads the style sheet when the UA supports display: flex, and only applies the style sheet on a handheld device with a maximum viewport width of 400px.
</p>

<pre class="lang-css">
@import url("narrow.css") supports(display: flex) handheld and (max-width: 400px);
</pre>

</div>

<p>
`string$t が供されている場合、それは，同じ引数を伴う 1 個の `url$t として解釈するモノトスル。
◎
If a &lt;string&gt; is provided, it must be interpreted as a &lt;url&gt; with the same value.
</p>

<div class="example">

<p>
次の 2 行（ `url$f によるものと, 文字列そのままのもの）は、意味的に等価な `import$at 構文になる：
◎
The following lines are equivalent in meaning and illustrate both @import syntaxes (one with url() and one with a bare string):
</p>

<pre class="lang-css">
@import "mystyle.css";
@import url("mystyle.css");
</pre>

</div>

		<section id="conditional-import">
<h3 title="Conditional @import Rules">2.1. 条件付き `import^at 規則</h3>

<p>
~importは，`~import条件$により，［
媒体／特能~support
］に依存させることもできる。
`~import条件$が無い下では，無条件に~importされる（その
`media-query-list$t 用の値 `all^v を指定しても，同じ効果になる）。
`~import条件$が合致しない場合、~importされる~stylesheet内の規則は適用されない
— ~importされた~stylesheetが，所与の媒体~queryを伴う［
`media$at ／ `supports$at
］~blockで括られたときとちょうど同じに。
◎
The import conditions allow the import to be media– or feature-support–dependent. In the absence of any import conditions, the import is unconditional. (Specifying all for the &lt;media-query-list&gt; has the same effect.) If the import conditions do not match, the rules in the imported stylesheet do not apply, exactly as if the imported stylesheet were wrapped in @media and/or @supports blocks with the given conditions.
</p>

<div class="example">

<p>
`import$at 規則を媒体に依存させる例を以下に示す：
◎
The following rules illustrate how @import rules can be made media-dependent:
</p>

<pre class="lang-css">
@import url("fineprint.css") print;
@import url("bluish.css") projection, tv;
@import url("narrow.css") handheld and (max-width: 400px);
</pre>

</div>

<p>
従って~UAは、`~import条件$が合致しない条件付き~importについては，~fetchせずに済ませられる。
加えて、~importによる~stylesheetの適用が `supports-condition$t により阻まれる場合には、その~stylesheetを（他の~linkを通して読込まれるのでない限り）~fetchしてはならず、その~import規則に対応する `CSSImportRule.styleSheet^c 値は，（他の~linkを通して読込まれる場合でも） ~NULL を返すモノトスル。
◎
User agents may therefore avoid fetching a conditional import as long as the import conditions do not match. Additionally, if a &lt;supports-condition&gt; blocks the application of the imported style sheet, the UA must not fetch the style sheet (unless it is loaded through some other link) and must return null for the import rule’s CSSImportRule.styleSheet value (even if it is loaded through some other link).
</p>

<div class="example">
<p>
作者が、より新しい~UAの~network処理能に響かすことなく，旧来の~UAに~fallback規則を供する方法を，次の規則に示す：
◎
The following rule illustrates how an author can provide fallback rules for legacy user agents without impacting network performance on newer user agents:
</p>

<pre class="lang-css">
@import url("fallback-layout.css") supports(not (display: flex));
@supports (display: flex) {
  ...
}
</pre>

</div>

<p>
`media-query@t
は、
`media_query_list$P 生成規則に対応し，`媒体~query$として解釈される。
`supports-condition@t
は、
`supports_condition$P 生成規則に対応し，
`supports$at 条件として解釈される。
`supports-condition$t に代えて
`declaration@t
（ `declaration$P 生成規則）が与えられた場合、
`supports_declaration_condition$P 生成規則として解釈した上で（すなわち，暗黙の丸括弧が追加される），
`supports-condition$t として扱うモノトスル。
◎
A &lt;media-query&gt; corresponds to the media_query_list production and is interpreted as a media query, and a &lt;supports-condition&gt; corresponds to a supports_condition production and is interpreted as an @supports condition. If a &lt;declaration&gt; (a declaration production) is given in place of a &lt;supports-condition&gt;, it must be interpreted as a supports_declaration_condition production (i.e. the extra set of parentheses is implied) and treated as a &lt;supports-condition&gt;.
</p>

<div class="example">
<p>
例えば、次の 2 行は等価になる：
◎
For example, the following two lines are equivalent:
</p>

<pre class="lang-css">
@import "mystyle.css" supports(display: flex);
@import "mystyle.css" supports((display: flex));
</pre>
</div>

<p>
`~import条件$の評価とその全部的な構文は
<a href="~TR/css3-mediaqueries/">Media Queries</a>
`MEDIAQ$r, および
<a href="~CSSCOND">CSS Conditional Rules</a>
`CSS3-CONDITIONAL$r
にて定義される。
◎
The evaluation and full syntax of the import conditions are defined by the Media Queries [MEDIAQ] and CSS Conditional Rules [CSS3-CONDITIONAL] specifications.
</p>

		</section>
		<section id="import-processing">
<h3 title="Processing Stylesheet Imports">2.2. ~importによる~stylesheetの処理</h3>

<p>
同じ~stylesheetが文書~内の複数の場所から~importまたは~linkされている場合、 ~UAは，それらの~linkをそれぞれが独立な~stylesheetを指しているかのように処理するモノトスル。
◎
When the same style sheet is imported or linked to a document in multiple places, user agents must process (or act as though they do) each link as though the link were to an independent style sheet.
</p>

<p class="note">注記：
これは、資源の~fetchingに要件を課すものではない。
~stylesheetは［
~CSSOMに どう反映されるか／
この仕様などの各種~仕様において どう利用されるか
］に課される要件になる。
複数箇所から~linkされている, あるいは複数回~importされたとしても，適切な~cache法の下で 一度だけ~stylesheetを~fetchすることは、ごく適切な~UAのふるまいになる。
◎
Note: This does not place any requirements on resource fetching, only how the style sheet is reflected in the CSSOM and used in specs such as this one. Assuming appropriate caching, it is perfectly appropriate for a UA to fetch a style sheet only once, even though it’s linked or imported multiple times.
</p>

<p>
~importされた~stylesheetが属する`出自$は、それを~importした~stylesheetが属する`出自$と同じになる。
◎
The origin of an imported style sheet is the origin of the style sheet that imported it.
</p>

	<p>
~importされた~stylesheetの`環境~符号化法$は、それを~importした~stylesheetの符号化法で与えられる。
`css-syntax-3$r
◎
The environment encoding of an imported style sheet is the encoding of the style sheet that imported it. [css-syntax-3]
</p>

		</section>
		<section id="content-type">
<h3 title="Content-Type of CSS Style Sheets">2.3. ~CSS~stylesheetの~Content-Type</h3>

<div class="p">

<p>
~importされた~stylesheetの処理は、~link先の資源の実際の型【 “~MIME型” 】に依存する
— 型は、次にしたがって決定される：
</p>
<ul>
	<li>
~host文書が`過去互換~mode$下にある, かつ
~host文書と~importされた~stylesheetは`同一-生成元$である場合
⇒
`text/css^c
</li>
	<li>
他の場合、資源に`~Content-Type~metadata$が伴われているならば
⇒
型は その~metadataにより決定される
</li>
	<li>
他の場合
⇒
`text/css^c
</li>
</ul>

◎
The processing of imported style sheets depends on the actual type of the linked resource. If the resource does not have Content-Type metadata, or the host document is in quirks mode and has the same origin as the imported style sheet, the type of the linked resource is text/css. Otherwise, the type is determined from its Content-Type metadata.
</div>

<p>
~link先の資源の型が `text/css^c である場合、~CSS~stylesheetとして解釈するモノトスル。
他の場合、~network~errorとして解釈するモノトスル。
◎
If the linked resource’s type is text/css, it must be interpreted as a CSS style sheet. Otherwise, it must be interpreted as a network error.
</p>

		</section>
	</section>
	<section id="shorthand">
<h2 title="Shorthand Properties">3. 略式~prop</h2>

<p>
作者が数種の~propの値を単独の~propで一括して指定できるようにするため、一部の~propは
`略式~prop@
（
`shorthand property^en, または略して `shorthand^en
）とされている。
`略式~prop$は、そのすべての非略式
`下位prop@
（
`longhand sub-property^en, または略して［
`longhand^en ／ `sub-property^en
］）を，その場で展開されたかのように設定する。
◎
Some properties are shorthand properties, meaning that they allow authors to specify the values of several properties with a single property. A shorthand property sets all of its longhand sub-properties, exactly as if expanded in place.
</p>

<p>
`略式~prop$から値が省略されて “消失した” それぞれの`下位prop$には、他から定義されない限り，その`初期~値$がアテガわれる。
◎
When values are omitted from a shorthand form, unless otherwise defined, each “missing” sub-property is assigned its initial value.
</p>

<div class="note">
<p>注記：
すなわち，`略式~prop$宣言は常に、その`すべて^emの`下位prop$を設定する
— それらが明示的に設定されなくても。
不注意に`略式~prop$を利用した場合，一部の`下位prop$を不知に設定し直すことになりかねないが、注意して利用すれば，不知に他の~sourceから~cascadeされた`下位prop$を設定し直して，“白紙状態” に戻すことを保証してくれる。
◎
This means that a shorthand property declaration always sets all of its sub-properties, even those that are not explicitly set. Carelessly used, this might result in inadvertently resetting some sub-properties. Carefully used, a shorthand can guarantee a “blank slate” by resetting sub-properties inadvertently cascaded from other sources.
</p>

<p>
例えば，
<code class="css">`background-color$p: `green^v;</code>
ではなく
<code class="css">`background$p: `green^v;</code>
と記すことにより、以前のどこかの宣言で 背景に `background-image$p による画像が設定されているかもしれないときでも，背景を`色だけ^emにするよう上書きできる。
◎
For example, writing background: green rather than background-color: green ensures that the background color overrides any earlier declarations that might have set the background to an image with background-image.
</p>

<p class="trans-note">【
“上書き”
— `~cascade法$における`出現順序$による順位付けの結果として，そうなる（より高次の順位付けの宣言d値（例えばより`詳細度$が高いもの）まで上書きするわけではない）。
】</p>

</div>

<div class="example">

<p>
例えば，CSS Level 1 の `font$p ~propは、
`font-style$p,
`font-variant$p,
`font-weight$p,
`font-size$p,
`line-height$p,
`font-family$p
を一括して設定するための，`略式~prop$である。
したがって，次の様な複数の宣言は：
◎
For example, the CSS Level 1 font property is a shorthand property for setting font-style, font-variant, font-weight, font-size, line-height, and font-family all at once. The multiple declarations of this example:
</p>

<pre class="lang-css">
h1 {
  font-weight: bold;
  font-size: 12pt;
  line-height: 14pt;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
</pre>

<p>
次の様に書き直せる
◎
can therefore be rewritten as
</p>

<pre class="lang-css">
h1 { font: bold 12pt/14pt Helvetica }
</pre>

<p>
`font$p に対する新たな`下位prop$が更に導入されれば、略式~prop宣言は，それらも その初期~値に設定し直すことになる。
◎
As more font sub-properties are introduced into CSS, the shorthand declaration resets those to their initial values as well.
</p>

</div>

<p class="trans-note">【
次の様な場合もあることに注意：
`border-width$p のような~propは、略式~prop
`border$p の下位propであると同時に，下位propに
`border-top-width$p, `border-left-width$p,
… 等々を持つ略式~propでもある。
この様な場合の `border$p の “下位prop” は、連鎖的に辿った末端の下位propを指しているように見受けられる
— が、この場合の “中間” の~prop（この例では
`border-width$p 等々）が，下位propに［含まれる／含まれない］のどちらに定義されているのかは、はっきりしない
【！展開については、末端のもののみに限定され， “中間” のものは除外されると推定されるが】
— どちらに解釈したとしても，~cascadeに現れる結果は変わらないと見受けられるので
<small>（末端の下位propに限定する必要がある所では，その旨を付記した方が誤解は少ないであろう）</small>。
あるいは、そうなることを利用して，意図的に曖昧に定義されているように思われる。
実際、何が［
略式~prop／下位prop
］と見なされるかは，実装にも依存する —
仕様が拡張されて、それまでは末端の~propであったものが，より細分化された下位propを持つ様になることもあるので（例えば
`overflow$p ~propに対する
`overflow-x$p, `overflow-y$p
）。

】</p>

<p>
一部の`略式~prop$は、その`下位prop$の値に直には対応しないような，異なる構文や特別な~keywordを持ち得る（そのような`略式~prop$は，その値の展開を明示的に定義することになる）。
◎
In some cases, a shorthand might have different syntax or special keywords that don’t directly correspond to values of its sub-properties. (In such cases, the shorthand will explicitly define the expansion of its values.)
</p>

<p>
また、略式~propにおいて
`設定し直すのみ@
になる`下位prop$もある：
それは、他の`下位prop$と同様に，略式~propの中で値が指定されていなければ 初期~値に設定し直すが、それ以外の値に設定する構文が，略式~propに備わっていないものである【 `~CSS全域~keyword$は別として】。
例えば， `border$p 略式~propは、
`border-image$p をその初期~値 `none^v に設定し直すが，それ以外の値に設定する構文を備えていない。
`css-backgrounds-3$r
◎
In other cases, a property might be a reset-only sub-property of the shorthand: Like other sub-properties, it is reset to its initial value by the shorthand when unspecified, but the shorthand might not include syntax to set the sub-property to any of its other values. For example, the border shorthand resets border-image to its initial value of none, but has no syntax to set it to anything else. [css-backgrounds-3]
</p>

<p>
`略式~prop$が いずれかの`~CSS全域~keyword$ `css-values-3$r として指定されている場合、そのすべての`下位prop$は，`設定し直すのみ$のものも含め，その~keywordに設定される。
（これらの~keywordは、略式~propに限らず，単独の宣言の中で他の値と組合できないことに注意。）
◎
If a shorthand is specified as one of the CSS-wide keywords [css-values-3], it sets all of its sub-properties to that keyword, including any that are reset-only sub-properties. (Note that these keywords cannot be combined with other values in a single declaration, not even in a shorthand.)
</p>

<p>
`略式~prop$を `!important$css を伴わせて宣言することは、そのすべての`下位prop$を `!important$css を伴わせて宣言することに等価になる。
◎
Declaring a shorthand property to be !important is equivalent to declaring all of its sub-properties to be !important.
</p>

		<section id="aliasing">
<h3 title="Aliasing">3.1. 別名化</h3>

<p>
~propの名前は、変更されることもある
— ~vendor接頭辞~付き~propなど，しばらくの間 ~supportされた後に標準~化されるときなど。
互換性の理由から，元の名前も依然として~supportされる必要があるが、新たな名前が選好される。
これを成遂げるため、~CSSでは，古い構文を新たな構文の “別名にする” 2 つの仕方を定義する：
◎
Properties sometimes change names after being supported for a while, such as vendor-prefixed properties being standardized. The original name still needs to be supported for compatibility reasons, but the new name is preferred. To accomplish this, CSS defines two different ways of “aliasing” old syntax to new syntax.
</p>

<dl class="def-list">
	<dt>
`旧来の別名n@
（ `legacy name alias^en ）
◎
legacy name aliases
</dt>
	<dd>
古い~propの構文による値~空間が，新たな~propの構文による それに一致するか, または下位集合である場合、古い~prop名は新たな~propの別名にされる
— 構文解析-時点で，文字大小対応（ `case-mapping^en ）演算の下で新たな~prop名に変換することにより。
この変換は、~CSSOMにおいても†，文字列~引数, ~prop~accessorの両者に適用される：
古い~prop名~向けの要請は、透過的に，新たな~prop名に転送される。
◎
When the old property’s syntax is identical to or a subset of the value space of the new property’s syntax, the two names are aliased with an operation on par with case-mapping: at parse time, the old property is converted into the new property. This conversion also applies in the CSSOM, both for string arguments and property accessors: requests for the old property name transparently transfer to the new property name instead.
</dd>
	<dd class="example">
例えば `old-name^p は `new-name^p 用の`旧来の別名n$である場合、
<code>getComputedStyle(%el).oldName</code>
は `newName^c ~propに算出される~styleを返すことになり，
<code>el.style.setPropertyValue(`old-name^l, `value^l)</code>
は `new-name^p ~propを `value^l に設定することになる。
◎
For example, if old-name is a legacy name alias for new-name, getComputedStyle(el).oldName will return the computed style of the newName property, and el.style.setPropertyValue("old-name", "value") will set the new-name property to "value".
</dd>

	<dt>
`旧来の略式~prop@
（ `legacy shorthand^en ）
◎
legacy shorthands
</dt>
	<dd>
古い~propの構文が新たな~propの構文とは別個のものである場合、古い~prop名は，`略式~prop$の仕組みを利用して 新たな~prop名の別名にされる。
古い~propは、【新たな~propを下位propとする】
`旧来の略式~prop$であるものと定義され，その利用は`非推奨に^emされる。
それ以外の点では、定例の略式と正確に同じに挙動する
— ~CSSOMにより宣言が直列化されるときには，古い名前を利用しないこと除いて。
`CSSOM$r
◎
When the old property has a distinct syntax from the new property, the two names are aliased using the shorthand mechanism. These shorthands are defined to be legacy shorthands, and their use is deprecated. They otherwise behave exactly as regular shorthands, except that the CSSOM will not use them when serializing declarations. [CSSOM]
</dd>
	<dd class="example">
<p>
例えば， `page-break-*^p ~propは、
`break-*^p ~prop用の`旧来の略式~prop$である（
<a href="~CSSBREAK#page-break-properties">§~page分断~propの別名</a>
`css-break-3$r を見よ）。
◎
For example, the page-break-* properties are legacy shorthands for the break-* properties (see CSS Fragmentation 3 §3.4 Page Break Aliases: the page-break-before, page-break-after, and page-break-inside properties).
</p>

<p>
`page-break-before$p が `always^v に設定された場合、他の略式が行う様に構文解析-時点で `break-before$p に展開される。
同様に， `break-before^p が `page^v に設定された場合、
<code>getComputedStyle(%el).pageBreakBefore</code>
を~callしたときには `always^l を返すことになる。
しかしながら，
~style~blockを直列化するとき（
~CSSOMの
<a href="~CSSOM1#serializing-css-values">§~CSS値の直列化-法</a>
を見よ）には、［
`page-break-before^p, `break-before^p
］のどちらが指定されようが，直列化する略式として `page-break-before^p ~propが選ばれることは決してなく、
常に `break-before^p が選ばれることになる。
◎
Setting page-break-before: always expands to break-before: page at parse time, like other shorthands do. Similarly, if break-before: page is set, calling getComputedStyle(el).pageBreakBefore will return "always". However, when serializing a style block (see CSSOM 1 §5.7.2 Serializing CSS Values), the page-break-before property will never be chosen as the shorthand to serialize to, regardless of whether it or break-before was specified; instead, break-before will always be chosen.
</p>
	</dd>
</dl>

		</section>
		<section id="all-shorthand">
<h3 title="Resetting All Properties: the all property">3.2. すべての~propを設定し直す： `all^p ~prop</h3>

◎名 `all@p
◎値 `initial$v | `inherit$v | `unset$v | `revert$v
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎ア 個々の~propを見よ
◎順 文法に従う
◎表終

<p>
`all$p ~propは、［
`direction$p, `unicode-bidi$p
］を除く，`すべての~CSS~prop^emを設定し直す`略式~prop$である。
`~CSS全域~keyword$のみが，その値として受容される。
また、`~custom~prop$は設定し直さない
`css-variables-1$r
。
◎
The all property is a shorthand that resets all CSS properties except direction and unicode-bidi. It only accepts the CSS-wide keywords. It does not reset custom properties [css-variables-1].
</p>

<p class="note">
除かれた［
`direction$p, `unicode-bidi$p
］~propは、実際には~markup~levelの特能であり，
<a href="~CSSWM#text-direction">作者~stylesheetには設定されるべきでない</a>
（それらは、~UAが~supportしていない文書~言語を~styleするための~CSS~propとしてのみ存在する）
`css-writing-modes-3$r
。
作者は、~HTMLの `dir$a 属性などの，適切な~markupを代わりに利用するべきである。
◎
Note: The excepted CSS properties direction and unicode-bidi are actually markup-level features, and should not be set in the author’s style sheet. (They exist as CSS properties only to style document languages not supported by the UA.) Authors should use the appropriate markup, such as HTML’s dir attribute, instead. [css-writing-modes-3]
</p>

<div class="example">

<p>
例えば，要素~上に
<code class="css">`all$p: `initial^v;</code>
が指定された場合、すべての継承は阻まれ，その要素の すべての~propは［
作者, 利用者, UA
］~levelの~cascadeの中に一切の規則が現れなかったかのように，設定し直されることになる。
◎
For example, if an author specifies all: initial on an element it will block all inheritance and reset all properties, as if no rules appeared in the author, user, or user-agent levels of the cascade.
</p>

<p>
これは、~page外の~styleの継承が望まれないような，~page内に含められた “~widget” の根~要素に有用になり得る。
ただし、その要素に適用される “既定の” ~style（例えば
`div^e などの塊~要素に対し，~UA~stylesheetからあてがわれる
<code class="css">`display$p: `block^v;</code>
など）も，吹飛ばされることに注意。
◎
This can be useful for the root element of a "widget" included in a page, which does not wish to inherit the styles of the outer page. Note, however, that any "default" style applied to that element (such as, e.g. display: block from the UA style sheet on block elements such as &lt;div&gt;) will also be blown away.
</p>

</div>

		</section>
	</section>
	<section id="value-stages">
<h2 title="Value Processing">4. 値の処理</h2>

<p>
~UAは、文書を構文解析して文書~treeを構築し終えたならば，~tree内のどの要素に対しても，および 対応する整形~構造の中のどの~boxに対しても、その~propのうち，~~目的の媒体~型を適用~対象にするものすべてに対し，値をアテガうモノトスル。
◎
Once a user agent has parsed a document and constructed a document tree, it must assign, to every element in the tree, and correspondingly to every box in the formatting structure, a value to every property that applies to the target media type.
</p>

<p>
所与の［
要素／~box
］の~CSS~propの最終的な値は、次の様な複数の段階を経て計算される：
◎
The final value of a CSS property for a given element or box is the result of a multi-step calculation:
</p>

<ol>
	<li>
最初に、各 要素に対し，要素を`適用-対象$とする各~propに対し，［
`要素に適用され$る`宣言d値$
］すべてが収集される。
そのような`宣言d値$は、各~要素の各~propごとに， 0 個以上いくつでもあり得る。
◎
First, all the declared values applied to an element are collected, for each property on each element. There may be zero or many declared values applied to the element.
</li>
	<li>
`~cascade法$により，`~cascaded値$を得る。
`~cascaded値$は、各~要素の各~propごとに，高々 1 個までである。
◎
Cascading yields the cascaded value. There is at most one cascaded value per property per element.
</li>
	<li>
`~default法$により，`指定d値$を得る。
どの要素も，~propごとにきっかり 1 個の`指定d値$を持つ。
◎
Defaulting yields the specified value. Every element has exactly one specified value per property.
</li>
	<li>
値の依存性を解決して，`算出d値$を得る。
どの要素も，~propごとにきっかり 1 個の`算出d値$を持つ。
◎
Resolving value dependencies yields the computed value. Every element has exactly one computed value per property.
</li>
	<li>
文書の整形（ `formatting^en ）を経ることで，`使用~値$を得る。
要素の~propが`使用~値$を持つのは、要素が その~propの`適用-対象$である場合に限られる。
◎
Formatting the document yields the used value. An element only has a used value for a given property if that property applies to the element.
</li>
	<li>
最後に，使用~値は、表示~環境による拘束に基づいて，`実際の値$に変形される。
`使用~値$と同じく、`実際の値$も，要素が ~propの`適用-対象$である場合に限り~~存在する。
◎
Finally, the used value is transformed to the actual value based on constraints of the display environment. As with the used value, there may or may not be an actual value for a given property on an element.
</li>
</ol>

		<section id="declared">
<h3 title="Declared Values">4.1. 宣言d値</h3>

<p>
`要素に適用され$る各~prop宣言が、その要素の~prop用の
`宣言d値@
（ `declared value^en ）を与える。
詳細は<a href="#filtering">§ 宣言の絞込み</a>にて。
◎
Each property declaration applied to an element contributes a declared value for that property associated with the element. See Filtering Declarations for details.
</p>

<p>
これらの値から、`~cascade$による処理を経て，
1 個の “最優先な値” が~~選定される。
◎
These values are then processed by the cascade to choose a single “winning value”.
</p>

		</section>
		<section id="cascaded">
<h3 title="Cascaded Values">4.2. ~cascaded値</h3>

<p>
`~cascaded値@
（ `cascaded value^en ）は、`~cascade$の結果を表現する。
それは、一連の`宣言d値$から，~cascadeを経て（`~cascadeの出力$の中で~sortされて）~~選定された値である。
`~cascadeの出力$が空~listである場合、`~cascaded値$は無い。
◎
The cascaded value represents the result of the cascade: it is the declared value that wins the cascade (is sorted first in the output of the cascade). If the output of the cascade is an empty list, there is no cascaded value.
</p>

		</section>
		<section id="specified">
<h3 title="Specified Values">4.3. 指定d値</h3>

<p>
所与の~propの
`指定d値@
（ `specified value^en ）は、~stylesheet作者がその要素に意図した値である。
多くの場合、`~cascaded値$が`指定d値$になるが，`~cascaded値$が無い場合は、`~default法$により`指定d値$が~~導出され，`~cascaded値$に置き換わる。
これにより、どの要素のどの~propにも，`指定d値$の存在が保証される。
~propの`~cascaded値$が`~CSS全域~keyword$であるときには、特別に取扱われ，`指定d値$を その~keywordから要求される値に設定する。
<a href="#defaulting-keywords">§明示的な~default法</a>
を見よ。
◎
The specified value is the value of a given property that the style sheet authors intended for that element. It is the result of putting the cascaded value through the defaulting processes, guaranteeing that a specified value exists for every property on every element.
◎
In many cases, the specified value is the cascaded value. However, if there is no cascaded value at all, the specified value is defaulted. The CSS-wide keywords are handled specially when they are the cascaded value of a property, setting the specified value as required by that keyword, see § 7.3 Explicit Defaulting.
</p>

		</section>
		<section id="computed">
<h3 title="Computed Values">4.4. 算出d値</h3>

<p>
`算出d値@
（ `computed value^en ）とは、
`指定d値$を，~prop定義表の “算出d値” 欄に従って解決した結果である。
一般に，指定d値は`継承$による伝播の際に絶対~化される。
◎
The computed value is the result of resolving the specified value as defined in the “Computed Value” line of the property definition table, generally absolutizing it in preparation for inheritance.
</p>

<p class="trans-note">【
各種~CSS仕様において、単に
“%foo ~propの値”
と記されたときは，およそ，算出d値を指し（ “〜に算出される” という句も同様）、
“%foo ~propに`指定された^em値”
と記されたときは，およそ，指定d値を指すと見受けられる。
しかしながら、どちらを指すかは文脈に応じて判断する必要もあるかもしれない。
あるいは、どちらに解釈しようが結果は同じになる場合には，単に “~propの値” と記されることもあろう。
】</p>

<p class="note">注記：
`継承$において親から子へ転送される値は、`指定d値$ではなく`算出d値$である。
歴史的な理由から、
`getComputedStyle()$c 関数 `CSSOM$r
は，`算出d値$を返すとは限らず，`使用~値$を返すこともある
【この関数が返す値は`解決d値$と呼ばれる】
。
`算出d値$は，抽象的な~data表現であり、その定義は，~data表現を反映する
— ~dataがどう直列化されるかではなく。
例えば、直列化の規則には，構文解析の間に黙示された ある種の値を省略できるようにしているものが多いが、そのような値であっても`算出d値$の一部を成す。
◎
Note: The computed value is the value that is transferred from parent to child during inheritance. For historical reasons, it is not necessarily the value returned by the getComputedStyle() function, which sometimes returns used values. [CSSOM] Furthermore, the computed value is an abstract data representation: their definitions reflect that data representation, not how that data is serialized. For example, serialization rules often allow omitting certain values which are implied during parsing; but those values are nonetheless part of the computed value.
</p>

<div class="example">
<p>
`指定d値$は、絶対的な値（すなわち、
`red^v や `2mm^v
など，別の値に相対的でない値）
または相対的な値（すなわち、
`auto^v や `2em^v
など，別の値に相対的な値）のいずれもとり得る。
一般に、相対的な値から算出d値を得るときは，絶対~化される：
◎
A specified value can be either absolute (i.e., not relative to another value, as in red or 2mm) or relative (i.e., relative to another value, as in auto, 2em). Computing a relative value generally absolutizes it:
</p>
<ul>
	<li>
相対的~単位（
`em$u, `ex$u, `vh$u, `vw$u
）を伴う値は、適切な基準~sizeを乗算して絶対~化するモノトスル。
◎
values with relative units (em, ex, vh, vw) must be made absolute by multiplying with the appropriate reference size
</li>
	<li>
一定の~keyword（例えば
`smaller^v, `bolder^v
）は、それらの定義に則って置換するモノトスル。
◎
certain keywords (e.g., smaller, bolder) must be replaced according to their definitions
</li>
	<li>
一部の~propに対する百分率~値は、（~propにて定義される）基準~値と乗算するモノトスル。
◎
percentages on some properties must be multiplied by a reference value (defined by the property)
</li>
	<li>
妥当な相対~URLは、絶対~URLに解決するモノトスル。
◎
valid relative URLs must be resolved to become absolute.
</li>
</ul>

<p>
<a href="#stages-examples">下の表</a>の
例 (f), (g), (h) を見よ。
◎
See examples (f), (g) and (h) in the table below.
</p>

</div>

<div class="note">
<p>注記：
一般に，`指定d値$を解決して`算出d値$を得る際には、文書の~layoutや，他の重い, あるいは並列化し難い演算
— ~network~requestを解決したり, 要素やその親 以外から値を検索取得するなど —
は、アリな限り~~避けられている。
◎
Note: In general, the computed value resolves the specified value as far as possible without laying out the document or performing other expensive or hard-to-parallelize operations, such as resolving network requests or retrieving values other than from the element and its parent.
</p>

<p class="trans-note">【
言い換えれば，算出d値は、概ね，~stylesheet, 文書~tree, その他の確定的な情報のみから決定でき，（~layout開始時には未知な）他の要因からは左右されない値を表す。
】【
参考：
~CSSによる~animationや遷移における値の補間は、
<a href="~CSSVAL#combining-values">算出d値に基づいて行われる</a>。
】</p>
</div>

<p>
`算出d値$は、要素が~propの`適用-対象$でないとしても，存在する。
しかしながら、要素が`適用-対象$であるかどうかに応じて，`算出d値$の決定-法が変化する~propもある。
◎
The computed value exists even when the property does not apply. However, some properties may change how they determine the computed value based on whether the property applies to the element.
</p>

		</section>
		<section id="used">
<h3 title="Used Values">4.5. 使用~値</h3>

<p>
`使用~値@
（ `used value^en ）は、`算出d値$を［
文書の整形に利用される絶対的な理論的な値
］に仕上げる計算を完了した結果である。
◎
The used value is the result of taking the computed value and completing any remaining calculations to make it the absolute theoretical value used in the formatting of the document.
</p>

<p class="trans-note">【
他の各種~CSS仕様によく現れる， “使用〜（ `used^en 〜）” のような句も、同様の概念を表すと見られる。
<small>（
<a href="index.html#spec-list-css">この~siteの CSS 関連の日本語訳</a>
に現れる語 “使用” は、~~原則的に，この意味と考えられる `used^en の対訳に限って利用している。
他の意味の `used^en には、別の対訳（ “利用される” など）が利用されるが、中には，この意味の “使用” を指すものもあるかもしれない。
）</small>
】</p>

<p class="example">
例えば，宣言
<code class="css">`width$p: `auto^v</code>
は、要素の先祖の~layoutを知ることなしには，長さに解決され得ない。
したがって`使用~値$は `100px^v のような絶対的な長さになる一方で，`算出d値$は `auto^v になる。
`CSS2$r
◎
For example, a declaration of width: auto can’t be resolved into a length without knowing the layout of the element’s ancestors, so the computed value is auto, while the used value is an absolute length, such as 100px. [CSS2]
</p>

<p class="example">
別の例として，
`div^e は `break-before$p の算出d値に `auto^v をとり得るが、その使用~値
`page^v
を，その最初の子からの伝播を通して獲得する。
`css-break-3$r
◎
As another example, a &lt;div&gt; might have a computed break-before value of auto, but acquire a used break-before value of page by propagation from its first child. [css-break-3]
</p>

<p>
~propは、その
`適用-対象@
— すなわち，その~prop定義表の “適用対象” 欄に挙げられているもの —
でない型の［
要素／~box
］上では，整形~効果は無く、したがって，その~prop用の`使用~値$も無い。
◎
If a property does not apply to this element or box type—as noted in its “Applies to” line—then it has no formatting effect on that type of box or element, and therefore has no used value for that property.
</p>

<p class="trans-note">【
個々の~prop`宣言^emが “`要素に適用され$る” のとは、意味が異なることに注意（そのことを明確化するため，この訳では語尾に “対象” を付与している）。
】</p>

<p class="example">
例えば， `flex$p ~propは、`~flex駒$でない要素に対しては`使用~値$は無い。
◎
For example, the flex property has no used value on elements that aren’t flex items.
</p>

<p class="note">注記：
~propのうち， “すべての要素” に適用されるものと定義されたものは、すべての［
要素~型／`表示~型$
］に適用されるが，どの`疑似要素$~型にも適用されるとは限らない
— 疑似要素には、自前の特有な具現化~modelや他の制約があることが多いので。
しかしながら，［
`before$pe ／ `after$pe
］疑似要素は、通常の要素と ほぼ違わない~boxを生成するものと定義されるので，
“すべての要素” に適用される~propすべてを受容するものと定義される。
`疑似要素$についての更なる情報は `CSS-PSEUDO-4$r を見よ。
◎
Note: A property defined to apply to “all elements” applies to all elements and display types, but not necessarily to all pseudo-element types, since pseudo-elements often have their own specific rendering models or other restrictions. The ::before and ::after pseudo-elements, however, are defined to generate boxes almost exactly like normal elements and are therefore defined accept all properties that apply to “all elements”. See [CSS-PSEUDO-4] for more information about pseudo-elements.
</p>

		</section>
		<section id="actual">
<h3 title="Actual Values">4.6. 実際の値</h3>

<p>
`使用~値$は、原則として，【具現化-用に】利用する準備が整った値であるが、所与の環境においては直に用立てれないこともある。
例えば~UAは，整数幅の画素境界にしか描画できないかもしれず、その場合，`使用~値$による幅を近似させる必要も生じ得る。
あるいは，要素の~font~sizeは、~fontの可用性や
`font-size-adjust$p ~prop値に基づいて，調整を要する。
`実際の値@
（ `actual value^en ）とは、使用~値に そのような調整を施した後の値である。
◎
A used value is in principle ready to be used, but a user agent may not be able to make use of the value in a given environment. For example, a user agent may only be able to render borders with integer pixel widths and may therefore have to approximate the used width. Also, the font size of an element may need adjustment based on the availability of fonts or the value of the font-size-adjust property. The actual value is the used value after any such adjustments have been made.
</p>

<p class="trans-note">【
`実際の値$は、概念的には，~CSSが定義する~modelからは決定し得ない外部の要因も織り込んだ結果と捉えられる。
そのため、この用語が他の~CSS仕様に現れることは，ほとんどない
— ~CSSからは、具体的な要件として定義し得ないので（実際の値に基づくような挙動は別として）。
】</p>

<p class="note">注記：
要素の実際の値を調べれば、文書の~layoutについて多くを知れる。
しかしながら、すべての情報が実際の値に記録されるわけではない。
例えば， `page-break-after$p ~propの実際の値は、要素の後に~page分断があるかどうかを反映しない。
同様に， `orphans$p の実際の値は、要素の中の実際の orphan 行数を反映しない。
<a href="#stages-examples">下の表</a>の例 (j), (k) を見よ。
◎
Note: By probing the actual values of elements, much can be learned about how the document is laid out. However, not all information is recorded in the actual values. For example, the actual value of the page-break-after property does not reflect whether there is a page break or not after the element. Similarly, the actual value of orphans does not reflect how many orphan lines there is in a certain element. See examples (j) and (k) in the table below.
</p>

		</section>
		<section id="stages-examples">
<h3 title="Examples">4.7. 例</h3>

<div style="overflow:auto;">
<table class="data" id="_samples_matrix">
<caption >
指定d値~列の “†” は初期~値
</caption>

<thead><tr><th>
<th style="min-width:12em;">~prop
<th><span >~~選定された宣言</span>
<th>~cascaded値
<th>指定d値
<th>算出d値
<th>使用~値
<th>実際の値
</thead>

<!-- 
Property
Winning declaration
Cascaded value
Specified value
Computed value
Used value
Actual value
-->

<tbody><tr><td>(a)
<th>`text-align$p
<td><code class="css">text-align: left</code>
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v

<tr><td>(b)
<th>`border-top-width$p,<br>`border-right-width$p,<br>`border-bottom-width$p,<br>`border-left-width$p
<td><code class="css">border-width: inherit</code>
<td>`inherit$v
<td class="say">`4.2px^v
<td>`4.2px^v
<td>`4.2px^v
<td>`4px^v

<tr><td>(c)
<th>`width$p
<td><small title="(none)">(なし)</small>
<td><small title="(none)">(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`120px^v
<td>`120px^v

<tr><td>(d)
<th>`list-style-position$p
<td><code class="css">list-style-position: inherit</code>
<td>`inherit$v
<td class="say">`inside^v
<td>`inside^v
<td>`inside^v
<td>`inside^v

<tr><td>(e)
<th>`list-style-position$p
<td><code class="css">list-style-position: initial</code>
<td>`initial$v
<td>`outside^v†
<td>`outside^v
<td>`outside^v
<td>`outside^v

<tr><td>(f)
<th>`font-size$p
<td><code class="css">font-size: 1.2em</code>
<td>`1.2em^v
<td>`1.2em^v
<td class="say">`14.1px^v
<td>`14.1px^v
<td>`14px^v

<tr><td>(g)
<th>`width$p
<td><code class="css">width: 80%</code>
<td>`80%^v
<td>`80%^v
<td>`80%^v
<td class="say">`354.2px^v
<td>`354px^v

<tr><td>(h)
<th>`width$p
<td><code class="css">width: auto</code>
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td class="say">`134px^v
<td>`134px^v

<tr><td>(i)
<th>`height$p
<td><code class="css">height: auto</code>
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td class="say">`176px^v
<td>`176px^v

<tr><td>(j)
<th>`page-break-after$p
<td><small>(なし)</small>
<td><small>(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`auto^v
<td>`auto^v

<tr><td>(k)
<th>`orphans$p
<td><code class="css">orphans: 3</code>
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
</tbody></table></div>

			</section>
		</section>
	<section id="filtering">
<h2 title="Filtering">5. 絞込み</h2>

<p>
`宣言d値$を見出すためには、実装はまず，各~要素ごとに`要素に適用され$るすべての宣言を識別するモノトスル。
所与の宣言は、次【のすべて】が満たされるならば
`要素に適用され@
る：
◎
In order to find the declared values, implementations must first identify all declarations that apply to each element. A declaration applies to an element if:
</p>
<ul>
	<li>
当の文書に現在 適用されている~stylesheetに属している。
◎
It belongs to a style sheet that currently applies to this document.
</li>
	<li>
偽に評価される`条件付き~group規則$ `CSS3-CONDITIONAL$r により~~除外されていない。
◎
It is not qualified by a conditional rule [CSS3-CONDITIONAL] with a false condition.
</li>
	<li>
それが属している~style規則の選択子 `SELECT$r が要素に合致する。
◎
It belongs to a style rule whose selector matches the element. [SELECT]
</li>
	<li>
構文として妥当である
— すなわち，宣言の~propは既知な~prop名であり, かつ 宣言の値は その~propの構文に合致している。
◎
It is syntactically valid: the declaration’s property is a known property name, and the declaration’s value matches the syntax for that property.
</li>
</ul>

<p class="issue">
~shadow~DOM用に必要なものをここに定義する。
◎
Define whatever it is that Shadow DOM needs here.
</p>

<p>
これらの適用される宣言の値が、各~要素の各~prop用の`宣言d値$の~listを成す。
この~list内のどれが選ばれるかは、次節の`~cascade法$にて与えられる。
◎
The values of the declarations that apply form, for each property on each element, a list of declared values. The next section, the cascade, prioritizes these lists.
</p>

	</section>
	<section id="cascading">
<h2 title="Cascading">6. ~cascade法</h2>

<p>
`~cascade@
（~cascade~~処理）は、［
所与の要素の所与の~prop用の`宣言d値$たちが成す，無順序~list
］から、以下に従って決定される優先順位により，それらの宣言を~sortした上で、
【その中で最も優先度の高い】
単独の`~cascaded値$を出力する。
◎
The cascade takes an unordered list of declared values for a given property on a given element, sorts them by their declaration’s precedence as determined below, and outputs a single cascaded value.
</p>

		<section id="cascade-sort">
<h3 title="Cascade Order">6.1. ~cascade順序</h3>

<p>
~cascadeにおいては、以下の判定基準に則って，宣言が~sortされる。
先に示される判定基準が後続の判定基準よりも優先される：
◎
The cascade sorts declarations according to the following criteria, in descending order of priority:
</p>

<dl class="def-list">
	<dt>
`出自と重要度@
（ `origin^en と `importance^en ）
</dt>
	<dd>
<p>
宣言が属する`出自$は、~~字義通りの~~意味に基づく。
宣言が`~importantな宣言$になるかどうかは、
`!important$css を伴って宣言されているかどうかに基づく。
各種`出自$【と`~important$が成す組】の優先順位は、高いものから順に，次で与えられる：
◎
The origin of a declaration is based on where it comes from and its importance is whether or not it is declared with !important (see below). The precedence of the various origins is, in descending order:
</p>
		<ol>
			<li>
遷移~宣言 `css-transitions-1$r
◎
Transition declarations [css-transitions-1]
</li>
			<li>
`~UA出自$に属する`~importantな宣言$
◎
Important user agent declarations
</li>
			<li>
`利用者~出自$に属する`~importantな宣言$
◎
Important user declarations
</li>
			<li>
`作者~出自$に属する`~importantな宣言$
◎
Important author declarations
</li>
			<li>
~animation宣言 `css-animations-1$r
◎
Animation declarations [css-animations-1]
</li>
			<li>
`作者~出自$に属する`通常の宣言$
◎
Normal author declarations
</li>
			<li>
`利用者~出自$に属する`通常の宣言$
◎
Normal user declarations
</li>
			<li>
`~UA出自$に属する`通常の宣言$
◎
Normal user agent declarations
</li>
		</ol>

<p>
上の~listの中で，より先に挙げた`出自$に属する宣言が より後に挙げた`出自$に属する宣言よりも優先される。
◎
Declarations from origins earlier in this list win over declarations from later origins.
</p>

<p class="trans-note">【
~importantの有無により，［
作者／利用者／~UA
］宣言の優先順位は逆になる。
】</p>

	</dd>

	<dt>
`文脈@
（ `context^en ）
</dt>
	<dd>
文書~言語は、相異なる
`~encapsulation文脈@
を源とする宣言たちを混ぜ合わせる~~仕組みを供することもある
— ~DOM【！`DOM$r】内の`~shadow~tree$を成す入子にされた`~tree文脈$など。
◎
A document language can provide for blending declarations sourced from different encapsulation contexts, such as the nested tree contexts of shadow trees in the [DOM].
</dd>
	<dd>
<p>
異なる`~encapsulation文脈$ %A, %B を源とする宣言どうしを比較する場合、
%A が %B を入子にしているならば
⇒＃
`通常の宣言$どうしでは， %A を源とする宣言が優先される／
`~importantな宣言$どうしでは， %B を源とする宣言が優先される
◎
When comparing two declarations that are sourced from different encapsulation contexts, then for normal rules the declaration from the outer context wins, and for important rules the declaration from the inner context wins.＼
</p>

<p class="trans-note">【
間接的に入子にしている場合、推移的に定義されることになる。
】【
“源とする” とは，具体的には、当の宣言は［
その文脈から~linkされた／その文脈に埋込まれた
］~stylesheet内にある（あるいは、その文脈~内の ある要素の`~style属性$内にある）ことを意味する。
】</p>

<p>
この目的においては、~DOMを成す`~tree文脈$は，`~shadowも含む~tree順序$で入子にされるものと見なされる。
◎
For this purpose, [DOM] tree contexts are considered to be nested in shadow-including tree order.
</p>

<p class="note">注記：
このことは、実質的に，次を意味する
⇒
`~encapsulation文脈$に属する宣言のうち
⇒＃
`通常の宣言$は，外縁~文脈（ %A ）から容易に上書きできる既定を設定できる／
`~importantな宣言$は，外縁~文脈からは上書きし得ない要件を施行できる
◎
Note: This effectively means that normal declarations belonging to an encapsulation context can set defaults that are easily overridden by the outer context, while important declarations belonging to an encapsulation context can enforce requirements that cannot be overridden by the outer context.
</p>
	</dd>
	<dt>
`詳細度@
（ `specificity^en ）
</dt>
	<dd>
各 宣言は、それが現れる~style規則（の選択子）と同じ詳細度を持つ。
選択子の
<a href="~SELECTORS4#specificity">詳細度を算出する方法</a>
は、
`SELECT$r にて述べられている。
この段の目的においては、~style規則に属さない【すなわち，選択子を伴わない】宣言（
<a href="~CSSSTYLEATTR#interpret">~style属性の内容</a>
など）は、他より詳細度が高いものと見なされる。
詳細度が高いものほど優先される。
◎
The Selectors module [SELECT] describes how to compute the specificity of a selector. Each declaration has the same specificity as the style rule it appears in. For the purpose of this step, declarations that do not belong to a style rule (such as the contents of a style attribute) are considered to have a specificity higher than any selector. The declaration with the highest specificity wins.
</dd>

	<dt>
`出現順序@ （ `order of appearance^en ）
</dt>
	<dd>
<p>
文書~順序
【~stylesheet内に現れる順序】
において より後に現れる宣言ほど優先される。
この目的においては：
◎
The last declaration in document order wins. For this purpose:
</p>
		<ul>
			<li>
`import$at 規則で~importされた~stylesheet内の宣言は、その規則が その~stylesheetで代用されたかのように，順序付けられる。
◎
Declarations from imported style sheets are ordered as if their style sheets were substituted in place of the @import rule.
</li>
			<li>
大元の文書から独立に~linkされた複数の~stylesheet内の宣言は、それらの~stylesheetが，~host文書~言語により決定される~link順で連結されたかのように扱われる。
◎
Declarations from style sheets independently linked by the originating document are treated as if they were concatenated in linking order, as determined by the host document language.
</li>
			<li>
`~style属性$内の宣言は、その属性が現れた要素たちの文書~順序に則って順序付けられ，どの~stylesheetよりも後に置かれる。
◎
Declarations from style attributes are ordered according to the document order of the element the style attribute appears on, and are all placed after any style sheets.
</li>
		</ul>
	</dd>
</dl>

<p>
`~cascadeの出力@
は、各~要素の各~prop用のすべての`宣言d値$を，この節に述べた規則に従って~sortした~listである（空にもなり得る）。
◎
The output of the cascade is a (potentially empty) sorted list of declared values for each property on each element.
</p>

		</section>
		<section id="cascading-origins">
<h3 title="Cascading Origins">6.2. ~cascade法における出自</h3>

<p>
各~style規則には、
`出自@
（ `cascade origin^en ）がある
— それは、規則が~cascadeのどの段階に入るかを決定する。
~CSSは、中核的な`出自$として，次の 3 種を定義する：
◎
Each style rule has a cascade origin, which determines where it enters the cascade. CSS defines three core origins:
</p>

<dl class="def-list">
	<dt>
`作者~出自@
（ `author origin^en ）
◎
Author Origin
</dt>
	<dd>
文書~言語の規約に則って，~source文書~用に作者が指定する~stylesheet。
例えば~HTMLでは，文書~内に含められたり, 外部へ~linkされ得る。
◎
The author specifies style sheets for a source document according to the conventions of the document language. For instance, in HTML, style sheets may be included in the document or linked externally.
</dd>

	<dt>
`利用者~出自@
（ `user origin^en ）
◎
User Origin
</dt>
	<dd>
利用者は、個々の文書~用に，~style情報を指定することもある。
例えば，利用者が~stylesheetを包含する~fileを指定することもあれば、
~UAが利用者~stylesheet（あるいはそのように挙動するもの）を生成する~UIを供することもある。
◎
The user may be able to specify style information for a particular document. For example, the user may specify a file that contains a style sheet or the user agent may provide an interface that generates a user style sheet (or behaves as if it did).
</dd>

	<dt>
`~UA出自@
（ `user agent origin^en ）
◎
User-Agent Origin
</dt>
	<dd>
適合~UAは、既定の~stylesheet（あるいはそのように挙動するもの）を適用するモノトスル。
~UAの既定の~stylesheetは、文書~言語の要素を，文書~言語にて一般に期待されている呈示を満たす仕方で呈示するべきである（例えば 視覚系~browserは，~HTMLの `em^e 要素を~italic~fontで呈示するなど）
— 例：
<a href="~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints">~HTMLの~UA~stylesheet</a>
`HTML$r。
◎
Conforming user agents must apply a default style sheet (or behave as if they did). A user agent’s default style sheet should present the elements of the document language in ways that satisfy general presentation expectations for the document language (e.g., for visual browsers, the EM element in HTML is presented using an italic font). See e.g. the HTML user agent style sheet. [HTML]
</dd>
</dl>

<p class="trans-note">【
この仕様も含む~CSS仕様 全般にわたり、この出自を指して，
“〜`~levelの^em~style” と記されたり，（
“作者`~levelの^em…” , “~UA`~levelの^em…”
等々），更に省略して
“利用者~style”,
等々と記されることが多い。
】</p>

<p>
~CSSに対する拡張は、次に挙げる追加的な`出自$も定義する：
◎
Extensions to CSS define the following additional origins:
</p>

<dl class="def-list">
	<dt>
`~animation出自@
（ `animation origin^en ）
◎
Animation Origin
</dt>
	<dd>
CSS Animations `css-animations-1$r
は、稼働中にその効果を表現する， “virtual” 規則を生成する。
◎
CSS Animations [css-animations-1] generate “virtual” rules representing their effects when running.
</dd>

	<dt>
`遷移~出自@
（ `transition origin^en ）
◎
Transition Origin
</dt>
	<dd>
CSS Animations 同様，
CSS Transitions `css-transitions-1$r
も、稼働中にその効果を表現する， “virtual” 規則を生成する。
◎
Like CSS Animations, CSS Transitions [css-transitions-1] generate “virtual” rules representing their effects when running.
</dd>
</dl>

		</section>
		<section id="importance">
<h3 title="Important Declarations: the !important annotation">6.3. ~important宣言： `!important^css</h3>

<p>
~CSSでは、作者~stylesheetと利用者~stylesheetの間で力の均衡をとることも~~考慮されている。
既定では、作者~stylesheet内の規則が利用者~stylesheet内のそれを上書きし，利用者~stylesheet内の規則が~UAの既定の~stylesheet内の規則を上書きする。
宣言を`~importantな宣言$にして~cascadeにおける重みを増やすことにより，この優先順位を逆にできる。
◎
CSS attempts to create a balance of power between author and user style sheets. By default, rules in an author’s style sheet override those in a user’s style sheet, which override those in the user-agent’s default style sheet. To balance this, a declaration can be marked important, which increases its weight in the cascade and inverts the order of precedence.
</p>

<p>
宣言のうち、次に該当するものは
`~importantな宣言@
とされ，他のすべては
`通常の宣言@
とされる
⇒
`css-syntax-3$r にて定義されるとおりに `!important^css 注釈を伴う
— すなわち、その値【`declaration-value$t】
の中の最後の 2 個の（空白でも~commentでもない）~tokenは，順に次で与えられている
⇒＃
区切子~token【`delim-token$t】 `!^l,
識別子~token【`ident-token$t】 `important^l
◎
A declaration is important if it has a !important annotation as defined by [css-syntax-3], i.e. if the last two (non-whitespace, non-comment) tokens in its value are the delimiter token ! followed by the identifier token important. All other declarations are normal (non-important).
</p>

<div class="example">

<pre class="lang-css">
[hidden] { display: none !important; }
</pre>

</div>

<p>
`~importantな宣言$は、`通常の宣言$より優先される。
［
作者~stylesheet／利用者~stylesheet
］は`~importantな宣言$を包含してもヨイ。
`利用者~出自$に属する`~importantな宣言$は、`作者~出自$に属する`~importantな宣言$を上書きする。
この~CSS特能を利用すれば、利用者の手による，呈示~制御~用の特別な要件（大きな~font, 色の組合n, 等々）を与えることで、文書の~accessibilityも向上させられる。
◎
An important declaration takes precedence over a normal declaration. Author and user style sheets may contain important declarations, with user-origin important declarations overriding author-origin important declarations. This CSS feature improves accessibility of documents by giving users with special requirements (large fonts, color combinations, etc.) control over presentation.
</p>

<p>
`~importantな宣言$は、その`出自$に関わらず，どの~animationよりも優先される。
これにより、作者は，重要な事例で~animateされた値を上書きできるようになる（~animateされた値は、通常は，他のすべての規則を上書きする）。
`css-animations-1$r
◎
Important declarations from all origins take precedence over animations. This allows authors to override animated values in important cases. (Animated values normally override all other rules.) [css-animations-1]
</p>

<p>
~UA~stylesheetも，`~importantな宣言$を包含してヨイ。
これらは、他のすべての［
`作者~出自$／`利用者~出自$
］に属する宣言を上書きする。
◎
User agent style sheets may also contain important declarations. These override all author and user declarations.
</p>

<div class="example">

<p>
次の例の 利用者~stylesheet内の 1 個目の規則が包含する宣言は、
`!important^css を伴うので，作者~stylesheetの対応する宣言を上書きする。
2 個目の規則についても `!important^css を伴うので同様に優先されることになる。
しかしながら，利用者~stylesheet内の 3 個目の宣言には `!important^css は無いので、作者~stylesheetの中の（`略式~prop$の~styleを設定する） 2 個目の規則の方が優先されることになる。
また、 3 個目の作者~規則より `!important^css を伴う 2 個目の作者~規則の方が優先されることになる。
すなわち， `!important^css を伴う宣言は、同じ作者~stylesheetの中でも機能する。
◎
The first rule in the user’s style sheet in the following example contains an !important declaration, which overrides the corresponding declaration in the author’s style sheet. The declaration in the second rule will also win due to being marked !important. However, the third declaration in the user’s style sheet is not !important and will therefore lose to the second rule in the author’s style sheet (which happens to set style on a shorthand property). Also, the third author rule will lose to the second author rule since the second declaration is !important. This shows that !important declarations have a function also within author style sheets.
</p>

<pre class="lang-css">
/* <span class="comment">
利用者による~stylesheet
◎
From the user’s style sheet
</span> */
p { text-indent: 1em !important }
p { font-style: italic !important }
p { font-size: 18pt }

/* <span class="comment">
作者による~stylesheet
◎
From the author’s style sheet
</span> */
p { text-indent: 1.5em !important }
p { font: normal 12pt sans-serif !important }
p { font-size: 24pt }
</pre>

<table><thead><tr><th>
~prop
◎
Property
<th>最優先な値
◎
Winning value
</thead><tbody>

<tr><th>`text-indent$p
<td>`1em^v

<tr><th>`font-style$p
<td>`italic^v

<tr><th>`font-size$p
<td>`12pt^v

<tr><th>`font-family$p
<td>`sans-serif^v
</tbody></table>

</div>

		</section>
		<section id="preshint">
<h3 title="Precedence of Non-CSS Presentational Hints">6.4. ~CSSによるものでない呈示用~hintの優先順位</h3>

<p>
~UAは、~source文書の~markup内の呈示用~hint†を尊守してもヨイ。
例えば `HTML$r における `bgcolor^a 属性や `s$e 要素。
文書~言語に基づくすべての~style付けは、対応する~CSS規則に翻訳した上で，［
`~UA出自$に属する規則, あるいは［
`詳細度$ 0 を伴って作者~stylesheetの先頭に置かれた，`作者~出自$に属する規則
］］として，~cascadeに入するモノトスル。
文書~言語は、そのような呈示用~hintが［
`~UA出自$／`作者~出自$
］のどちらに属するものとして`~cascade$に入するかを定義してもヨイ。
その場合、~UAは，それに則って挙動するモノトスル。
例えば，~SVGでは、その`呈示~属性$を作者~levelに対応付けている。
◎
The UA may choose to honor presentational hints in a source document’s markup, for example the bgcolor attribute or s element in [HTML]. All document language-based styling must be translated to corresponding CSS rules and either enter the cascade as UA-origin rules or be treated as author-origin rules with a specificity of zero placed at the start of the author style sheet. A document language may define whether such a presentational hint enters the cascade as UA-origin or author-origin; if so, the UA must behave accordingly. For example, [SVG11] maps its presentation attributes into the author level.
</p>

<p class="trans-note">【†
“`presentational hints^en”
— 本来は~CSSが受持つべき，呈示~用の役割も担う~markup
（参考：<a href="~HTMLrendering#presentational-hints">~HTMLが定義する呈示用~hint</a>）
】</p>

<p class="note">注記：
呈示用~hintのうち，`~UA出自$に属する規則として~cascadeに入するものは、［
`作者~出自$／`利用者~出自$
］に属する~styleで上書きできる。
`作者~出自$に属する規則として~cascadeに入するものは、`作者~出自$に属する~styleで上書きできるが、`利用者~出自$に属する`~important$でない~styleからは，上書きできない。
~host言語は、これらを考慮した上で，呈示用~hint用に適切な`出自$を選ぶべきである。
◎
Note: Presentational hints entering the cascade as UA-origin rules can be overridden by author-origin or user-origin styles. Presentational hints entering the cascade as author-origin rules can be overridden by author-origin styles, but not by non-important user-origin styles. Host languages should choose the appropriate origin for presentational hints with these considerations in mind.
</p>

		</section>
	</section>
	<section id="defaulting">
<h2 title="Defaulting">7. ~default法</h2>

<p>
`~cascade$の結果（`~cascadeの出力$）が空である場合、他の何らかの仕方で`指定d値$を見出すモノトスル。
`継承d~prop$は、その既定の値（ `default^en ）を，`継承$を通して親~要素から取り込む。
他のすべての~propは、その`初期~値$を既定の値としてとる。
~stylesheet作者は、［
`inherit$v ／ `initial$v
］~keywordを通して，明示的に［
継承／初期化
］を要請できる。
◎
When the cascade does not result in a value, the specified value must be found some other way. Inherited properties draw their defaults from their parent element through inheritance; all other properties take their initial value. Authors can explicitly request inheritance or initialization via the inherit and initial keywords.
</p>

		<section id="initial-values">
<h3 title="Initial Values">7.1. 初期~値</h3>

<p>
各種~propには、それぞれの~prop定義表にて，その
`初期~値@
（ `initial value^en ）が定義される。
要素の~prop %P が`継承d~prop$でなく, かつ %P の`~cascaded値$も無い場合、その要素の %P の`指定d値$は， %P の`初期~値$で与えられる。
◎
Each property has an initial value, defined in the property’s definition table. If the property is not an inherited property, and the cascade does not result in a value, then the specified value of the property is its initial value.
</p>

		</section>
		<section id="inheriting">
<h3 title="Inheritance">7.2. 継承法</h3>

<p>
~prop値は
`継承@
（ `inheritance^en ）により，親~要素から その各~子~要素へ伝播する。
要素の~propの
`継承d値@
（ `inherited value^en ）は、要素の親~要素の~propの`算出d値$で与えられる。
親~要素がない根~要素~用の`継承d値$は、~propの`初期~値$で与えられる。
◎
Inheritance propagates property values from parent elements to their children. The inherited value of a property on an element is the computed value of the property on the element’s parent element. For the root element, which has no parent element, the inherited value is the initial value of the property.
</p>

<p>
継承は、~shadowを伴う~DOM~treeに対しては，`平坦~化された要素~tree$に対し演算する。
◎
For a [DOM] tree with shadows, inheritance operates on the flattened element tree.＼
</p>

<p class="note">注記：
すなわち，ある `slot$e 要素 %slot にアテガわれた要素は、~styleを
— `~light~tree$の親から直にではなく —
%slot から継承する。
◎
This means that slotted elements inherit from the slot they’re assigned to, rather than directly from their light tree parent.＼
</p>

<p class="note">注記：
各 `疑似要素$は、その定義に述べられる，`仮想の~tag列$ `CSS-PSEUDO-4$r に則って~prop値を継承する。
◎
Pseudo-elements inherit according to the fictional tag sequence described for each pseudo-element. [CSS-PSEUDO-4]
</p>

<p>
一部の~propは、その~prop定義表にて，
`継承d~prop@
（ `inherited property^en ）であるものと定義される。
これは、`~cascaded値$が無いときは，その値が`継承$により決定されることを意味する。
◎
Some properties are inherited properties, as defined in their property definition table. This means that, unless the cascade results in a value, the value will be determined by inheritance.
</p>

<p>
~propを明示的に継承させることもできる。
`inherit$v ~keywordを見よ。
◎
A property can also be explicitly inherited. See the inherit keyword.
</p>

<p class="note">注記：
継承は，文書~treeに従うものであり、生成される`~box~tree$における組み替え
— 合間に`匿名~box$が挟まれるなど —
からは影響されないことに注意。
◎
Note: Inheritance follows the document tree and is not intercepted by anonymous boxes, or otherwise affected by manipulations of the box tree.
</p>

		</section>
		<section id="defaulting-keywords">
<h3 title="Explicit Defaulting">7.3. 明示的な~default法</h3>

<p>
以下では、各種`~CSS全域~keyword$を定義する。
これらの値をとる~prop宣言は、特定0の`~default法$の挙動を明示的に指定する。
`css-values-3$r
にて指定される様に、すべての~CSS~propは，これらの値を受容する。
◎
Several CSS-wide property values are defined below; declaring a property to have these values explicitly specifies a particular defaulting behavior. As specified in CSS Values and Units Level 3 [css-values-3], all CSS properties can accept these values.
</p>

			<section id="initial">
<h4 title="Resetting a Property: the initial keyword">7.3.1. ~propを設定し直す： `initial^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`initial@v
~keywordになる場合、その`指定d値$は，~propの`初期~値$にされる。
◎
If the cascaded value of a property is the initial keyword, the property’s specified value is its initial value.
</p>

			</section>
			<section id="inherit">
<h4 title="Explicit Inheritance: the inherit keyword">7.3.2. 明示的な継承： `inherit^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`inherit@v
~keywordになる場合、その~propの`継承d値$が，`指定d値$および`算出d値$を与える。
◎
If the cascaded value of a property is the inherit keyword, the property’s specified and computed values are the inherited value.
</p>

			</section>
			<section id="inherit-initial">
<h4 title="Erasing All Declarations: the unset keyword">7.3.3. すべての宣言を取り消す ： `unset^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`unset@v
~keywordになる場合、~propは`継承d~prop$であるならば `inherit$v として扱われ，そうでなければ
`initial$v として扱われる。
この~keywordにより、以前の`~cascade$に出現した すべての`宣言d値$は取り消され、継承するかどうかも~prop（`略式~prop$の場合は，そのすべての下位propのそれぞれ）に応じて，適切に扱われる。
◎
If the cascaded value of a property is the unset keyword, then if it is an inherited property, this is treated as inherit, and if it is not, this is treated as initial. This keyword effectively erases all declared values occurring earlier in the cascade, correctly inheriting or not as appropriate for the property (or all longhands of a shorthand).
</p>

<p class="trans-note">【
“以前の…すべての” — 
`~cascade法$による順位付けの結果、`出現順序$による順位付けに従って， “以前の” 宣言d値が取り消される（`詳細度$など，より高次の順位付けにおいて優先度が高い宣言d値まで上書きされるわけではない）。
】</p>

			</section>
			<section id="revert">
<h4 title="Rolling Back The Cascade: the revert keyword">7.3.4. ~cascadeの巻戻し： `revert^v ~keyword</h4>

<p class="trans-note">【
巻戻し（ `rolling back^en ）：
~prop値を，他の`出自$†による既定の値（他の出自にてその~propに指定されている値）に “戻す” 。
（† 下の定義により、通常は，優先順位がより低い出自による~style
— `~importantな宣言$対しては， “より高い” に逆転することになる。）
】</p>

<p>
~propの`~cascaded値$が
`revert@v
~keywordになる場合の挙動は、その宣言が属する`出自$に依存する：
◎
If the cascaded value of a property is the revert keyword, the behavior depends on the cascade origin to which the declaration belongs:
</p>
<ul class="switch">
	<li>
`~UA出自$
⇒
`unset$v に等価。
◎
user-agent origin
• Equivalent to unset.
</li>
	<li>
`利用者~出自$
⇒
`~cascaded値$を~UA~levelに巻戻す。
すなわち，当の要素の~propの`指定d値$は、［
~propには，［
`作者~出自$／`利用者~出自$
］に属する規則は指定されていなかった
］かのように計算される。
◎
user origin
• Rolls back the cascaded value to the user-agent level, so that the specified value is calculated as if no author-origin or user-origin rules were specified for this property on this element.
</li>
	<li>
`作者~出自$
⇒
`~cascaded値$を利用者~levelに巻戻す。
すなわち，当の要素の~propの`指定d値$は、［
~propには，`作者~出自$に属する規則は指定されていなかった
］かのように計算される。
`revert$v の目的においては、この出自には`~animation出自$も含まれる。
◎
author origin
• Rolls back the cascaded value to the user level, so that the specified value is calculated as if no author-origin rules were specified for this property on this element. For the purpose of revert, this origin includes the Animation origin.
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">8. 変更点</h2>

【この訳では、差分の記述は省略する。】

<dl>
	<dt id="changes-2018">
<a href="~TR/2018/CR-css-cascade-4-20180828/">2018年 8月 28日 勧告候補</a>
からの些末でない変更点
◎
8.1. Changes Since the 28 August 2018 Candidate Recommendation
◎
Non-trivial changes since the 28 August 2018 Working Draft include:
</dt>
	<dd id="change-2018-context">
~shadow~DOM `DOM$r に適応するため、`~cascade$の~sort判定基準に`文脈$を追加した。
（ `5372$issue ）
◎
Added context to the cascade sort criteria to accommodate Shadow DOM. [DOM] (Issue 5372)
</dd>
	<dd id="change-2018-shadow-inherit">
`~shadow~tree$を考慮に入れるよう、`継承$は，`平坦~化された要素~tree$越しに演算するものと定義した。
◎
Defined that, in consideration of shadow trees, inheritance operates over the flattened element tree.
</dd>
	<dd id="change-2018-drop-scoped">
`~cascade$を~sortするための判定基準から，視野-法を除去した
— それは、実装されたことがないので。
◎
Removed scoping from the cascade sort criteria, because it has not been implemented.
</dd>

	<dt id="changes-2016">
<a href="https://www.w3.org/TR/2016/CR-css-cascade-4-20160114/">2016年 1月 14日 勧告候補</a>
からの些末でない変更点
◎
8.2. Changes Since the 14 January 2016 Candidate Recommendation
◎
Non-trivial changes since the 14 January 2016 Working Draft include:
</dt>
	<dd id="change-2016-alias">
~CSSが利用する<a href="#aliasing">§ 別名化</a>の種別を精確に定義した。
（ `866$issue ）
◎
Precisely defined the types of aliasing that CSS uses. (Issue 866) See § 3.1 Aliasing.
</dd>
	<dd id="change-2016-revert">
`revert$v が影響するのは、~cascaded値であって，継承される値ではないことを明確化した。
◎
Clarified that revert only affects the cascaded value, not the inherited value.

• user origin
•• Rolls back the cascade cascaded value to the user-agent level, so that the specified value is calculated as if no author-level or user-level rules were specified for this property on this element . 
• author origin
•• Rolls back the cascade cascaded value to the user level, so that the specified value is calculated as if no author-level rules were specified for this property on this element.
</dd>
	<dd id="change-2016-custom-all">
`all$p 略式は`~custom~prop$を設定し直さないことを明確化した。
（ `2518$issue ）
◎
Clarified that custom properties are not reset by the all shorthand. (2518)
• The all property is a shorthand that resets all CSS properties except direction and unicode-bidi. … It does not reset custom properties [css-variables-1].
</dd>
	<dd id="change-2016-import">
~importされた~stylesheetは、~importしている~stylesheetとは
— 規則の順序関係, 等々の点で —
で別々に解釈されることについて，より精確に定義した。
◎
Defined more precisely that imported stylesheets are interpreted separately from the importing stylesheet, in terms of ordering of rules, etc.

• If an @import rule refers to a valid stylesheet, user agents must treat the contents of the stylesheet as if they were written in place of the @import rule , with two exceptions:
•• If a feature (such as the @namespace rule) explicitly defines that it only applies to a particular stylesheet, and not any imported ones, then it doesn’t apply to the imported stylesheet.
•• If a feature relies on the relative ordering of two or more constructs in a stylesheet (such as the requirement that @charset must not have any other content preceding it), it only applies between constructs in the same stylesheet. 
</dd>
	<dd id="change-2016-text">
~text~nodeは、その親~要素の子であると見なされ，`~default法$を介して~styleを受取るものと指定した
— ~text~nodeの~propは，今や、
`display$p に対する `contents^v を介して親の~propと別個に観測-可能になるので。
`css-display-3$r
◎
Specified that text nodes are considered children of their parent element, and receive styles via defaulting, as their properties are now observable distinct from their inline parent’s via display: contents [css-display-3].

• For the purpose of this specification, text nodes are treated as element children of their associated element, and possess the full set of properties; since they cannot be targetted by selectors all of their computed values are assigned by defaulting.
</dd>
	<dd id="change-2016-override">
廃用にされた “上書き” `出自$を除去した
— 元々は
<a href="~TR/2000/REC-DOM-Level-2-Style-20001113/">DOM Level 2 Style</a>
により定義されたが，後に放棄された。
（ <a href="~CSSissue#1385">課題 #1385</a> ）
◎
Removed any mention of the obsolete “override” origin, originally defined by DOM Level 2 Style and later abandoned. (Issue 1385) 
</dd>
	<dd>
<a href="~CSSWG/css-cascade-3/issues-cr-2016">各~commentに対する処置集</a>もある。
◎
A Disposition of Comments is available.
</dd>

	<dt id="changes-2015">
<a href="~TR/2015/WD-css-cascade-4-20150421/">2015年 4月 21日 作業草案</a>
からの変更点
◎
8.3. Changes Since the 21 April 2015 Working Draft
◎
Changes since the 21 April 2015 Working Draft include:
</dt>
	<dd>
`default^v ~keywordを `revert$v に改称した。
◎
Renamed default keyword to revert.
</dd>
	<dd>
`supports^f 構文~内の多重~丸括弧は、宣言を 1 個だけ包含する場合には~~省けるようにした。
◎
Allowed dropping duplicate parentheses in supports() syntax when it only contains one declaration.
</dd>

	<dt id="additions-l3">
<a href="~TR/css-cascade-3/">Level 3</a>
からの追加
◎
8.4. Additions Since Level 3
◎
The following features have been added since Level 3:
</dt>
	<dd>
~cascadeの巻戻し用の `revert$v ~keywordを導入した。
◎
Introduced revert keyword, for rolling back the cascade.
</dd>
	<dd>
supports 条件付き `import$at 規則~用に `supports^f 構文を導入した。
◎
Introduced supports() syntax for supports-conditional @import rules.
</dd>
	<dd>
~shadow~DOM `DOM$r
に適応するため，`~cascade$の~sort判定基準に`~encapsulation文脈$を追加した。
◎
Added encapsulation context to the cascade sort criteria to accommodate Shadow DOM. [DOM]
</dd>
	<dd>
~CSSが旧来の構文を~supportするために利用する，~propを別名化する仕組みを 2 つ定義した。
<a href="#aliasing">§ 別名化</a>を見よ。
◎
Defined the property two aliasing mechanisms CSS uses to support legacy syntaxes. See See § 3.1 Aliasing.
</dd>

	<dt id="changes-2">
<a href="~TR/CSS2/cascade.html">Level 2</a>
からの追加
◎
8.5. Additions Since Level 2
◎
The following features have been added since Level 2:
</dt>
	<dd>
`all$p 略式~prop
◎
The all shorthand
</dd>
	<dd>
`unset$v ~keyword
◎
The unset keyword
</dd>
	<dd>
［
~animation, 遷移
］を`~cascade$の中に組入れた。
◎
Incorporation of animations and transitions into the cascade.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に貢献された次の方々に：
</p>

<p lang="en-x-a0">
David Baron, Tantek Çelik, Simon Sapin, and Boris Zbarsky contributed to this specification.
</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacyと~securityの考慮点</h2>

<ul>
	<li>
~cascade処理-は、［
同一-生成元, 非同一-生成元
］の~stylesheetを判別しないため、文書に適用される~styleの算出d値から，非同一-生成元~stylesheetの内容を推定するのも可能になる。
◎
The cascade process does not distinguish between same-origin and cross-origin stylesheets, enabling the content of cross-origin stylesheets to be inferred from the computed styles they apply to a document.
</li>
	<li>
~style規則の適用を介して表出される［
利用者~選好, ~UAの既定
］は、~cascade処理-により公開されるので，それらが文書に適用した~styleの算出d値から推定できる。
◎
User preferences and UA defaults expressed via application of style rules are exposed by the cascade process, and can be inferred from the computed styles they apply to a document.
</li>
	<li>
`import$at 規則は、非同一-生成元からの~stylesheetを読込む際に
<a href="~FETCH#cors-protocol">~CORS~protocol</a>
を適用せず，それらを自由に~importして適用するのを許容する。
◎
The @import rule does not apply the CORS protocol to loading cross-origin stylesheets, instead allowing them to be freely imported and applied.
</li>
	<li>
`import$at 規則は、`~Content-Type~metadata$を伴わない資源を（または、~host文書は`過去互換~mode$下にある場合は、同一-生成元からのどの資源も）【その~MIME型を】 `text/css^c と見做す
— その結果、［
任意な資源を~pageの中へ~importして~CSSとして解釈する ／
文書に適用される~styleの算出d値から敏感な~dataを推定する
］ことも許容することになり得る。
◎
The @import rule assumes that resources without Content-Type metadata (or any same-origin file if the host document is in quirks mode) are text/css, potentially allowing arbitrary files to be imported into the page and interpreted as CSS, potentially allowing sensitive data to be inferred from the computed styles they apply to a document.
</li>
</ul>

	</section>
</main></div>

