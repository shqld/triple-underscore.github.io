<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Painting API Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 't': // type
	text = `&lt;${key}&gt;`;
	break;
case 'f': // 
	text = `${key}()`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
case 'sl': // internal slot
	text = `[[${key}]]`;
	break;
case 'issue':
	return(
`<a href="https://github.com/w3c/css-houdini-drafts/issues/${key}">issue#${key}</a>`
	);
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>


<script type="text/plain" id="_source_data">

●●options
spec_title:CSS Painting API Level 1
spec_date:2018-08-27
trans_update:2019-01-02
source_checked:180827
original_url:https://drafts.css-houdini.org/css-paint-api-1/
	page_state_key:CSS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2018,use
trans_1st_pub:2019-01-02


●●class_map
p:property
v:value
u:unit
f:func
t:type
u:unit
css:css
e:element
a:attr
E:error
sl:js-slot
jv:js-value
jC:js-class
jA:abstract

●●tag_map
p:code
f:code
u:code
v:code
t:var
I:code
m:code
E:code
e:code
u:code
a:code
css:code
c:code
sl:span
jC:span
jv:code
jA:span
i:i
em:em
V:var

●●original_id_map

●●link_map
	●IDL

boolean:~WEBIDL#idl-boolean
double:~WEBIDL#idl-double
unrestricted double:~WEBIDL#idl-unrestricted-double
VoidFunction:~WEBIDL#VoidFunction
DOMString:~WEBIDL#idl-DOMString
I.Function:~WEBIDL#Function

Exposed:~WEBIDL#Exposed
Global:~WEBIDL#Global
SameObject:~WEBIDL#SameObject

E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.InvalidModificationError:~WEBIDL#invalidmodificationerror

I.PaintWorkletGlobalScope:#paintworkletglobalscope
I.PaintRenderingContext2DSettings:#dictdef-paintrenderingcontext2dsettings
I.PaintRenderingContext2D:#paintrenderingcontext2d
I.PaintSize:#paintsize

I.CSS:~CSSOM1#namespacedef-css
I.CSSImageValue:~CSSTOM1#cssimagevalue
I.CanvasCompositing:~HEcanvas#canvascompositing
I.CanvasDrawImage:~HEcanvas#canvasdrawimage
I.CanvasDrawPath:~HEcanvas#canvasdrawpath
I.CanvasFillStrokeStyles:~HEcanvas#canvasfillstrokestyles
I.CanvasImageData:~HEcanvas#canvasimagedata
I.CanvasImageSmoothing:~HEcanvas#canvasimagesmoothing
I.CanvasImageSource:~HEcanvas#canvasimagesource
I.CanvasPath:~HEcanvas#canvaspath
I.CanvasPathDrawingStyles:~HEcanvas#canvaspathdrawingstyles
I.CanvasRect:~HEcanvas#canvasrect
I.CanvasRenderingContext2D:~HEcanvas#canvasrenderingcontext2d
I.CanvasRenderingContext2DSettings:~HEcanvas#canvasrenderingcontext2dsettings
I.CanvasShadowStyles:~HEcanvas#canvasshadowstyles
I.CanvasState:~HEcanvas#canvasstate
I.CanvasText:~HEcanvas#canvastext
I.CanvasTextDrawingStyles:~HEcanvas#canvastextdrawingstyles
I.CanvasTransform:~HEcanvas#canvastransform
I.CanvasUserInterface:~HEcanvas#canvasuserinterface
I.StylePropertyMap:~CSSTOM1#stylepropertymap
I.StylePropertyMapReadOnly:~CSSTOM1#stylepropertymapreadonly
I.Worklet:~WORKLETS1#worklet
I.WorkletGlobalScope:~WORKLETS1#workletglobalscope
I.DOMException:~WEBIDL#idl-DOMException


m.paintWorklet:#dom-css-paintworklet
m.devicePixelRatio:#dom-paintworkletglobalscope-devicepixelratio
m.alpha:#dom-paintrenderingcontext2dsettings-alpha
m.registerPaint:#dom-paintworkletglobalscope-registerpaint
m.width:#dom-paintsize-width
m.height:#dom-paintsize-height

	m.devicePixelRatio:~CSSOMVIEW#dom-window-devicepixelratio
m.drawImage:~HEcanvas#dom-context-2d-drawimage
m.clip:~HEcanvas#dom-context-2d-clip

	name:#dom-paintworkletglobalscope-registerpaint-name-paintctor-name
	paintCtor:#dom-paintworkletglobalscope-registerpaint-name-paintctor-paintctor


	●p
p.border-image:~CSSBG#propdef-border-image
p.cursor:~CSSUI#propdef-cursor

f.paint:#funcdef-paint
t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident:~CSSVAL#typedef-ident
t.image:~CSSIMAGE#typedef-image

	●CSSPAINT
その時点の具体~obj~size:#_snapped-concrete-object-size

塗り定義:#paint-definition
塗り定義~map:#paint-definitions
pD.~class構築子:#paint-definition-class-constructor
pD.塗り関数:#paint-definition-paint-function
pD.構築子~妥当~flag:#paint-definition-constructor-valid-flag
pD.入力~prop~list:#paint-definition-input-properties
pD.塗り~2D描画~文脈~設定群:#paint-definition-paintrenderingcontext2dsettings-object
pD.塗り~class~instance~map:#paint-class-instances

文書~塗り定義:#document-paint-definition
文書~塗り定義~map:#document-paint-definitions
dPD.入力~prop~list:#document-paint-definition-input-properties
dPD.入力~引数~構文:#document-paint-definition-input-argument-syntaxes
dPD.塗り~2D描画~文脈~設定群:#document-paint-definition-paintrenderingcontext2dsettings-object

出力~bitmap:#paintrenderingcontext2d-output-bitmap
~alpha~flag:#paintrenderingcontext2d-alpha
塗り~2D描画~文脈を作成する:#create-a-paintrenderingcontext2d-object
塗り関数の画像を描く:#draw-a-paint-image
塗り~callbackを呼出す:#invoke-a-paint-callback

	#global-scope-selection

	●外部

~list:~INFRA#list
空にする:~INFRA#list-empty
空:~INFRA#list-is-empty
付加する:~INFRA#list-append
有順序~map:~INFRA#ordered-map
構造体:~INFRA#struct

jA.Construct:~TC39#sec-construct
jA.Get:~TC39#sec-get-o-p
jA.IsConstructor:~TC39#sec-isconstructor
jA.Type:~TC39#sec-ecmascript-data-types-and-values
~class構築子:~TC39#sec-constructor
	jA.get:~TC39#sec-get-o-p

~IDL値に変換-:~WEBIDL#dfn-convert-ecmascript-to-idl-value
	誤:~WEBIDL#web-idl-arguments-list-converting
	誤:~WEBIDL#dfn-convert-idl-to-ecmascript-value
~callback関数を呼出す:~WEBIDL#invoke-a-callback-function
~callback関数:~WEBIDL#dfn-callback-function
	~callback this 値:~WEBIDL#dfn-callback-this-value
	~THROW:~WEBIDL#dfn-throw

文書:~DOM4#concept-document

sl.declarations:~CSSTOM1#dom-stylepropertymapreadonly-declarations-slot

~worklet大域~scopeを作成する:~WORKLETS1#create-a-workletglobalscope
~worklet大域~scope型:~WORKLETS1#worklet-global-scope-type
~worklet大域~scope~list:~WORKLETS1#worklets-workletglobalscopes
所有者~文書:~WORKLETS1#workletglobalscope-owner-document

~supportされる構文~文字列:~CSSPV1#supported-syntax-strings

~taskを~queueする:~WAPI#queue-a-task
並列的:~HTMLINFRA#in-parallel

無効な画像:~CSSIMAGE4#invalid-image
具体~obj~size:~CSSIMAGE#concrete-object-size
内在的~寸法:~CSSIMAGE#intrinsic-dimensions
~obj~size折衝~algo:~CSSIMAGE#object-size-negotiation

~box:~CSSDISP#css-box

算出d値:~CASCADE#computed-value

~custom~prop:~CSSVAR#custom-property

~supportされる~CSS~prop:~CSSOM1#supported-css-property

透明な黒:~CSSCOLOR#transparent-black
不透明な黒:~CSSCOLOR#opaque-black

~bitmap寸法を設定する:~HEcanvas#concept-canvas-set-bitmap-dimensions
既定の状態に設定し直す:~HEcanvas#reset-the-rendering-context-to-its-default-state

	https://github.com/w3c/css-houdini-drafts/blob/master/css-paint-api/EXPLAINER.md
	~CSSIMAGE#object-sizing-examples
	~WORKLETS1#code-idempotency
	https://drafts.css-houdini.org/css-paint-api-1/issues-list-2018-04-10

●●words_table1

SeqDS:<code>sequence&lt;DOMString&gt;</code>
BQ:`

●●words_table

	●データ型／操作
class::::クラス
flag::::フラグ
instance::::インスタンス
item::::アイテム
obj:object:::オブジェクト
具体:concrete:~
list::::リスト
map::::マップ
queue::::キュー
構造体:struct::~
有順序:ordered::~
変換-:convert::~
換算-:convert::~
付加-:append::~
作成-:create::~
設定-:set::~
	設定しておく:set up／setup
	設定し直す:reset
設定群:settings::~
除去-:remove::~
	^en:dispose
拡充-:populate::~
取得子:getter::~
格納-:store::~
初期:initial::~
	初期~時には:initially
初期化-:initialize::~
	初期化-:initialise
	除去する:filter／filter out
options:::option 集
内部:internal::~
slot::::スロット


	●IDL
IDL:
prop:property:::プロパティ
prototype::::
method::::メソッド
構築子:constructor::~::コンストラクタ
mixin::::
anti-alias:
call::::
callback::::
interface::::インタフェース
typedef::::
worklet::::
scope::::スコープ

WebGL:
WebIDL:
WebAnimations:Web Animations
WorkletGlobalScope:
PaintRenderingContext2DSettings:
PaintRenderingContext2D:

	●一般処理
cache::::キャッシュ
task::::タスク
thread::::スレッド
error::::エラー

折衝:negotiation::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
	解析済み:parsed::~::パース済み
生成-:generate::~
	生成し直せない:non-regeneratable
生産-:produce::~
無力化-:neuter::~
冪等性:idempotency::~
並列的:parallel::~
同期的:synchronous::~
例外:exception::~
投出-:throw::~
例外投出あり:exception が throw され得る::~
	例外投出あり:If an exception is thrown, rethrow the exception and abort all these steps
手続き:steps:~
段:step:~

	●塗り／layout
2D:
3D:
layout::::レイアウト
box::::ボックス
canvas::::キャンバス
size::::サイズ
sizing::::サイズ法
filter::::フィルタ
alpha::::アルファ
bitmap::::ビットマップ
channel::::チャネル
塗ng:painting::塗り
塗らな:paintしな::~
塗り:paint::~
塗る:paintする::~
描く:drawする::~
描ける:drawできる::~
描法:drawing::~
描画-:render::~
描画:rendering::~
画像:image::~
不透明:opaque::~
透明:transparent::~
内側:inside::~
外側:outside::~
区画:area::~
境界:boundary::~
層:layer::~
座標:coordinate::~
寸法:dimension::~
内在的:intrinsic::~
横幅:width::~
縦幅:height::~
画素:pixel::~
真円:circle::~
積層:stacking::~
空間:space::~
背後:behind::~
背景:background::~
色:color::~
	色~付きの~colored
解像度:resolution::~
黒:black:::~
矩形:rectangle::~
	矩形:rectange
切抜き:clipping::切り抜き
領域:region::~
	切抜き領域:clip
ベタ:solid:ベタ塗り
縦横比:aspect ratio::~
fill:

始端:start:~
角度:angle:~
終端:end:~
半径:radius:~
線幅:line width:~
	縦横比を保つように:proportional change

	●呈示／CSS
style::::スタイル
access::::アクセス
accessibility::access 能:アクセス能:アクセシビリティ
	~access可能:accessible:
focus::::フォーカス
animate::::アニメート
animation::::アニメーション
zoom::::ズーム
強調:highlight::~
単位:unit:~

	●仕様
API:
Web:
web:
HTML:
CSS:
JS:JavaScript
	~JS:javascript
UA:user agent:UA
algo:algorithm:::アルゴリズム
security::::セキュリティ
console::::コンソール
data::::データ
log::::ログ
debug::::デバッグ
	~debug用:debugging
dialog::::ダイアログ
privacy::::プライバシー
level::::レベル
custom::::カスタム
version::::バージョン
	~program的:programmatical
tool::::ツール
native::::ネイティブ
事例:case:~
高品質:high-quality::~
	〜品質:-quality
実際の:actualな:~
将来:future:~
前方-互換:forwards compatible:~
手続き:steps:~
概念:concept:~
特能:feature::~
目的:purpose:~
能:ability:~
課題:issue:~
	normally
通例的:usual:~
	-:available:~
適切:appropriate:~
	同様に:similarly／:similar
アリ:possible:可能
情報:information:~
	自立的:stand-alone
求める:wantする:~
	より容易に:easier
実質的:effective:~
効果:effect:~
複雑:complicated:~
複階性:complexity:複雑さ
経験則:heuristics:~
段階:stage:~
事実:fact:~
任意選択で:optionalに:~
高価:expensive:~
機会:opportunity::~
機器:device::~
発行版:publication::~
黙って:silentに:~

	注記:note
	担当する:responsible
	最も高い~~見積もり:picked as high upper bound 

	●仕様（動詞
support::::サポート
support:::サポート
	~supportされない:unsupported
fallback::::フォールバック
fallback:::フォールバック

供-:provide:~
依拠-:rely:~
先送り:defer:~
利用-:use:~
	利用して:using
再利用-:re-use:~
有用:useful:~
変更点:changes:~
変化:change:~
不変:unchanged:~
定義-:define:~
	定義-法:defining
定義:definition:~
実装-:implement:~
開発者:developer:~
序論:introduction:~
意味-:mean:~
拘束-:constrain:~
	拘束-:under 〜 constraints
拡張-:extend:~
指定-:specify:~
	指定されていない:unspecified
	指定-法:specifying
仕様:spec:~
特定的には:specificalには:具体的には
改善-:improve:~
暗黙的:implicit:~
更新-:update:~
期待-:expect:~
標準の:standardな:~
正しい:correctな:~
決定-:determine:~
無視-:ignore:~
移動-:move:~
要求-:require:~
考慮点:considerations:~
許容-:allow:~
	許容されない:disallowed
述べる:describeする:~
遂行-:perform:~
	適合する:are conformant
適用-:apply:~
	適用-可能:applicable
関係-:relate:~
既知:known:~
未知:unknown:~
作者:author:~
確保-:ensure:~
公開-:expose:~
調整-:adjust:~
設計-:design:~
存在-:exist:~
既存の:existing:~
導入-:introduce:~
受容-:accept:~
	受容-可能:acceptable
試みら:attemptさ:~
追加的な:additionalな:追加の
追加的な:additionalな:追加の
管理:management:~
取戻す:reclaimする:取り戻す
言明-:state:~
最適化:optimization:~
結付けら:associateさ:結び付けら
取扱う:handleする:取り扱う
投機-:speculate:~
投機的:speculative:~

	~~形をとる:shape
	〜に基づく:based
	おそらく:probably
	しかしながら，:however
	すなわち:that is:
	とは限らない:not necessarily
	にするため:in order for
	のみならず:limit
	もはや:no longer
	例:example
	例えば:for example
	も:still
	従って:following
	必要:need
	必要なら:potentially
	則って:according
	則って~accordingly:
	加えて:additionally
	加えて~in-addition-to:
	扱う:treat
	時を経れば:over time
	次に従って:as follows
	特に:in particular
	見よ:see
	用立てる:make use
	あり続ける:remains
	呼応して:in response to
	~~仕掛け:tooling

	●未分類（動詞
clear:
丸めた:roundした::~
保持-:hold::~
包含-:contain::~
内容:content::~
参照:reference::~
合致-:match::~
照合-:match::~
固定-:fix::~

変更-:change::~
登録-:register::~
表現-:represent::~
表示-:display::~
計算-:calculate::~
記録-:record::~
読込n:load::読み込み
読込まれ:loadされ::読み込まれ

通信-:communicate::~
遷移:transition::~
選定-:select::~
選定:selection::~

受取る:receiveする::受け取る
受取っ:receiveし::受け取っ
受取らな:receiveしな::受け取らな
失敗-:fail::~
完了-:complete::~
実行:execution::~
成功-:succeed::~
応答-:respond::~
	応答-不能:unresponsive
投出:throw::~
終了-:terminate::~
走らす:runする:~
走らせ:runし:~
走っ:runし:~
呼出せる:invokeできる:呼び出せる
呼出され:invokeされ:呼び出され
呼出した:invokeした:呼び出した
呼出す:invokeする:呼び出す
呼出n:invocation:呼び出し
被呼出時:被 invoke 時:~
	被呼出時:called
現れな:appearしな:~
追加-:add:~
所有者:owner::~
検索-:look up:~
	含-:include
	対応-:correspond

	●未分類
code::::コード
frame::::フレーム
text::::テキスト
記憶域:memory::~::メモリ
script::::スクリプト
source::::ソース
上限:limit::~
下位集合:subset::~
下層の:underlying::~
	不変で:unchanged
値:value::~
入力:input::~
内部的:internal::~
円弧:arc::~
出力:output::~
動的:dynamic::~
可視域:visual viewport::~
可視性:visibility::~
名:name::~
名前:name::~
型:type::~
大域:global::~::グローバル
妥当:valid::~
	妥当でない:invalid
無効:invalid::~
無効化:invalidation::~
属性:attribute::~
引数:argument::~
成分:component::~
文字列:string::~
文書:document::~
文法:grammar::~
文脈:context::~
既定の:default::~
未来:future::~
構文:syntax::~
演算:operation::~
状態:state::~

略式:shorthand::~

空:empty::~
等価:equivalent::~
算出d:computed::算出
要素:element::~
規則:rule::~
記法:notation::~
部位:portion::~
関数:function::~
静的:static::~
生の:raw:~
	その時点の:snapped
残念顔:sad face:~
	~~仮の:placeholder

	●変数
	塗り~2D描画~文脈:PaintRenderingContext2D object
	塗り~2D描画~文脈:paintRenderingContext2D
	塗り~2D描画~文脈~設定群:PaintRenderingContext2DSettings object
	塗り~2D描画~文脈~設定群:paintRenderingContext2DSettings

	塗り定義~map:paintDefinitionMap
	入力~prop~list:inputProperties
	-:inputPropertiesIterable
	入力~引数~list:inputArguments
	-:inputArgumentsIterable
	入力~引数~list構文~list:inputArgumentSyntaxes
	-:parsedSyntax
	-:paintValue
	文書~塗り定義~map:documentPaintDefinitionMap
	文書~塗り定義:documentDefinition
	既存の文書~塗り定義:existingDocumentDefinition
	~snapped具体~obj~size:snappedConcreteObjectSize
	具体~obj~size:concreteObjectSize
	塗り関数:paintFunction
	塗り関数~callback:paintFunctionCallback
	塗り~class~instance~map:paintClassInstanceMap
	塗り~instance:paintInstance
	~style~map:styleMap
	描画~文脈:renderingContext
	塗り~size:paintSize
	文脈~options:contextOptionsValue
	塗り構築子:paintCtor
	:paintCtor
	~worklet大域~scope:workletGlobalScope

	●指示語
新たな:new:~
全部的:full:~
現在の:current:~
	現時点／現在:currently
	時間内:within 〜 time
	個の:one／:two
	〜の代わりに:instead
	この:this
	これらの:these
	すべての:all
	その:that
	その次:next
	それらの:their
	だけに:just
	一致:identical
	一連の:sequence
	一部:part-of
	下:below
	与-:give
	両者:both
	今や:now
	他の:other
	以上の:at least:
	以前の:previous:
	元の:original
	別の:another
	各:each
	各~変化:changes
	合間:between
	同じ:same
	回:time
	多過ぎる:too many
	後:after
	後続の:subsequent
	所与の:given
	時点:at 〜 time
	最初の:first
	最後の:last
	最終的:eventual:
	次の:the following
	次回:next time
	生じ:occur
	異なる:different
	示す:show
	節:section
	結果:result
	結果の:resulting
	続けて:in a row:
	繰り返し:repeatably:
	通:through
	間:during
	任意の時点:at any time
	任意の時点に:at any point
	後続して:subsequently
	一度だけ:once
	下方:downward::~

●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-display-3/
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Image Values and Replaced Content Module Level 4. 13 April 2017. WD. URL: https://www.w3.org/TR/css-images-4/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/
[CSS-TYPED-OM-1]
    Shane Stephens; Tab Atkins Jr.; Naina Raisinghani. CSS Typed OM Level 1. 10 April 2018. WD. URL: https://www.w3.org/TR/css-typed-om-1/
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 22 December 2017. WD. URL: https://www.w3.org/TR/css-ui-4/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 10 October 2018. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/
[CSSOM-VIEW-1]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/
[WORKLETS-1]
    Ian Kilpatrick. Worklets Level 1. 7 June 2016. WD. URL: https://www.w3.org/TR/worklets-1/


●●trans_metadata
<p>
~THIS_PAGEは、 W3C により
編集者草案として公開された
<a href="~SPEC_URL">CSS Painting API Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新 発行バージョン
	http://www.w3.org/TR/css-paint-api-1/
以前のバージョン
	https://www.w3.org/TR/2018/WD-css-paint-api-1-20180410/
	https://www.w3.org/TR/2016/WD-css-paint-api-1-20160607/

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bcss-paint-api%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[css-paint-api] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)

編集
	<a href="mailto:ikilpatrick@chromium.org">Ian Kilpatrick</a>
	<a href="mailto:dino@apple.com">Dean Jackson</a>
前任編集者
	<a href="mailto:shanestephens@google.com">Shane Stephens</a>
最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/labels/css-paint-api-1">GitHub Issues</a>

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master/css-paint-api

</script>


</head><body>

<header>

	<hgroup>
<h1 id="title">CSS Painting API Level 1</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~JSにより，~custom~CSS `image$t を定義する~APIを述べる。
それは、~style, ~sizeの各~変化に応答することを，~web開発者に許容する。
<a href="https://github.com/w3c/css-houdini-drafts/blob/master/css-paint-api/EXPLAINER.md">説明書</a>
を見よ。
◎
An API for allowing web developers to define a custom CSS &lt;image&gt; with javascript, which will respond to style and size changes. See EXPLAINER.
</p>

	</section>
	<section id="status">
~STATUSofTHIS

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの塗り段階は、~boxの［
（~layout段階で生成される）~size【言い換えれば，~sizeの使用~値】,
算出d~style【各種~propの算出d値】
］に基づく，~boxの［
背景, 内容, 強調
］の塗ngを担当する。
◎
The paint stage of CSS is responsible for painting the background, content and highlight of a box based on that box’s size (as generated by the layout stage) and computed style.
</p>

<p>
この仕様は、［
追加的な `image$t 関数で［
~size／算出d~style
］の各~変化に呼応して，~boxの一部を塗る
］ことを開発者に許容する~APIを述べる。
◎
This specification describes an API which allows developers to paint a part of a box in response to size / computed style changes with an additional &lt;image&gt; function.
</p>

<p class="note">注記：
この仕様の将来~versionでは、~boxのある部位に対する（例えば，背景~層に対する）［
切抜き領域, 大域~alpha, ~filter
］の定義-法の~supportも追加され得る。
◎
Note: In a future version of the spec, support could be added for defining the clip, global alpha, filter on a portion of a box (for example on the background layers).
</p>

	</section>
	<section id="paint-worklet">
<h2 title="Paint Worklet">2. 塗り~worklet</h2>

<p>
`paintWorklet$m 属性は、塗ngに関係するすべての~classを担当する `Worklet$I への~accessできるようにする。
◎
The paintWorklet attribute allows access to the Worklet responsible for all the classes which are related to painting.
</p>

<p>
`paintWorklet$m の`~worklet大域~scope型$は、
`PaintWorkletGlobalScope$I である。
◎
The paintWorklet's worklet global scope type is PaintWorkletGlobalScope.
</p>

<pre class="idl">
partial namespace `CSS$I {
    [`SameObject$] readonly attribute `Worklet$I `paintWorklet@m;
};
</pre>

<p>
`PaintWorkletGlobalScope$I は `paintWorklet$m の大域~実行~文脈である。
◎
A PaintWorkletGlobalScope is a global execution context of the paintWorklet.
</p>

<p>
各 `PaintWorkletGlobalScope$I は `devicePixelRatio$m ~propを持つ
— それは
`Window^I 上の
<a href="~CSSOMVIEW#dom-window-devicepixelratio">`devicePixelRatio^m</a>
~propに一致する。
◎
A PaintWorkletGlobalScope has a devicePixelRatio property which is identical to the Window.devicePixelRatio property.
</p>

<pre class="idl">
[`Global$=(Worklet,PaintWorklet),`Exposed$=PaintWorklet]
interface `PaintWorkletGlobalScope@I : `WorkletGlobalScope$I {
    void `registerPaint$m(`DOMString$ %name, `VoidFunction$ %paintCtor);
    readonly attribute `unrestricted double$ `devicePixelRatio@m;
};
</pre>

<p>
`PaintRenderingContext2DSettings$I は、塗り~canvasに結付けられる描画~文脈~用の設定群を包含する。
`PaintRenderingContext2DSettings$I は、~canvas描画~文脈の~2D設定群
【 `CanvasRenderingContext2DSettings$I 】
が~supportするものの下位集合を供する。
将来には、塗り~canvasにおける色~管理も~supportするよう，拡張され得る。
◎
The PaintRenderingContext2DSettings contains the settings for the rendering context associated with the paint canvas. The PaintRenderingContext2DSettings provides a supported subset of canvas rendering context 2D settings. In the future, it may be extended to support color management in paint canvas.
</p>

<pre class="idl">
dictionary `PaintRenderingContext2DSettings@I {
    `boolean$ `alpha@m = true;
};
</pre>

<div class="note">

<p>注記：
当の~classは、次のような~~形をとるベキである：
◎
Note: The shape of the class should be:
</p>
<pre class="lang-javascript">
class MyPaint {
    static get inputProperties() { return ['--foo']; }
    static get inputArguments() { return ['&lt;color&gt;']; }
    static get contextOptions() { return {alpha: true}; }

    paint(%ctx, %size, %styleMap) {
        /* <span class="comment">
塗り~codeはここに。
◎
Paint code goes here.
</span> */
    }
}
</pre>

</div>

	</section>
	<section id="concepts">
<h2 title="Concepts">3. 各種~概念</h2>

<p>
`塗り定義@
は、［
`PaintWorkletGlobalScope$I に必要になる，作者が定義する `image$t についての情報
］を述べる`構造体$であり（ `paint$f 関数により参照され得る），次に挙げるものからなる：
◎
A paint definition is a struct which describes the information needed by the PaintWorkletGlobalScope about the author defined &lt;image&gt; (which can be referenced by the &lt;paint()&gt; function). It consists of:
</p>

<div>

<dl class="def-list">
	<dt>`~class構築子@pD</dt>
	<dd>
~JS `~class構築子$。
</dd>

	<dt>`塗り関数@pD</dt>
	<dd>
`~callback関数$ 型の `Function$I 。
【原文の参照先 <a href="https://drafts.csswg.org/css-syntax-3/#function">Function</a> （~CSS関数~記法）は誤りであろう。】
</dd>

	<dt>`構築子~妥当~flag@pD</dt>
	<dd>
~T または ~F
</dd>

	<dt>`入力~prop~list@pD</dt>
	<dd>
0 個以上の文字列からなる`~list$（ ~SeqDS 型の値）。
</dd>

	<dt>`塗り~2D描画~文脈~設定群@pD</dt>
	<dd>
`PaintRenderingContext2DSettings$I ~obj。
</dd>
</dl>

◎
class constructor which is the class constructor.
◎
paint function which is the paint Function callback function type.
◎
constructor valid flag.
◎
input properties which is a list of DOMStrings.
◎
A PaintRenderingContext2DSettings object.
</div>

<p>
`文書~塗り定義@
は、［
`文書$に必要になる，作者が定義する `image$t についての情報
］を述べる`構造体$であり（ `paint$f 関数により参照され得る），次に挙げるものからなる：
◎
A document paint definition is a struct which describes the information needed by the document about the author defined &lt;image&gt; function (which can be referenced by the paint function). It consists of:
</p>

<div>

<dl class="def-list">
	<dt>`入力~prop~list@dPD</dt>
	<dd>
0 個以上の文字列からなる`~list$（ ~SeqDS 型の値）。
</dd>

	<dt>`入力~引数~構文@dPD</dt>
	<dd>
`~supportされる構文~文字列$を構文解析した結果の`~list$。
</dd>

	<dt>`塗り~2D描画~文脈~設定群@dPD</dt>
	<dd>
`PaintRenderingContext2DSettings$I ~obj。
</dd>
</dl>

◎
A input properties which is a list of DOMStrings.
◎
A input argument syntaxes which is a list of parsed CSS Properties and Values API 1 §2.3 Supported syntax strings.
◎
A PaintRenderingContext2DSettings object.
</div>

	</section>
	<section id="registering-custom-paint">
<h2 title="Registering Custom Paint">4. ~customな塗りの登録-法</h2>

<p>
各 `文書$は、
`文書~塗り定義~map@
を持つ。
それは、`有順序~map$であり，初期~時には空とする。
この~mapは、 `registerPaint()$m が~callされたときに拡充される。
◎
The document has a map of document paint definitions. Initially this map is empty; it is populated when registerPaint(name, paintCtor) is called.
</p>

<p>
各 `PaintWorkletGlobalScope$I ~objは、次に挙げるものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`塗り定義~map@</dt>
	<dd>
`有順序~map$であり，初期~時には空とする。
この~mapは、 `registerPaint()$m が~callされたときに拡充される。
◎
A PaintWorkletGlobalScope has a map of paint definitions. Initially this map is empty; it is populated when registerPaint(name, paintCtor) is called.
</dd>

	<dt>`塗り~class~instance~map@pD</dt>
	<dd>
`有順序~map$であり，初期~時には空とする。
この~mapは、~UAが`塗り関数の画像を描く$を呼出したときに拡充される。
◎
A PaintWorkletGlobalScope has a map of paint class instances. Initially this map is empty; it is populated when draw a paint image is invoked by the user agent.
</dd>
	<dd>
~UAは、任意の時点に，この~map内の塗り~classの~instanceを `dispose^en する
【別~threadへ移動する？】
か除去してもヨイ。
これは、［
`paint$f 関数がもはや利用されなくなった／記憶域を取戻す必要がある
］ときに行なわれ得る。
◎
Instances of paint classes in the paint class instances map may be disposed and removed from the map by the user agent at any time. This may be done when a &lt;paint()&gt; function no longer is used, or the user agent needs to reclaim memory.
</dd>
</dl>

<p class="idl-def">
`registerPaint(name, paintCtor)@m
~methodの被呼出時には、次を走らすモノトスル：
◎
When the registerPaint(name, paintCtor) method is called, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~THROW `TypeError$E
◎
If the name is an empty string, throw a TypeError and abort all these steps.
</li>
	<li>
%塗り定義~map ~LET `PaintWorkletGlobalScope$I の`塗り定義~map$
◎
Let paintDefinitionMap be PaintWorkletGlobalScope's paint definitions map.
</li>
	<li>
~IF［
%塗り定義~map[ %name ] ~NEQ ε
］
⇒
~THROW `InvalidModificationError$E
◎
If paintDefinitionMap[name] exists throw a "InvalidModificationError" DOMException and abort all these steps.
</li>
	<li>
%入力~prop~list ~LET `Get$jA( %paintCtor, `inputProperties^l ) の結果に応じて
⇒＃
`undefined^jv ならば空 ~SeqDS ／
~ELSE_ 結果を ~SeqDS 型の`~IDL値に変換-$した結果（例外投出あり）
◎
Let inputProperties be an empty sequence&lt;DOMString&gt;.
◎
Let inputPropertiesIterable be the result of Get(paintCtor, "inputProperties").
◎
If inputPropertiesIterable is not undefined, then set inputProperties to the result of converting inputPropertiesIterable to a sequence&lt;DOMString&gt;. If an exception is thrown, rethrow the exception and abort all these steps.
</li>
	<li>
<p>
%入力~prop~list から［
`~supportされる~CSS~prop$, `~custom~prop$
］以外の~itemを除去する
◎
Filter inputProperties so that it only contains supported CSS properties and custom properties.
</p>

<p class="note">注記：
入力~prop~list取得子
【 `get inputProperties()^c 】
が供する~CSS~propの~listは、~custom~prop, 略式~propも含めれることに加え、塗り画像~classを前方-互換にするため，~UAにとって現在~妥当でない~prop（例： `margin-nanjasorya-property^p ）も含めれる。
◎
Note: The list of CSS properties provided by the input properties getter can either be custom or native CSS properties.
◎
Note: The list of CSS properties may contain shorthands.
◎
Note: In order for a paint image class to be forwards compatible, the list of CSS properties can also contains currently invalid properties for the user agent. For example margin-bikeshed-property.
</p>

	</li>
	<li>
%入力~引数~list ~LET `Get$jA( %paintCtor, `inputArguments^l ) の結果に応じて
⇒＃
`undefined^jv ならば空 ~SeqDS ／
~ELSE_ 結果を ~SeqDS 型の`~IDL値に変換-$した結果（例外投出あり）
◎
Let inputArguments be an empty sequence&lt;DOMString&gt;.
◎
Let inputArgumentsIterable be the result of Get(paintCtor, "inputArguments").
◎
If inputArgumentsIterable is not undefined, then set inputArguments to the result of converting inputArgumentsIterable to a sequence&lt;DOMString&gt;. If an execption is thrown, rethrow the execption and abort all these steps.
</li>
	<li>
%入力~引数~list構文~list ~LET 新たな`~list$
<!-- ＊空にする$ -->
◎
Let inputArgumentSyntaxes be an empty list.
</li>
	<li>
<p>
%入力~引数~list 内の
~EACH( %~item )
に対し
⇒
%入力~引数~list構文~list に［
`~supportされる構文~文字列$の規則に則って %~item を構文解析した結果
］を`付加する$
⇒
~IF［
構文解析-に失敗した
］
⇒
~THROW `TypeError$E
◎
For each item in inputArguments perform the following substeps:
• Let parsedSyntax be the result of parsing item according to the rules in CSS Properties and Values API 1 §2.3 Supported syntax strings. If it fails to parse throw a TypeError and abort all these steps.
• Append parsedSyntax to inputArgumentSyntaxes.
</li>
	<li>
<p>
%塗り~2D描画~文脈~設定群 ~LET
`Get$jA( %paintCtor, `contextOptions^l ) の結果を `PaintRenderingContext2DSettings$I 型の`~IDL値に変換-$した結果（例外投出あり）
◎
Let contextOptionsValue be the result of Get(paintCtor, "contextOptions").
◎
Let paintRenderingContext2DSettings be the result of converting contextOptionsValue to a PaintRenderingContext2DSettings. If an exception is thrown, rethrow the exception and abort all these steps.
</p>

<p class="note">注記：
%塗り~2D描画~文脈~設定群 の `alpha$m を ~F に設定した場合、~textに対する “可視性” の最適化を遂行する（例：塗り画像が不透明なときには、その背後にある画像を塗らない）ことに加え，~anti-aliasすることを~UAに許容する。
◎
Note: Setting paintRenderingContext2DSettings.alpha is false allows user agents to anti-alias text in addition to performing "visibility" optimizations, e.g. not painting an image behind the paint image as the paint image is opaque.
</p>
	</li>
	<li>
~IF［
`IsConstructor$jA( %paintCtor ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If the result of IsConstructor(paintCtor) is false, throw a TypeError and abort all these steps.
</li>
	<li>
%~prototype ~LET
`Get$jA( %paintCtor, `prototype^l )
◎
Let prototype be the result of Get(paintCtor, "prototype").
</li>
	<li>
~IF［
`Type$jA( %~prototype ) ~NEQ `Object^jC
］
⇒
~THROW `TypeError$E
◎
If the result of Type(prototype) is not Object, throw a TypeError and abort all these steps.
</li>
	<li>
%塗り関数 ~LET `Get$jA( %~prototype, `paint^l ) の結果を`~callback関数$ 型の`~IDL値に変換-$した結果（例外投出あり）
<!-- ＊Function -->
◎
Let paintValue be the result of Get(prototype, "paint").
◎
Let paint be the result of converting paintValue to the Function callback function type. Rethrow any exceptions from the conversion.
</li>
	<li>
%定義 ~LET 次のようにされた新たな`塗り定義$
⇒＃
`~class構築子$pD ~SET %paintCtor,
`塗り関数$pD ~SET %塗り関数,
`構築子~妥当~flag$pD ~SET ~T,
`入力~prop~list$pD ~SET %入力~prop~list,
`塗り~2D描画~文脈~設定群$pD ~SET %塗り~2D描画~文脈~設定群
◎
Let definition be a new paint definition with:
• class constructor being paintCtor.
• paint function being paint.
• constructor valid flag being true.
• input properties being inputProperties.
• PaintRenderingContext2DSettings object being paintRenderingContext2DSettings.
</li>
	<li>
%塗り定義~map[ %name ] ~SET %定義
◎
Set paintDefinitionMap[name] to definition.
</li>
	<li>
<p>
次を走らす`~taskを~queueする$
◎
Queue a task to run the following steps:
</p>
		<ol>
			<li>
%文書~塗り定義~map ~LET 結付けられている`文書$【此れの`所有者~文書$】の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document’s document paint definitions map.
</li>
			<li>
%文書~塗り定義 ~LET 次のようにされた新たな`文書~塗り定義$
⇒＃
`入力~prop~list$dPD ~SET %入力~prop~list,
`入力~引数~構文$dPD ~SET %入力~引数~list構文~list,
`塗り~2D描画~文脈~設定群$dPD ~SET %塗り~2D描画~文脈~設定群
◎
Let documentDefinition be a new document paint definition with:
• input properties being inputProperties.
• input argument syntaxes being inputArgumentSyntaxes.
• PaintRenderingContext2DSettings object being paintRenderingContext2DSettings.
</li>
			<li>
<p>
~IF［
%文書~塗り定義~map[ %name ] ~NEQ ε
］：
◎
If documentPaintDefinitionMap[name] exists, run the following steps:
</p>
				<ol>
					<li>
%既存の文書~塗り定義 ~LET %文書~塗り定義~map[ %name ]
◎
Let existingDocumentDefinition be the result of get documentPaintDefinitionMap[name].
</li>
					<li>
<p>
~IF［
%既存の文書~塗り定義 ~NEQ `invalid^l
］~AND［
［
%既存の文書~塗り定義, %文書~塗り定義
］は等価でない（すなわち，
`入力~prop~list$dPD,
`入力~引数~構文$dPD,
`塗り~2D描画~文脈~設定群$dPD
【のいずれか】が異なる)
］：
◎
If existingDocumentDefinition is "invalid", abort all these steps.
◎
If existingDocumentDefinition and documentDefinition are not equivalent, (that is input properties, input argument syntaxes, and PaintRenderingContext2DSettings object are different), then:
</p>
						<ol>
							<li>
%文書~塗り定義~map[ %name ] ~SET `invalid^l
◎
Set documentPaintDefinitionMap[name] to "invalid".
</li>
							<li>
同じ~classが等価でない`文書~塗り定義$で登録されようとしたことを言明する~errorを，~debug用~consoleに~logする
◎
Log an error to the debugging console stating that the same class was registered with different inputProperties, inputArguments, or paintRenderingContext2DSettings.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%文書~塗り定義~map[ %name ] ~SET %文書~塗り定義
◎
Otherwise, set documentPaintDefinitionMap[name] to documentDefinition.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
入力~prop~listは、一度だけ検索されるベキである
— 当の~classが、その入力~prop~listを動的に変更する機会を得ないよう。
◎
Note: The list of input properties should only be looked up once, the class doesn’t have the opportunity to dynamically change its input properties.
</p>

<p class="note">注記：
この仕様の将来~versionにおいては、作者は，異なる型の描画~文脈（ `RenderingContext^en ）を受取る能を持てるようにされ得る。
特に、~3D効果の描画-用として~WebGL描画~文脈が求められるであろう。
`PaintSize$I, `StylePropertyMap$I を入力にとるため、~WebGL描画~文脈を設定しておくときに複階性がある。
◎
Note: In a future version of the spec, the author could have the ability to receive a different type of RenderingContext. In particular the author may want a WebGL rendering context to render 3D effects. There are complexities in setting up a WebGL rendering context to take the PaintSize and StylePropertyMap as inputs.
</p>

	</section>
	<section id="paint-notation">
<h2 title="Paint Notation">5. 塗り記法</h2>

<pre class="prod">
`paint@f = paint( `ident$t, `declaration-value$t? )

</pre>

<p>
`paint$f 関数は、 `image$t 型が~supportする追加的な記法である。
◎
The &lt;paint()&gt; function is an additional notation to be supported by the &lt;image&gt; type.
</p>

<div class="example">

<pre class="lang-markup">
&lt;style&gt;
    .logo { background-image: paint(company-logo); }
    .chat-bubble { background-image: paint(chat-bubble, blue); }
&lt;/style&gt;
</pre>

</div>

<p>
`cursor$p ~propに対しては、 `paint$f 関数は`無効な画像$として扱った上で，その次に~supportされる `image$t に~fallbackするベキである。
◎
For the cursor property, the &lt;paint()&gt; function should be treated as an invalid image and fallback to the next supported &lt;image&gt;.
</p>

<p>
`paint$f 関数は、`算出d値$の時点では， `registerPaint()$m により登録された文法と照合する`必要はない^em。
合致しない場合、代わりに，`塗り関数の画像を描く$の内側で構文解析が生じるときに`無効な画像$になる。
◎
At computed value time the &lt;paint()&gt; function does not need to match the grammar registered by registerPaint(). Instead this will result in an invalid image when the parsing occurs inside draw a paint image.
</p>

	</section>
	<section id="2d-rendering-context">
<h2 title="The 2D rendering context">6. ~2D描画~文脈</h2>

<pre class="idl">
[`Exposed$=PaintWorklet]
interface `PaintRenderingContext2D@I {
};
`PaintRenderingContext2D$I includes `CanvasState$I;
`PaintRenderingContext2D$I includes `CanvasTransform$I;
`PaintRenderingContext2D$I includes `CanvasCompositing$I;
`PaintRenderingContext2D$I includes `CanvasImageSmoothing$I;
`PaintRenderingContext2D$I includes `CanvasFillStrokeStyles$I;
`PaintRenderingContext2D$I includes `CanvasShadowStyles$I;
`PaintRenderingContext2D$I includes `CanvasRect$I;
`PaintRenderingContext2D$I includes `CanvasDrawPath$I;
`PaintRenderingContext2D$I includes `CanvasDrawImage$I;
`PaintRenderingContext2D$I includes `CanvasPathDrawingStyles$I;
`PaintRenderingContext2D$I includes `CanvasPath$I;
</pre>

<p class="note">注記：
`PaintRenderingContext2D$I は、 `CanvasRenderingContext2D$I ~APIの下位集合を実装する。
特定的には，次に挙げる~APIは実装しない
⇒＃
`CanvasImageData$I,
`CanvasUserInterface$I,
`CanvasText$I,
`CanvasTextDrawingStyles$I
◎
Note: The PaintRenderingContext2D implements a subset of the CanvasRenderingContext2D API. Specifically it doesn’t implement the CanvasImageData, CanvasUserInterface, CanvasText, or CanvasTextDrawingStyles APIs.
</p>

<p>
各 `PaintRenderingContext2D$I ~objは、次のものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`出力~bitmap@</dt>
	<dd>
~objの作成-時に初期化される。
`出力~bitmap$の~sizeは、その描画-先~objの`具体~obj~size$になる。
◎
A PaintRenderingContext2D object has a output bitmap. This is initialised when the object is created. The size of the output bitmap is the concrete object size of the object it is rendering to.
</dd>

	<dt>`~alpha~flag@</dt>
	<dd>
~T, ~F いずれかをとり、~objの作成-時には ~T に設定されるモノトスル。
この~flagが ~F に設定された場合、~objの~alpha~channelはすべての画素に対し 1.0 （全部的に不透明）に固定し、ある画素の~alpha成分を変更しようと試みられたときは，黙って無視するモノトスル。
◎
A PaintRenderingContext2D object also has an alpha flag, which can be set to true or false. Initially, when the context is created, its alpha flag must be set to true. When a PaintRenderingContext2D object has its alpha flag set to false, then its alpha channel must be fixed to 1.0 (fully opaque) for all pixels, and attempts to change the alpha component of any pixel must be silently ignored.
</dd>
</dl>

<p>
`出力~bitmap$の~sizeは、~UAが［
内部的／描画の間
］に利用することになる実際の~bitmapの~sizeを表現するとは限らない。
例えば，可視域が~zoomされた場合、~UAは，結果の描画が高品質になるよう座標~空間~内の機器~画素~数に対応する~bitmapを内部的に利用してもヨイ。
◎
The size of the output bitmap does not necessarily represent the size of the actual bitmap that the user agent will use internally or during rendering. For example, if the visual viewport is zoomed the user agent may internally use bitmaps which correspond to the number of device pixels in the coordinate space, so that the resulting rendering is of high quality.
</p>

<p>
加えて，~UAは、`出力~bitmap$に適用された一連の描法~演算を，後続して機器~bitmap上に正しい解像度で描けるよう記録してもヨイ。
これはまた
— 例えば可視域が~zoomされている間に —
`出力~bitmap$の同じ出力を繰り返し再利用できるようにもする。
◎
Additionally the user agent may record the sequence of drawing operations which have been applied to the output bitmap such that the user agent can subsequently draw onto a device bitmap at the correct resolution. This also allows user agents to re-use the same output of the output bitmap repeatably while the visual viewport is being zoomed for example.
</p>

<p>
`PaintRenderingContext2D$I ~APIにて，色として `currentColor^l が利用されたときは、`不透明な黒$として扱われる。
◎
Whenever "currentColor" is used as a color in the PaintRenderingContext2D API, it is treated as opaque black.
</p>

<div class="example">

<p>
次の~codeは、黒ベタの矩形を生産することになる。
◎
The code below will produce a solid black rectange.
</p>

<pre class="lang-javascript">
registerPaint('currentcolor', class {
    paint(%ctx, %size) {
        %ctx.fillStyle = 'currentColor';
        %ctx.fillRect(0, 0, %size.width, %size.height);
    }
});
</pre>

</div>

<div class="algorithm">

<p>
`塗り~2D描画~文脈を作成する@
ときは、所与の
( %~size, %塗り~2D描画~文脈~設定群 )
に対し，次の手続きを走らすモノトスル：
◎
When the user agent is to create a PaintRenderingContext2D object for a given width, height, and paintRenderingContext2DSettings, it must run the following steps:
</p>

<ol>
	<li>
%文脈 ~LET 新たな `PaintRenderingContext2D$I
◎
Create a new PaintRenderingContext2D.
</li>
	<li>
%文脈 の`出力~bitmap$用の`~bitmap寸法を設定する$( %~size の横幅, 縦幅を丸めた結果 )
◎
Set bitmap dimensions for the context’s output bitmap to the rounded values of width and height.
</li>
	<li>
`PaintRenderingContext2D$I の`~alpha~flag$ ~SET %塗り~2D描画~文脈~設定群 の `alpha$m
◎
Set the PaintRenderingContext2D's alpha flag to paintRenderingContext2DSettings’s alpha.
</li>
	<li>
~RET %文脈
◎
Return the new PaintRenderingContext2D.
</li>
</ol>

<p class="note">注記：
描画~文脈の初期~状態は、`~bitmap寸法を設定する$ ~algoの内側で設定され、それに伴い
描画~文脈を`既定の状態に設定し直す$ことに加え，`出力~bitmap$を【`透明な黒$に】~clearする。
◎
Note: The initial state of the rendering context is set inside the set bitmap dimensions algorithm, as it invokes reset the rendering context to its default state and clears the output bitmap.
</p>

</div>

		<section id="drawing-a-cssimagevalue">
<h3 title="Drawing a CSSImageValue">6.1. `CSSImageValue^I の描法</h3>

<p>
`CanvasImageSource$I ~typedefは、画像~sourceとして利用される `CSSImageValue$I 型も含むよう拡張される。
◎
The CanvasImageSource typedef is extended to also include the CSSImageValue type to be used as an image source.
</p>

<p>
`CanvasDrawImage$I ~mixinを利用する~interface用には：
◎
For interfaces which use the CanvasDrawImage mixin:
</p>

<ul>
	<li>
`CanvasImageSource$I ~objが，ある `CSSImageValue$I を表現するときは、
— `drawImage()$m の目的においては —
~source画像として，値の下層の画像~algoを呼出した結果を利用するモノトスル。
◎
When a CanvasImageSource object represents an CSSImageValue, the result of invoking the value’s underlying image algorithm must be used as the source image for the purposes of drawImage.
</li>
</ul>

<p class="note">注記：
これは、最終的には~HTML仕様の~canvas節へ移動されるベキである。
◎
Note: This should eventually be moved to the canvas section of the HTML specification.
</p>

		</section>
	</section>
	<section id="drawing-an-image">
<h2 title="Drawing an image">7. 画像の描法</h2>

<p>
`~box$用の `paint$f 関数~画像【の描画-先】が可視域の中にある場合、~UAは，`塗り関数の画像を描く$を呼出した結果の画像~出力を表示するモノトスル。
◎
If a &lt;paint()&gt; function image for a box is within the visual viewport, the user agent must display an image output from an invocation of the draw a paint image algorithm.
</p>

<p class="note">注記：
~UAは、可視域の中で `paint$f 関数~用に各~frameごとに`塗り関数の画像を描く$を走らす必要はない。
~cacheした結果で，正しい画像~出力を表示できる（必要なら追加的な無効化~手続きも利用して）。
◎
Note: The user agent doesn’t have to run draw a paint image each frame for a &lt;paint()&gt; function within the visual viewport. It can cache results, (potentially using additional invalidation steps) to display the correct image output.
</p>

<p class="note">注記：
~UAは、可視域の外側にある画像に対しては，任意選択で描くのを先送りできる。
◎
Note: The user agent can optionally defer drawing images which are outside the visual viewport.
</p>

<div class="example">

<p>
作者が `requestAnimationFrame()^m の内側で~styleを更新した場合の例：
◎
If an author updates a style inside a requestAnimationFrame, e.g.
</p>

<pre class="lang-javascript">
requestAnimationFrame(function() {
    %element.styleMap.set('--custom-prop-invalidates-paint', 42);
});
</pre>

<p>
%element が可視域の内側にある場合、~UAには次が要求される
⇒＃
`塗り関数の画像を描く$,
現在の~frame用の結果を表示する
◎
And the element is inside the visual viewport, the user agent is required to draw a paint image and display the result for the current frame.
</p>

</div>

<p>
`塗り関数の画像を描く$は、`~obj~size折衝~algo$の間に~UAにより呼出される。
それは、通例的には`~box$の`具体~obj~size$と同じ~sizeとして定義される，
`その時点の具体~obj~size@
による `image$t の描画を担当する。
しかしながら，~UAは、画素~境界を塗るようこの~sizeを調整してもヨイ。
そうする場合、元の~sizeの縦横比を保つように，`その時点の具体~obj~size$を調整するベキである
— それに則って `paint$f 関数が描法を調整できるよう。
◎
The draw a paint image function is invoked by the user agent during the object size negotiation algorithm which is responsible for rendering an &lt;image&gt;, with snappedConcreteObjectSize defined as follows. Let concreteObjectSize be the concrete object size of the box. The snappedConcreteObjectSize is usually the same as the concreteObjectSize. However, the user agent may adjust the size such that it paints to pixel boundaries. If it does, the user agent should adjust the snappedConcreteObjectSize by the proportional change from its original size such that the &lt;paint()&gt; function can adjust the drawing accordingly.
</p>

<p>
`~obj~size折衝~algo$の目的においては、塗り画像には`内在的~寸法$は無い。
◎
For the purposes of the object size negotiation algorithm, the paint image has no intrinsic dimensions.
</p>

<p class="note">注記：
この仕様の将来~versionでは、作者には，塗り画像の`内在的~寸法$を指定する能も与えられ得る。
これはおそらく，作者に次を許容するような~callbackとして公開されることになる
⇒
静的な`内在的~寸法$を定義する／
算出d~style, ~sizeの各~変化に基づいて`内在的~寸法$を動的に更新する
◎
Note: In a future version of the spec, the author could have the ability to specify the intrinsic dimensions of the paint image. This will probably be exposed as a callback allowing the author to define static intrinsic dimensions or dynamically updating the intrinsic dimensions based on computed style and size changes.
</p>

<p>
`PaintSize$I ~objは、作者が描くベキ画像の~sizeを表現する。
これは、~UAが与える`その時点の具体~obj~size$を表す。
◎
The PaintSize object represents the size of the image that the author should draw. This is the snappedConcreteObjectSize given by the user agent.
</p>

<p class="note">注記：
`具体~obj~size$がどう計算されるかの例は、
<a href="~CSSIMAGE#object-sizing-examples">~CSS~obj~sizingの例</a>
を見よ。
◎
Note: See CSS Images 3 §5.4 Examples of CSS Object Sizing for examples on how the concrete object size is calculated.
</p>

<p>
~UAは、`塗り関数の画像を描く$を任意の時点に任意の`その時点の具体~obj~size$で投機的に呼出せる。
結果の画像は表示されない。
◎
The draw a paint image function may be speculatively invoked by the user agent at any point, with any snappedConcreteObjectSize. The resulting image is not displayed.
</p>

<p class="note">注記：
~UAは、経験則を利用して，未来の`その時点の具体~obj~size$用にアリな値を投機してもヨイ
— 例えば，~sizeは不変であり続けることを投機するなど。
◎
Note: User agents may use any heuristic to speculate a possible future value for snappedConcreteObjectSize, for example speculating that the size remains unchanged.
</p>

<p class="note">注記：
画像は、表示されなくとも~cacheしてヨイ
— 後続の `paint$f の呼出nは~cacheした画像を利用してヨイ。
◎
Note: Although the image is not displayed, it may still be cached, and subsequent invocations of &lt;paint()&gt; may use the cached image.
</p>

<pre class="idl">
[`Exposed$=PaintWorklet]
interface `PaintSize@I {
    readonly attribute `double$ `width@m;
    readonly attribute `double$ `height@m;
};
</pre>

<div class="algorithm">

<p>
~UAは，
`塗り関数の画像を描く@
ときは、所与の
( %~box, `その時点の具体~obj~size$ %具体~obj~size )
に対し，次の手続きを走らせて生産される画像~出力を［
%~box 用に適切な積層~level（ %~box の~CSS~propにより定義される）の中へ描く
］モノトスル：
◎
When the user agent wants to draw a paint image of a &lt;paint()&gt; function for a box into its appropriate stacking level (as defined by the property the CSS property its associated with), given snappedConcreteObjectSize it must run the following steps:
</p>

<ol>
	<li>
%塗り関数 ~LET %~box 上の `paint$f 関数
◎
Let paintFunction be the &lt;paint()&gt; function on the box which the user agent wants to draw.
</li>
	<li>
%名前 ~LET %塗り関数 の最初の引数
◎
Let name be the first argument of the paintFunction.
</li>
	<li>
%文書~塗り定義~map ~LET 結付けられている`文書$【 %~box が生成される文書】の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document’s document paint definitions map.
</li>
	<li>
~IF［
%文書~塗り定義~map[ %名前 ] ~EQ ε
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If documentPaintDefinitionMap[name] does not exist, let the image output be an invalid image and abort all these steps.
</li>
	<li>
%文書~塗り定義 ~LET %文書~塗り定義~map[ %名前 ]
◎
Let documentDefinition be the result of get documentPaintDefinitionMap[name].
</li>
	<li>
~IF［
%文書~塗り定義 ~EQ `invalid^l
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If documentDefinition is "invalid", let the image output be an invalid image and abort all these steps.
</li>
	<li>
%入力~引数~list構文~list ~LET %文書~塗り定義 の`入力~引数~構文$dPD
◎
Let inputArgumentSyntaxes be documentDefinition’s input argument syntaxes.
</li>
	<li>
%入力~引数~list ~LET %塗り関数 の `declaration-value$t 引数を成す成分たちからなる`~list$
◎
Let inputArguments be the list of all the paintFunction arguments after the "paint name" argument.
</li>
	<li>
<p>
~IF［
%入力~引数~list は %入力~引数~list構文~list に与えられた登録-済み文法に合致しない
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If inputArguments do not match the registered grammar given by inputArgumentSyntaxes, let the image output be an invalid image and abort all these steps.
</p>

<div class="example">

<p>
この段は、次の事例では失敗し得る：
◎
This step may fail in the following cases:
</p>

<pre class="lang-javascript">
// paint.js
registerPaint('failing-argument-syntax', class {
    static get inputArguments() { return ['&lt;length&gt;']; }
    paint(%ctx, %size, %styleMap, %args) { /* paint code here. */ }
});
</pre>

<pre class="lang-markup">
&lt;style&gt;
    .example-1 {
        background-image: paint(failing-argument-syntax, red);
    }
    .example-2 {
        background-image: paint(failing-argument-syntax, 1px, 2px);
    }
&lt;/style&gt;
&lt;div class=example-1&gt;&lt;/div&gt;
&lt;div class=example-2&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.paintWorklet.addModule('paint.js');
&lt;/script&gt;
</pre>

<p>
`example-1^c は`無効な画像$を生産する
— `red^l は登録-済み文法に合致しないので。
◎
example-1 produces an invalid image as "red" does not match the registered grammar.
</p>

<p>
`example-2^c は`無効な画像$を生産する
— 関数の引数が多過ぎるので。
◎
example-2 produces an invalid image as there are too many function arguments.
</p>
</div>
	</li>
	<li>
<p>
%~worklet大域~scope ~LET 
<a href="#global-scope-selection">§ 大域~scopeの選定</a>に定義される規則に従って，
塗り `Worklet$I の`~worklet大域~scope~list$から選んだ `PaintWorkletGlobalScope$I ~obj
◎
Let workletGlobalScope be a PaintWorkletGlobalScope from the list of worklet’s WorkletGlobalScopes from the paint Worklet, following the rules defined in §7.1 Global Scope Selection.
</p>

<p>
~UAは、この時点で次を行っても`ヨイ^em
⇒
塗り `Worklet$I を与える下で，`~worklet大域~scopeを作成する$
◎
The user agent may also create a WorkletGlobalScope at this time, given the paint Worklet.
</p>
	</li>
	<li>
<p>
この段は、任意選択で`並列的$に, または同期的に走らす
⇒
`塗り~callbackを呼出す$( %名前, %入力~引数~list, %具体~obj~size, %~worklet大域~scope )
◎
Run invoke a paint callback given name, inputArguments, snappedConcreteObjectSize, workletGlobalScope optionally in parallel.
</p>

<p class="note">注記：
`並列的$な~thread内で`塗り~callbackを呼出す$場合、~UAは，その~thread上で利用できる塗り~worklet大域~scopeを選定するベキである。
◎
Note: If the user agent runs invoke a paint callback on a thread in parallel, it should select a paint worklet global scope which can be used on that thread.
</p>
	</li>
</ol>

</div>

<div class="algorithm">

<p>
`塗り~callbackを呼出す@
ときは、所与の
( %名前, %入力~引数~list, %具体~obj~size, %~worklet大域~scope )
に対し，次の手続きを走らすモノトスル：
◎
When the user agent wants to invoke a paint callback given name, inputArguments, snappedConcreteObjectSize, and workletGlobalScope, it must run the following steps:
</p>

<ol>
	<li>
%塗り定義~map ~LET %~worklet大域~scope の`塗り定義~map$
◎
Let paintDefinitionMap be workletGlobalScope’s paint definitions map.
</li>
	<li>
%定義 ~LET %塗り定義~map[ %名前 ]
<!-- Get -->
◎
↓</li>
	<li>
<p>
~IF［
%定義 ~EQ ε
］：
◎
If paintDefinitionMap[name] does not exist, run the following steps:
</p>
		<ol>
			<li>
<p>
次を走らす`~taskを~queueする$：
◎
Queue a task to run the following steps:
</p>
				<ol>
					<li>
%文書~塗り定義~map ~LET 結付けられている`文書$
【%~worklet大域~scope の`所有者~文書$】
の`文書~塗り定義~map$
◎
Let documentPaintDefinitionMap be the associated document's document paint definitions map.
</li>
					<li>
%文書~塗り定義~map[ %名前 ] ~SET `invalid^l
◎
Set documentPaintDefinitionMap[name] to "invalid".
</li>
					<li>
~UAは、~debug用~consoleに次を~logする`ベキ^emである
⇒
どの `PaintWorkletGlobalScope$I にも~classは登録されていないことを言明する~error
◎
The user agent should log an error to the debugging console stating that a class wasn’t registered in all PaintWorkletGlobalScopes.
</li>
				</ol>
			</li>
			<li>
画像~出力は`無効な画像$
◎
Let the image output be an invalid image and＼
</li>
			<li>
~RET
◎
abort all these steps.
</li>
		</ol>

<p class="note">注記：
塗り~worklet大域~scopeには、
%名前 用の `registerPaint()$m を受取らなかったものもある（しかしながら，受取った大域~scopeもある）かもしれない
— これは、そのような事例を取扱う。
他の大域~scope上で呼出された塗り~callbackは成功したとしても、後続の~frameでは，`塗り関数の画像を描く$が~callされても成功しないことになる。
◎
Note: This handles the case where there could be a paint worklet global scope which didn’t receive the registerPaint(name, paintCtor) for name (however another global scope did). A paint callback which is invoked on the other global scope could succeed, but wont succeed on a subsequent frame when draw a paint image is called.
</p>
	</li>
	<li>
%塗り~class~instance~map ~LET %~worklet大域~scope の`塗り~class~instance~map$pD
◎
↑Let definition be the result of get paintDefinitionMap[name].
◎
Let paintClassInstanceMap be workletGlobalScope’s paint class instances map.
</li>
	<li>
%塗り~instance ~LET %塗り~class~instance~map[ %名前 ]
◎
Let paintInstance be the result of get paintClassInstanceMap[|name]|.＼
</li>
	<li>
<p>
~IF［
%塗り~instance ~EQ ε
］：
◎
If paintInstance is null, run the following steps:
</p>
		<ol>
			<li>
~IF［
%定義 の`構築子~妥当~flag$pD ~EQ ~F
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
If the constructor valid flag on definition is false, let the image output be an invalid image and abort all these steps.
</li>
			<li>
%塗り構築子 ~LET %定義 上の`~class構築子$pD
◎
Let paintCtor be the class constructor on definition.
</li>
			<li>
%塗り~instance ~SET `Construct$jA( %塗り構築子 )
◎
Let paintInstance be the result of Construct(paintCtor).
</li>
			<li>
~IF［
前~段にて例外が投出された
］
⇒＃
%定義 の`構築子~妥当~flag$pD ~SET ~F；
画像~出力は`無効な画像$；
~RET
◎
If construct throws an exception, set the definition’s constructor valid flag to false, let the image output be an invalid image and abort all these steps.
</li>
			<li>
%塗り~class~instance~map[ %名前 ] ~SET %塗り~instance
◎
Set paintClassInstanceMap[name] to paintInstance.
</li>
		</ol>
	</li>
	<li>
%入力~prop~list ~LET %定義 の`入力~prop~list$pD
◎
Let inputProperties be definition’s input properties.
</li>
	<li>
%~style~map ~LET 新たな `StylePropertyMapReadOnly$I
◎
Let styleMap be a new StylePropertyMapReadOnly＼
</li>
	<li>
%~style~map
の `declarations$sl 内部~slot
を［
%入力~prop~list 内に~listされた~prop用の`算出d値$
］`のみ^emで拡充する
◎
populated with only the computed value's for properties listed in inputProperties.
</li>
	<li>
<p>
%描画~文脈 ~LET `塗り~2D描画~文脈を作成する$( %具体~obj~size, %定義 の`塗り~2D描画~文脈~設定群$pD )：
◎
Let renderingContext be the result of create a PaintRenderingContext2D object given:
• "width" - The width given by concreteObjectSize.
• "height" - The height given by concreteObjectSize.
• "paintRenderingContext2DSettings" - The PaintRenderingContext2DSettings object given by definition.
</p>

<p class="note">注記：
%描画~文脈 は、塗りの各~呼出nの間で再利用されることはない。
これは、各~呼出nの間では %描画~文脈 上に格納-済みの~dataや状態は無いことを暗黙的に意味する。
例えば， %描画~文脈 上で `clip()$m により切抜き領域を設定しておいても、次回に塗り~methodが~callされるとき同じ切抜き領域が適用されることは，期待できない。
◎
Note: The renderingContext is not be re-used between invocations of paint. Implicitly this means that there is no stored data, or state on the renderingContext between invocations. For example you can’t setup a clip on the context, and expect the same clip to be applied next time the paint method is called.
</p>

<p class="note">注記：
これは、［
%描画~文脈 は実質的に塗り~methodが完了した後に “無力化される”
］ことを暗黙的に意味する。
作者~codeは %描画~文脈 への参照を保持して，それ上で~methodを呼出すこともできるが、現在の／後続の画像に対する効果は無い。
◎
Note: Implicitly this also means that renderingContext is effectively "neutered" after a paint method is complete. The author code may hold a reference to renderingContext and invoke methods on it, but this will have no effect on the current image, or subsequent images.
</p>
	</li>
	<li>
%塗り~size ~LET 次のように初期化された新たな `PaintSize$I ~obj
⇒＃
`width$m ~SET %具体~obj~size の横幅,
`height$m ~SET %具体~obj~size の縦幅
◎
Let paintSize be a new PaintSize initialized to the width and height defined by snappedConcreteObjectSize.
</li>
	<li>
<p>
~UAは、この段階で以前の呼出nからの画像を再利用してもヨイ
— ［
%塗り~size, %~style~map, %入力~引数~list
］は以前の呼出nに等価であるならば
— その場合
⇒＃
画像~出力はその~cache済み画像；
~RET
◎
At this stage the user agent may re-use an image from a previous invocation if paintSize, styleMap, inputArguments are equivalent to that previous invocation. If so let the image output be that cached image and abort all these steps.
</p>

<div class="example">

<p>
下の例では， `div-1^css, `div-2^css の両者とも等価な~JS引数~listをとる塗り関数を持つ。
~UAは、ある回の呼出nの結果を~cacheして，それを両~要素~用に利用できる。
◎
In the example below, both div-1 and div-2 have paint functions which have equivalent javascript arguments. A user-agent can cache the result of one invocation and use it for both elements.
</p>
<pre class="lang-javascript">
// paint.js
registerPaint('simple', class {
    paint(%ctx, %size) {
        %ctx.fillStyle = 'green';
        %ctx.fillRect(0, 0, %size.width, %size.height);
    }
});
</pre>

<pre class="lang-markup">
&lt;style&gt;
    .div-1 {
        width: 50px;
        height: 50px;
        background-image: paint(simple);
    }
    .div-2 {
        width: 100px;
        height: 100px;

        background-size: 50% 50%;
        background-image: paint(simple);
    }
&lt;/style&gt;
&lt;div class=div-1&gt;&lt;/div&gt;
&lt;div class=div-2&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.paintWorklet.addModule('paint.js');
&lt;/script&gt;
</pre>
</div>
	</li>
	<li>
%塗り関数~callback ~LET %定義 の`塗り関数$pD
◎
Let paintFunctionCallback be definition’s paint function.
</li>
	<li>
<p>
`~callback関数を呼出す$( %塗り関数~callback, 次に与える~list, %塗り~instance )
⇒
« %描画~文脈, %塗り~size, %~style~map, %入力~引数~list »
◎
Invoke paintFunctionCallback with arguments «renderingContext, paintSize, styleMap, inputArguments», and with paintInstance as the callback this value.
</p>
		<ul>
			<li>
<p>
~IF［
%塗り関数~callback は （~UAが決定する）受容-可能な時間内に完了しなかった（すなわち， “~scriptは長い間~走っている”）
］
⇒＃
~UAは~scriptを終了しても`ヨイ^em；
画像~出力は`無効な画像$；
~RET
◎
If paintFunctionCallback does not complete within an acceptable time (as determined by the user agent, i.e. it is a "long running script") the user agent may terminate the script, let the image output be an invalid image, and abort all these steps.
</p>

<p class="note">注記：
~UAは、自身の~debug用~toolの中で，それらの塗り~classがどう高価か作者に示す~~仕掛けを供することもできる。
この事例では，~UAは、適切になるならば，
“~scriptは応答-不能である”
様子を~dialogに示すこともできる。
◎
Note: User agents could provide tooling within their debugging tools to show authors how expensive their paint classes are. User agents could also how an "unresponsive script" dialog in this case if appropriate.
</p>
			</li>
			<li>
~IF［
%塗り関数~callback から例外が投出された
］
⇒＃
画像~出力は`無効な画像$；
~RET
◎
↓
</li>
		</ul>
	</li>
	<li>
画像~出力は前~段により %描画~文脈 から生産されたそれ
◎
The image output is to be produced from the renderingContext given to the method.
◎
If an exception is thrown the let the image output be an invalid image.
</li>
</ol>

<p class="note">注記：
結果の画像の内容は、~access可能になるものと設計されていない。
作者は、有用な情報があれば，標準の~accessibility~APIを通して通信できる。
◎
Note: The contents of the resulting image are not designed to be accessible. Authors can communicate any useful information through the standard accessibility APIs.
</p>

</div>

		<section id="global-scope-selection">
<h3 title="Global Scope Selection">7.1. 大域~scopeの選定</h3>

<p>
~UAは、`~worklet大域~scope~list$から塗り~worklet用の `PaintWorkletGlobalScope$I を選定する必要があるときは，次に従うモノトスル：
◎
When the user agent needs to select a PaintWorkletGlobalScope from the paint worklet’s WorkletGlobalScopes list it must:
</p>

<ul>
	<li>
`2 個~以上の^em  `PaintWorkletGlobalScope$I を選定する
— ~UAの記憶域が拘束されていない限り。
◎
Select from at least two PaintWorkletGlobalScopes, unless the user agent is under memory constraints.
</li>
	<li>
<p>
同じ `PaintWorkletGlobalScope$I を続けて再利用するのは、 `1000 回まで^emにすること。
◎
Not re-use the same PaintWorkletGlobalScope more than 1000 times in a row.
</p>

<p class="note">注記：
上限の 1000 回は、最も高い~~見積もりであり，時を経れば下方へ改善され得る。
◎
Note: The 1000 limit was picked as a high upper bound, this limit may improve (downwards) over time.
</p>
	</li>
</ul>

<p class="note">注記：
これらの規則は、［
状態を大域~obj上に格納できる ／
生成し直せない状態を~class上に格納できる
］ことに作者が依拠しないことを確保するために存在する。
<a href="~WORKLETS1#code-idempotency">§~codeの冪等性</a> `WORKLETS$r
を見よ。
◎
Note: These rules exist to ensure that authors do not rely on being able to store state on the global object or non-regeneratable state on the class. See Worklets 1 §1.2 Code Idempotency.
</p>

		</section>
	</section>
	<section id="examples">
<h2 title="Examples">8. 例</h2>

		<section>
<h3 title="Example 1: Colored Circle">8.1. 色~付きの真円</h3>

<p>
下の例は、 `paint$f 関数は~animate可能である事実を用立てる。
例えば `textarea^e が~focusされたとき、
`--circle-color^p ~propは， `deepskyblue^v から `purple^v へ遷移することになる。
◎
The example below makes use of the fact that &lt;paint()&gt; functions are able to be animated. E.g. when the textarea is focused in the example below, the --circle-color property will transition from deepskyblue to purple.
</p>

<p>
この能は、遷移のみならず，~CSS~animationや~WebAnimations~APIにも適用される。
◎
This ability isn’t limited to just transitions, it also applies to CSS animations, and the Web Animations API.
</p>

<pre class="lang-markup">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
  #example {
    --circle-color: deepskyblue;

    background-image: paint(circle);
    font-family: sans-serif;
    font-size: 36px;
    transition: --circle-color 1s;
  }

  #example:focus {
    --circle-color: purple;
  }
&lt;/style&gt;

&lt;textarea id="example"&gt;
  CSS is awesome.
&lt;/textarea&gt;

&lt;script&gt;
    CSS.registerProperty({
      name: '--circle-color',
      syntax: '&lt;color&gt;',
      initialValue: 'black',
      inherits: false
    });
    CSS.paintWorklet.addModule('circle.js');
&lt;/script&gt;
</pre>

<pre class="lang-javascript">
// circle.js
registerPaint('circle', class {
  static get inputProperties() { return ['--circle-color']; }
  paint(%ctx, %geom, %properties) {
    /* <span class="comment">
~fill色を変更する。
◎
Change the fill color.
</span> */
    const %color = %properties.get('--circle-color');
    %ctx.fillStyle = %color.cssText;

    /* <span class="comment">
中心点と半径を決定する。
◎
Determine the center point and radius.
</span> */
    const %x = %geom.width / 2;
    const %y = %geom.height / 2;
    const %radius = Math.min(%x, %y);

    /* <span class="comment">
真円を描く
◎
Draw the circle \o/
</span> */
    %ctx.beginPath();
    %ctx.arc(%x, %y, %radius, 0, 2 * Math.PI, false);
    %ctx.fill();
  }
});
</pre>

		</section>
		<section>
<h3 title="Example 2: Image Placeholder">8.2. ~~仮の画像</h3>

<p>
作者は、画像が読込n中にある間，~~仮の画像を描く塗りを利用することもアリである。
◎
It is possible for an author to use paint to draw a placeholder image while an image is being loaded.
</p>

<pre class="lang-markup">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
#example {
    --image: url('#someUrlWhichIsLoading');
    background-image: paint(image-with-placeholder);
}
&lt;/style&gt;

&lt;div id="example"&gt;&lt;/div&gt;

&lt;script&gt;
    CSS.registerProperty({
        name: '--image',
        syntax: '&lt;image&gt; | none',
        initialValue: 'none',
    });
    CSS.paintWorklet.addModule('image-placeholder.js');
&lt;/script&gt;
</pre>

<pre class="lang-javascript">
// image-placeholder.js
registerPaint('image-with-placeholder', class {
    static get inputProperties() { return ['--image']; }
    paint(%ctx, %geom, %properties) {
        const %img = %properties.get('--image');

        switch (%img.state) {
            case 'ready':
                /* <span class="comment">
読込まれた画像を描く。
◎
The image is loaded! Draw the image.
</span> */
                %ctx.drawImage(%img, 0, 0, %geom.width, %geom.height);
                break;
            case 'pending':
                /* <span class="comment">
画像は読込n中。
何か山を描く
◎
The image is loading, draw some mountains.
</span> */
                drawMountains(%ctx);
                break;
            case 'invalid':
            default:
                /* <span class="comment">
無効な画像（例：読込まれなかった）。
残念顔を描く。
◎
The image is invalid (e.g. it didn’t load), draw a sad face.
</span> */
                drawSadFace(%ctx);
                break;
        }
    }
});
</pre>

		</section>
		<section>
<h3 title="Example 3: Arcs">8.3. 円弧</h3>

<pre class="lang-markup">
&lt;!DOCTYPE html&gt;
&lt;style&gt;
#example {
  width: 200px;
  height: 200px;

  background-image:
    paint(arc, purple, 0.4turn, 0.8turn, 40px, 15px),
    paint(arc, blue, -20deg, 170deg, 30px, 20px),
    paint(arc, red, 45deg, 220deg, 50px, 10px);
}
&lt;/style&gt;

&lt;div id="example"&gt;&lt;/div&gt;

&lt;script&gt;
    CSS.paintWorklet.addModule('arc.js');
&lt;/script&gt;
</pre>

<pre class="lang-javascript">
// arc.js
registerPaint('arc', class {
  static get inputArguments() {
    return [
      '&lt;color&gt;',
      '&lt;angle&gt;',  // 始端~角度
      '&lt;angle&gt;',  // 終端~角度
      '&lt;length&gt;', // 半径
      '&lt;length&gt;', // 線幅
    ];
  }

  paint(%ctx, %geom, _, %args) {
    %ctx.strokeStyle = %args[0].cssText;

    /* <span class="comment">
中心点を決定する。
◎
Determine the center point.
</span> */
    const %x = %geom.width / 2;
    const %y = %geom.height / 2;

    /* <span class="comment">
始端~角度, 終端~角度 を `rad^css 単位に換算する
◎
Convert the start and end angles to radians.
</span> */
    const %startAngle = this.convertAngle(%args[1]) - Math.PI / 2;
    const %endAngle = this.convertAngle(%args[2]) - Math.PI / 2;

    /* <span class="comment">
半径と線幅を `px^css 単位に換算する
◎
Convert the radius and lineWidth to px.
</span> */
    const %radius = this.convertLength(%args[3]);
    const %lineWidth = this.convertLength(%args[4]);

    %ctx.lineWidth = lineWidth;

    %ctx.beginPath();
    %ctx.arc(%x, %y, %radius, %startAngle, %endAngle, false);
    %ctx.stroke();
  }

  convertAngle(%angle) {
    switch (%angle.unit) {
      case 'deg':
        return %angle.value * Math.PI / 180;
      case 'rad':
        return %angle.value;
      case 'grad':
        return %angle.value * Math.PI / 200;
      case 'turn':
        return %angle.value * Math.PI / 0.5;
      default:
        throw Error(~BQ未知な角度~単位: ${%angle.unit}~BQ);
    }
  }

  convertLength(%length) {
    switch (%length.type) {
      case 'px':
        return %length.value;
      default:
        throw Error(~BQ未知な長さ型: ${%length.type}~BQ);
    }
  }
});
</pre>

		</section>
		<section>
<h3 title="Example 4: Different Colors (based on size)">8.4. 色を（~sizeに応じて）違える</h3>

<pre class="lang-markup">
&lt;h1&gt;
    Heading 1
&lt;/h1&gt;
&lt;h1&gt;
    Another heading
&lt;/h1&gt;

&lt;style&gt;
h1 {
    background-image: paint(heading-color);
}
&lt;/style&gt;

&lt;script&gt;
    CSS.paintWorklet.addModule('heading-color.js');
&lt;/script&gt;
</pre>

<pre class="lang-javascript">
// heading-color.js
registerPaint('heading-color', class {
    static get inputProperties() { return []; }
    paint(%ctx, %geom, %properties) {
        /* <span class="comment">
画像の~sizeに基づいて色を選定する。
◎
Select a color based on the width and height of the image.
</span> */
        const %width = %geom.width;
        const %height = %geom.height;
        const %color = colorArray[(%width * %height) % colorArray.length];

        /* <span class="comment">
ベタ画像を描く。
◎
Draw just a solid image.
</span> */
        %ctx.fillStyle = color;
        %ctx.fillRect(0, 0, %width, %height);
    }
});
</pre>

		</section>
		<section>
<h3 title="Example 5: Drawing outside an element’s area">8.5. 要素の区画の外側への描法</h3>

<p>
`border-image$p ~propを利用すれば、要素の区画の外側に描くこともアリである。
◎
It is possible to draw outside an element’s area by using the border-image property.
</p>

<pre class="lang-markup">
&lt;style&gt;
#overdraw {
    --border-width: 10;

    border-style: solid;
    border-width: calc(var(--border-width) * 1px);

    border-image-source: paint(overdraw);
    border-image-slice: 0 fill;
    border-image-outset: calc(var(--border-width) * 1px);

    width: 200px;
    height: 200px;
}
&lt;/style&gt;
&lt;div id="overdraw"&gt;&lt;/div&gt;
&lt;script&gt;
    CSS.paintWorklet.addModule('overdraw.js');
&lt;/script&gt;
</pre>

<pre class="lang-javascript">
// overdraw.js
registerPaint('overdraw', class {
    static get inputProperties() { return ['--border-width']; }
    paint(%ctx, %geom, %properties) {
        const %borderWidth = parseInt(%properties.get('--border-width'));
        %ctx.shadowColor = 'rgba(0,0,0,0.25)';
        %ctx.shadowBlur = %borderWidth;

        %ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        %ctx.fillRect(%borderWidth,
                     %borderWidth,
                     %geom.width - 2 * %borderWidth,
                     %geom.height - 2 * %borderWidth);
    }
});
</pre>

		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">9. ~securityの考慮点</h2>

<p>
これらの特能により導入される既知な~security上の課題は無い。
◎
There are no known security issues introduced by these features.
</p>

	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">10. ~privacyの考慮点</h2>

<p>
これらの特能により導入される既知な~privacy上の課題は無い。
◎
There are no known privacy issues introduced by these features.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">11. 変更点</h2>

<p>
最後の発行版からの変更点は：
◎
Changes since the last publication:
</p>

<ul>
	<li id="change-2018-paint-function-webidl">
塗り関数を，生の~JS関数に代えて~WebIDL `Function$I 型に変換するようにした。
（ `743$issue ）
◎
Adding converting the paint function to the WebIDL Function type, instead of just a raw javascript function. (Issue 743)
</li>
	<li id="change-2018-filter-input-properties"> 
`registerPaint()$m に，~supportされない~native~CSS~propを除去する段を追加した。
これらは今や、塗り関数に供される `StylePropertyMapReadOnly$I 内に現れない。
（ `523$issue ）
◎
Added a step to registerPaint() to filter out unsupported native CSS properties. These now do not appear in the StylePropertyMapReadOnly provided to the paint function. (Issue 523)
</li>
</ul>

<p>
<a href="https://drafts.css-houdini.org/css-paint-api-1/issues-list-2018-04-10">コメント集積</a>
もある。
◎
A Disposition of Comments is available.
</p>

	</section>
</main></div>
