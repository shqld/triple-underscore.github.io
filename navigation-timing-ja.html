<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Navigation Timing 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>
#_time-table {
	background: #eef7f7;
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: thin solid gray;
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 1em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;


	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case '1': // level 1
	href= `#dom-performancetiming-${key.toLowerCase()}`;
	break;
case '1n': // level 1
	href= `#dom-performancenavigation-${key.toLowerCase()}`;
	break;
case '1p': // level 1
	href= `#dom-performance-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}


</script>
<!-- 
		result = [
"Name:       " + T.name,
"Entry Type: " + T.entryType,
"Start Time: " + T.startTime,
"Duration:   " + T.duration,
"Unload:     " + (T.unloadEventEnd - T.unloadEventStart),
"Redirect:   " + (T.redirectEnd - T.redirectStart),
"App Cache:  " + (T.domainLookupStart - T.fetchStart),
"DNS:        " + (T.domainLookupEnd - T.domainLookupStart),
"TCP:        " + (T.connectEnd - T.connectStart),
"Request:    " + (T.responseStart - T.requestStart),
"Response:   " + (T.responseEnd - T.responseStart),
"Processing: " + (T.loadEventStart - T.responseEnd),
"Onload:     " + (T.loadEventEnd - T.loadEventStart)
].join('\n');
	} catch(e){
		result = 'エラー（ ' + e.name + ' ）\n' + e.message;
	}

	E('_test_output2').textContent = result;

 -->
<script>

function get_timing_data2(){
	let result;
	try {
		const entry = performance.getEntriesByType("navigation")[0].toJSON();
		const s = [];
		for(var k in entry){
			s.push(
`${(k + ' ........................').slice(0, 29)}. ${JSON.stringify(entry[k])}`
			);
		}
		result = s.join('\n');
	} catch(e){
		result = `エラー（ ${e.name} ）\n${e.message}`;
	}
	E('_test_output2').textContent = result;
}

function get_timing_data1(){ // level 1 用
	let timing = performance && performance.timing
	if(!timing) return '利用中のブラウザでは window.performance.timing はサポートされていないようです。';
	timing = timing.toJSON();
//	console.table(timing.toJSON());
	const s = [];
	const t0 = timing.navigationStart || NaN;
	for(let k in timing){
		let t = timing[k];
		s.push(
`${(k + ' ....................').slice(0, 29)}. ${'' + t} (${t - t0})`
		);
	}
	E('_test_output1').textContent = s.join('\n');
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Navigation Timing 2
spec_date:2019-12-17
trans_update:2019-07-16
source_checked:181114
page_state_key:TIMING
original_url:https://w3c.github.io/navigation-timing/
	abbr_url:NAV-TIMING
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2019,permissive
trans_1st_pub:2013-10-04


●●class_map
h:header
hm:method
e:element
a:attr
et:event-type
css:css

●●tag_map
I:code
m:code
c:code
1:code
1n:code
1p:code
h:code
hm:code
e:code
a:code
et:code
st:code
css:code
v:var
i:i

●●words_table1

	SW:https://www.w3.org/TR/service-workers/
fetch_ev: <code class="event-type">fetch</code> 

bookmarklet1:javascript:console.log(JSON.stringify(performance.timing.toJSON()).slice(1,-1).replace(/%22(\w+)%22:/g,'＠$1................................').replace(/,?＠(.{0,35})\.+/g,'\n$1 '));

bookmarklet2:javascript:console.log(JSON.stringify(performance.getEntriesByType('navigation')[0].toJSON()).slice(1,-1).replace(/%22(\w+)%22:/g,'＠$1................................').replace(/,?＠(.{0,35})\.+/g,'\n$1 '));


●●words_table


	●保安
login:::ログイン
末端利用者:end user:~:::エンドユーザ
認証:authentication::~
細工-:craft:~
信頼-:trust::~
推定-:infer:~
	供する~server:provider
未承認の:unauthorized:~
流出-:disclose:~
流出:disclosure:~
緩い:relaxed:~

	~secure化-:secured

	●fetch／network
load:
unload:
reload:
handshake::::ハンドシェイク
hop:
prompt:
IP:
持続的:persistent::~
検索:lookup::~
素片識別子:fragment:~
端点間:end-to-end::~::エンドツーエンド

辿り:traversal operation:~
事前具現化-:prerender::予め具現化::プリレンダー

閉じら:closeさ:~
開いた:openした:~
開いて:openして:~
開く:openする:~
	再び開く:reopen

	●処理能
時列線:timeline::~::タイムライン
時刻:time::~
時刻起点:time origin::~
時区間:time interval::~
時間:time::~
計測-:measure::~
計量:metric::~
	metrics
	~SET:record

測定:measure::~
終了:end:~
開始:start:~

高解像度:high resolution:~

	●仕様
義務:mandatory:~
包括的:comprehensive:~
出荷-:ship:~
	出荷-済み:shipped
様相:picture:~
素朴:naive:~
再試行:retry:~

	encoded body and decode
	recommendation

	●未分類（動詞
合格-:pass:~
拒否-:refuse:~
共有d:shared:共有
閲覧:browsing:~
手入力ng:entering:手入力

	すでに存在する:preexist
	初期~化:initializing

	●未分類
toJSON:
address-bar:address bar:::アドレスバー
directory::::ディレクトリ
memory::::メモリ
準備度:readiness::~
特性:characteristics:~
	高速に:faster

	●指示語
	~~直前:immediately before
	~~直後:immediately after
	~~等:or equivalent
	以降:since／
	任意:any
	前の:previous
	等:or equivalent
	一部:some／part of
	ない:no


	●level 1
encapsulation::::カプセル化
改善点:improvements:~

	送信し直し:resend
	強く勧める:strongly advised
	optional
	1970 年 1 月 1 日, 午前 0 時:midnight of January 1, 1970

●●original_id_map
dom-performancenavigationtiming-name:dom-PerformanceNavigationTiming-name
dom-performancenavigationtiming-entrytype:dom-PerformanceNavigationTiming-entryType
dom-performancenavigationtiming-starttime:dom-PerformanceNavigationTiming-startTime
dom-performancenavigationtiming-duration:dom-PerformanceNavigationTiming-duration
dom-performancenavigationtiming-initiatortype:dfn-initiatortype
dom-performancenavigationtiming-workerstart:dom-PerformanceNavigationTiming-workerStart

●●mdn_urls
dom-performancenavigationtiming:API/PerformanceNavigationTiming
dom-performancetiming:API/PerformanceTiming
dom-performancenavigation:API/PerformanceNavigation
	idl-def-navigationtype:API/NavigationType
dom-performance-timing:API/Performance/timing
dom-performance-navigation:API/Performance/navigation
dom-performancenavigationtiming-domcomplete:API/PerformanceNavigationTiming/domComplete
dom-performancenavigationtiming-domcontentloadedeventend:API/PerformanceNavigationTiming/domContentLoadedEventEnd
dom-performancenavigationtiming-domcontentloadedeventstart:API/PerformanceNavigationTiming/domContentLoadedEventStart
dom-performancenavigationtiming-dominteractive:API/PerformanceNavigationTiming/domInteractive
dom-performancenavigationtiming-loadeventend:API/PerformanceNavigationTiming/loadEventEnd
dom-performancenavigationtiming-loadeventstart:API/PerformanceNavigationTiming/loadEventStart
dom-performancenavigationtiming-redirectcount:API/PerformanceNavigationTiming/redirectCount
dom-performancenavigationtiming-tojson:API/PerformanceNavigationTiming/toJSON
dom-performancenavigationtiming-type:API/PerformanceNavigationTiming/type
dom-performancenavigationtiming-unloadeventend:API/PerformanceNavigationTiming/unloadEventEnd
dom-performancenavigationtiming-unloadeventstart:API/PerformanceNavigationTiming/unloadEventStart

●●link_map


	●I
Exposed:~WEBIDLjs#Exposed
Default:~WEBIDLjs#Default
SameObject:~WEBIDLjs#SameObject

I.PerformanceTiming:#dom-performancetiming
I.PerformanceNavigation:#dom-performancenavigation
I.PerformanceNavigationTiming:#dom-performancenavigationtiming
I.NavigationType:#idl-def-navigationtype

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.PerformanceEntry:~TIMELINE#dom-performanceentry
I.PerformanceResourceTiming:~RESOURCE-TIMING#dom-performanceresourcetiming
I.Window:~WINDOW#window
~window:~WINDOW#the-window-object

	I.Performance:#dom-performance

	●m
m.connectEnd:~RESOURCE-TIMING#dom-performanceresourcetiming-connectend
m.connectStart:~RESOURCE-TIMING#dom-performanceresourcetiming-connectstart
m.decodedBodySize:~RESOURCE-TIMING#dom-performanceresourcetiming-decodedbodysize
m.domainLookupEnd:~RESOURCE-TIMING#dom-performanceresourcetiming-domainlookupend
m.domainLookupStart:~RESOURCE-TIMING#dom-performanceresourcetiming-domainlookupstart
m.encodedBodySize:~RESOURCE-TIMING#dom-performanceresourcetiming-encodedbodysize
m.fetchStart:~RESOURCE-TIMING#dom-performanceresourcetiming-fetchstart
m.nextHopProtocol:~RESOURCE-TIMING#dom-performanceresourcetiming-nexthopprotocol
m.redirectEnd:~RESOURCE-TIMING#dom-performanceresourcetiming-redirectend
m.redirectStart:~RESOURCE-TIMING#dom-performanceresourcetiming-redirectstart
m.requestStart:~RESOURCE-TIMING#dom-performanceresourcetiming-requeststart
m.responseEnd:~RESOURCE-TIMING#dom-performanceresourcetiming-responseend
m.responseStart:~RESOURCE-TIMING#dom-performanceresourcetiming-responsestart
m.secureConnectionStart:~RESOURCE-TIMING#dom-performanceresourcetiming-secureconnectionstart
m.transferSize:~RESOURCE-TIMING#dom-performanceresourcetiming-transfersize

m.supportedEntryTypes:~TIMELINE#dom-performanceobserver-supportedentrytypes

m.unloadEventStart:#dom-performancenavigationtiming-unloadeventstart
m.unloadEventEnd:#dom-performancenavigationtiming-unloadeventend
m.domInteractive:#dom-performancenavigationtiming-dominteractive
m.domContentLoadedEventStart:#dom-performancenavigationtiming-domcontentloadedeventstart
m.domContentLoadedEventEnd:#dom-performancenavigationtiming-domcontentloadedeventend
m.domComplete:#dom-performancenavigationtiming-domcomplete
m.loadEventStart:#dom-performancenavigationtiming-loadeventstart
m.loadEventEnd:#dom-performancenavigationtiming-loadeventend
m.type:#dom-performancenavigationtiming-type
m.redirectCount:#dom-performancenavigationtiming-redirectcount
m.toJSON:#dom-performancenavigationtiming-tojson

m.name:#dom-performancenavigationtiming-name
m.entryType:#dom-performancenavigationtiming-entrytype
m.startTime:#dom-performancenavigationtiming-starttime
m.duration:#dom-performancenavigationtiming-duration

m.initiatorType:#dom-performancenavigationtiming-initiatortype
	#dfn-initiatortype
	~RESOURCE-TIMING#dom-performanceresourcetiming-initiatortype
m.workerStart:#dom-performancenavigationtiming-workerstart
	#dom-PerformanceNavigationTiming-workerStart
	~RESOURCE-TIMING#dom-performanceresourcetiming-workerstart


m.getEntriesByType:~TIMELINE#dom-performance-getentriesbytype
m.performance:~HRTIME#dom-windoworworkerglobalscope-performance
m.timeOrigin:~HRTIME#dom-performance-timeorigin

m.location.reload():~HISTORY#dom-location-reload

	#dom-performancetiming-*
	1.navigationStart
	1.unloadEventStart
	1.unloadEventEnd
	1.redirectStart
	1.redirectEnd
	1.fetchStart
	1.domainLookupStart
	1.domainLookupEnd
	1.connectStart
	1.connectEnd
	1.secureConnectionStart
	1.requestStart
	1.responseStart
	1.responseEnd
	1.domLoading
	1.domInteractive
	1.domContentLoadedEventStart
	1.domContentLoadedEventEnd
	1.domComplete
	1.loadEventStart
	1.loadEventEnd
	1.toJSON

	#dom-performancenavigation-*
	1n.TYPE_NAVIGATE
	1n.TYPE_RELOAD
	1n.TYPE_BACK_FORWARD
	1n.TYPE_RESERVED
	1n.type
	1n.redirectCount
	1n.toJSON

1.timing:#dom-performance-timing
1.navigation:#dom-performance-navigation

	●
et.DOMContentLoaded:~HTMLindex#event-domcontentloaded
	#DOMContentLoaded
~unload~event:#_unload_event
	~NAVI#unloading-documents

l.back_forward:#dom-navigationtype-back_forward
l.navigate:#dom-navigationtype-navigate
l.prerender:#dom-navigationtype-prerender
l.reload:#dom-navigationtype-reload


	●
現在の文書:#dfn-current-document
局所~cache等:#_cache-or-local

時刻~値:#_time-value
所要時間:#_duration

i.~objの作成-:#step-create-object
i.~fetch開始:#fetch-start-step
i.~domain検索:#_step-domain-lookup
i.接続-開始:#connect-start-step
i.要請~開始:#request-start-step
i.応答~開始:#step-response-start
i.応答~終了:#step-response-end

処理能~entry~buffer:#dfn-performance-entry-buffer

	●外部
時刻起点:~HRTIME#dfn-time-origin
処理能~時列線:~TIMELINE#dfn-performance-timeline
同一-生成元~検査:#dfn-same-origin-check

x.ALPN Protocol ID:~RFCx/rfc7301
	:~RESOURCE-TIMING#sec-cross-origin-resources

処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
		定義表

~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~redirect状態s:~FETCH#redirect-status
要請:~FETCH#concept-request
要請~method:~FETCH#concept-request-method
rq.~redirect数:~FETCH#concept-request-redirect-count
rs.状態s:~FETCH#concept-response-status
~HTTP~redirect:~FETCH#redirect-status


	●
処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer

閲覧文脈:~BROWSERS#browsing-context
作動中の文書:~BROWSERS#active-document
結付けられている文書:~WINDOW#concept-document-window
関連な大域~obj:~WAPI#concept-relevant-global

緩い同一-生成元~施策:~ORIGIN#relaxing-the-same-origin-restriction
生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
閲覧文脈~sandbox化( ~navi )~flag:~ORIGIN#sandboxed-navigation-browsing-context-flag
閲覧文脈~sandbox化( 非~利用者~作動化~top-level~navi )~flag:~ORIGIN#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
閲覧文脈~sandbox化( 利用者~作動化~top-level~navi )~flag:~ORIGIN#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag

~navi:~NAVI#navigate
履歴の辿り:~NAVI#traverse-the-history
~unloadは利用者から拒否された:~NAVI#refused-to-allow-the-document-to-be-unloaded
素片識別子により生じた:~NAVI#navigate-fragid-step
	文書の~unload:~NAVI#unload-a-document
	§文書の~unload法:~NAVI#unloading-documents

現在の準備度:~HTMLdom#current-document-readiness
doc.~URL:~HTMLdom#the-document's-address
	'
refresh pragma 指令:~HEmetadata#attr-meta-http-equiv-refresh
meta refresh:~HEmetadata#attr-meta-http-equiv-refresh

持続的な接続:~HTTPmsg#persistent.connections
	https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1
非同期に閉じられ:~HTTPmsg#persistent.failures
	~RFC7230#section-6.5
事前具現化-:~RESOURCE-HINTS#prerender
作動中の~sw登録:~SW1#dfn-containing-service-worker-registration
~sw登録:~SW1#dfn-service-worker-registration
作動中の~worker:~SW1#dfn-active-worker
名前~fetch_evの~eventを発火-:~SW1#on-fetch-request-algorithm
	~SW1#fetchevent
~workerを走らす:~SW1#run-service-worker
走らす:~SW1#run-service-worker

関連な~app~cache:~HTMLLS/offline.html#relevant-application-cache

	~HTMLurl#fetching-resources
	~HTMLsyntax:#the-end

既定の~toJSON手続き:~WEBIDLjs#default-tojson-steps

~unloadを~prompt:~NAVI#prompt-to-unload-a-document
~HTTP~cache:~HTTPcache#cache
	~RFC7234#cache
~URL~scheme:~URL1#concept-url-scheme
I.Document:~HTMLdom#document


●●ref_normative

[ECMASCRIPT]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.es/ecma262/
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik. W3C. 21 November 2019. W3C Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[NAVIGATION-TIMING]
    Navigation Timing. Zhiheng Wang. W3C. 17 December 2012. W3C Recommendation. URL: https://www.w3.org/TR/navigation-timing/
[PERFORMANCE-TIMELINE-2]
    Performance Timeline Level 2. Ilya Grigorik. W3C. 24 October 2019. W3C Working Draft. URL: https://www.w3.org/TR/performance-timeline-2/
[RESOURCE-HINTS]
    Resource Hints. Ilya Grigorik. W3C. 2 July 2019. W3C Working Draft. URL: https://www.w3.org/TR/resource-hints/
[RESOURCE-TIMING]
    Resource Timing Level 1. Arvind Jain; Todd Reifsteck; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 30 March 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/resource-timing-1/
[RESOURCE-TIMING-2]
    Resource Timing Level 2. Todd Reifsteck; Ilya Grigorik; Yoav Weiss; Arvind Jain; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 28 November 2019. W3C Working Draft. URL: https://www.w3.org/TR/resource-timing-2/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC2616]
    Hypertext Transfer Protocol -- HTTP/1.1. R. Fielding; J. Gettys; J. Mogul; H. Frystyk; L. Masinter; P. Leach; T. Berners-Lee. IETF. June 1999. Draft Standard. URL: https://tools.ietf.org/html/rfc2616
[RFC7234]
    Hypertext Transfer Protocol (HTTP/1.1): Caching. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7234.html
[RFC8174]
    Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://tools.ietf.org/html/rfc8174
[SERVICE-WORKERS]
    Service Workers 1. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. 19 November 2019. W3C Candidate Recommendation. URL: https://www.w3.org/TR/service-workers-1/
[URL]
    URL Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://url.spec.whatwg.org/
[WebIDL]
    Web IDL. Boris Zbarsky. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/

●●ref_informative

[JSMEASURE]
    Measuring Client-Perceived Response Times on the WWW. Ramakrishnan Rajamony; Mootaz Elnozahy. March 2001. The Proceedings of the 3rd USENIX Symposium on Internet Technologies and Systems (USITS). URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.69.7329&rep=rep1&type=pdf
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://httpwg.org/specs/rfc7230.html


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">Navigation Timing 2</a>
を日本語に翻訳したものです（ level 1 仕様も
<a href="#obsolete">§ 廃用</a>
に取り込まれています）。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/navigation-timing-2/
最新の編集者草案
	https://w3c.github.io/navigation-timing/
テスト一式
	https://wpt.fyi/navigation-timing/
編集
	<a href="mailto:igrigorik@gmail.com">Ilya Grigorik</a> (Google)
前任編集者
	<a href="mailto:tobint@microsoft.com">Tobin Titus</a> (Microsoft Corp.) (Until January 2015)
	<a href="mailto:jmann@microsoft.com">Jatinder Mann</a>, (Microsoft Corp.) (Until February 2014)
	<a href="mailto:arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
Participate
	<a href="https://github.com/w3c/navigation-timing/">GitHub w3c/navigation-timing</a>
	<a href="https://github.com/w3c/navigation-timing/issues/">File a bug</a>
	<a href="https://github.com/w3c/navigation-timing/commits/gh-pages">Commit history</a>
	<a href="https://github.com/w3c/navigation-timing/pulls/">Pull requests</a>
ブラウザサポート
	https://caniuse.com/nav-timing
Mailing list
	https://lists.w3.org/Archives/Public/public-web-perf/
発行者
	<a href="https://www.w3.org/webperf/">Web Performance</a> Working Group

</script>

</head>

<body>

<header>

	<hgroup>
<h1>ナビの計時 — Navigation Timing 2</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section class="introductory" id="abstract">
~ABSTRACT

<p>
この仕様は、~web~appが文書の~naviに関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for navigation of a document.
</p>
	</section>

	<section id="sotd" class="introductory">
~STATUSofTHIS

<p>
これは編集者草案の公の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status">W3C 日本語訳 共通ページ</a>／冒頭の仕様メタデータに委譲。】
</p>

<p>
Navigation Timing 2 は、その最初の~versionである
`NAVIGATION-TIMING$r
を置き換えるものであり、次に挙げる変更を含んでいます：
◎
Navigation Timing 2 replaces the first version of [NAVIGATION-TIMING] and includes the following changes:
</p>

<ul>
	<li>
`Performance^I ~interfaceの定義は
`PERFORMANCE-TIMELINE-2$r
に移動された。
◎
the definition of Performance interface was moved to [PERFORMANCE-TIMELINE-2];
</li>
	<li>
`RESOURCE-TIMING-2$r の上に築かれる。
◎
builds on top of [RESOURCE-TIMING-2];
</li>
	<li>
`PERFORMANCE-TIMELINE-2$r
の~support。
◎
support for [PERFORMANCE-TIMELINE-2];
</li>
	<li>
`HR-TIME-2$r
の~support。
◎
support for [HR-TIME-2];
</li>
	<li>
`事前具現化-$させる~naviの~support。
`RESOURCE-HINTS$r
◎
support for prerender navigations [RESOURCE-HINTS];
</li>
	<li>
最後の非~redirect~naviからの~redirect数
— `redirectCount$m —
を公開する。
◎
exposes number of redirects since the last non-redirect navigation;
</li>
	<li>
次の~hopの~network~protocol
— `nextHopProtocol$m —
を公開する
◎
exposes next hop network protocol;
</li>
	<li>
［
転送 ／ 符号化された本体 ／ 復号された本体
］~size情報
— `transferSize$m ／ `encodedBodySize$m ／ `decodedBodySize$m —
を公開する。
◎
exposes transfer, encoded body and decoded body size information;
</li>
	<li>
`secureConnectionStart$m
属性の~supportは、今や，義務とされた。
◎
secureConnectionStart attribute is now mandatory.
</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~appの処理能~特性の測定は、~web~appをより高速にするために重要な側面になる。
`JSMEASURE$r
などの，~JSに基づく仕組みは、~app内における利用者~待時間（ `latency^en ）の測定~用の包括的な~~手段を供せる一方で、多くの事例で，それらは端点間における待時間の完全なあるいは詳細な様相を供せない。
例えば、次の~JSは、~pageが全部的に~loadされるまでの時間を，ごく素朴に測定しようと試みる：
◎
Accurately measuring performance characteristics of web applications is an important aspect of making web applications faster. While JavaScript-based mechanisms, such as the one described in [JSMEASURE], can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete or detailed end-to-end latency picture. For example, the following JavaScript shows a naive attempt to measure the time it takes to fully load a page:
</p>

<div class="example">

<pre class="lang-html">
&lt;html&gt;
&lt;head&gt;
&lt;script type="text/javascript"&gt;
var start = new Date().getTime();
function onLoad() {
  var now = new Date().getTime();
  var latency = now - start;
  alert("page loading time: " + latency);
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="onLoad()"&gt;
&lt;!-- <span class="comment">
~page本体の内容…
◎
Main page body goes from here.
</span> --&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

</div>

<p>
上の~scriptは `head^e ~tag内の最初の~JS~codeが実行されて<strong>以降から</strong>，~pageが~loadされるまでの時間は計算するが、~serverから~pageを得るために要した時間や, ~pageの初期~化 lifecycle 【！ ＊ 】についての情報は与えない。
◎
The above script calculates the time it takes to load the page after the first bit of JavaScript in the head is executed, but it does not give any information about the time it takes to get the page from the server, or the initialization lifecycle of the page.
</p>

<p>
この仕様は、文書の~naviに関係する高解像度の処理能~計量~dataを格納する／検索取得するための，
`PERFORMANCE-TIMELINE-2$r
に関与する `PerformanceNavigationTiming$I ~interfaceを定義する。
`PerformanceNavigationTiming$I ~interfaceは
`HR-TIME-2$r を利用するので、すべての時刻~値は，
`Window$I ~objの`時刻起点$を~~基準に計測される。
【したがって、 `PerformanceNavigationTiming^I ~interfaceが返す`時刻~値$ 0 は，`時刻起点$を表すことになる。】
◎
This specification defines the PerformanceNavigationTiming interface which participates in the [PERFORMANCE-TIMELINE-2] to store and retrieve high resolution performance metric data related to the navigation of a document. As the PerformanceNavigationTiming interface uses [HR-TIME-2], all time values are measured with respect to the time origin of the Window object.
</p>

<div class="example">
<p>
例えば，~HTTP応答の終了が~naviの開始から 100ms 後であったとするなら、
`PerformanceNavigationTiming$I
の~dataは次の様になるであろう：
◎
For example, if we know that the response end occurs 100ms after the start of navigation, the PerformanceNavigationTiming data could look like so:
</p>

<pre>
startTime:           0.000  /* <span class="comment">
~navi要請の開始~時刻
◎
start time of the navigation request
</span> */
responseEnd:       100.000  /* <span class="comment">
高解像度による，最後に受信された~byteの時刻
◎
high resolution time of last received byte
</span> */
</pre>
</div>

<p>
文書の~naviに関係する正確aな計時~dataを得するために，
`PerformanceNavigationTiming$I
~interfaceを利用する例を次の~scriptに示す：
◎
The following script shows how a developer can use the PerformanceNavigationTiming interface to obtain accurate timing data related to the navigation of the document:
</p>

<div class="example">

<pre class="lang-html">
&lt;script&gt;
function showNavigationDetails() {
  /* <span class="comment">
最初の~entryを取得する
◎
Get the first entry
</span> */
  const [%entry] = performance.getEntriesByType("navigation");
  /* <span class="comment">
結果を開発者~console内に表の~~形で示す
◎
Show it in a nice table in the developer console
</span> */
  console.table(%entry.toJSON());
}
&lt;/script&gt;
&lt;body onload="showNavigationDetails()"&gt;
</pre>

<div class="_test" id="_test_level2">【
利用中の~UAで、この~scriptに等価な処理を
<button onclick="get_timing_data2()">試みる</button>
】
<pre id="_test_output2">（結果は~consoleではなく，ここに示される）</pre>
【
他~pageでも利用できる<a href="~bookmarklet2">ブックマークレット</a>（結果は~consoleに示される）
】【
<a href="#_test_level1">Level 1 実装~用のもの</a>もある
】
</div>

</div>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology">W3C 日本語訳 共通ページ</a>,
次の下位節に委譲
】
◎
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo.
◎
The term "navigation" refers to the act of navigating.
</p>

<p>
【この仕様の各種~APIの記述に現れる】
`現在の文書@
は、【コレに`関連な大域~obj$である】`~window$に`結付けられている文書$を指す。
【この用語が利用される文脈における “前の文書” は、`現在の文書$へ~navigateされる前の時点で，当の閲覧文脈に在った文書を指す（明確には定義されていない）。】
◎
The term current document refers to the document associated with the Window object's newest Document object.
◎
The term JavaScript is used to refer to ECMA262, rather than the official term ECMAScript, since the term JavaScript is more widely known. [ECMASCRIPT]
</p>

<p id="_measured-since">
この仕様を通して、時刻は 文書の~naviの開始を起点としてミリ秒~単位で計測される。
例えば，文書の~naviの開始は、時刻 0 で生じる。
語 “<i>〜の時刻</i>” は、文書の~naviの開始から その時点までに経過した，ミリ秒数による時刻を指す。
この，時刻の定義は、 `HR-TIME-2$r による。
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document. For example, the start of navigation of the document occurs at time 0. The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time. This definition of time is based on [HR-TIME-2] specification.
</p>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>
<p>
簡潔に記すため、次の非公式な用語を導入する：
</p>

<ul>
	<li>
`時刻~値@
（あるいは
`所要時間@
）とは、何らかの時刻（あるいは時間~差）を表現する `DOMHighResTimeStamp$I 型~値を意味する。
“`時刻~値$ %t ”
という句は、値 %t をとる`時刻~値$を意味する。
“〜した／〜の時刻~値”
という句は、
“〜した／〜の時刻を表現する`時刻~値$”
の略記である。
</li>
	<li>
`~unload~event@
を開始した／完了した時点は、［
<a href="~NAVI#unloading-documents">文書の~unload法</a> ／
<a href="~NAVI#unload-a-document">文書の~unload手続き</a>
］の前後を指すか，これらの中で `unload^et ~eventを発火する前後を指す。
（原文の記述からは、この “`event^en” が~event~objを表すのか “~~出来事” を表すのかはっきりしないので、ここに集約して定義している。
意図的に曖昧にされているのかもしれない。）
</li>
</ul>

<p>
<a href="#obsolete">§ 廃用</a>（ Level 1 ）で原文が参照する~HTTP用語は，過去の~HTTP仕様 `RFC2616$r を参照しているが、この訳では，それに代わる改訂を成す一連の仕様（ `RFC7230$r 他, またはその和訳）を参照することにする。
</p>

		</section>
	</section>

	<section id="sec-navigation-timing">
<h2 title="Navigation Timing">3. ~naviの計時</h2>

		<section id="performanceentry">
<h3 title="Relation to the PerformanceEntry interface">3.1. `PerformanceEntry^I ~interfaceとの関係</h3>

<p>
`PerformanceNavigationTiming$I ~interfaceは、
`PerformanceEntry$I ~interfaceの次の属性を拡張する：
◎
PerformanceNavigationTiming interface extends the following attributes of PerformanceEntry interface:
</p>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
`現在の文書$の`~URL$doc【を直列化した結果】を返すモノトスル。
◎
The name attribute MUST return the DOMString value of the address of the current document.
</dd>

	<dt>`entryType@m</dt>
	<dd>
`DOMString^I 値 `navigation^l を返すモノトスル。
◎
The entryType attribute MUST return the DOMString "navigation".
</dd>

	<dt>`startTime@m</dt>
	<dd>
`時刻~値$ 0 を返すモノトスル。
◎
The startTime attribute MUST return a DOMHighResTimeStamp with a time value of 0. [HR-TIME-2]
</dd>

	<dt>`duration@m</dt>
	<dd>
`startTime$m
から
`loadEventEnd$m
までの`所要時間$を返すモノトスル。
【！ ,~respectively ？】
◎
The duration attribute MUST return a DOMHighResTimeStamp equal to the difference between loadEventEnd and startTime, respectively.
</dd>
</dl>

<p class="note">注記：
`PerformanceNavigationTiming$I を実装する~UAは、その~supportを開発者が検出できるよう，`~window$文脈~用の `supportedEntryTypes$m 内に `navigation^l を含める必要がある。
◎
Note
A user agent implementing PerformanceNavigationTiming would need to include "navigation" in supportedEntryTypes for Window contexts. This allows developers to detect support for Navigation Timing.
</p>

		</section>
		<section id="PerformanceResourceTiming">
<h3 title="Relation to the PerformanceResourceTiming interface">3.2. `PerformanceResourceTiming^I ~interfaceとの関係</h3>

<p>
`PerformanceNavigationTiming$I ~interfaceは、
`PerformanceResourceTiming$I ~interfaceの次の属性を拡張する：
◎
PerformanceNavigationTiming interface extends the following attributes of the PerformanceResourceTiming interface:
</p>

<dl class="idl-def">
	<dt>`initiatorType@m</dt>
	<dd>
取得子は、 `navigation^l を返すモノトスル。
◎
The initiatorType attribute MUST return the DOMString "navigation".
</dd>

	<dt>`workerStart@m</dt>
	<dd>
<p>
取得子は、次を返すモノトスル：
◎
The workerStart attribute MUST return＼
</p>
		<ul>
			<li>
`現在の文書$に `作動中の~sw登録$がある場合
— すなわち，［
要請を~serviceするために `~workerを走らす$ことが要求されている, または
そのような~workerは すでに可用である場合
`SERVICE-WORKERS$r
⇒
~UAが［
`作動中の~worker$に向けて，`名前~fetch_evの~eventを発火-$する／した
］直前の`時刻~値$
◎
the time immediately before the user agent ran the worker (if the current document has an active service worker registration [SERVICE-WORKERS]) required to service the request, or if the worker was already available, the time immediately before the user agent fired an event named `fetch` at the active worker.＼
</li>
			<li>
他の場合（`作動中の~worker$はない）、`時刻~値$ 0
◎
Otherwise, if there is no active worker this attribute MUST return zero.
</li>
		</ul>
	</dd>
</dl>

<p class="note">注記：
`処理能~時列線$に含められるのは
`現在の文書$ 資源に限られる
— `処理能~時列線$ 内にある `PerformanceNavigationTiming$I ~objは 1 個に限られる。
◎
Only the current document resource is included in the performance timeline; there is only one PerformanceNavigationTiming object in the performance timeline.
</p>

		</section>
		<section id="sec-PerformanceNavigationTiming">
<h3 title="The PerformanceNavigationTiming interface">3.3. `PerformanceNavigationTiming^I ~interface</h3>

<p class="note">注記：
`~HTTP~cache$ `RFC7234$r を検査して，そこから内容を検索取得することは、`~fetching$の一部を成す。
それは、［
`requestStart$m, `responseStart$m, `responseEnd$m
］属性が受持つ。
◎
Checking and retrieving contents from the HTTP cache [RFC7234] is part of the fetching process. It's covered by the requestStart, responseStart and responseEnd attributes.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `PerformanceNavigationTiming@I : `PerformanceResourceTiming$I {
    readonly attribute `DOMHighResTimeStamp$I `unloadEventStart$m;
    readonly attribute `DOMHighResTimeStamp$I `unloadEventEnd$m;
    readonly attribute `DOMHighResTimeStamp$I `domInteractive$m;
    readonly attribute `DOMHighResTimeStamp$I `domContentLoadedEventStart$m;
    readonly attribute `DOMHighResTimeStamp$I `domContentLoadedEventEnd$m;
    readonly attribute `DOMHighResTimeStamp$I `domComplete$m;
    readonly attribute `DOMHighResTimeStamp$I `loadEventStart$m;
    readonly attribute `DOMHighResTimeStamp$I `loadEventEnd$m;
    readonly attribute `NavigationType$I      `type$m;
    readonly attribute unsigned short      `redirectCount$m;
    [`Default$] object `toJSON$m();
};
</pre>

<dl class="idl-def">

	<dt>`unloadEventStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
When getting the value of the unloadEventStart attribute, run the following steps: 
</p>
		<ol>
			<li>
~IF［
前の文書は無い
］~OR［
`同一-生成元~検査$の結果 ~EQ `失敗-^i
］
⇒
~RET `時刻~値$ 0
◎
If there is no previous document, or if the same-origin check fails, return a DOMHighResTimeStamp with a time value equal to zero.
</li>
			<li>
~RET ~UAが［
前の文書の`~unload~event$を開始する
］直前の`時刻~値$
◎
Otherwise, return a DOMHighResTimeStamp with a time value equal to the time immediately before the user agent starts the unload event of the previous document.
</li>
		</ol>
	</dd>

	<dt>`unloadEventEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
When getting the value of the unloadEventEnd attribute, run the following steps:
</p>
		<ol>
			<li>
~IF［
前の文書は無い
］~OR［
`同一-生成元~検査$の結果 ~EQ `失敗-^i
］
⇒
~RET `時刻~値$ 0
◎
If there is no previous document, or if the same-origin check fails, return a DOMHighResTimeStamp with a time value equal to zero.
</li>
			<li>
~RET ~UAが［
前の文書の`~unload~event$を終えた
］直後の`時刻~値$
【原文では `unloadEventStart$m と同じ記述になっているが、誤記であろう。】
◎
Otherwise, return a DOMHighResTimeStamp with a time value equal to the time immediately before the user agent starts the unload event of the previous document.
</li>
		</ol>
	</dd>

	<dt>`domInteractive@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
~UAが［
`現在の文書$の`現在の準備度$を `interactive^l に設定する
］直前の`時刻~値$
◎
The domInteractive attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately before the user agent sets the current document readiness of the current document to "interactive" [HTML].
</dd>

	<dt>`domContentLoadedEventStart@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
~UAが［
`現在の文書$に向けて `DOMContentLoaded$et ~eventを発火する
］直前の`時刻~値$
◎
The domContentLoadedEventStart attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately before the user agent fires the DOMContentLoaded event at the current document.
</dd>

	<dt>`domContentLoadedEventEnd@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
［
`現在の文書$に向けて発火された `DOMContentLoaded$et ~eventが完了した
］直後の`時刻~値$
◎
The domContentLoadedEventEnd attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately after the current document's DOMContentLoaded event completes.
</dd>

	<dt>`domComplete@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
~UAが［
`現在の文書$の`現在の準備度$ `HTML$r を `complete^l に設定する
］直前の`時刻~値$
◎
The domComplete attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately before the user agent sets the current document readiness of the current document to "complete" [HTML].
</dd>
	<dd>
`現在の準備度$が複数回にわたり同じ状態に変化した場合、［
`domInteractive$m ／
`domContentLoadedEventStart$m ／
`domContentLoadedEventEnd$m ／
`domComplete$m
］は、［
最初に生じた`現在の準備度$の変化
］に対応している`時刻~値$を返すモノトスル。
◎
If the current document readiness changes to the same state multiple times, domInteractive, domContentLoadedEventStart, domContentLoadedEventEnd and domComplete MUST return a DOMHighResTimeStamp with a time value equal to the time of the first occurrence of the corresponding document readiness change [HTML].
</dd>

	<dt>`loadEventStart@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
［
`現在の文書$に向けて `load^et ~eventは発火された
］ならば その直前の`時刻~値$ ／
~ELSE_ `時刻~値$ 0 
◎
The loadEventStart attribute MUST return a DOMHighResTimeStamp with a time value equal to the time immediately before the load event of the current document is fired. It MUST return a DOMHighResTimeStamp with a time value equal to zero when the load event is not fired yet.
</dd>

	<dt>`loadEventEnd@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
［
`現在の文書$に向けて `load^et ~eventは発火され, 完了した
］ならば その`時刻~値$ ／
~ELSE_ `時刻~値$ 0
◎
The loadEventEnd attribute MUST return a DOMHighResTimeStamp with a time value equal to the time when the load event of the current document is completed. It MUST return a DOMHighResTimeStamp with a time value equal to zero when the load event is not fired or is not completed.
</dd>

	<dt>`type@m</dt>
	<dd>
取得子は、次を返すモノトスル
⇒
［
現在の閲覧文脈における最後の非~redirect`~navi$
］の種別を表す、いずれかの `NavigationType$I 値
◎
The type attribute MUST return a DOMString describing the type of the last non-redirect navigation in the current browsing context. It MUST have one of the NavigationType values.
</dd>

<dd class="note">注記：
`refresh pragma 指令$
を利用する類いの，~client側~redirectは、この仕様においては`~HTTP~redirect$とは見なされない。
その場合の `type$m 属性は、
現在の~pageを~reloadしている場合は `reload$l ／
新たな~URLへの~naviの場合は `navigate$l
など，適切な値を返すベキである。
◎
Client-side redirects, such as those using the Refresh pragma directive, are not considered HTTP redirects by this spec. In those cases, the type attribute SHOULD return appropriate value, such as reload if reloading the current page, or navigate if navigating to a new URL.
</dd>

	<dt>`redirectCount@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
When getting the redirectCount attribute, run the following steps:
</p>
		<ol>
			<li>
~IF［
~redirectは無い
］~OR［
`同一-生成元~検査$の結果 ~EQ `失敗-^i
］
⇒
~RET 0
◎
If there are no redirects or if the same-origin check fails, return zero.
</li>
			<li>
~RET 現在の`閲覧文脈$の下での，最後の非~redirect~naviからの~redirect回数
◎
Otherwise, return the number of redirects since the last non-redirect navigation under the current browsing context.
</li>
		</ol>
	</dd>

	<dt>`toJSON@m</dt>
	<dd>
`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
The toJSON() method runs [WEBIDL]'s default toJSON operation.
</dd>
</dl>

			<section id="sec-performance-navigation-types">
<h4 title="NavigationType enum">3.3.1. `NavigationType^I 列挙</h4>

<pre class="idl">
enum `NavigationType@I {
    `navigate$l,
    `reload$l,
    `back_forward$l,
    `prerender$l
};
</pre>

<p>
各種 値は、以下の定義に従う：
◎
The values are defined as follows:
</p>

<dl class="idl-def">
	<dt>`navigate@l</dt>
	<dd>
<p>
~naviは次のいずれかにより開始された：
</p>

<ul ><li>~linkの~click
</li><li>~UAの~address-barへの~URL手入力ng
</li><li>~form提出
</li><li>
下に挙げる `reload$l や `back_forward$l
に利用されるもの以外の，~script演算を通した初期~化
</li></ul>

◎
Navigation started by clicking on a link, or entering the URL in the user agent's address bar, or form submission, or initializing through a script operation other than the ones used by reload and back_forward as listed below.
</dd>

	<dt>`reload@l</dt>
	<dd>
~reload演算または
`location.reload()$m
~methodによる~navi。
◎
Navigation through the reload operation or the location.reload() method.
</dd>

	<dt>`back_forward@l</dt>
	<dd>
`履歴の辿り$による~navi。
◎
Navigation through a history traversal operation.
</dd>

	<dt>`prerender@l</dt>
	<dd>
`事前具現化-$させる~hintにより起動された~navi。
◎
Navigation initiated by a prerender hint [RESOURCE-HINTS].
</dd>

</dl>

<p class="note">注記：
上の列挙~値 `back_forward^l は
<a href="~WEBIDL#idl-enums">WebIDL が推奨する列挙~値の形式</a>
に整合していないが、出荷-済み実装との後方-互換性のため，変更するわけにはいかない。
◎
The format of the above enumeration value is inconsistent with the WebIDL recommendation for formatting of enumeration values. Unfortunately, we are unable to change it due to backwards compatibility issues with shipped implementations.
</p>

			</section>
		</section>
	</section>

	<section id="process">
<h3 title="Process">4. 処理</h3>

		<section id="processing-model">
<h3 title="Processing Model">4.1. 処理~model</h3>

<figure style="overflow:auto;">
<figcaption>
<b>図 1.</b>
次の図式は、
`PerformanceNavigationTiming$I
~interfaceにて定義される計時~属性を示すものである。
括弧内の属性は、`同一-生成元$でない文書を孕む~naviでは可用でない。
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceNavigationTiming interface. Attributes in parenthesis indicate that they may not be available for navigations involving documents from different origins.
</figcaption>

<div id="_time-table">
（時間は下に向かって進行する。）
	<div>
<div style="top:-0.5em">← `startTime$m</div>
<div style="top:0.5em">← ( `unloadEventStart$m )</div>
~unloadに対する~prompt
<div style="bottom:-0.5em">← ( `unloadEventEnd$m )</div>
	</div>
（ここからは `RESOURCE-TIMING$r ）
	<div>
<div style="top:-0.5em">← ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← `fetchStart$m</div>
~app~cache
	</div>
	<div>
<div style="top:-0.5em">← `domainLookupStart$m</div>
DNS
<div style="bottom:-0.5em">← `domainLookupEnd$m</div>
	</div>
	<div>
<div style="top:-0.5em">← `connectStart$m</div>
<div style="top:0.5em">← `secureConnectionStart$m</div>
TCP
<div style="bottom:-0.5em">← `connectEnd$m</div>
	</div>
	<div style="margin-bottom:0">
<div style="top:-0.5em">← `requestStart$m</div>
要請
	</div>
	<div style="margin-top:0">
<div style="top:-0.5em">← `responseStart$m</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>
（ `RESOURCE-TIMING$r はここまで）
	<div style="height: 5em">
<div style="top:-0.5em">← `domInteractive$m</div>
<div style="top:0.5em">← `domContentLoadedEventStart$m</div>
処理
<div style="bottom:0.5em">← `domContentLoadedEventEnd$m</div>
<div style="bottom:-0.5em">← `domComplete$m</div>
	</div>
	<div>
<div style="top:-0.5em">← `loadEventStart$m</div>
~load
<div style="bottom:-0.5em">← `loadEventEnd$m</div>
	</div>
</div>

【この訳では、原文の図式（ SVG ）を HTML + CSS による等価な図式に差し替えている。】

</figure>

<ol>
	<li>
<p>
~IF［
当の`~navi$は 次のいずれかの事由により中止された
］
⇒
~RET
◎
If the navigation is aborted for any of the following reasons, abort these steps.
</p>
		<ul>
			<li>
`閲覧文脈~sandbox化( ~navi )~flag$により
◎
The navigation is aborted due to the sandboxed navigation browsing context flag,＼
</li>
			<li>
`閲覧文脈~sandbox化( 非~利用者~作動化~top-level~navi )~flag$により
◎
the sandboxed top-level navigation without user activation browsing context flag or＼
</li>
			<li>
`閲覧文脈~sandbox化( 利用者~作動化~top-level~navi )~flag$により
◎
the sandboxed top-level navigation with user activation browsing context flag,＼
</li>
			<li>
当の`閲覧文脈$を~navigateする試みがすでに存在する
◎
a preexisting attempt to navigate the browsing context, or＼
</li>
			<li>
利用者が~naviを取り消した
◎
the user canceling the navigation.
</li>
			<li>
~naviは~page内の`素片識別子により生じた$
◎
The navigation is caused by fragment identifiers within the page.
</li>
			<li>
~navi先の資源は 何らかの種類の~inline内容により処理されている
◎
The new resource is to be handled by some sort of inline content.
</li>
			<li>
~navi先の資源は `閲覧文脈$に影響しない仕組みを利用して処理されている
◎
The new resource is to be handled using a mechanism that does not affect the browsing context.
</li>
			<li>
前の文書の`~unloadは利用者から拒否された$
◎
The user refuses to allow the document to be unloaded.
</li>
		</ul>
	</li>
	<li>
`~objの作成-@i
⇒
%計時~obj ~LET 新たな `PerformanceNavigationTiming$I ~obj
— 以降に現れる［
この~interface, この~interfaceが継承する~interface
］の属性は、すべて %計時~obj 上のそれを表すとする
◎
Create a new PerformanceNavigationTiming object and＼
</li>
	<li>
%計時~obj を`処理能~entry~buffer$に追加する
◎
add it to the performance entry buffer.
</li>
	<li>
`name$m ← `document^l
◎
Set name to the DOMString "document".
</li>
	<li>
`entryType$m ← `navigation^l
◎
↓</li>
	<li>
`initiatorType$m ← `navigation^l
◎
Set entryType and initiatorType to the DOMString "navigation".
</li>
	<li>
`startTime$m ← `時刻~値$ 0
◎
Set startTime to a DOMHighResTimeStamp with a time value of zero,＼
</li>
	<li>
`nextHopProtocol$m ← 空 `DOMString^I
◎
and nextHopProtocol to the empty DOMString.
</li>
	<li>
<p>
~IF［
現在の~navi種別はまだ設定されていない
【この条件は何を意味する？】
］
⇒
`type$m ~SET
~naviがどう開始されたかに応じて，次で与えられる~navi種別
◎
Record the current navigation type in type if it has not been set:
</p>
		<dl class="switch">
			<dt>~linkの~click</dt>
			<dt>~UAの~address-barへの~URL手入力ng</dt>
			<dt>~form提出</dt>
			<dt>`location.reload()$m ~method以外の~script演算を通した初期~化</dt>
			<dd>
`navigate$l
◎
If the navigation was started by clicking on a link, or entering the URL in the user agent's address bar, or form submission, or initializing through a script operation other than the location.reload() method, let the navigation type be the DOMString "navigate".
</dd>

			<dt>`meta refresh$ の結果</dt>
			<dt>`location.reload()$m ~method</dt>
			<dt>その他の等価な動作</dt>
			<dd>
`reload$l
◎
If the navigation was started either as a result of a meta refresh, or the location.reload() method, or other equivalent actions, let the navigation type be the DOMString "reload".
</dd>

			<dt>`履歴の辿り$</dt>
			<dd>
`back_forward$l
◎
If the navigation was started as a result of history traversal, let the navigation type be the DOMString "back_forward".
</dd>
		</dl>
	</li>
	<li>
( `unloadEventStart$m, `unloadEventEnd$m ) ~SET ( 0, 0 )
◎
↓</li>
	<li>
<p>
~IF［
~redirectはある
］~AND［
`同一-生成元~検査$の結果 ~EQ `合格-^i
］：
</p>
		<ol>
			<li>
`unloadEventStart$m ~SET 前の文書の`~unload~event$の直前の時刻
</li>
			<li>
`unloadEventEnd$m ~SET 前の文書の`~unload~event$を完了した直後の時刻
</li>
			<li>
%workerStart ~LET 0
</li>
			<li>
<p>
~IF［
~navi~URLに合致する`~sw登録$ %worker はある
］：
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である（`作動中の~worker$である）
］
⇒
%workerStart ~SET
~UAが %worker に向けて `名前~fetch_evの~eventを発火-$した直前の時刻
</li>
					<li>
~ELSE
⇒
%workerStart ~SET
~UAが %worker を`走らす$直前の時刻
</li>
				</ol>
			</li>
			<li>
`workerStart$m ~SET %workerStart
</li>
		</ol>

◎
If there are no redirects or if the same-origin check fails, set both unloadEventStart and unloadEventEnd to 0 then go to fetch-start-step. Otherwise, record unloadEventStart as the time immediately before the unload event.
◎
Immediately after the unload event is completed, record the current time as unloadEventEnd. If the navigation URL has an active worker registration, immediately before the user agent runs the worker record the time as workerStart, or if the worker is available, record the time before the event named fetch is fired at the active worker. Otherwise, if the navigation URL has no matching service worker registration, set workerStart value to zero.
</li>
	<li>
<p>
`~fetch開始@i：
</p>
		<ol>
			<li>
%fetchStart ~SET 0
</li>
			<li>
~IF［
新たな資源の~fetchは `GET^hm `要請~method$により行われた
］
⇒
%fetchStart ~SET
~UAが`関連な~app~cache$を検査する直前の時刻
</li>
			<li>
~ELSE
⇒
%fetchStart ~SET
~UAが資源の`~fetching$を開始する直前の時刻
</li>
			<li>
(
`fetchStart$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
) ~SET ( %fetchStart, %fetchStart, %fetchStart, %fetchStart, %fetchStart )
</li>
		</ol>
◎
[fetch-start-step] If the new resource is to be fetched using a "GET" request method, immediately before a user agent checks with the relevant application caches, record the current time as fetchStart. Otherwise, immediately before a user agent starts the fetching process, record the current time as fetchStart.
◎
Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
	<li>
`name$m ~SET 現在の文書の`~URL$doc【を直列化した結果】
◎
Set name to a DOMString value of the address of the current document.
</li>
	<li>
~IF［
資源は（ `~HTTP~cache$ `RFC7234$r も含めた）`関連な~app~cache$や局所~資源から~fetchされる
］
⇒
~GOTO `要請~開始$i
◎
If the resource is fetched from the relevant application cache or local resources, including the HTTP cache [RFC7234], go to request-start-step.
</li>
	<li>
<p>
`~domain検索@i：
</p>
		<ol>
			<li>
~IF［
~domain検索は要求されていない
］
⇒
~GOTO `接続-開始$i
◎
If no domain lookup is required, go to connect-start-step.＼
</li>
			<li>
`domainLookupStart$m ~SET ~UAが~domain名~検索を開始する直前の時刻
◎
Otherwise, immediately before a user agent starts the domain name lookup, record the time as domainLookupStart.
</li>
			<li>
~IF［
~domain検索に成功しなかった
］
⇒
~RET
— ~UAは成功するまで複数回の再試行が必要になり得る
◎
↓</li>
			<li>
`domainLookupEnd$m ~SET ~domain名~検索に成功した直後の時刻
◎
Record the time as domainLookupEnd immediately after the domain name lookup is successfully done. A user agent MAY need multiple retries before that. If the domain lookup fails, abort the rest of the steps.
</li>
		</ol>
	</li>
	<li>
<p>
`接続-開始@i：
</p>
		<ol>
			<li>
~IF［
資源の~fetchに持続的~transport接続が利用されている
］
⇒
( `connectStart$m, `connectEnd$m )
~SET
( `domainLookupEnd$m, `domainLookupEnd$m )
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
`connectStart$m ~SET ~serverへの接続を起動する直前の時刻
</li>
					<li>
~IF［
~serverまたは~proxyへの接続を確立できなかった
］
⇒
~RET
— ~UAは確立されるまで複数回の再試行が必要になり得る。
</li>
					<li>
`connectEnd$m ~SET ~serverまたは~proxyへの接続が確立された直後の時刻
</li>
					<li>
`nextHopProtocol$m ~SET 接続に利用される `ALPN Protocol ID$x
</li>
				</ol>
			</li>
		</ol>

◎
[connect-start-step] If a persistent transport connection is used to fetch the resource, let connectStart and connectEnd be the same value of domainLookupEnd. Otherwise, record the time as connectStart immediately before initiating the connection to the server and record the time as connectEnd immediately after the connection to the server or the proxy is established. A user agent MAY need multiple retries before this time. Once connection is established set the value of nextHopProtocol to the ALPN ID used by the connection. If a connection can not be established, abort the rest of the steps.
</li>
	<li>
`secureConnectionStart$m ~SET
`RESOURCE-TIMING$r の処理~model
【<a href="~RESOURCE-TIMING#processing-model">~~参照</a>】
に定義されるとおりに，この属性に設定される値
◎
A user agent MUST also set the secureConnectionStart attribute as defined in the attribute's processing model in [RESOURCE-TIMING].
</li>
	<li>
<p>
`要請~開始@i：
</p>
		<ol>
			<li>
`requestStart$m ~SET ~UAが文書への要請の送信を開始する直前の時刻
◎
[request-start-step] Immediately before a user agent starts sending request for the document, record the current time as requestStart.
</li>
			<li>
`応答~開始@i
⇒
`responseStart$m ~SET ~UAが応答の最初の~byteを受信した直後の時刻
◎
Record the time as responseStart immediately after the user agent receives the first byte of the response.
</li>
			<li>
`応答~終了@i
⇒
`responseEnd$m ~SET ~UAが応答の最後の~byteを受信した直後の時刻
◎
Record the time as responseEnd immediately after receiving the last byte of the response.
</li>
		</ol>

<p>
この段の中で 要請の送信または応答~全体の受信-に失敗し，接続を再び開く必要がある場合
⇒
~GOTO `接続-開始$i
◎
Return to connect-start-step if the user agent fails to send the request or receive the entire response, and needs to reopen the connection.
</p>

<p class="note">注記：
`持続的な接続$が可能化されているときは、
~UAはまず最初に，要請を送信するために開いた接続の再利用を（その接続は`非同期に閉じられ$得るが）試行してもヨイ。
そのような場合の
`connectStart$m,
`connectEnd$m,
`requestStart$m
は、再び開いた接続において収集された計時~情報を表現するベキである。
◎
When persistent connection [RFC7230] is enabled, a user agent MAY first try to re-use an open connect to send the request while the connection can be asynchronously closed. In such case, connectStart, connectEnd and requestStart SHOULD represent timing information collected over the re-open connection.
</p>
	</li>
	<li>
( `transferSize$m, `encodedBodySize$m, `decodedBodySize$m )
~SET 前~段による結果の対応する値
◎
Set the value of transferSize, encodedBodySize, decodedBodySize to corresponding values.
</li>
	<li>
<p>
~IF［
資源を~fetchした結果，`~HTTP~redirect$になった
］：
◎
If the fetched resource results in an HTTP redirect, then
</p>
		<ol>
			<li>
~IF［
`同一-生成元~検査$の結果 ~EQ `失敗-^i
］
⇒＃
( `redirectStart$m, `redirectEnd$m, `unloadEventStart$m, `unloadEventEnd$m, `redirectCount$m ) ~SET ( 0, 0, 0, 0, 0 )；
~GOTO `~fetch開始$i（新たな資源の下で）
◎
If the same-origin check fails, set redirectStart, redirectEnd, unloadEventStart, unloadEventEnd and redirectCount to 0. Then, return to fetch-start-step with the new resource.
</li>
			<li>
`redirectCount$m ~INCBY 1
◎
Increment redirectCount by 1.
</li>
			<li>
~IF［
`redirectStart$m ~EQ 0
］
⇒
`redirectStart$m ~SET `fetchStart$m
◎
If the value of redirectStart is 0, let it be the value of fetchStart.
</li>
			<li>
`redirectEnd$m ~SET `responseEnd$m
◎
Let redirectEnd be the value of responseEnd.
</li>
			<li>
`nextHopProtocol$m ~SET 空 `DOMString^I
◎
↓</li>
			<li>
%計時~obj 内の属性のうち，次に挙げるものを除く すべての属性の値 ~SET 0
⇒
`startTime$m,
`redirectStart$m,
`redirectEnd$m,
`redirectCount$m,
`type$m,
`nextHopProtocol$m,
`unloadEventStart$m,
`unloadEventEnd$m
◎
Set all of the attributes in the PerformanceNavigationTiming object to 0 except startTime, redirectStart, redirectEnd, redirectCount, type, nextHopProtocol, unloadEventStart and unloadEventEnd. Set nextHopProtocol to the empty DOMString.
</li>
			<li>
~GOTO `~fetch開始$i（新たな資源の下で）
◎
Return to fetch-start-step with the new resource.
</li>
		</ol>
	</li>
	<li>
`domInteractive$m ~SET
~UAが文書の`現在の準備度$を `interactive^l に設定する直前の時刻
◎
Record the time as domInteractive immediately before the user agent sets the current document readiness to "interactive".
</li>
	<li>
`domContentLoadedEventStart$m ~SET
~UAが文書に向けて `DOMContentLoaded$et ~eventを発火する直前の時刻
◎
Record the time as domContentLoadedEventStart immediately before the user agent fires the DOMContentLoaded event at the document.
</li>
	<li>
`domContentLoadedEventEnd$m ~SET
`DOMContentLoaded$et ~eventが完了した直後の時刻
◎
Record the time as domContentLoadedEventEnd immediately after the DOMContentLoaded event completes.
</li>
	<li>
`domComplete$m ~SET
~UAが文書の`現在の準備度$を `complete^l に設定する直前の時刻
◎
Record the time as domComplete immediately before the user agent sets the current document readiness to "complete".
</li>
	<li>
`loadEventStart$m ~SET
~UAが `load^et ~eventを発火する直前の時刻
◎
Record the time as loadEventStart immediately before the user agent fires the load event.
</li>
	<li>
`loadEventEnd$m ~SET
~UAが `load^et ~eventを完了した直後の時刻
◎
Record the time as loadEventEnd immediately after the user agent completes the load event.
</li>
	<li>
`duration$m ~SET ［
`startTime$m から `loadEventEnd$m まで
］の`所要時間$
【！ ,~respectively ？】
◎
Set the duration to a DOMHighResTimeStamp equal to the difference between loadEventEnd and startTime, respectively.
</li>
	<li>
`処理能~entryを~queueする$( %計時~obj )
◎
Queue the new PerformanceNavigationTiming object.
</li>
</ol>

<p>
一部の~UAは、 “進む”, “戻る” などの~navi演算の間，文書の DOM 構造を~memory内に保守する。
そのような~naviの間は `PerformanceNavigationTiming$I ~objは改められないモノトスル。
◎
Some user agents maintain the DOM structure of the document in memory during navigation operations such as forward and backward. In those cases, the PerformanceNavigationTiming object MUST NOT be altered during the navigation. 
</p>

		</section>
		<section id="same-origin-check">
<h3 title="Same-origin check">4.2. 同一-生成元~検査</h3>

<div class="algorithm">
<p>
`同一-生成元~検査@
は、次を走らす：
</p>

<ol>
	<li>
%生成元~list ~LET 空~list
</li>
	<li>
~IF［
前の文書は存在する
］
⇒
%生成元~list に前の文書の生成元を付加する
</li>
	<li>
%生成元~list に`現在の文書$を~fetchさせた`要請$に対する，すべての~redirect
— `状態s$rsは`~redirect状態s$である応答 —
の生成元を付加する
</li>
	<li>
%生成元~list を成す
~EACH( %生成元 )
に対し
⇒
~IF［
( %生成元, `現在の文書$の生成元 )
は`同一-生成元$でない
］
⇒
~RET `失敗-^i
</li>
	<li>
~RET `合格-^i
</li>
</ol>

<p class="trans-note">【
原文の~algoは，~redirectが生じなかった場合に問答無用で `失敗-^i を返しているが、明らかに見落としであろう。
】</p>

◎
When asked to run the same-origin check, the user agent MUST run the following steps:
• If the previous document exists and its origin is not same origin as the current document's origin, return "fail".
• Let request be the current document's request.
• If request's redirect count is not zero, and all of request's HTTP redirects have the same origin as the current document, return "pass".
• Otherwise, return "fail".
</div>

		</section>
	</section>
	<section id="privacy">
<h2 title="Privacy">5. ~privacy</h2>

~INFORMATIVE

		<section id="info_disclosure">
<h3 title="Information disclosure">5.1. 情報の流出</h3>
<p>
注意深く細工された計時~攻撃の利用により、末端利用者による
閲覧／行動
の履歴が流出する可能性がある。
一例として、~unload時刻から前の~pageの~unload~handlerに要した時間が明らかにされ，利用者の~login状態sの推定-に利用され得る。
これらの攻撃は、［
前の~naviを含む計時~情報に~accessされたときに，`同一-生成元~検査$を施行する
］ことにより，軽減される。
◎
There is the potential for disclosing an end-user's browsing and activity history by using carefully crafted timing attacks. For instance, the unloading time reveals how long the previous page takes to execute its unload handler, which could be used to infer the user's login status. These attacks have been mitigated by enforcing the same-origin check algorithm when timing information involving the previous navigation is accessed.
</p>

<p>
`緩い同一-生成元~施策$は、文書~間に渡る，未承認の訪問に対する十分な保護を供さない。
共有d~hostにおいては、信頼できない第三者主体が，同じ~IP~addressの異なる~port上で~HTTP~serverを~hostし得る。
◎
The relaxed same origin policy doesn't provide sufficient protection against unauthorized visits across documents. In shared hosting, an untrusted third party is able to host an HTTP server at the same IP address but on a different port.
</p>
		</section>

		<section id="cross-directory">
<h3 title="Cross-directory access">5.2. ~directory間をまたがる~access</h3>
<p>
同じ~host名を共有する異なる~page
— 例えば、同じ~siteに~hostされている，利用者が生成した内容を伴う, 異なる作者による内容 —
は、~path名に基いて~accessを制約するような特能がないため，`同一-生成元$から来たものと見なされる。
これらの~page間の~naviに際しては、後の~pageから，~redirectや`~unload~event$に対する計時など，前の~pageの計時~情報への~accessが可能になる。
◎
Different pages sharing one host name, for example contents from different authors hosted on sites with user generated content are considered from the same origin because there is no feature to restrict the access by pathname. Navigating between these pages allows a latter page to access timing information of the previous one, such as timing regarding redirection and unload event.
</p>

		</section>
	</section>

	<section id="security">
<h2 title="Security">6. ~security</h2>

~INFORMATIVE

<p>
`PerformanceNavigationTiming$I ~interfaceは、前の文書についての計時~情報を`現在の文書$に公開する。
`PerformanceNavigationTiming$I 上の属性のうち，前の文書の情報を含むものへの~accessを制限するため、`同一-生成元~検査$が施行され，【失敗した場合は】前の文書に関係する属性は 0 に設定される。
◎
The PerformanceNavigationTiming interface exposes timing information about the previous document to the current document. To limit the access to PerformanceNavigationTiming attributes which include information on the previous document, the same-origin check algorithm is enforced and attributes related to the previous document are set to zero.
</p>

		<section id="authentication">
<h3 title="Detecting proxy servers">6.1. ~proxy~serverの検出-法</h3>
<p>
~UAと~web~serverとの間に~proxyが配備されている場合、
`connectStart$m 属性と `connectEnd$m 属性との間の時区間は、 ~web~serverではなく，~proxyと~UAとの間の待時間を示すものになる。
それにより、~web~serverは，~proxyの存在を推定できる可能性がある。
SOCKS ~proxyについては、この時区間には~proxy認証に要した時間と~proxyが~web~serverへの接続に要した時間も含まれ，~proxyの検出を難しくする。
~HTTP~proxyの場合、~UAは~proxy~serverについての知識を一切持たないこともあるので、この攻撃を常に軽減できるとは限らない。
◎
In case a proxy is deployed between the user agent and the web server, the time interval between the connectStart and the connectEnd attributes indicates the delay between the user agent and the proxy instead of the web server. With that, web server can potentially infer the existence of the proxy. For SOCKS proxy, this time interval includes the proxy authentication time and time the proxy takes to connect to the web server, which obfuscate the proxy detection. In case of an HTTP proxy, the user agent might not have any knowledge about the proxy server at all so it's not always feasible to mitigate this attack.
</p>

		</section>
	</section>
	<section id="obsolete" style="background:#FFF0F0;">
<h2 title="Obsolete">7. 廃用</h2>

<p>
この節では、以前に
`NAVIGATION-TIMING$r Level 1
にて導入された属性, ~interfaceを定義し，後方-互換性のために ここに保つ。
作者には、以下の~interfaceを利用するべきでない
— 新たな `PerformanceNavigationTiming$I ~interfaceを利用することを強く勧める。
<a href="#sotd" >変更点と改善点の要約</a>を見よ。
◎
This section defines attributes and interfaces previously introduced in [NAVIGATION-TIMING] Level 1 and are kept here for backwards compatibility. Authors should not use the following interfaces and are strongly advised to use the new PerformanceNavigationTiming interface—see summary of changes and improvements.
</p>

<p>
以下における
`局所~cache等@
は、［
`関連な~app~cache$, または局所~資源
］を指す総称とする。
</p>

		<section id="dom-performancetiming">
<h3 title="The PerformanceTiming interface">7.1. `PerformanceTiming^I ~interface</h3>
<pre class="idl">
[`Exposed$=Window]
interface `PerformanceTiming$I {
  readonly attribute unsigned long long `navigationStart$1;
  readonly attribute unsigned long long `unloadEventStart$1;
  readonly attribute unsigned long long `unloadEventEnd$1;
  readonly attribute unsigned long long `redirectStart$1;
  readonly attribute unsigned long long `redirectEnd$1;
  readonly attribute unsigned long long `fetchStart$1;
  readonly attribute unsigned long long `domainLookupStart$1;
  readonly attribute unsigned long long `domainLookupEnd$1;
  readonly attribute unsigned long long `connectStart$1;
  readonly attribute unsigned long long `connectEnd$1;
  readonly attribute unsigned long long `secureConnectionStart$1;
  readonly attribute unsigned long long `requestStart$1;
  readonly attribute unsigned long long `responseStart$1;
  readonly attribute unsigned long long `responseEnd$1;
  readonly attribute unsigned long long `domLoading$1;
  readonly attribute unsigned long long `domInteractive$1;
  readonly attribute unsigned long long `domContentLoadedEventStart$1;
  readonly attribute unsigned long long `domContentLoadedEventEnd$1;
  readonly attribute unsigned long long `domComplete$1;
  readonly attribute unsigned long long `loadEventStart$1;
  readonly attribute unsigned long long `loadEventEnd$1;
  [`Default$] object `toJSON$1();
};
</pre>

<div class="_test" id="_test_level1">【
利用中の~UAで、この~pageについて，これらの属性~値を
<button onclick="get_timing_data1()"
>取得-を試みる</button>
（括弧内は `navigationStart$1 からの時間差）
】
<pre id="_test_output1">（結果は~consoleではなく，ここに示される）</pre>

<p>【
他~pageでも利用できる<a href="~bookmarklet1">ブックマークレット</a>（結果は~consoleに示される）】【
<a href="#_test_level2">Level 2 実装~用のもの</a>もある
】</p>
</div>

<p class="note">注記：
この節に定義されるすべての時刻~値は、
1970 年 1 月 1 日, 午前 0 時（ UTC ）からのミリ秒単位で計測されるとする。
◎
All time values defined in this section are measured in milliseconds since midnight of January 1, 1970 (UTC).
</p>

<dl class="idl-def">
	<dt>`navigationStart@1</dt>
	<dd>
前の文書があるならば
~UAが前の文書に対し`~unloadを~prompt$し終えた直後の時刻 ／
~ELSE_ 現在の文書が作成された時刻を返すモノトスル。
◎
This attribute must return the time immediately after the user agent finishes prompting to unload the previous document. If there is no previous document, this attribute must return the time the current document is created.
</dd>
	<dd class="note">注記：
この属性は、 `PerformanceNavigationTiming$I 用には定義されていない。
作者は、代わりに `timeOrigin$m を利用して，等価な時刻印を得せる。
◎
This attribute is not defined for PerformanceNavigationTiming. Instead, authors can use timeOrigin to obtain an equivalent timestamp.
</dd>

	<dt>`unloadEventStart@1</dt>
	<dd>
前の文書がある, かつ
前の文書と現在の文書が`同一-生成元$に属する場合は，~UAが前の文書の`~unload~event$を開始する直前の時刻 ／
~ELSE_ 0 を返すモノトスル。
◎
If the previous document and the current document have the same origin, this attribute must return the time immediately before the user agent starts the unload event of the previous document. If there is no previous document or the previous document has a different origin than the current document, this attribute must return zero.
</dd>

	<dt>`unloadEventEnd@1</dt>
	<dd>
前の文書はある, かつ
前の文書と現在の文書が`同一-生成元$に属する, かつ
前の文書の`~unload~event$は完了している
場合は，~UAが その~eventを終えた直後の時刻  ／
~ELSE_ 0 を返すモノトスル。
◎
If the previous document and the current document have the same same origin, this attribute must return the time immediately after the user agent finishes the unload event of the previous document. If there is no previous document or the previous document has a different origin than the current document or the unload is not yet completed, this attribute must return zero.
</dd>
	<dd>
~navigate時に`~HTTP~redirect$があって, かつ その中に`同一-生成元$に属さない`~HTTP~redirect$がある場合、［
`unloadEventStart$1, `unloadEventEnd$1
］とも 0 を返すモノトスル。
◎
If there are HTTP redirects when navigating and not all the redirects are from the same origin, both PerformanceTiming.unloadEventStart and PerformanceTiming.unloadEventEnd must return zero.
</dd>

	<dt>`redirectStart@1</dt>
	<dd>
~navigate時に`~HTTP~redirect$があって, かつ
すべての`~HTTP~redirect$が`同一-生成元$に属する場合は， `fetchStart$1 と同じ値 ／
~ELSE_ 0 を返すモノトスル。
◎
If there are HTTP redirects when navigating and if all the redirects are from the same origin, this attribute must return the starting time of the fetch that initiates the redirect. Otherwise, this attribute must return zero.
</dd>

	<dt>`redirectEnd@1</dt>
	<dd>
~navigate時に`~HTTP~redirect$があって, かつ
すべての`~HTTP~redirect$が`同一-生成元$に属する場合は，その最後の~redirectを成す応答の最後の~byteを受信した直後の時刻 ／
~ELSE_ 0
を返すモノトスル。
◎
If there are HTTP redirects when navigating and all redirects are from the same origin, this attribute must return the time immediately after receiving the last byte of the response of the last redirect. Otherwise, this attribute must return zero.
</dd>

	<dt>`fetchStart@1</dt>
	<dd>
`GET^hm `要請~method$を利用して新たな資源が`~fetch$された場合は，~UAが`関連な~app~cache$の検査を開始する直前の時刻 ／
~ELSE_ ~UAが資源の`~fetch$を開始した時刻
を返すモノトスル。
◎
If the new resource is to be fetched using a "GET" request method, fetchStart must return the time immediately before the user agent starts checking any relevant application caches. Otherwise, it must return the time when the user agent starts fetching the resource.
</dd>

	<dt>`domainLookupStart@1</dt>
	<dd>
現在の文書の~domain名~検索を開始する直前の時刻を返すモノトスル。
`持続的な接続$が利用されている，または
現在の文書が`局所~cache等$から検索取得されている場合、この属性は
`fetchStart$1
と同じ値を返すモノトスル。
◎
This attribute must return the time immediately before the user agent starts the domain name lookup for the current document. If a persistent connection [RFC2616] is used or the current document is retrieved from relevant application caches or local resources, this attribute must return the same value as PerformanceTiming.fetchStart.
</dd>

	<dt>`domainLookupEnd@1</dt>
	<dd>
~UAが現在の文書に対する~domain名~検索を終えた直後の時刻を返すモノトスル。
`持続的な接続$が利用されている，または
現在の文書が`局所~cache等$から検索取得されている場合、この属性は
`fetchStart$1
と同じ値を返すモノトスル。
◎
This attribute must return the time immediately after the user agent finishes the domain name lookup for the current document. If a persistent connection [RFC2616] is used or the current document is retrieved from relevant application caches or local resources, this attribute must return the same value as PerformanceTiming.fetchStart.
</dd>
	<dd class="note">注記：
`~HTTP~cache$からの内容の 検査と検索取得は`~fetching$の一部である。
それは、［
`requestStart$1, `responseStart$1, `responseEnd$1
］属性が受持つ。
◎
Checking and retrieving contents from the HTTP cache [RFC2616] is part of the fetching process. It's covered by the PerformanceTiming.requestStart, PerformanceTiming.responseStart and PerformanceTiming.responseEnd attributes.
</dd>
	<dd class="note">注記：
~UAが~cache内に~domain情報をすでに持っている場合、［
`domainLookupStart$1, `domainLookupEnd$1
］は，順に，~UAによる~cacheからの~domain~dataの検索取得を［
開始-, 終了
］した時刻を表現する。
◎
In case where the user agent already has the domain information in cache, domainLookupStart and domainLookupEnd represent the times when the user agent starts and ends the domain data retrieval from the cache.
</dd>

	<dt>`connectStart@1</dt>
	<dd>
~UAが文書を検索取得するために~serverへの接続を確立し始める直前の時刻を返すモノトスル。
`持続的な接続$が利用されている，または
現在の文書が`局所~cache等$から検索取得されている場合、この属性は
`domainLookupEnd$1
と同じ値を返すモノトスル。
◎
This attribute must return the time immediately before the user agent start establishing the connection to the server to retrieve the document. If a persistent connection [RFC2616] is used or the current document is retrieved from relevant application caches or local resources, this attribute must return value of PerformanceTiming.domainLookupEnd.
</dd>

	<dt>`connectEnd@1</dt>
	<dd>
~UAが文書を検索取得するための~serverへの接続を確立し終えた直後の時刻を返すモノトスル。
`持続的な接続$が利用されている，または
現在の文書が`局所~cache等$から検索取得されている場合、この属性は
`domainLookupEnd$1
と同じ値を返すモノトスル。
◎
This attribute must return the time immediately after the user agent finishes establishing the connection to the server to retrieve the current document. If a persistent connection [RFC2616] is used or the current document is retrieved from relevant application caches or local resources, this attribute must return the value of PerformanceTiming.domainLookupEnd
</dd>
	<dd>
~transport接続が失敗し, かつ~UAが接続を再び開いた場合、［
`connectStart$1, `connectEnd$1
］は，新たな接続に対応する値を返すべきである。
◎
If the transport connection fails and the user agent reopens a connection, PerformanceTiming.connectStart and PerformanceTiming.connectEnd should return the corresponding values of the new connection.
</dd>
	<dd>
`connectEnd$1 には、 SSL ~handshakeや SOCKS 認証も含めて，~transport接続を確立するのに要した時間も含めるモノトスル。
◎
PerformanceTiming.connectEnd must include the time interval to establish the transport connection as well as other time interval such as SSL handshake and SOCKS authentication.
</dd>

	<dt>`secureConnectionStart@1</dt>
	<dd>
この属性の~supportは任意選択~である。
~UAは、この属性を可用にしない場合は， `undefined^c を返すモノトスル。
可用にする場合、［［
現在の~pageの`~URL~scheme$ `URL$r ~EQ `https^l
］ならば 現在の接続を~secureにするための~handshake処理-を開始する直前の時刻 ／
~ELSE_ 0
］を返すモノトスル。
◎
This attribute is optional. User agents that don't have this attribute available must set it as undefined. When this attribute is available, if the scheme [URL] of the current page is "https", this attribute must return the time immediately before the user agent starts the handshake process to secure the current connection. If this attribute is available but HTTPS is not used, this attribute must return zero.
</dd>

	<dt>`requestStart@1</dt>
	<dd>
~UAが，現在の文書を［
~serverから, または`局所~cache等$から
］得るために 要請を開始した直前の時刻を返すモノトスル。
◎
This attribute must return the time immediately before the user agent starts requesting the current document from the server, or from relevant application caches or from local resources.
</dd>
	<dd>
要請を送信した後に~transport接続が失敗して, ~UAが接続を再び開いて要請を送信し直していた場合、
`requestStart$1
は，新たな要請に対応している値を返すべきである。
◎
If the transport connection fails after a request is sent and the user agent reopens a connection and resend the request, PerformanceTiming.requestStart should return the corresponding values of the new request.
</dd>
	<dd class="note">
<p>注記：
この~interfaceには <code>requestEnd</code> のような類いの，要請の送信の完了を表現する属性は含まれていない：
◎
This interface does not include an attribute to represent the completion of sending the request, e.g., requestEnd.
</p>

		<ul>
			<li>
~UAからの要請の送信の完了は、（その種の属性の便益のほとんどを占める）~network~transportにおける対応する完了­時刻を常に指示するとは限らない。
◎
Completion of sending the request from the user agent does not always indicate the corresponding completion time in the network transport, which brings most of the benefit of having such an attribute.
</li>
			<li>
一部の~UAにおいては、HTTP 層の~encapsulationに因り，要請の送信を実際に完了した時刻を決定するのに~costがかかる。
◎
Some user agents have high cost to determine the actual completion time of sending the request due to the HTTP layer encapsulation.
</li>
		</ul>
	</dd>

	<dt>`responseStart@1</dt>
	<dd>
~UAが~serverからの, または`局所~cache等$からの，応答の最初の~byteを受信した直後の時刻を返すモノトスル。
◎
This attribute must return the time immediately after the user agent receives the first byte of the response from the server, or from relevant application caches or from local resources.
</dd>

	<dt>`responseEnd@1</dt>
	<dd>
~UAが
現在の文書の最後の~byteを受信した直後の時刻と, ~transport接続が閉じらる直前の時刻のうち，早い方を返すモノトスル。
ここでの文書は、~serverから, および`局所~cache等$から，のいずれから受信されたものも含まれる。
◎
This attribute must return the time immediately after the user agent receives the last byte of the current document or immediately before the transport connection is closed, whichever comes first. The document here can be received either from the server, relevant application caches or from local resources.
</dd>

	<dt>`domLoading@1</dt>
	<dd>
~UAが文書の`現在の準備度$を `loading^l に設定する直前の時刻を返すモノトスル。
◎
This attribute must return the time immediately before the user agent sets the current document readiness to "loading".
</dd>
	<dd class="warning">
既存の~UA内で `Document$I ~objが いつ作成されたかの違いに因り，この属性が返す値は実装に特有であり、有意義な計量に利用されるべきではない。
◎
Due to differences in when a Document object is created in existing user agents, the value returned by the domLoading is implementation specific and should not be used in meaningful metrics.
</dd>

	<dt>`domInteractive@1</dt>
	<dd>
~UAが文書の`現在の準備度$を `interactive^l に設定する直前の時刻を返すモノトスル。
◎
This attribute must return the time immediately before the user agent sets the current document readiness to "interactive".
</dd>

	<dt>`domContentLoadedEventStart@1</dt>
	<dd>
~UAが `Document$I に向けて `DOMContentLoaded$et ~eventを発火する直前の時刻を返すモノトスル。
◎
This attribute must return the time immediately before the user agent fires the DOMContentLoaded event at the Document.
</dd>

	<dt>`domContentLoadedEventEnd@1</dt>
	<dd>
文書の
<a><code>DOMContentLoaded</code> ~event</a>
が完了した直後の時刻を返すモノトスル。
◎
This attribute must return the time immediately after the document's DOMContentLoaded event completes.
</dd>

	<dt>`domComplete@1</dt>
	<dd>
~UAが文書の`現在の準備度$を `complete^l に設定する直前の時刻を返すモノトスル。
◎
This attribute must return the time immediately before the user agent sets the current document readiness to "complete".
</dd>
	<dd>
文書の`現在の準備度$が複数回にわたり同じ状態に変化した場合、
`domLoading$1,
`domInteractive$1,
`domContentLoadedEventStart$1,
`domContentLoadedEventEnd$1,
`domComplete$1
は、最初に生じた 文書の`現在の準備度$の変化に対応している時刻を返すモノトスル。
◎
If the current document readiness changes to the same state multiple times, PerformanceTiming.domLoading, PerformanceTiming.domInteractive, PerformanceTiming.domContentLoadedEventStart, PerformanceTiming.domContentLoadedEventEnd and PerformanceTiming.domComplete must return the time of the first occurrence of the corresponding document readiness change.
</dd>

	<dt>`loadEventStart@1</dt>
	<dd>
現在の文書に `load^et ~eventが発火される直前の時刻を返すモノトスル。
`load^et ~eventがまだ発火されていないときには、 0 を返すモノトスル。
◎
This attribute must return the time immediately before the load event of the current document is fired. It must return zero when the load event is not fired yet.
</dd>

	<dt>`loadEventEnd@1</dt>
	<dd>
現在の文書の `load^et ~eventの発火-が完了した時刻を返すモノトスル。
`load^et ~eventがまだ発火されていない, またはまだ完了していないときには、 0 を返すモノトスル。
◎
This attribute must return the time when the load event of the current document is completed. It must return zero when the load event is not fired or is not completed.
</dd>

	<dt>`toJSON@1</dt>
	<dd>
`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
Runs [WEBIDL]'s default toJSON operation.
</dd>
</dl>

		</section>
		<section id="dom-performancenavigation">
<h3 title="The PerformanceNavigation interface">7.2. `PerformanceNavigation^I ~interface</h3>

<pre class="idl">
[`Exposed$=Window]
interface `PerformanceNavigation$I {
  const unsigned short `TYPE_NAVIGATE$1n = 0;
  const unsigned short `TYPE_RELOAD$1n = 1;
  const unsigned short `TYPE_BACK_FORWARD$1n = 2;
  const unsigned short `TYPE_RESERVED$1n = 255;
  readonly attribute unsigned short `type$1n;
  readonly attribute unsigned short `redirectCount$1n;
  [`Default$] object `toJSON$1n();
};
</pre>

<dl class="idl-def">
	<dt>`TYPE_NAVIGATE@1n</dt>
	<dd>
<p>
~naviが、次のいずれかにより開始された：
</p>
<ul><li>~linkの~click
</li><li>~UAの~address-barへの~URL手入力ng
</li><li>~form提出
</li><li>下に挙げる
`TYPE_RELOAD$1n, `TYPE_BACK_FORWARD$1n
に利用されるもの以外の，~script演算を通した初期~化
</li></ul>
◎
Navigation started by clicking on a link, or entering the URL in the user agent's address bar, or form submission, or initializing through a script operation other than the ones used by TYPE_RELOAD and TYPE_BACK_FORWARD as listed below.
</dd>

	<dt>`TYPE_RELOAD@1n</dt>
	<dd>
~reload演算または `location.reload()$m ~methodによる~navi。
◎
Navigation through the reload operation or the location.reload() method.
</dd>

	<dt>`TYPE_BACK_FORWARD@1n</dt>
	<dd>
`履歴の辿り$による~navi。
◎
Navigation through a history traversal operation.
</dd>

	<dt>`TYPE_RESERVED@1n</dt>
	<dd>
上で定義されない任意の種別の~navi。
◎
Any navigation types not defined by values above.
</dd>

	<dt>`type@1n</dt>
	<dd>
現在の`閲覧文脈$における最後の非~redirect`~navi$の種別を，上に挙げた定数~値のいずれかとして返すモノトスル。
◎
This attribute must return the type of the last non-redirect navigation in the current browsing context. It must have one of the following navigation type values.
</dd>
	<dd class="note">注記：
`refresh pragma 指令$を利用する類いの，~client側による~redirectは、この仕様においては`~HTTP~redirect$とは見なされない。
それらの場合，この属性は、［
現在の~pageを~reloadしている場合は `TYPE_RELOAD$1n ／
新たな URL へ~navigateしている場合は `TYPE_NAVIGATE$1n
］など，適切な値を返すべきである。
◎
Client-side redirects, such as those using the Refresh pragma directive, are not considered HTTP redirects by this spec. In those cases, the type attribute should return appropriate value, such as TYPE_RELOAD if reloading the current page, or TYPE_NAVIGATE if navigating to a new URL.
</dd>

	<dt>`redirectCount@1n</dt>
	<dd>
現在の`閲覧文脈$の下での，最後の非~redirect~naviからの~redirect回数を返すモノトスル。
［
そのような~redirectは無い, または
行先~文書と`同一-生成元$に属さない~redirectがある
］場合、 0 を返すモノトスル。
◎
This attribute must return the number of redirects since the last non-redirect navigation under the current browsing context. If there is no redirect or there is any redirect that is not from the same origin as the destination document, this attribute must return zero.
</dd>

	<dt>`toJSON@1n</dt>
	<dd>
`既定の~toJSON手続き$ `WEBIDL$r を走らす。
◎
Runs [WEBIDL]'s default toJSON operation.
</dd>
</dl>

		</section>
		<section id="extensions-to-the-performance-interface">
<h3 title="Extensions to the Performance interface">7.3. `Performance^I ~interfaceに対する拡張</h3>

<pre class="idl">
[`Exposed$=Window]
partial interface `Performance^I {
  [`SameObject$]
  readonly attribute `PerformanceTiming$I `timing$1;
  [`SameObject$]
  readonly attribute `PerformanceNavigation$I `navigation$1;
};
</pre>

<p>
`Performance^I ~interfaceは `PERFORMANCE-TIMELINE-2$r にて定義される。
【！ ~TIMELINE#extensions-to-the-performance-interface】
◎
The Performance interface is defined in [PERFORMANCE-TIMELINE-2].
</p>

<dl class="idl-def">
	<dt>`timing@1</dt>
	<dd>
最後の非~redirect ~navi以降の`閲覧文脈$に関係する計時~情報を表現する。
◎
The timing attribute represents the timing information related to the browsing contexts since the last non-redirect navigation.＼
</dd>
	<dd>
この属性は `PerformanceTiming$I ~interfaceにより定義される。
◎
This attribute is defined by the PerformanceTiming interface.
</dd>
	<dt>`navigation@1</dt>
	<dd>
この属性は `PerformanceNavigation$I ~interfaceにより定義される。
◎
The navigation attribute is defined by the PerformanceNavigation interface.
</dd>
</dl>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgments">謝辞</h2>

<p>
貢献された次の方々に感謝する：
</p>

<p lang="en-x-a0">
Thanks to Anne Van Kesteren, Arvind Jain, Boris Zbarsky, Jason Weber, Jonas Sicking, James Simonsen, Karen Anderson, Nic Jansma, Philippe Le Hegaret, Steve Souders, Todd Reifsteck, Tony Gentilcore, William Chan and Zhiheng Wang for their contributions to this work.
</p>

	</section>
</main></div>
