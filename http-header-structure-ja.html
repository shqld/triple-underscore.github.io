<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Structured Headers for HTTP（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<style type="text/css">
.hex-value {
	font-family: sans-serif0, sans-serif;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#ref-${key}`;//.toLowerCase();
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'sh': // types
	text = `${text}<sup>sh</sup>`;
	break;
case 'p':
	href = `#p.${key}`;
	break;
case 'sec':
	{
		const keys = key.split('/');
		const spec = keys[0];
		const sec = keys[1];
		if(sec){
			text = `[${spec}] § ${sec}`;
			if(spec.slice(0,3) === 'RFC'){
				href = `~IETF/rfc${spec.slice(3)}#section-${sec}`;
			}
		} else {
			text = ` § ${spec}`;
		}
		klass = '';
	}
	break;
case 'X': // byte value
	text = `%x${text}`;
	break;
case 'ch':
	return(
`<span class="hex-value">0x${(key.charCodeAt(0)).toString(16).toUpperCase()}</span>（ "<code class="literal">${key}</code>" ）`
	);
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>


<script type="text/plain" id="_source_data">

●●options

spec_date:2020-02-01
trans_update:2020-02-03
source_checked:200124
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html
	abbr_url:HEADER-STRUCTURE
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_id_prefix:ref-
ref_rfc:true
site_nav:network,http
trans_1st_pub:2020-01-27

●●class_map
p:production
P:token
X:hex-value
h:header
m:method

●●tag_map
h:code
m:code
P:code
p:code
c:code
s:samp
X:span
i:i
cite:cite
st:code

●●original_id_map

references:rfc.references

●●link_map

P.ALPHA:~HTTPcommon#P.ALPHA
P.DIGIT:~HTTPcommon#P.DIGIT
P.DQUOTE:~HTTPcommon#P.DQUOTE
P.SP:~HTTPcommon#P.SP
P.VCHAR:~HTTPcommon#P.VCHAR
P.LF:~HTTPcommon#P.LF
	P.CR:~HTTPcommon#P.CR
	P.HTAB:~HTTPcommon#P.HTAB
	P.CTL:~HTTPcommon#P.CTL
	制御~文字

	~RFC7230 → ~HTTPsem
p.token:~HTTPsem#p.token
p.tchar:~HTTPsem#p.tchar
p.field-name:~HTTPsem#p.field-name
p.field-value:~HTTPsem#p.field-value

p.bare-item:#p.bare-item
p.base64:#p.base64
p.boolean:#p.boolean
p.chr:#p.chr
p.dict-member:#p.dict-member
p.escaped:#p.escaped
p.inner-list:#p.inner-list
p.key:#p.key
p.lcalpha:#p.lcalpha
p.list-member:#p.list-member
p.member-name:#p.member-name
p.member-value:#p.member-value
p.param-name:#p.param-name
p.param-value:#p.param-value
p.sh-binary:#p.sh-binary
p.sh-boolean:#p.sh-boolean
p.sh-dictionary:#p.sh-dictionary
p.sh-decimal:#p.sh-decimal
p.sh-integer:#p.sh-integer
p.sh-item:#p.sh-item
p.sh-list:#p.sh-list
p.sh-string:#p.sh-string
p.sh-token:#p.sh-token
p.unescaped:#p.unescaped


有構造~header名:#structured-header-name
有構造~header値:#structured-header-value

sh.~list:#sh-list
sh.内縁~list:#sh-inner-list
sh.~parameters:#sh-parameters
sh.辞書:#sh-dictionary
sh.~item:#sh-item
sh.裸~item:#sh-bare-item
sh.~key:#sh-key
sh.~byte列:#sh-binary
sh.真偽値:#sh-boolean
sh.~decimal:#sh-decimal
sh.~token:#sh-token
sh.文字列:#sh-string
sh.整数:#sh-integer

	§
	sh.~parameters:#param
	sh.~key:#_key
	sh.~byte列:#binary
	sh.真偽値:#boolean
	sh.辞書:#dictionary
	sh.~decimal:#decimal
	sh.~token:#token
	sh.文字列:#string
	sh.内縁~list:#inner-list
		~inner-list:#inner-list
		~inner-list
	sh.整数:#integer
	sh.~item:#item
	sh.~list:#list
	sh.~parameters:#param
	sh.裸~item:#_bare-item

~token文字:#_token-characters
~key文字:#_key-characters
	~base64~alphabet:#_base64-alphabet

裸~itemを直列化する:#ser-bare-item
~byte列を直列化する:#ser-binary
真偽値を直列化する:#ser-boolean
辞書を直列化する:#ser-dictionary
内縁~listを直列化する:#ser-innerlist
~itemまたは内縁~listを直列化する:#_ser-item-or-list
~itemを直列化する:#ser-item
~keyを直列化する:#ser-key
~listを直列化する:#ser-list
~parametersを直列化する:#ser-params
整数を直列化する:#ser-integer
負でない整数を直列化する:#_ser-non-negative-integer
~decimalを直列化する:#ser-decimal
文字列を直列化する:#ser-string
~tokenを直列化する:#ser-token

裸~itemを構文解析する:#parse-bare-item
~byte列を構文解析する:#parse-binary
真偽値を構文解析する:#parse-boolean
辞書を構文解析する:#parse-dictionary
内縁~listを構文解析する:#parse-innerlist
~itemを構文解析する:#parse-item
~itemまたは内縁~listを構文解析する:#parse-item-or-list
~keyを構文解析する:#parse-key
~listを構文解析する:#parse-list
実数を構文解析する:#parse-number
~parametersを構文解析する:#parse-param
文字列を構文解析する:#parse-string
~tokenを構文解析する:#parse-token

	~spaceを読飛ばす:#_skip-space

	●§
	有構造~headerの構文解析-法:#text-parse
	有構造~headerの直列化-法:#text-serialize

	rfc.abstract
	rfc.title
	rfc.status
	rfc.copyrightnotice
	rfc.toc
1:#introduction
1.1:#strict
1.2:#notational-conventions
2:#specify
3:#types
3.1:#list
3.1.1:#inner-list
3.1.2:#param
3.2:#dictionary
3.3:#item
3.3.1:#integer
3.3.2:#decimal
3.3.3:#string
3.3.4:#token
3.3.5:#binary
3.3.6:#boolean
4:#text
4.1:#text-serialize
4.1.1:#ser-list
4.1.2:#ser-dictionary
4.1.3:#ser-item
4.1.4:#ser-integer
4.1.5:#ser-decimal
4.1.6:#ser-string
4.1.7:#ser-token
4.1.8:#ser-binary
4.1.9:#ser-boolean
4.2:#text-parse
4.2.1:#parse-list
4.2.2:#parse-dictionary
4.2.3:#parse-item
4.2.4:#parse-number
4.2.5:#parse-string
4.2.6:#parse-token
4.2.7:#parse-binary
4.2.8:#parse-boolean
5:#iana-considerations
6:#security-considerations
7:#rfc.references
7.1:#rfc.references.1
7.2:#rfc.references.2

A:#acknowledgements
B:#faq
B.1:#why-not-json
B.2:#structured-headers-dont-fit-my-data
C:#implementation-notes
D:#changes
	D.1:#since-draft-ietf-httpbis-header-structure-14
	D.2:#since-draft-ietf-httpbis-header-structure-13
	D.3:#since-draft-ietf-httpbis-header-structure-12
	D.4:#since-draft-ietf-httpbis-header-structure-11
	D.5:#since-draft-ietf-httpbis-header-structure-10
	D.6:#since-draft-ietf-httpbis-header-structure-09
	D.7:#since-draft-ietf-httpbis-header-structure-08
	D.8:#since-draft-ietf-httpbis-header-structure-07
	D.9:#since-draft-ietf-httpbis-header-structure-06
	D.10:#since-draft-ietf-httpbis-header-structure-05
	D.11:#since-draft-ietf-httpbis-header-structure-04
	D.12:#since-draft-ietf-httpbis-header-structure-03
	D.13:#since-draft-ietf-httpbis-header-structure-02
	D.14:#since-draft-ietf-httpbis-header-structure-01
	D.15:#since-draft-ietf-httpbis-header-structure-00
	#rfc.authors


	●外部（HTTP

受信者:~HTTPsem#recipient
中継者:~HTTPsem#intermediary
送信者:~HTTPsem#sender
	~message
上流:~HTTPsem#upstream
下流:~HTTPsem#downstream
結合-:~HTTPsem#combine-headers
RFC7230/3.2.2:~RFC7230#section-3.2.2
	結合-:~RFC7231#combine-headers
	結合-:~HTTPsem#combine-headers
新たな~headerに対する考慮点:~RFC7231#section-8.3.1
	RFC7231/8.3.1
	~HTTPsem#considerations.for.new.header.fields

	●外部（INFRA

真偽値:#boolean
~byte列:~INFRA#byte-sequence

~tuple:~INFRA#tuple
~list:~INFRA#list
~size:~INFRA#list-size
~item:~INFRA#list-item
有順序~map:~INFRA#ordered-map
map.~key:~INFRA#map-key
map.値:~INFRA#map-value
map.~entry:~INFRA#map-entry

除去する:~INFRA#list-remove
付加する:~INFRA#list-append
	置換する:~INFRA#list-replace
連結する:~INFRA#string-concatenate
~ASCII復号する:~INFRA#ascii-decode
~ASCII符号化する:~INFRA#ascii-encode
長さ:~INFRA#string-length
位置~変数:~INFRA#string-position-variable
文字~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace

制御~文字:~INFRA#control
~ASCII文字:~INFRA#ascii-code-point
~ASCII数字:~INFRA#ascii-digit
~ASCII英字:~INFRA#ascii-alpha
~ASCII英小文字:~INFRA#ascii-lower-alpha
~ASCII~byte:~INFRA#ascii-byte


●●words_table1
HTTPsem:http-semantics-ja.html

ナラナイ:<em class="rfc2119">ならない</em>
ベキ:<em class="rfc2119">べき</em>
ヨイ:<em class="rfc2119">よい</em>

●●words_table

	●型／構造
decimal:::10 進数
parameters:::parameter 群:パラメタ群
実数:number:数
有符号:signed:~
無符号:unsigned:~
深さ:depth:~
数量-:numeric:~
下位構造:substructure::~
包装-:wrap::~
裸:bare::~
	〜を包装する:wrapper
	~list$:array
構成-:compose:~
小数:fractional:~
符号:sign:~
分割-:split:~
HPACK:

	浮動小数点
	固定小数点数
	Dictionary
	List
	Item
	列:sequence／sequence of
	-:key-value
	-:name-value
	~item$sh:singular
	有構造~header:Structured Header／:structured header
	〜:inclusive
	内縁~list:inner list／inner-list
	~byte列:bytes/byte sequence/sequence of bytes/array of bytes
	~parameter(s)を伴い得る:parameterised

	●構文解析／直列化
結合-:combine::~
	結合-時:upon combination
連結-:concatenate::~
	連結:concatenation
読飛ばす:skipする:読み飛ばす
引用符:quote:~
	引用符で括られない:unquoted
二重引用符:double quote:~
一重引用符:single quotes:~
丸括弧:parenthesis:~
区切子:delimiter::~
	全体を〜括:surrounding
	区切られ:separate
	区切りの:-separated
	区切られ:delimitされ
	括られ:delimitされ
	で区切る:separated
	区切りの:-separated:~
base64:
alphabet:
octet::::オクテット
英小文字:lower alpha::~
英字:alpha::~
数字:digit::~
桁数:digits:~
桁:digit:~
単語:word:~
生産器:producer::~
消費器:consumer::~
pad:
	~padするもの:padding
合成-:synthesize:~
	0 個以上の:optional
貪欲:greedy:~

	`\^ch: backslash
	` ^ch:space:
	`,^ch:comma:
	`;^ch:semicolon
	`:^ch:colon:
	` ^ch:whitespace
	`SP$P:whitespace
	`HTAB^P, `LF^P, `CR^P:tabs, newlines, carriage returns
	LF$P:line feed
	2 個目以降:remaining
	%位置 ~INCBY 1:discard
	破棄-:Discard any leading SP characters from
	-:removing
	~~文字:letter
	始まる／の先頭に:beginning
	~ASCII数字:decimal digits
	10 進数:decimal number
	過ぎた:reach
	$p:field-name
	$p:field-value
	混在する:mixされた
	混成:mix
	-:printable
	~base64に符号化-:base64-encoding
	欠落して:missing
	末尾に余計な:trailing
	-:rounding
	-:equidistant
	〜を閉じる:closing
	10 進記数法:base 10
	~header:field

	●処理
剥取る:stripする:剥ぎ取る
往来-:round-trip::~
overhead::::オーバーヘッド
	~NEQ ε:there is a duplicate
	~BREAK~exit the loop
	~MUL:product
	^en:Base 64
	~EQ:~match
	構文解析を失敗させる:fail parsing
	直列化を失敗させる:fail serialisation
	-:prepend
	-:outside

	●network
送信者:sender::~
中継者:intermediary::~
受信者:recipient::~
主体:party::~
回送-:forward::~
伝送路:wire::~
伝達-:convey::~

	受信した〜である:receiving
	伝送路~上:on-wire

	●仕様
component::::コンポーネント
収容-:accommodate:~
安全性:safety:~
微妙:subtle:~
指導:guidance:~
採用:adoption:~
架空の:fictitiousな:~
正せ:correctでき:~
流儀:fashion:~
良好:good:~
表出:expression:~
表記上の:notational:~
質問:question:~
陥穽:pitfall:落とし穴
高処理能:performant:~
不一致:disagreement:~
具体的:concrete:~
助言:advice:~
確約-:assure:~
際どい:edge:~
緩めな:relaxしな:~
緩めれ:relaxでき:~
	~~緩める:loosen
将来有望:prospective:~
読者:reader:~
課す:imposeする:~
消費:consumption:~
機能:function:~
一式:suite:~
任意選択する:opt inする:任意で選択する
拙く:poorに:~
忠実:faithful:~
	忠実に:fidelity
IANA:
収まっ:fitし:~
収まら:fitし:~
収める:fitさせる:~
感覚:feeling:~
具体化-:illustrate:~
制定-:stipulate:~

	しわ寄せが行く:create pressure
	予め除外する:preclude
	厳密さ:strictness
	定義し直す:redefine
	認識されない:unrecognised
	逆に:conversely
	選ばれ:chosen
	必要に応じて:as they require／:as necessary
	-:readability
	-:remember
	〜周り:around
	きちんと:well
	ここ:herein:#1
	それ~~専用の:bespoke
	それにより／その結果:thereby
	でない:non-
	なり得るもの:potential
	主要な~major:#1
	予測-不能:unpredictable
	人:people
	似た何か／見えない:look
	作業-法:working
	優先される~precedenceを~take
	全体:overall
	全体を／-:at all
	制限-付き／制限された:limited
	勧める~advise:
	区別:distinction
	好ましい:preferably
	少しの:little
	少しばかり:slightly
	広い:broad
	広く:widely
	必要とされ:necessary
	悪化させ:make worse
	早期の:earlier
	更には:furthermore
	書かれる:written
	書き手:writer
	極めて:extremely
	次の様な見かけになる:might/could look like
	注記:note
	短かく言えば:in short
	至った:led
	表され:denote
	見込みが高い／見込まれ:likely
	許容しないものとして:disallow
	骨の折れる:onerous
	可能性もある:It is possible
	判別-不能:indistinguishable
	省略可否:whether their presence is required or optional
	欠落して:missing
	次の点で相違する:with the exceptions
	したくなりがち:tempted
	不必要な:unnecessary
	代替を成す:alternative
	~~寛容:tolerant
	~~親切:helpful
	一助:help
	-:thanks to
	:opt into
	まっとうに:right
	却下:reject
	適さない:unsuitable
	どう実装されても:vary
	対象になる:target
	一連の段からなる:step-by-step
	早く:early
	近く:closely
	を指して〜称せる:~refer
	特になし:has no actions
	全~能力を備える:fully capable

	●未分類
Foo:
巨大:large:~

	短い:short
	箇所:place
	在ること:presence
	重複する／:duplicate
	最後:final
	^en:memory commitment
	`Example-Description^h ~header:description

	●訳注
TLS:
random::::ランダム
負債:debt:~

	●変数
	%出力:output
	%~memberたち:members
	%~member:(member_value, parameters)
	%~member値:member_value
	%出力~文字列:output_string
	%入力~list:input_list
	%~list:inner_list
	%~list~parameters:list_parameters
	%入力~parameters:input_parameters
	%~parameter名:param_name
	%~parameter値:param_value
	%~parameter名:~parameter-name
	%入力~key:input_key
	%入力~辞書:input_dictionary
	%~member名:member_name
	%裸~item:bare_item
	%~item~parameters:item_parameters
	%入力~item:input_item
	%入力~整数~input_integer
	%入力~decimal:input_decimal
	%整数~桁数:integer_digits
	%入力~文字列:input_string
	%入力~token:input_token
	%入力~byte列:input_byte
	%入力~真偽値:input_boolean
	-:input_number
	%~header型:header_type
	~item_or_inner_list:item_or_inner_list
	%~key:this_key
	%出力:output_number
	-:next_char
	%~base64内容:b64_content
	%~binary内容:binary_content
	%文字:char
	%符号:sign

	●指示語
	個までは:at least
	更なる:further
	少数の:few
	後続の:subsequent
	頭部の:leading
	いくつかの:a number of
	他には〜ない:the only
	まるごと:altogether
	一連の:set of／
	個数:number of
	一部分:portion thereof
	総数:total number of
	わたって／またがって:across
	〜の個数:cardinality
	12:fifteen
	最も近い:nearest
	まで:at most
	まで:no more than

●●ref_normative

[RFC0020]
    Cerf, V., “ASCII format for network interchange”, STD 80, ~RFC20, October 1969
[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, ~RFC2119, March 1997
[RFC4648]
    Josefsson, S., “The Base16, Base32, and Base64 Data Encodings”, ~RFC4648, October 2006
[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, ~RFC5234, January 2008
[RFC7230]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, ~RFC7230, June 2014
[RFC8174]
    Leiba, B., “Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words”, BCP 14, ~RFC8174, May 2017
[INFRA]
    <span lang="ja">（この訳による追加）</span>
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 

●●ref_informative

[IEEE754]
    IEEE, “IEEE Standard for Floating-Point Arithmetic”, IEEE 754-2019, July 2019, URL: https://ieeexplore.ieee.org/document/8766229
[RFC7231]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, ~RFC7231, June 2014
[RFC7493]
    Bray, T., Ed., “The I-JSON Message Format”, ~RFC7493, March 2015
[RFC7540]
    Belshe, M., Peon, R., and M. Thomson, Ed., “Hypertext Transfer Protocol Version 2 (HTTP/2)”, ~RFC7540, May 2015
[RFC7541]
    Peon, R. and H. Ruellan, “HPACK: Header Compression for HTTP/2”, ~RFC7541, May 2015
[RFC8259]
    Bray, T., Ed., “The JavaScript Object Notation (JSON) Data Interchange Format”, STD 90, ~RFC8259, December 2017
[UTF-8]
    Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, ~RFC3629, November 2003


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による Internet-Draft
<a href="~SPEC_URL">Structured Headers for HTTP</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

発行者
	HTTP Working Group
位置付け
	Internet-Draft
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	Mark Nottingham, Fastly <a href="mailto:mnot@mnot.net">mnot@mnot.net</a>, <a href="https://www.mnot.net/">https://www.mnot.net/</a>
	Poul-Henning Kamp, The Varnish Cache Project <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a>
HTTP working group mailing list
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
commit 履歴
	https://github.com/httpwg/http-extensions/commits/master
HTTP 拡張仕様の草案／ HTTP WG 情報
	https://httpwg.github.io/
ソースコード／課題リスト
	https://github.com/httpwg/http-extensions/labels/header-structure
実装テスト
	https://github.com/httpwg/structured-header-tests
実装追跡
	https://github.com/httpwg/wiki/wiki/Structured-Headers

</script>

</head>

<body>


<header>
	<hgroup>
<h1>HTTP 用の有構造ヘッダ — Structured Headers for HTTP</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="rfc.abstract">
~ABSTRACT
<p>
この文書は、一連の~data型, それらに結付けられる~algoを述べる。
それは、［
伝統的な~HTTP~header値より制約的な，共通な構文
］を利用したいと望む，新たな~HTTP~headerの仕様から利用するために、~HTTP~headerをより容易に定義して, より安全に取扱うために意図される。
◎
This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.
</p>

	</section>
	<section id="rfc.note.1">
<h2 title="Note to Readers">読者~向け注記</h2>

<p>
`この節は、発行~前に除去されることになる^em
【以下，この節の他の内容は、冒頭の仕様~metadataに移譲。】
◎
RFC EDITOR: please remove this section before publication
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>に委譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に委譲。
】</p>

<p lang="en-x-a0">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

	</section>

<main id="MAIN0">
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
新たな~HTTP~headerの構文を指定することは、骨の折れる~taskである。
`RFC7231$r には`新たな~headerに対する考慮点$sec【！`RFC7231/8.3.1$sec】による指導はあれど、将来有望な~HTTP~headerの作者にとって，多くの裁定
— および陥穽 —
がある。
◎
Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in Section 8.3.1 of [RFC7231], there are many decisions – and pitfalls – for a prospective HTTP header field author.
</p>

<p>
~headerを定義したなら、それ~~専用の［
構文解析器／直列化器
］も書く必要があることが多い
— 各~headerには、共通な構文にも見える様な少しばかり異なる取扱いがあるので。
◎
Once a header field is defined, bespoke parsers and serializers often need to be written, because each header has slightly different handling of what looks like common syntax.
</p>

<p>
これらの問題に取組むため，この文書は、新たな~HTTP~header値の定義における利用-用に一連の共通な~data構造を導入する。
特に，~header値~用の汎用かつ抽象的な~modelを
— その~modelを~HTTP~header `RFC7230$r にて表出するための具体的な直列化とともに —
定義する。
◎
This document introduces a set of common data structures for use in definitions of new HTTP header field values to address these problems. In particular, it defines a generic, abstract model for header field values, along with a concrete serialisation for expressing that model in HTTP [RFC7230] header fields.
</p>

<p>
“有構造~header”（
“`Structured Header^en” ／ “`structured header^en
）として定義される~HTTP~headerは、その構文と基本的な取扱い規則を，この仕様に定義される各種 型を利用して定義する
— それにより，仕様の書き手による定義, および実装による取扱いの両者を単純~化する。
◎
HTTP headers that are defined as “Structured Headers” use the types defined in this specification to define their syntax and basic handling rules, thereby simplifying both their definition by specification writers and handling by implementations.
</p>

<p>
加えて，~HTTPの将来~versionは、これらの構造の抽象-~modelの代替を成す直列化を定義し得る
— それを利用する~headerを定義し直すことなく，より効率的に伝送できるようにするため。
◎
Additionally, future versions of HTTP can define alternative serialisations of the abstract model of these structures, allowing headers that use it to be transmitted more efficiently without being redefined.
</p>

<p>
この文書の目標は、既存の~HTTP~headerの構文を定義し直すことではないことに注意。
ここに述べる仕組みは、明示的にそれを任意選択する~headerに限り，利用されることが意図される。
◎
Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.
</p>

<p>
有構造~headerを指定する方法は `2$sec に述べる。
◎
Section 2 describes how to specify a Structured Header.
</p>

<p>
`3$sec では、有構造~headerにて利用できる，抽象-~data型をいくつか定義する。
それらの抽象-型は、 `4$sec に述べる~algoを利用して，~HTTP~header［
へ直列化できる／から構文解析できる
］。
◎
Section 3 defines a number of abstract data types that can be used in Structured Headers. Those abstract types can be serialized into and parsed from HTTP headers using the algorithms described in Section 4.
</p>
		<section id="strict">
<h3 title="Intentionally Strict Processing">1.1. 意図的に厳密な処理</h3>

<p>
この仕様は、一連の段からなる~algoを利用して，構文解析と直列化の挙動を意図的に厳密に定義する
— ~errorの取扱いは、演算をまるごと失敗させる他には定義されない。
◎
This specification intentionally defines strict parsing and serialisation behaviours using step-by-step algorithms; the only error handling defined is to fail the operation altogether.
</p>

<p>
それは、忠実な実装を奨励して，良好な相互運用能を得るために設計されている。
したがって，入力に~~寛容であることにより “~~親切” であろうと試行する実装は、相互運用能を悪化させることになる
— そうすると、類似な（が、微妙に異なる見込みが高い）対処法を実装する他の実装に，しわ寄せが行くことになるので。
◎
It is designed to encourage faithful implementation and therefore good interoperability. Therefore, an implementation that tried to be “helpful” by being more tolerant of input would make interoperability worse, since that would create pressure on other implementations to implement similar (but likely subtly different) workarounds.
</p>

<p>
言い換えれば，厳密な処理は、この仕様の意図的な特能である
— それは、不適合tな入力を生産器が より早く発見して正せるようにして、さもなければ生じることになる［
相互運用能／~security
］の課題を避けれるようにする。
◎
In other words, strict processing is an intentional feature of this specification; it allows non-conformant input to be discovered and corrected by the producer early, and avoids both interoperability and security issues that might otherwise result.
</p>

<p>
この厳密さの結果として，ある~headerが複数の主体により付加される場合（例：`中継者$や`送信者$における異なる~component）、ある主体による値に~errorがあれば，当の~header全体の構文解析を失敗させると見込まれることに注意。
◎
Note that as a result of this strictness, if a header field is appended to by multiple parties (e.g., intermediaries, or different components in the sender), an error in one party’s value is likely to cause the entire header field to fail parsing.
</p>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.2. 表記上の規約</h3>

<p class="trans-note">【
この節の他の内容（ `RFC2119$r, `RFC8174$r ）は、
<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
この文書は、構文解析と直列化の挙動を指定する各種~algoを利用し、~HTTP~headerにおいて期待される構文を具体化するために `RFC5234$r による
<abbr title="Augmented Backus-Naur Form">~ABNF</abbr>記法を利用する。
また、
`RFC5234$r の［
`VCHAR$P, `SP$P, `DIGIT$P, `ALPHA$P, `DQUOTE$P
］規則, および
`RFC7230$r の `tchar$p 規則を利用する。
◎
This document uses algorithms to specify parsing and serialisation behaviours, and the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] to illustrate expected syntax in HTTP header fields. In doing so, uses the VCHAR, SP, DIGIT, ALPHA and DQUOTE rules from [RFC5234]. It also includes the tchar rule from [RFC7230].
</p>

<p>
~HTTP~headerから構文解析する実装は，~algoに従わなければナラナイが、指定された挙動と判別-不能である限り，どう実装されてもヨイ。
構文解析~algoと~ABNFの間に不一致がある場合、指定された~algoが優先される。
いくつかの箇所では，~algoは空白に関して “貪欲” であるが、これは適合性には影響しないはずである。
◎
When parsing from HTTP header fields, implementations MUST follow the algorithms, but MAY vary in implementation so as the behaviours are indistinguishable from specified behaviour. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence. In some places, the algorithms are “greedy” with whitespace, but this should not affect conformance.
</p>

<p>
~ABNFは、受容-可能な伝送路~表現が成す範囲を
— ~headerへの直列化~用に —
アリな限り忠実に具体化する。
各~algoは、そのような表現を生産するときに推奨される仕方を定義する。
~algoは、出力が~ABNFに合致する限り，どう実装されてもヨイ。
◎
For serialisation to header fields, the ABNF illustrates the range of acceptable wire representations with as much fidelity as possible, and the algorithms define the recommended way to produce them. Implementations MAY vary from the specified behaviour so long as the output still matches the ABNF.
</p>

		</section>
		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
~algoや定義を［
明確化する／精緻化する／簡潔に述べる
］ため、この訳では `INFRA$r に定義される各種用語, 表記法を取り入れている。
それに伴い、原文から大きく構成を違えている~algoもある。
</p>

<p>
この仕様に定義される，すべての抽象-~data型は、より汎用な~data型（例：`~list$）と区別するため， `<var>型~名</var> ^sh （例： `~list$sh ）の様に表記される（ <sup>sh</sup> は `Structured Header^en の略語）。
【！原文では，型名は "`List^en" の様に（一部は）大文字で／その~instanceは小文字で記されていたりもするが、日本語では表現できない。】
</p>

<p>
原文にて~HTTP仕様（ `RFC7230$r 他）を参照している用語には、その改訂-下にある仕様の和訳への~linkを付与している。
</p>


		</section>
	</section>
	<section id="specify">
<h2 title="Defining New Structured Headers">2. 新たな有構造~headerの定義-法</h2>

<p>
~HTTP~headerを有構造~headerとして指定するためには、作者は以下に従う必要がある：
◎
To specify a HTTP header as a structured header, its authors needs to:
</p>

<ul>
	<li>
この仕様を参照すること。
~headerの［
`受信者$／生成器
］は、この文書の要件が効果を及ぼすことを知る必要があるので。
◎
Reference this specification. Recipients and generators of the header need to know that the requirements of this document are in effect.
</li>
	<li>
<p>
~header値の型を［
`辞書$sh／`~list$sh／`~item$sh
］いずれかとして指定すること。
</p>

<p class="trans-note">【
`文字列$shなど他の型の値をとるかのよう指定する仕様もあるかもしれないが、それは，［
~header値の型は`~item$shであって，その値は`文字列$shに制約される
］ものと指定することの略記と見なされる。
】</p>

◎
Specify the type of the header field itself; either Dictionary (Section 3.2), List (Section 3.1), or Item (Section 3.3).
</li>
	<li>
~header値の構造の意味論を定義すること。
◎
Define the semantics of those structures.
</li>
	<li>
その構造が利用される際に追加的な拘束があれば、拘束に違反した場合の帰結とともに指定すること。
◎
Specify any additional constraints upon the structures used, as well as the consequences when those constraints are violated.
</li>
</ul>

<p>
すなわち，~header定義は、概して，~top-level型
— `辞書$sh／ `~list$sh／`~item$sh —
指定してから，それに許容-可能な型を定義して，それらを拘束することになる。
例えば，`~list$shとして定義された~headerは、それを成す各~memberに対し，すべて`整数$shとすることもあれば，何種かの型の混成とすることもあろう。
あるいは，`~item$shとして定義された~headerは、その値として，`文字列$sh, それも文字 `Q^ch から始まるものに限り許容することもあろう。
同様に， `内縁~list$shは、~header定義にて明示的に許容される場合に限り，妥当になる。
◎
Typically, this means that a header definition will specify the top-level type – Dictionary, List or Item – and then define its allowable types, and constraints upon them. For example, a header defined as a List might have all Integer members, or a mix of types; a header defined as an Item might allow only Strings, and additionally only strings beginning with the letter “Q”. Likewise, inner lists are only valid when a header definition explicitly allows them.
</p>

<p>
有構造~headerの構文解析に失敗したときは、~headerは無視される（ `4.2$sec を見よ）。
ほとんどの状況においては、~headerに特有な拘束に違反することも，同じ効果になるべきである。
したがって，`~item$shとして定義され，`整数$shをとることが要求された~headerに`文字列$shが受信された場合、既定では無視されることになる。
当の~headerに対し，異なる~errorの取扱いを要求する場合、明示的に指定するべきである。
◎
When Structured Headers parsing fails, the header is ignored (see Section 4.2); in most situations, violating header-specific constraints should have the same effect. Thus, if a header is defined as an Item and required to be an Integer, but a String is received, it will by default be ignored. If the header requires different error handling, this should be explicitly specified.
</p>

<p>
しかしながら，［
`~item$sh／`内縁~list$sh
］は、拡張能の仕組みとして，`~parameters$shを許容する。
これは、その値は もっと情報を収容するために必要なら，後で拡張され得ることを意味する。
それゆえ，~header仕様には、認識されない~parameterが在ることを~error条件として定義することは，忌避される。
◎
However, both items and inner lists allow parameters as an extensibility mechanism; this means that values can later be extended to accommodate more information, if need be. As a result, header specifications are discouraged from defining the presence of an unrecognised parameter as an error condition.
</p>

<p>
［
この拡張能が将来にも可用になるのを確約する一助
］になるよう，および［
消費器が有構造~header構文解析器の全~能力を備えることを奨励する
］ため、~header定義は［
送信者は “潤滑（ `grease^en ）” ~parameter†を追加する
］ものと指定できる。
例えば，仕様は、［
~~文字 `q^c から始まる~parameterは、すべて，この利用~用に予約される
］よう制定することもできる。
◎
To help assure that this extensibility is available in the future, and to encourage consumers to use a fully capable Structured Headers parser, a header definition can specify that “grease” parameters be added by senders. For example, a specification could stipulate that all parameters beginning with the letter ‘q’ are reserved for this use.
</p>

<p class="trans-note">【
~TLSの `GREASE^en と同様な発想による（
<a href="https://jovi0608.hatenablog.com/entry/2016/10/02/101233">参考</a>
）、［
不適合な実装を早期に発見して，技術的~負債を残さないようにする
］ための，［
~randomに選ばれ，未定義になる名前
］を持つ~parameterと見受けられる（
<a href="https://github.com/httpwg/http-extensions/issues/1015">課題 #1015</a>
に論点がある）。
~~文字 `q^c が挙げられているのは、 "q" から始まる英単語が珍しく，定義済みの名前と衝突し難いからのようだ。
】</p>

<p>
~header定義は、この仕様の要件を緩めることはできないことに注意
— そうすると，汎用~softwareによる取扱いを予め除外することになるので。
~header定義は、追加的な拘束に限り追加できる（例：
`整数$shや`~decimal$shの数量-範囲 ／
`文字列$shや`~token$shの形式／
`辞書$shを成す~memberの値に許容される型／
`~list$shを成す`~item$shの個数）。
同様に，~header定義が有構造~headerを利用できるのは、~header値の一部分ではなく，値~全体~用に限られる。
◎
Note that a header field definition cannot relax the requirements of this specification because doing so would preclude handling by generic software; they can only add additional constraints (for example, on the numeric range of integers and decimals, the format of strings and tokens, the types allowed in a dictionary’s values, or the number of items in a list). Likewise, header field definitions can only use Structured Headers for the entire header field value, not a portion thereof.
</p>

<p>
この仕様は、有構造~header実装により~supportされる様々な構造の長さや個数~用に最小を定義する。
ほとんどの事例では最大~sizeは指定しないが、~header作者は，［
~HTTP実装が［
個々の~headerの~size／
~headerの総数／
~header~block全体の~size
］に様々な制限を課す
］ことを自覚するべきである。
◎
This specification defines minimums for the length or number of various structures supported by Structured Headers implementations. It does not specify maximum sizes in most cases, but header authors should be aware that HTTP implementations do impose various limits on the size of individual header fields, the total number of fields, and/or the size of the entire header block.
</p>

<p>
仕様は、必要に応じて，有構造~headerの［
`field-name$p を指して
`有構造~header名@
／
`field-value$p を指して
`有構造~header値@
］と称せる。
~header定義には、［
この仕様に定義される `sh-^p
］で始まる~ABNF規則を利用することが奨励される。
この仕様における他の規則は、そのような利用-用には意図されていない。
◎
Specifications can refer to a Structured Header’s field-name as a “structured header name” and its field-value as a “structured header value” as necessary. Header definitions are encouraged to use the ABNF rules beginning with “sh-“ defined in this specification; other rules in this specification are not intended for their use.
</p>

<div class="example">

<p>
例えば，架空の `Foo-Example^h ~headerは、次のように指定されるかもしれない：
◎
For example, a fictitious Foo-Example header field might be specified as:
</p>

<div>

<div style="font-size:larger;">
42. `Foo-Example^h ~header
</div>

<p>
`Foo-Example^h ~HTTP~headerは、~messageが~Fooをどれだけ有するかについての情報を伝達する。
</p>

<p>
`Foo-Example^h は、`~item$shを値にとる有構造~headerである `RFCxxxx^r 。
値は`整数$shでなければナラナイ（ `RFCxxxx^r, § Y.Y ）。
その~ABNFは：
</p>

<pre class="ABNF">
Foo-Example = `sh-integer$p
</pre>

<p>
その値は、~message内にある~Fooの量を指示する。
値は 0 以上 10 以下でなければナラナイ
— 他の値に対しては、~header全体を無視しなければナラナイ。
</p>

<p>
`~parameters$shを成す~parameterとして次が定義される
— 下の処理~要件を見よ
⇒＃
名前は `fooUrl^l,
値は~message用の~Foo~URLを伝達している`文字列$shである（ `RFCxxxx^r, § Y.Y ）
</p>

<p>
~parameter `fooUrl^l は、 `URI-reference^p （ `RFC3986/4.1$sec ）を値にとる。
値が妥当な `URI-reference^p でない場合、その~URLは無視しなければナラナイ。
値が相対~参照（ `RFC3986/4.2$sec ）である場合、利用する前に解決しなければナラナイ（ `RFC3986/5$sec ）。
</p>

<p>
例えば：
</p>

<pre class="http-code">
Foo-Example: 2; foourl="https://foo.example.com/"
</pre>

<pre lang="en">
42. Foo-Example Header

The Foo-Example HTTP header field conveys information about how
much Foo the message has.

Foo-Example is a Item Structured Header [RFCxxxx]. Its value MUST be
an Integer (Section Y.Y of [RFCxxxx]). Its ABNF is:

  Foo-Example = sh-integer

Its value indicates the amount of Foo in the message, and MUST
be between 0 and 10, inclusive; other values MUST cause
the entire header to be ignored.

The following parameters are defined:
* A parameter whose name is "fooUrl", and whose value is a string
  (Section Y.Y of [RFCxxxx]), conveying the Foo URLs
  for the message. See below for processing requirements.

"fooUrl" contains a URI-reference (Section 4.1 of
[RFC3986], Section 4.1). If its value is not a valid URI-reference,
that URL MUST be ignored. If its value is a relative reference
(Section 4.2 of [RFC3986]), it MUST be resolved (Section 5 of
[RFC3986]) before being used.

For example:

  Foo-Example: 2; foourl="https://foo.example.com/"
</pre>
</div>

</div>

	</section>
	<section id="types">
<h2 title="Structured Data Types">3. 各種 有構造~data型</h2>

<p>
この節は、有構造~headerを構成し得る抽象的な値~型を定義する。
供される~ABNFは、~HTTP~headerにおける伝送路~上の形式を表現する。
◎
This section defines the abstract value types that can be composed into Structured Headers. The ABNF provided represents the on-wire format in HTTP headers.
</p>

<p>
要約すれば：
◎
In summary:
</p>

<ul>
	<li>
~HTTP~headerの値として定義し得る~top-level型には［
`~list$sh, `辞書$sh, `~item$sh
］の 3 種がある。
◎
There are three top-level types that a HTTP header can be defined as; Lists, Dictionaries, and Items.
</li>
	<li>
［
`~list$sh, `辞書$sh
］は容器であり、それらの各~memberは［
`~item$sh／`内縁~list$sh
］を値にとり得る（後者は それ自体が一連の`~item$shからなる~listである）。
◎
Lists and Dictionaries are containers; their members can be Items or Inner Lists (which are themselves lists of items).
</li>
	<li>
［
`~item$sh／`内縁~list$sh
］のどちらも、`~parameters$shを伴い得る。
◎
Both Items and Inner Lists can be parameterised with key/value pairs.
</li>
</ul>

		<section id="list">
<h3 title="Lists">3.1. `~list^sh</h3>

<p>
`~list@sh
（ `list^en ）は， 0 個以上の［
`~item$sh／`内縁~list$sh
］からなる`~list$である。
◎
Lists are arrays of zero or more members, each of which can be an item (Section 3.3) or an inner list (Section 3.1.1), both of which can be parameterised (Section 3.1.2).
</p>

<p>
~HTTP~headerにおける`~list$sh用の~ABNFは：
◎
The ABNF for lists in HTTP headers is:
</p>

<pre class="ABNF">
`sh-list@p
      = `list-member$p *( *`SP$P "," *`SP$P `list-member$p )
`list-member@p
      = `sh-item$p
      / `inner-list$p
</pre>

<p>
~HTTP~headerにおいては、各~memberは［
0 個以上の空白を伴う `,^ch
］で区切られる。
◎
In HTTP headers, each member is separated by a comma and optional whitespace.＼
</p>

<div class="example">
<p>
例えば，`文字列$shの~listを値にとるものと定義される~headerは、次の様な見かけになる：
◎
For example, a header field whose value is defined as a list of strings could look like:
</p>

<pre class="http-code">
Example-StrListHeader: "foo", "bar", "It was the best of times."
</pre>
</div>

<p>
~HTTP~headerにおいては、空な`~list$shは，~header全体を直列化しないことにより表される。
◎
In HTTP headers, an empty list is denoted by not serialising the header at all.
</p>

<p>
`~list$shを成す~memberたちは、~header~blockの内側にて複数の~instanceにまたがるように分割し得ることに注意
;
◎
Note that lists can have their members split across multiple instances inside a block of fields;＼
</p>

<div class="example">
<p>
例えば，次は：
◎
for example, the following are equivalent:
</p>

<pre class="http-code">
Example-Hdr: foo, bar
</pre>

<p>
次と等価になる：
◎
and
</p>

<pre class="http-code">
Example-Hdr: foo
Example-Hdr: bar
</pre>

</div>

<p>
しかしながら，`~list$shを成す個々の~memberは、複数の~instanceに安全に分割し得ない
— 詳細は`4.2$sec を見よ。
◎
However, members of a list cannot be safely split between instances; see Section 4.2 for details.
</p>

<p>
構文解析器は、`~list$shを成す~memberとして 1024 個までは~supportしなければナラナイ。
~header仕様は、個々の`~list$shを成す［
個々の~memberの型／~memberの個数
］を必要に応じて拘束し得る。
◎
Parsers MUST support lists containing at least 1024 members. Header specifications can constrain the types and cardinality of individual list values as they require.
</p>
			<section id="inner-list">
<h4 title="Inner Lists">3.1.1. `内縁~list^sh</h4>

<p>
`内縁~list@sh
（ `inner list^en ／ `inner-list^en 【 “~top-level構造でない~list” 】）は、
0 個以上の`~item$shからなる`~list$であって，`~parameters$shも伴い得るものである。
◎
An inner list is an array of zero or more items (Section 3.3). Both the individual items and the inner-list itself can be parameterised (Section 3.1.2).
</p>

<p class="trans-note">【
`内縁~list$shが~parameterを伴わないことと，その`~parameters$shは空であることは同義になる。
すなわち，構造としては、
( `~list$, `~parameters$sh )
が成す`~tuple$と見做せる。
】</p>

<p>
~HTTP~headerにおける`内縁~list$sh用の~ABNFは：
◎
The ABNF for inner-lists in HTTP headers is:
</p>

<pre class="ABNF">
`inner-list@p
      = "(" *`SP$P [ `sh-item$p *( 1*`SP$P `sh-item$p ) *`SP$P ] ")" *`parameter$p
</pre>

<p>
~HTTP~headerにおいては、`内縁~list$shは，各`~item$shどうしを 1 個の ` ^ch で区切った上で【`~parameters$shを除く】全体を丸括弧で括って表される。
◎
In HTTP headers, inner lists are denoted by surrounding parenthesis, and have their values delimited by a single space.＼
</p>

<div class="example">
<p>
一連の［
一連の`文字列$shからなる`内縁~list$sh
］からなる`~list$shを値にとるように定義された~headerは、次の様な見かけになる：
◎
A header field whose value is defined as a list of inner-lists of strings could look like:
</p>

<pre class="http-code">
Example-StrListListHeader: ("foo" "bar"), ("baz"), ("bat" "one"), ()
</pre>

<p>
この例における最後の~member（ `()^c ）は、空な`内縁~list^shを表すことに注意。
◎
Note that the last member in this example is an empty inner list.
</p>

<p>
`~list$shを成す［
`内縁~list$sh, および それを成すある`~item$sh
］どちらも`~parameters$shを伴うように定義された~headerは、次の様な見かけになる：
◎
A header field whose value is defined as a list of inner-lists with parameters at both levels could look like:
</p>

<pre class="http-code">
Example-ListListParam: ("foo"; a=1;b=2);lvl=5, ("bar" "baz");lvl=1
</pre>
</div>

<p>
構文解析器は、`内縁~list$shを成す`~item$として 256 個までは~supportしなければナラナイ。
~headerの仕様は、`内縁~list$shを成す［
個々の~memberの型／~memberの個数
］を必要に応じて拘束し得る。
◎
Parsers MUST support inner-lists containing at least 256 members. Header specifications can constrain the types and cardinality of individual inner-list members as they require.
</p>

			</section>
			<section id="param">
<h4 title="Parameters">3.1.2. `~parameters^sh</h4>

<div class="p">
<p>
`~parameters@sh
（ `parameters^en ）は、［
`~item$sh ／ `内縁~list$sh
］に結付けられる`有順序~map$であり，それを成す各`~entry$mapの：
</p>

<ul>
	<li>
`~key$mapは、この~mapの視野の中で一意な名前を成す`~key$shを与える。
</li>
	<li>
`値$mapは，`裸~item$shを与える
</li>
</ul>
◎
Parameters are an ordered map of key-values pairs that are associated with an item (Section 3.3) or inner-list (Section 3.1.1). The keys are unique within the scope of a map of parameters, and the values are bare items (i.e., they themselves cannot be parameterised; see Section 3.3).
</div>

<p>
~HTTP~headerにおける`~parameters$shを成す各~parameter用の~ABNFは：
◎
The ABNF for parameters in HTTP headers is:
</p>

<pre class="ABNF">
`parameter@p
      = ";" *`SP$P `param-name$p [ "=" `param-value$p ]
`param-name@p
      = `key$p
`key@p
      = `lcalpha$p *( `lcalpha$p / `DIGIT$P / "_" / "-" / "." / "*" )
`lcalpha@p
      = `61-7A^X ; a-z 【`~ASCII英小文字$】
`param-value@p
      = `bare-item$p
</pre>

<p class="trans-note">【
~HTTP~headerにおいては、同じ `param-name$p が複数回~現れても許容され，最後に現れるものが他を上書きする（`~parametersを構文解析する$secを見よ）。
】</p>

<p>
~HTTP~headerにおいては、`~parameters$shを成す各~parameterは， `;^ch を接頭することにより他と区切られる。
◎
In HTTP headers, parameters are separated from their item or inner-list and each other by semicolons.＼
</p>

<div class="example">
<p>
例えば【 `abc;…,^c は`~item$sh ／ `(ghi;jk=4 l)…^c は`内縁~list$sh 】：
◎
For example:
</p>

<pre class="http-code">
Example-ParamListHeader: abc;a=1;b=2; cde_456, (ghi;jk=4 l);q="9";r=w
</pre>
</div>

<p>
`真偽値$sh ~T を値にとる~parameterを直列化するときには、その値は省略しなければナラナイ。
◎
Parameters whose value is Boolean true MUST omit that value when serialised.＼
</p>

<div class="example">
<p>
例えば【~parameter `a^c, `b^c は`真偽値^shを値にとる】：
◎
For example:
</p>

<pre class="http-code">
Example-IntHeader: 1; a; b=?0
</pre>
</div>

<p>
この要件は、直列化に限られることに注意。
構文解析器には、`~parameters$sh内に ~T 値が出現しても正しく取扱うことが，依然として要求される。
◎
Note that this requirement is only on serialisation; parsers are still required to correctly handle the true value when it appears in parameters.
</p>

<p>
構文解析器は、［
`~item$sh／`内縁~list$sh
］の`~parameters$shを成す`~entry$mapとして 256 個までは~supportしなければナラナイ。
【！§ ~key それらの各~entryの~keyを成す文字として 64 個までは~supportしなければナラナイ。】
~header仕様は、`~parameters$shを成す［
個々の~parameterの名前／
個々の~parameterの値の型／
~parameterの個数
］を必要に応じて拘束し得る。
◎
Parsers MUST support at least 256 parameters on an item or inner-list, and support parameter keys with at least 64 characters. Header specifications can constrain the types and cardinality of individual parameter names and values as they require.
</p>

				<section id="_key">
<h4>3.1.2.1. `~key^sh</h4>

<p class="trans-note">【
この節は、他所を集約するための，この訳による追加。
】</p>

<p>
`~key@sh
は、［
`~parameters$sh／`辞書$sh
］を成す各`~entry$mapの`~key$mapを与える。
それは、次を満たす文字列である：
</p>

<ul>
	<li>
1 個以上の，次に挙げる
`~key文字@
のみからなる
⇒＃
`~ASCII英小文字$,
`~ASCII数字$,
`_^ch,
`-^ch,
`.^ch,
`*^ch
</li>
	<li>
最初の文字は`~ASCII英小文字$に制約される。
</li>
</ul>

<p>
~HTTP~headerにおける`~key$sh用の~ABNFは、 `key$p である。
</p>

<p>
構文解析器は、`~key$shを成す文字として 64 個までは~supportしなければナラナイ。
</p>

				</section>
			</section>
		</section>
		<section id="dictionary">
<h3 title="Dictionaries">3.2. `辞書^sh</h3>

<div class="p">
<p>
`辞書@sh
（ `dictionary^en ）は、`有順序~map$であり，それを成す各`~entry$mapの：
</p>
<ul>
	<li>
`~key$mapは、この~mapの視野の中で一意な，短い~textな名前を成す`~key$shを与える。
</li>
	<li>
`値$mapは、［
`~item$sh／`内縁~list$sh
］を与える。
</li>
</ul>
◎
Dictionaries are ordered maps of name-value pairs, where the names are short, textual strings and the values are items (Section 3.3) or arrays of items, both of which can be parameterised (Section 3.1.2). There can be zero or more members, and their names are unique in the scope of the dictionary they occur within.
</div>

<p>
実装は、`辞書$shへの［
~indexによる~access, 名前による~access
］両者を供さなければナラナイ。
仕様は、~memberに~accessする手段にどちらを利用してもヨイ。
◎
Implementations MUST provide access to dictionaries both by index and by name. Specifications MAY use either means of accessing the members.
</p>

<p>
~HTTP~headerにおける`辞書$sh用の~ABNFは：
◎
The ABNF for dictionaries in HTTP headers is:
</p>

<pre class="ABNF">
`sh-dictionary@p
      = `dict-member$p *( *`SP$P "," *`SP$P `dict-member$p )
`dict-member@p
      = `member-name$p [ "=" `member-value$p ]
`member-name@p
      = `key$p
`member-value@p
      = `sh-item$p
      / `inner-list$p
</pre>

<p class="trans-note">【
~HTTP~headerにおいては、同じ `dict-name$p が複数回~現れても許容され，最後に現れるものが他を上書きする（`辞書を構文解析する$secを見よ）。
】</p>

<p>
~HTTP~headerにおいては、各~memberは［
0 個以上の空白を伴う `,^ch
］で区切られる一方で，その名前と値は［
空白は伴わない `=^ch
］で区切られる。
◎
In HTTP headers, members are separated by a comma with optional whitespace, while names and values are separated by “=” (without whitespace).＼
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="http-code">
Example-DictHeader: en="Applepie", da=:w4ZibGV0w6ZydGU=:
</pre>
</div>

<p>
~memberのうち`真偽値$sh ~T を値にとる`~item$shは、`~parameters$shが空である場合には，直列化するときには 値を省略しなければナラナイ。
◎
Members whose value is Boolean true MUST omit that value when serialised, unless it has parameters.＼
</p>

<div class="example">
<p>
次の例の~member［
`b^c, `c^c
］の値は、どちらも ~T を値にとる`~item$shであるが，
`c^c は`~parameters$shを伴うので直列化される：
◎
For example, here both “b” and “c” are true, but “c”’s value is serialised because it has parameters:
</p>

<pre class="http-code">
Example-DictHeader: a=?0, b, c=?1; foo=bar
</pre>
</div>

<p>
この要件は、直列化に限られることに注意。
構文解析器には、`辞書$shを成す各~memberに出現する ~T 値を正しく取扱うことが依然として要求される。
◎
Note that this requirement is only on serialisation; parsers are still required to correctly handle the true value when it appears in dictionary values.
</p>

<div class="example">
<p>
一連の`~token$shからなる`内縁~list$shを値にとる~memberを伴う`辞書$sh：
◎
A dictionary with a member whose value is an inner-list of tokens:
</p>

<pre class="http-code">
Example-DictListHeader: rating=1.5, feelings=(joy sadness)
</pre>

<p>
各~memberの値として［
`~item$sh, `内縁~list$sh
］が混在する`辞書$shの例
— うちいくつか（ `c^c, `d^c ）は`~parameters$shも伴う:
◎
A dictionary with a mix of singular and list values, some with parameters:
</p>

<pre class="http-code">
Example-MixDict: a=(1 2), b=3, c=4;aa=bb, d=(5 6);valid=?1
</pre>
</div>

<p>
`~list$shと同じく，空な`辞書$shは、~HTTP~headerにおいては，~header全体を省略することにより表現される。
◎
As with lists, an empty dictionary is represented in HTTP headers by omitting the entire header field.
</p>

<p>
~header仕様は、`辞書$shの意味論を，概して［
個々の~member名に対し，［
値に許容される型（たち）,
~memberの省略可否
］を指定する
］ことにより定義することになる。
`受信者$は、［
未定義／未知
］な名前を
— ~headerの仕様が特定的にそれを許容しないものとしている場合を除き —
無視しなければナラナイ。
◎
Typically, a header field specification will define the semantics of dictionaries by specifying the allowed type(s) for individual member names, as well as whether their presence is required or optional. Recipients MUST ignore names that are undefined or unknown, unless the header field’s specification specifically disallows them.
</p>

<p>
`辞書$shを成す~memberたちは、~header~blockの内側にて複数の~instanceにまたがるように分割し得ることに注意。
◎
Note that dictionaries can have their members split across multiple instances inside a block of fields;＼
</p>

<div class="example">
<p>
例えば，次は：
◎
for example, the following are equivalent:
</p>

<pre class="http-code">
Example-Hdr: foo=1, bar=2
</pre>

<p>
次と等価になる：
◎
and
</p>

<pre class="http-code">
Example-Hdr: foo=1
Example-Hdr: bar=2
</pre>
</div>

<p>
しかしながら，`辞書$shを成す個々の~member【の値】は、複数の~instanceに安全に分割し得ない。
詳細は`4.2$sec を見よ。
◎
However, members of a dictionary cannot be safely split between instances; see Section 4.2 for details.
</p>

<p>
構文解析器は、`辞書$shを成す~memberとして 1024 個までは~supportしなければナラナイ。
【！§ ~key 構文解析器は、`辞書$shを成す~memberの名前を成す文字として 64 個までは~supportしなければナラナイ。】
◎
Parsers MUST support dictionaries containing at least 1024 name/value pairs, and names with at least 64 characters.
</p>

		</section>
		<section id="item">
<h3 title="Items">3.3. `~item^sh</h3>

<div>
<p>
`~item@sh
（ `item^en ）は、【単に “~itemの値” とも称される】`裸~item$shを値にとり，`~parameters$shも伴い得るものである。
</p>

<p class="trans-note">【
`内縁~list$shと同様に、`~item$shが~parameterを伴わないことと，その`~parameters$shは空であることは同義になる。
すなわち，構造としては、
( 値, `~parameters$sh )
が成す`~tuple$と見做せる。
】</p>

<p>
`裸~item@sh
（ `bare item^en ）は、次に挙げる いずれかの型として排他的に識別される値である
⇒＃
`整数$sh,
`~decimal$sh,
`文字列$sh,
`~token$sh,
`~byte列$sh,
`真偽値$sh
</p>

◎
An item can be a integer (Section 3.3.1), decimal (Section 3.3.2), string (Section 3.3.3), token (Section 3.3.4), byte sequence (Section 3.3.5), or Boolean (Section 3.3.6). It can have associated parameters (Section 3.1.2).
</div>

<p class="trans-note">【
例えば［
`文字列$sh, `~token$sh
］とも文字列であるが、実装は，型に応じて別々に扱えるよう型~情報を保持する必要がある。
】</p>

<p>
~HTTP~headerにおける`~item$sh用の~ABNFは：
◎
The ABNF for items in HTTP headers is:
</p>

<pre class="ABNF">
`sh-item@p
      = `bare-item$p *`parameter$p
`bare-item@p
      = `sh-integer$p
      / `sh-decimal$p
      / `sh-string$p
      / `sh-token$p
      / `sh-binary$p
      / `sh-boolean$p
</pre>

<div class="example">
<p>
例えば，`整数$shを値にとるものと定義される~headerは、次の様な見かけになる:
◎
For example, a header field that is defined to be an Item that is an integer might look like:
</p>

<pre class="http-code">
Example-IntItemHeader: 5
</pre>

<p>
あるいは，`~parameters$shを伴う場合は：
◎
or with parameters:
</p>

<pre class="http-code">
Example-IntItemHeader: 5; foo=bar
</pre>
</div>

			<section id="integer">
<h4 title="Integers">3.3.1. `整数^sh</h4>

<p>
`整数@sh
（ `integer^en ）は、
`IEEE754$r との互換性を得るため†，
範囲 { −999999999999999 〜 999999999999999 } に入る整数とする（すなわち， 15 桁まで, 有符号）。
【† すなわち、実装が整数を double 型の値として保持する場合に，文字列との相互変換が往来することを確保するため。】
◎
Integers have a range of −999,999,999,999,999 to 999,999,999,999,999 inclusive (i.e., up to fifteen digits, signed), for IEEE 754 compatibility ([IEEE754]).
</p>

<p>
~HTTP~headerにおける`整数$sh用の~ABNFは：
◎
The ABNF for integers in HTTP headers is:
</p>

<pre class="ABNF">
`sh-integer@p
      = ["-"] 1*15`DIGIT$P
</pre>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="http-code">
Example-IntegerHeader: 42
</pre>
</div>

<p>
◎
（和訳には不要な内容なので省略）
Note that commas in integers are used in this section’s prose only for readability; they are not valid in the wire format.
</p>

			</section>
			<section id="decimal">
<h4 title="Decimals">3.3.2. `~decimal^sh</h4>

<p>
`~decimal@sh
（ `decimal^en ）は、
( 整数~成分, 小数~成分 )
からなる。
整数~成分は範囲 { −999999999999 〜 999999999999 } に入る整数（すなわち， 12 桁まで, 有符号）,
小数~成分は範囲 { 0 〜 999 } に入る整数とする（すなわち， 3 桁まで, 無符号）。
それは、整数~成分と同じ正負, かつ絶対値が次に等しい実数【固定小数点数】を表現する
⇒
整数~成分の絶対値 ~PLUS ( 小数~成分 ~DIV 1000 )
◎
Decimals are numbers with an integer and a fractional component. The Integer component has at most 12 digits; the fractional component has at most three digits.
</p>

<p>
~HTTP~headerにおける`~decimal$sh用の~ABNFは：
◎
The ABNF for decimals in HTTP headers is:
</p>

<pre class="ABNF">
`sh-decimal@p
      = ["-"] 1*12`DIGIT$P "." 1*3`DIGIT$P
</pre>

<div class="example">
<p>
例えば，`~decimal$shを値にとるように定義される~headerは、次の様な見かけになる：
◎
For example, a header whose value is defined as a decimal could look like:
</p>

<pre class="http-code">
Example-DecimalHeader: 4.5
</pre>
</div>

			</section>
			<section id="string">
<h4 title="Strings">3.3.3. `文字列^sh</h4>

<p>
`文字列@sh
（ `string^en ）は、 0 個以上の［
`制御~文字$以外の`~ASCII文字$【！`RFC0020$r】（すなわち， ` ^ch 〜 `~^ch ）
］からなる。
これは、 `HTAB^P, `LF^P, `CR^P, 等々を除外することに注意。
◎
Strings are zero or more printable ASCII [RFC0020] characters (i.e., the range %x20 to %x7E). Note that this excludes tabs, newlines, carriage returns, etc.
</p>

<p>
~HTTP~headerにおける`文字列$sh用の~ABNFは：
◎
The ABNF for strings in HTTP headers is:
</p>

<pre class="ABNF">
`sh-string@p
      = `DQUOTE$P *(`chr$p) `DQUOTE$P
`chr@p
      = `unescaped$p
      / `escaped$p
`unescaped@p
      = `20-21^X
      / `23-5B^X
      / `5D-7E^X
`escaped@p
      = "\" ( `DQUOTE$P / "\" )
</pre>

<p>
~HTTP~headerにおいては、`文字列$shは二重引用符 `"^ch （ `DQUOTE$P ）で区切られ，［
`"^ch ／ `\^ch
］は `\^ch を利用して~escapeされる。
◎
In HTTP headers, strings are delimited with double quotes, using a backslash (“\”) to escape double quotes and backslashes.＼
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="http-code">
Example-StringHeader: "hello world"
</pre>
</div>

<p>
`文字列$shが区切子として利用するのは `"^ch に限られる
— 一重引用符 `'^ch は`文字列$shを区切らないことに注意。
更には、~escapeできる文字は［
`"^ch ／ `\^ch
］に限られる
— `\^ch の直後にある他の文字は、構文解析を失敗させなければナラナイ。
◎
Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings. Furthermore, only DQUOTE and “\” can be escaped; other characters after “\” MUST cause parsing to fail.
</p>

<p>
`文字列$shにおいては、~Unicodeは直に~supportされない
— それは、相互運用能の課題をいくつかもたらすのと，~header値に それが要求されるのは少数の例外に限られるので。
◎
Unicode is not directly supported in strings, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.
</p>

<p>
~header値が~ASCIIでない内容を伝達することが必要とされる場合、`~byte列$shを その文字~符号化法（ `UTF-8$r が好ましい）とともに指定するベキである。
◎
When it is necessary for a field value to convey non-ASCII content, a byte sequence (Section 3.3.5) SHOULD be specified, along with a character encoding (preferably [UTF-8]).
</p>

<p>
構文解析器は、`文字列$shを成す文字として 1024 個までは~supportしなければナラナイ。
◎
Parsers MUST support strings with at least 1024 characters.
</p>

			</section>
			<section id="token">
<h4 title="Tokens">3.3.4. `~token^sh</h4>

<div class="p">
<p>
`~token@sh
（ `token^en ）は、次を満たす文字列である：
</p>

<ul>
	<li>
1 個以上の，次に挙げる
`~token文字@
のみからなる
⇒＃
`tchar$p に許容される~octetに等価な各~文字,
`:^ch,
`/^ch
</li>
	<li>
最初の文字は［
`~ASCII英字$ ／ `*^ch
］に制約される。
</li>
</ul>

<p>
`~token$shは、短い~textな単語であり，その抽象-~modelは~HTTP~headerの直列化における表出に一致する。
</p>

◎
Tokens are short textual words; their abstract model is identical to their expression in the HTTP header serialisation.
</div>

<p>
~HTTP~headerにおける`~token$sh用の~ABNFは：
◎
The ABNF for tokens in HTTP headers is:
</p>

<pre class="ABNF">
`sh-token@p
      = ( `ALPHA$P / "\*" ) *( `tchar$p / ":" / "/" )
</pre>

<p>
構文解析器は、`~token$shを成す文字として 512 個までは~supportしなければナラナイ。
◎
Parsers MUST support tokens with at least 512 characters.
</p>

<p>
有構造~headerの`~token$shは、［
`RFC7230$r に定義される `token$p ~ABNF規則
］を成す文字を許容するが、次の点で相違することに注意
⇒＃
最初の文字は、`~ASCII英字$か `*^ch にすることが要求される／
後続の各~文字には、 `:^ch, `/^ch も許容される
◎
Note that a Structured Header token allows the characters as the “token” ABNF rule defined in [RFC7230], with the exceptions that the first character is required to be either ALPHA or “*”, and “:” and “/” are also allowed in subsequent characters.
</p>

			</section>
			<section id="binary">
<h4 title="Byte Sequences">3.3.5. `~byte列^sh</h4>

<p>
`~byte列@sh
（ `byte sequence^en ）は、`~byte列$であり，有構造~header内に伝達できる。
◎
Byte sequences can be conveyed in Structured Headers.
</p>

<p>
~HTTP~headerにおける`~byte列$sh用の~ABNFは：
◎
The ABNF for a byte sequence in HTTP headers is:
</p>

<pre class="ABNF">
`sh-binary@p
      = ":" *(`base64$p) ":"
`base64@p
      = `ALPHA$P
      / `DIGIT$P
      / "+"
      / "/"
      / "="
</pre>

<p>
~HTTP~headerにおいては、`~byte列$shは， `base64$p を利用して符号化された上で（ `RFC4648/4$sec ），
`:^ch で括られる。
◎
In HTTP headers, a byte sequence is delimited with colons and encoded using base64 ([RFC4648], Section 4).＼
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="http-code">
Example-BinaryHdr: :cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==:
</pre>
</div>

<p>
構文解析器は、復号-後における`~byte列$shを成す~octetとして，16384 【 ~EQ 1024 × 16 】個までは~supportしなければナラナイ。
◎
Parsers MUST support byte sequences with at least 16384 octets after decoding.
</p>

			</section>
			<section id="boolean">
<h4 title="Booleans">3.3.6. `真偽値^sh</h4>

<p>
`真偽値@sh
（ `boolean^en ）は、［
~T, ~F
］いずれかを値にとり，有構造~header内に伝達できる。
◎
Boolean values can be conveyed in Structured Headers.
</p>

<p>
~HTTP~headerにおける`真偽値$sh用の~ABNFは：
◎
The ABNF for a Boolean in HTTP headers is:
</p>

<pre class="ABNF">
`sh-boolean@p
      = "?" `boolean$p
`boolean@p
      = "0"
      / "1"
</pre>

<p>
~HTTP~headerにおいては、`真偽値$shは［
~T 値を表す `?1^l ／
~F 値を表す `?0^l
］で指示される。
◎
In HTTP headers, a boolean is indicated with a leading “?” character followed by a “1” for a true value or “0” for false.＼
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="http-code">
Example-BoolHdr: ?1
</pre>
</div>

			</section>
		</section>
	</section>
	<section id="text">
<h2 title="Working With Structured Headers in HTTP Headers">4. ~HTTP~header内の有構造~headerに対する作業-法</h2>

<p>
この節は、~header内の有構造~headerを［
直列化する／構文解析する
］方法, および
それらと互換な~protocolを定義する
（例： ~HPACK `RFC7541$r が適用される前の ~HTTP/2 `RFC7540$r における）。
◎
This section defines how to serialize and parse Structured Headers in header fields, and protocols compatible with them (e.g., in HTTP/2 [RFC7540] before HPACK [RFC7541] is applied).
</p>

		<section id="text-serialize">
<h3 title="Serializing Structured Headers">4.1. 有構造~headerの直列化-法</h3>

<p>
所与の
（ %構造 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す。
◎
Given a structure defined in this specification, return an ASCII string suitable for use in a HTTP header value.
</p>

<ol>
	<li>
~IF［
%構造 は［
`辞書$sh ／ `~list$sh
］である
］~AND［
%構造 は空である
］
⇒
~RET
— 当の~headerは直列化しない（すなわち， `field-name$p, `field-value$p 両者とも省略する）
◎
If the structure is a Dictionary or List and its value is empty (i.e., it has no members), do not serialize the field at all (i.e., omit both the field-name and field-value).
</li>
	<li>
%出力~文字列 ~LET %構造 に応じて
⇒＃
`辞書$shであるならば `辞書を直列化する$( %構造 ) ／
`~list$shであるならば `~listを直列化する$( %構造 ) ／
`~item$shであるならば `~itemを直列化する$( %構造 )／
~ELSE_ 直列化を失敗させる
◎
If the structure is a Dictionary, let output_string be the result of running Serializing a Dictionary (Section 4.1.2) with the structure.
◎
Else if the structure is a List, let output_string be the result of running Serializing a List (Section 4.1.1) with the structure.
◎
Else if the structure is an Item, let output_string be the result of running Serializing an Item (Section 4.1.3) with the structure.
◎
Else, fail serialisation.
</li>
	<li>
~RET `~ASCII符号化する$( %出力~文字列 )
【！ `RFC0020$r を利用して， を~byte列に変換した結果】
◎
Return output_string converted into an array of bytes, using ASCII encoding [RFC0020].
</li>
</ol>

<p>
以下に与える各種 直列化~algoにおいて，［
ある引数が それに付与される型に（とり得る値の範囲も含め）合致しない場合 ／
どこかで ~Assert に違反した場合
］には、直列化は全体が失敗したものと見なされる。
【この段落は、以下を簡潔に述べるための，この訳による追加的な規約（明快にするため，論理的に重複している表明もあるので、実装は，それらのうち不要な検査を省ける）。】
</p>

			<section id="ser-list">
<h4 title="Serializing a List">4.1.1. `~list^shの直列化-法</h4>

<p>
所与の
( `~list$sh %入力~list )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an array of (member_value, parameters) tuples as input_list, return an ASCII string suitable for use in a HTTP header value.
</p>
<ol>
	<li>
%出力~list ~LET 新たな`~list$
◎
Let output be an empty string.
</li>
	<li>
%入力~list を成す
~EACH( %~member )
に対し：
⇒
%出力~list に次の結果を`付加する$
⇒
%~member に応じて
⇒＃
`内縁~list$shであるならば `内縁~listを直列化する$( %~member ) ／
~ELSE_ `~itemを直列化する$( %~member )
◎
For each (member_value, parameters) of input_list:
• If member_value is an array, append the result of running Serialising an Inner List (Section 4.1.1.1) with (member_value, parameters) to output.
• Otherwise, append the result of running Serializing an Item (Section 4.1.3) with (member_value, parameters) to output.
</li>
	<li>
~RET %出力~list を［
`,^ch, ` ^ch
］並びで`連結する$
◎
• If more member_values remain in input_list:
•• Append a COMMA to output.
•• Append a single SP to output.
◎
Return output.
</li>
</ol>

				<section id="ser-innerlist">
<h5 title="Serialising an Inner List">4.1.1.1. `内縁~list^shの直列化-法</h5>

<p>
所与の
( `内縁~list$sh %内縁~list )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す。
◎
Given an array of (member_value, parameters) tuples as inner_list, and parameters as list_parameters, return an ASCII string suitable for use in a HTTP header value.
</p>
<ol>
	<li>
%出力~item~list ~LET 新たな`~list$
◎
↓</li>
	<li>
%内縁~list を成す
~EACH( %~member )
に対し
⇒
%出力~item~list に次の結果を`付加する$
⇒
`~itemを直列化する$( %~member )
◎
Let output be the string “(“.
◎
For each (member_value, parameters) of inner_list:
• Append the result of running Serializing an Item (Section 4.1.3) with (member_value, parameters) to output.
• If more values remain in inner_list, append a single SP to output.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`(^ch,
%出力~item~list を ` ^ch で`連結する$,
`)^ch,
`~parametersを直列化する$( %内縁~list の`~parameters$sh )
◎
↑
◎
Append “)” to output.
◎
Append the result of running Serializing Parameters Section 4.1.1.2 with list_parameters to output.
◎
Return output.
</li>
</ol>
				</section>
				<section id="ser-params">
<h5 title="Serializing Parameters">4.1.1.2. `~parameters^shの直列化-法</h5>

<p>
所与の
( `~parameters$sh %入力~parameters )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an ordered dictionary as input_parameters (each member having a param_name and a param_value), return an ASCII string suitable for use in a HTTP header value.
</p>
<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be an empty string.
</li>
	<li>
<p>
%入力~parameters を成す
~EACH( %~parameter名 → %~parameter値 )
に対し：
◎
For each parameter-name with a value of param_value in input_parameters:
</p>
		<ol>
			<li>
%出力 に `;^ch を付加する
◎
Append “;” to output.
</li>
			<li>
%出力 に次の結果を付加する
⇒
`~keyを直列化する$( %~parameter名 )
◎
Append the result of running Serializing a Key (Section 4.1.1.3) with param_name to output.
</li>
			<li>
~IF［
%~parameter値 は`真偽値$shである
］~AND［
%~parameter値 ~EQ ~F
］
⇒
~CONTINUE
◎
If param_value is not Boolean true:
</li>
			<li>
%出力 に `=^ch を付加する
◎
Append “=” to output.
</li>
			<li>
%出力 に次の結果を付加する
⇒
`裸~itemを直列化する$( %~parameter値 )
◎
Append the result of running Serializing a bare Item (Section 4.1.3.1) with param_value to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
				</section>
				<section id="ser-key">
<h5 title="Serializing a Key">4.1.1.3. ~keyの直列化-法</h5>

<p>
所与の
( `~key$sh %入力~key )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a key as input_key, return an ASCII string suitable for use in a HTTP header value.
• If input_key is not a sequence of characters, or contains characters not in lcalpha, DIGIT, “_”, “-“, “.”, or “*” fail serialisation.
• If the first character of input_key is not lcalpha, fail parsing.
</p>

<ol>
	<li>
~RET %入力~key
◎
Let output be an empty string.
◎
Append input_key to output.
◎
Return output.
</li>
</ol>

				</section>
			</section>
			<section id="ser-dictionary">
<h4 title="Serializing a Dictionary">4.1.2. `辞書^shの直列化-法</h4>

<p>
所与の
( `辞書$sh %入力~辞書 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an ordered dictionary as input_dictionary (each member having a member_name and a tuple value of (member_value, parameters)), return an ASCII string suitable for use in a HTTP header value.
</p>
<ol>
	<li>
%出力~list ~LET 新たな`~list$
◎
Let output be an empty string.
</li>
	<li>
<p>
%入力~辞書 を成す
~EACH( %~member名 → %~member値 )
に対し：
</p>
		<ol>
			<li>
%出力 ~LET `~keyを直列化する$( %~member名 )
</li>
			<li>
~IF［
%~member値 は
( `真偽値$sh ~T, 空な`~parameters$sh )
からなる`~item$shである
⇒＃
%出力~list に %出力 を`付加する$
~CONTINUE
</li>
			<li>
%出力~値 ~LET %~member値 に応じて
⇒＃
`内縁~list$shであるならば `内縁~listを直列化する$( %~member値 ) ／
~ELSE_ `~itemを直列化する$( %~member値 )
</li>
			<li>
%出力 に次を順に付加する
⇒＃
`=^ch,
%出力~値
</li>
			<li>
%出力~list に %出力 を`付加する$
</li>
		</ol>

【！原文は入れ子がおかしい】
◎
For each member_name with a value of (member_value, parameters) in input_dictionary:
• Append the result of running Serializing a Key (Section 4.1.1.3) with member’s member_name to output.
• If member_value is not Boolean true or parameters is not empty:
•• Append “=” to output.
• If member_value is an array, append the result of running Serialising an Inner List (Section 4.1.1.1) with (member_value, parameters) to output.
• Otherwise, append the result of running Serializing an Item (Section 4.1.3) with (member_value, parameters) to output.
• If more members remain in input_dictionary:
•• Append a COMMA to output.
•• Append a single SP to output.
</li>
	<li>
~RET %出力~list を［
`,^ch, ` ^ch
］並びで`連結する$
◎
↑
◎
Return output.
</li>
</ol>
			</section>
			<section id="ser-item">
<h4 title="Serializing an Item">4.1.3. `~item^shの直列化-法</h4>

<p>
所与の
( `~item$sh %~item )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an item bare_item and parameters item_parameters as input, return an ASCII string suitable for use in a HTTP header value.
</p>
<ol>
	<li>
~RET 次を順に連結した結果
⇒＃
`裸~itemを直列化する$( %~item の値 ),
`~parametersを直列化する$( %~item の`~parameters$sh )
◎
Let output be an empty string.
◎
Append the result of running Serializing a Bare Item Section 4.1.3.1 with bare_item to output.
◎
Append the result of running Serializing Parameters Section 4.1.1.2 with item_parameters to output.
◎
Return output.
</li>
</ol>

				<section id="ser-bare-item">
<h5 title="Serialising a Bare Item">4.1.3.1. `裸~item^shの直列化-法</h5>

<p>
所与の
( `裸~item$sh %入力~item )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an item as input_item, return an ASCII string suitable for use in a HTTP header value.
</p>

<ol>
	<li>
<p>
~RET %入力~item の型に応じて：
</p>
		<ul class="switch">
			<li>
`整数$shである
⇒
`整数を直列化する$( %入力~item )
◎
If input_item is an integer, return the result of running Serializing an Integer (Section 4.1.4) with input_item.
</li>
			<li>
`~decimal$shである
⇒
`~decimalを直列化する$( %入力~item )
◎
If input_item is a decimal, return the result of running Serializing a Decimal (Section 4.1.5) with input_item.
</li>
			<li>
`文字列$shである
⇒
`文字列を直列化する$( %入力~item )
◎
If input_item is a string, return the result of running Serializing a String (Section 4.1.6) with input_item.
</li>
			<li>
`~token$shである
⇒
`~tokenを直列化する$( %入力~item )
◎
If input_item is a token, return the result of running Serializing a Token (Section 4.1.7) with input_item.
</li>
			<li>
`真偽値$shである
⇒
`真偽値を直列化する$( %入力~item )
◎
If input_item is a Boolean, return the result of running Serializing a Boolean (Section 4.1.9) with input_item.
</li>
			<li>
`~byte列$shである
⇒
`~byte列を直列化する$( %入力~item )
◎
If input_item is a byte sequence, return the result of running Serializing a Byte Sequence (Section 4.1.8) with input_item.
</li>
			<li>
その他
⇒
~Assert：
この事例は生じ得ない
◎
Otherwise, fail serialisation.
</li>
		</ul>
	</li>
</ol>

				</section>
			</section>
			<section id="ser-integer">
<h4 title="Serializing an Integer">4.1.4. `整数^shの直列化-法</h4>

<p>
所与の
( `整数$sh %入力~整数 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given an integer as input_integer, return an ASCII string suitable for use in a HTTP header value.
◎
• If input_integer is not an integer in the range of −999,999,999,999,999 to 999,999,999,999,999 inclusive, fail serialisation.
</p>
<ol>
	<li>
%符号 ~LET 空~文字列
◎
Let output be an empty string.
</li>
	<li>
~IF［
%入力~整数 ~LT 0
］
⇒＃
%符号 ~SET `-^ch；
%入力~整数 ~SET %入力~整数 の絶対値
◎
If input_integer is less than (but not equal to) 0, append “-“ to output.
</li>
	<li>
%整数~部 ~LET `負でない整数を直列化する$( %入力~整数 )
◎
Append input_integer’s numeric value represented in base 10 using only decimal digits to output.
</li>
	<li>
~Assert：
%整数~部 の`長さ$ ~IN { 1 〜 15 }
◎
↑</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%符号,
%整数~部
◎
Return output.
</li>
</ol>

<p>
`負でない整数を直列化する@
ときは、所与の
( 負でない整数 %入力~整数 )
に対し，次を返す
⇒
%入力~整数 を`~ASCII数字$のみを利用して 10 進記数法で【最短に】表現する文字列（ 0 ならば `0^l ）
</p>


			</section>
			<section id="ser-decimal">
<h4 title="Serializing a Decimal">4.1.5. `~decimal^shの直列化-法</h4>

<div>
<p>
所与の
( `~decimal$sh %入力~decimal )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
</p>
<ol>
	<li>
( %入力~整数, %小数~成分 ) ~LET %入力~decimal の ( 整数~成分, 小数~成分 )
</li>
	<li>
%符号 ~LET 空~文字列
</li>
	<li>
~IF［
%入力~整数 ~LT 0
］
⇒＃
%符号 ~SET `-^ch；
%入力~整数 ~SET %入力~整数 の絶対値
</li>
	<li>
%整数~部 ~LET `負でない整数を直列化する$( %入力~整数 )
</li>
	<li>
~Assert：
%整数~部 の`長さ$ ~IN { 1 〜 12 }
</li>
	<li>
%小数~部 ~LET `負でない整数を直列化する$( %小数~成分 )†
</li>
	<li>
~Assert：
%小数~部 の`長さ$ ~IN { 1 〜 3 }
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%符号,
%整数~部,
`.^ch,
%小数~部
</li>
</ol>

<p class="trans-note">【†
原文には，この段にて小数の丸めに関する仔細が述べられているが、この仕様には本質的でないので，省略する
— その本義は、実装が`~decimal$shを（例えば演算~用に） double 型の値として保持する場合に，それらの相互変換が往来すること
— `~decimal$shを double 型に変換してから`~decimal$shに変換した結果が同じ値に戻ること —
を確保することにある（<a href="https://github.com/httpwg/http-extensions/issues/982">参照</a>）。
】</p>

◎
Given a decimal_number as input_decimal, return an ASCII string suitable for use in a HTTP header value.
• Let output be an empty string.
• If input_decimal is less than (but not equal to) 0, append “-“ to output.
• Append input_decimal’s integer component represented in base 10 (using only decimal digits) to output; if it is zero, append “0”.
• If the number of characters appended in the previous step is greater than 12, fail serialisation.
• Append “.” to output.
• If input_decimal’s fractional component is zero, append “0” to output.
• Else if input_decimal’s fractional component has up to three digits, append them represented in base 10 (using only decimal digits) to output.
• Otherwise, append the first three digits of input_decimal’s fractional component (represented in base 10, using only decimal digits) to output, rounding the final digit to the nearest value, or to the even value if it is equidistant.
• Return output.
</div>

			</section>
			<section id="ser-string">
<h4 title="Serializing a String">4.1.6. `文字列^shの直列化-法</h4>

<p>
所与の
( `文字列$sh %入力~文字列 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a string as input_string, return an ASCII string suitable for use in a HTTP header value.
• If input_string is not a sequence of characters, or contains characters in the range %x00-1f or %x7f (i.e., is not in VCHAR or SP), fail serialisation.
</p>
<ol>
	<li>
%出力 ~LET `"^ch
◎
Let output be an empty string.
◎
Append DQUOTE to output.
</li>
	<li>
<p>
%入力~文字列 を成す
~EACH( %文字 )
に対し：
◎
For each character char in input_string:
</p>
		<ol>
			<li>
~IF［
%文字 ~IN { `\^ch, `"^ch }
］
⇒
%出力 に `\^ch を付加する
◎
If char is “\” or DQUOTE:
• Append “\” to output.
</li>
			<li>
%出力 に %文字 を付加する
◎
Append char to output.
</li>
		</ol>
	</li>
	<li>
%出力 に `"^ch を付加する
◎
Append DQUOTE to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
			</section>
			<section id="ser-token">
<h4 title="Serializing a Token">4.1.7. `~token^shの直列化-法</h4>

<p>
所与の
( `~token$sh %入力~token )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a token as input_token, return an ASCII string suitable for use in a HTTP header value.
• If input_token is not a sequence of characters, the first character is not ALPHA or “*”, or the remaining contain a character not in tchar, “:” or “/”, fail serialisation.
</p>
<ol>
	<li>
~RET %入力~token
◎
Let output be an empty string.
◎
Append input_token to output.
◎
Return output.
</li>
</ol>

			</section>
			<section id="ser-binary">
<h4 title="Serializing a Byte Sequence">4.1.8. `~byte列^shの直列化-法</h4>

<p>
所与の
( `~byte列$sh %入力~byte列 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a byte sequence as input_bytes, return an ASCII string suitable for use in a HTTP header value.
• If input_bytes is not a sequence of bytes, fail serialisation.
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be an empty string.
</li>
	<li>
%出力 に `:^ch を付加する
◎
Append “:” to output.
</li>
	<li>
%出力 に次の結果を付加する
⇒
`RFC4648/4$sec に従って, および下に与える要件を織り込む下で，
%入力~byte列 を~base64に符号化した結果
◎
Append the result of base64-encoding input_bytes as per [RFC4648], Section 4, taking account of the requirements below.
</li>
	<li>
%出力 に `:^ch を付加する
◎
Append “:” to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p>
`RFC4648/3.2$sec に従って、符号化された~dataには， `=^ch を~padすることが要求される†。
◎
The encoded data is required to be padded with “=”, as per [RFC4648], Section 3.2.
</p>

<p>
同様に， `RFC4648/3.5$sec に従って、符号化される~dataにおける~pad~bit††は 0 に設定するベキである
— 実装の拘束に因り，そうするのはアリでない限り。
◎
Likewise, encoded data SHOULD have pad bits set to zero, as per [RFC4648], Section 3.5, unless it is not possible to do so due to implementation constraints.
</p>

<p class="trans-note">【†
すなわち、符号化した結果の長さが 4 の倍数にならない場合，そうなるよう補充する。
】【††
~base64単位を成す 6 ~bitと~byte単位を成す 8 ~bitとのずれに因る不足分を（~byte列の末尾に）補充する~bit。
】【
構文解析器は、~padに関しては，この~algoの出力より~~寛容な形式を受容する（ `4.2.7$sec ）。
】</p>


			</section>
			<section id="ser-boolean">
<h4 title="Serializing a Boolean">4.1.9. `真偽値^shの直列化-法</h4>

<p>
所与の
( `真偽値$ %入力~真偽値 )
に対し，［
~HTTP~header値に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a Boolean as input_boolean, return an ASCII string suitable for use in a HTTP header value.
• If input_boolean is not a boolean, fail serialisation.
</p>
<ol>
	<li>
~RET %入力~真偽値 に応じて
⇒＃
~T ならば `?1^l ／
~F ならば `?0^l
◎
Let output be an empty string.
◎
Append “?” to output.
◎
If input_boolean is true, append “1” to output.
◎
If input_boolean is false, append “0” to output.
◎
Return output.
</li>
</ol>
			</section>
		</section>
		<section id="text-parse">
<h3 title="Parsing Header Fields into Structured Headers">4.2. 有構造~headerの構文解析-法</h3>

<p>
受信した［
有構造~headerであることが既知な~HTTP~header
］を構文解析する実装は、［
相互運用能や~securityにまで問題をもたらし得る，いくつかの際どい事例
］を~careすることが重要になる。
この節は、そうするための~algoを指定する。
◎
When a receiving implementation parses HTTP header fields that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.
</p>

<p>
所与の
( %入力~byte列, %~header型 )
に対し，構文解析された~header値を返す：
◎
Given＼
</p>

<ol>
	<li>
~Assert：
%入力~byte列 は当の~headerの `field-value$p を表現する`~byte列$である（その~headerが無い場合、空~byte列）
◎
an array of bytes input_bytes that represents the chosen header’s field-value (which is empty if that header is not present), and＼
</li>
	<li>
~Assert：
%~header型 ~IN { `辞書^i, `~list^i, `~item^i }
◎
header_type (one of “dictionary”, “list”, or “item”), return the parsed header value.
</li>
	<li>
~IF［
%入力~byte列 を成すある~byteは`~ASCII~byte$でない
］
⇒
構文解析を失敗させる
◎
↓</li>
	<li>
%入力~文字列 ~LET `~ASCII復号する$( %入力~byte列 )
◎
Convert input_bytes into an ASCII string input_string; if conversion fails, fail parsing.
</li>
	<li>
<p>
~IF［
%入力~文字列 を成すある文字は`制御~文字$である
］
⇒
構文解析を失敗させる
</p>

<p class="trans-note">【
この段は、この訳による追加。
この仕様が定義する どの構文解析~algoも，`制御~文字$に対し構文解析を失敗させることになるので、この段で予めそれらを排することにより，他所の記述を単純~化する。
】</p>
	</li>
	<li>
<p>
%位置 ~LET %入力~文字列 内の先頭を指している`位置~変数$
⇒
%入力~文字列, %位置 は、この~algoが利用する すべての~algoから共有される。
</p>

<p class="trans-note">【
この段は、この訳による追加。
この節~全体を通して，各種~algoは、構文解析される文字列を保持する %入力~文字列,
および 次に構文解析される文字を指す変数 %位置 を用いる~patternに従う（そのように，この訳では改めている）。
詳細は、以降に現れる %位置↗ という表記も含め，`位置~変数$を参照されたし。
】</p>

	</li>
	<li>
<p>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
</p>

<p class="trans-note">【
%入力~文字列 内には`制御~文字$は無いので、これは`~ASCII空白を読飛ばす$ことと同義になる（以下同様）。
】</p>
◎
Discard any leading SP characters from input_string.
</li>
	<li>
%出力 ~LET %~header型 に応じて，次に与える結果
⇒＃
`~list^i ならば %入力~文字列 から`~listを構文解析する$／
`辞書^i ならば %入力~文字列 から`辞書を構文解析する$／
`~item^i ならば %入力~文字列 から`~itemを構文解析する$
◎
If header_type is “list”, let output be the result of running Parsing a List (Section 4.2.1) with input_string.
◎
If header_type is “dictionary”, let output be the result of running Parsing a Dictionary (Section 4.2.2) with input_string.
◎
If header_type is “item”, let output be the result of running Parsing an Item (Section 4.2.3) with input_string.
</li>
	<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
	<li>
~IF［
%入力~文字列 は空でない
］
⇒
構文解析を失敗させる
◎
If input_string is not empty, fail parsing.
</li>
	<li>
~RET %出力
◎
Otherwise, return output.
</li>
</ol>

<p>
%入力~byte列 を生成するとき、構文解析器は
— `RFC7230/3.2.2$sec に従って —
対象になる~headerすべての~instanceを
`,^ch で区切って 1 個の `field-value$p に`結合-$しなければナラナイ
— これは~headerが正しく処理されることを確約する。
◎
When generating input_bytes, parsers MUST combine all instances of the target header field into one comma-separated field-value, as per [RFC7230], Section 3.2.2; this assures that the header is processed correctly.
</p>

<p>
［
`~list$sh／`辞書$sh
］に対しては、これには，~headerのすべての~instanceを正しく連結する効果がある
— ~top-level~data構造を成す個々の~memberが複数の~header~instanceにまたがるように分割されていない限り。
◎
For Lists and Dictionaries, this has the effect of correctly concatenating all instances of the header field, as long as individual individual members of the top-level data structure are not split across multiple header instances.
</p>

<p>
`文字列$shは、複数の~header~instanceにまたがって分割されると予測-不能な結果になる
— 結合-時に挿入される `,^ch や ` ^ch は、構文解析器による文字列~出力の一部を成すことになるので。
連結は［
【`下流$／】`上流$
］の`中継者$により行われるかもしれないので、その結果は［
直列化器／構文解析器
］からは制御し得ない。
◎
Strings split across multiple header instances will have unpredictable results, because comma(s) and whitespace inserted upon combination will become part of the string output by the parser. Since concatenation might be done by an upstream intermediary, the results are not under the control of the serializer or the parser.
</p>

<p>
［
`~token$sh／`整数$sh／`~decimal$sh／`~byte列$sh
］は、複数の~headerにまたがるように分割し得ない
— 【`結合-$時に】挿入される `,^ch は，構文解析を失敗させることになるので。
◎
Tokens, Integers, Decimals and Byte Sequences cannot be split across multiple headers because the inserted commas will cause parsing to fail.
</p>

<p>
構文解析が失敗する場合
— 別の~algoを~callするときも含め —
~header全体の値を，無視しなければナラナイ（すなわち、当の~headerは~message内に無かったかのように扱われる）
【~algoにおいては、 “構文解析を失敗させる” という句で指示される】
。
相互運用能と安全性を改善するため、これは意図的に厳密である
— この文書を参照している仕様には、この要件を~~緩めることは許容されない。
◎
If parsing fails – including when calling another algorithm – the entire header field’s value MUST be ignored (i.e., treated as if the header field were not present in the message). This is intentionally strict, to improve interoperability and safety, and specifications referencing this document are not allowed to loosen this requirement.
</p>

<p>
この要件は、~headerを構文解析しない実装には適用されないことに注意。
例えば，`中継者$には、［
~messageを回送する前に，失敗している~headerを剥取る
］ことは要求されない。
◎
Note that this requirement does not apply to an implementation that is not parsing the header field;＼
◎
for example, an intermediary is not required to strip a failing header field from a message before forwarding it.
</p>

			<section id="parse-list">
<h4 title="Parsing a List">4.2.1. `~list^shの構文解析-法</h4>

<p>
%入力~文字列 から`~list$shを構文解析して返す：
◎
Given an ASCII string as input_string, return an array of (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
%~memberたち ~LET 新たな`~list$
◎
Let members be an empty array.
</li>
	<li>

<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While input_string is not empty:
</p>
		<ol>
			<li>
%~memberたち に次の結果を`付加する$
⇒
%入力~文字列 から`~itemまたは内縁~listを構文解析する$
◎
Append the result of running Parsing an Item or Inner List (Section 4.2.1.1) with input_string to members.
</li>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~BREAK
◎
If input_string is empty, return members.
</li>
			<li>
~IF［
%位置↗ ~NEQ `,^ch
］
⇒
構文解析を失敗させる
◎
↓</li>
			<li>
%位置 ~INCBY 1
⇒
◎
Consume the first character of input_string; if it is not COMMA, fail parsing.
</li>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
構文解析を失敗させる
（尾部に余計な `,^ch がある）
◎
If input_string is empty, there is a trailing comma; fail parsing.
</li>
		</ol>
	</li>
	<li>
~RET %~memberたち
【！No structured data has been found;】
◎
No structured data has been found; return members (which is empty).
</li>
</ol>

				<section id="parse-item-or-list">
<h5 title="Parsing an Item or Inner List">4.2.1.1. `~item$shまたは`内縁~list^shの構文解析-法</h5>

<p>
%入力~文字列 から［
`~item$sh／`内縁~list$sh
］を構文解析して返す：
◎
Given an ASCII string as input_string, return the tuple (item_or_inner_list, parameters), where item_or_inner_list can be either a single bare item, or an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~EQ `(^ch
］
⇒
~RET %入力~文字列 から`内縁~listを構文解析する$
◎
If the first character of input_string is “(“, return the result of running Parsing an Inner List (Section 4.2.1.2) with input_string.
</li>
	<li>
~RET %入力~文字列 から`~itemを構文解析する$
◎
Return the result of running Parsing an Item (Section 4.2.3) with input_string.
</li>
</ol>

				</section>
				<section id="parse-innerlist">
<h5 title="Parsing an Inner List">4.2.1.2. `内縁~list^shの構文解析-法</h5>

<p>
%入力~文字列 から`内縁~list$shを構文解析して返す：
◎
Given an ASCII string as input_string, return the tuple (inner_list, parameters), where inner_list is an array of (bare_item, parameters) tuples. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NEQ `(^ch
］
⇒
構文解析を失敗させる
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
Consume the first character of input_string; if it is not “(“, fail parsing.
</li>
	<li>
%~list ~LET 新たな`~list$
◎
Let inner_list be an empty array.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While input_string is not empty:
</p>
		<ol>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `)^ch
］：
◎
If the first character of input_string is “)”:
</p>
				<ol>
					<li>
%位置 ~INCBY 1
◎
Consume the first character of input_string.
</li>
					<li>
%~parameters ~LET %入力~文字列 から`~parametersを構文解析する$
◎
Let parameters be the result of running Parsing Parameters (Section 4.2.3.2) with input_string.
</li>
					<li>
~RET ( %~list, %~parameters ) からなる`内縁~list$sh
◎
Return the tuple (inner_list, parameters).
</li>
				</ol>
			</li>
			<li>
%~list に次の結果を`付加する$
⇒
%入力~文字列 から`~itemを構文解析する$
◎
Let item be the result of running Parsing an Item (Section 4.2.3) with input_string.
◎
Append item to inner_list.
</li>
			<li>
~IF［
%位置↗ ~NIN { ` ^ch, `)^ch }
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not SP or “)”, fail parsing.
</li>
		</ol>
	</li>
	<li>
構文解析を失敗させる
（`内縁~list$shを閉じる括弧を見出すことなく， %入力~文字列 の終端を過ぎた）
◎
The end of the inner list was not found; fail parsing.
</li>
</ol>
				</section>
			</section>
			<section id="parse-dictionary">
<h4 title="Parsing a Dictionary">4.2.2. `辞書^shの構文解析-法</h4>

<p>
%入力~文字列 から`辞書$shを構文解析して返す：
◎
Given an ASCII string as input_string, return an ordered map whose values are (item_or_inner_list, parameters) tuples. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
%辞書 ~LET 新たな`有順序~map$
◎
Let dictionary be an empty, ordered map.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While input_string is not empty:
</p>
		<ol>
			<li>
%~key ~LET %入力~文字列 から`~keyを構文解析する$
◎
Let this_key be the result of running Parsing a Key (Section 4.2.3.3) with input_string.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `=^ch
］
◎
If the first character of input_string is “=”:
</p>
				<ol>
					<li>
%位置 ~INCBY 1
◎
Consume the first character of input_string.
</li>
					<li>
%~member ~LET %入力~文字列 から`~itemまたは内縁~listを構文解析する$
◎
Let member be the result of running Parsing an Item or Inner List (Section 4.2.1.1) with input_string.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~member ~LET ( `真偽値$sh ~T, 空な`~parameters$sh ) からなる`~item$sh
◎
Otherwise:
• Let value be Boolean true.
• Let parameters be an empty, ordered map.
• Let member be the tuple (value, parameters).
</li>
			<li>
%辞書[ %~key ] ~SET %~member
◎
Add name this_key with value member to dictionary. If dictionary already contains a name this_key (comparing character-for-character), overwrite its value.
</li>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~BREAK
◎
If input_string is empty, return dictionary.
</li>
			<li>
~IF［
%位置↗ ~NEQ `,^ch
］
⇒
構文解析を失敗させる
◎
↓</li>
			<li>
%位置 ~INCBY 1
◎
Consume the first character of input_string; if it is not COMMA, fail parsing.
</li>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
構文解析を失敗させる
（尾部に余計な `,^ch がある）
◎
If input_string is empty, there is a trailing comma; fail parsing.
</li>
		</ol>
	</li>
	<li>
~RET %辞書
【！No structured data has been found;】
◎
No structured data has been found; return dictionary (which is empty).
</li>
</ol>
			</section>
			<section id="parse-item">
<h4 title="Parsing an Item">4.2.3. `~item^shの構文解析-法</h4>

<p>
%入力~文字列 から`~item$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a (bare_item, parameters) tuple. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
%裸~item ~LET %入力~文字列 から`裸~itemを構文解析する$
◎
Let bare_item be the result of running Parsing a Bare Item (Section 4.2.3.1) with input_string.
</li>
	<li>
%~parameters ~LET %入力~文字列 から`~parametersを構文解析する$
◎
Let parameters be the result of running Parsing Parameters (Section 4.2.3.2) with input_string.
</li>
	<li>
~RET ( %裸~item, %~parameters ) からなる`~item$sh
◎
Return the tuple (bare_item, parameters).
</li>
</ol>
				<section id="parse-bare-item">
<h5 title="Parsing a Bare Item">4.2.3.1. `裸~item^shの構文解析-法</h5>

<p>
%入力~文字列 から`裸~item$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a bare item. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
<p>
%位置↗ に応じて：
</p>
		<ol class="switch">
			<li>
`-^ch ／ `~ASCII数字$
⇒
~RET %入力~文字列 から`実数を構文解析する$
◎
If the first character of input_string is a “-“ or a DIGIT, return the result of running Parsing a Number (Section 4.2.4) with input_string.
</li>
			<li>
`"^ch
⇒
~RET %入力~文字列 から`文字列を構文解析する$
◎
If the first character of input_string is a DQUOTE, return the result of running Parsing a String (Section 4.2.5) with input_string.
</li>
			<li>
`:^ch
⇒
~RET %入力~文字列 から`~byte列を構文解析する$
◎
If the first character of input_string is “:”, return the result of running Parsing a Byte Sequence (Section 4.2.7) with input_string.
</li>
			<li>
`?^ch
⇒
~RET %入力~文字列 から`真偽値を構文解析する$
◎
If the first character of input_string is “?”, return the result of running Parsing a Boolean (Section 4.2.8) with input_string.
</li>
			<li>
`*^ch ／ `~ASCII英字$
⇒
~RET %入力~文字列 から`~tokenを構文解析する$
◎
If the first character of input_string is an ALPHA or “*”, return the result of running Parsing a Token (Section 4.2.6) with input_string.
</li>
			<li>
その他
⇒
構文解析を失敗させる（認識されない型である）
◎
Otherwise, the item type is unrecognized; fail parsing.
</li>
		</ol>
	</li>
</ol>

				</section>
				<section id="parse-param">
<h5 title="Parsing Parameters">4.2.3.2. `~parameters^shの構文解析-法</h5>

<p>
%入力~文字列 から`~parameters$shを構文解析して返す：
◎
Given an ASCII string as input_string, return an ordered map whose values are bare items. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
%~parameters ~LET 新たな`有順序~map$
◎
Let parameters be an empty, ordered map.
</li>
	<li>

<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While input_string is not empty:
</p>
		<ol>
			<li>
~IF［
%位置↗ ~NEQ `;^ch
］
⇒
~BREAK
◎
If the first character of input_string is not “;”, exit the loop.
</li>
			<li>
%位置 ~INCBY 1
◎
Consume a “;” character from the beginning of input_string.
</li>
			<li>
%入力~文字列 内の %位置 から ` ^ch からなる`文字~並びを収集する$
◎
Discard any leading SP characters from input_string.
</li>
			<li>
%~parameter名 ~LET %入力~文字列 から`~keyを構文解析する$
◎
let param_name be the result of running Parsing a Key (Section 4.2.3.3) with input_string.
</li>
			<li>
%~parameter値 ~LET `真偽値$sh ~T
◎
Let param_value be Boolean true.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `=^ch
］：
◎
If the first character of input_string is “=”:
</p>
				<ol>
					<li>
%位置 ~INCBY 1
◎
Consume the “=” character at the beginning of input_string.
</li>
					<li>
%~parameter値 ~LET %入力~文字列 から`裸~itemを構文解析する$
◎
Let param_value be the result of running Parsing a Bare Item (Section 4.2.3.1) with input_string.
</li>
				</ol>
			</li>
			<li>
%~parameters[ %~parameter名 ] ~SET %~parameter値
◎
Append key param_name with value param_value to parameters. If parameters already contains a name param_name (comparing character-for-character), overwrite its value.
</li>
		</ol>
	</li>
	<li>
~RET %~parameters
◎
Return parameters.
</li>
</ol>
				</section>
				<section id="parse-key">
<h5 title="Parsing a Key">4.2.3.3. `~key^shの構文解析-法</h5>

<p>
%入力~文字列 から［
`辞書$sh／`~parameters$sh
］用の`~key$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a key. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NIN { `~ASCII英小文字$ }
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not lcalpha, fail parsing.
</li>
	<li>
~RET %入力~文字列 内の %位置 から`~key文字$からなる`文字~並びを収集する$
◎
Let output_string be an empty string.
◎
While input_string is not empty:
• If the first character of input_string is not one of lcalpha, DIGIT, “_”, “-“, “.”, or “*”, return output_string.
• Let char be the result of removing the first character of input_string.
• Append char to output_string.
◎
Return output_string.
</li>
</ol>
</section>

			</section>
			<section id="parse-number">
<h4 title="Parsing a Number">4.2.4. 実数の構文解析-法</h4>

<p>
%入力~文字列 から［
`整数$sh／`~decimal$sh
］を構文解析して返す：
◎
Given an ASCII string as input_string, return a number. input_string is modified to remove the parsed value.
</p>

<p class="note">
この~algoは、`整数$sh, `~decimal$shの両者を構文解析して，対応する構造を返す。
◎
NOTE: This algorithm parses both Integers (Section 3.3.1) and Decimals (Section 3.3.2), and returns the corresponding structure.
</p>

<div>
<ol>
	<li>
%符号 ~LET 1
</li>
	<li>
~IF［
%位置↗ ~EQ `-^ch
］
⇒＃
%位置 ~INCBY 1；
%符号 ~SET ~MINUS 1
</li>
	<li>
%整数~部 ~LET %入力~文字列 内の %位置 から`~ASCII数字$からなる`文字~並びを収集する$
</li>
	<li>
~IF［
%整数~部 の`長さ$ ~NIN { 1 〜 15 }
］
⇒
構文解析を失敗させる
</li>
	<li>
%整数~成分 ~LET %整数~部 を 10 進~整数として解釈した結果
</li>
	<li>
%整数~成分 ~SET %符号 ~MUL %整数~成分
</li>
	<li>
~Assert：
%整数~成分 ~IN { −999999999999999 〜 999999999999999 }
</li>
	<li>
~IF［
%位置↗ ~NEQ `.^ch
］
⇒
~RET %整数~成分 を値にとる`整数$sh
</li>
	<li>
%位置 ~INCBY 1；
</li>
	<li>
~IF［
%整数~部 の`長さ$ ~GT 12
］
⇒
構文解析を失敗させる
</li>
	<li>
~Assert：
%整数~成分 ~IN { −999999999999 〜 999999999999 }
</li>
	<li>
%小数~部 ~LET %入力~文字列 内の %位置 から`~ASCII数字$からなる`文字~並びを収集する$
</li>
	<li>
~IF［
%小数~部 の`長さ$ ~NIN { 1 〜 3 }
］
⇒
構文解析を失敗させる
</li>
	<li>
%小数~成分 ~LET %小数~部 を 10 進~整数として解釈した結果
</li>
	<li>
~Assert：
%小数~成分 ~IN { 0 〜 999 }
</li>
	<li>
~RET
( %整数~成分, %小数~成分 )
からなる`~decimal$sh
</li>
</ol>

◎
Let type be “integer”.
◎
Let sign be 1.
◎
Let input_number be an empty string.
◎
If the first character of input_string is “-“, consume it and set sign to -1.
◎
If input_string is empty, there is an empty integer; fail parsing.
◎
If the first character of input_string is not a DIGIT, fail parsing.
◎
While input_string is not empty:
• Let char be the result of consuming the first character of input_string.
• If char is a DIGIT, append it to input_number.
• Else, if type is “integer” and char is “.”:
•• If input_number contains more than 12 characters, fail parsing.
•• Otherwise, append char to input_number and set type to “decimal”.
• Otherwise, prepend char to input_string, and exit the loop.
（消費した文字を戻す）
• If type is “integer” and input_number contains more than 15 characters, fail parsing.
• If type is “decimal” and input_number contains more than 16 characters, fail parsing.
◎
If type is “integer”:
• Parse input_number as an integer and let output_number be the product of the result and sign.
• If output_number is outside the range −999,999,999,999,999 to 999,999,999,999,999 inclusive, fail parsing.
◎
Otherwise:
• If the final character of input_number is “.”, fail parsing.
• If the number of characters after “.” in input_number is greater than three, fail parsing.
• Parse input_number as a decimal number and let output_number be the product of the result and sign.
◎
Return output_number.
</div>

			</section>
			<section id="parse-string">
<h4 title="Parsing a String">4.2.5. `文字列^shの構文解析-法</h4>

<p>
%入力~文字列 から`文字列$shを返す（引用符で括られない）：
◎
Given an ASCII string as input_string, return an unquoted string. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
%出力~文字列 ~LET 空~文字列
◎
Let output_string be an empty string.
</li>
	<li>
~IF［
%位置↗ ~NEQ `"^ch
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not DQUOTE, fail parsing.
</li>
	<li>
%位置 ~INCBY 1
◎
Discard the first character of input_string.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
</p>
		<ol>
			<li>
~IF［
%位置↗ ~EQ `"^ch
］
⇒＃
%位置 ~INCBY 1；
~RET %出力~文字列
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `\^ch
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%位置↗ ~NIN { `"^ch, `\^ch }
］
⇒
構文解析を失敗させる
</li>
				</ol>
			</li>
<!-- 
			<li>
~ELIF［
%位置↗ ~NIN { ＊`VCHAR$P, ` ^ch }
］
⇒
構文解析を失敗させる
</li>
 -->
			<li>
%出力~文字列 に %位置↗ を付加する
</li>
			<li>
%位置 ~INCBY 1
</li>
		</ol>
◎
While input_string is not empty:
• Let char be the result of consuming the first character of input_string.
• If char is a backslash (“\”):
•• If input_string is now empty, fail parsing.
•• Let next_char be the result of consuming the first character of input_string.
•• If next_char is not DQUOTE or “\”, fail parsing.
•• Append next_char to output_string.
• Else, if char is DQUOTE, return output_string.
• Else, if char is in the range %x00-1f or %x7f (i.e., is not in VCHAR or SP), fail parsing.
• Else, append char to output_string.
</li>
	<li>
構文解析を失敗させる
（`文字列$shを閉じる `"^ch を見出すことなく %入力~文字列 の終端を過ぎた）
◎
Reached the end of input_string without finding a closing DQUOTE; fail parsing.
</li>
</ol>

			</section>
			<section id="parse-token">
<h4 title="Parsing a Token">4.2.6. `~token^shの構文解析-法</h4>

<p>
%入力~文字列 から`~token$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a token. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NIN { `~ASCII英字$, `*^ch }
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not ALPHA or “*”, fail parsing.
</li>
	<li>
~RET %入力~文字列 内の %位置↗ から`~token文字$からなる`文字~並びを収集する$
◎
Let output_string be an empty string.
◎
While input_string is not empty:
• If the first character of input_string is not in tchar, “:” or “/”, return output_string.
• Let char be the result of consuming the first character of input_string.
• Append char to output_string.
◎
Return output_string.
</li>
</ol>

			</section>
			<section id="parse-binary">
<h4 title="Parsing a Byte Sequence">4.2.7. `~byte列^shの構文解析-法</h4>

<p>
%入力~文字列 から`~byte列$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a byte sequence. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NEQ `:^ch
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not “:”, fail parsing.
</li>
	<li>
%位置 ~INCBY 1
◎
Discard the first character of input_string.
</li>
	<li>
%~base64内容 ~LET
%入力~文字列 内の %位置 から次に挙げる文字（ `base64$p ）からなる`文字~並びを収集する$
⇒＃
`~ASCII英字$,
`~ASCII数字$,
`+^ch,
`/^ch,
`=^ch
◎
If there is not a “:” character before the end of input_string, fail parsing.
◎
Let b64_content be the result of consuming content of input_string up to but not including the first instance of the character “:”.
◎
Consume the “:” character at the beginning of input_string.
◎
If b64_content contains a character not included in ALPHA, DIGIT, “+”, “/” and “=”, fail parsing.
</li>
	<li>
~IF［
%位置↗ ~NEQ `:^ch
］
⇒
構文解析を失敗させる
◎
↑</li>
	<li>
%位置 ~INCBY 1
◎
↑</li>
	<li>
%~binary内容 ~LET %~base64内容 を `Base 64^en 復号した結果 `RFC4648$r
— 必要とされるなら~padするものを合成して（下に与える`受信者$の挙動についての要件に注意）
◎
Let binary_content be the result of Base 64 Decoding [RFC4648] b64_content, synthesizing padding if necessary (note the requirements about recipient behaviour below).
</li>
	<li>
~RET %~binary内容
◎
Return binary_content.
</li>
</ol>

<p>
構文解析器は、符号化された~dataにおいて：
◎
↓</p>
<ul>
	<li>
`=^ch が適正に~padされていない場合でも（ `RFC4648/3.2$sec を見よ）、失敗するベキでない
— そうし得ないように環境設定されていない限り。
~base64実装には、その却下を許容しないものもあるので。
◎
Because some implementations of base64 do not allow reject of encoded data that is not properly “=” padded (see [RFC4648], Section 3.2), parsers SHOULD NOT fail when it is not present, unless they cannot be configured to do so.
</li>
	<li>
0 でない~pad~bitがある場合でも（ `RFC4648/3.5$sec を見よ）、失敗するベキでない
— そうし得ないように環境設定されていない限り。
~base64実装には，その却下を許容しないものもあるので。
◎
Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see [RFC4648], Section 3.5), parsers SHOULD NOT fail when it is present, unless they cannot be configured to do so.
</li>
	<li>
`base64$p ~alphabetでない文字に対しては、 `LF$P であろうが，失敗しなければナラナイ
— この仕様は、
`RFC4648/3.1$sec,
`RFC4648/3.3$sec
における要件は緩めない。
◎
This specification does not relax the requirements in [RFC4648], Section 3.1 and 3.3; therefore, parsers MUST fail on characters outside the base64 alphabet, and on line feeds in encoded data.
</li>
</ul>

			</section>
			<section id="parse-boolean">
<h4 title="Parsing a Boolean">4.2.8. `真偽値^shの構文解析-法</h4>

<p>
%入力~文字列 から`真偽値$shを構文解析して返す：
◎
Given an ASCII string as input_string, return a Boolean. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NEQ `?^ch
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not “?”, fail parsing.
</li>
	<li>
%位置 ~INCBY 1
◎
Discard the first character of input_string.
</li>
	<li>
~IF［
%位置↗ ~EQ `1^ch
］
⇒＃
%位置 ~INCBY 1；
~RET `真偽値$sh ~T
◎
If the first character of input_string matches “1”, discard the first character, and return true.
</li>
	<li>
~IF［
%位置↗ ~EQ `0^ch
］
⇒＃
%位置 ~INCBY 1；
~RET `真偽値$sh ~F
◎
If the first character of input_string matches “0”, discard the first character, and return false.
</li>
	<li>
構文解析を失敗させる
◎
No value has matched; fail parsing.
</li>
</ol>
			</section>
		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">5. ~IANA考慮点</h2>

<p>
特になし。
◎
This draft has no actions for IANA.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">6. ~securityの考慮点</h2>

<p>
有構造~headerにより定義される ほとんどの型の~sizeは、制限されない。
その結果、極めて巨大な~headerは，攻撃~行路にもなり得る（例：資源の消費）。
ほとんどの~HTTP実装は、そのような攻撃を軽減するため［
個々の~headerの~size, ~header~block全体の~size
］を制限する。
◎
The size of most types defined by Structured Headers is not limited; as a result, extremely large header fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of individual header fields as well as the overall header block size to mitigate such attacks.
</p>

<p>
ある主体が，［
有構造~headerの意味を変更するような，新たな~HTTP~headerを注入する能
］を有する可能性もある。
これは，一部の状況下では構文解析を失敗させるが、すべての そのような状況下で依拠-可能に失敗させることはアリでない。
◎
It is possible for parties with the ability to inject new HTTP header fields to change the meaning of a Structured Header. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">付録 A. 謝辞</h2>

<p>
この仕様の開発に詳細な~feedback, 注意深い考慮を寄せられた
`Matthew Kerwin^en 氏に。
◎
Many thanks to Matthew Kerwin for his detailed feedback and careful consideration during the development of this specification.
</p>

</section>

	<section id="faq">
<h2 title="Frequently Asked Questions">付録 B. よくある質問</h2>

		<section id="why-not-json">
<h3 title="B.1. Why not JSON?">B.1. なぜ~JSONじゃない？</h3>

<p>
有構造~header用の早期の提案は~JSON `RFC8259$r に基づいていたが、その利用を
~HTTP~header用に相応しくなるように拘束することは，［
`送信者$／`受信者$
］に特有な追加的な取扱いを実装するために要求される。
◎
Earlier proposals for structured headers were based upon JSON [RFC8259]. However, constraining its use to make it suitable for HTTP header fields required senders and recipients to implement specific additional handling.
</p>

<p>
例えば，~JSON仕様には［
巨大な実数／重複する~memberを伴う~obj
］周りに課題がある。
これらの課題を避けるための助言も可用であるが（例： `RFC7493$r ）、それには依拠できない。
◎
For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., [RFC7493]), it cannot be relied upon.
</p>

<p>
同様に，~JSON文字列は既定では~Unicode文字列であり、相互運用能の課題になり得るものがいくつかある（例：比較において）。
実装者には，不必要な所では~ASCIIでない内容を避けるよう勧めるが、これを施行するのは困難である。
◎
Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.
</p>

<p>
別の例として、任意な深さまで内容を入子にする~JSONの能も挙げられる。
結果の `memory commitment^en 【必要に応じて~~確保する実メモリの~~絶対量】は適さないかもしれないので（例：埋込dその他の，制限された~server配備において）、それを何らかの流儀で制限することが必要とされる
— しかしながら，既存の~JSON実装には そのような制限sは無く、制限-が指定されても，一部の~header定義は それに違反する必要を見出すことになる見込みが高い。
◎
Another example is JSON’s ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it’s necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it’s likely that some header field definition will find a need to violate it.
</p>

<p>
~JSONには広い採用と実装があるので、すべての実装にわたって，そのような追加的な拘束を課すのは困難である。
それを施行するのに失敗する配備が一部でもあれば、相互運用能を害することになる。
短かく言えば、~JSONに似た何かにした場合，人は~JSON［
構文解析器／直列化器
］を~headerに利用したくなりがちになる。
◎
Because of JSON’s broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability. In short, if it looks like JSON, people will be tempted to use a JSON parser / serialiser on header fields.
</p>

<p>
有構造~headerの主要な目標は、相互運用能を改善して，実装を単純~化することにあるので、これらの懸念から，専用の［
構文解析器, 直列化器
］を要求する形式に至った。
◎
Since a major goal for Structured Headers is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serializer.
</p>

<p>
加えて，~JSONは、~HTTP~header内では “まっとうに見えない” 感覚が広く共有されている。
◎
Additionally, there were widely shared feelings that JSON doesn’t “look right” in HTTP headers.
</p>

		</section>
		<section id="structured-headers-dont-fit-my-data">
<h3 title="B.2. Structured Headers don’t “fit” my data.">B.2. 有構造~headerに “収まって” くれない~dataがあるんですが</h3>

<p>
有構造~headerは、［
少しの~overheadで高処理能な方式で処理できること
］を確約するため，~data構造の複階性を意図的に制限する。
すなわち、~~目的の~dataを【この仕様に定義した】何らかの~data型に収める作業が必要とされる。
◎
Structured headers intentionally limits the complexity of data structures, to assure that it can be processed in a performant manner with little overhead. This means that work is necessary to fit some data types into them.
</p>

<p>
これは、［
値~内に制限-付き下位構造を作成する／複数種の~headerを利用する
］ことにより達成できることもある。
◎
Sometimes, this can be achieved by creating limited substructures in values, and/or using more than one header.＼
</p>

<div class="example">
<p>
例えば，次を考える【この例の字下げに伴う改行は、呈示~用であり，実際には無い】：
◎
For example, consider:
</p>

<pre class="http-code">
Example-Thing: name="Widget", cost=89.2, descriptions=(foo bar)
Example-Description:
    foo; url="https://example.net"; context=123,
    bar; url="https://example.org"; context=456
</pre>

<p>
`Example-Description^h ~headerは、［
一連の~tokenからなる~listを包含していて，各~tokenには一連の［
( ~key, 値 ) が成す~pair
］も伴われる
］ので，`~list$shを利用してそれを表現する。
`Example-Thing^h ~headerは、`辞書$sh を値にとる
— その `descriptions^c ~memberは，`内縁~list$shを値にとり、その各`~item$shの値に`~token$shを利用して，前者の`~list$shを成す各`~item$shを識別する。
◎
Since the description contains an array of key/value pairs, we use a List to represent them, with the token for each item in the array used to identify it in the “descriptions” member of the Example-Thing dictionary header.
</p>

</div>

<p>
複数種の~headerを指定する必要がある場合、［
いずれかの~headerが欠落しているとき，処理器の挙動はどうなるべきか
］を述べることが重要になる。
◎
When specifying more than one header, it’s important to remember to describe what a processor’s behaviour should be when one of the headers is missing.
</p>

<p>
1 個の~headerの中に任意に複階的な~dataを収める必要がある利用事例においては、有構造~headerは，おそらく拙くしか収まらない。
◎
If you need to fit arbitrarily complex data into a header, Structured Headers is probably a poor fit for your use case.
</p>

		</section>
	</section>
	<section id="implementation-notes">
<h2 title="Implementation Notes">付録 C. 実装~向けの注記</h2>

<p>
この仕様の汎用な実装は、~top-levelの［
構文解析する機能（ `4.2$sec ）／直列化する機能（ `4.1$sec ）
］を公開するべきである。
それらは、関数にする必要はない
— 例えば，各種~top-level型~用に異なる~methodを伴う~objとして，実装することもできる。
◎
A generic implementation of this specification should expose the top-level parse (Section 4.2) and serialize (Section 4.1) functions. They need not be functions;＼
◎
for example, it could be implemented as an object, with methods for each of the different top-level types.
</p>

<p>
相互運用能を得るため，汎用な実装は，完全な, かつ~algoに近く従うことが重要になる
— `1.1$sec を見よ。
これを援助するため、~communityは，共通な~test一式を
<a href="https://github.com/httpwg/structured-header-tests">https://github.com/httpwg/structured-header-tests</a>
にて保守している。
◎
For interoperability, it’s important that generic implementations be complete and follow the algorithms closely; see Section 1.1. To aid this, a common test suite is being maintained by the community at https://github.com/httpwg/structured-header-tests.
</p>

<p>
実装者は、［
`辞書$sh／`~parameters$sh
］が順序を保全する~mapであることに注意するべきである。
~headerには，これらの~data型に対する順序付けにより意味を伝達しないものもあるが、順序を利用する必要がある応用にも可用なるよう，順序は依然として公開されるべきである。
◎
Implementers should note that dictionaries and parameters are order-preserving maps. Some headers may not convey meaning in the ordering of these data types, but it should still be exposed so that applications which need to use it will have it available.
</p>

<p>
同様に，実装は、［
`~token$shと`文字列$shの区別を保全する
］ことが重要なことに注意するべきである。
ほとんどの~programming言語は，それ以外の型に きちんと対応付けられる~nativeな型を備えるが、［
“~token” を包装する~objを作成する／
これらの型が別々であり続けることを確約するような~parameterを関数に利用する
］ことも必要とされ得る。
◎
Likewise, implementations should note that it’s important to preserve the distinction between tokens and strings. While most programming languages have native types that map to the other types well, it may be necessary to create a wrapper “token” object or use a parameter on functions to assure that these types remain separate.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">付録 D. 変更点</h2>

【この節は、未訳。】

	</section>
</main></div>
