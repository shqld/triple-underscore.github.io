<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Scoping Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style type="text/css">
.js-slot {
	color: green;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Scoping Module Level 1
spec_date:2018-09-26
trans_update:2018-09-28
source_checked:170825
page_state_key:CSS
original_url:https://drafts.csswg.org/css-scoping-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2018,permissive
trans_1st_pub:2017-09-01


●●class_map
p:property
ps:pseudo
pe:pseudo
css:css
e:element
a:attr
v:value
at:at-rule
f:func
t:type
sl:js-slot

●●tag_map
I:code
m:code
p:code
ps:code
pe:code
at:code
t:var
css:code
e:code
a:code
v:code
f:code
c:code
sl:span

●●original_id_map

●●words_table1

●●words_table


	●内容／構造／slot／scope／node tree／shadow
	Scope
	Shadow
light:
shadow:
	~shadowを貫く:shadow-piercing
	~light~tree:light-tree
slot:
slotable:
	slot-assigned
	slot-assignment
	at all slot-assignment levels
貫く:pierceする::~
	~treeに留まる:tree-abiding
入子:nest::入れ子
encapsulation::::カプセル化
埋める:fillする:~
包装-:wrap::~
	wrapper
平坦:flat::~
平坦化-:flatten::~
	平坦化-法:flattening
深い:deepな:~

	到達-不能:unreachable
	containing
	より深い:deeper
	-:pre-order
	どうしの順序:relative ordering
	最も外縁:outermost
	内部~slot:private slot
	遮断-:disrupt
	引き込む:pulled into
	居る:live

	●選択子／視野
詳細度:specificity::~
選択-:select::~
	選択できない:unselectable
複体:complex::~
合体:compound::~
結合子:combinator::~
無特能:featureless::~
	無特能:so weird
出自:origin::~
出自の:originating::~
対象に:target:~
勝つ:winする:優先される

	視野~付け:scoping
	視野~付き:scoped

	●CSS
	cascade法:cascading
flexbox:
	styling
	stylesheet:sheet

	●演算／処理
優先-:prioritize:~
処理待ち:pending:~
渡され:passされ:~


	●仕様
明白:obvious:~
適理な:reasonableな:理に適う

	できるよう:possible
	-不可能:impossible for 〜
	Standard
	we
	先ず挙げられる:primary
	別の言い方をすれば:alternately
	良くないことが起こる:very good
	~~素の:vanilla
	難しい:hard
	不都合:complaint
	capable
	complex
	idea
	informative
	概ね:loosely
	幸いなことに:luckily
	note
	類似する:similar
	他の点では:otherwise
	独力で:affirmatively 〜 all by itself
	なら〜必要がある:we can’t say〜

	●仕様（動詞
続行-:proceed:~
偶発的:accidental:~
介入-:intervene:~

	予測-不能:unpredictable
	-:provide
	単一化:single unified
	聞く:hear
	基づく:rebase
	必要がある:want
	~~先送り:punt
	~~編成し直す:reorg
	~~問題にはならない:matter
	任意選択で選ぶ:opt into
	力点を置いて:focusing
	-:remember
	〜ないように:prevent
	しようと:-try
	戸惑う／confusing

	●未分類（動詞

提示-:present:~
後続-:follow:~
足した:plusした:~
	観測され得ない:observable
	現れる:appear
	-:attach
	called
	coming
	-:gain
	-:get
	名前:keyed with
	originating
	-:pop
	-:put
	made
	できない:capable
	対応付ける:map する

	●未分類
	対象にできない:untargettable
部品:component:~
	Selector

関数形:functional form:~
関数形の:functional:~
	function
変種:variant:~
種類:kind:~

theme::::テーマ
色:color:~

	低い:low
	~~特性:qualities

	●指示語
普通は:ordinaryには:~
普通の:ordinaryな:~

	他の部分:the rest
	部分:part
	うち一部:some of
	どこか:somewhere
	一部:part of
	先に来る:earlier
	後に来る:coming later
	~slotに:downwards
	-:sort of
	ちょうど同じく:just as
	同類:akin
	種々の:various
	逆:opposite
	遡る:on the way up
	across
	against
	top
	一握りhandful
	higher
	later
	sole
	somewhat
	somewhere
	whichever
	より上位にある:lies〜 above
	より上位:higher up
	もっぱら:sole
	他:nobody else
	どうやっても:any way


●●link_map


I.Window:~WINDOW#window
~at-rule:~CSSSYN#at-rule
at.font-face:~CSSFONT#at-font-face-rule
m.querySelector():~DOM4#dom-parentnode-queryselector
sl.defaultElementStylesMap:#dom-window-defaultelementstylesmap-slot

e.slot:~HEscripting#the-slot-element
e.style:~HEmetadata#the-style-element

p.display:~CSSDISP#propdef-display

v.contents:~CSSDISP#valdef-display-contents

pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.slotted():#selectordef-slotted
ps.host():#selectordef-host-function
ps.host-context():#selectordef-host-context
ps.host:#selectordef-host
ps.matches():~SELECTORS4#matches-pseudo
ps.not():~SELECTORS4#negation-pseudo

t.compound-selector-list:~SELECTORS4#typedef-compound-selector-list
t.stylesheet:~CSSSYN#typedef-stylesheet

	●
~cascade:~CASCADE#cascade
子:~DOM4#concept-tree-child
	子たち:~DOM4#concept-tree-child
~custom要素:~DOM4#concept-element-custom
	アテガわれ




複体~選択子:~SELECTORS4#complex
合体~選択子:~SELECTORS4#compound
の~list:~SELECTORS4#list-of-simple-selectors
子孫:~DOM4#concept-tree-descendant
子孫~結合子:~SELECTORS4#descendant-combinator
無特能:~SELECTORS4#featureless
平坦化され:~DOM4#find-flattened-slotables
~slot用に平坦化された~slotableたちを見出す:~DOM4#find-flattened-slotables
~slot用に~slotableたちを見出す:~DOM4#find-slotables
平坦化された要素~tree:#flat-tree
平坦~tree:#flat-tree
断片~疑似要素:#fragment-pseudo-element
~host:~DOM4#concept-documentfragment-host
~shadow~treeの文脈~下:#in-the-context-of-a-shadow-tree
~light~tree:~DOM4#concept-light-tree
局所~名:~DOM4#concept-element-local-name
要素に対し選択子を照合-:~SELECTORS4#match-a-selector-against-an-element
~treeに対し選択子を照合-:~SELECTORS4#match-a-selector-against-a-tree

根:~DOM4#concept-tree-root
文書片:~DOM4#interface-documentfragment

	選択子~合致-~list:~SELECTORS4#selector-match-list
~shadowも含む先祖:~DOM4#concept-shadow-including-ancestor
~shadowも含む~tree順序:~DOM4#concept-shadow-including-tree-order
~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadow~tree:~DOM4#concept-shadow-tree
~slot:~DOM4#concept-slot
~slotable:~DOM4#concept-slotable
~tree文脈:#tree-context
型~選択子:~SELECTORS4#type-selector

~UA出自:~CASCADE#cascade-origin-ua
詳細度:~SELECTORS4#specificity
出自の要素:~SELECTORS4#originating-element

cC.出自:~CASCADE#cascade-origin
cC.視野:~CASCADE#cascade-scope
cC.~shadow~tree:#_cascade-shadow-tree

	選択対象:~SELECTORS4#selector-subject


●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 4. 20 September 2018. WD. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 7 June 2016. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 February 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●ref_informative

[SELECTORS-3]
    Tantek Çelik; et al. Selectors Level 3. 11 September 2018. PR. URL: https://www.w3.org/TR/selectors-3/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Scoping Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-scoping-1/

編集者草案
	https://drafts.csswg.org/css-scoping/

以前のバージョン
	https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/

テスト一式
	http://test.csswg.org/suites/css-scoping-1_dev/nightly-unstable/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-scoping-1">GitHub Issues</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-scoping-1/Overview.bs">GitHub Editor</a>

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">CSS Scoping Module Level 1</h1>
	</hgroup>

</header>


<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~CSSによる［
視野~付け／~encapsulation
］の仕組みを，特に ~shadow~DOMの視野~付け（ `scoping^en ）に力点を置いて定義する。
◎
This specification defines scoping/encapsulation mechanisms for CSS, focusing on the Shadow DOM scoping mechanism.
</p>

~CSSisaLANG


	</section>
	<section id="status">
~STATUSofTHIS

<p>
この節では、発行時点における…
これは編集者草案の公の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

【未策定】

	</section>
	<section id="default-element-styles">
<h2 title="Default Styles for Custom Elements">2. ~custom要素に対する既定の~style</h2>

<p>
`~custom要素$の定義-時には、それに対する
— 組込みの要素に適用される~UA~styleと同類の —
“既定の” ~styleを設定しておくよう求められることが多い。
あいにく，これを~~素の~CSSで行うのは、次の 2 点から難しい：
◎
When defining custom elements, one often wants to set up "default" styles for them, akin to the user-agent styles that apply to built-in elements. This is, unfortunately, hard to do in vanilla CSS, due to issues of scoping and specificity—＼
</p>

<ul>
	<li>
視野~付けの課題：
当の要素は，`~shadow~tree$内で利用されるかもしれない
— その場合、最も外縁の文書~内にある，要素を対象にしている選択子からは到達-不能になる。
◎
the element in question might be used in shadow trees, and thus is unreachable by any selector targeting it in the outermost document;＼
</li>
	<li>
詳細度の課題：
`型~選択子$の様な詳細度が低い選択子でも、当の要素を対象にするよう~~意図された作者~levelの~styleを，偶発的に上書きし得る。
◎
and selectors, even low-specificity ones like simple type selectors, can accidentally override author-level styles meant to target the element.
</li>
</ul>

<p>
これを援助するため、この節では，所与の要素に対し
“既定の要素~style”
を与える~stylesheetの作成-法を定義する。
この種の~stylesheetは、［
文書~全体, および すべての`~shadow~tree$内
］にわたって適用され、その中の各~規則は，作者~levelの規則が自動的に勝つように，`~UA出自$の下で適用される。
◎
To aid in this, this section defines a way to create a stylesheet of "default element styles" for a given element. This stylesheet applies across the entire document, in all shadow trees, and the rules in it apply at the user agent origin, so author-level rules automatically win.
</p>

<p>
各 `Window$I は、
`defaultElementStylesMap@sl
内部~slotを持つ
— それは、要素の`局所~名$を~stylesheetに対応付ける。
それらの~stylesheetは：
◎
Windows gain a private slot [[defaultElementStylesMap]] which is a map of local names to stylesheets.
</p>

<ul>
	<li>
<p>
~window内のどの文書にも適用されるモノトスル。
加えて，~UA~stylesheetとして解釈されるモノトスル。
◎
These stylesheets must apply to every document in the window. They must be interpreted as user agent stylesheets.
</p>

<p class="note">注記：
これは特に、各~文書ごとに，その中のすべての`~shadow~tree$に適用され、それらの中の宣言は`~UA出自$になることを含意する。
◎
Note: This implies, in particular, that they apply to all shadow trees in every document, and that the declarations in them are from the user agent origin.
</p>
	</li>
	<li>
`~cascade$の目的においては、~UAの自前の~stylesheetより後の順になる。
この種の~stylesheetどうしの順序は、観測され得ないので，~~問題にはならない。
◎
For the purpose of the cascade, these stylesheets are ordered after the user agent’s own stylesheets; their relative ordering doesn’t matter as it is not observable.
</li>
	<li>
その中の`複体~選択子$は、無効になるモノトスル。
◎
Within these stylesheets, complex selectors must be treated as invalid.＼
</li>
	<li>
その中の`合体~選択子$は、［［
要素のうち，その`局所~名$は `defaultElementStylesMap$sl 内で当の~stylesheetに対応付けられるもの
］を選択する，`型~選択子$
］が追加されているものと扱うモノトスル。
◎
Every compound selector must be treated as containing an additional type selector that selects elements with the local name that the stylesheet is keyed with.
</li>
</ul>

<p class="issue">
この種の~stylesheetに利用-可能な`~at-rule$を制約する必要はあるか？
例えば、 `font-face$at は許容されるか？
編集者は、とりあえず，何か不都合を
聞くまで／聞かない限り
は、許容したままにしておくことにする。
◎
Do we need to restrict the at-rules that can be used in these sheets? For example, do we allow an @font-face? I’m going to leave it as allowed unless/until I hear complaints.
</p>

<p>
この仕様は、
`defaultElementStylesMap$sl を［
追加する, 除去する, その他、一般に操作する
］方法は，定義しない。
そうするための仕方は、 `DOM$r などの他の仕様が定義するものと期待される。
◎
This specification does not define how to add to, remove from, or generally manipulate the [[defaultElementStylesMap]]. It is expected that other specifications, such as [DOM], will define ways to do so.
</p>

	</section>
	<section id="shadow-dom">
<h2 title="Shadow Encapsulation">3. ~shadowの~encapsulation</h2>

		<section id="shadow-gloss">
<h3 title="Informative Explanation of Shadow DOM">3.1. ~shadow~DOMの説明</h3>

~INFORMATIVE

<p>
この節では、この仕様が何を定義しているかを，~DOM標準 `DOM$r を全部的に把握せずに理解するのを援助するため、~DOMが規範的に定義しているいくつかの概念を説明する。
◎
The following is a non-normative explanation of several concepts normatively defined in the DOM Standard [DOM], to aid in understanding what this spec defines without having to fully grok the DOM Standard.
</p>

<p>
`SELECTORS4$r の <a href="~SELECTORS4#data-model">~data~model節</a>
に定義される要素~treeの各種~~特性に加え、~DOM標準は，`~shadow~tree$に関係するいくつかの新たな概念を追加している。
うちいくつかは~CSSにも関連する。
◎
In addition to the qualities of an element tree defined in Selectors Level 4 §data-model, the DOM Standard adds several new concepts related to shadow trees, several of which are relevant to CSS.
</p>

<p>
要素 %~host は、ある`~shadow~tree$ %~shadow~tree を~hostすることもある
— その根である`~shadow根$ %~shadow根 は、特別な種類の`文書片$である（要素~nodeではない）。
%~shadow根 の子孫は、普通の要素その他の~nodeからなる。
%~host は、 %~shadow根 の`~host$であり，
【 %~shadow~tree を~hostする】`~shadow~host$になる。
◎
An element can host a shadow tree, which is a special kind of document fragment with a shadow root (a non-element node) at its root. Children of the shadow root are ordinary elements and other nodes. The element hosting the shadow tree is its host, or shadow host.
</p>

<p>
%~shadow~tree 内の要素は、一般に %~host の`子孫$とはされない（`子孫~結合子$の様な選択子の目的も含め）。
しかしながら， %~shadow~tree は、 %~host が属する~tree
—  `~light~tree$ %~light~tree —
における`平坦~tree$の構築に利用される。
~CSSにおいては、この平坦~treeが，選択子<em>より後の</em> すべて目的に（継承や~boxの構築なども含め）利用される。
◎
The elements in a shadow tree are not descendants of the shadow host in general (including for the purposes of Selectors like the descendant combinator). However, the shadow tree, when it exists, is used in the construction of the flattened element tree, which CSS uses for all purposes after Selectors (including inheritance and box construction).
</p>

<p>
%~shadow~tree は、概ね，［
%~light~tree における， %~host の通常の内容
］に代わって %~host の内容として扱われる。
しかしながら，［
%~light~tree における %~host の子
］も、ある`~slot$ %~slot にアテガわれることにより， %~shadow~tree の “中に引き込まれる” ことはある
— そのような子は、~CSSの目的においては %~slot の子として扱われる。
さらには、 %~slot も，より深い`~shadow~tree$内の`~slot$にアテガわれることもある。
幸いなことに どの`~slot$も，それ自身は
<a href="#slots-in-shadow-tree">既定では~boxを生成しない</a>
ので、
%~shadow~tree を包装して~CSSを遮断している `slot$e 要素†の~cascadeを，作者が予測-不能になることはない。
【†~slotを作成できるのは、この型の要素に限られる。】
◎
Loosely, the shadow tree is treated as the shadow host’s contents instead of its normal light tree contents. However, some of its light tree children can be "pulled into" the shadow tree by assigning them to slots. This causes them to be treated as children of the slot for CSS purposes. The slots can then be assigned to slots in deeper shadow trees; luckily, slots themselves don’t generate boxes by default, so you don’t get an unpredictable cascade of slot wrapper elements disrupting your CSS.
</p>

<p>
`~slot$に何も明示的にアテガわれていない場合、代わりに `~slot$の自前の子たちが， “既定の” 内容としてアテガわれる。
◎
If nothing is explicitly assigned to a slot, the slot’s own children are instead assigned to it, as a sort of "default" contents.
</p>


		</section>
		<section id="selectors">
<h3 title="Shadow DOM and Selectors">3.2. ~shadow~DOMと選択子</h3>

			<section id="selectors-data-model">
<h4 title="Matching Selectors Against Shadow Trees">3.2.1. ~shadow~treeに対する選択子の照合-法</h4>

<p>
選択子が`~shadow~tree$に対し照合されるときの `selector match list^en†は、初期~時には，［
先頭の`~shadow~host$, および［
`~shadow~tree$の`~shadow根$
］の子孫すべて
］からなり、~tree順序にされるとする。
<!-- ordered by a pre-order traversal -->
◎
When a selector is matched against a shadow tree, the selector match list is initially the shadow host, followed by all children of the shadow tree’s shadow root and their descendants, ordered by a pre-order traversal.
</p>

<p class="trans-note">【†
この用語（ “選択子~照合-~list” ）は、 `SELECTORS4$r 仕様に定義されていたが，現在は廃され、照合する方法も含め，別の形で表現されている。
ここの, およびこの用語を参照している記述は、更新される必要がある。
】</p>

<p class="note">注記：
`~shadow~tree$は、要素の子孫には含まれない
— 要素の子孫は、`~light~tree$内の，要素の`子$に基づく。
◎
Note: Remember that the descendants of an element are based on the light tree children of the element, which does not include the shadow trees of the element.
</p>

<p>
`~treeに対し選択子を照合-$するときの
`~tree文脈@
は、［
その~algoに渡される %根~要素
］の`根$で与えられる。
`~tree文脈$が`~shadow根$であるとき、選択子は
`~shadow~treeの文脈~下@
で照合されてるという。
◎
When a selector is matched against a tree, its tree context is the root of the root elements passed to the algorithm. If the tree context is a shadow root, that selector is being matched in the context of a shadow tree.
</p>

<div class="example">
<p>
例えば、ある~stylesheetが，`~shadow~tree$内の［
要素~内に埋込まれて／
要素から~linkされて
］いるとき，その~stylesheet内のどの選択子も，`~shadow~treeの文脈~下$にある。
`~shadow根$上で~callされる `querySelector()$m に渡す選択子~引数も同様になる。
◎
For example, any selector in a stylesheet embedded in or linked from an an element in a shadow tree is in the context of a shadow tree. So is the argument to querySelector() when called from a shadow root.
</p>

</div>

<p>
宣言~block内の各~宣言は、それを適用するために照合した選択子の`~tree文脈$を継承する。
◎
Declarations inherit the tree context of the selector that was matched to apply them.
</p>



			</section>
			<section id="host-element-in-tree">
<h4 title="Selecting Shadow Hosts from within a Shadow Tree">3.2.2. ~shadow~treeの中から~shadow~hostを選択するとき</h4>

<p>
`~shadow~host$ %~host は、それが~hostする`~shadow~tree$ %~shadow~tree の外側にあるので、普通は，`~shadow~treeの文脈~下$で評価される選択子からは対象にできないが（選択子を照合する対象は，単独の~treeに制限される）、 %~shadow~tree の文脈の内側からも， %~host を~styleできれば有用になることもときどきある。
◎
A shadow host is outside of the shadow tree it hosts, and so would ordinarily be untargettable by any selectors evaluated in the context of the shadow tree (as selectors are limited to a single tree), but it is sometimes useful to be able to style it from inside the shadow tree context.
</p>

<ul>
	<li>
選択子の目的においては、 %~host も
— その子たちが %~shadow~tree の内容であるものと扱うように —
%~shadow~tree に現れる（言い換えれば、 %~host は，`~shadow根$
—  %~shadow~tree の根 — 
を置換するものとして扱われる）
◎
For the purpose of Selectors, a shadow host also appears in its shadow tree, with the contents of the shadow tree treated as its children. (In other words, the shadow host is treated as replacing the shadow root node.)
</li>
	<li>
%~host は、 %~shadow~tree の中では，`無特能$であると見なされ、合致し得る選択子は［
`host$ps ／ `host()$ps ／ `host-context()$ps
］疑似類に限られる。
◎
When considered within its own shadow trees, the shadow host is featureless. Only the :host, :host(), and :host-context() pseudo-classes are allowed to match it.
</li>
</ul>

<details class="note">
<summary>注記：
なぜ~shadow~hostは`無特能$にされているのか ？
◎
Why is the shadow host so weird?
</summary>

<p>
%~shadow~tree の外側に居る %~host の~markupは、
【~shadow~treeを内容とする】部品の作者ではなく，~page作者の制御~下にある。
◎
The shadow host lives outside the shadow tree, and its markup is in control of the page author, not the component author.
</p>

<p>
この部品が、 %~shadow~tree 内の~stylesheet内で，特定0の~class名を内部的に利用しているとする。
そのような部品を利用している~page作者が，同じ~class名を偶発的に %~host に利用した場合、良くないことが起こる。
そのような状況の結果，
【その~class名を選択する選択子を通して，~hostに】
偶発的にあてられる~styleは、部品~作者には予測-不可能であり，~page作者も~debugに戸惑うことになる。
◎
It would not be very good if a component used a particular class name internally in a shadow tree stylesheet, and the page author using the component accidentally also used the the same class name and put it on the shadow host. Such a situation would result in accidental styling that is impossible for the component author to predict, and confusing for the page author to debug.
</p>

<p>
しかしながら、 %~shadow~tree 内の~stylesheetが， %~host を~styleすることが適理な利用事例も依然としてある（例えば，その部品は~flexboxとして~lay-outするよう求められている場合、 %~host の `display$p を設定することが要求される）。
なので、この状況を許容しつつ，偶発的に~styleされないようにするため、 %~host は %~shadow~tree には現れるが、完全に`無特能$で，選択するためには部品~作者が明示的に［
`host$ps, あるいは `host()^ps, `host-context()^ps
］を通して~markupに合致させる他ないようにされている。
◎
However, there are still some reasonable use-cases for letting a stylesheet in a shadow tree style its shadow host. (For example, the component might want to be laid out as a flexbox, requiring the shadow host to be set to display: flex.) So, to allow this situation but prevent accidental styling, the shadow host appears but is completely featureless and unselectable except through :host and its related functional forms, which make it very explicit when you’re trying to match against markup provided by the page author.
</p>

</details>

			</section>
			<section id="host-selector">
<h4 title="Selecting Into the Light: the :host, :host(), and :host-context() pseudo-classes">3.2.3.  ~light~treeの中への選択-法： `host^ps, `host()^ps, `host-context()^ps 疑似類</h4>

<p>
`host@ps
疑似類は、`~shadow~treeの文脈~下$では，当の`~shadow~tree$を~hostしている`~shadow~host$に合致するように評価され、他の文脈~下では，何にも合致しない。
◎
The :host pseudo-class, when evaluated in the context of a shadow tree, matches the shadow tree’s shadow host. In any other context, it matches nothing.
</p>

<p>
関数形の疑似類
`host()@ps
の構文は、次で与えられる：
◎
The :host() function pseudo-class has the syntax:
</p>

<pre class="prod">
:host( `compound-selector-list$t )
</pre>

<p>
それは、`~shadow~treeの文脈~下$では，当の`~shadow~tree$を~hostしている`~shadow~host$であって, かつ［
通常の文脈~下で引数の選択子（`合体~選択子$`の~list$）にも合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, it matches the shadow tree’s shadow host if the shadow host, in its normal context, matches the selector argument. In any other context, it matches nothing.
</p>

<p>
`host$ps の`詳細度$は、疑似類のそれとする。
`host()$ps の`詳細度^は、疑似類のそれに引数の`詳細度^を足したものになる。
◎
The specificity of :host is that of a pseudo-class. The specificity of :host() is that of a pseudo-class, plus the specificity of its argument.
</p>

<p class="note">注記：
これは、 `matches()$ps や `not()$ps の様な，類似するが引数の詳細度しかとらない疑似類の詳細度と異なる。
そのわけは、 `host$ps が， “通常の” 疑似類の様に~~独力で【すなわち，引数なしでも】要素を選択するからである
— それは構文上の理由から引数に選択子をとるが（ `:host.foo^css に合致するなら `.foo^css にも合致させる必要がある）、他の点では，単に ある選択子が後続している `host^ps を利用することに一致する。
【 `:host.foo^css は `:host^css と `.foo^css の論理積を表すが、 `.foo^css 単体では~shadow~treeの外にあるものに合致できない。】
◎
Note: This is different from the specificity of similar pseudo-classes, like :matches() or :not(), which only take the specificity of their argument. This is because :host is affirmatively selecting an element all by itself, like a "normal" pseudo-class; it takes a selector argument for syntactic reasons (we can’t say that :host.foo matches but .foo doesn’t), but is otherwise identical to just using :host followed by a selector.
</p>

<div class="example">
<p>
例えば、次の様な`~shadow~tree$を伴う部品があるとするとき：
◎
For example, say you had a component with a shadow tree like the following:
</p>

<pre class="lang-ml">
&lt;x-foo class="foo"&gt;
  &lt;“~shadow~tree”&gt;
    &lt;div class="foo"&gt;...&lt;/div&gt;
  &lt;/&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow~tree$の中の~stylesheetにおいては：
◎
For a stylesheet within the shadow tree:
</p>

<ul>
	<li>
`host$ps は、 `x-foo^e 要素に合致する。
◎
:host matches the &lt;x-foo&gt; element.
</li>
	<li>
`x-foo^css は、何にも合致しない。
◎
x-foo matches nothing.
</li>
	<li>
`.foo^css は `div^e 要素のみに合致する。
◎
.foo matches only the &lt;div&gt; element.
</li>
	<li>
`.foo:host^css は、何にも合致しない
— `.foo^css は `x-foo^e 要素に合致しないので。
◎
.foo:host matches nothing
</li>
	<li>
`:host(.foo)^css は、 `x-foo^e 要素に合致する
— 引数の `.foo^css も合致するので。
◎
:host(.foo) matches the &lt;x-foo&gt; element.
</li>
</ul>

</div>

<p>
`~shadow~tree$の中の選択子からは、普通は，`~shadow~tree$の外側にある要素は全く見えない。
しかしながら、~shadow~treeの外側のどこか, 同じ文書~内の, より上位にある先祖を選択できると有用になることもときどきある。
◎
Ordinary, selectors within a shadow tree can’t see elements outside the shadow tree at all. Sometimes, however, it’s useful to select an ancestor that lies somewhere outside the shadow tree, above it in the document.
</p>

<div class="example">

<p>
例えば、一群の部品からなる~groupは、それぞれがどう応答するか知る，一握りの色~themeを定義することもある
— ~page作者が、［
それらの部品または, 文書~内のより上位
］に特定の~classを追加して，特定0の~themeを任意選択で選べるような。
◎
For example, a group of components can define a handful of color themes they they know how to respond to. Page authors could opt into a particular theme by adding a specific class to the components, or higher up in the document.
</p>

<p class="trans-note">【
すなわち、部品を内容に含ませている先祖にあてがわれた~classに応じて、利用する色~theme（部品どうしや, その内部の構成子たちの色合いが調和するように設計された，色の集合）を切り替える。
】</p>

</div>

<p>
関数形の疑似類
`host-context()@ps
は、`~shadow~tree$の外側に［
特定0の選択子に合致するような先祖
］があるかどうか~testする。
その構文は、次で与えられる：
◎
The :host-context() functional pseudo-class tests whether there is an ancestor, outside the shadow tree, which matches a particular selector. Its syntax is:
</p>

<pre class="prod">
:host-context( `compound-selector-list$t )
</pre>

<p>
`host-context()$ps
疑似類は、`~shadow~treeの文脈~下$では，［
当の~shadow~treeを~hostしている`~shadow~host$, または その`~shadowも含む先祖$
］のうち［
通常の文脈~下で引数の選択子（`合体~選択子$`の~list$）に合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, the :host-context() pseudo-class matches the shadow host, if the shadow host or one of its shadow-including ancestors matches the provided &lt;compound-selector-list&gt;. In any other context, it matches nothing.
</p>

<p>
`host-context()$ps の`詳細度$は、疑似類のそれに引数の`詳細度^を足したものになる。
◎
The specificity of :host-context() is that of a pseudo-class, plus the specificity of its argument.
</p>

<p class="note">注記：
これは、当の選択子は、［
文書の根に到達するか, 引数に合致する要素が見つかる
］まで，~shadow境界を貫くように遡ることを意味する。
◎
Note: This means that the selector pierces through shadow boundaries on the way up, looking for elements that match its argument, until it reaches the document root.
</p>

			</section>
			<section id="slotted-pseudo">
<h4 title="Selecting Slot-Assigned Content: the ::slotted() pseudo-element">3.2.4. ~slotにアテガわれた内容の選択-法： `slotted()^pe 疑似要素</h4>

<p>
`slotted()@pe
疑似要素は、`平坦化され$た上で`~slot$にアテガわれた要素たちを表現する。
この疑似要素は：
◎
The ::slotted() pseudo-element represents the elements assigned, after flattening, to a slot.＼
</p>

<ul>
	<li>
`~slot$上にのみ存在する。
【すなわち、当の~slotが，この疑似要素の`出自の要素$になる。】
◎
This pseudo-element only exists on slots.
</li>
	<li>
当の~tree内の他の要素を指す<em>別名</em>であり、それ自体は~boxを生成しない。
◎
The ::slotted() pseudo-element is an alias for other elements in the tree, and does not generate any boxes itself.
</li>
	<li>
<p>
その文法は、次で与えられる：
◎
The grammar of the ::slotted() pseudo-element is:
</p>

<pre class="prod">
::slotted( `compound-selector-list$t )
</pre>

	</li>
	<li>
<p>
次をいずれも満たす要素を表現する：
◎
The ::slotted() pseudo-element represents the elements that are:
</p>

		<ul>
			<li>
`平坦化され$て［
`slotted^pe の`出自の要素$である`~slot$
］にアテガわれている。
◎
assigned, after flattening, to the slot that is ::slotted’s originating element
</li>
			<li>
`要素に対し選択子を照合-$した結果、引数の `compound-selector-list$t （`合体~選択子$`の~list$）に合致する。
◎
matched by its &lt;compound-selector-list&gt; argument
</li>
		</ul>
	</li>
	<li>
<span class="css">`slotted()^pe`before^pe</span>
の様に，
<a href="~CSSPSEUDO#tree-abiding">~treeに留まる疑似要素</a>
を後続させれる
— それは、 `slotted()$pe 疑似要素により表現される要素を`出自の要素$とする適切な疑似要素を表現する。
◎
The ::slotted() pseudo-element can be followed by a tree-abiding pseudo-element, like ::slotted()::before, representing the appropriate pseudo-element of the elements represented by the ::slotted() pseudo-element.
</li>
</ul>

<p>
`slotted()$pe の`詳細度$は、疑似要素のそれに引数の`詳細度^を足したものになる。
◎
The specificity of ::slotted() is that of a pseudo-element, plus the specificity of its argument.
</p>

<div class="example">
<p>
例えば、次の様な［
子たち, および~shadow~tree
］を伴う部品があるとする：
◎
For example, say you had a component with both children and a shadow tree, like the following:
</p>

<pre class="lang-ml">
&lt;x-foo&gt;
  &lt;div id="one" slot="foo" class="foo"&gt;...&lt;/div&gt;
  &lt;div id="two" slot="foo"&gt;...&lt;/div&gt;
  &lt;div id="three" class="foo"&gt;
    &lt;div id="four" slot="foo"&gt;...&lt;/div&gt;
  &lt;/div&gt;
  &lt;“~shadow~tree”&gt;
    &lt;div id="five"&gt;...&lt;/div&gt;
    &lt;div id="six"&gt;...&lt;/div&gt;
    &lt;slot name="foo"&gt;&lt;/slot&gt;
  &lt;/&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow~tree$の中の~stylesheetにおいては、選択子 `::slotted(*)^css は，［
`#one^css, `#two^css
］のみを選択する
— それらはもっぱら `slot$e 要素に
<a href="~DOM4#find-flattened-slotables">アテガわれる要素</a>なので。
それは、 `slot^a 属性を有さない `#three^css は選択しない。
また、 `#four^css も選択しない（ `~slot$にアテガわれる~nodeは、`~shadow~host$の（直な）`子$に限られるので）。
◎
For a stylesheet within the shadow tree, a selector like ::slotted(*) selects #one and #two only, as they’re the elements assigned to the sole slot element. It will not select #three (no slot attribute) nor #four (only direct children of a shadow host can be assigned to a slot).
</p>

<p>
一方で， `::slotted(.foo)^css の様な選択子は、［
`#one^css, `#two^css
］のうち `.foo^css に合致する前者のみを選択する。
◎
A selector like ::slotted(.foo), on the other hand, will only select #one, as it matches .foo, but #two doesn’t.
</p>

<p class="note">注記：
`::slotted(*)^css
の様な選択子は、
`*::slotted(*)^css と等価になる
— 先頭の `*^css は、 `slot$e 要素の他にも多数の要素を選択するが、`~slot$になるのは `slot$e 要素に限られるので，合致するのは `slotted()$pe 疑似要素に合致する要素に限られる。
◎
Note: Note that a selector like ::slotted(*) is equivalent to *::slotted(*), where the * selects many more elements than just the slot element. However, since only the slot elements are slots, they’re the only elements with a ::slotted() pseudo-element as well.
</p>

</div>

<p class="note">注記：
`~slot$には~text~nodeもアテガえるが、それらは `slotted()$pe では表現されないので，選択できない。
そのような~text~nodeを~styleする仕方は、`~slot$を~styleした上で，継承に依拠する他にない。
◎
Note: ::slotted() can only represent the elements assigned to the slot. Slots can also be assigned text nodes, which can’t be selected by ::slotted(). The only way to style assigned text nodes is by styling the slot and relying on inheritance.
</p>

			</section>
		</section>
		<section id="shadow-cascading">
<h3 title="Shadow Trees and the Cascade">3.3. ~shadow~treeと~cascade</h3>

<p>
~shadow根~内の要素たちを対象にしている規則の~cascade法に欲される挙動に取組むため、この仕様は，
`CSS3CASCADE$r に定義される
<a href="~CASCADE#cascading">~cascade順序</a>
を拡張する。
◎
To address the desired cascading behavior of rules targetting elements in shadow roots, this specification extends the cascade order defined in the Cascade specification. [CSS3CASCADE]
</p>

<p>
`出自$cCと`視野$cCとの合間に，次の~cascade判定基準が追加されるモノトスル：
◎
An additional cascade criteria must be added, between Origin and Scope, called Shadow Tree.
</p>

<dl>
	<dt>`~shadow~tree@cC</dt>
	<dd>
`~tree文脈$が互いに異なる 2 つの宣言を比較するときは、通常の規則に対しては，`~shadowも含む~tree順序$において，先に来る
【実質的には、より先祖の~treeに属する】
宣言が勝つ。
`!important^css 規則に対しては、逆に，後に来る宣言が勝つ。
◎
When comparing two declarations that have different tree contexts, then for normal rules the declaration earlier in the shadow-including tree order wins, and for important rules the declaration coming later in the shadow-including tree order wins.
</dd>
	<dd class="note">注記：
これは、視野~付き~styleに対する場合と【先祖, 子孫の順位が】<em>逆になる</em>。
◎
Note: This is the opposite of how scoped styles work.
</dd>
</dl>


		</section>
		<section id="flattening">
<h3 title="Flattening the DOM into an Element Tree" data-algorithm="Flattening the DOM into an Element Tree">3.4. ~DOMから要素~treeへの平坦化-法</h3>

<p>
選択子は，~host言語が提示する~DOM~treeに対し演算するが、~CSSの他の部分が［
標準な 親／`子$ 関係性を介することでは到達-不能な，別々の~tree
］に働くためには、単一化された~tree構造が必要になる。
これは、
`平坦化された要素~tree@
（略して，`平坦~tree$）と呼ばれ，次に従って構築される
【この “平坦化-” は、要素の入子ではなく，~treeの入子を平坦化することを表す。】
：
◎
While Selectors operates on the DOM tree as the host language presents it, with separate trees that are unreachable via the standard parent/child relationship, the rest of CSS needs a single unified tree structure to work with. This is called the flattened element tree (or flat tree), and is constructed as follows:
</p>

<ol>
	<li>
%根 ~LET 文書の`根$要素
◎
↓</li>
	<li>
%処理待ち~node~list ~LET 空~list
— この~listは、 ( `~node^i, `親^i ) の組として与えられる~itemたちで拡充されることになる
◎
Let pending nodes be a list of DOM nodes with associated parents,＼
</li>
	<li>
%処理待ち~node~list に ( %根, ε ) を付加する
◎
initially containing just the document’s root element with no associated parent.
</li>
	<li>
%平坦~tree ~LET ε
◎
↓</li>
	<li>
<p>
~WHILE %処理待ち~node~list は空でない：
◎
Repeatedly execute the following substeps until pending nodes is empty:
</p>

		<ol>
			<li>
%~item ~LET %処理待ち~node~list の最初の~item
◎
↓</li>
			<li>
%処理待ち~node~list から %~item を除去する
◎
Pop the first element from pending nodes, and assign it to pending node.
</li>
			<li>
%~node ~LET %~item の `~node^i
◎
↓</li>
			<li>
~IF［
%平坦~tree ~NEQ ε
］
⇒
%~node を，%~item の `親^i の`子$として %平坦~tree の中に挿入する
◎
Insert pending node into the flat tree as a child of its associated parent.＼
</li>
			<li>
~ELSE
⇒
%平坦~tree ~SET %根 を根とする， %根 のみからなる新たな`平坦~tree$
◎
(If it has no associated parent, it’s the document root—just insert it into the flat tree as its root.)
</li>
			<li>
<p>
~IF［
%~node は`~shadow~host$である
］：
◎
Perform one of the following, whichever is the first that matches:
◎
pending node is a shadow host
</p>
				<ol>
					<li>
%~node が~hostしている`~shadow~tree$の`~shadow根$の
~EACH ( %子~node ) に対し
⇒
%処理待ち~node~list に
( %子~node, %~node )
を付加する
◎
Append the child nodes of the shadow root of the shadow tree it hosts to pending nodes, with pending node as their associated parent.
</li>
					<li>
~CONTINUE
</li>
				</ol>
			</li>
			<li>

<p>
~IF［
%~node は`~slot$である
］：
</p>
				<ol>
					<li>
%~slotable~list ~LET `~slot用に~slotableたちを見出す$( %~node )
</li>
					<li>
<p>
~IF［
%~slotable~list は空でない
］：
</p>

<ol><li>%~slotable~list 内の ~EACH( %~slotable ) に対し
⇒
%処理待ち~node~list に
( %~slotable, %~node )
を付加する
</li><li>~CONTINUE
</li></ol>
					</li>
				</ol>
◎
pending node is a slot
◎
Find slotables for pending node, and append them to pending nodes, with pending node as their associated parent.
◎
↓If no slotables were found for pending node, instead append its children to pending nodes, with pending node as their associated parent.
</li>
			<li>
%~node の~EACH( （`~light~tree$における）`子$ %子 ) に対し
⇒
%処理待ち~node~list に
( `子$, %~node )
を付加する
◎
Otherwise,
◎
Append the child nodes of pending node’s light tree to pending nodes, with pending node as their associated parent.
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>注記：
言い換えれば、`平坦~tree$は~top-level~DOM~treeであるが：
</p>
<ul>
	<li>
各`~shadow~host$は、その`~light~tree$内の子たちに代わって，`~shadow~tree$内の子たちで埋められる（更に，その`~shadow~tree$も`~shadow~host$を包含するならば，これを再帰的に続行する）
</li>
	<li>
各`~slot$は、それにアテガわれた~nodeたちで埋められる（更に，`~slot$自身が より深い`~shadow~tree$内の`~slot$がアテガわれたなら，これを再帰的に続行する）。
</li>
</ul>
◎
Note: In other words, the flat tree is the top-level DOM tree, but shadow hosts are filled with their shadow tree children instead of their light tree children (and this proceeds recursively if the shadow tree contains any shadow hosts), and slots get filled with the nodes that are assigned to them (and this proceeds recursively if the slots are themselves assigned to a slot in a deeper shadow tree).
</div>

<p class="issue">
これによる明白でない結果は、~slotにアテガわれた要素は、その~slotから【~styleを】継承することである
— 要素の~light~treeにおける親や, その~slotがアテガわれている より深い~slotでなく。
このことは、【~slotにアテガわれた】~text~nodeは、その親の~shadow~treeにより~styleされ，他からはどうやっても介入できないことを意味する。
そのような~text~nodeを対象にする追加的な疑似要素は，求められるか？
— それらにも，要素のときと同様に at all slot-assignment levels【？】で~styleできるように。
このことは、~light~tree内の~text~nodeに対しても，~slotに<!-- downwards -->アテガわれる前に，そのような疑似要素が働く必要があることを含意する。
なので、これは，ただの `slotted()$pe の変種にはなり得ない。
Luckily, this is a long-standing request!【何が Luckily？】
◎
A non-obvious result of this is that elements assigned to a slot inherit from that slot, not their light-tree parent or any deeper slots their slot gets assigned to. This means that text nodes are styled by the shadow tree of their parent, with nobody else capable of intervening in any way. Do we want an additional pseudo-element for targeting those text nodes so they can be styled at all slot-assignment levels, like normal elements can be? This implies it needs to work for text nodes in the light tree before they’re assigned downwards, so this can’t just be a ::slotted() variant. Luckily, this is a long-standing request!
</p>



			<section id="slots-in-shadow-tree">
<h4 title="Slots and Slotted Elements in a Shadow Tree">3.4.1. ~shadow~tree内の~slotとそれにアテガわれる要素</h4>

<p>
`~slot$は、［
`~UA出自$内の規則を介して，その `display$p に `contents$v がアテガわれている
］かのように動作するモノトスル。
これは、 `display$p を介して上書きできるモノトスル
— 欲されるときには、`~slot$が<em>~boxを生成できる</em>よう。
◎
Slots must act as if they were assigned display: contents via a rule in the UA origin. This must be possible to override via display, so they do generate boxes if desired.
</p>

<p class="trans-note">【
これは， `HTML$r では、~UA~stylesheetの
`slot{ display: contents }^css
規則として
<a href="~HTMLrendering#flow-content-3">実装されている</a>。
】</p>


<p class="note">注記：
`~slot$に要素をアテガうことによる明白でない結果は、要素は，その`~slot$から【~styleを】継承することである。
［
要素の親（`~light~tree$における要素の元の親）
］／［
その`~slot$もまた 他の`~slot$にアテガわれたとするときの，他の`~slot$
］は、継承には影響しない。
◎
Note: A non-obvious result of assigning elements to slots is that they inherit from the slot they’re assigned to. Their original light tree parent, and any deeper slots that their slot gets assigned to, don’t affect inheritance.
</p>



			</section>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">4. 変更点</h2>

<p>
<a href="https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/">2014 年 4 月 3 日付 作業草案</a>
からの有意な変更点は：
◎
The following significant changes were made since the 3 April 2014 Working Draft.
</p>

<ul>
	<li>
`content^pe を `slotted^pe に改称した。
◎
Renamed ::content to ::slotted.
</li>
	<li>
`平坦化された要素~tree$を定義した。
◎
Define the flattened tree
</li>
	<li>
Shadow DOM 節を，現在の `DOM$r に基づくように~~編成し直した。
◎
Generally reorg and rebase the Shadow DOM section on top of current DOM.
</li>
	<li>
`scope^at, `region^pe
に関係するものを次の~levelの草案まで~~先送りした。
◎
Punt @scope and related things, and ::region and related things, to the next level of the draft.
</li>
</ul>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">5. ~privacyと~security上の考慮点</h2>

<p>
この仕様は Shadow DOM および，ある~shadowを貫く能力を導入するが、それが何らかの［
~privacy／~security
］に課題を導入することはない
—  現在の~shadow ~DOMは、そのような境界にならないよう，意図的に指定されているので（また、
~UAの［
~shadow~DOMを利用する ／
そのような境界が<em>ある</em>
］部分は、暗黙的に未だ指定されていない保護に依拠している
— それはそれらをこの仕様にて定義されるものから保護する【？】
）。
◎
This specification introduces Shadow DOM and some shadow-piercing capabilities, but this does not introduce any privacy or security issues—shadow DOM, as currently specified, is intentionally not a privacy/security boundary (and the parts of the UA that use shadow DOM and do have a privacy/security boundary implicitly rely on protections not yet specified, which protect them from the things defined in this specification).
</p>

	</section>


<!-- 
<h2 title="Acknowledgments">謝辞</h2>
-->

</main></div>
