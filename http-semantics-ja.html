<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Semantics （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:HTTP Semantics
spec_date:2020-08-27
trans_update:2020-08-28
source_checked:200710
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
abbr_url:HTTPsem
spec_status:IETFID
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22

●●class_map

●●tag_map

●●original_id_map

●●mdn_urls
field.connection:HTTP/Headers/Connection
field.content-type:HTTP/Headers/Content-Type
field.content-encoding:HTTP/Headers/Content-Encoding
field.content-language:HTTP/Headers/Content-Language
field.content-length:HTTP/Headers/Content-Length
field.content-location:HTTP/Headers/Content-Location
field.content-range:HTTP/Headers/Content-Range
field.host:HTTP/Headers/Host
field.te:HTTP/Headers/TE
field.trailer:HTTP/Headers/Trailer
field.upgrade:HTTP/Headers/Upgrade
field.via:HTTP/Headers/Via

●●link_map
h.Received:~RFCx/rfc5322#section-3.6.7
h.Accept-Patch:~HTTPpatch#accept-patch
	RFC5789/3.1:~HTTPpatch#section-3.1
h.Keep-Alive:~HTTPmsg#compatibility.with.http.1.0.persistent.connections
h.Proxy-Connection:~HTTPmsg#compatibility.with.http.1.0.persistent.connections

p.example-list-elmt:~HTTPsem#p.example-list-elmt
p.example-list:~HTTPsem#p.example-list

c.bytes:~HTTPsem#_bytes
c.none:~HTTPsem#_none
c.q:~HTTPsem#c.q
c.trailers:~HTTPsem#_trailers-token

	:#rule.token.separators
	引用符~付き文字列:#rule.quoted-string
	:#rule.quoted-pair
	~comment:#rule.comment
	~parameter:#rule.parameter
	:#rule.ranges-specifier
	:#rule.ranges-specifier.suffix

	p.range-unit:#range.units
	p.first-pos:#rule.int-range
	p.int-range:#rule.int-range
	p.last-pos:#rule.int-range
	p.other-range:#rule.other-range
	p.range-set:#rule.ranges-specifier
	p.range-spec:#rule.ranges-specifier
	p.ranges-specifier:#rule.ranges-specifier
	p.suffix-length:#rule.suffix-range
	p.suffix-range:#rule.suffix-range

c.application/octet-stream:~RFCx/rfc2046#section-4.5.1

sdir.no-transform:~HTTPcache#cache-response-directive.no-transform

二重引用符:~HTTPcommon#P.DQUOTE

参加者:#participant
役割:#role
	接続:#connection
~secure化:#secured

絶対~形:#p.absolute-URI

~scheme:~HTTPsem#p.scheme
~host:~HTTPsem#p.host
~port:~HTTPsem#p.port
~path:~HTTPsem#p.path
素片:~HTTPsem#p.fragment
生成元:#origin
接続~option:~HTTPsem#connection-option

権限的:~HTTPsem#authoritative
権限的な応答:~HTTPsem#authoritative

形式変換ng~proxy:~HTTPsem#transforming-proxy
形式変換-:~HTTPsem#message.transformations
形式変換:~HTTPsem#message.transformations
要請~密入~攻撃:~HTTPmsg#request.smuggling
~chunked符号法:~HTTPmsg#chunked.encoding

鮮度維持期間:~HTTPcache#freshness-lifetime

既定の重み:~HTTPsem#defult-weight

cite.~URI~scheme~registry:~IANA-a/uri-schemes
cite.~HTTP~field名~registry:~IANA-a/http-fields/
cite.内容~符号法~registry:~IANA-a/http-parameters
cite.~HTTP範囲~単位~registry:~IANA-a/http-parameters
cite.~HTTP~method~registry:~IANA-a/http-methods
cite.~HTTP状態s~code~registry:~IANA-a/http-status-codes
cite.~HTTP認証~scheme~registry:~IANA-a/http-authschemes
cite.~HTTP Upgrade ~token~registry:~IANA-a/http-upgrade-tokens
	cite.文字集合~registry:~IANA-a/character-sets
	cite.~MIME型~registry

禁止~header名:~FETCH#forbidden-header-name

	●§
著作者の~address:#rfc.authors
1:~HTTPsem#introduction
1.1:~HTTPsem#intro.purpose
1.2:~HTTPsem#intro.evolution
1.3:~HTTPsem#intro.semantics
1.4:~HTTPsem#intro.obsoletes
1.5:~HTTPsem#intro.requirements
1.6:~HTTPsem#notation
1.6.1:~HTTPsem#whitespace
2:~HTTPsem#architecture
2.1:~HTTPsem#operation
2.2:~HTTPsem#intermediaries
2.3:~HTTPsem#caches
2.4:~HTTPsem#uri
2.5:~HTTPsem#resources
2.5.1:~HTTPsem#http.uri
2.5.2:~HTTPsem#https.uri
2.5.3:~HTTPsem#uri.comparison
2.5.4:~HTTPsem#http.userinfo
2.5.5:~HTTPsem#uri.fragment.identifiers
3:~HTTPsem#conformance
3.1:~HTTPsem#implementation-diversity
3.2:~HTTPsem#role-requirements
3.3:~HTTPsem#parsing-elements
3.4:~HTTPsem#error-handling
4.2:~HTTPsem#protocol.version
5:~HTTPsem#header.and.trailer.fields
5.1:~HTTPsem#field.order
5.2:~HTTPsem#field.limits
5.3:~HTTPsem#field.names
5.3.1:~HTTPsem#field.extensibility
5.3.2:~HTTPsem#field.name.registry
5.4:~HTTPsem#field.values
5.4.1:~HTTPsem#field.components
5.4.1.1:~HTTPsem#tokens
5.4.1.2:~HTTPsem#quoted.strings
5.4.1.3:~HTTPsem#comments
5.4.1.4:~HTTPsem#parameter
5.4.1.5:~HTTPsem#http.date
5.5:~HTTPsem#abnf.extension
5.5.1:~HTTPsem#abnf.extension.sender
5.5.2:~HTTPsem#abnf.extension.recipient
5.6:~HTTPsem#trailer.fields
5.6.1:~HTTPsem#trailers.purpose
5.6.2:~HTTPsem#trailers.limitations
5.6.3:~HTTPsem#trailers.processing
5.6.4:~HTTPsem#field.trailer
5.6.5:~HTTPsem#field.te
5.7:~HTTPsem#considerations.for.new.header.fields
5.8:~HTTPsem#field.definitions
6:~HTTPsem#message.routing
6.1:~HTTPsem#target.resource
6.2:~HTTPsem#origin
6.3:~HTTPsem#routing.inbound
6.3.1:#routing.cache
6.3.2:#routing.proxy
6.3.3:#routing.origin
6.3.3.1:~HTTPsem#http.origin
6.3.3.2:~HTTPsem#https.origin
6.3.3.3:~HTTPsem#https.verify
6.4:~HTTPsem#reconstructing.target.uri
6.5:~HTTPsem#field.host
6.6:~HTTPsem#message.forwarding
6.6.1:~HTTPsem#field.via
6.6.2:~HTTPsem#message.transformations
6.7:~HTTPsem#field.upgrade
6.7.1:~HTTPsem#upgrade.protocol.names
6.7.2:~HTTPsem#upgrade.token.registry
6.8:~HTTPsem#field.connection
7:~HTTPsem#representations
7.1:~HTTPsem#representation.data
7.1.1:~HTTPsem#media.type
7.1.1.1:~HTTPsem#charset
7.1.1.2:~HTTPsem#canonicalization.and.text.defaults
7.1.1.3:~HTTPsem#multipart.types
7.1.2:~HTTPsem#content.codings
7.1.2.1:~HTTPsem#compress.coding
7.1.2.2:~HTTPsem#deflate.coding
7.1.2.3:~HTTPsem#gzip.coding
7.1.2.4:~HTTPsem#content.coding.registry
7.1.3:~HTTPsem#language.tags
7.1.4:~HTTPsem#range.units
7.1.4.1:~HTTPsem#range.specifiers
7.1.4.2:~HTTPsem#byte.ranges
7.1.4.3:~HTTPsem#range.units.other
7.1.4.4:~HTTPsem#range.unit.registry
7.2:~HTTPsem#representation.metadata
7.2.1:~HTTPsem#field.content-type
7.2.2:~HTTPsem#field.content-encoding
7.2.3:~HTTPsem#field.content-language
7.2.4:~HTTPsem#field.content-length
7.2.5:~HTTPsem#field.content-location
7.3:~HTTPsem#payload
7.3.1:~HTTPsem#payload.purpose
7.3.2:~HTTPsem#identifying.payload
7.3.3:~HTTPsem#payload.body
7.3.4:~HTTPsem#field.content-range
7.3.5:~HTTPsem#multipart.byteranges
7.4:~HTTPsem#content.negotiation
7.4.1:~HTTPsem#proactive.negotiation
7.4.2:~HTTPsem#reactive.negotiation
7.4.3:~HTTPsem#request.payload.negotiation
7.4.4:~HTTPsem#quality.values

8:~HTTPrq#methods
8.1:~HTTPrq#method.overview
8.2:~HTTPrq#method.properties
8.2.1:~HTTPrq#safe.methods
8.2.2:~HTTPrq#idempotent.methods
8.2.3:~HTTPrq#cacheable.methods
8.3:~HTTPrq#method.definitions
8.3.1:~HTTPrq#GET
8.3.2:~HTTPrq#HEAD
8.3.3:~HTTPrq#POST
8.3.4:~HTTPrq#PUT
8.3.5:~HTTPrq#DELETE
8.3.6:~HTTPrq#CONNECT
8.3.7:~HTTPrq#OPTIONS
8.3.8:~HTTPrq#TRACE
8.4:~HTTPrq#method.extensibility
8.4.1:~HTTPrq#method.registry
8.4.2:~HTTPrq#considerations.for.new.methods
9:~HTTPrq#request.header.fields
9.1:~HTTPrq#request.controls
9.1.1:~HTTPrq#field.expect
9.1.2:~HTTPrq#field.max-forwards
9.2:~HTTPrq#preconditions
9.2.1:~HTTPrq#evaluation
9.2.2:~HTTPrq#precedence
9.2.3:~HTTPrq#field.if-match
9.2.4:~HTTPrq#field.if-none-match
9.2.5:~HTTPrq#field.if-modified-since
9.2.6:~HTTPrq#field.if-unmodified-since
9.2.7:~HTTPrq#field.if-range
9.3:~HTTPrq#field.range
9.4:~HTTPrq#request.conneg
9.4.1:~HTTPrq#field.accept
9.4.2:~HTTPrq#field.accept-charset
9.4.3:~HTTPrq#field.accept-encoding
9.4.4:~HTTPrq#field.accept-language
9.5:~HTTPrq#request.auth
9.5.1:~HTTPrq#challenge.and.response
9.5.2:~HTTPrq#protection.space
9.5.3:~HTTPrq#field.authorization
9.5.4:~HTTPrq#field.proxy-authorization
9.5.5:~HTTPrq#auth.scheme.extensibility
9.5.5.1:~HTTPrq#auth.scheme.registry
9.5.5.2:~HTTPrq#considerations.for.new.auth.schemes
9.6:~HTTPrq#request.context
9.6.1:~HTTPrq#field.from
9.6.2:~HTTPrq#field.referer
9.6.3:~HTTPrq#field.user-agent

10:~HTTPrs#status.codes
10.1:~HTTPrs#overview.of.status.codes
10.2:~HTTPrs#status.1xx
10.2.1:~HTTPrs#status.100
10.2.2:~HTTPrs#status.101
10.3:~HTTPrs#status.2xx
10.3.1:~HTTPrs#status.200
10.3.2:~HTTPrs#status.201
10.3.3:~HTTPrs#status.202
10.3.4:~HTTPrs#status.203
10.3.5:~HTTPrs#status.204
10.3.6:~HTTPrs#status.205
10.3.7:~HTTPrs#status.206
10.3.7.1:~HTTPrs#partial.single
10.3.7.2:~HTTPrs#partial.multipart
10.3.7.3:~HTTPrs#combining.byte.ranges
10.4:~HTTPrs#status.3xx
10.4.1:~HTTPrs#status.300
10.4.2:~HTTPrs#status.301
10.4.3:~HTTPrs#status.302
10.4.4:~HTTPrs#status.303
10.4.5:~HTTPrs#status.304
10.4.6:~HTTPrs#status.305
10.4.7:~HTTPrs#status.306
10.4.8:~HTTPrs#status.307
10.5:~HTTPrs#status.4xx
10.5.1:~HTTPrs#status.400
10.5.2:~HTTPrs#status.401
10.5.3:~HTTPrs#status.402
10.5.4:~HTTPrs#status.403
10.5.5:~HTTPrs#status.404
10.5.6:~HTTPrs#status.405
10.5.7:~HTTPrs#status.406
10.5.8:~HTTPrs#status.407
10.5.9:~HTTPrs#status.408
10.5.10:~HTTPrs#status.409
10.5.11:~HTTPrs#status.410
10.5.12:~HTTPrs#status.411
10.5.13:~HTTPrs#status.412
10.5.14:~HTTPrs#status.413
10.5.15:~HTTPrs#status.414
10.5.16:~HTTPrs#status.415
10.5.17:~HTTPrs#status.416
10.5.18:~HTTPrs#status.417
10.5.19:~HTTPrs#status.426
10.6:~HTTPrs#status.5xx
10.6.1:~HTTPrs#status.500
10.6.2:~HTTPrs#status.501
10.6.3:~HTTPrs#status.502
10.6.4:~HTTPrs#status.503
10.6.5:~HTTPrs#status.504
10.6.6:~HTTPrs#status.505
10.7:~HTTPrs#status.code.extensibility
10.7.1:~HTTPrs#status.code.registry
10.7.2:~HTTPrs#considerations.for.new.status.codes
11:~HTTPrs#response.header.fields
11.1:~HTTPrs#response.control.data
11.1.1:~HTTPrs#field.date
11.1.2:~HTTPrs#field.location
11.1.3:~HTTPrs#field.retry-after
11.1.4:~HTTPrs#field.vary
11.2:~HTTPrs#response.validator
11.2.1:~HTTPrs#weak.and.strong.validators
11.2.2:~HTTPrs#field.last-modified
11.2.2.1:~HTTPrs#lastmod.generation
11.2.2.2:~HTTPrs#lastmod.comparison
11.2.3:~HTTPrs#field.etag
11.2.3.1:~HTTPrs#entity.tag.generation
11.2.3.2:~HTTPrs#entity.tag.comparison
11.2.3.3:~HTTPrs#example.entity.tag.vs.conneg
11.2.4:~HTTPrs#when.to.use.entity.tags.and.last-modified.dates
11.3:~HTTPrs#response.auth
11.3.1:~HTTPrs#field.www-authenticate
11.3.2:~HTTPrs#field.proxy-authenticate
11.4:~HTTPrs#response.context
11.4.1:~HTTPrs#field.accept-ranges
11.4.2:~HTTPrs#field.allow
11.4.3:~HTTPrs#field.server
12:~HTTPsem#security.considerations
12.1:~HTTPsem#establishing.authority
12.2:~HTTPsem#risks.intermediaries
12.3:~HTTPsem#attack.pathname
12.4:~HTTPsem#attack.injection
12.5:~HTTPsem#attack.protocol.element.length
12.7:~HTTPsem#personal.information
12.8:~HTTPsem#privacy.of.server.log.information
12.9:~HTTPsem#sensitive.information.in.uris
12.10:~HTTPsem#fragment.disclosure
12.11:~HTTPsem#disclosure.product.information
12.12:~HTTPsem#fingerprinting
12.13:~HTTPsem#security.validators
12.14:~HTTPsem#overlapping.ranges
12.15:~HTTPsem#security.auth
12.15.1:~HTTPsem#confidentiality.of.credentials
12.15.2:~HTTPsem#auth.credentials.and.idle.clients
12.15.3:~HTTPsem#protection.spaces
13:~HTTPsem#IANA.considerations
	13.1:~HTTPsem#uri.scheme.registration
	13.2:~HTTPsem#method.registration
	13.3:~HTTPsem#status.code.registration
	13.4:~HTTPsem#header.field.registration
	13.5:~HTTPsem#auth.scheme.registration
	13.6:~HTTPsem#content.coding.registration
	13.7:~HTTPsem#range.unit.registration
	13.8:~HTTPsem#media.type.reg
15:~HTTPsem#rfc.references

A:~HTTPsem#collected.abnf
B:~HTTPsem#changes.from.previous.rfcs
B.1:~HTTPsem#changes.from.rfc.2818
B.2:~HTTPsem#changes.from.rfc.7230
B.3:~HTTPsem#changes.from.rfc.7231
B.4:~HTTPsem#changes.from.rfc.7232
B.5:~HTTPsem#changes.from.rfc.7233
B.6:~HTTPsem#changes.from.rfc.7235
B.7:~HTTPsem#changes.from.rfc.7538
B.8:~HTTPsem#changes.from.rfc.7615
B.9:~HTTPsem#changes.from.rfc.7694
C:~HTTPsem#change.log
	C.1:~HTTPsem#changes.since.publication.as.rfc
	C.2:~HTTPsem#changes.since.00
	C.3:~HTTPsem#changes.since.01
	...
C.13:~HTTPsem#change.log

Caching/2:~HTTPcache#caching.overview
Caching/~cache制御~拡張:~HTTPcache#cache.control.extensions
Caching/7:~HTTPcache#security.considerations
Messaging/3.3:~HTTPmsg#reconstructing.target.uri
Messaging/5.1:~HTTPmsg#field.parsing
Messaging/5.2:~HTTPmsg#line.folding
Messaging/6:~HTTPmsg#message.body
Messaging/6.2:~HTTPmsg#body.content-length
Messaging/B:~HTTPmsg#differences.between.http.and.mime
Messaging/11:~HTTPmsg#security.considerations
Messaging/2.1:~HTTPmsg#message.format
Messaging/7.1.2:~HTTPmsg#chunked.trailer.section

●●words_table1

●●words_table

	●network／環境
UNIX:
IP:
DNS:
HTTP-to-HTTP:
HTTP2:HTTP/2
HTTP3:HTTP/3
HTTP09:HTTP/0.9
	~web~site:website
NTP:
UDP:
QUIC:
HPACK:
hostname::::ホスト名
	~frame法:framing
intercept:
interception:
captive:
subscription:
multicast::::マルチキャスト
broadcast::::ブロードキャスト
off-line::::オフライン
加速器:accelerator::~::アクセラレータ
worldwide:
区割り:partitioning:~
大陸間:transoceanic:~
負荷分散-:load balance:~
負荷分散:load balancing:~
高遅延:high-latency:~
委譲-:delegate:~
node::::ノード
巡る:crawlする:~
家電:household appliance:~
	home appliance
firmware::::ファームウェア
視聴覚機器:stereo::~
計測機器:scale:~
交通camera:traffic camera:交通カメラ
住宅用自動化設備:home automation unit:~
事務機械:office machine:OA 機器
自律型robot:autonomous robot:自律型ロボット
news-feed:news feed:::ニュースフィード
	ad selectors:
動画配信:video-delivery::動画配信::ビデオ配信
mobile::::モバイル
国別:national:~
分析:analysis:~
医療:medical:~
科学的:scientific:~
画像処理:imaging:~
消費:consumption:~
多重化-:multiplex::~

	World Wide Web

	●構文
US-ASCII:
underscore::::アンダースコア
hyphen::::ハイフン
semicolon::::セミコロン
period::::ピリオド
エスケープ:quote::~
空白列:linear whitespace::~
縮約-:collapse:~
印字可能:visual:~
小数点:decimal point:~
数字:digit:~
数字列:numerals:~
数量-:numeric:~
丸括弧:parentheses:~
正規:normal::~
改行:line break:~
wildcard::::ワイルドカード
	片:fragment:~
封入法:envelope::~
構成-:compose:~
	構成し直-:recompose
英数字:alphanumeric character:~
封入-:enclose:~
省かれ:elideされ:~

	構文~的に:syntactically
	固定的な長さ:fixed-length
	前後:around

	●範囲
単位:unit:~
接頭-:prefix::~
区分-:partition:~
p-s-r-r-t:pages, sections, records, rows, time:::ページ, セクション, レコード, 行, 時区間
	~~尾部:suffix
	先頭:beginning
	付番され:numbered
	列:sequence
	~address可能:addressable
	〜から:rerative

	●保安
malware::::マルウェア
phishing::::フィッシング
罠:pitfall:落とし穴
反射攻撃:replay attack::~
密入:smuggling::~
真正性:authenticity::~
能動的:active::~
証明書:certificate::~
識別情報:identity::~
非公開の:non-publicな:~
不特定多数の:multitude:~
銘柄:branding:~
流出:publish:~
本物の:realな:~
集めら:gatherさ:~
危険:dangerous:~
迂回-:bypass:~
匿名化:anonymization:~
疑似匿名:pseudonymous:~
	~~感受性が~~高い:susceptible
whitelist::::ホワイトリスト
予防策:precaution:~
個人識別可能:personally-identifiable:~
厄介な:annoying:~
民族:ethnic group:~
防ぐ:prevent する:~
防護:guard::~
製品:product::~
維持:retention:~
未保護:unprotected::~
秘密鍵:private key::~
監査:audit:~
検査情報:check:~
不用意:accidental:~
証明:proof:~
権威ある:definitiveな:~
帰属-:attribute:~
冗長性:redundancy::~
SQL:
	信用に価し得る:trustworthy
	検証y-可能に:verifiably
	晒し:expose
	晒され:-
	~~無防備に:leaves 〜 open
	~secure化され:secured
	誤って~directされた:misdirected
	なりすます:impersonation

	●仕様
誤誘導:mislead:~
場当的:ad hoc:場当たり的
critical:
scale::::スケール
	~scale能:scalability
mailing-list:mailing list:::メーリングリスト
確認:confirmation:~
主張-:claim:~
行動様式:reading pattern:~
関心事:subjects of interest:~
確立:establishment::~
無視r:disregard:無視することに
動詞:verb:~
代表者:delegate:~
任命-:appoint:~
指名-:designate:~
専門家:expert:~
助言:advice:~:::アドバイス
暫定的:provisional:~
協議:consultation:~
規制:regulations:~
不整合:inconsistency:~
法律:laws:~
social:
発展-:evolve:~
発展:evolution:~
放棄-:abandon:~
甚しい:egregiousな:~
拒否-:refuse:~
時事的:topical:~
論題:topic:~
解決s:solve:解決
奇妙:bizarre:~
引換関係:trade-off:引き換え関係
想定:envision:~
成員:membership:~
補助的:auxiliary:~
事実調査:research:~
限定-:confine:~
推定-:infer:~
矛盾-:contradict:~
発見:discovery:~
	発見-:discovery
実質上の:substantiveな:~
解釈器:interpreter:~
指示書き:instruction:~
指示命令:instruction:~
必要最小限:minimal:~
過剰:superfluous:~
俗に:colloquialに:~
超越-:transcend:~
揃える:alignする:~
拡げら:expandさ:~
再構成-:refactor:~
人為的:artificial:~
起点:anchor:~
手配-:arrange:~
	予め手配-:prearrange
同意t:consent:同意（または黙認）
機能:function:~
表出:expression:~
地点:point:~
仮の:hypotheticalな:~
招いて:inviteして:~
復旧-:restore::~
参照r:refer:参照
進展-:progress:~
成長-:grow:~
些細:trivial:~
衝突:collision:~
独立性:independence:~
邪魔-:hinder:~

	IESG
	^en:standards track
	実効:effective
	読み易く:readability を improve
	引き換え:commission:引き換え
	~~明らか:apparent
	~~見かけの:apparent
	~~精確に~~述べる:delineate
	必要十分でない:inadequate
	~~簡単に:readily
	~~適した:readily
	関知しない:no awareness
	考えに陥り易い:fall into a trap of thinking
	受け持つ:partake
	~~供する:serve as
	~~無関心に:without regard to
	定める:label
	~~手間を要する:suffers from the
	親切さ:-friendliness
	遂げられ:carried out
	~~講じる:take
	~~究極の~privacy~~保護措置:extreme privacy measure
	~~順調:nicely
	より~~適化する:optimistic
	~~最善:at best
	~~最悪:at worst
	勧める:advised to
	立場にある:privy
	立場に:position
	~~帰属:vesting
	〜とも呼ばれる:a.k.a
	すなわち:a.k.a
	当を得た選択〜right choice
	~~高度:high degree of
	~~総称される:collectively referred to as
	ごくありふれている:extremely common
	そのため:To that end
	無用:needless／:needlessly
	独り占め:squatting
	よく知られた:well-known
	失敗した所:in the event of 〜 failure
	限定的に利用される:limited-use
	略語:abbreviation:~
	Foo
	Application
	Description
	よって:hence
	~~基準に:with respect to
	イミを成し得る:sensible
	別物:distinct
	問わず:regardless
	〜向け:oriented
	~~可能性がある:potential
	〜としても:potential
	なり得る:potential
	~~可能性:potentially
	上で述べた:above-described
	満たす:meet
	くつがえす:unmade
	必要がある:will necessarily
	とても:very
	最小でも:at a minimum
	少なくとも〜に足る:sufficient minimum
	よって:hence
	~~普通に見られる:common
	そのため、:and consequently
	／除き〜は別として:aside from
	優先:take precedence
	視る:view
	踏んで:take
	今や:now
	~~緩め:loosen
	好ましい:preferably
	に特有なそれ:specifics of
	区別:distinction
	有用さ:usefulness
	何者か:whomever
	ごく:very
	そうであっても:nevertheless
	用意はない:unwilling
	その結果:in turn
	責を負う:responsible
	割愛する:leaves out
	それぞれの:respective
	避けれない:unavoidable
	~~恒久的に居残る:stays forever
	窓口:point of
	成せる~~立場にある:situated for
	予め〜と見做される資源:presumed
	始まった:began
	誤って:erroneously
	際どい:edge
	再利用-能:reusability

	●未分類
透過的:transparent::~
逐語的:verbatim:~
background::::バックグラウンド
鮮度維持期間:freshness lifetime::~
	鮮度維持期間:freshness time
command-line::::コマンドライン
overflow::::オーバーフロー
routine::::ルーチン
install::::インストール
pipe::::パイプ
digital::::デジタル
point::::ポイント
	~access~point
listener::::リスナ
	その~code化:coding
multi-tenant::::マルチテナント
流れる:flowする:~
完全修飾:fully qualified::~
単線:linear:~
参照先の:referenced:~
切落して:truncateして:切り落として
変名:variation:~
後続-:follow:~
形状:shape:~
中間:intermediation:~
仮想:virtual::~
稼働時:run-time:~
未登録の:unregistered:~
logout::::ログアウト
commit::::承諾
採取-:harvest:~
延長-:extend:~
総計:total:~
増やさ:incrementさ:~
増分的:incremental:~

Canada::カナダ
Danish::デンマーク語
Maori::マオリ語
directory::::ディレクトリ
intranet::::イントラネット
peer::::ピア
subscription:
display::::ディスプレイ

会話-:communicate:~
保つ:keepする:~
入門書:primer:~
sniff:
	~sniff法:sniffing
傾向:tendency:~
傾向に:tendに:~
underscore::::アンダースコア
hyphen::::ハイフン

再組成:recomposition:~
分散-:distribute:~
初学者:beginner:~
排他的:mutually exclusive:~
文0:statement::文
時間帯:zone::~
窓:window:~
符号化形:coded form::~::コード化形
紙:paper:~
自動解凍-:automatic に decompress:~
視聴者:audience:~
話者:-literate audience:~
購入:purchase:~
配達:deployment:~
領収書:receipt document:~
遅い:slowな:~
変形-:transform::~
拡げる:expandする:~
選好順:descending preference の order:選好度の高い順
固定的:fixed:~
序数:ordinal:~
反復的:iterative:~

	場を占める:take place
	組:triple
	入って来る:incoming
	始める:begin
	その場で:on the fly
	~~遡る:follow〜back to
	:Specification Required
	ワイタンギ条約:Treaty of Waitangi
	型~付け:typing
	~~通過中:transit
	失われ:lost
	個数:cardinality
	0 〜 1 個の／ 0 個以上の~potential
	encryption
	32-bit
	CRC
	LZ77
	Huffman
	zlib
	Microsoft Windows
	渡され:passed
	~~大文字頭字:capitalization
	~~前身:predecessor
	~~グリニッジ~~平均時
	~~頭字語:abbreviation
	最下~層のものから昇順に:layer-ascending order
	切り替え-:shift
	？:conclude

	●言い換え
	依存-:dependent
	参照を解く:dereference
	環境設定:configuration setting
	根とする:rooted in
	伝送路~上の:on-wire
	伝送-:transmission
	運用~上の:operational
	期間は〜不定:indefinitely
	期間:time period
	内容~符号法:content-coding
	〜な時間内に:within 〜 period of time
	何らかの型の:some type(s)
	範囲に含まれ:inclusive／inclusive numbered parts
	結合し直:recombine
	暗号化されてない:unencrypted
	拘束されない:unconstrained
	労力:effort required
	~~完全に:quite
	中核を成す:core
	内包しない:missing
	識別し直-:re-identify
	再~識別:re-identification
	資質からして:in nature
	してもらう:encourage
	~~仕向ける:telling
	利用者に知覚される:user-perceived
	引用符~無し／有無:unquoted
	環境設定-能:configurability
	~whitelist化:whitelisted
	英語の一方言:variety of English
	まず予期しない:least expected
	賢明でない:unwise
	向こう側で 独立に動作する者:independent actor on the other side
	力点を置く傾向に:tend to focus on
	特に関心を引くもの:of particular interest
	~~増やす:degrade
	類する:analogous な
	代わるもの:replacement
	各用紙に刷られる:added to templates
	現れる:appear
	当の:the respective
	同じさ度合い:sameness
	まず〜ない:least
	至らせる:drawする
	~~代理する:take the place of
	再掲-:restate
	になり得る:potential
	〜から:rerative
	~~連続する一連の:ordered subsequence
	単純にするため:for simplicity
	-:fashion
	依存しない:independent
	少なくとも:minimum
	それでも:Regardless,
	等しく:equally
	判別-不能:indistinguishable
	直近:immediate
	共用~辞書:shared-dictionary
	内容~符号法:content-codings
	転送~符号法:transfer-codings
	~streamにおける中途:mid-stream
	期待されるもの:expectation
	~frame化:framing
	見つけようと:looking for

	●他の語
	^i:ORIGIN

	早く:early
	変わり続ける:continue changing in the future
	多種多様:wide variety of
	~~位置:offset
	僅か:tiny
	位置:position
	位置／番:offset
	順不同:out of order
	再度〜促す:re-prompt
	~~前提:presume
	:easier
	^en:auditing
	^en:fraud control
	`DQUOTE$P:double-quote mark
	message回送:message-forwarding
	渡り歩く:travel
	~sizeや形状が様々な:in a multitude of shapes and sizes
	~~事前の:advance
	~~直に~code化:hard-coded
	~~適用する:target
	~~領域:space
	いくらでも:full
	もたらす／:cause
	一連の:sequence
	~~周知:commonly known
	圧縮-済み:compressed
	変わり続け:continue changing
	~~変遷:changed over the course of
	~~多岐に~~渡る:vary widely
	~~多量ではない:not so much
	~~多量:large amounts
	目立つ様に:prominently
	繋がる:becomes an avenue
	~~虚偽:false
	~~補強-:aid
	誰も:anyone
	通り抜けられるようにする:satisfy〜through
	~~長大:very long
	~~長過ぎる:too long
	~~一過性の:transitory
	~~正常に~~処理されました。:It worked!
	~~単独の:bare
	~~伝える:tell
	~~長さ~~無制限:unbounded
	~~生じさせた:resulted in
	短さ:as short as
	~~直前:just prior to
	保存:…Save as ...
	文字大小の正規化:case-normalization
	抗-:against
	短い:short
	ほぼ:mostly
	最終的な:final
	最終的:ultimately
	各自の:own
	~direct:at the direction of
	他よりずっと:by far the most
	の近くに:closer
	置く:placing
	〜までは:〜and earlier
	各部:parts
	低-:low-
	次に:next
	より高い:greater
	より広:greater
	総体としての:overall

●●section_map
	#rfc.abstract:SECTION
	#rfc.note.1:SECTION
	#rfc.status:SECTION
	#rfc.copyrightnotice:SECTION

	謝辞:~HTTPsem#acks:
	index:~HTTPsem#rfc.index
	著作者:~HTTPsem#rfc.authors

●●ref_data
RFC6585=副            ~/http-status-code-428-429-431-511-ja.html
SNIFFING=副           ~/mimesniff-ja.html
RFC7538=副            ~/http-status-code-308-ja.html
RFC7540=副            summerwind.jp/docs/rfc7540/
RFC7541=副            syucream.github.io/hpack-spec-ja/rfc7541-ja.html
RFC8246=副            ~/http-immutable-response-ja.html

●●ref_normative
[Caching]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP Caching”, Internet-Draft (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html
[Messaging]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP/1.1 Messaging”, Internet-Draft (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-messaging-latest.html
[RFC0793]
    Postel, J., “Transmission Control Protocol”, STD 7, ~RFC793, September 1981
[RFC1950]
    Deutsch, L. and J-L. Gailly, “ZLIB Compressed Data Format Specification version 3.3”, ~RFC1950, May 1996
[RFC1951]
    Deutsch, P., “DEFLATE Compressed Data Format Specification version 1.3”, ~RFC1951, May 1996
[RFC1952]
    Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and G. Randers-Pehrson, “GZIP file format specification version 4.3”, ~RFC1952, May 1996
[RFC2045]
    Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies”, ~RFC2045, November 1996
[RFC2046]
    Freed, N. and N. Borenstein, “Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types”, ~RFC2046, November 1996
[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, ~RFC2119, March 1997
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, ~RFC3986, January 2005
[RFC4647]
    Phillips, A., Ed. and M. Davis, Ed., “Matching of Language Tags”, BCP 47, ~RFC4647, September 2006
[RFC4648]
    Josefsson, S., “The Base16, Base32, and Base64 Data Encodings”, ~RFC4648, October 2006
[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, ~RFC5234, January 2008
[RFC5646]
    Phillips, A., Ed. and M. Davis, Ed., “Tags for Identifying Languages”, BCP 47, ~RFC5646, September 2009
[RFC6125]
    Saint-Andre, P. and J. Hodges, “Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)”, ~RFC6125, March 2011
[RFC6365]
    Hoffman, P. and J. Klensin, “Terminology Used in Internationalization in the IETF”, BCP 166, ~RFC6365, September 2011
[RFC7405]
    Kyzivat, P., “Case-Sensitive String Support in ABNF”, ~RFC7405, December 2014
[RFC8174]
    Leiba, B., “Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words”, BCP 14, ~RFC8174, May 2017
[USASCII]
    American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI X3.4, 1986.
[Welch]
    Welch, T., “A Technique for High-Performance Data Compression”, IEEE Computer 17(6)

●●ref_informative

[BCP13]
    Freed, N., Klensin, J., and T. Hansen, “Media Type Specifications and Registration Procedures”, BCP 13, ~RFC6838, January 2013
[BCP178]
    Saint-Andre, P., Crocker, D., and M. Nottingham, “Deprecating the "X-" Prefix and Similar Constructs in Application Protocols”, BCP 178, ~RFC6648, June 2012
[BCP35]
    Thaler, D., Ed., Hansen, T., and T. Hardie, “Guidelines and Registration Procedures for URI Schemes”, BCP 35, ~RFC7595, June 2015
[BREACH]
    Gluck, Y., Harris, N., and A. Prado, “BREACH: Reviving the CRIME Attack”, July 2013, URL: http://breachattack.com/resources/BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf
[Bujlow]
    Bujlow, T., Carela-Espanol, V., Sole-Pareta, J., and P. Barlet-Ros, “A Survey on Web Tracking: Mechanisms, Implications, and Defenses”, Proceedings of the IEEE 105(8), August 2017.
    URL: http://dx.doi.org/10.1109/JPROC.2016.2637878
[Err1912]
    RFC Errata, Erratum ID 1912, RFC 2978, URL: https://www.rfc-editor.org/errata/eid1912
[Err5433]
    RFC Errata, Erratum ID 5433, RFC 2978, URL: https://www.rfc-editor.org/errata/eid5433
[Georgiev]
    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, “The Most Dangerous Code in the World: Validating SSL Certificates in Non-browser Software”, DOI 10.1145/2382196.2382204, In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49, October 2012. URL: http://dx.doi.org/10.1145/2382196.2382204
[HTTP3]
    Bishop, M., “Hypertext Transfer Protocol Version 3 (HTTP/3)”, Internet-Draft draft-ietf-quic-http-29 (work in progress), June 2020.
    URL: https://tools.ietf.org/html/draft-ietf-quic-http-29
[ISO-8859-1]
    International Organization for Standardization, “Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1”, ISO/IEC 8859-1:1998, 1998. 
[Kri2001]
    Kristol, D., “HTTP Cookies: Standards, Privacy, and Politics”, ACM Transactions on Internet Technology 1(2), November 2001, URL: http://arxiv.org/abs/cs.SE/0105018
[OWASP]
    van der Stock, A., Ed., “A Guide to Building Secure Web Applications and Web Services”, The Open Web Application Security Project (OWASP) 2.0.1, July 2005, URL: https://www.owasp.org/
[REST]
    Fielding, R., “Architectural Styles and the Design of Network-based Software Architectures”, Doctoral Dissertation, University of California, Irvine, September 2000, URL: https://roy.gbiv.com/pubs/dissertation/top.htm
[RFC1919]
    Chatel, M., “Classical versus Transparent IP Proxies”, ~RFC1919, March 1996
[RFC1945]
    Berners-Lee, T., Fielding, R., and H. Nielsen, “Hypertext Transfer Protocol -- HTTP/1.0”, ~RFC1945, May 1996
[RFC2047]
    Moore, K., “MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text”, ~RFC2047, November 1996
[RFC2068]
    Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, ~RFC2068, January 1997
[RFC2145]
    Mogul, J., Fielding, R., Gettys, J., and H. Nielsen, “Use and Interpretation of HTTP Version Numbers”, ~RFC2145, May 1997
[RFC2295]
    Holtman, K. and A. Mutz, “Transparent Content Negotiation in HTTP”, ~RFC2295, March 1998
[RFC2324]
    Masinter, L., “Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)”, ~RFC2324, 1 April 1998
[RFC2557]
    Palme, F., Hopmann, A., Shelness, N., and E. Stefferud, “MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)”, ~RFC2557, March 1999
[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, ~RFC2616, June 1999
[RFC2617]
    Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, “HTTP Authentication: Basic and Digest Access Authentication”, ~RFC2617, June 1999
[RFC2774]
    Frystyk, H., Leach, P., and S. Lawrence, “An HTTP Extension Framework”, ~RFC2774, February 2000
[RFC2818]
    Rescorla, E., “HTTP Over TLS”, ~RFC2818, May 2000
[RFC2978]
    Freed, N. and J. Postel, “IANA Charset Registration Procedures”, BCP 19, ~RFC2978, October 2000
[RFC3040]
    Cooper, I., Melve, I., and G. Tomlinson, “Internet Web Replication and Caching Taxonomy”, ~RFC3040, January 2001
[RFC4033]
    Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, “DNS Security Introduction and Requirements”, ~RFC4033, March 2005
[RFC4559]
    Jaganathan, K., Zhu, L., and J. Brezak, “SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows”, ~RFC4559, June 2006
[RFC4918]
    Dusseault, L., Ed., “HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)”, ~RFC4918, June 2007
[RFC5322]
    Resnick, P., “Internet Message Format”, ~RFC5322, October 2008
[RFC5789]
    Dusseault, L. and J. Snell, “PATCH Method for HTTP”, ~RFC5789, March 2010
[RFC5905]
    Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, “Network Time Protocol Version 4: Protocol and Algorithms Specification”, ~RFC5905, June 2010
[RFC6265]
    Barth, A., “HTTP State Management Mechanism”, ~RFC6265, April 2011
[RFC6454]
    Barth, A., “The Web Origin Concept”, ~RFC6454, December 2011
[RFC6585]
    Nottingham, M. and R. Fielding, “Additional HTTP Status Codes”, ~RFC6585, April 2012
[RFC7230]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, ~RFC7230, June 2014
[RFC7231]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, ~RFC7231, June 2014
[RFC7232]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests”, ~RFC7232, June 2014
[RFC7233]
    Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Range Requests”, ~RFC7233, June 2014
[RFC7235]
    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Authentication”, ~RFC7235, June 2014
[RFC7538]
    Reschke, J., “The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)”, ~RFC7538, April 2015
[RFC7540]
    Belshe, M., Peon, R., and M. Thomson, Ed., “Hypertext Transfer Protocol Version 2 (HTTP/2)”, ~RFC7540, May 2015
[RFC7541]
    Peon, R. and H. Ruellan, “HPACK: Header Compression for HTTP/2”, ~RFC7541, May 2015
[RFC7578]
    Masinter, L., “Returning Values from Forms: multipart/form-data”, ~RFC7578, July 2015
[RFC7615]
    Reschke, J., “HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields”, ~RFC7615, September 2015
[RFC7616]
    Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, “HTTP Digest Access Authentication”, ~RFC7616, September 2015
[RFC7617]
    Reschke, J., “The 'Basic' HTTP Authentication Scheme”, ~RFC7617, September 2015
[RFC7694]
    Reschke, J., “Hypertext Transfer Protocol (HTTP) Client-Initiated Content-Encoding”, ~RFC7694,November 2015
[RFC7838]
    Nottingham, M., McManus, P., and J. Reschke, “HTTP Alternative Services”, ~RFC7838, April 2016
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, ~RFC8126, June 2017
[RFC8187]
    Reschke, J., “Indicating Character Encoding and Language for HTTP Header Field Parameters”, ~RFC8187, September 2017
[RFC8246]
    McManus, P., “HTTP Immutable Responses”, ~RFC8246, September 2017
[RFC8288]
    Nottingham, M., “Web Linking”, ~RFC8288, October 2017
[RFC8336]
    Nottingham, M. and E. Nygren, “The ORIGIN HTTP/2 Frame”, ~RFC8336, March 2018
[RFC8446]
    Rescorla, E., “The Transport Layer Security (TLS) Protocol Version 1.3”, ~RFC8446, August 2018
[Sniffing]
    WHATWG, “MIME Sniffing”, URL: https://mimesniff.spec.whatwg.org

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公開された，
<a href="~SPEC_URL">HTTP Semantics</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
発行者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	7230, 7231, 7232, 7233, 7235, 7538, 7615, 7694 （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集
	R. Fielding, Editor (Adobe)
	M. Nottingham, Editor (Fastly)
	J. Reschke, Editor (greenbytes)
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-semantics
commit 履歴
	<a href="https://github.com/httpwg/http-core/commits/master">GitHub</a>
HTTP working group mailing list
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
Draft HTTP Core Documents
	https://github.com/httpwg/http-core
</script>

</head>
<body>

<header>
	<hgroup>
<h1 title="HTTP Semantics">HTTP 意味論（ Semantics ）</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="rfc.abstract">
~ABSTRACT

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、分散型の協調的な~hypertext情報~system用の，`~stateless$な応用~levelの~protocolである。
この文書は、次に挙げる~HTTPの意味論を定義する
⇒＃
~architecture,
各種用語,
"`http$c" および "`https$c" ~URI~scheme,
中核を成す`要請~method$,
`要請~header$,
`応答~状態s~code$,
`応答~header$,
`内容~折衝$
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines the semantics of HTTP: its architecture, terminology, the "http" and "https" Uniform Resource Identifier (URI) schemes, core request methods, request header fields, response status codes, response header fields, and content negotiation.
</p>

<p>
この文書は、次を廃用にする
⇒＃
`RFC7230$r を成すいくつかの部位,
`RFC2818$r,
`RFC7231$r,
`RFC7232$r,
`RFC7233$r,
`RFC7235$r,
`RFC7538$r,
`RFC7615$r,
`RFC7694$r
◎
This document obsoletes RFC 2818, RFC 7231, RFC 7232, RFC 7233, RFC 7235, RFC 7538, RFC 7615, RFC 7694, and portions of RFC 7230.
</p>

	</section>
	<section id="rfc.note.1">
<h2 title="Editorial Note">編集上の注記</h2>

<p>
この注記は、~RFCとして発行する前に除去されることになる。
◎
This note is to be removed before publishing as an RFC.
</p>

<p>
この草案について論を交わす場, この草案の~source~codeや課題~listは、冒頭の仕様~metadataから見出せる。
◎
Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;https://lists.w3.org/Archives/Public/ietf-http-wg/&gt;.
◎
Working Group information can be found at &lt;https://httpwg.org/&gt;; source code and issues list for this draft can be found at &lt;https://github.com/httpwg/http-core&gt;.
</p>

<p>
この草案における変更点は、
`C.13$sec に要約されている。
◎
The changes in this draft are summarized in Appendix C.13.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>に~~委譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en-x-a0">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に~~委譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

		<section id="intro.purpose">
<h3 title="Purpose">1.1. 目的</h3>

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、［
~networkに基づく，~hypertext情報~system
］と柔軟にヤリトリするために［
汎用な~interface,
拡張-可能な意味論,
自己-記述的な~message
］を共有する，［
`~stateless$な, 応用~levelな, ［
要請／応答
］の
］~protocolたちが成す族である。
◎
The Hypertext Transfer Protocol (HTTP) is a family of stateless, application-level, request/response protocols that share a generic interface, extensible semantics, and self-descriptive messages to enable flexible interaction with network-based hypertext information systems.
</p>

<p>
~HTTPは、［
供される資源の型に依存しない，`~client$向けの統一的な~interface
］を呈示することにより，~serviceがどう実装されるかについての詳細を隠す。
同様に`~server$も，各~clientの目的について自覚する必要はない
— 要請は、［
特定の型の~client／予め決定された手順を適用すること
］に結付けられずに，他から隔離して考慮できる。
これは、次を許容する
⇒＃
多くの異なる文脈で一般用~実装を効果的に利用する／
相互作用による複階性を抑制する／
時と伴に独立な発展を可能化する
◎
HTTP hides the details of how a service is implemented by presenting a uniform interface to clients that is independent of the types of resources provided. Likewise, servers do not need to be aware of each client's purpose: a request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps. This allows＼
general-purpose implementations to be used effectively in many different contexts,＼
reduces interaction complexity,＼
and enables independent evolution over time.
</p>

<p>
~HTTPはまた、［
`~proxy$や`~gateway$が，非~HTTP情報~systemを より汎用な~interfaceの中へ翻訳できる
］ような，中間~protocolとしての利用-用にも設計されている。
◎
HTTP is also designed for use as an intermediation protocol, wherein proxies and gateways can translate non-HTTP information systems into a more generic interface.
</p>

<div class="p">
<p>
この柔軟性による帰結の一つは、~interfaceの背後で生じるものからは，~protocolを定義し得ないことである。
代わりに，次を定義することに制限される
⇒＃
通信の構文／
受信された通信の意図／
`受信者$に期待される挙動
◎
One consequence of this flexibility is that the protocol cannot be defined in terms of what occurs behind the interface. Instead, we are limited to defining＼
the syntax of communication,＼
the intent of received communication, and＼
the expected behavior of recipients.＼
</p>

<p>
各~通信を他から隔離して考慮するならば、成功裡に終わる動作に対応する変化は，`~server$が供する観測-可能な~interfaceを通して反映される~OUGHT。
しかしながら、複数の~clientが，並列的かつ~~大体は違う目的で動作するであろうから、［
そのような変化が，単独の応答の視野を超えて観測-可能になる
］ことは要求できない。
◎
If the communication is considered in isolation, then successful actions ought to be reflected in corresponding changes to the observable interface provided by servers. However, since multiple clients might act in parallel and perhaps at cross-purposes, we cannot require that such changes be observable beyond the scope of a single response.
</p>
</div>

		</section>
		<section id="intro.evolution">
<h3 title="Evolution">1.2. 発展</h3>

<p>
~HTTPは、
1990 年の導入~以来， World Wide Web 用の首な情報~転送~protocolであり続けている。
それは、［
所与の~pathnameで識別され，予め~hypertext文書と見做される資源
］の転送を要請するために，単独の~method（ `GET$m ）を伴う低-待時間な要請~用の些細な仕組みとして始まった（ ~HTTP09 ）。
~Webが成長する伴い、~HTTPは次を行えるよう拡張され，最終的には~HTTP10 `RFC1945$r として定義された
⇒＃
~messageの中に要請や応答を封入する／
~MIMEの様な~media型【`~MIME型$】を利用して，任意な~data形式を転送する／
中継者を通して要請を~routeする
◎
HTTP has been the primary information transfer protocol for the World Wide Web since its introduction in 1990. It began as a trivial mechanism for low-latency requests, with a single method (GET) to request transfer of a presumed hypertext document identified by a given pathname (HTTP/0.9). As the Web grew, HTTP was extended to＼
enclose requests and responses within messages,＼
transfer arbitrary data formats using MIME-like media types,＼
and route requests through intermediaries,＼
eventually being defined as HTTP/1.0 [RFC1945].
</p>

<p>
~HTTP11は、既存の［
~textに基づく~message法~構文
］との互換性は維持しつつ，~protocolの各種~特能を精緻化して、~Internetにまたがる その［
相互運用能, ~scale能, 堅牢性
］を改善するべく設計された。
これには、次に挙げるものが含められた：
◎
HTTP/1.1 was designed to refine the protocol's features while retaining compatibility with the existing text-based messaging syntax, improving its interoperability, scalability, and robustness across the Internet. This included＼
</p>
<ul>
	<li>
［
固定的／動的（~chunked）
］な内容~用の長さに基づく~payload区切子
◎
length-based payload delimiters for both fixed and dynamic (chunked) content,＼
</li>
	<li>
`内容~折衝$用の一貫した~framework
◎
a consistent framework for content negotiation,＼
</li>
	<li>
`条件付き要請$~用の不透明な`検証子$
◎
opaque validators for conditional requests,＼
</li>
	<li>
~cacheの一貫性をより良くするための~cache制御
◎
cache controls for better cache consistency,＼
</li>
	<li>
部分的な更新~用の`範囲~要請$
◎
range requests for partial updates,＼
</li>
	<li>
既定の持続的な接続
◎
and default persistent connections.＼
</li>
</ul>

<p>
~HTTP11は、
1995 年に導入され，
`standards track^en にて発行された
⇒＃
1997 年には `RFC2068$r,
1999 年には `RFC2616$r,
2014 年には `RFC7230$r 〜 `RFC7235$r
◎
HTTP/1.1 was introduced in 1995 and published on the standards track in 1997 [RFC2068], 1999 [RFC2616], and 2014 ([RFC7230] – [RFC7235]).
</p>

<p>
~HTTP2（ `RFC7540$r ）は、複数の~HTTP~messageを同時的に交換するため，既存の［
~TLS, ~TCP
］~protocolの上層に多重化された~session層を導入した
— 効率的な~header圧縮と~server~pushも伴って。
~HTTP3（ `HTTP3$r ）は、~QUICを［
~TCP越しに代えて，~UDP越しの~secureな多重化された~transport
］として利用することにより，同時的な~message用に より高い独立性を供する。
◎
HTTP/2 ([RFC7540]) introduced a multiplexed session layer on top of the existing TLS and TCP protocols for exchanging concurrent HTTP messages with efficient header field compression and server push. HTTP/3 ([HTTP3]) provides greater independence for concurrent messages by using QUIC as a secure multiplexed transport over UDP instead of TCP.
</p>

<p>
これら~HTTPの 3 つの`~major~version$は、この文書に定義される意味論に依拠する。
それらは、互いに他を廃用にすることはない
— それぞれには、利用される文脈に依存して，特有な便益や制限があるので。
実装には、自身の特定0の文脈~用に最も適切な［
~transport, ~message法~構文
］を選ぶことが期待される。
◎
All three major versions of HTTP rely on the semantics defined by this document. They have not obsoleted each other because each one has specific benefits and limitations depending on the context of use. Implementations are expected to choose the most appropriate transport and messaging syntax for their particular context.
</p>

<p>
~HTTPのこの改訂は、現在の~HTTP11の~message法~構文（ `Messaging$r ）から，意味論の定義（この文書）と~cache法（ `Caching$r ）を分離して、~majorな各~protocol~versionが同じ中核~意味論を参照rしながら独立に進展できるようにする。
◎
This revision of HTTP separates the definition of semantics (this document) and caching ([Caching]) from the current HTTP/1.1 messaging syntax ([Messaging]) to allow each major protocol version to progress independently while referring to the same core semantics.
</p>

		</section>
		<section id="intro.semantics">
<h3 title="Semantics">1.3. 意味論</h3>

<p>
~HTTPは、［
`資源$の［
型／資質／実装
］を問わず，資源とヤリトリする
］ための統一的な~interfaceを，当の資源の`表現$を［
操作する／転送する
］~messageを送信することにより供する。
◎
HTTP provides a uniform interface for interacting with a resource (Section 2.5), regardless of its type, nature, or implementation, by sending messages that manipulate or transfer representations (Section 7).
</p>

<div class="p">
<p>
各~messageは、`要請$, `応答$のどちらかになる：
◎
Each message is either a request or a response.＼
</p>
<ol>
	<li>
`~client$は、
自身の意向を通信する要請~messageを構築して，
識別された`生成元~server$へ向けて~messageを~routeする。
◎
A client constructs request messages that communicate its intentions and routes those messages toward an identified origin server. 
</li>
	<li>
`~server$は、
要請を~listenして，
受信した各~messageを構文解析して，
識別された`~target資源$に関係する~message意味論を解釈して，
その要請に対し 1 個~以上の応答~messageで応答する。
◎
A server listens for requests, parses each message received, interprets the message semantics in relation to the identified target resource, and responds to that request with one or more response messages.＼
</li>
	<li>
`~client$は、自身の意向が遂げられたどうか見るために受信した応答を精査して，受信した［
`状態s~code$, `~payload$
］に基づいて 次に何を行うか決定する。
◎
The client examines received responses to see if its intentions were carried out, determining what to do next based on the received status and payloads.
</li>
</ol>
</div>

<div class="p">
<p>
~HTTP意味論は、次を含む：
◎
HTTP semantics include＼
</p>
<ul>
	<li>
各種 `要請~method$が定義する意向
◎
the intentions defined by each request method (Section 8),＼
</li>
	<li>
各種 `要請~header$にて述べ得るような，それらの意味論に対する拡張
◎
extensions to those semantics that might be described in request header fields (Section 9),＼
</li>
	<li>
応答について述べる各種 `状態s~code$
◎
status codes that describe the response (Section 10),＼
</li>
	<li>
各種 `応答~header$【！応答~field】にて与え得る，他の［
`制御~data$／資源~metadata
］
◎
and other control data and resource metadata that might be given in response fields (Section 11).
</li>
</ul>
</div>

<div class="p">
<p>
意味論は、次も含む：
◎
Semantics also include＼
</p>
<ul>
	<li>
次について述べる，`表現~metadata$
⇒
`~payload$は、受信者からは，どう解釈されるものと意図されているか
◎
representation metadata that describe how a payload is intended to be interpreted by a recipient,＼
</li>
	<li>
内容の選定に波及し得る，`要請~header$
◎
request header fields that might influence content selection,＼
</li>
	<li>
“<dfn>`内容~折衝$</dfn>”
と~~総称される，様々な選定~algo
◎
and the various selection algorithms that are collectively referred to as "content negotiation" (Section 7.4).
</li>
</ul>
</div>

		</section>
		<section id="intro.obsoletes">
<h3 title="Obsoletes">1.4. 廃用</h3>

<p>
この文書は、次に挙げる仕様を廃用にする（括弧内は変更点）
⇒＃
`HTTP Over TLS^cite `RFC2818$r（ `B.1$sec ）,
`HTTP/1.1 Message Syntax and Routing^cite `RFC7230$r（ `B.2$sec ）†,
`HTTP/1.1 Semantics and Content^cite `RFC7231$r（ `B.3$sec ）,
`HTTP/1.1 Conditional Requests^cite `RFC7232$r（ `B.4$sec ）,
`HTTP/1.1 Range Requests^cite `RFC7233$r（ `B.5$sec ）,
`HTTP/1.1 Authentication^cite `RFC7235$r（ `B.6$sec ）,
`HTTP Status Code 308 (Permanent Redirect)^cite `RFC7538$r（ `B.7$sec ）,
`HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields^cite `RFC7615$r（ `B.8$sec ）,
`HTTP Client-Initiated Content-Encoding^cite `RFC7694$r（ `B.9$sec ）,
◎
This document obsoletes the following specifications:
◎
Table 1
Title 	Reference 	Changes
HTTP Over TLS 	[RFC2818] 	B.1
HTTP/1.1 Message Syntax and Routing [*] 	[RFC7230] 	B.2
HTTP/1.1 Semantics and Content 	[RFC7231] 	B.3
HTTP/1.1 Conditional Requests 	[RFC7232] 	B.4
HTTP/1.1 Range Requests 	[RFC7233] 	B.5
HTTP/1.1 Authentication 	[RFC7235] 	B.6
HTTP Status Code 308 (Permanent Redirect) 	[RFC7538] 	B.7
HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields 	[RFC7615] 	B.8
HTTP Client-Initiated Content-Encoding 	[RFC7694] 	B.9
</p>

<p>†
この文書が廃用にするのは、
`RFC7230$r を成す，~HTTP11の［
~message法の構文／接続~管理
］に依存しない部位に限られる。
`RFC7230$r を成す他の部分は、 `Messaging$r により廃用にされた。
◎
[*] This document only obsoletes the portions of RFC 7230 that are independent of the HTTP/1.1 messaging syntax and connection management; the remaining bits of RFC 7230 are obsoleted by "HTTP/1.1 Messaging" [Messaging].
</p>

		</section>
		<section id="intro.requirements">
<h3 title="Requirements Notation">1.5. 要件の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>
に~~委譲。
】</p>

<p>
適合性の判定基準, および
~errorの取扱いに関する考慮点は、`適合性$secにて定義される。
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
◎
Conformance criteria and considerations regarding error handling are defined in Section 3.
</p>

		</section>
		<section id="notation">
<h3 title="Syntax Notation">1.6. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#syntax-notation">~HTTP共通~page</a>
に~~委譲。
】
</p>

<p>
`A$sec にて、すべての~list演算子を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
◎
It also uses a list extension, defined in Section 5.5, that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
As a convention, ABNF rule names prefixed with "obs-" denote "obsolete" grammar rules that appear for historical reasons.
◎
The following core rules are included by reference, as defined in Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII character).
</p>

<p>
`5.4.1$sec にて、`~field値$用の汎用な構文上の成分をいくつか定義する。
◎
Section 5.4.1 defines some generic syntactic components for field values.
</p>

<p>
次に挙げる規則は `Messaging$r にて定義される
⇒＃
`transfer-coding$p
◎
The rules below are defined in [Messaging]:
◎
transfer-coding = &lt;transfer-coding, see [Messaging], Section 7&gt;
◎
This specification uses the terms "character", "character encoding scheme", "charset", and "protocol element" as they are defined in [RFC6365].
</p>

			<section id="whitespace">
<h4 title="Whitespace">1.6.1. 空白</h4>

<p>
この仕様は、空白列（ `linear whitespace^en ）の利用を記すときに，次の 3 つの規則を利用する：
◎
This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS ("bad" whitespace).
</p>

<dl>
	<dt>`OWS@p （省略可能な空白）</dt>
	<dd>
<p>
この規則は、［
0 個~以上の~octetからなる空白列
］が出現し得る所で利用される。
`送信者$は、各~protocol要素に対し：
◎
The OWS rule is used where zero or more linear whitespace octets might appear. For protocol elements＼
</p>
		<ul>
			<li>
［
読み易くするため，省略可能な空白が選好される所
］では、［
省略可能な空白を 1 個の `SP$P として`生成する$
］ベキである。
◎
where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP;＼
</li>
			<li>
他の所では、~messageを~filterする際に， `OWS$p を`生成する$ベキでない
— ただし、［
妥当でない／求まれてない
］~protocol要素
］を white out する
【空白に置換する？】
ために必要になる場合は除く。
◎
otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering.
</li>
		</ul>
	</dd>

	<dt>`RWS@p （要求される空白）</dt>
	<dd>
この規則は、［
各~field~tokenを分離するために，［
1 個~以上の~octetからなる空白列
］が要求される
］ときに，利用される。
`送信者$は、 `RWS$p として 1 個の `SP$P を`生成する$ベキである。
◎
The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.
</dd>
	<dd>
［
`OWS$p ／ `RWS$p
］の意味論は、 1 個の `SP^P と同じになる。
［
`OWS^p ／ `RWS^p 
］として定義されたことが既知な，どの内容も
— ~messageを［
解釈する, あるいは`下流$へ回送する
］前に —
1 個の `SP$P に置換してもヨイ。
◎
OWS and RWS have the same semantics as a single SP. Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.
</dd>

	<dt>`BWS@p （ “不良な” 空白）</dt>
	<dd>
この規則は、［
もっぱら歴史的な理由のため，省略可能な空白が文法にて許容される所
］で利用される。
`送信者$は、~message内に `BWS$p を`生成し$てはナラナイ。
`受信者$は、~protocol要素を解釈する前に，そのような不良~空白を構文解析して除去しなければナラナイ。
◎
The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.
</dd>
	<dd>
`BWS^p には意味論は無い。
`BWS^p として定義されたことが既知な，どの内容も
— ~messageを［
解釈する, あるいは`下流$へ回送する
］前に —
除去してもヨイ。
◎
BWS has no semantics. Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.
</dd>
</dl>

<pre class="bnf">
`OWS$p
    = *( `SP$P / `HTAB$P )
    ; `省略可能な空白^com
`RWS$p
    = 1*( `SP$P / `HTAB$P )
    ; `要求される空白^com
`BWS$p
    = `OWS$p
    ; `“不良” 空白^com
</pre>

			</section>
		</section>
	</section>
	<section id="architecture">
<h2 title="Architecture">2. ~architecture</h2>

<p>
~HTTP は、 World Wide Web（ WWW ）~architecture用に作成され，［
~worldwide~hypertext~systemにおける~scale能の必要性
］を~supportするために，時と伴に発展してきた。
その~architectureの多くは、~HTTPを定義するために利用される［
各種用語, および構文~生成規則
］に反映されている。
◎
HTTP was created for the World Wide Web (WWW) architecture and has evolved over time to support the scalability needs of a worldwide hypertext system. Much of that architecture is reflected in the terminology and syntax productions used to define HTTP.
</p>

		<section id="operation">
<h3 title="Client/Server Messaging">2.1. ~client／~serverによる~message法</h3>

<div class="p">
<p>
~HTTPは、［
依拠-可能な［
~transport層／~session層
］の接続にまたがって，~messageを交換する
］ことにより運用される，`~stateless$な［
要請, 応答
］~protocolである。
◎
HTTP is a stateless request/response protocol that operates by exchanging messages across a reliable transport- or session-layer "connection".
</p>
<ul>
	<li>
~HTTP
`~client@
とは、 1 個~以上の~HTTP要請を送信する目的で，`~server$への接続を確立する~programである。
◎
An HTTP "client" is a program that establishes a connection to a server for the purpose of sending one or more HTTP requests.＼
</li>
	<li>
~HTTP
`~server@
とは、~HTTP要請に対し，その接続を受容し、`~client$への~serviceとして，~HTTP応答を送信する~programである。
◎
An HTTP "server" is a program that accepts connections in order to service HTTP requests by sending HTTP responses.
</li>
</ul>
</div>

<div class="p">
<p>
2 つの用語 “`~client$”, “`~server$” が指すのは、［
特定0の接続~用に，これらの~programが遂行する`役割$
］に限られる。
同じ~programが［
ある接続~上では~clientになると~~同時に，他の接続~上では~server
］として，動作し得る。
◎
The terms "client" and "server" refer only to the roles that these programs perform for a particular connection. The same program might act as a client on some connections and a server on others.＼
</p>

<p class="trans-note">【
語
`接続^dfn
は、~messageの経路（後述の，接続の`連鎖$）全体ではなく，隣接する ある 2 つの
`参加者@
（連鎖に属する~node）間の接続を指すことに注意（個々の参加者から直に見えるのは，隣の参加者だけなので）。
】</p>
<ul>
	<li>
用語
`~UA@
（ `user agent^en ）は、［
要請を起動する任意の`~client$~program
］を指し，様々なものがある
⇒
~browser,
~spider（~webに基づく~robot）,
~command-line~tool,
~custom~app,
~mobile~app,
等々
◎
The term "user agent" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps.＼
</li>
	<li>
用語
`生成元~server@
は、［
所与の`~target資源$に対する`権限的な応答$
］を出生できる~programを指す。
◎
The term "origin server" refers to the program that can originate authoritative responses for a given target resource.＼
</li>
	<li>
用語
`送信者@
／
`受信者@
は、所与の~messageを［
送信する／受信する
］任意の実装を指す。
◎
The terms "sender" and "recipient" refer to any implementation that sends or receives a given message, respectively.
</li>
</ul>
</div>

<p>
~HTTPは、［
`~target資源$と, 資源~間の関係性
］を指示するために，［
<abbr title="Uniform Resource Identifier">URI</abbr> 標準 `RFC3986$r
］に依拠する。
◎
HTTP relies upon the Uniform Resource Identifier (URI) standard [RFC3986] to indicate the target resource (Section 6.1) and relationships between resources.
</p>

<p>
ほとんどの~HTTP通信は、［
`~URI$により識別される何らかの`資源$
］の`表現$に対する，検索取得 要請（ `GET$m ）からなる。
最も単純な事例では、これは，［
`~UA$（ `UA^V ）と`生成元~server$（ `O^V ）との間の，単独の双方向-接続（ `===^c ）
］を介して成遂げられるであろう：
◎
Most HTTP communication consists of a retrieval request (GET) for a representation of some resource identified by a URI. In the simplest case, this might be accomplished via a single bidirectional connection (===) between the user agent (UA) and the origin server (O).
</p>

<pre class="presentation">
       要請   &gt;
  `UA^V ======================================= `O^V
                              &lt;   応答
</pre>

<div class="p">
<p>
~HTTPの各 `~major~version$は、~messageの通信~用に，自前の構文を定義する。
いずれにせよ，それらに共通な抽象-化として、各~messageは，何らかの形の封入法や~frame法の下で次を包含する：
</p>
<ul>
	<li>
~messageの意味論と~route法を指示する自己-記述的な`制御~data$
◎
self-descriptive control data that indicates its semantics and routing,＼
</li>
	<li>
0 個以上の有名`~field$からなる，`~header節$
</li>
	<li>
0 〜 1 個の本体
</li>
	<li>
本体が始まった後に送信される，
0 個以上の有名`~field$
— それらは、 0 個以上の`~trailer節$を成す
</li>
</ul>
◎
Each major version of HTTP defines its own syntax for the communication of messages. Nevertheless, a common abstraction is that each message contains some form of envelope/framing with＼
self-descriptive control data that indicates its semantics and routing,＼
a potential set of named fields up front (a header section),＼
a potential body, and＼
potential fields sent after the body begins (trailer sections).
</div>

<div class="p">
<p>
`~client$は、要請を［
`~method$, `要請~target$
］【~HTTP11においては `request-line$p 】を伴う
`要請@
~messageの形で`~server$へ送信する。
要請は、次に挙げるものも包含し得る：
◎
A client sends requests to a server in the form of a request message with a method (Section 8) and request target. The request might also contain＼
</p>
<ul>
	<li>
［
要請の改変子／`~client$情報／`表現~metadata$
］用の`~header$たち
◎
header fields for request modifiers, client information, and representation metadata (Section 5),＼
</li>
	<li>
~methodに則って処理されることになる`~payload本体$
◎
a payload body (Section 7.3.3) to be processed in accordance with the method,＼
</li>
	<li>
`~payload$を送信している間に収集された~metadata用の`~trailer$たち
◎
and trailer fields for metadata collected while sending the payload.
</li>
</ul>
</div>

<div class="p">
<p>
`~server$は、`~client$からの要請に対し，
1 個~以上の
`応答@
~message
を送信して応答する
【 0 個以上の`暫定-応答$, 1 個の`最終-応答$】
。
各~応答は、`状態s~code$
【~HTTP11においては `status-line$p 】
を内包し，次に挙げるものも包含し得る：
◎
A server responds to a client's request by sending one or more response messages, each including a status code (Section 10). The response might also contain＼
</p>
<ul>
	<li>
［
~server情報／資源~metadata／`表現~metadata$
］用の`~header$たち
◎
header fields for server information, resource metadata, and representation metadata (Section 5),＼
</li>
	<li>
`状態s~code$に則って解釈されることになる`~payload本体$
◎
a payload body (Section 7.3.3) to be interpreted in accordance with the status code,＼
</li>
	<li>
`~payload$を送信している間に収集された~metadata用の`~trailer$たち
◎
and trailer fields for metadata collected while sending the payload.
</li>
</ul>
</div>

<p>
~message~frame法には、~messageは
`完全@
であることを確約する機能がある。
~messageは、その~frame法により指示される すべての~octetが可用になったとき，`完全$と見なされる。
明示的な~frame法が利用されていない場合、~transport接続の~closeにより終端された応答~messageは
— 不完全な応答と判別-不能であろうが，~transport~levelの~errorにより完全でないものと指示されない限り —
`完全$と見なされることに注意。
◎
One of the functions of message framing is to assure that messages are complete. A message is considered complete when all of the octets indicated by its framing are available. Note that, when no explicit framing is used, a response message that is ended by the transport connection's close is considered complete even though it might be indistinguishable from an incomplete response, unless a transport-level error indicates that it is not complete.
</p>

<p>
同じ接続が，複数の［
要請／応答
］の交換に利用されることもある。
要請~messageと応答~messageとを相関するために利用される仕組みは、~versionに依存する
— ~HTTPのある~versionは~messageの暗黙的な順序付けを利用する一方で，他の~versionは明示的な識別子を利用する。
◎
A connection might be used for multiple request/response exchanges. The mechanism used to correlate between request and response messages is version dependent; some versions of HTTP use implicit ordering of messages, while others use an explicit identifier.
</p>

<p>
応答は（`最終-応答$, `暫定-応答$どちらも）、要請を受信した後のいつでも
— 要請がまだ完了していなくとも —
送信できる。
しかしながら，~client（中継者も含む）は、応答が適度な時間内に来なければ，要請を放棄することもある。
◎
Responses (both final and interim) can be sent at any time after a request is received, even if it is not yet complete. However, clients (including intermediaries) might abandon a request if the response is not forthcoming within a reasonable period of time.
</p>

<div class="example">
<p>
代表的な例として、~URI
"`http://www.example.com/hello.txt^c"
へ向けた `GET$m 要請における，~message交換の様子を次に示す：
◎
The following example illustrates a typical message exchange for a GET request (Section 8.3.1) on the URI "http://www.example.com/hello.txt":
</p>

<p>
~clientによる要請：
◎
Client request:
</p>

<pre class="lang-http">
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
</pre>

<p>
~serverからの応答：
◎
Server response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
</pre>
</div>

		</section>
		<section id="intermediaries">
<h3 title="Intermediaries">2.2. 中継者</h3>

<p>
~HTTPは、要請が接続の
`連鎖@
を通り抜けられるようにするため，
`中継者@
の利用も可能化する。
~HTTP中継者には、 3 種の共通な形［
`~proxy$,
`~gateway$,
`~tunnel$
］がある。
一部の事例では、単独の中継者が，各~要請の資質に基づいて 自身の挙動を［
`生成元~server$,
`~proxy$,
`~gateway$,
`~tunnel$
］のいずれかに切替えながら動作することもある。
◎
HTTP enables the use of intermediaries to satisfy requests through a chain of connections. There are three common forms of HTTP intermediary: proxy, gateway, and tunnel. In some cases, a single intermediary might act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.
</p>

<pre class="presentation">
       &gt;             &gt;             &gt;             &gt;
  `UA^V =========== `A^V =========== `B^V =========== `C^V =========== `O^V
             &lt;             &lt;             &lt;             &lt;
</pre>

<div class="p">
<p>
上の図は、`~UA$（ `UA^V ）と `生成元~server$（ `O^V ）の間に挟まれた， 3 つの`中継者$（
`A^V, `B^V, `C^V
）を示している。
`連鎖$の端から端まで届けられる［
要請／応答
］~messageは、 4 つの別々の接続を渡り歩くことになる。
~HTTP通信~optionには、次のいずれかに適用されるものもある：
◎
The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response message that travels the whole chain will pass through four separate connections. Some HTTP communication options might apply＼
</p>
<ul>
	<li>
最も近い, `~tunnel$でない隣接点との接続のみ
【 `隣点間@（ `hop-by-hop^en ） 】
◎
only to the connection with the nearest, non-tunnel neighbor,＼
</li>
	<li>
連鎖の両
`端点@
にのみ
◎
only to the endpoints of the chain, or＼
</li>
	<li>
連鎖~沿いにある すべての接続
【 `端点間@（ `end-to-end^en ）】
◎
to all connections along the chain.＼
</li>
</ul>

<p>
また，上の図式は単線だが、各~参加者は，同時に複数の通信に携わることもある。
例えば `B^V は、
`A^V からの要請を取扱うと同時に，［
`A^V 以外の多数の~clientからの要請を受信していたり,
`C^V 以外の`~server$向けの要請を回送している
］こともあり得る。
同様に，今後の要請が、異なる経路による接続
— 多くの場合、負荷分散~用の動的~環境設定に基づく —
を通して送信されることもあり得る。
◎
Although the diagram is linear, each participant might be engaged in multiple, simultaneous communications. For example, B might be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request. Likewise, later requests might be sent through a different path of connections, often based on dynamic configuration for load balancing.
</p>
</div>

<p>
用語
`上流@
／
`下流@
は、［
~messageが流れる方向
］に関係して，要件を述べるときに用いられる：
すべての~messageは上流から下流へ流れる。
用語
`内方@
／
`外方@
は、［
要請が~routeされる方向
］に関係して，要件を述べるときに用いられる：
“内方” は`生成元~server$へ向かうことを意味し，
“外方” は`~UA$へ向かうことを意味する。
◎
The terms "upstream" and "downstream" are used to describe directional requirements in relation to the message flow: all messages flow from upstream to downstream. The terms "inbound" and "outbound" are used to describe directional requirements in relation to the request route: "inbound" means toward the origin server and "outbound" means toward the user agent.
</p>

<p>
`~proxy@
は、［
何らかの型の絶対~URIへ向けた要請を受信したときには、［
~HTTP~interfaceを通した翻訳
］を介して，その要請を満足しようと試みる
］ような，~message回送~agentであり、通例的に，`~client$の局所的な環境設定~規則を介して，~clientにより選定される。
翻訳には、［
"`http$c" ~URIへ向けた~proxy要請のような必要最小限なもの
］もある一方，［
全面的に異なる応用~levelの~protocolへの／からの翻訳を要する要請
］もあり得る。
`~proxy$は、［
~security,
注釈~service†,
共用~caching
］の~~目的で，［
組織~内の~HTTP要請を，共通な`中継者$を通して~group分けする
］ために利用されることが多い。
一部の`~proxy$は、~messageを回送する際に，［
選定された
~message／`~payload$
に`形式変換$を適用する
］ように設計されている。
◎
A "proxy" is a message-forwarding agent that is selected by the client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and attempt to satisfy those requests via translation through the HTTP interface. Some translations are minimal, such as for proxy requests for "http" URIs, whereas other requests might require translation to and from entirely different application-level protocols. Proxies are often used to group an organization's HTTP requests through a common intermediary for the sake of security, annotation services, or shared caching. Some proxies are designed to apply transformations to selected messages or payloads while they are being forwarded, as described in Section 6.6.2.
</p>

<p class="trans-note">【†
元の~dataに~~注釈情報（ `annotation^en ）を付加する（例えば，用語に~linkを補完するなど）ような~serviceを意味すると見受けられる。
】</p>

<div class="p">
<p>
`~gateway@
（ “逆~proxy” とも呼ばれる）は，`中継者$の一種であり、`外方$への接続に対しては`生成元~server$として動作しつつ，受信した要請を翻訳して `内方$にある別の`~server$たちへ回送する。
~gatewayは、次のために利用されることが多い：
◎
A "gateway" (a.k.a. "reverse proxy") is an intermediary that acts as an origin server for the outbound connection but translates received requests and forwards them inbound to another server or servers. Gateways are often used＼
</p>
<ul>
	<li>
旧来の, あるいは信用できない情報~serviceを~encapsulateする。
◎
to encapsulate legacy or untrusted information services,＼
</li>
	<li>
~cachingによる “加速器” を通して~server処理能を改善する。
◎
to improve server performance through "accelerator" caching, and＼
</li>
	<li>
複数の~machineにまたがる［
~HTTP~serviceの区割りや負荷分散
］を可能化する。
◎
to enable partitioning or load balancing of HTTP services across multiple machines.
</li>
</ul>
</div>

<p>
`生成元~server$に適用-可能な，すべての~HTTP要件は、`~gateway$の`外方$への通信にも適用される。
`~gateway$は、自身が欲する任意の~protocol
— この仕様の視野から外れる，~HTTPに対する私的~拡張も含む —
を利用して，`内方$にある`~server$と通信する。
しかしながら、第三者主体の~HTTP~serverと相互運用したいと望む~HTTP-to-HTTP`~gateway$は、［
~gatewayの`内方$への接続
］に課される`~UA$要件にも適合する~OUGHT。
◎
All HTTP requirements applicable to an origin server also apply to the outbound communication of a gateway. A gateway communicates with inbound servers using any protocol that it desires, including private extensions to HTTP that are outside the scope of this specification. However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection.
</p>

<p>
`~tunnel@
は、~messageを変更することなく， 2 つの接続の間を盲目的に中継するように動作する。
いったん作動中になった~tunnelは、それが~HTTP要請により起動されたとしても，~HTTP通信の主体とは見なされない。
~tunnelが存在し得るのは、［
中継された接続の両~端
］が~closeされるまでである。
~tunnelは、［
共用~firewall~proxyを通した機密的~通信
］を確立するために，~TLS（ `Transport Layer Security^en, `RFC8446$r）が利用されるときなど、［
`中継者$を通した仮想~接続
］を拡張するために利用される。
◎
A "tunnel" acts as a blind relay between two connections without changing the messages. Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request. A tunnel ceases to exist when both ends of the relayed connection are closed. Tunnels are used to extend a virtual connection through an intermediary, such as when Transport Layer Security (TLS, [RFC8446]) is used to establish confidential communication through a shared firewall proxy.
</p>

<p>
上の`中継者$の類別は、［
~HTTP通信における参加者
］として動作しているもののみが考慮される。
中継者には、［
~network~protocol~stackの より低~層
］で動作して，［
~message送信者についての知識や許可
］なしに［
~HTTP流通を~filterしたり~redirectする
］ものもある。
~network中継者は，（~protocol~levelでは）経路上の攻撃者かどうか判別-不能なので、［
~HTTP意味論を誤解して違反することに因る，~securityの欠陥や相互運用能の問題
］が導入されることも多い。
◎
The above categories for intermediary only consider those acting as participants in the HTTP communication. There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders. Network intermediaries are indistinguishable (at a protocol level) from an on-path attacker, often introducing security flaws or interoperability problems due to mistakenly violating HTTP semantics.
</p>

<p>
例えば， “~interception~proxy” `RFC3040$r （ “透過的~proxy” `RFC1919$r や “~captive~portal” としても~~周知）は、~clientにより選定されるものではない点で，~HTTP`~proxy$とは相違する。
代わりに，~interception~proxyは、［
外向けの~TCP~port 80 ~packet
］を（ときには、他の共通的な~port上の流通も），~filterしたり~redirectする。
~interception~proxyは、［［
公共~network~access~pointにて，局所的でない~Internet~serviceの利用を許容する
］に先立って，~account~subscriptionを施行する手段
］として, あるいは［
~network利用e~施策を施行する企業~firewall
］の中で，共通的に見出される。
◎
For example, an "interception proxy" [RFC3040] (also commonly known as a "transparent proxy" [RFC1919] or "captive portal") differs from an HTTP proxy because it is not selected by the client. Instead, an interception proxy filters or redirects outgoing TCP port 80 packets (and occasionally other common port traffic). Interception proxies are commonly found on public network access points, as a means of enforcing account subscription prior to allowing use of non-local Internet services, and within corporate firewalls to enforce network usage policies.
</p>

<p>
~HTTPは、
`~stateless@
な~protocolとして定義されている
— すなわち、各~要請~messageは，互いに隔離されても解せることを意味する。
多くの実装は、［
~proxyされた接続を再利用したり，
複数の~serverにまたがって要請を動的に負荷分散する
］ときに，［
~HTTPの~statelessな設計
］に依存する。
よって，`~server$は、［
同じ接続~上の 2 つの要請
］を，同じ`~UA$からのものと見做してはナラナイ
— その接続が［
`~secure化$されていて，その~UAに特有である
］のでない限り。
一部の非~標準~HTTP拡張（例： `RFC4559$r）は、この要件に違反していることが既知であり、~security, および相互運用能の問題を起こす。
◎
HTTP is defined as a stateless protocol, meaning that each request message can be understood in isolation. Many implementations depend on HTTP's stateless design in order to reuse proxied connections or dynamically load balance requests across multiple servers. Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent. Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.
</p>

		</section>
		<section id="caches">
<h3 title="Caches">2.3. ~cache</h3>

<p>
`~cache@
とは、［
以前に受け取った応答~messageの局所的な格納域
］であり，それらの~messageの［
~storage, 検索取得, 削除
］を制御する下位~systemである。
~cacheは、`~cache可能$な応答を，未来の等価な要請に要する［
応答~時間／~network帯域幅の消費
］を抑制するために格納する。
どの［
`~client$／`~server$
］も，~cacheを使役してヨイ
— `~tunnel$として動作している~serverは、~cacheを利用し得ないが。
◎
A "cache" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel.
</p>

<p>
~cacheによる効果は、［
要請／応答
］の連鎖が
— ［
`連鎖$沿いにある いずれかの参加者
］が［
その要請に適用-可能な ~cache済み応答
］を持つときには —
短縮されることである。
次の図に、ある要請に対し， `B^V が~cache済み複製を持っている
— それは［
~~以前に
【ある~UAによる，その要請と等価な要請に対し】
 `O^V から（ `C^V を介して）返された応答
］の複製であり，［
`UA^V や `A^V には まだ~cacheされていない
］とする —
ときの結果を示す：
◎
The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.
</p>

<pre class="presentation">
          &gt;             &gt;
     `UA^V =========== `A^V =========== `B^V - - - - - - `C^V - - - - - - `O^V
                &lt;             &lt;
</pre>

<p>
応答~messageは、［
後続の要請に対する回答に利用するためとして，複製を~cacheに格納することが許容される
］とき，
`~cache可能@
であるという。
応答が~cache可能であるとしても、［
特定0の要請に対し，~cache済み応答が いつ利用できるか
］について，［
`~client$や`生成元~server$により，追加的な拘束が設置される
］こともある。
［
~cacheの挙動, および
~cache可能な応答
］に課される~HTTP要件は、
`Caching/2$sec にて定義される。
◎
A response is "cacheable" if a cache is allowed to store a copy of the response message for use in answering subsequent requests. Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request. HTTP requirements for cache behavior and cacheable responses are defined in Section 2 of [Caching].
</p>

<p>
World Wide Webや, 巨大な組織の内側にまたがって配備されている~cacheには、多種多様な~architectureや環境設定がある。
これらには、次に挙げるものなども含まれる
⇒＃
大陸間~帯域幅を節約するための，~proxy~cacheの国別~階層／
~cache~entryを~broadcastしたり~multicastする，協調的な~system／
~off-lineや高遅延な環境で利用するために，事前fetchされた~cache~entryの~archive
◎
There is a wide variety of architectures and configurations of caches deployed across the World Wide Web and inside large organizations. These include national hierarchies of proxy caches to save transoceanic bandwidth, collaborative systems that broadcast or multicast cache entries, archives of pre-fetched cache entries for use in off-line or high-latency environments, and so on.
</p>

		</section>
		<section id="uri">
<h3 title="Uniform Resource Identifiers">2.4. URI</h3>

<p>
~HTTP~~全体に渡り、
`~URI^dfn
（ `Uniform Resource Identifiers^en `RFC3986$r — 統一的~資源~識別子）が，`資源$を識別するための手段に利用される。
~URI参照は、［
要請を~targetするため ／
~redirectを指示するため ／
関係性を定義する
］ために利用される。
◎
Uniform Resource Identifiers (URIs) [RFC3986] are used throughout HTTP as the means for identifying resources (Section 2.5). URI references are used to target requests, indicate redirects, and define relationships.
</p>

<p>
`absolute-path$p 規則は、［
空でない `path$p 成分を包含し得る~protocol要素
］用に定義される。
（この規則は、［
"`//^c" から始まる `path^p
］を許容しない点で，［
`URI-reference$p における空 `path^p の利用
］を許容していた `RFC3986$r の `path-abempty^p 規則から少し相違する）。
◎
The definitions of "URI-reference", "absolute-URI", "relative-part", "authority", "port", "host", "path-abempty", "segment", and "query" are adopted from the URI generic syntax. An "absolute-path" rule is defined for protocol elements that can contain a non-empty path component. (This rule differs slightly from the path-abempty rule of RFC 3986, which allows for an empty path to be used in references, and path-absolute rule, which does not allow paths that begin with "//".)＼
</p>

<p>
`partial-URI$p 規則は、［
相対~URIを包含できるが，その中に `fragment$p 成分は包含できない
］ような~protocol要素~用に定義される。
◎
A "partial-URI" rule is defined for protocol elements that can contain a relative URI but not a fragment component.
</p>

<p>
下に挙げる各種~定義は、~URIの汎用~構文から採用されている：
【 ";" 以下の~commentは訳者補足】
◎
↓</p>

<pre class="bnf">
`URI-reference@p
    = &lt;URI-reference, `RFC3986/4.1$sec&gt; ; `~URI参照^com
`absolute-URI@p
    = &lt;absolute-URI, `RFC3986/4.3$sec&gt; ; `絶対~URI^com
`relative-part@p
    = &lt;relative-part, `RFC3986/4.2$sec&gt; ; `相対~URI（~query以下を除く）^com
`authority@p
    = &lt;authority, `RFC3986/3.2$sec&gt; ; `権限^com
`uri-host@p
    = &lt;host, `RFC3986/3.2.2$sec&gt; ; `~host^com
`port@p
    = &lt;port, `RFC3986/3.2.3$sec&gt; ; `~port^com
`path-abempty@p
    = &lt;path-abempty, `RFC3986/3.3$sec&gt; ; `~path（空もあり）^com
`segment@p
    = &lt;segment, `RFC3986/3.3$sec&gt; ; `~pathの一階層^com
`query@p
    = &lt;query, `RFC3986/3.4$sec&gt; ; `~query^com
</pre>

<p class="trans-note">【
その他、原文には［
`scheme@p （~scheme）,
`host@p （~host）,
`path@p （~path）,
`fragment@p （素片~識別子）
］も現れる。
これらが［
`RFC3986$r に定義される~protocol要素,
それが表現する概念
］のどちらを表すかは、明確に線引きできず，両義的に解釈できる箇所もあることに注意。
`port$p （~port）についても同様。
】</p>

<p>
加えて，次の規則も定義される：
◎
↓</p>

<pre class="bnf">
`absolute-path@p
    = 1*( "/" `segment$p )
`partial-URI@p
    = `relative-part$p [ "?" `query$p ]
</pre>

<div class="p">
<p>
~HTTPにおける，［
~URI参照を許容する 各~protocol要素
］では、その~ABNF生成規則により，［
要素に許容されるのは，次のいずれかである
］ことを指示することになる：
◎
Each protocol element in HTTP that allows a URI reference will indicate in its ABNF production whether the element allows＼
</p>
<ul>
	<li>
任意の形による参照（ `URI-reference$p ）
◎
any form of reference (URI-reference),＼
</li>
	<li>
絶対~形（ `absolute-URI$p ）による~URIのみ
◎
only a URI in absolute form (absolute-URI),＼
</li>
	<li>
`path$p 成分, および
省略可能な `query$p 成分のみ
◎
only the path and optional query components, or＼
</li>
	<li>
前項と前前項の組合n
◎
some combination of the above.＼
</li>
</ul>

<p>
他から指示されない限り、~URI参照は，`~target~URI$に相対的に構文解析される。
◎
Unless otherwise indicated, URI references are parsed relative to the target URI (Section 6.1).
</p>
</div>

<p>
すべての［
送信者／受信者
］は、~protocol要素の長さにおいて，最小でも 8000 個以上の~octetからなる~URIを~supportすることが`推奨される^2119。
これは，何らかの構造, 伝送路~上の表現は（例えば，~HTTP11における `request-line$p ）、一部の事例では，より大きくする必要があることを含意することに注意。
◎
It is RECOMMENDED that all senders and recipients support, at a minimum, URIs with lengths of 8000 octets in protocol elements. Note that this implies some structures and on-wire representations (for example, the request line in HTTP/1.1) will necessarily be larger in some cases.
</p>

		</section>
		<section id="resources">
<h3 title="Resources">2.5. 資源</h3>

<p>
~HTTP要請の~targetは、
`資源^dfn
と呼ばれる。
~HTTPは、資源の資質を制限しない
— 単に，資源とヤリトリするときに利用できる~interfaceを定義するに過ぎない。
ほとんどの資源は、`~URI$により識別される。
◎
The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Most resources are identified by a Uniform Resource Identifier (URI), as described in Section 2.4.
</p>

<p>
~HTTPの設計~目標の一つは、`資源$の識別を 要請の意味論から分離することである
— それは、要請の意味論を［
`要請~method$, および 要請を改変する少数の`要請~header$
］に~~帰属させることにより，アリになる。
~method意味論と`~URI$自身が含意する意味論が競合する場合、
`8.2.1$sec 【の最後の段落】にて述べるように，~method意味論が優先される。
◎
One design goal of HTTP is to separate resource identification from request semantics, which is made possible by vesting the request semantics in the request method (Section 8) and a few request-modifying header fields (Section 9). If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 8.2.1, the method semantics take precedence.
</p>

<p>
~IANAは、`~URI~scheme~registry$cite `BCP35$r を保守する。
要請は，どの~URI`~scheme$も~targetにし得るが、次に挙げる~schemeは，~HTTP~serverに内来的である
⇒＃
`http$c,
`https$c
◎
IANA maintains the registry of URI Schemes [BCP35] at &lt;https://www.iana.org/assignments/uri-schemes/&gt;. Although requests might target any URI scheme, the following schemes are inherent to HTTP servers:
◎
Table 2
URI Scheme 	Description 	Ref.
http 	Hypertext Transfer Protocol 	2.5.1
https 	Hypertext Transfer Protocol Secure 	2.5.2
</p>

<p>
［
"`http$c" ／ "`https$c"
］~URIが在ることが、［
~URIで識別される`生成元$に，接続を~listenしている~HTTP`~server$が常に在る
］ことを含意することにはならないことに注意。
［
~serverが存在するかどうか,
~serverが現在 その識別子をある資源に対応付けているかどうか
］を問わず、~URIは誰もが創出できる。
登録-済みな名前と~IP~addressは、委譲される資質があり，連合された名前空間を作成する
— そこに~HTTP~serverが在ろうが無かろうが。
◎
Note that the presence of an "http" or "https" URI does not imply that there is always an HTTP server at the identified origin listening for connections. Anyone can mint a URI, whether or not a server exists and whether or not that server currently maps that identifier to a resource. The delegated nature of registered names and IP addresses creates a federated namespace whether or not an HTTP server is present.
</p>

			<section id="http.uri">
<h4 title="http URI Scheme">2.5.1. `http^c ~URI~scheme</h4>

<p>
"`http^c" ~URI`~scheme$は、［
所与の`~port$上で~TCP （`RFC0793$r）接続を~listenすることになり得る~HTTP`生成元~server$
］により統治される階層的な名前空間の中で，【資源の】識別子を創出するためとして、ここに定義される。
◎
The "http" URI scheme is hereby defined for minting identifiers within the hierarchical namespace governed by a potential HTTP origin server listening for TCP ([RFC0793]) connections on a given port.
</p>

<pre class="bnf">
`http-URI@p
    = "http" "://" `authority$p `path-abempty$p [ "?" `query$p ]
</pre>

<p>
"`http^c" ~URI用の`生成元~server$は、 `authority$p 成分により識別される
— それは、［
`host$p 識別子, および
省略可能な~TCP `port$p 番号
］（ `RFC3986/3.2.2$sec ）を内包する。
`port$p 下位成分が［
空な場合／与えられていない場合
］の既定の~TCP~portは、
80 （ WWW ~service用に予約された~port）とする。
`生成元$は、［
識別される`資源$を~targetする要請に対し，誰が`権限的$に応答する権利を持つか
］を
— `6.3.3.1$secに定義されるように —
決定する。
◎
The origin server for an "http" URI is identified by the authority component, which includes a host identifier and optional port number ([RFC3986], Section 3.2.2). If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 6.3.3.1.
</p>

<p>
`送信者$は、［
`host$p 識別子が空にされた "`http^c" ~URI
］を`生成し$てはナラナイ。
そのような~URI参照を処理する`受信者$は、それを妥当でないものとして却下しなければナラナイ。
◎
A sender MUST NOT generate an "http" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.
</p>

<p>
［
階層的な `path$p, 省略可能な `query$p
］成分は、［
その`生成元~server$の名前空間の中で，`~target資源$になるもの
］を識別する。
◎
The hierarchical path component and optional query component identify the target resource within that origin server's name space.
</p>

			</section>
			<section id="https.uri">
<h4 title="https URI Scheme">2.5.2. `https^c ~URI~scheme</h4>

<p>
"`https^c" ~URI`~scheme$は、［
所与の`~port$上で~TCP（`RFC0793$r）接続を~listenすることになり得る`生成元~server$
］のうち［
~HTTP通信~用に`~secure化$された~TLS（`RFC8446$r）接続を確立する能力があるもの
］により統治される階層的な名前空間の中で，【資源の】識別子を創出するためとして、ここに定義される。
この文脈における，
`~secure化@
されている（ `secured^en ）とは、特定的に次を意味する
⇒
~serverは，識別された権限に利するよう動作しているものとして認証されていて、その~serverとのすべての~HTTP通信の機密性と完全性は，強い暗号化の利用を通して保護されている
◎
The "https" URI scheme is hereby defined for minting identifiers within the hierarchical namespace governed by a potential origin server listening for TCP connections on a given port and capable of establishing a TLS ([RFC8446]) connection that has been secured for HTTP communication. In this context, "secured" specifically means that the server has been authenticated as acting on behalf of the identified authority and all HTTP communication with that server has been protected for confidentiality and integrity through the use of strong encryption.
</p>

<pre class="bnf">
`https-URI@p
    = "https" "://" `authority$p `path-abempty$p [ "?" `query$p ]
</pre>

<p>
"`https^c" ~URI用の`生成元~server$は、 `authority$p 成分により識別される
— それは、［
`host$p 識別子, および
省略可能な~TCP `port$p 番号
］（ `RFC3986/3.2.2$sec ）を内包する。
`port$p 下位成分が［
空な場合／与えられていない場合
］の既定の~TCP~portは、
443 （~TLS越しの~HTTP用に予約された~port）とする。
`生成元$は、［
識別される`資源$を~targetする要請に対し，誰が`権限的$に応答する権利を持つか
］を
— `6.3.3.2$secに定義されるように —
決定する。
◎
The origin server for an "https" URI is identified by the authority component, which includes a host identifier and optional port number ([RFC3986], Section 3.2.2). If the port subcomponent is empty or not given, TCP port 443 (the reserved port for HTTP over TLS) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 6.3.3.2.
</p>

<p>
`送信者$は、［
`host$p 識別子が空にされた "`https^c" ~URI
］を`生成し$てはナラナイ。
そのような~URI参照を処理する`受信者$は、それを妥当でないものとして却下しなければナラナイ。
◎
A sender MUST NOT generate an "https" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.
</p>

<p>
［
階層的な `path$p,
省略可能な `query$p
］成分は、［
その`生成元~server$の名前空間の中で，`~target資源$になるもの
］を識別する。
◎
The hierarchical path component and optional query component identify the target resource within that origin server's name space.
</p>

<p>
`~client$は、自身による "`https^c" 資源への~HTTP要請に対し，次を確保しなければナラナイ
⇒＃
通信されるに先立って，要請は`~secure化$されること／
要請に対する応答は，`~secure化$されたものに限り受容すること
◎
A client MUST ensure that its HTTP requests for an "https" resource are secured, prior to being communicated, and that it only accepts secured responses to those requests.
</p>

<p>
"`https^c" `~scheme$を介して可用にされた`資源$は、
"`http$c" `~scheme$を伴うものとは，同一性を共有しない
— それらは、別個な名前空間を伴う，別個な`生成元$と見なされる。
しかしながら、［
同じ~hostに属する すべての`生成元$に適用されるように定義された，~HTTPに対する拡張
— ~Cookie~protocol `RFC6265$r など
］により，［
ある~serviceから設定された情報
］による［
~host~domainに合致する~groupに属する，他の~serviceとの通信
］への影響iが許容されることもある。
◎
Resources made available via the "https" scheme have no shared identity with the "http" scheme. They are distinct origins with separate namespaces. However, an extension to HTTP that is defined to apply to all origins with the same host, such as the Cookie protocol [RFC6265], can allow information set by one service to impact communication with other services within a matching group of host domains.
</p>

			</section>
			<section id="uri.comparison">
<h4 title="http and https URI Normalization and Comparison">2.5.3. `http^c／`https^c ~URI の正規化と比較</h4>

<p>
［
"`http$c" ／ "`https$c"
］`~scheme$は，~URIの汎用~構文に適合するので、そのような~URIは，［
`RFC3986/6$sec にて定義される~algo
］に則って
— 上で述べた，それぞれの`~scheme$用の既定~portを利用して —
正規化され, 比較される。
◎
Since the "http" and "https" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in Section 6 of [RFC3986], using the defaults described above for each scheme.
</p>

<p>
`port$p が `scheme$p 用の既定の~portに等しい場合、
`port$p 下位成分は省略するのが，正規な形である。
空な `path$p 成分は
— `OPTIONS$m 要請の~targetとして利用されている場合を除き —
絶対~path "`/^c" に等価であり、正規な形においては，代わりに ~path "`/^c" を供する。
［
`scheme$p ／ `host$p
］は、文字大小無視であり，正規には小文字により供される
— 他のすべての成分は、文字大小区別の下で比較される。
`reserved^p 集合（ `RFC3986/2.2$sec ）に属さない どの文字も、［
それを~percent符号化した~octet列（ `RFC3986/2.1$sec ）
］に等価になる
— 正規な形においては、それらは符号化しない。
◎
If the port is equal to the default port for a scheme, the normal form is to omit the port subcomponent. When not being used as the target of an OPTIONS request, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead. The scheme and host are case-insensitive and normally provided in lowercase; all other components are compared in a case-sensitive manner. Characters other than those in the "reserved" set are equivalent to their percent-encoded octets: the normal form is to not encode them (see Sections 2.1 and 2.2 of [RFC3986]).
</p>

<div class="example">
<p>
例えば，次の 3 つの~URIは、等価になる：
◎
For example, the following three URIs are equivalent:
</p>

<pre>
http://example.com:80/~smith/home.html
http://EXAMPLE.com/`%^7Esmith/home.html
http://EXAMPLE.com:/`%^7esmith/home.html
</pre>
</div>

			</section>
			<section id="http.userinfo">
<h4 title="Deprecated userinfo">2.5.4. 廃用にされた `userinfo^p</h4>

<p>
［
`authority$p （権限）用の~URIの汎用~構文
］には、［
利用者~認証~情報を~URI内に内包するための
`userinfo@p
下位成分（ `RFC3986/3.2.1$sec ）
］も含まれている。
そのような下位成分においては、 "`user:password^c" 形式の利用は非推奨にされた。
【 ~passwordが無いもの（ "`:^c" を含まないもの）は非推奨にされていない。】
◎
The URI generic syntax for authority also includes a userinfo subcomponent ([RFC3986], Section 3.2.1) for including user authentication information in the URI. In that subcomponent, the use of the format "user:password" is deprecated.
</p>

<p>
一部の実装は、 `userinfo^p 成分を，認証~情報の内部~環境設定
— ［
~command呼出nの~option,
環境設定~file,
~bookmark~list
］などの中など —
に用立てる
— そのような用法が［
利用者~識別子や~password
］を公開するかもしれないとしても。
◎
Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password.
</p>

<p>
`送信者$は、［
"`http^c" ／ "`https^c"
］~URI参照を［
`~target~URI$や`~field値$
］として~message内に`生成する$ときには，［
`userinfo^p 下位成分（および その "`@^c" 区切子）
］を`生成し$てはナラナイ。
◎
A sender MUST NOT generate the userinfo subcomponent (and its "@" delimiter) when an "http" or "https" URI reference is generated within a message as a target URI or field value.
</p>

<p>
`受信者$は、信用できない源から受信される［
"`http^c" ／ "`https^c"
］~URI参照を用立てる前に，［
`userinfo^p を構文解析した上で，それが在る場合は~errorとして扱う
］ベキである
— それは、~phishing攻撃の~~目的で，権限を不明瞭にするために利用された可能性が高いので。
◎
Before making use of an "http" or "https" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.
</p>

			</section>
			<section id="uri.fragment.identifiers">
<h4 title="Fragment Identifiers on http(s) URI References">2.5.5. `http^c／`https^c ~URI参照における素片~識別子</h4>

<p>
素片~識別子（ `fragment^p ）は、 `RFC3986/3.5$sec にて定義されるように，~URI`~scheme$とは独立に資源の間接的な識別を許容する。
~URIを指す一部の~protocol要素には、 `fragment$p の内包を許容するものもあれば，そうでないものもある。
それは、利用される~ABNF規則が `fragment^p を許容するかどうかにより判別される。
`fragment^p を除外した規則が利用される所では、素片は許容されない（ `6.1$sec を見よ）。
◎
Fragment identifiers allow for indirect identification of a secondary resource, independent of the URI scheme, as defined in Section 3.5 of [RFC3986]. Some protocol elements that refer to a URI allow inclusion of a fragment, while others do not. They are distinguished by use of the ABNF rule for elements where fragment is allowed; otherwise, a specific rule that excludes fragments is used (see Section 6.1).
</p>

<p class="note">注記：
素片~識別子~成分は、~URI`~scheme$用の実際の~scheme定義の一部を成さないので（
`RFC3986/4.3$sec
を見よ），上の［
"`http^c" ／ "`https^c"
］~URI`~scheme$用の~ABNF定義~内には出現しない。
◎
Note: the fragment identifier component is not part of the actual scheme definition for a URI scheme (see Section 4.3 of [RFC3986]), thus does not appear in the ABNF definitions for the "http" and "https" URI schemes above.
</p>

			</section>
		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">3. 適合性</h2>

		<section id="implementation-diversity">
<h3 title="Implementation Diversity">3.1. 実装の多様性</h3>

<div class="p">
<p>
~HTTPの設計を考慮するとき、［
すべての`~UA$は 一般用~browserで, すべての`生成元~server$は 巨大な公共~web~siteである
］ような考えに陥り易いが、実施においては，あてはまらない：
◎
When considering the design of HTTP, it is easy to fall into a trap of thinking that all user agents are general-purpose browsers and all origin servers are large public websites. That is not the case in practice.＼
</p>
<ul>
	<li>
~HTTP`~UA$には、次に挙げるものも~~普通にある
⇒＃
家電,
視聴覚機器,
計測機器,
~firmware更新~script,
~command-line~program,
~mobile~app,
~sizeや形状が様々な通信~機器,
…等々
◎
Common HTTP user agents include household appliances, stereos, scales, firmware update scripts, command-line programs, mobile apps, and communication devices in a multitude of shapes and sizes.＼
</li>
	<li>
同様に，~HTTP`生成元~server$には、次に挙げるものも~~普通にある
⇒＃
住宅用自動化設備,
環境設定-可能な~network用~component,
事務機械,
自律型robot,
~news-feed,
交通camera,
ad selector 【“広告セレクタ”】,
動画配信~platform,
…等々
◎
Likewise, common HTTP origin servers include home automation units, configurable networking components, office machines, autonomous robots, news feeds, traffic cameras, ad selectors, and video-delivery platforms.
</li>
</ul>
</div>

<p>
用語 “`~UA$” は、要請の時点に［
~software~agentと直にヤリトリしているヒト利用者が居る
］ことを含意するわけではない。
多くの事例で、`~UA$は~backgroundにて稼働するように ~installされ, あるいは環境設定されていて，その結果を（あるいは，その中の関心がある／誤りがありそうな部分のみを）今後の検分~用に保存する。
例えば，~spiderは、概して，所与の~URIから開始して［
~Webを~hypertext~graphとして巡る間，一定の挙動に従う
］よう環境設定される。
◎
The term "user agent" does not imply that there is a human user directly interacting with the software agent at the time of a request. In many cases, a user agent is installed or configured to run in the background and save its results for later inspection (or save only a subset of those results that might be interesting or erroneous). Spiders, for example, are typically given a start URI and configured to follow certain behavior while crawling the Web as a hypertext graph.
</p>

<p>
~HTTP実装の多様性は、すべての`~UA$が［
利用者に向けて対話的に何かを示唆したり,
~securityや~privacyに関する懸念のために必要十分な警告を供せる
］わけではないことを意味する。
この仕様が［
利用者~向けに~errorを報告する
］ことを要求する，少数の事例では、そのような報告が［
~error~consoleや~log~fileにのみ観測-可能である
］ことも受容-可能である。
同様に，自動化~動作についても、［
続行する前に利用者による確認を要する
］ような要件は，［
~~事前の環境設定の選択,
稼働時~option,
安全でない動作に対する単純な回避法
］などを介して~~満たされ得る
— 確認は、利用者がすでにその選択を済ませていた場合には，いかなる［
特定の利用者~interfaceや, 通常~処理の中断
］も含意しない。
◎
The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns. In the few cases where this specification requires reporting of errors to the user, it is acceptable for such reporting to only be observable in an error console or log file. Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice.
</p>

		</section>
		<section id="role-requirements">
<h3 title="Role-based Requirements">3.2. 役割に基づく要件</h3>

<div class="p">
<p>
この仕様は、［
~HTTP通信における参加者の
`役割@
］に則って，適合性の判定基準を~~適用する。
よって，~HTTP要件は、それにより拘束される挙動に依存して，次のものに設置される：
</p>
<ul ><li>`送信者$
</li><li>`受信者$
</li><li>`~client$
</li><li>`~server$
</li><li>`~UA$
</li><li>`中継者$
</li><li>`生成元~server$
</li><li>`~proxy$
</li><li>`~gateway$
</li><li>`~cache$
</li></ul>
◎
This specification targets conformance criteria according to the role of a participant in HTTP communication. Hence, HTTP requirements are placed on senders, recipients, clients, servers, user agents, intermediaries, origin servers, proxies, gateways, or caches, depending on what behavior is being constrained by the requirement.＼
</div>

<p>
また，［
単独の通信の視野を超えて適用される
］ときには、追加的な（~socialな）要件が，［
実装／資源~所有者／~protocol要素~登録
］に設置されることもある。
◎
Additional (social) requirements are placed on implementations, resource owners, and protocol element registrations when they apply beyond the scope of a single communication.
</p>

<p>
要件の中で，［
~protocol要素を作成すること
］を，［
受信した要素を 単に`下流$へ回送すること
］から相違化して記す所では、前者に対し，動詞
“`生成する@”
が， “送信する” に代わって利用される。
◎
The verb "generate" is used instead of "send" where a requirement differentiates between creating a protocol element and merely forwarding a received element downstream.
</p>

<p>
実装は、［
~HTTPにおいて自身が受け持つ各 `役割$に結付けられる，すべての要件
］に準拠するならば、適合すると見なされる。
◎
An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.
</p>

<div class="p">
<p>
適合性には、~protocol要素の［
構文, 意味論
］の両者が含まれる。
`送信者$は、次に挙げるものを，~message内に`生成し$てはナラナイ：
◎
Conformance includes both the syntax and semantics of protocol elements.＼
</p>
<ul>
	<li>
［
その送信者にとって，~~虚偽であることが既知である
］ような意味を伝達する~protocol要素。
◎
A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false.＼
</li>
	<li>
［
対応する~ABNF規則により定義される文法
］に合致しない~protocol要素。
◎
A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.＼
</li>
	<li>
［
他の`役割$（すなわち，その~messageに対し送信者が持たない`役割$）を持つ参加者
］のみに`生成する$ことが許容されている，［
~protocol要素／構文~代替
］。
◎
Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).
</li>
</ul>
</div>

		</section>
		<section id="parsing-elements">
<h3 title="Parsing Elements">3.3. 要素の構文解析-法</h3>

<div class="p">
<p>
`受信者$は，受信した~protocol要素を構文解析するときは、次をすべて~~満たすような，どの値も構文解析できなければナラナイ
⇒＃
受信者の`役割$に適用-可能である,
対応する~ABNF規則にて定義される文法に合致する,
その要素に見合う長さである
◎
When a received protocol element is parsed, the recipient MUST be able to parse any value of＼
reasonable length that is applicable to the recipient's role and＼
that matches the grammar defined by the corresponding ABNF rules.＼
↓↓＼
</p>

<p>
受信される~protocol要素には，構文解析されないものもあることに注意。
例えば，~messageを回送している`中継者$は、~構文解析器により`~field$から汎用な［
`~field名$, `~field値$
］成分を取り出しつつ, `~field値$の内側まではそれ以上 構文解析せずに，`~field$を回送することもある。
◎
Note, however, that some received protocol elements might not be parsed. For example, an intermediary forwarding a message might parse a field into generic field name and field value components, but then forward the field without further parsing inside the field value.
</p>
</div>

<p>
~HTTPにおける多くの~protocol要素は，特定の長さ制限を設けていない
— 何故なら，［
適切になるであろう長さ
］は、実装の［
配備~文脈や目的
］に依存して，~~多岐に~~渡るので。
よって，［
`送信者$と`受信者$との間の相互運用能
］は、［
各種~protocol要素に見合う長さに関して，共有されている期待
］に依存する。
更には，一部の~protocol要素に対しては、［
それに見合う長さであると共通的に解されているもの
］は，過去 20 年に渡る~HTTP利用に伴って~~変遷しており、また，将来も変わり続けるものと予期されている。
◎
HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation. Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element. Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future.
</p>

<p>
`受信者$は、最小でも［［
他の~message内の同じ~protocol要素
］に対し，自身が`生成し$得る値の長さ
］以上の長さの~protocol要素を，構文解析して処理できなければナラナイ。
例えば，［
自前の`資源$に ~~長大な~URI参照を発行する`生成元~server$
］は、［
`~target~URI$として受信した，同じ参照
］を構文解析して処理できる必要がある。
◎
At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages. For example, an origin server that publishes very long URI references to its own resources needs to be able to parse and process those same references when received as a target URI.
</p>

		</section>
		<section id="error-handling">
<h3 title="Error Handling">3.4. ~errorの取扱い</h3>

<p>
`受信者$は、受信した~protocol要素を，［
この仕様がそれに定義する意味論
— この仕様に対する拡張も含む
］に則って解釈しなければナラナイ
— ただし、受信者が［
送信者が，それらの意味論に含意されるものを不正に実装している
］ものと，（経験または環境設定を通して）決定できたときは除く。
例えば，`生成元~server$は、［
`User-Agent$h ~headerの検分
］から，［［
ある種の`内容~符号法$の受領に際し失敗する
］と既知である，特定の実装~version
］が指示されたときには、［
受信した `Accept-Encoding$h ~headerの内容
］を無視rするであろう。
◎
A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics. For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.
</p>

<p>
他が注記されない限り，`受信者$は、妥当でない構成子から，利用-可能な~protocol要素を回復しようと試みてもヨイ。
~HTTPは、［
~securityへの直接的な影響iがある
］ときを除いて，［
~errorを取扱う特定の仕組み
］を定義しない
— ~errorを取扱うにあたって要求される方針は、~protocolの応用ごとに異なるので。
例えば、~Web~browserは，［
応答の `Location$h ~headerが~ABNFに則って構文解析できない
］ときに 透過的な回復を望むかもしれないが、~system制御~clientは，いかなる形の~error回復も 危険と見なすかもしれない。
◎
Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies. For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.
</p>

<p>
一部の要請は、下層の接続が失敗した所で，~clientにより自動的に再試行され得る
— `冪等~method$secに述べられるように。
◎
Some requests can be automatically retried by a client in the event of an underlying connection failure, as described in Section 8.2.2.
</p>

		</section>
	</section>
	<section id="extending.versioning">
<h2 title="Extending and Versioning HTTP">4. ~HTTPの拡張-法と~version法</h2>

<p>
~HTTPの中核を成す意味論は、~protocol~version間で変化しないが，
それらが “伝送路~上” でどう表出されるかは変化し得るので、
伝送路~形式に対し互換でない変更が為されたときには，~HTTP~version番号は変化する。
加えて，~HTTPは、定義-済みな拡張~地点の利用を通して，~protocolに対し［
~versionを変更することなく，増分的に後方-互換な変更を為す
］ことを許容する。
◎
While HTTP's core semantics don't change between protocol versions, the expression of them "on the wire" can change, and so the HTTP version number changes when incompatible changes are made to the wire format. Additionally, HTTP allows incremental, backwards-compatible changes to be made to the protocol without changing its version through the use of defined extension points.
</p>

			<section id="extending">
<h3 title="Extending HTTP">4.1. ~HTTPの拡張-法</h3>

<p>
~HTTPは、［
新たな~versionを導入することなく，~protocolに能力を導入する
］ために利用できる汎用な拡張~地点を，いくつか定義する
— ~method（ `8.4$sec ）,
状態s~code（ `10.7$sec ）,
~headerと~trailer（ `5.7$sec ）なども含めて。
更には、定義-済み~fieldの中にも拡張能を成す地点がある（ `Caching/~cache制御~拡張$secにおける `Cache-Control$h など）。
~HTTPの意味論には~versionは無いので、これらの拡張~地点は持続的である
— 利用-中にある~protocolの~versionは、それらの意味論には影響しない。
◎
HTTP defines a number of generic extension points that can be used to introduce capabilities to the protocol without introducing a new version, including methods (Section 8.4), status codes (Section 10.7), header and trailer fields (Section 5.7), and further extensibility points within defined fields (such as Cache-Control in Section 5.2.3 of [Caching]). Because the semantics of HTTP are not versioned, these extension points are persistent; the version of the protocol in use does not affect their semantics.
</p>

<p>
~versionに依存しない拡張は、利用-中にある 特定の~protocol~version［
に依存する／
と相互作用する
］ことは忌避される。
これを避けれない場合、当の拡張は，各~version間でどう相互運用し得るかについて注意深い考慮を与える必要がある。
◎
Version-independent extensions are discouraged from depending on or interacting with the specific version of the protocol in use. When this is unavoidable, careful consideration needs to be given to how the extension can interoperate across versions.
</p>

<p>
加えて，~HTTPの特定の~versionは、自前の拡張能を成す地点を備えることもある
— ~HTTP11における`転送~符号法$（ `Transfer-Encoding$h ）,
~HTTP2における `SETTINGS^en や `frame types^en （ `RFC7540$r ）など。
これらの拡張~地点は、それらが生じた~protocolの~versionに特有になる。
◎
Additionally, specific versions of HTTP might have their own extensibility points, such as transfer-codings in HTTP/1.1 (Section 6.1 of [Messaging]) and HTTP/2 ([RFC7540]) SETTINGS or frame types. These extension points are specific to the version of the protocol they occur within.
</p>

<p>
~versionに特有な拡張は、（~methodや~headerの様な）~versionに依存しない［
仕組み／拡張~地点
］の意味論を上書きし得ず, 改変し得ない
— 当の~protocol要素が明示的にそれを許容していない限り。
例えば，`CONNECT$m ~methodは、これを許容する。
◎
Version-specific extensions cannot override or modify the semantics of a version-independent mechanism or extension point (like a method or header field) without explicitly being allowed by that protocol element. For example, the CONNECT method (Section 8.3.6) allows this.
</p>

<p>
これらの指針は、経路を成す各部が実装する~HTTP~versionが異なるときでも，~protocolが正しくかつ予測-可能に演算することを確約する。
◎
These guidelines assure that the protocol operates correctly and predictably, even when parts of the path implement different versions of HTTP.
</p>

		</section>
		<section id="protocol.version">
<h3 title="Protocol Versioning">4.2. ~protocolの~version法</h3>

<div class="p">
<p>
~HTTP
`~version番号^dfn
は、［
"." （~period／小数点）で分離される 2 個の~decimal桁（ `DIGIT$P ）
］からなる：
◎
The HTTP version number consists of two decimal digits separated by a "." (period or decimal point).＼
</p>
<ul>
	<li>
1 個目の桁
— `~major~version@ —
は、~HTTP~message法の構文を指示する。
◎
The first digit ("major version") indicates the HTTP messaging syntax, whereas＼
</li>
	<li>
2 個目の桁
— `~minor~version@ —
は、最初の桁による`~major~version$の下で，`送信者$が［
適合する, かつ
未来の通信においても解せる
］ような，最も高い~minor~versionを指示する。
◎
the second digit ("minor version") indicates the highest minor version within that major version to which the sender is conformant and able to understand for future communication.
</li>
</ul>
</div>

<p>
~protocol~versionは、それ一体として，［［
その~versionに対応する~HTTPの仕様
］にて挙げられた要件の集合
］に，`送信者$が適合していることを指示する。
例えば，~version "`HTTP/1.1^c" は、［
この文書, `Caching$r, `Messaging$r
］を組合せた仕様により定義される。
◎
The protocol version as a whole indicates the sender's conformance with the set of requirements laid out in that version's corresponding specification of HTTP. For example, the version "HTTP/1.1" is defined by the combined specifications of this document, "HTTP Caching" [Caching], and "HTTP/1.1 Messaging" [Messaging].
</p>

<p>
`~minor~version$は、`送信者$が［
~protocolの後方-互換な下位集合
］のみを利用しているときでも，［
送信者の通信~能力
］を広告し、それにより，［
未来の［
（~serverによる）応答／（~clientによる）要請
］において，より高度な特能も利用できる
］ことを受信者に知らせる。
◎
The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients).
</p>

<div class="p">
<p>
`~client$が要請~内に送信する~versionは：
◎
A client SHOULD send a request version＼
</p>
<ul>
	<li>
<p>
次を満たす，最も高い~versionにするベキである：
</p>
		<ul>
			<li>
~client自身が適合している，かつ
</li>
			<li>
その`~major~version$は、［
`~server$が~supportする，最も高い~version
］が~clientに既知である場合は，それ以下である。
</li>
		</ul>
◎
equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known.＼
</li>
	<li>
~client自身が適合していなければナラナイ。
◎
A client MUST NOT send a version to which it is not conformant.
</li>
</ul>
</div>

<p>
`~client$は、［
~serverが~HTTP仕様を不正に実装している
］ことが既知である場合，［
より低い~versionによる要請
］を送信してもヨイ
— ただし，それは、~clientが，少なくとも 1 回は通常の要請を試みて，［
`応答~状態s~code$や`~header$（例： `Server$h ）
］から［
~serverが より高い要請~versionを不適正に取扱う
］ことを決定できた後に限られる。
◎
A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.
</p>

<div class="p">
<p>
`~server$が，要請に対する応答に送信する~versionは：
◎
A server SHOULD send a response version＼
</p>
<ul>
	<li>
<p>
次を満たす，最も高い~versionにするベキである：
</p>
		<ul>
			<li>
~server自身が適合している，かつ
</li>
			<li>
その`~major~version$は、その要請にて受信したもの以下である。
</li>
		</ul>
◎
equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.＼
</li>
	<li>
~server自身が適合していなければナラナイ。
◎
A server MUST NOT send a version to which it is not conformant.＼
</li>
</ul>

<p>
`~server$は、何らかの事由で［
`~client$の~protocol`~major~version$
］に対する~serviceの拒否-を望むときは，
`505$st 応答を送信できる。
◎
A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.
</p>
</div>

<p>
`~major~version$番号は、互換でない~message構文が導入される場合に増やされる。
`~minor~version$番号は、~protocolに加えられた変更sにより，［
~message意味論が追加されるか,
`送信者$に追加的な能力が含意される
］場合に増やされる。
◎
HTTP's major version number is incremented when an incompatible message syntax is introduced. The minor number is incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender.
</p>

<div class="p">
<p>
`受信者$は、受信した~HTTP~messageが：
◎
↓</p>
<ul>
	<li>
自身が実装する`~major~version$番号 `~major^V を伴いつつ，
自身が実装するものより高い`~minor~version$番号 `~minor^V を伴うときには
⇒
その~messageを［
`~minor^V は、 `~major^V の中で 自身が適合する，最も高い`~minor~version$であった
］かのように処理するベキである。
◎
When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant.＼
</li>
	<li>
自身が~supportするより高い`~minor~version$を伴っていて，自身がまだ~supportを指示するより前に送信されてきたものである場合
⇒
その~messageを［
同じ`~major~version$のどの実装からも安全に処理できる程度に，十分に後方-互換である
］ものと見做せる。
◎
A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.
</li>
</ul>
</div>

<p>
~HTTPの`~major~version$が`~minor~version$を定義しない場合、その暗黙の`~minor~version$は， "`0^c" とする
— それは、［
~minor~versionの送信が要求される~protocol要素
］の中で，そのような~protocolを参照rするときに利用される。
◎
When a major version of HTTP does not define any minor versions, the minor version "0" is implied and is used when referring to that protocol within a protocol element that requires sending a minor version.
</p>

		</section>
	</section>
	<section id="header.and.trailer.fields">
<h2 title="Header and Trailer Fields">5. ~headerと~trailer</h2>

<p>
~HTTP~messageは、［［
~key, 値
］が成す~pair
］たちを利用して，［
~message／
~messageの`~payload$／
`~target資源$／
接続
］についての~dataを伝達する。
これらの~pairは、
`~field@
（ `HTTP field^en ／ 略して `field^en ）†と呼ばれる。
~fieldは、次の 2 種に大別される：
◎
HTTP messages use key/value pairs to convey data about the message, its payload, the target resource, or the connection. They are called "HTTP fields" or just "fields".
</p>

<ul>
	<li>
`~header@
（ `header field^en ／ 俗に `header^en ）†
は、`~message本体$より前に［
送信される／受信される
］ものを指す。
それらは、~messageの
`~header節@
（ `header field section^en ／ 略して `header section^en ）
の中に所在する。
`~header$は、［
有名~fieldのうち，`~header節$内に限り送信することが許容されるもの
］を特定的に指す【ためにも利用される】。
◎
Fields that are sent/received before the message body are referred to as "header fields" (or just "headers", colloquially) and are located within the "header section" of a message. We refer to some named fields specifically as a "header field" when they are only allowed to be sent in the header section.
</li>
	<li>
`~trailer@
（ `trailer field^en ／ 俗に `trailer^en ）†
は、`~header節$が終端した後（通例的には，`~message本体$を成す~streamが始まった後）に［
送信される／受信される
］ものを指す。
それらは、ある
`~trailer節@
（ `trailer field section^en ／ 略して `trailer section^en ）†
の中に所在する。
1 個以上の`~trailer節$がアリになるのは、利用-中の~HTTP~versionが それを~supportしていて，［
何個かの~message節に~frame化するための拡張-可能な仕組み
］により可能化されているときに限られる。
◎
Fields that are sent/received after the header section has ended (usually after the message body begins to stream) are referred to as "trailer fields" (or just "trailers", colloquially) and located within a "trailer section". One or more trailer sections are only possible when supported by the version of HTTP in use and enabled by an extensible mechanism for framing message sections.
</li>
</ul>

<p class="trans-note">【†
この訳では、もっぱら，これらの略称／俗称で表記する。
`~field$は［
~header／~trailer
］の総称になる。
これらの用語は、~HTTP以外の文脈においては（あるいは、何かの正式名称の一部を成すときは）， “~HTTP” が接頭されることもある（例： “~HTTP~header” ）。
】【
原文には、［
~header節／~trailer節
］をもっと略して，［
`headers^en ／ `trailers^en
］（複数形）と記される箇所もある。
和訳では（文脈から明らかな所では）［
“~header節” ／ “~trailer節”
］としている。
】【
~header節が［
0 個の~fieldからなること, 無いこと
］を区別して取扱うような要件は，この仕様には無いので、この訳では，~header節は概念的には常に在ると見做す。
】【
~HTTP11における［
`~header節$／`~trailer節$
］は、［
`Messaging/2.1$sec ／ `Messaging/7.1.2$sec
］に述べられる。
】
</p>

<p>
どちらの節も，任意個数の
`~field行l@
から構成される。
各~field行lは、~fieldを識別する
`~field名@
（`5.3$sec を見よ）, および
~field用の~dataを伝達する
`~field行l値@
を伴う。
◎
Both sections are composed of any number of "field lines", each with a "field name" (see Section 5.3) identifying the field, and a "field line value" that conveys data for the field.
</p>

<p>
［
`~header節$, `~trailer節$
］それぞれに対し、その節~内に在る各`~field名$には，対応する
`~field値@
がある。
それは、その節~内にある［
所与の`~field名$を伴う`~field行l値$
］すべてから構成される
— ~commaで分離されるよう，一緒に連結して。
~messageを成す~fieldたちの［
順序付け／結合
］の意味論についての更なる論は `5.1$secを見よ。
`~field値$についての更なる論は、 `5.4$sec
を見よ。
◎
Each field name present in a section has a corresponding "field value" for that section, composed from all field line values with that given field name in that section, concatenated together and separated with commas. See Section 5.1 for further discussion of the semantics of field ordering and combination in messages, and Section 5.4 for more discussion of field values.
</p>

<div class="example">
<p>
例えば，次の一節は：
◎
For example, this section:
</p>

<pre class="lang-http">
Example-Field: Foo, Bar
Example-Field: Baz
</pre>

<p>
2 個の`~field行l$を包含する。
どちらも`~field名$は "`Example-Field^c" になる。
`~field行l値$は、［
1 個目は "`Foo, Bar^c",
2 個目は "`Baz^c"
］になる。
`Example-Field^h 用の`~field値$は、
3 個の~member［
"`Foo^c", "`Bar^c", "`Baz^c"
］からなる~listになる。
◎
contains two field lines, both with the field name "Example-Field". The first field line has a field line value of "Foo, Bar", while the second field line value is "Baz". The field value for "Example-Field" is a list with three members: "Foo", "Bar", and "Baz".
</p>
</div>

<p>
`~field$の解釈は、［
同じ~HTTP`~major~version$の下での，`~minor~version$どうし
］では，変化しない
— そのような~fieldが無い下では、`受信者$の既定の挙動は，変化し得るが。
他から指定されない限り、~fieldは，すべての~versionの~HTTP用に定義される。
特に，［
`Host$h ／ `Connection$h
］~fieldは、~HTTP11への適合性を広告するかどうかに関わらず，すべての HTTP/1.x 実装において実装される~OUGHT。
【~HTTP10も含むことになる。】
◎
The interpretation of a field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change. Unless specified otherwise, fields are defined for all versions of HTTP. In particular, the Host and Connection fields ought to be implemented by all HTTP/1.x implementations whether or not they advertise conformance with HTTP/1.1.
</p>

<p>
新たな`~field$を，［
~protocol~versionを変更する
］ことなく，導入できる
— ［
それに定義される意味論
］において，［
それを認識しない`受信者$が，それを安全に無視する
］ことが許容されるならば。
`5.3.1$sec を見よ。
◎
New fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them; see Section 5.3.1.
</p>

		<section id="field.order">
<h3 title="Field Ordering and Combination">5.1. ~fieldの順序付けと結合</h3>

<p>
~message内に`~field行l$が受信される順序は、`~field名$が相違するものどうしでは，有意でない。
しかしながら、［
要請における `Host$h, 応答における `Date$h などの，`制御~data$を包含する~header
］を最初に送信することは，良い実施とされる
— 実装は、より早く，~messageを取扱うかどうか裁定できるようになるので。
`~server$は、要請の`~header節$全体が受信されるまで，要請をその`~target資源$に適用してはナラナイ
—  後に続く~header`~field行l$は、要請~処理に影響iするような［
`条件付き要請$ ／
認証~用の`資格証$ ／
故意に誤誘導するように重複された~header
］を内包することもあるので。
◎
The order in which field lines with differing names are received in a message is not significant. However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible. A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header field lines might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing.
</p>

<p>
`受信者$は、~messageの意味論を変更することなく［
`~field名$が同じである複数個の`~field行l$
］を 1 個の`~field行l$に
`結合-@
してもヨイ
— それらのうち［
最初の`~field行l$の`~field値$
］に，後続の各`~field行l値$を［
現れた順に、~commaと `OWS$p （省略可能な空白）で分離した上で，付加する
］ことにより。
一貫性を得るためには、［
~comma, `SP$P
］並びを利用すること。
◎
A recipient MAY combine multiple field lines with the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma and OWS (optional whitespace). For consistency, use comma SP.
</p>

<p>
したがって、［
同じ`~field名$を伴う複数個の`~field行l$
］が受信される順序は，［
結合された`~field値$の解釈
］において有意になる —
`~proxy$は、~messageを回送するときに，これらの`~field行l値$の順序を変更してはナラナイ。
◎
The order in which field lines with the same name are received is therefore significant to the interpretation of the field value; a proxy MUST NOT change the order of these field line values when forwarding a message.
</p>

<p>
すなわち、よく知られた例外（下に注記される）は別として，および［
当の~fieldの定義にて，［
`~field名$が同じである複数個の`~field行l$を（［
`~header節$または`~trailer節$
］内で）`結合-$し直す
］ことが許容されている（すなわち、当の`~field値$の定義を成す ある代替が，~ABNF規則
<code>#(`values^p)</code>
などとして ~comma区切りの~list（ `5.5$sec ）を許容している）場合
］を除き、`送信者$は，同じ~message内に
⇒＃
`~field名$が同じ複数個の`~field行l$を`生成し$てはナラナイ／
すでに存在する`~field行l$と同じ`~field名$を伴う`~field行l$を付加してはナラナイ
◎
This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers), or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list [i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.5].
</p>

<p class="trans-note">【
~messageを回送するときなど，~field行lを生成しない場合の取扱いは
— 同じ~field名を伴う~field行lが複数個あっても —
この要件から外されているが、それらのうちいずれかの`~field行l値$を改変する動作は，当の~field行lを生成した（または除去してから付加し直した）ものと見なされ，この要件の対象にされよう。
】</p>

<p class="note">注記：
`Set-Cookie^h ~header（`RFC6265$r）は，~list構文を利用せず、実施においては，同じ応答~message内に複数個の`~field行l$にわたって出現することが多い。
すなわち，［
同じ`~field名$を伴う複数個の`~field行l$に課される，上の要件
］に違反している。
それは， 1 個の `~field値$に結合できないので、`受信者$は，~fieldたちを処理する際に
`Set-Cookie$h を特別~事例として取扱う~OUGHT（
詳細は `Kri2001$r
<a href="http://arxiv.org/abs/cs.SE/0105018#appendix-A.2.3">付録 A.2.3</a>
を見よ）。
◎
Note: In practice, the "Set-Cookie" header field ([RFC6265]) often appears in a response message across multiple field lines and does not use the list syntax, violating the above requirements on multiple field lines with the same field name. Since it cannot be combined into a single field value, recipients ought to handle "Set-Cookie" as a special case while processing fields. (See Appendix A.2.3 of [Kri2001] for details.)
</p>

		</section>
		<section id="field.limits">
<h3 title="Field Limits">5.2. ~fieldの長さ制限</h3>

<p>
`適合性$sec にて述べたように、~HTTPは、各［
`~field行l$／
`~field値$／
一体としての`~header節$／
一体としての`~trailer節$
］の長さに，定義済み制限を設置しない。
実施においては、個々の長さには，特定の~fieldの意味論に依存して，様々な場当的な制限が見出されることも多い。
◎
HTTP does not place a predefined limit on the length of each field line, field value, or on the length of a header or trailer section as a whole, as described in Section 3. Various ad hoc limitations on individual lengths are found in practice, often depending on the specific field's semantics.
</p>

<p>
`~server$は、［
自身が望んで処理する大きさ
］を超えるような~header［
`~field行l$／`~field値$／`~field$の集合
］を伴う要請を受信したときは，［
適切な `4xx$st 状態s~code
］で応答しなければナラナイ。
そのような~headerを【代わりに】無視することは、`要請~密入~攻撃$ `Messaging$r に対する~serverの脆弱性を高めることになる。
◎
A server that receives a request header field line, field value, or set of fields larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code. Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 11.2 of [Messaging]).

<p>
`~client$は、［
自身が望んで処理する大きさを超えるような`~field行l$
］を受信したときは、その`~field$の意味論にて［
その値が落とされても，［
~message~frame法や, 応答の意味論
］を変更することなく，安全に無視できる
］ならば、その`~field行l$を破棄するか, 【その`~field行l値$を？】切落してもヨイ。
◎
A client MAY discard or truncate received field lines that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.
</p>

		</section>
		<section id="field.names">
<h3 title="Field Names">5.3. ~field名</h3>

<p>
`field-name$p ~tokenが、`~field名$を与える。
それは、対応する`~field値$を［
その名前の`~field$により定義される意味論
］を有するものと定める。
例えば， `Date$h ~headerは、［
それが出現する~messageの，出生時の時刻印
］を包含しているものと定義される。
◎
The field-name token labels the corresponding field value as having the semantics defined by that field. For example, the Date header field is defined in Section 11.1.1 as containing the origination timestamp for the message in which it appears.
</p>

<pre class="bnf">
`field-name@p
    = `token$p
</pre>

<p>
`~field名$は文字大小無視であり、
`~HTTP~field名~registry$cite
の中に登録される~OUGHT。
`5.3.2$sec を見よ。
◎
Field names are case-insensitive and ought to be registered within the "Hypertext Transfer Protocol (HTTP) Field Name Registry"; see Section 5.3.2.
</p>

<p class="trans-note">【参考：
~HTTP2においては、`~field名$は，送信する前に小文字のみに強制される。
】</p>

<p>
新たな`~field$を定義している仕様の策定者には、短いが記述的な`~field名$を選ぶよう勧める。
短い名前は、無用な~data伝送を避ける。
記述的な名前は、より広く利用されているかもしれない他の名前との混同や “名前の独り占め” を避ける。
◎
Authors of specifications defining new fields are advised to choose a short but descriptive field name. Short names avoid needless data transmission; descriptive names avoid confusion and "squatting" on names that might have broader uses.
</p>

<p>
そのため，限定的に利用される~field（単独の［
応用／利用事例
］に限定される~headerなど）には、その用途の名前（または略語）を接頭辞として含む名前を利用することが奨励される。
例えば， “Description” ~fieldが必要な応用 “Foo” は、
"`Foo-Desc^c" を利用することになろう
— "`Description^c" では汎用に過ぎ， "`Foo-Description^c" では無用に長いので。
◎
To that end, limited-use fields (such as a header confined to a single application or use case) are encouraged to use a name that includes its name (or an abbreviation) as a prefix; for example, if the Foo Application needs a Description field, it might use "Foo-Desc"; "Description" is too generic, and "Foo-Description" is needlessly long.
</p>

<p>
`field-name$p 構文は、どの~token文字も許容するものと定義されているが、実施においては，
`field-name$p 内に受容する文字に対し制限sを設置する実装もある。
相互運用可能になるよう、新たな`~field名$は，［
英数字 ／ "`-^c" ／ "`.^c"
］のみからなっていて，英数字から始まるよう拘束するベキである。
【 "`_^c" は含まない。】
◎
While the field-name syntax is defined to allow any token character, in practice some implementations place limits on the characters they accept in field-names. To be interoperable, new field names SHOULD constrain themselves to alphanumeric characters, "-", and ".", and SHOULD begin with an alphanumeric character.
</p>

<p>
`~field名$には、 "`X-^c" を接頭しない~OUGHT
— 更なる情報は `BCP178$r を見よ。
◎
Field names ought not be prefixed with "X-"; see [BCP178] for further information.
</p>

<p>
`~field名$には、他の接頭辞が利用されることもある。
例えば，多くの内容~折衝~headerには、 "`Accept-^c" が利用されている。
これらの接頭辞は、`~field$の目的を認識する援助でしかなく，自動的な処理を誘発することはない。
【とは言え，`禁止~header名$の "`Sec-^c" のように、他の仕様により，特別な要件が一律に課される接頭辞もある。】
◎
Other prefixes are sometimes used in HTTP field names; for example, "Accept-" is used in many content negotiation headers. These prefixes are only an aid to recognizing the purpose of a field, and do not trigger automatic processing.
</p>

			<section id="field.extensibility">
<h4 title="Field Extensibility">5.3.1. ~fieldの拡張能</h4>

<p>
新たな`~field名$の導入（大概は新たな意味論を定義する）に制限はない。
◎
There is no limit on the introduction of new field names, each presumably defining new semantics.
</p>

<div class="p">
<p>
新たな`~field$は、次のいくつかを行い得るように定義できる：
◎
New fields can be defined such that,＼
</p>
<ul>
	<li>
`受信者$により解されるときの［
以前に定義された`~field$の解釈
］を［
上書きする／増強する
］。
◎
when they are understood by a recipient, they might override or enhance the interpretation of previously defined fields,＼
</li>
	<li>
要請を評価する際の`事前条件$を定義する。
◎
define preconditions on request evaluation, or＼
</li>
	<li>
応答の意味を精緻化する。
◎
refine the meaning of responses.
</li>
</ul>
</div>

<div class="p">
<p>
`~proxy$は、自身が認識しない各`~header$を回送しなければナラナイ
— 次のいずれかの場合を除いて：
◎
A proxy MUST forward unrecognized header fields unless＼
</p>
<ul>
	<li>
その`~field名$は、 `Connection$h ~headerに~listされている。
◎
the field name is listed in the Connection header field (Section 6.8) or＼
</li>
	<li>
~proxy自身が、そのような`~field$を［
阻止する, あるいは`形式変換-$する
］ように，特定的に環境設定されている。
◎
the proxy is specifically configured to block, or otherwise transform, such fields.＼
</li>
</ul>

<p>
他の`受信者$は、自身が認識しない各［
`~header$／`~trailer$
］を無視するベキである。
◎
Other recipients SHOULD ignore unrecognized header and trailer fields.＼
</p>

<p>
これらの要件により、配備されている`中継者$における更新を事前に要求することなく，~HTTPの機能性を増強することが可能になる。
◎
These requirements allow HTTP's functionality to be enhanced without requiring prior update of deployed intermediaries.
</p>
</div>

			</section>
			<section id="field.name.registry">
<h4 title="Field Name Registry">5.3.2. ~field名~registry</h4>

<p>
`~HTTP~field名~registry$cite
が，~HTTP`~field名$用の名前空間を定義する。
◎
The "Hypertext Transfer Protocol (HTTP) Field Name Registry" defines the namespace for HTTP field names.
</p>

<p>
どの主体も~HTTP`~field$の登録を要請できる。
新たな~HTTP`~field$を作成するときに織り込む考慮点については、
`5.7$sec を見よ。
◎
Any party can request registration of a HTTP field. See Section 5.7 for considerations to take into account when creating a new HTTP field.
</p>

<p>
`~field名$の登録~要請は、［
`~HTTP~field名~registry$cite
に所在する指示書きに従うか，
"ietf-http-wg@ietf.org" ~mailing-list宛に~emailを送信する
］ことにより為せる。
◎
The "Hypertext Transfer Protocol (HTTP) Field Name Registry" is located at &lt;https://www.iana.org/assignments/http-fields/&gt;. Registration requests can be made by following the instructions located there or by sending an email to the "ietf-http-wg@ietf.org" mailing list.
</p>

<p>
`~field名$は、
<a href="~RFCx/rfc8126.html#section-5">指名された専門家</a>
（ IESG, または その代表者により任命される）による助言の下で登録される。
位置付け `恒久的^i を伴う`~field$は、仕様~化が要求される（ `RFC8126/4.6$sec ）。
◎
Field names are registered on the advice of a Designated Expert (appointed by the IESG or their delegate). Fields with the status 'permanent' are Specification Required ([RFC8126], Section 4.6).
</p>

<p>
登録~要請は、少なくとも次に挙げる情報からなる：
◎
Registration requests consist of at least the following information:
</p>

<dl>
	<dt>
`Field name:^en
（~field名）
</dt>
	<dd>
要請された`~field名$。
`field-name$p 構文に適合しなければナラナイ
— それは、［
英字, 数字, ~hyphen ('-'）, ~underscore ('_')
］文字のみからなる, かつ最初の文字は英字
に制約されるベキである。
◎
The requested field name. It MUST conform to the field-name syntax defined in Section 5.3, and SHOULD be restricted to just letters, digits, hyphen ('-') and underscore ('_') characters, with the first character being a letter.
</dd>

	<dt>
`Status:^en
（位置付け）
</dt>
	<dd>
次のいずれか
⇒
`恒久的^i（ `permanent^en ）,
`暫定的^i（ `provisional^en ）
◎
"permanent" or "provisional".
</dd>

	<dt>
`Specification document(s):^en
（仕様~文書）
</dt>
	<dd>
当の`~field$を指定する文書への参照。
文書の複製を検索取得するために利用できる~URIを含める方が好ましい。
関連な各~節の指示も含ませれるが、要求されてはいない。
◎
Reference to the document that specifies the field, preferably including a URI that can be used to retrieve a copy of the document. An indication of the relevant section(s) can also be included, but is not required.
</dd>
</dl>

<div class="p">
<p>
および，任意選択で、次に挙げるものも：
</p>
<dl>
	<dt>
`Comments:^en
（~comment）
</dt>
	<dd>
追加的な情報
— 予約-済みかどうかなど
</dd>
</dl>
◎
And, optionally:
Comments: Additional information, such as about reserved entries.
</div>

<p>
専門家（たち）は、~communityとの協議の下で，~registry内に収集されることになる追加的な`~field$を定義できる。
◎
The Expert(s) can define additional fields to be collected in the registry, in consultation with the community.
</p>

<p>
標準により定義される名前の位置付けは `恒久的^i とする。
他の名前も［
~communityとの協議の下で、当の専門家（たち）が，それが利用-中にあると見出した
］ならば、 `恒久的^i として登録できる。
他の名前は、 `暫定的^i として登録されるべきである。
◎
Standards-defined names have a status of "permanent". Other names can also be registered as permanent, if the Expert(s) find that they are in use, in consultation with the community. Other names should be registered as "provisional".
</p>

<p>
専門家（たち）は、`暫定的^i ~entryを除去できる
— ~communityとの協議の下で、利用-中でないものと見出したならば。
当の専門家（たち）は、いつでも， `暫定的^i ~entryの位置付けを `恒久的^i に変更できる。
◎
Provisional entries can be removed by the Expert(s) if — in consultation with the community — the Expert(s) find that they are not in use. The Experts can change a provisional entry's status to permanent at any time.
</p>

<p>
第三者主体（当の専門家（たち）も含む）も，名前を登録できることに注意
— 当の専門家（たち）が［
未登録の名前が、広範に配備されていて，さもなければ適時な方式で登録される見込みが低い
］と決定した場合には。
◎
Note that names can be registered by third parties (including the Expert(s)), if the Expert(s) determines that an unregistered name is widely deployed and not likely to be registered in a timely manner otherwise.
</p>

			</section>
		</section>
		<section id="field.values">
<h3 title="Field Values">5.4. ~field値</h3>

<p>
~HTTP`~field値$の構文は、概して~ABNF（`RFC5234$r）を利用して
— 必要とされるなら， `5.5$sec に定義される拡張も利用して —
定義される。
また、通例的に，US-ASCII 文字の範囲に拘束される。
より広~範囲な文字を必要とする`~field$は、`RFC8187$r にて定義されるものなどの，符号化法を利用できる。
◎
HTTP field values typically have their syntax defined using ABNF ([RFC5234]), using the extension defined in Section 5.5 as necessary, and are usually constrained to the range of US-ASCII characters. Fields needing a greater range of characters can use an encoding such as the one defined in [RFC8187].
</p>

<pre class="bnf">
`field-value@p
    = *`field-content$p
`field-content@p
    = `field-vchar$p [ 1*( `SP$P / `HTAB$P / `field-vchar$p ) `field-vchar$p ]
`field-vchar@p
    = `VCHAR$P / `obs-text$p
</pre>

<p>
歴史的に，~HTTPは、ISO-8859-1 ~charset `ISO-8859-1$r の~textによる`~field$内容を許容し、他の~charsetの~supportは， `RFC2047$r 符号化法の利用を通してのみ許容してきた。
実施においては、ほとんどの~HTTP`~field値$は［
~US-ASCII~charset `USASCII$r の下位集合
］のみを利用している。
新たに定義される`~field$は、その`~field値$を，~US-ASCII~octetに制限するベキである。
`受信者$は、`~field$内容 内の他の~octet（ `obs-text$p ）を，不透明な~dataとして扱うベキである。
◎
Historically, HTTP allowed field content with text in the ISO‑8859‑1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. In practice, most HTTP field values use only a subset of the US-ASCII charset [USASCII]. Newly defined fields SHOULD limit their values to US‑ASCII octets. A recipient SHOULD treat other octets in field content (obs‑text) as opaque data.
</p>

<p>
`CR$P や `LF$P などの制御-文字（ `CTL$P ）を包含している~field値は、妥当でない
— 受信者は、そのような~field値を却下するか，~messageを［
処理する／回送する
］前に制御-文字を `SP$P に変換しなければナラナイ。
◎
Field values containing control (CTL) characters such as CR or LF are invalid; recipients MUST either reject a field value containing control characters, or convert them to SP before processing or forwarding the message.
</p>

<p>
生の~field値における頭部／尾部の`空白$は、`~field$を構文解析する際に除去される（例： `Messaging/5.1$sec ）。
~field定義において，値における頭部／尾部の`空白$が有意になる所では、
`quoted-string$p などの~container構文を~~要することになる。
◎
Leading and trailing whitespace in raw field values is removed upon field parsing (e.g., Section 5.1 of [Messaging]). Field definitions where leading or trailing whitespace in values is significant will have to use a container syntax such as quoted-string (Section 5.4.1.2).
</p>

<p>
~comma（ "`,^c" ）は、`~field値$内の~memberたちを分離するために利用されることが多い。
複数個の~memberを許容する~fieldを指して、
`~listに基づく~field@
（ `list-based field^en ）という。
1 個の~memberしか見越さない~fieldを指して、
`単数~field@
（ `singleton field^en ）という。
◎
Commas (",") often are used to separate members in field values. Fields that allow multiple members are referred to as list-based fields. Fields that only anticipate a single member are referred to as singleton fields.
</p>

<p>
~commaは，~member間の汎用な区切子として利用されるので、そのような各~memberの中の~dataとして許容される場合，~careの下で扱う必要がある。
これは、~listに基づく~fieldのみならず，`単数~field$にも該当する
— `単数~field$は、誤って複数個の~memberで送信されるかもしれないので。
この条件が検出-可能になれば、相互運用能は改善される。
~memberの中に［
`HTTP-date$p や `URI-reference$p などの，~commaを包含する要素
］を期待する~fieldは、［
~list分離子が在ったとしても，要素の中の~commaと判別できる
］よう，当の要素の前後を区切子で括るように定義される~OUGHT。
◎
Because commas are used as a generic delimiter between members, they need to be treated with care if they are allowed as data within a member. This is true for both list-based and singleton fields, since a singleton field might be sent with multiple members erroneously; being able to detect this condition improves interoperability. Fields that expect to contain a comma within a member, such as an HTTP-date or URI-reference element, ought to be defined with delimiters around that element to distinguish any comma within that data from potential list separators.
</p>

<div class="example">
<p>
例えば，［
~textな日時, `~URI$
］（ともに~commaを包含し得る）は、次の様にして，`~listに基づく~field$の`~field値$内で安全に運べる:
◎
For example, a textual date and a URI (either of which might contain a comma) could be safely carried in list-based field values like these:
</p>

<pre class="lang-http">
Example-URI-Field: "http://example.com/a.html,foo", "http://without-a-comma.example.com/"
Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
</pre>
</div>

<p>
`二重引用符$ 区切子は、ほぼ常に，
`quoted-string$p 生成規則と伴に利用されることに注意
— `二重引用符$の内側で異なる構文を利用した場合、不必要な混同をもたらす見込みが高くなる。
◎
Note that double-quote delimiters almost always are used with the quoted-string production; using a different syntax inside double-quotes will likely cause unnecessary confusion.
</p>

<p>
多くの`~field$（ `Content-Type$h など）は、`~parameter$用に共通な構文を利用する
— それは、~parameter値（ `parameter-value$p ）用の構文に［
引用符~無し（ `token$p ）と有り（ `quoted-string$p ）
］両者とも許容する。
共通な構文を利用すれば、`受信者$は，既存の構文解析器を再利用できるようになる。
両~形とも許容するときは、どちらの形で受信しようが，~parameter値の意味は同じになる~OUGHT。
◎
Many fields (such as Content-Type, defined in Section 7.2.1) use a common syntax for parameters that allows both unquoted (token) and quoted (quoted-string) syntax for a parameter value (Section 5.4.1.4). Use of common syntax allows recipients to reuse existing parser components. When allowing both forms, the meaning of a parameter value ought to be the same whether it was received as a token or a quoted string.
</p>

<p>
歴史的に，~HTTP`~field値$は、複数~行lにも渡れるように拡張されていた
— 2 行l~目 以降の各~行lに， 1 個~以上の［
`SP$P や `HTAB$P
］を先行させること（ `obs-fold$p ）により。
この文書は、`~field値$を解釈するに先立って，そのような廃用にされた行l折返しは
— `Messaging/5.2$sec に述べるように —
1 個以上の `SP$P ~octetに置換されていると見做す。
◎
Historically, HTTP field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This document assumes that any such obsolete line folding has been replaced with one or more SP octets prior to interpreting the field value, as described in Section 5.2 of [Messaging].
</p>

<p class="note">注記：
この仕様は、（ `RFC7230$r より前に発行された）早期の版で行われていたような，各［
"`Field Name: Field Value^c" ~pair
］を定義する~ABNF規則は利用しない。
代わりに、~ABNF規則は、登録-済みな各`~field名$に則って命名される
【例： `Content-Length$p 】
— そこでの規則は、その`~field$に対応する`~field値$（すなわち、汎用~field構文解析器により，~field値が抽出された後の値）が妥当になるための文法を定義する。
◎
Note: This specification does not use ABNF rules to define each "Field Name: Field Value" pair, as was done in earlier editions (published before [RFC7230]). Instead, ABNF rules are named according to each registered field name, wherein the rule defines the valid grammar for that field's corresponding field values (i.e., after the field value has been extracted by a generic field parser).
</p>

			<section id="field.components">
<h4 title="Common Field Value Components">5.4.1. ~field値に共通な成分</h4>

<p>
多くの~HTTP`~field値$は、何個かの共通な構文~成分を利用して定義され，それらの成分は［
`空白$や, 特定の区切子~文字
］で分離される。
区切子は［
~US-ASCII印字可能~文字（ `VCHAR$P ）のうち，
`token$p 内には許容されないもの
］の集合（
`DQUOTE$P および "<code>(),/:;&lt;=&gt;?@[\]{}</code>"
）から選ばれる：
◎
Many HTTP field values are defined using common syntax components, separated by whitespace or specific delimiting characters. Delimiters are chosen from the set of US-ASCII visual characters not allowed in a token (DQUOTE and "(),/:;&lt;=&gt;?@[\]{}").
</p>

				<section id="tokens">
<h5 title="Tokens">5.4.1.1. ~token</h5>


<p id="rule.token.separators">
~tokenは、空白や区切子を内包しない，短い~textな識別子である：
◎
Tokens are short textual identifiers that do not include whitespace or delimiters.
</p>

<pre class="bnf">
`token@p
    = 1*`tchar$p

`tchar@p
    = "!" / "#" / "$" / "`%^" / "&amp;" / "'" / "*"
    / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
    / `DIGIT$P / `ALPHA$P
    ; <span class="comment">
区切子を除く，任意の `VCHAR$P
◎
any VCHAR, except delimiters
</span>
</pre>

				</section>
				<section id="quoted.strings">
<h5 title="Quoted Strings">5.4.1.2. 引用符~付き文字列</h5>

<p id="rule.quoted-string">
~textによる文字列は、二重引用符（ `DQUOTE^P ）で括られていれば，単独の値として構文解析される：
◎
A string of text is parsed as a single value if it is quoted using double-quote marks.
</p>

<pre class="bnf">
`quoted-string@p
    = `DQUOTE$P *( `qdtext$p / `quoted-pair$p ) `DQUOTE$P
`qdtext@p
    = `HTAB$P / `SP$P / `21^X / `23-5B^X / `5D-7E^X / `obs-text$p
`obs-text@p
    = `80-FF^X
</pre>

<p id="rule.quoted-pair">
構成子［
`quoted-string$p ／ `comment$p
］の中では、 1 個の~octetをエスケープする仕組みとして，~backslash（"`\^c"）を利用できる。
`受信者$は、 `quoted-string$p による値を処理するときには、
`quoted-pair$p を，それが［
~backslashの直後の~octetに置換されていた
］かのように取扱わなければナラナイ。
◎
The backslash octet ("\") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.
</p>

<pre class="bnf">
`quoted-pair@p
    = "\" ( `HTAB$P / `SP$P / `VCHAR$P / `obs-text$p )
</pre>

<div class="p">
<p>
`送信者$は、［
`quoted-string$p ／ `comment$p
］内に `quoted-pair$p を`生成する$ベキでない
— 次に挙げる~octetをエスケープするときを除いて：
</p>
<ul>
	<li>
`quoted-string$p の中の［
`DQUOTE$P, ~backslash
］
</li>
	<li>
`comment$p の中の［
丸括弧, ~backslash
］
</li>
</ul>
◎
A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string.＼
A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses ["(" and ")"] and backslash octets occurring within that comment.
</div>

				</section>
				<section id="comments">
<h5 title="Comments">5.4.1.3. ~comment</h5>

<p id="rule.comment">
一部の~HTTP`~field$では、丸括弧（ "`(^c", "`)^c" ）で括ることで，~commentを内包させられる。
~commentが許容されるのは、［
`~field値$の定義の一部に "`comment$p" を包含している`~field$
］内に限られる：
◎
Comments can be included in some HTTP fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing "comment" as part of their field value definition.
</p>

<pre class="bnf">
`comment@p
    = "(" *( `ctext$p / `quoted-pair$p / `comment$p ) ")"
`ctext@p
    = `HTAB$P / `SP$P / `21-27^X / `2A-5B^X / `5D-7E^X / `obs-text$p
</pre>

				</section>
				<section id="parameter">
<h5 title="Parameters">5.4.1.4. ~parameters</h5>

<p id="rule.parameter">
~parameters（ `parameters$p ）は、
0 個以上の~parameterを与える
— それは、ある~itemに補助的な情報を付加するための共通な構文として，`~field値$の中で利用されることが多い。
各~parameter（ `parameter$p ）は、［
名前, 値
］が成す~pairを（ 名前=値 の形で）与える
— 各~pairは、通例的に，直前の~semicolonにより区切られる。
◎
Parameters are zero or more instances of a name=value pair; they are often used in field values as a common syntax for appending auxiliary information to an item. Each parameter is usually delimited by an immediately preceding semicolon.
</p>

<pre class="bnf">
`parameters@p
    = *( `OWS$p ";" `OWS$p [ `parameter$p ] )
`parameter@p
    = `parameter-name$p "=" `parameter-value$p
`parameter-name@p
    = `token$p
`parameter-value@p
    = ( `token$p / `quoted-string$p )
</pre>

<p>
~parameterの名前を成す `parameter-name$p は、文字大小無視である。
~parameterの値を成す `parameter-value$p が文字大小区別になるかどうかは、名前の意味論に依存する。
~parameterの例, および一部の等価な形は、`~MIME型$, `Accept$h ~headerに見られる。
◎
Parameter names are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. Examples of parameters and some equivalent forms can be seen in media types (Section 7.1.1) and the Accept header field (Section 9.4.1).
</p>

<p>
`token$p 生成規則に合致する `parameter$p 値は、［
`token$p として，または
`quoted-string$p の中に
］伝送できる。
値は、引用符の有無に関わらず，等価になる。
◎
A parameter value that matches the token production can be transmitted either as a token or within a quoted-string. The quoted and unquoted values are equivalent.
</p>

<p class="note">注記：
~parameterにおける文字 "`=^c" の前後には、`空白$は許容されない（ “不良” 空白（ `BWS$p ）であっても）。
◎
Note: Parameters do not allow whitespace (not even "bad" whitespace) around the "=" character.
</p>

				</section>
				<section id="http.date">
<h5 title="Date/Time Formats">5.4.1.5. 日付時刻の形式</h5>

<p>
1995 年より前は、時刻印を通信するときに， 3 種の形式が~serverで共通的に利用されていた。
古い実装との互換性を得るため、その 3 種すべては，ここに定義される。
選好される形式は、［
`Internet Message Format^cite `RFC5322$r
に利用されている，日付時刻~仕様
］の下位集合
— 固定的な長さ, かつ単~時間帯なそれ（ `IMF-fixdate$p ） —
である。
◎
Prior to 1995, there were three different formats commonly used by servers to communicate timestamps. For compatibility with old implementations, all three are defined here. The preferred format is a fixed-length and single-zone subset of the date and time specification used by the Internet Message Format [RFC5322].
</p>

<pre class="bnf">
`HTTP-date@p
    = `IMF-fixdate$p
    / `obs-date$p
</pre>

<div class="example">
<p>
選好される形式の例：
◎
An example of the preferred format is
</p>

<pre class="lang-http">
Sun, 06 Nov 1994 08:49:37 GMT    ; `IMF-fixdate^p
</pre>

<p>
廃用にされた 2 種の形式の例（順に，廃用にされた RFC 850 形式, ANSI C の `asctime()^c 形式）：
◎
Examples of the two obsolete formats are
</p>

<pre class="lang-http">
Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
</pre>
</div>

<p>
`受信者$は、~HTTP~field内の時刻印 値を構文解析するときは，
3 種の `HTTP-date$p 形式すべてを受容しなければナラナイ。
`送信者$は、［
`HTTP-date$p による時刻印を包含する~field
］を`生成する$ときは，
`IMF-fixdate$p 形式による時刻印を`生成し$なければナラナイ。
◎
A recipient that parses a timestamp value in an HTTP field MUST accept all three HTTP-date formats. When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.
</p>

<p>
`HTTP-date$p 値は、時刻を［
~UTC（ `Coordinated Universal Time^en ）の~instance
］として表現する。
最初の 2 種の形式は、［
~UTC名の~~前身である， `Greenwich Mean Time^en （~~グリニッジ~~平均時）の~~頭字語 “GMT”
］による~UTCを指示する
— ［
`asctime^p 形式~内の値
］は~UTCであるものと見做される。
局所的な時計から `HTTP-date$p 値を`生成する$`送信者$は、その時計を~UTCと同期させるため，
~NTP（ `RFC5905$r ）または 何らかの類似な~protocolを利用する~OUGHT。
◎
An HTTP-date value represents time as an instance of Coordinated Universal Time (UTC). The first two formats indicate UTC by the three-letter abbreviation for Greenwich Mean Time, "GMT", a predecessor of the UTC name; values in the asctime format are assumed to be in UTC. A sender that generates HTTP-date values from a local clock ought to use NTP ([RFC5905]) or some similar protocol to synchronize its clock to UTC.
</p>

<p>
選好される形式は：
◎
Preferred format:
</p>

<pre class="bnf">
`IMF-fixdate@p
    = `day-name$p "," SP `date1$p SP `time-of-day$p SP `GMT$p
    ; <span class="comment">
固定的な［ 長さ／時間帯／~~大文字頭字 ］による下位集合が成す形式 — `RFC5322/3.3$sec を見よ
◎
fixed length/zone/capitalization subset of the format; see Section 3.3 of [RFC5322]
</span>

`day-name@p
    = ~Ps"Mon"
    / ~Ps"Tue"
    / ~Ps"Wed"
    / ~Ps"Thu"
    / ~Ps"Fri"
    / ~Ps"Sat"
    / ~Ps"Sun"

`date1@p
    = `day$p SP `month$p SP `year$p
    ; `例：^com 02 Jun 1982

`day@p
    = 2DIGIT
`month@p
    = ~Ps"Jan"
    / ~Ps"Feb"
    / ~Ps"Mar"
    / ~Ps"Apr"
    / ~Ps"May"
    / ~Ps"Jun"
    / ~Ps"Jul"
    / ~Ps"Aug"
    / ~Ps"Sep"
    / ~Ps"Oct"
    / ~Ps"Nov"
    / ~Ps"Dec"
`year@p
    = 4DIGIT

`GMT@p
    = ~Ps"GMT"

`time-of-day@p
    = `hour$p ":" `minute$p ":" `second$p
    ; 00:00:00 - 23:59:60 `（うるう秒（ leap second ））^com

`hour@p
    = 2DIGIT
`minute@p
    = 2DIGIT
`second@p
    = 2DIGIT
</pre>

<p>
廃用にされた形式は：
◎
Obsolete formats:
</p>

<pre class="bnf">
`obs-date@p
    = `rfc850-date$p
    / `asctime-date$p

`rfc850-date@p
    = `day-name-l$p "," SP `date2$p SP `time-of-day$p SP GMT
`date2@p
    = `day$p "-" `month$p "-" 2DIGIT
    ; `例：^com 02-Jun-82

`day-name-l@p
    = ~Ps"Monday"
    / ~Ps"Tuesday"
    / ~Ps"Wednesday"
    / ~Ps"Thursday"
    / ~Ps"Friday"
    / ~Ps"Saturday"
    / ~Ps"Sunday"

`asctime-date@p
    = `day-name$p SP `date3$p SP `time-of-day$p SP `year$p
`date3@p
    = `month$p SP ( 2DIGIT / ( SP 1DIGIT ))
    ; `例：^com Jun  2
</pre>

<p>
`HTTP-date$p は文字大小区別である。
`送信者$は、 `HTTP-date$p 内に，［
文法~内に `SP$P として特定的に内包されたもの
］以外の 余計な`空白$を`生成し$てはナラナイ。
［
`day-name$p, `day$p, `month$p, `year$p, `time-of-day$p
］の意味論は、［
`Internet Message Format^cite
の，対応する名前の構成子
］に定義されるそれ（ `RFC5322/3.3$sec ）と同じである。
◎
HTTP-date is case sensitive. A sender MUST NOT generate additional whitespace in an HTTP-date beyond that specifically included as SP in the grammar. The semantics of day-name, day, month, year, and time-of-day are the same as those defined for the Internet Message Format constructs with the corresponding name ([RFC5322], Section 3.3).
</p>

<p>
［
`rfc850-date$p 形式による 2 桁~年を利用する時刻印 値
］の`受信者$は、［
50 年より先の未来として出現する時刻印
］を［
最後の 2 桁が同じ，過去の年
］を表現しているものと解釈しなければナラナイ。
◎
Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.
</p>

<p>
時刻印 値の`受信者$には、~field定義により制約されない限り，時刻印の構文解析において堅牢であることが奨励される。
例えば，~messageは、ときには［［
`Internet Message Format^cite により定義される，いずれかの日付時刻 指定
］を生成し得るような，非~HTTP源
］から~HTTP越しに回送されることもある。
◎
Recipients of timestamp values are encouraged to be robust in parsing timestamps unless otherwise restricted by the field definition. For example, messages are occasionally forwarded over HTTP from a non-HTTP source that might generate any of the date and time specifications defined by the Internet Message Format.
</p>

<p class="note">注記：
~HTTPが時刻印の形式に課す要件は、~protocol~streamの中での利用eに限り適用される。
実装には、これらの形式を［
利用者への呈示, 要請の~logをとる, 等々
］に利用することは，要求されない。
◎
Note: HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream. Implementations are not required to use these formats for user presentation, request logging, etc.
</p>

				</section>
			</section>
		</section>
		<section id="abnf.extension">
<h3 title="ABNF List Extension: #rule">5.5. ~ABNF~list拡張： <code>#`規則^V</code></h3>

<p>
`~listに基づく~field$の`~field値$の定義のうち 一部のものを読み易くするため、
`RFC5234$r の~ABNF規則に対する拡張
<code>#`規則^V</code>
が利用される：
◎
A #rule extension to the ABNF rules of [RFC5234] is used to improve readability in the definitions of some list-based field values.
</p>

<p>
構成子 "`#^c" は、 "`*^c" と類似に定義され，~commaで区切られた要素からなる~listを定義する。
全部的な形は，
<code>&lt;`n^V&gt;#&lt;`m^V&gt;`<var>element</var>^p</code>
であり、
`n^V 個〜 `m^V 個までの，［
1 個の~comma （"`,^c"）とその前後の省略可能な空白（ `OWS$p ）
］で互いに分離された
`<var>element</var>^p
を指示する。
◎
A construct "#" is defined, similar to "*", for defining comma-delimited lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single comma (",") and optional whitespace (OWS).
</p>

			<section id="abnf.extension.sender">
<h4 title="Sender Requirements">5.5.1. 送信者に対する要件</h4>

<p>
`送信者$は、~list構成子を利用するどの生成規則に対しても，空な~list要素を`生成し$てはナラナイ。
言い換えれば、送信者は，［
次の構文を満足する~list
］を`生成し$なければナラナイ：
◎
In any production that uses the list construct, a sender MUST NOT generate empty list elements. In other words, a sender MUST generate lists that satisfy the following syntax:
</p>

<pre class="bnf">
1#`element^V =&gt; `element^V *( `OWS$p "," `OWS$p `element^V )
</pre>

<p>
および：
◎
and:
</p>

<pre class="bnf">
#`element^V =&gt; [ 1#`element^V ]
</pre>

<p>
`n^V &gt;= 1, `m^V &gt; 1 に対し：
◎
and for n &gt;= 1 and m &gt; 1:
</p>

<pre class="bnf">
&lt;`n^V&gt;#&lt;`m^V&gt;`element^V =&gt; `element^V &lt;`n-1^V&gt;*&lt;`m-1^V&gt;( `OWS$p "," `OWS$p `element^V )
</pre>

<p>
`A$sec にて，送信者~用の［
~list構成子が展開された後の，総集的な~ABNF
］を示す。
◎
Appendix A shows the collected ABNF for senders after the list constructs have been expanded.
</p>

			</section>
			<section id="abnf.extension.recipient">
<h4 title="Recipient Requirements">5.5.2. 受信者に対する要件</h4>

<p>
空な要素は、要素として数えられない。
`受信者$は，［
適度な数の空な~list要素
］を構文解析しつつ，それを超える分は無視しなければナラナイ
— ［
送信者が値を併合する際にやりがちな誤りを取扱うに十分
］かつ［
~DoS攻撃の仕組みとして利用し得るほど~~多量ではない
］ような。
言い換えれば、受信者は，次の構文を満足する どの~listも受容しなければナラナイ：
◎
Empty elements do not contribute to the count of elements present. A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism. In other words, a recipient MUST accept lists that satisfy the following syntax:
</p>

<pre class="bnf">
#`element^V =&gt; [ `element^V ] *( `OWS$p "," `OWS$p [ `element^V ] )
</pre>

<p>
空な~list要素も在り得るので、 `RFC5234$r の~ABNFは，~listを成す要素の個数について施行できない。
そのため、どの事例でも，個数は指定されていないかのように対応付けられる。
◎
Note that because of the potential presence of empty list elements, the RFC 5234 ABNF cannot enforce the cardinality of list elements, and consequently all cases are mapped is if there was no cardinality specified.
</p>

<div class="example">
<p>
例えば，次の~ABNF生成規則が与えられたとき：
◎
For example, given these ABNF productions:
</p>

<pre class="bnf">
`example-list@p
    = 1#`example-list-elmt$p
`example-list-elmt@p
    = `token$p【！4.4.1.1】
</pre>

<p>
次のいずれも、 `example-list$p に対する妥当な値になる（二重引用符は含まない — それは，区切りを示すためのみに在る）：
◎
Then the following are valid values for example-list (not including the double quotes, which are present for delimitation only):
</p>

<pre>
"foo,bar"
"foo ,bar,"
"foo , ,bar,charlie"
</pre>

<p>
対照的に，次のいずれも，妥当でない値になる
— `example-list$p 生成規則には， 1 個~以上の空でない要素が要求されるので：
◎
In contrast, the following values would be invalid, since at least one non-empty element is required by the example-list production:
</p>

<pre>
""
","
",   ,"
</pre>
</div>

			</section>
		</section>
		<section id="trailer.fields">
<h3 title="Trailer Fields">5.6. ~trailer</h3>

			<section id="trailers.purpose">
<h4 title="Purpose">5.6.1. 目的</h4>

<p>
一部の~HTTP~versionにおいては、初期`~header節$が完了した後に，追加的な~metadata
— ［
~messageの完全性~検査／ ~digital署名／後処理~状態s
］など — 
を送信できる（`~payload本体$を伝送する間にも，その後にも）。
例えば，~HTTP11における`~chunked符号法$では、`~payload本体$の後に`~trailer節$が許容され、何個かの`~trailer$を包含し得る。
それらは、［
`~field名$, `~field値$
］については~headerと［
同じ構文, 同じ名前空間
］を共有するが，`~header節$より後に受信される。
◎
In some HTTP versions, additional metadata can be sent after the initial header section has been completed (during or after transmission of the payload body), such as a message integrity check, digital signature, or post-processing status. For example, the chunked coding in HTTP/1.1 allows a trailer section after the payload body (Section 7.1.2 of [Messaging]) which can contain trailer fields: field names and values that share the same syntax and namespace as header fields but that are received after the header section.
</p>

<p>
`~trailer$は、［
`~header節$が完了した時点で既知になった~message意味論
］に矛盾するのを避けるため，`~header節$内の`~field$とは別々に処理され, 格納される~OUGHT。
ある種の~headerの有無は、［
`~trailer$を受信する前に，一体としての~messageを［
~routeする／処理する
］ために為される選択
］に影響iするかもしれない
— そのような選択は、後から`~trailer$が発見されても，くつがえせない。
◎
Trailer fields ought to be processed and stored separately from the fields in the header section to avoid contradicting message semantics known at the time the header section was complete. The presence or absence of certain header fields might impact choices made for the routing or processing of the message as a whole before the trailers are received; those choices cannot be unmade by the later discovery of trailer fields.
</p>

			</section>
			<section id="trailers.limitations">
<h4 title="Limitations">5.6.2. 制限</h4>

<p>
多くの`~field$は、［
その評価が、`~message本体$の受信に先立って必要とされる
］ので，`~header節$の外側では処理し得ない
— ~messageの［
~frame法／
~route法／
認証／
要請~改変子／
応答~制御／
~payload形式
］を述べる`~field$など。
送信者は、次を知っている場合を除き，`~trailer$を`生成し$てはナラナイ
⇒
対応する【！~header】`~field名$の定義は、当の`~field$を`~trailer節$内に送信することを許可している
◎
Many fields cannot be processed outside the header section because their evaluation is necessary prior to receiving the message body, such as those that describe message framing, routing, authentication, request modifiers, response controls, or payload format. A sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.
</p>

<p>
`~trailer$は、ある~protocol~versionから別のそれへ~messageを回送する`中継者$にとっては，処理が困難にもなり得る。
一部の中継者は、~~通過中の~message全体を~bufferできる場合には
— それを回送する前に —
`~trailer$を`~header節$の中へ（適切に）併合することもできる。
しかしながら，ほとんどの事例では、`~trailer$たちは単純に破棄される。
受信者は、次が満たされる場合を除き，`~trailer$を`~header節$の中に併合してはナラナイ
⇒
［
受信者は、対応する`~field名$【！~header】の定義を解する
］かつ［
その定義は、当の~trailerの`~field値$を安全に併合する方法を定義していて，それを明示的に許可している
］
◎
Trailer fields can be difficult to process by intermediaries that forward messages from one protocol version to another. If the entire message can be buffered in transit, some intermediaries could merge trailer fields into the header section (as appropriate) before it is forwarded. However, in most cases, the trailers are simply discarded. A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.
</p>

<p>
`TE$h ~header `Messaging$r 内に~keyword
"`trailers@c"
が在る場合、`~client$は
— 自身, および`下流$の~clientたちに利するため —
~trailerを受容する用意があることを指示する。
`中継者$からの要請においては、これは，［
下流にある すべての~clientは、回送されてきた応答~内の`~trailer$を受容する用意がある
］ことを含意する。
"`trailers^c" が在ったとしても、［
応答~内の特定0の~trailerについて，それを処理する~client（たち）がある
］ことにはならないことに注意
— それが意味するのは、どの~clientも，`~trailer節$を落とさないことに限られる。
◎
The presence of the keyword "trailers" in the TE header field (Section 5.6.5) indicates that the client is willing to accept trailer fields, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that all downstream clients are willing to accept trailer fields in the forwarded response. Note that the presence of "trailers" does not mean that the client(s) will process any particular trailer field in the response; only that the trailer section(s) will not be dropped by any of the clients.
</p>

<p>
`~trailer$は，~~通過中に破棄される~~可能性があるので、~serverは，［
~UAが受信することが必要とされると予見されるもの
］を`~trailer$として`生成する$ベキでない
◎
Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.
</p>

			</section>
			<section id="trailers.processing">
<h4 title="Processing">5.6.3. 処理</h4>

<p>
同じ名前を伴う`~trailer$たちは、`~header$の様に，受信した順序で処理される。
同じ名前を伴う複数個の~trailer`~field行l$による意味論は、それらが別々の`~trailer節$内に受信されたときでも，~memberの~listに複数個の値を付加するのと等価になる。
~trailerのうち，同じ~messageの間に複数個~生成され得るものは、~list値として定義されなければナラナイ
— 各~member値は、`~field行l$が受信されるごとに 1 度~限り【その場限りで】処理されるとしても。
◎
Like header fields, trailer fields with the same name are processed in the order received; multiple trailer field lines with the same name have the equivalent semantics as appending the multiple values as a list of members, even when the field lines are received in separate trailer sections. Trailer fields that might be generated more than once during a message MUST be defined as a list value even if each member value is only processed once per field line received.
</p>

<p>
`~trailer$に対しては、
1 回に 1 個の`~trailer節$が処理されるものと期待される（要求されないが）。
すなわち，~trailerを見つけようとしている受信者は、受信した各`~trailer節$に対し，~message処理における その時点で、受信した節を一連の~fieldに構文解析して，それらに結付けられている処理を呼出してから、総体としての~message用に，それらの~fieldを［
受信した~trailerが成す集合
］に付加することになる。
【！したがって，処理の時機を除けば、複数個の~trailer節と それらを 1 個の~trailer節に併合したものは，等価と見なされることになる。】
◎
Trailer fields are expected (but not required) to be processed one trailer section at a time. That is, for each trailer section received, a recipient that is looking for trailer fields will parse the received section into fields, invoke any associated processing for those fields at that point in the message processing, and then append those fields to the set of trailer fields received for the overall message.
</p>

<p>
この挙動は、何個かの`~trailer$が［
増分的な［
署名~情報／~streamにおける中途の状態s情報
］を包含する ／
同じ節の中で他の値を互いに参照rするかもしれない
］場合のために，反復的な処理を許容する。
しかしながら，各`~trailer節$が［
`~message本体$を成す~streamへの関係を切り替えない／
~~通過中に結合し直されない（または落とされない）
］ことは保証されないので、~trailerのうち［
~~現在の`~trailer節$の外側にある~dataを参照rするもの
］には，自己-記述的な参照を利用する（すなわち、当の~dataを［
名前／序数による位置／~octet範囲
］で参照rする）必要がある
— 最も近過去に受信した~dataと見做すのではなく。
◎
This behavior allows for iterative processing of trailer fields that contain incremental signatures or mid-stream status information, and fields that might refer to each other's values within the same section. However, there is no guarantee that trailer sections won't shift in relation to the message body stream, or won't be recombined (or dropped) in transit, so trailer fields that refer to data outside the present trailer section need to use self-descriptive references (i.e., refer to the data by name, ordinal position, or an octet range) rather than assume it is the data most recently received.
</p>

<p>
同様に，受信者は、~messageの終端にて，受信した`~trailer$が成す集合~全体を［
当の~messageが結論するものと見なされるような，
1 個の~data構造
］として扱ってもヨイ。
`~trailer節$内での利用が意図される~fieldに対しては、追加的な処理として期待されるものがあるならば，当の~field仕様の中で定義できる。
◎
Likewise, at the end of a message, a recipient MAY treat the entire set of received trailer fields as one data structure to be considered as the message concludes. Additional processing expectations, if any, can be defined within the field specification for a field intended for use in trailers.
</p>

			</section>
			<section id="field.trailer">
<h4 title="Trailer">5.6.4. `Trailer^h</h4>

<p>
`Trailer^h ~headerは、送信者が［
同じ~messageの中に`~trailer$として送信するもの
］と見越している，`~field名$の~listを供する。
これは、［
本体の処理を開始する前に，指示された~metadataの受領に対し準備する
］ことを，受信者に許容する。
◎
The "Trailer" header field provides a list of field names that the sender anticipates sending as trailer fields within that message. This allows a recipient to prepare for receipt of the indicated metadata before it starts processing the body.
</p>

<pre class="bnf">
`Trailer@p
    = #`field-name$p
</pre>

<p>
例えば，送信者は、［
`~payload$が~stream化されるに伴い，~message完全性の検査情報が算出され、最終的な署名を`~trailer$として供することになる
］ことを指示するかもしれない。
受信者は、~payload~dataを受信するに伴い，その場で同じ検査を遂行できるようになる。
◎
For example, a sender might indicate that a message integrity check will be computed as the payload is being streamed and provide the final signature as a trailer field. This allows a recipient to perform the same check on the fly as the payload data is received.
</p>

<p>
~message内に`~trailer$を`生成し$ようと意図する送信者は、その~messageの`~header節$内に `Trailer$h ~headerを`生成し$て，そのような`~field$が`~trailer節$内に在るかもしれないことを指示するベキである。
◎
A sender that intends to generate one or more trailer fields in a message SHOULD generate a Trailer header field in the header section of that message to indicate which fields might be present in the trailers.
</p>

			</section>
			<section id="field.te">
<h4 title="TE">5.6.5. `TE^h</h4>

<p>
要請~内に［
"`trailers$c" ~memberを包含する `TE^h ~header
］を利用すれば、`送信者$は`~trailer$を破棄しないことを指示できる。
【！ `5.6$sec → 5.6.2 `trailers$c】
◎
The "TE" header field in a request can be used to indicate that the sender will not discard trailer fields when it contains a "trailers" member, as described in Section 5.6.
</p>

<p>
加えて，特定の~HTTP~versionでは、
`TE^h は，［
`~client$が応答にて受容する用意がある`転送~符号法$
］を指示するためにも利用できる。
◎
Additionally, specific HTTP versions can use it to indicate the transfer codings the client is willing to accept in the response.
</p>

<p>
`TE$h の`~field値$は，~tokenの~listであり、それを成す各~tokenは，省略可能な`~parameter$【 `transfer-parameter$p 】たちを許容する。
◎
The TE field-value consists of a list of tokens, each allowing for optional parameters (as described in Section 5.4.1.4).
</p>

<pre class="bnf">
`TE@p
    = #`t-codings$p
`t-codings@p
    = "`trailers$c"
    / ( `transfer-coding$p [ `t-ranking$p ] )
`t-ranking@p
    = `OWS$p ";" `OWS$p "q=" `rank$p
`rank@p
    = ( "0" [ "." 0*3`DIGIT$P ] )
    / ( "1" [ "." 0*3("0") ] )
</pre>

			</section>
		</section>
		<section id="considerations.for.new.header.fields">
<h3 title="Considerations for New HTTP Fields">5.7. 新たな~HTTP~fieldに対する考慮点</h3>

<p>
`~field名$に対する一般~要件は、 `5.3$sec を見よ。
`~field値$についての論は、 `5.4$sec を見よ。
◎
See Section 5.3 for a general requirements for field names, and Section 5.4 for a discussion of field values.
</p>

<p>
新たな`~field$を定義する仕様の策定者には、次の文書~化を考慮することを勧める：
◎
Authors of specifications defining new fields are advised to consider documenting:
</p>
<ul>
	<li>
<p>
当の~fieldは、［
`単数~field$／`~listに基づく~field$
］どちらなのか？
◎
Whether the field has a singleton or list-based value (see Section 5.4).
</p>

<p>
`単数~field$の場合、複数個の~memberが在るときに，~messageを扱う方法も（その~fieldを無視するのが既定としてイミを成し得るかもしれないが、常に当を得た選択になるとは限らない）。
◎
If it is a singleton field, document how to treat messages where the multiple members are present (a sensible default would be to ignore the field, but this might not always be the right choice).
</p>

<p>
当の`~field$が`単数~field$として定義されていようが、`中継者$や~software~libraryは，［
複数個の`~field行l$【！~field~instance】を一つに`結合-$し得る
］ことに注意。
堅牢な形式は、受信者がこれらの状況を発見することを可能化する。
例えば：
◎
Note that intermediaries and software libraries might combine multiple field instances into a single one, despite the field being defined as a singleton. A robust format enables recipients to discover these situations＼
</p>
		<ul>
			<li>
良い例： "`Content-Type$p"
— ~commaが出現し得るのは、引用符~付き文字列の内側に限られるので
◎
(good example: "Content-Type", as the comma can only appear inside quoted strings;＼
</li>
			<li>
悪い例： "`Location$p"
— ~URIの内側に~commaが生じ得る
◎
bad example: "Location", as a comma can occur inside a URI).
</li>
		</ul>
	</li>
	<li>
`~field$は，どの条件の下で利用できるか？
— 例：
応答のみ ／
要請のみ ／
すべての~message ／
特定0の`要請~method$に対する応答のみ,
等々。
◎
Under what conditions the field can be used; e.g., only in responses or requests, in all messages, only on responses to a particular request method, etc.
</li>
	<li>
`~field$内に伝達される情報の適用能が及ぶ視野は、どこまでか。
既定では、~fieldは，それに結付けられた~messageに限り適用されるが、応答~fieldには，資源の表現~すべてに
— あるいは、資源~自身にも, もっと広い視野にすら —
適用されるよう設計されているものもある。
応答~fieldの視野を拡げる仕様は、［
内容~折衝／適用能が及ぶ期間／
（一部の事例では）~multi-tenant【複数の事業者（店子）から共有される】~server配備
］などの課題を注意深く考慮する必要がある。
◎
What the scope of applicability for the information conveyed in the field is. By default, fields apply only to the message they are associated with, but some response fields are designed to apply to all representations of a resource, the resource itself, or an even broader scope. Specifications that expand the scope of a response field will need to carefully consider issues such as content negotiation, the time period of applicability, and (in some cases) multi-tenant server deployments. 
</li>
	<li>
`~field$は、 `PUT$m 要請に際して それを解する`生成元~server$により格納されるべきか？
◎
Whether the field should be stored by origin servers that understand it upon a PUT request.
</li>
	<li>
`~field$の意味論は、既存の`要請~method$や`状態s~code$などの文脈の下で，更に精緻化されるか？
◎
Whether the field semantics are further refined by the context, such as by existing request methods or status codes.
</li>
	<li>
当の`~field名$を `Connection$h ~header内に~listすることは、適切になるか？（すなわち，その`~field$は`隣点間$か？
— `6.8$sec を見よ）。
◎
Whether it is appropriate to list the field name in the Connection header field (i.e., if the field is to be hop-by-hop; see Section 6.8).
</li>
	<li>
`中継者$は、どの条件の下で，`~field$の値を［
挿入する／削除する／改変する
］ことが許容されるか？
◎
Under what conditions intermediaries are allowed to insert, delete, or modify the field's value.
</li>
	<li>
［
`Vary$h `応答~header$内に，`~field名$を~listする
］ことは適切になるか？（例： `要請~header$が，`生成元~server$の内容~選定~algoにより利用されるときなど）。
◎
Whether it is appropriate to list the field name in a Vary response header field (e.g., when the request header field is used by an origin server's content selection algorithm; see Section 11.1.4).
</li>
	<li>
`~field$は、`~trailer節$にて許容され得るか？
（ `5.6$secを見よ）
◎
Whether the field is allowable in trailers (see Section 5.6).
</li>
	<li>
`~field$は、~redirectを経ても保全される~OUGHTか？
◎
Whether the field ought to be preserved across redirects.
</li>
	<li>
~privacyに関係する~dataの開示など，追加的な~security考慮点を導入するか？
◎
Whether it introduces any additional security considerations, such as disclosure of privacy-related data.
</li>
</ul>

		</section>
		<section id="field.definitions">
<h3 title="Fields Defined In This Document">5.8. この文書に定義される各種~field</h3>

<p>
この文書では、次に挙げる名前の`~field$が定義される
— 位置付けは、`非推奨d^i （ `deprecated^en ）が付記されたものを除き `標準^i （ `standard^en ）である
⇒＃
`Accept$h,
`Accept-Charset$h — `非推奨d^i,
`Accept-Encoding$h,
`Accept-Language$h,
`Accept-Ranges$h,
`Allow$h,
`Authorization$h,
`Authentication-Info$h,
`Connection$h,
`Content-Encoding$h,
`Content-Language$h,
`Content-Length$h,
`Content-Location$h,
`Content-Range$h,
`Content-Type$h,
`Date$h,
`ETag$h,
`Expect$h,
`From$h,
`Host$h,
`If-Match$h,
`If-Modified-Since$h,
`If-None-Match$h,
`If-Range$h,
`If-Unmodified-Since$h,
`Last-Modified$h,
`Location$h,
`Max-Forwards$h,
`Proxy-Authenticate$h,
`Proxy-Authentication-Info$h,
`Proxy-Authorization$h,
`Range$h,
`Referer$h,
`Retry-After$h,
`Server$h,
`TE$h,
`Trailer$h,
`Upgrade$h,
`User-Agent$h,
`Vary$h,
`Via$h,
`WWW-Authenticate$h
◎
The following fields are defined by this document:
◎
Table 3
Field Name 	Status Ref.
Accept 	standard 	9.4.1
Accept-Charset 	deprecated 	9.4.2
Accept-Encoding 	standard 	9.4.3
Accept-Language 	standard 	9.4.4
Accept-Ranges 	standard 	11.4.1
Allow 	standard 	11.4.2
Authentication-Info 	standard 	11.3.3
Authorization 	standard 	9.5.3
Connection 	standard 	6.8 
Content-Encoding 	standard 	7.2.2
Content-Language 	standard 	7.2.3
Content-Length 	standard 	7.2.4
Content-Location 	standard 	7.2.5
Content-Range 	standard 	7.3.4
Content-Type 	standard 	7.2.1
Date 	standard 	11.1.1
ETag 	standard 	11.2.3
Expect 	standard 	9.1.1
From 	standard 	9.6.1
Host 	standard 	6.5
If-Match 	standard 	9.2.3
If-Modified-Since 	standard 	9.2.5
If-None-Match 	standard 	9.2.4
If-Range 	standard 	9.2.7
If-Unmodified-Since 	standard 	9.2.6
Last-Modified 	standard 	11.2.2
Location 	standard 	11.1.2
Max-Forwards 	standard 	9.1.2
Proxy-Authenticate 	standard 	11.3.2
Proxy-Authentication-Info 	standard 	11.3.4
Proxy-Authorization 	standard 	9.5.4
Range 	standard 	9.3
Referer 	standard 	9.6.2
Retry-After 	standard 	11.1.3
Server 	standard 	11.4.3
TE 	standard 	5.6.5
Trailer 	standard 	5.6.4
Upgrade 	standard 	6.7
User-Agent 	standard 	9.6.3
Vary 	standard 	11.1.4
Via 	standard 	6.6.1
WWW-Authenticate 	standard 	11.3.1
</p>

<p>
加えて，~field名 "`*^c" は、位置付け `標準^i として，予約-済みである。
その名前を~HTTP~headerとして利用するのは、
`Vary$h ~headerにおける "`*^c" の特別な意味論と競合するかもしれないので。
◎
Furthermore, the field name "*" is reserved, since using that name as an HTTP header field might conflict with its special semantics in the Vary header field (Section 11.1.4).
◎
Table 4
Field Name 	Status 	Ref. 	Comments
* 	standard 	5.8 	(reserved)
</p>

		</section>
	</section>
	<section id="message.routing">
<h2 title="Message Routing">6. ~messageの~route法</h2>

<div class="p">
<p>
~HTTP要請~messageの~route法は、各`~client$により，次に基づいて決定される
⇒＃
`~target資源$,
~clientの~proxy環境設定,
`内方$への接続の確立／再利用
◎
HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection.＼
</div>

<p>
対応する応答の~route法は、同じ接続`連鎖$を，~clientまで~~遡る。
◎
The corresponding response routing follows the same connection chain back to the client.
</p>

		<section id="target.resource">
<h3 title="Identifying a Target Resource">6.1. ~target資源の識別-法</h3>

<p>
~HTTPは、一般用~computerから家電までに渡る，多種多様な応用で利用される。
一部の事例では、通信~optionは，~clientの環境設定~内に~~直に~code化されている。
しかしながら，ほとんどの~HTTP~clientは、一般用~Web~browserと同じ［
`資源$を識別するための仕組みと, 環境設定~技法
］に依拠する。
◎
HTTP is used in a wide variety of applications, ranging from general-purpose computers to home appliances. In some cases, communication options are hard-coded in a client's configuration. However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers.
</p>

<p>
~HTTP通信は、何らかの目的で`~UA$から起動される。
その目的は、`要請の意味論$と,
それらの意味論が適用される
`~target資源@
との組合nである。
`要請~target@
とは、`~target資源$を識別する~protocol要素である。
◎
HTTP communication is initiated by a user agent for some purpose. The purpose is a combination of request semantics and a target resource upon which to apply those semantics. The "request target" is the protocol element that identifies the "target resource".
</p>

<p>
`要請~target$は、概して，`~URI$参照である
— `~UA$は、
`~target~URI@
を得するため，この~URIを`絶対~形$に解決することになる。
参照~内の素片（ `fragment$p ）成分は、在っても，~target~URIからは除外される
— 素片~識別子は、`~client$側の処理（ `RFC3986/3.5$sec ）に予約されているので。
◎
Typically, the request target is a URI reference (Section 2.4) which a user agent would resolve to its absolute form in order to obtain the "target URI". The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([RFC3986], Section 3.5).
</p>

<p>
しかしながら、次に挙げる，~methodに特有な特別な形があり、特定の状況下で`要請~target$用に許容される：
◎
However, there are two special, method-specific forms allowed for the request target in specific circumstances:
</p>
<ul>
	<li>
`CONNECT$m 用には
⇒
`要請~target$は、~tunnelの行先を与える，~colonで分離された［
~host名と~port番号
］になる。
◎
For CONNECT (Section 8.3.6), the request target is the host name and port number of the tunnel destination, separated by a colon.
</li>
	<li>
`OPTIONS$m 用には
⇒
`要請~target$は、 1 個の~asterisk（ "`*^c" ）にもなり得る。
◎
For OPTIONS (Section 8.3.7), the request target can be a single asterisk ("*").
</li>
</ul>

<p>
詳細は、それぞれの~method定義を見よ。
これらの形は、他の~methodとともに利用されてはナラナイ。
◎
See the respective method definitions for details. These forms MUST NOT be used with other methods.
</p>

		</section>
		<section id="origin">
<h3 title="Determining Origin">6.2. 生成元の決定-法</h3>

<p>
所与の~URI用の
`生成元^dfn
は、
( `~scheme$, `~host$, `~port$ )
が成す組である
— `~scheme$, `~host$は小文字に正規化して，`~port$は頭部にある `0^c を除去して正規化した後の。
`~port$が~URIから省かれている場合、その`~scheme$用の既定の~portが利用される。
◎
The "origin" for a given URI is the triple of scheme, host, and port after normalizing the scheme and host to lowercase and normalizing the port to remove any leading zeros. If port is elided from the URI, the default port for that scheme is used.＼
</p>

<p class="example">
例えば，~URI
`https://Example.Com/happy.js^c
用の生成元は
( "`https^c", "`example.com^c", "`443^c" )
が成す組になり、`~port$が常に在るよう正規化された~URI接頭辞
`https://example.com:443^c
としても記述できる。
◎
For example, the URI
◎
https://Example.Com/happy.js
◎
would have the origin
◎
which can also be described as the normalized URI prefix with port always present:
◎
https://example.com:443
</p>

<p>
各~生成元は、自前の名前空間を定義し，その名前空間に属する識別子が`資源$へどう対応付けられるかを制御する。
その結果，妥当な要請に対し当の生成元がどう応答するかは、時経過にわたり一貫して，利用者が~URIに結付けることになる意味論を決定する
— そのような意味論の有用さは、利用者が未来に参照して~accessするために，これらの仕組みを最終的に “資源” の中へ変形することにある【？】。
◎
Each origin defines its own namespace and controls how identifiers within that namespace are mapped to resources. In turn, how the origin responds to valid requests, consistently over time, determines the semantics that users will associate with a URI, and the usefulness of those semantics is what ultimately transforms these mechanisms into a "resource" for users to reference and access in the future.
</p>

<p>
2 つの生成元は、［
`~scheme$, `~host$, `~port$
］いずれかが相違するならば別個とされる。
これら 2 つの生成元を同じ実体が制御することを検証yできたとしても、それらの生成元の下にある 2 つの名前空間は
— 一方の生成元が、それに対し権限的な~serverにより明示的に，他方の別名にされない限り —
別個になる。
◎
Two origins are distinct if they differ in scheme, host, or port. Even when it can be verified that the same entity controls two distinct origins, the two namespaces under those origins are distinct unless explicitly aliased by a server authoritative for that origin.
</p>

<p>
`RFC6454$r にて述べられるように、生成元は，この文書の視野を超える~HTMLやそれに関係する~Web~protocolの中でも利用される。
◎
Origin is also used within HTML and related Web protocols, beyond the scope of this document, as described in [RFC6454].
</p>

		</section>
		<section id="routing.inbound">
<h3 title="Routing Inbound">6.3. 内方への~route法</h3>

<p>
`~target~URI$と その`生成元$が決定されたなら、`~client$は，次を裁定する
⇒＃
欲された意味論を成遂げるためには，~network要請が必要とされるかどうか／
必要とされるなら，その要請をどこへ~directするか
◎
Once the target URI and its origin are determined, a client decides whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.
</p>

			<section id="routing.cache">
<h4 title="To a Cache">6.3.1. ~cacheへの~route法</h4>

<p>
`~client$が`~cache$ `RFC7234$r を備えていて, かつ
それにより要請を満足できる場合、要請は，通例的に，最初にそこへ~directされる。
◎
If the client has a cache [Caching] and the request can be satisfied by it, then the request is usually directed there first.
</p>

			</section>
			<section id="routing.proxy">
<h4 title="To a Proxy">6.3.2. ~proxyへの~route法</h4>

<p>
代表的な`~client$は、［
要請が`~cache$により満足できない
］場合に［
要請を満足するために利用される`~proxy$があるかどうか
］を決定するため，自身の環境設定を検査することになる。
~proxy環境設定は、実装に依存するが，［
~URI接頭辞の照合,
選択的な権限の照合,
または この両者
］に基づくことが多く、~proxy自身は，通例的に［
"`http$c" ／ "`https$c"
］~URIにより識別される。
適用-可能な`~proxy$がある場合、~clientは，［
その~proxyへの接続を確立する（または再利用する）
］ことにより，`内方$へ接続する。
◎
If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI. If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy.
</p>

			</section>
			<section id="routing.origin">
<h4 title="To the Origin">6.3.3. 生成元への~route法</h4>

<p>
適用-可能な`~proxy$は無い場合、代表的な`~client$は，［
`~target資源$用の`生成元$へ直に接続する
］ために［
通例的に`~target~URI$の`~scheme$ごとに特有な，~handler~routine
］を呼出すことになる。
これが どう成遂げられるかは、~target~URIの`~scheme$に依存し，それを~~規定する仕様により定義される。
◎
If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an origin for the target resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification.
</p>

				<section id="http.origin">
<h5 title="http origins">6.3.3.1. `http^c 生成元</h5>

<p>
~HTTPは，~transport~protocolには依存しないが、
"`http$c" `~scheme$は，次に関して~TCPに特有である
— その `authority$p （ “権限” ）成分の中で識別される `host$p が何であれ、権限を［［
その `host$p の指示された `port$p 上で，~TCP接続を~listenしている`生成元~server$
］を制御する何者か
］に結付けることに関して。
これは，［
`~client$に特有な名前~解決の仕組み
］にも［
経路上の攻撃者に対し~secure化されないかもしれない通信
］にも依存するので、ごく弱いイミの権限である。
そうであっても，［
"`http$c" 識別子たちを，ある`生成元~server$に束縛すること
］は、少なくとも，信用される環境の中で解決が一貫するためには足るものになる。
◎
Although HTTP is independent of the transport protocol, the "http" scheme (Section 2.5.1) is specific to associating authority with whomever controls the origin server listening for TCP connections on the indicated port of whatever host is identified within the authority component. This is a very weak sense of authority because it depends on both client-specific name resolution mechanisms and communication that might not be secured from an on-path attacker. Nevertheless, it is a sufficient minimum for binding "http" identifiers to an origin server for consistent resolution within a trusted environment.
</p>

<p>
`host$p 識別子が~IP~addressとして供された場合、［
その~IP~addressが指示する~TCP~port
］上の~listenerが（もし在れば），`生成元~server$になる。
`~host$が登録-済みな名前である場合、その名前は，［
その`生成元~server$用の適切な~addressを見出すための間接的な識別子
］として［
~DNSなどの名前~解決~service
］用に利用される。
◎
If the host identifier is provided as an IP address, the origin server is the listener (if any) on the indicated TCP port at that IP address. If host is a registered name, the registered name is an indirect identifier for use with a name resolution service, such as DNS, to find an address for an appropriate origin server.
</p>

<div class="p">
<p>
"`http$c" ~URIが［
指示された`資源$への~accessを~callする文脈
］の下で利用されるときは、`~client$は，次により~accessしようと試みてもヨイ：
</p>
<ol>
	<li>
`host$p 識別子を~IP~addressに解決して、
</li>
	<li>
その~addressへの~TCP接続を指示された `port$p 上に確立して、
</li>
	<li>
~HTTP要請~messageを
— 当の~URIを識別する~dataを包含した上で —
`~server$へ送信する（ `2.1$sec ）。
</li>
</ol>
◎
When an "http" URI is used within a context that calls for access to the indicated resource, a client MAY attempt access by＼
resolving the host identifier to an IP address,＼
establishing a TCP connection to that address on the indicated port, and＼
sending an HTTP request message to the server containing the URI's identifying data (Section 2.1).
</div>

<p>
`~client$からの そのような要請に対する，`~server$からの`最終-応答$は、
【！暫定-（ `1xx$st ）でない~HTTP応答~messageで応答したなら、その応答は】
当の要請に対する`権限的$な回答と見なされる。
◎
If the server responds to such a request with a non-interim HTTP response message, as described in Section 10, then that response is considered an authoritative answer to the client's request.
</p>

<p>
しかしながら，上述は、［
`権限的な応答$を得するための唯一の手段
］でも［
`権限的な応答$は常に必要とされることを含意するもの
］でもないことに注意（ `Caching$r を見よ）。
例えば， `Alt-Svc^h ~header `RFC7838$r は、［
他の~serviceのうち、当の`生成元$用にも権限的になるものが，識別されるようにする
］ことを`生成元~server$に許容する。
"`http$c" で識別される`資源$への~accessは、この文書の視野の外側にある~protocolにより供されるかもしれない。
◎
Note, however, that the above is not the only means for obtaining an authoritative response, nor does it imply that an authoritative response is always necessary (see [Caching]). For example, the Alt-Svc header field [RFC7838] allows an origin server to identify other services that are also authoritative for that origin. Access to "http" identified resources might also be provided by protocols outside the scope of this document.
</p>

<p>
権限の確立-法に関係する~securityの考慮点は、
`12.1$sec を見よ。
◎
See Section 12.1 for security considerations related to establishing authority.
</p>


				</section>
				<section id="https.origin">
<h5 title="https origins">6.3.3.2. `https^c 生成元</h5>

<p>
`https$c ~schemeは、［
識別された`生成元~server$用に信用に価し得るものと`~client$が見なす，ある証明書
］に対応している秘密鍵を利用する~serverの能に基づいて，権限を結付ける。
~clientは、通例的に，何らかの信用-起点
— 予め手配したか環境設定されたそれ —
から伝達される信用の連鎖に依拠して，証明書が信用に価し得るかどうか判断する（ `6.3.3.3$sec ）。
◎
The "https" scheme (Section 2.5.2) associates authority based on the ability of a server to use the private key corresponding to a certificate that the client considers to be trustworthy for the identified origin server. The client usually relies upon a chain of trust, conveyed from some prearranged or configured trust anchor, to deem a certificate trustworthy (Section 6.3.3.3).
</p>

<p>
~HTTP11までは、ある接続~越しに`~server$と通信している`~client$が，~serverに権限を帰属させるのは、当の接続が［
特定的に，当の~URI生成元の~hostへ、成功裡に確立され, かつ`~secure化$されている
］ときに限られる。
接続の確立と証明書の検証yは、権限の証明として利用される。
◎
In HTTP/1.1 and earlier, a client will only attribute authority to a server when they are communicating over a successfully established and secured connection specifically to that URI origin's host. The connection establishment and certificate verification are used as proof of authority.
</p>

<p>
［
~HTTP2／~HTTP3
］においては、`~client$が`~server$に権限を帰属させるのは、［
成功裡に確立され, `~secure化$された接続
］越しに通信していて，［
当の~URIの`生成元$の~hostは、~serverの証明書~内に在る いずれかの~hostに合致する
］かつ［
~clientは、当の~URIへ向けて，合致した~hostへの接続を~openできると予見する
］場合になる。
実施においては、~clientは，［
`生成元$の~hostが、確立した接続と同じ~server~IP~addressを包含する
］か検査するために，~DNS~queryを為すことになる。
この制約は、`生成元~server$が等価な
`ORIGIN^i ~frame `RFC8336$r
を送信している場合は，除去し得る。
◎
In HTTP/2 and HTTP/3, a client will attribute authority to a server when they are communicating over a successfully established and secured connection if the URI origin's host matches any of the hosts present in the server's certificate and the client believes that it could open a connection to that host for that URI. In practice, a client will make a DNS query to check that the origin's host contains the same server IP address as the established connection. This restriction can be removed by the origin server sending an equivalent ORIGIN frame [RFC8336].
</p>

<p>
`要請~target$の［
`~host$, `~port$
］値は、各~HTTP要請の中に渡され，`生成元$を［
同じ~serverが制御しているかもしれない他の名前空間に属するもの
］と判別するよう識別することになる。
［
証明書の秘密鍵に対する制御も伴って供される
］ような どの~serviceも，［
対応する "`https$c" 名前空間を管理することに等しく責を負う
］, あるいは少なくとも［
誤って~directされるように出現した要請を却下するよう準備しておく
］ことを確保するのは、`生成元~server$【！生成元】の責務である。
`~server$は、［
一部の`~host$に対しては、`生成元$として~serveする権限を有するときでも，そうする用意はない
］かもしれない。
◎
The request target's host and port value are passed within each HTTP request, identifying the origin and distinguishing it from other namespaces that might be controlled by the same server. It is the origin's responsibility to ensure that any services provided with control over its certificate's private key are equally responsible for managing the corresponding "https" namespaces, or at least prepared to reject requests that appear to have been misdirected. A server might be unwilling to serve as the origin for some hosts even when they have the authority to do so.
</p>

<p>
例えば，ある~network攻撃者が［
~port `N^V 用の接続を~port `Q^V にて受信させるようにした
］場合でも、`~target~URI$を検査して，［
同意tを伴わない限り、
"<code>https://example.com:`N^V/foo</code>"
は
"<code>https://example.com:`Q^V/foo</code>"
に置換され得ない
］ことを確保することが必要とされる。
◎
For example, if a network attacker causes connections for port N to be received at port Q, checking the target URI is necessary to ensure that the attacker can't cause "https://example.com:N/foo" to be replaced by "https://example.com:Q/foo" without consent.
</p>

<p>
"`https$c" `~scheme$は、権限を結付けるときに，［
~TCP, 接続される~port番号
］どちらにも依拠しないことに注意
— どちらも、~secure化された通信の外側にあり，権威あるものとして信用できないので。
よって，~HTTP通信は、`~secure化$【！Section 2.5.2】されたどの~channel越しにも
— ~TCPを利用しない~protocolも含めて —
場を占めるかもしれない。
◎
Note that the "https" scheme does not rely on TCP and the connected port number for associating authority, since both are outside the secured communication and thus cannot be trusted as definitive. Hence, the HTTP communication might take place over any channel that has been secured, as defined in Section 2.5.2, including protocols that don't use TCP.
</p>

<div class="p">
<p>
"`https$c" ~URIが［
指示された`資源$への~accessを~callする文脈
］の下で利用されるときは、`~client$は，次により~accessしようと試みてもヨイ：
</p>
<ol>
	<li>
`host$p 識別子を~IP~addressに解決して、
</li>
	<li>
その~addressへの~TCP接続を指示された `port$p 上に確立して、
</li>
	<li>
`端点間$の接続を
— ~TCP越しに~TLSを成功裡に起動することにより —
機密性と完全性が保護されるよう`~secure化$して、
</li>
	<li>
その接続~越しに，~HTTP要請~messageを
— 当の~URIを識別する~dataを包含した上で —
送信する（ `2.1$sec ）。
</li>
</ol>
◎
When an "https" URI is used within a context that calls for access to the indicated resource, a client MAY attempt access＼
by resolving the host identifier to an IP address,＼
establishing a TCP connection to that address on the indicated port,＼
securing the connection end-to-end by successfully initiating TLS over TCP with confidentiality and integrity protection, and＼
sending an HTTP request message over that connection containing the URI's identifying data (Section 2.1).
</div>

<p>
`~client$からの そのような要請に対する，`~server$からの`最終-応答$は、
【！暫定-（ `1xx$st ）でない~HTTP応答~messageで応答したなら、その応答は】
当の要請に対する`権限的$な回答と見なされる。
◎
If the server responds to such a request with a non-interim HTTP response message, as described in Section 10, then that response is considered an authoritative answer to the client's request.
</p>

<p>
しかしながら，上述は、［
`権限的な応答$を得するための唯一の手段
］でも［
`権限的な応答$は常に必要とされることを含意するもの
］でもないことに注意（ `Caching$r を見よ）。
◎
Note, however, that the above is not the only means for obtaining an authoritative response, nor does it imply that an authoritative response is always necessary (see [Caching]).
</p>

				</section>
				<section id="https.verify">
<h5 title="https certificate verification">6.3.3.3. `https^c 証明書の検証y</h5>

<p>
`~secure化$された接続を確立して~URIを参照を解く（ `dereference^en する）ためには、`~client$は，［
当の~serviceの識別情報（ `identity^en ）は、~URIの`生成元~server$に合致するものとして受容-可能かどうか
］を検証yしなければナラナイ。
証明書の検証yは、［
経路上の攻撃者／名前~解決を制御する攻撃者
］が~serverになりすますのを防止するために利用される。
この処理nには、~clientが信用-起点（ `trust anchor^en ）の集合で環境設定されることが要求される。
◎
To establish a secured connection to dereference a URI, a client MUST verify that the service's identity is an acceptable match for the URI's origin server. Certificate verification is used to prevent server impersonation by an on-path attacker or by an attacker that controls name resolution. This process requires that a client be configured with a set of trust anchors.
</p>

<p>
一般に，~clientは、
`RFC6125/6$sec に定義される検証y処理nを利用して，~serviceの識別情報を（型 `URI-ID^i の参照~識別子に対し）検証yしなければナラナイ
— ~clientが何らかの他の形による検証yを受容するよう，特定的に環境設定されていない限り。
例えば，~clientは、当の~serviceは
— 動的な~URIの生成元~server識別子に合致するものではなく —
~serviceに特有な証明書（あるいは、何らかの外部で定義される参照~識別情報に合致している証明書）を呈示するものと期待する下で，［
~address, ~hostname
］とも動的な~serverへ接続しているかもしれない。
◎
In general, a client MUST verify the service identity using the verification process defined in Section 6 of [RFC6125] (for a reference identifier of type URI-ID) unless the client has been specifically configured to accept some other form of verification. For example, a client might be connecting to a server whose address and hostname are dynamic, with an expectation that the service will present a specific certificate (or a certificate matching some externally defined reference identity) rather than one matching the dynamic URI's origin server identifier.
</p>

<p>
特殊な事例では，［
~serverの識別情報を単純に無視することが，~clientにとって適切になり得る
］が、これは，［
接続を能動的な攻撃に対し~~無防備にする
］ものと解されなければならない。
◎
In special cases, it might be appropriate for a client to simply ignore the server's identity, but it must be understood that this leaves a connection open to active attack.
</p>

<p>
証明書が~URIの`生成元~server$用として妥当でない場合、`~UA$は，利用者に通知するか（~UAは、事例を問わず，利用者に接続を継続する~optionを与えてもヨイ），または 不良~証明書~errorで接続を終了しなければナラナイ。
自動化された`~client$は、（可用なら）適切な監査~logに~errorを~logしなければナラナイ
— 加えて、接続を（不良~証明書~errorで）終了するベキである。
自動化された~clientは、この検査を不能化する環境設定を供してもヨイが，それを可能化する設定も供さなければナラナイ。
◎
If the certificate is not valid for the URI's origin server, a user agent MUST either notify the user (user agents MAY give the user an option to continue with the connection in any case) or terminate the connection with a bad certificate error. Automated clients MUST log the error to an appropriate audit log (if available) and SHOULD terminate the connection (with a bad certificate error). Automated clients MAY provide a configuration setting that disables this check, but MUST provide a setting which enables it.
</p>

				</section>
			</section>
		</section>
		<section id="reconstructing.target.uri">
<h3 title="Reconstructing the Target URI">6.4. ~target~URIの再構築-法</h3>

<p>
`内方$への接続を得したなら、`~client$は，~HTTP要請~messageを送信する（ `2.1$sec ）。
◎
Once an inbound connection is obtained, the client sends an HTTP request message (Section 2.1).
</p>

<p>
~clientの~target~URIは、当の要請の資質に依存して，要請~messageを成す様々な各部の中へ 何~成分かに分割されて，伝送される（または含意される）こともある。
各~受信者は、［
各自の局所的な環境設定, 入って来る接続の文脈
］に則って，`~target~URI$を決定する。
~serverが~HTTP11要請~用に~target~URIを決定する方法は、
`Messaging/3.3$sec
が定義する。
◎
Depending on the nature of the request, the client's target URI might be split into components and transmitted (or implied) within various parts of a request message. These parts are recombined by each recipient, in accordance with their local configuration and incoming connection context, to determine the target URI. Section 3.3 of [Messaging] defines how a server determines the target URI for an HTTP/1.1 request.
</p>

<div class="p">
<p>
`~target~URI$が再構築されたなら、`生成元~server$は，［
その~URIに対する~serviceを，［
要請が受信された接続
］を介して供するかどうか
］を裁定する必要がある。
例えば，受信した要請の `Host$h ~headerの中の情報は、故意に, あるいは不用意に誤って［
接続が為された［
`~host$＆`~port$
］とは相違する何か
］を~directしているかもしれない。
信用された`~gateway$からの接続であれば，その不整合は予期されたものかもしれないが、他の場合，次の試みを指示しているかもしれない
⇒＃
~security~filterを迂回する ／
非公開の内容を送達させるよう，~serverを騙す ／
~cacheを汚染する
◎
Once the target URI has been reconstructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received. For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received Host header field differs from the host or port upon which the connection has been made. If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.＼
</p>

<p>
~messageの~route法に関する~securityの考慮点は、
`12$sec を見よ。
◎
See Section 12 for security considerations regarding message routing.
</p>
</div>

<p class="note">注記：
以前の仕様は、構成し直した~target~URIを，別個な概念として
<dfn id="effective.request.uri">実効~要請~URI</dfn>
（ `effective request URI^en ）と定義していた。
◎
Note: previous specifications defined the recomposed target URI as a distinct concept, the effective request URI.
</p>

		</section>
		<section id="field.host">
<h3>6.5. `Host^h</h3>

<p>
要請~内の `Host^h ~headerは、`~target~URI$からの［
`host$p ＆ `port$p
］情報を供して、`生成元~server$が［
単独の~IP~address上にて複数の~host名に対する要請
］を~serviceしている間でも，`資源$を互いに判別できるようにする：
◎
The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.
</p>

<pre class="bnf">
`Host@p
    = `uri-host$p [ ":" `port$p ] ; `~URI$sec
</pre>

<p>
`Host$h の`~field値$は，要請を取扱うときに~criticalな情報なので、`~UA$は，
`Host$h を`~header節$の中の最初の~fieldとして`生成する$ベキである。
◎
Since the Host field value is critical information for handling a request, a user agent SHOULD generate Host as the first field in the header section.
</p>

<div class="example">
<p>
例えば、
`http://www.example.org/pub/WWW/^c
用の`生成元~server$へ向けた `GET$m 要請 は、次で始まることになろう：
◎
For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</p>

<pre class="lang-http">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</pre>
</div>

<p>
`Host$h ~headerは，応用~levelの~route法の仕組みとして動作するので、~malwareにとっては，`共用~cache$を汚染したり,
要請を意図されていない`~server$へ~redirectさせる，格好の標的になる。
~interception`~proxy$は、［
要請を内部~serverへ~redirectする／`共用~cache$内の~cache~keyとして利用する
］ときに `Host$h `~field値$に依拠していて，［
~interceptされた接続が，当の~host用の妥当な~IP~addressを~targetにしているかどうか
］を最初に検証yしていない場合には、特に脆弱になる。
◎
Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the Host field value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.
</p>

		</section>
		<section id="message.forwarding">
<h3 title="Message Forwarding">6.6. ~messageの回送-法</h3>

<p>
`中継者$は
— `2.2$sec にて述べたように —
~HTTP［
要請, 応答
］の処理において，様々な`役割$を~serveし得る。
中継者には、［
処理能や可用性を改善する
］ために利用されるものもあれば，［
~accessを制御する／内容を~filterする
］ために利用されるものもある。
~HTTP~streamには，［
~pipe＆~filter
~architecture
］に類似な特性があるので、`中継者$が増強-（または干渉-）し得る限度には
— ~streamの方向を問わず —
内来的な制限は無い。
◎
As described in Section 2.2, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.
</p>

<p>
`~tunnel$として動作しない`中継者$は、
`Connection$h ~headerを，その節に指定されるとおりに実装しなければナラナイ
— 加えて，［
自身宛の接続のみに意図されている~field
］は、回送する際に除外しなければナラナイ。
◎
An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.8, and exclude fields from being forwarded that are only intended for the incoming connection.
</p>

<p>
`中継者$は、自身宛の~messageを回送してはナラナイ
— それが，無限~要請~loopから保護されていない限り【？】
。
一般に，`中継者$は、自前の~server名
— ［
別名,
局所的な変名,
~literal~IP~address
］も含む —
を認識して，そのような要請に対し直に応答する~OUGHT。
◎
An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.
</p>

<p>
~HTTP~messageは、［
増分的に処理する／`下流$へ回送する
］ときには，~streamとして構文解析できる。
しかしながら，`受信者$は、増分的~送達による部分的~messageには，依拠できない
— 一部の実装は、［
~network効率性,
~security検査,
`~payload$の`形式変換$
］の~~目的で，~message回送を~bufferしたり遅延するので。
◎
An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations.
</p>

			<section id="field.via">
<h4>6.6.1. `Via^h</h4>

<div class="p">
<p>
`Via$h ~headerは、中継~protocolが在ること, および［
要請においては `~UA$ ↔ ︎`~server$ 間にある`受信者$たち ／
応答においては `生成元~server$ ↔ `~client$ 間にある`受信者$たち
］を指示する。
それは、~emailにおける `Received$h ~header `RFC5322$r に類似する。
◎
The "Via" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the "Received" header field in email (Section 3.6.7 of [RFC5322]).＼
</p>

<p>
`Via$h は、次の用途に利用できる
⇒＃
各~message回送-の追跡 ／
要請~loopを避ける ／
［要請／応答］の`連鎖$沿いにある各~送信者の~protocol能力を識別する
◎
Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.
</p>
</div>

<pre class="bnf">
`Via@p
    = #( `received-protocol$p `RWS$p `received-by$p [ `RWS$p `comment$p ] )
`received-protocol@p
    = [ `protocol-name$p "/" ] `protocol-version$p【！; see 6.8】
`received-by@p
    = `pseudonym$p [ ":" `port$p ]
`pseudonym@p
    = `token$p
</pre>

<p class="trans-note">【
“`pseudonym^p” ＝ “`pseudo^en” + “`anonymous^en” （ “~~疑似匿名（~~仮名）” ）
】</p>

<p>
`Via$h `~field値$を成す各~memberは、当の~messageを回送した［
`~proxy$／`~gateway$
］を表現する。
各`中継者$は、［
~messageがどう受信されたかについての，自前の情報
］を［
回送した`受信者$たちの順序が保たれる
］ように付加する。
◎
Each member of the Via field value represents a proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.
</p>

<div class="p">
<p>
`~proxy$は、以下に述べるように，回送する各~message内に適切な `Via$h ~headerを送信しなければナラナイ。
◎
A proxy MUST send an appropriate Via header field, as described below, in each message that it forwards.＼
</p>

<p>
~HTTP-to-HTTP`~gateway$は、回送する~messageが：
◎
An HTTP-to-HTTP gateway＼
</p>
<ul>
	<li>
`内方$への要請ならば、適切な `Via$h ~headerを送信しなければナラナイ。
◎
MUST send an appropriate Via header field in each inbound request message and＼
</li>
	<li>
【`外方$への】応答ならば、 `Via$h ~headerを送信してもヨイ。
◎
MAY send a Via header field in forwarded response messages.
</li>
</ul>
</div>

<p>
`received-protocol$p は、~messageの`下流$の`中継者$たちに対し，［
`上流$の`送信者$により利用された~protocol, その~version
］を指示する。
すなわち， `Via$h `~field値$は、［
要請／応答
］`連鎖$にて広告された~protocol能力を，`下流$の`受信者$から可視であり続けるように記録する
— これは、 `4.2$sec にて述べたように，［
後方-互換でない特能のうち，どれが［
応答／今後の要請
］の中で利用するときに安全になり得るか
］を決定するときに有用になり得る。
~~簡潔にするため、受信される~protocolが~HTTPであるときは，
`received-protocol$p 内の `protocol-name^p は省略される【されてもヨイ？】
。
◎
For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 4.2. For brevity, the protocol-name is omitted when the received protocol is HTTP.
</p>

<p>
`received-by$p を成す部位は、通常は［
受信者`~server$, または［
~messageを~~後続へ回送した`~client$
］］の［
`host$p, および省略可能な `port$p 番号
］になる。
しかしながら，［
本物の~hostは敏感な情報である
］と見なされる場合、`送信者$は，それを `pseudonym$p に置換してもヨイ。
`port$p が供されていない場合、`受信者$は，それを［
`received-protocol$p の既定の~TCP~port上で受信されたことを意味している
］と解釈してもヨイ
— 当の~protocolに既定の~TCP~portが定義されている限り。
◎
The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol.
</p>

<p>
`送信者$は、各`受信者$の~softwareを識別するために【識別する側とされる側が逆？】，
`comment$p を`生成し$てもヨイ
— ［
`User-Agent$h ／ `Server$h
］~headerに相似的な。
しかしながら，
`Via$h ~header内の~commentは任意選択であり、受信者は
— ~messageを回送するに先立って —
それらを除去してもヨイ。
◎
A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.
</p>

<div class="example">
<div class="p">
<p>
例えば，要請~messageが：
◎
For example, a request message could＼
</p>
<ol>
	<li>
~HTTP10`~UA$から［
~code名 "`fred^c" の内部~proxy
］に向けて送信され，
◎
be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred",＼
</li>
	<li>
その内部~proxyは，それを［
`p.example.net^c にある公共~proxy
］に向けて回送するときに~HTTP11を利用し，
◎
which uses HTTP/1.1 to forward the request to a public proxy at p.example.net,＼
</li>
	<li>
その公共~proxyは，それを［
`www.example.com^c にある`生成元~server$
］に向けて回送して，完了した
◎
which completes the request by forwarding it to the origin server at www.example.com.＼
</li>
</ol>

<p>
とするとき、
`www.example.com^c にて受信される要請には，次の `Via$h ~headerが在ることになろう：
◎
The request received by www.example.com would then have the following Via header field:
</p>
</div>

<pre class="lang-http">
Via: 1.0 fred, 1.1 p.example.net
</pre>
</div>

<p>
［
~network~firewallを通る~portal
］として利用される`中継者$は、明示的に可能化されていない限り，［
~firewall領域の中の各~host
］の［
名前＆~port
］を回送するベキでない。
可能化されていない場合、そのような`中継者$は，［
~firewallの背後の~hostを表すような，各 `received-by$p ~host
］を［
その~hostに適切な `pseudonym$p
］に置換するベキである。
◎
An intermediary used as a portal through a network firewall SHOULD NOT forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary SHOULD replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.
</p>

<p>
`中継者$は、
`Via$h ~headerの［
`received-protocol$p 値が互いに一致する，~~連続する一連の~list~member
］を，単独の~memberに結合してもヨイ。
◎
An intermediary MAY combine an ordered subsequence of Via header field list members into a single member if the entries have identical received-protocol values.＼
</p>

<div class="example">
<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre>

<p>
は、次の様に縮約することもできる：
◎
could be collapsed to
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre>
</div>

<div class="p">
<p>
`送信者$は：
◎
↓</p>
<ul>
	<li>
複数の~list~memberを 1 つに結合するベキでない
— ただし、［
それらすべてが同じ組織の制御~下にある
］かつ［
それらの~hostは すでに `pseudonym$p に置換されている
］場合は除く。
◎
A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.＼
</li>
	<li>
［
`received-protocol$p 値が互いに異なる，複数の~member
］を 1 つに結合してはナラナイ。
◎
A sender MUST NOT combine members that have different received-protocol values.
</li>
</ul>
</div>

			</section>
			<section id="message.transformations">
<h4 title="Transformations">6.6.2. 形式変換</h4>

<p>
一部の`中継者$は、［
~messageとその`~payload$を，`形式変換する^dfn
］ための特能を有している。
例えば，`~proxy$には、［
~cache~~領域を節約したり, 遅い~link上の流通~量を抑制する
］ために，画像~形式を変換するものもある。
しかしながら、これらの形式変換が［［
医療~画像処理や科学的~data分析などの~criticalな応用
］に意図されている~payload
］に適用されるとき，運用~上の問題が生じるかもしれない
— 特に、受信される~payloadが元と一致することを確保するために，完全性~検査や~digital署名が利用されている下では。
◎
Some intermediaries include features for transforming messages and their payloads. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original.
</p>

<p>
［
~messageを，意味論的に有意義な仕方で改変する
］ように［
設計され／環境設定され
］ている~HTTP-to-HTTP`~proxy$は、
`形式変換ng~proxy@
と呼ばれる（改変するとは、通常の~HTTP処理に要求されるものを超えて，［
元の`送信者$にとって有意になる, あるいは
`下流$の`受信者$にとって有意になり得る
］ような仕方で~messageを変更することを意味する）。
例えば，形式変換ng~proxyには、［
共用~注釈~server（応答を，局所的な注釈~databaseへの参照を内包するように 改変する）,
~malware~filter,
形式~符号変換器,
~privacy~filter
］などとして，動作しているものもあるかもしれない。
そのような`形式変換$は、~client（または~client組織）が何であれ，［
`~client$が欲して`~proxy$を選定した
］ことが~~前提にあるとされる。
◎
An HTTP-to-HTTP proxy is called a "transforming proxy" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) selected the proxy.
</p>

<p>
`~proxy$は：
◎
↓</p>
<ul>
	<li>
<p>
受信した`~target~URI$に［
完全修飾~domain名でない `host$p 名
］が伴われる場合には、要請を回送するときに，自前の~domainを受信した `host$p 名に追加してもヨイ。
◎
If a proxy receives a target URI with a host name that is not a fully qualified domain name, it MAY add its own domain to the host name it received when forwarding the request.＼
</p>

<p>
`~target~URI$が完全修飾~domain名を包含する場合には。 `host$p 名を変更してはナラナイ。
◎
A proxy MUST NOT change the host name if the target URI contains a fully qualified domain name.
</p>

	</li>
	<li>
受信した`~target~URI$を，`内方$にある次の`~server$へ回送するときには、その［
`absolute-path$p, `query$p
］を成す部分を改変してはナラナイ
— ただし，上に注記された［
空な~pathを "`/^c" または "`*^c" に置換する
］場合を除く。
◎
A proxy MUST NOT modify the "absolute-path" and "query" parts of the received target URI when forwarding it to the next inbound server, except as noted above to replace an empty path with "/" or "*".
</li>
	<li>
<p>
当の~messageが［
`no-transform$sdir `Cache-Control$h 応答~指令
］を：
◎
↓</p>
		<ul>
			<li>
包含する場合、その`~payload$を`形式変換-$してはナラナイ。
`転送~符号法$などの［
~payloadには影響しない，`~message本体$に対する変更
］は、これには該当しないことに注意。
◎
A proxy MUST NOT transform the payload (Section 7.3) of a message that contains a no-transform cache-control response directive (Section 5.2 of [Caching]).＼
Note that this does not include changes to the message body that do not affect the payload, such as transfer codings (Section 7 of [Messaging]).
</li>
			<li>
包含しない場合、その`~payload$を`形式変換-$してもヨイ。
加えて，［
`200$st 応答の`~payload$
］を`形式変換-$するときは、［
`応答~状態s~code$を `203$st に変更する
］ことにより，［
`下流$の`受信者$たちに`形式変換$が適用されていることを伝える
］こともできる。
◎
A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive. A proxy that transforms the payload of a 200 (OK) response can inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 10.3.4).
</li>
		</ul>
	</li>
	<li>
<p>
次についての情報を供する~headerは、改変するベキでない
⇒＃
通信`連鎖$の両`端点$,
`資源$の状態,
`選定された表現$（`~payload$について以外の）
◎
A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the payload)＼
</p>

<p>
— ただし，次に該当するときは除く
⇒＃
~headerの定義が，そのような改変を特定的に許容している ／
~privacyや~securityのために，改変が必要と判断される
◎
unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security.
</p>
	</li>
</ul>

			</section>
		</section>
		<section id="field.upgrade">
<h3 title="Upgrading HTTP">6.7. ~HTTPの昇格-法</h3>

<p>
`Upgrade$h ~headerは、［［
ある接続~上で，`~HTTP11$から 何らかの他の~protocolへ移行する
］ための単純な仕組み
］を意図して供されている。
◎
The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.
</p>

<p>
`~client$は、要請の `Upgrade$h ~header内に［
選好順による，~protocol名の~list
］を送信して，［
`~server$が`最終-応答$を送信する前に，
1 個~以上の それらの名前の~protocolに切替えてもらう
］よう，~serverを招いてもヨイ。
`~server$は、その接続~上で現在の~protocolを利用し続けたいと望むならば，受信した `Upgrade$h ~headerを無視してもヨイ。
`Upgrade$h を利用して，~protocol変更を強要することはできない。
◎
A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.
</p>

<pre class="bnf">
`Upgrade@p
    = #`protocol$p
`protocol@p
    = `protocol-name$p ["/" `protocol-version$p]
`protocol-name@p
    = `token$p
`protocol-version@p
    = `token$p
</pre>

<p>
~protocol名は，選好される文字大小で登録されるが、受信者は，［
各 `protocol-name$p を~supportされる~protocolと照合するとき
］には文字大小無視で比較するベキである。
◎
Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.
</p>

<p>
`~server$は：
</p>
<ul>
	<li>
<p>
`101$st 応答を送信するときは：
◎
A server that sends a 101 (Switching Protocols) response＼
</p>
		<ul>
			<li>
`Upgrade$h ~headerを送信して、切替えようとしている接続に対し，
1 個~以上の新たな~protocolを指示しなければナラナイ。
◎
MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched;＼
</li>
			<li>
切替えようとしている~protocol層が複数ある場合，それらを，最下~層のものから昇順に~listしなければナラナイ。
◎
if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.＼
</li>
			<li>
~protocolを［［［
`~client$による，対応する要請
］の `Upgrade$h ~header
］内に指示されていないもの
］に切替えてはナラナイ。
◎
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.＼
</li>
			<li>
`~client$により指示された［
選好の順序
］を無視することにして，［
要請の資質や, ~server上の現在の負荷などの，他の要因
］に基づく新たな†~protocol（たち）を選定してもヨイ。
【† “新たな” — 前項に反しない中で】
◎
A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.
</li>
		</ul>
	</li>
	<li>
`426$st 応答を送信するときは
⇒
［
選好順による， `Upgrade$h ~header
］を送信して，受容-可能な~protocolを指示しなければナラナイ。
◎
A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.
</li>
	<li>
他の応答においても、未来の要請~用に適切になるときは
⇒
［
選好順による， `Upgrade$h ~header
］を送信して，［
~listされた~protocolに昇格するための~supportを，自身が実装している
］ことを広告してもヨイ。
◎
A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.
</li>
</ul>

<div class="example">
<p>
`~client$により送信される仮の例を次に示す：
◎
The following is a hypothetical example sent by a client:
</p>

<pre class="lang-http">
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
</pre>
</div>

<p>
~protocol変更~後の［
応用~level通信の能力や資質
］は、［
選ばれた新たな~protocol（たち）
］に全面的に依存する。
しかしながら，`~server$は、
`101$st 応答を送信した直後に［
新たな~protocolの中で，元の要請に等価なものを受信した
］かのように応答を継続するものと期待されている（すなわち，~protocolが変更された後であっても、依然として，満足するべき応答待ち要請【まだ`最終-応答$は受信されていない要請】は在って，~serverには［
要請の繰返しを要求することなく，それを満足する
］ものと期待されている）。
◎
The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).
</p>

<p>
例えば，~serverが、［
`GET$m 要請にて `Upgrade$h ~headerが受信された
］下で，~protocolを切替えると裁定した場合には、まず［
HTTP/1.1 `101$st ~message
］で応答した直ぐ後に，［
新たな~protocolにおける［
`~target資源$上の `GET$m に対する応答
］に等価なもの
］が後続する。
これにより、追加的な往来による待時間~costなしに，［
~HTTPと同じ意味論を有する~protocol
］へ接続を昇格できるようになる。
`~server$は、新たな~protocolが［
受信した~messageの意味論
］を尊守し得ない場合は，~protocolを切替えてはナラナイ
— `OPTIONS$m 要請は，どの~protocolからも尊守し得る。
◎
For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.
</p>

<div class="example">
<p>
上に示した仮の要請に対する応答~例を，次に示す：
◎
The following is an example response to the above hypothetical request:
</p>

<pre class="lang-http">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

<span class="comment">
[…… "`GET /hello^c" 要請に対し，適切な応答により~data~streamを
websocket に切替える（その新たな~protocolによる定義に従って）…… ]
◎
[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
</span>
</pre>
</div>

<p>
`Upgrade$h を送信する`送信者$は、［
`Upgrade$h が［
~listされた~protocolを実装していない`中継者$
］により偶発的に回送される
］ことを防ぐために，［
"`upgrade^c" `接続~option$を包含する `Connection$h ~header
］も送信しなければナラナイ。
`~server$は、［
~HTTP10要請にて受信した `Upgrade$h ~header
］を無視しなければナラナイ。
◎
When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.8) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols. A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.
</p>

<p>
`~client$は、［
要請~messageを完全に送信し終える
］まで，接続~上にて昇格された~protocolの利用を~~開始できない（すなわち，~clientは、~messageの中途で，送信している~protocolを変更できない）。
`~server$は、［
`Upgrade$h,
`100-continue$c `期待$を伴う `Expect$h
］の両~headerとも受信したときは，
`101$st 応答を送信する前に `100$st 応答を送信しなければナラナイ。
◎
A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 9.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.
</p>

<p>
`Upgrade$h ~headerは，［
既存の接続の上層にある~protocolの切替
］にのみ適用される。
それは［
下層~接続の（~transport）~protocolの切替
］, あるいは［
既存の通信を異なる接続に切替えること
］には利用し得ない。
その種の目的には、 `3xx$st 応答を利用する方が適切である。
◎
The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 10.4).
</p>

			<section id="upgrade.protocol.names">
<h4 title="Upgrade Protocol Names">6.7.1. `Upgrade^h ~protocol名</h4>

<p>
この仕様は、［
Hypertext Transfer Protocol 族
］に利用するための~protocol名として
—［
~HTTP~version規則
`4.2$sec, および この仕様に対する将来の更新
］に定義されるように —
"`HTTP^c" のみを定義する。
追加的な~protocol名は、
`6.7.2$sec に定義される登録~手続きを利用して登録される~OUGHT。
◎
This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 4.2 and future updates to this specification. Additional protocol names ought to be registered using the registration procedure defined in Section 6.7.2.
</p>

<div>
<table><thead><tr><td>値
<td>説明d
<td>期待される~version~token
<td>参照
</thead>

<tbody><tr><td>`HTTP^c
<td>Hypertext Transfer Protocol
<td>任意の `DIGIT.DIGIT^c （例： "`2.0^c" ）
<td>`4.2$sec
</tbody></table>
◎
Table 5
Name 	Description 	Expected Version Tokens 	Ref.
HTTP 	Hypertext Transfer Protocol 	any DIGIT.DIGIT (e.g, "2.0") 	4.2
</div>

			</section>
			<section id="upgrade.token.registry">
<h4 title="Upgrade Token Registry">6.7.2. `Upgrade^h ~token~registry</h4>

<p>
［
`Upgrade$h ~header内の~protocolを識別するために利用される，
`protocol-name$p ~token
］用の名前空間は、
`~HTTP Upgrade ~token~registry$cite
にて保守され，定義される。
◎
The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines the namespace for protocol-name tokens used to identify protocols in the Upgrade header field. The registry is maintained at &lt;https://www.iana.org/assignments/http-upgrade-tokens&gt;.
</p>

<p>
登録された各~protocol名には、連絡~先~情報に加えて，省略可能な［
接続は、昇格された後 どう処理されるかについて詳細を述べる仕様の集合
］が結付けられる。
◎
Each registered protocol name is associated with contact information and an optional set of specifications that details how the connection will be processed after it has been upgraded.
</p>

<p>
登録は、
“~~申請順（ `First Come First Served^en ）”（
`RFC8126/4.4$sec
）に基づいて行われ，次の規則の~subjectになる：
◎
Registrations happen on a "First Come First Served" basis (see Section 4.4 of [RFC8126]) and are subject to the following rules:
</p>
<ol>
	<li>
一度~登録された `protocol-name$p ~tokenは、登録されたまま~~恒久的に居残る。
◎
A protocol-name token, once registered, stays registered forever.
</li>
	<li>
`protocol-name$p ~tokenは文字大小無視であるが、送信者が生成するときは，登録された文字大小が選好される。
◎
A protocol-name token is case-insensitive and registered with the preferred case to be generated by senders.
</li>
	<li>
登録は、登録に対する責任主体を命名しなければナラナイ。
◎
The registration MUST name a responsible party for the registration.
</li>
	<li>
登録は、連絡~窓口を命名しなければナラナイ。
◎
The registration MUST name a point of contact.
</li>
	<li>
登録は、［
その~tokenに結付けられる仕様の集合
］を命名してもヨイ。
そのような仕様は、公に可用になる必要はない。
◎
The registration MAY name a set of specifications associated with that token. Such specifications need not be publicly available.
</li>
	<li>
登録は、［
登録の時点でその~tokenに結付けられる［
期待される "`protocol-version$p" ~tokenからなる集合
］］を命名するベキである。
◎
The registration SHOULD name a set of expected "protocol-version" tokens associated with that token at the time of registration.
</li>
	<li>
責任主体は、いつでも登録を変更してもヨイ。
~IANAは、そのような変更sすべての記録-を保って，要請に応じて，それらを可用にすることになる。
◎
The responsible party MAY change the registration at any time. The IANA will keep a record of all such changes, and make them available upon request.
</li>
	<li>
IESG は、
`protocol$p ~tokenに対する責任主体を他にアテガってもヨイ。
これは、通常は，責任主体に連絡できなくなったときに限られる。
◎
The IESG MAY reassign responsibility for a protocol token. This will normally only be used in the case when a responsible party cannot be contacted.
</li>
</ol>

			</section>
		</section>
		<section id="field.connection">
<h3 title="Connection-Specific Fields">6.8. 接続に特有な~field</h3>

<p>
`Connection^h ~headerは、［
現在の接続に欲される制御~option
］を~listすることを，`送信者$に許容する。
◎
The "Connection" header field allows the sender to list desired control options for the current connection.
</p>

<p>
`送信者$は、［
`Connection^h 以外の`~field$
］を［
現在の接続［
用／について
］の制御~情報を給する
］ために利用するときは，対応する`~field名$を `Connection^h ~headerの中に~listしなければナラナイ。
~HTTPの一部の~versionは、そのような情報~用に各~fieldを利用するのを禁制する
— したがって， `Connection^h ~fieldを許容しない —
ことに注意。
◎
When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field. Note that some versions of HTTP prohibit the use of fields for such information, and therefore do not allow the Connection field.
</p>

<div class="p">
<p>
`中継者$は、受信した~message `M^V を回送する前に，次を行わなければナラナイ：
◎
Intermediaries MUST＼
</p>
<ol>
	<li>
`M^V 内の `Connection^h ~header`~field値$を構文解析する。
◎
parse a received Connection header field before a message is forwarded and,＼
</li>
	<li>
前~段の結果を成す各 `connection-option$p に対し
⇒
`M^V から［
`connection-option$p と同じ名前を`~field名$に伴う［
`~header$／`~trailer$
］］をすべて除去する
◎
for each connection-option in this field, remove any header or trailer field(s) from the message with the same name as the connection-option, and then＼
</li>
	<li>
次のいずれかを行う
⇒＃
`M^V から `Connection^h ~headerを除去する／
`M^V 内の `Connection^h の値を 自前の`接続~option$で置換する
◎
remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).
</li>
</ol>
</div>

<p>
すなわち， `Connection^h ~headerは、［
直近の`受信者$のみに意図された（`隣点間$）`~field$
］と［
`連鎖$上にある すべての`受信者$に意図された（`端点間$）`~field$
］とを判別できるようにする，宣言的な仕方を供する
— それは、~messageを自己-記述的にすることで，［
古い`中継者$により盲目的に回送されるおそれ
］なく，［
接続ごとに特有な，将来の拡張
］を配備できるようにする。
◎
Hence, the Connection header field provides a declarative way of distinguishing fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.
</p>

<p>
さらに，`中継者$は、次に該当する各~fieldを
— ~fieldの意味論を適用した後に —
除去するか置換するベキである
⇒
その意味論は回送する前の除去を要求することが既知であるもの
— ~field名が `Connection^h の`接続~option$として出現するかどうかは問わない。
次に挙げる~fieldは，これに含まれるが、この限りでない
⇒＃
`Proxy-Connection$h `Messaging$r,
`Keep-Alive$h `RFC2068/19.7.1$sec,
`TE$h,
`Trailer$h,
`Transfer-Encoding$h `Messaging$r,
`Upgrade$h
◎
Furthermore, intermediaries SHOULD remove or replace field(s) whose semantics are known to require removal before forwarding, whether or not they appear as a Connection option, after applying those fields' semantics. This includes but is not limited to:
• Proxy-Connection (Appendix C.1.2 of [Messaging])
• Keep-Alive (Section 19.7.1 of [RFC2068])
• TE (Section 5.6.5)
• Trailer (Section 5.6.4)
• Transfer-Encoding (Section 6.1 of [Messaging])
• Upgrade (Section 6.7)
</p>

<p>
`Connection$h ~header`~field値$の文法は：
◎
The Connection header field's value has the following grammar:
</p>

<pre class="bnf">
`Connection@p
    = #`connection-option$p
`connection-option@p
    = `token$p
</pre>

<p>
`connection-option$p が各
`接続~option@
を与える。
それらは、文字大小無視である。
◎
Connection options are case-insensitive.
</p>

<p>
`送信者$は、`接続~option$として［
`~payload$を受け取るすべての`受信者$向けに意図された`~field$
］に対応するものは，送信してはナラナイ。
例えば， `Cache-Control$h は、接続~optionとしては，決して適切にならない。
◎
A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the payload. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [Caching]).
</p>

<p>
`接続~option$は，常に［
~message内に在る`~field$
］に対応するとは限らない
— 結付けられる~parameterがない接続~optionに対しては、［
接続ごとに特有な`~field$
］は不要になり得るので。
対照的に，［
対応する接続~optionを伴わずに受信された，接続ごとに特有な~field
］は、通例的に［
当の~fieldは`中継者$により不適正に回送された
］ことを指示するので，`受信者$は無視する~OUGHT。
◎
The connection options do not always correspond to a field present in the message, since a connection-specific field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.
</p>

<p>
仕様~策定者は，新たな`接続~option$を定義するときは、予約-済み`~field名$として文書~化した上で，その定義を
— 衝突を避けるよう —
`~HTTP~field名~registry^cite（ `5.3.2$sec ）に登録する~OUGHT。
◎
When defining new connection options, specification authors ought to document it as reserved field name and register that definition in the Hypertext Transfer Protocol (HTTP) Field Name Registry (Section 5.3.2), to avoid collisions.
</p>

		</section>
	</section>
	<section id="representations">
<h2 title="Representations">7. 表現</h2>

<p>
`資源$はどの様なモノにもなり得ること，および
~HTTPにより供される統一的~interfaceは， “窓” のようなもの
— ［
その窓の向こう側で 独立に動作する者との，~messageの通信
］を通してのみ、そのようなモノを観測して, 動作できるような窓 —
であることを考えるとき、その通信においては，そのモノの［
現在の状態
【すなわち，応答】
や, 欲される状態
【すなわち，要請】
］を表現する（ “~~代理する” ）ための抽象-化が必要になる。
そのような抽象-化は、
`表現^dfn
と呼ばれる。
`REST$r
◎
Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent ("take the place of") the current or desired state of that thing in our communications. That abstraction is called a representation [REST].
</p>

<p>
~HTTPの目的における
`表現@
とは、［
所与の`資源$の［
過去の／現在の／欲される
］状態を反映する
］ように意図された，［
~protocolを介して通信するに~~適した形式による情報
］であり，［
`表現~metadata$からなる集合, および
`表現~data$の~stream（~~長さ~~無制限にもなり得る）
］からなる。
◎
For the purposes of HTTP, a "representation" is information that is intended to reflect a past, current, or desired state of a given resource, in a format that can be readily communicated via the protocol, and that consists of a set of representation metadata and a potentially unbounded stream of representation data.
</p>

<p>
`生成元~server$は、同じ`~target資源$に対し，［
それぞれが`資源$の現在の状態を反映するものと意図された，複数の表現
］を［
供する／生成する
］能力を備えていることもある。
そのような事例では、生成元~serverにより，［
それらの表現のうち，所与の要請に最も適用-可能なもの
］を
— 通例的に，`内容~折衝$に基づいて —
選定するような、何らかの~algoが利用される。
このようにして一つに
`選定された表現@
が、［
`条件付き要請$を評価する
］ため, および ［
`GET$m に対する
`200$st ／ `206$st ／ `304$st
応答の~payloadを構築する
］ための，［
~dataと~metadata
］を供するために利用される。
◎
An origin server might be provided with, or be capable of generating, multiple representations that are each intended to reflect the current state of a target resource. In such cases, some algorithm is used by the origin server to select one of those representations as most applicable to a given request, usually based on content negotiation. This "selected representation" is used to provide the data and metadata for evaluating conditional requests (Section 9.2) and constructing the payload for 200 (OK), 206 (Partial Content), and 304 (Not Modified) responses to GET (Section 8.3.1).
</p>

		<section id="representation.data">
<h3 title="Representation Data">7.1. 表現~data</h3>

<p>
~HTTP~messageに結付けられる`表現$を成す~dataは、［
~messageの`~payload本体$として供される
］か, または［
~message意味論と`~target~URI$から指される
］か，のいずれかになる。
表現~dataの［
形式と符号化法
］は、`表現~metadata$~headerにより定義される。
◎
The representation data associated with an HTTP message is either provided as the payload body of the message or referred to by the message semantics and the target URI. The representation data is in a format and encoding defined by the representation metadata header fields.
</p>

<p>
表現~dataの~data型は、［
`Content-Type$h, および `Content-Encoding$h 
］~headerを介して決定される。
これらは［
2 層からなる, 順序付けられた符号化~model
］を定義する：
◎
The data type of the representation data is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:
</p>

<blockquote>
表現~data := `Content-Encoding^V ( `Content-Type^V ( ビット列 ) )
◎
representation-data := Content-Encoding( Content-Type( bits ) )
</blockquote>

			<section id="media.type">
<h4 title="Media Type">7.1.1. ~MIME型</h4>

<p class="trans-note">【
この訳では、原文の［
`Internet media type^en, その略称 `media type^en
］を，一律に “~MIME型” と表記する（ RFC 以外の他の~web標準と一貫させるため）。
】</p>

<p>
~HTTPは、［
~openかつ拡張できる，~dataの型~付けと型~折衝
］を供するため，［
`Content-Type$h, `Accept$h
］~header内で~MIME型 `2046$r を利用する。
`~MIME型^dfn
（ `media-type$p ）は、~data形式, および
様々な処理~model
— ~dataが受信される各~文脈に則って，~dataを処理する方法 —
を定義する。
◎
HTTP uses media types [RFC2046] in the Content-Type (Section 7.2.1) and Accept (Section 9.4.1) header fields in order to provide open and extensible data typing and type negotiation. Media types define both a data format and various processing models: how to process that data in accordance with each context in which it is received.
</p>

<pre class="bnf">
`media-type@p
    = `type$p "/" `subtype$p `parameters$p
`type@p
    = `token$p
`subtype@p
    = `token$p
</pre>

【！ Errata 4031 Rejected】

<p>
［
`type$p, `subtype$p
］とも、文字大小無視である。
◎
The type and subtype tokens are case-insensitive.
</p>

<p>
`type/subtype^p には、~semicolonで区切られた何個かの
`~MIME型~parameter@
— `名前^V=`値^V ~pairの形をとる`~parameter$ —
が後続してもヨイ。
~parameterの有無は、［
~MIME型~registryにおける その定義
］に依存して，~MIME型の処理に有意になり得る。
各~parameterの値が文字大小区別になるかどうかは、当の~parameterの名前の意味論に依存する。
◎
The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.4.1.4) in the form of name=value pairs. The presence or absence of a parameter might be significant to the processing of a media type, depending on its definition within the media type registry. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.
</p>

<div class="example">
<p>
例えば次のものは、~UTF-8文字~符号化~schemeに符号化された~HTML~text~dataを述べるときには，どれも等価になる（ "`charset^c" ~parameterの値は、
`RFC2046/4.1.2$sec
にて文字大小無視として定義されている）
— 一貫性を得るため、最初のものが選好されるが：
◎
For example, the following media types are equivalent in describing HTML text data encoded in the UTF-8 character encoding scheme, but the first is preferred for consistency (the "charset" parameter value is defined as being case-insensitive in [RFC2046], Section 4.1.2):
</p>

<pre class="lang-http">
text/html;charset=utf-8
Text/HTML;Charset="utf-8"
text/html; charset="utf-8"
text/html;charset=UTF-8
</pre>
</div>

<p>
~MIME型は、`BCP13$rにて定義される手続きに則って，~IANAにより登録される~OUGHT。
◎
Media types ought to be registered with IANA according to the procedures defined in [BCP13].
</p>

				<section id="charset">
<h5 title="Charset">7.1.1.1. ~charset</h5>

<p>
~HTTPでは、［
~textな表現の，文字~符号化~scheme `RFC6365$r
］を指示したり折衝するときに，~charset名（ `charset$p ）を利用する。
`charset$p は、文字大小無視~tokenにより識別される。
◎
HTTP uses charset names to indicate or negotiate the character encoding scheme of a textual representation [RFC6365]. A charset is identified by a case-insensitive token.
</p>

<pre class="bnf">
`charset@p
    = `token$p
</pre>

<p>
~charset名は、`RFC2978/2$sec にて定義される手続きに則って，~IANA
<a href="~IANA-a/character-sets">Character Sets</a>
~registryに登録される~OUGHT。
◎
Charset names ought to be registered in the IANA "Character Sets" registry (&lt;https://www.iana.org/assignments/character-sets&gt;) according to the procedures defined in Section 2 of [RFC2978].
</p>

<p class="note">注記：
理論~上は、~charset名は， `mime-charset^p ~ABNF規則  `RFC2978/2.3$sec に定義される（ `Err1912$r により正された上で）。
その規則は， `token$p に含まれない 2 つの文字（ "`{^c", "`}^c" ）を許容するが、これを書いている時点では，それらの文字を含む~charset名は登録されていない（ `Err5433$r を見よ）。
◎
Note: In theory, charset names are defined by the "mime-charset" ABNF rule defined in Section 2.3 of [RFC2978] (as corrected in [Err1912]). That rule allows two characters that are not included in "token" ("{" and "}"), but no charset name registered at the time of this writing includes braces (see [Err5433]).
</p>

				</section>
				<section id="canonicalization.and.text.defaults">
<h5 title="Canonicalization and Text Defaults">7.1.1.2. 正準-化, ~textにおける既定</h5>

<p>
~MIME型は、［
~native符号化~形式が様々な~system
］間でも相互運用-可能にするため，正準-形で登録される。
［
MIME（ `Multipurpose Internet Mail Extensions^en ）`RFC2045$r
］にて述べられている多くの理由と同じ理由から、［
~HTTPを介して 選定される／転送される`表現$
］は正準-形にされる~OUGHT。
しかしながら，［
~email配達（すなわち，~messageを格納して~peerへ回送する）の処理能 特性
］は、［
~HTTPや~Web（~serverに基づく情報~service）において共通的なそれ
］からは有意に異なる。
更には、~MIMEによる拘束は，古い~mail転送~protocolとの互換性を~~目的にしており、~HTTPには適用されない（ `Messaging/B$sec を見よ）。
◎
Media types are registered with a canonical form in order to be interoperable among systems with varying native encoding formats. Representations selected or transferred via HTTP ought to be in canonical form, for many of the same reasons described by the Multipurpose Internet Mail Extensions (MIME) [RFC2045]. However, the performance characteristics of email deployments (i.e., store and forward messages to peers) are significantly different from those common to HTTP and the Web (server-based information services). Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see Appendix B of [Messaging]).
</p>

<p>
~MIMEの正準-形では、［
"`text^c" `~MIME型$を成すすべての下位型
］において，~text改行に `CRLF$P を利用することが要求される。
一方で，~HTTPでは、［
改行が~~単独の `CR$P ／ `LF$P で表現された，~text~media
］の転送も，［
そのような改行が`表現$ 全体で~~一貫している
］ときには 許容される。
~HTTP［
`送信者$／`受信者$
］は、~text~media内に［
`CRLF$P 並びや, ~~単独の `CR$P ／ `LF$P による改行
］を`生成し$てもヨイ
— また，構文解析できなければナラナイ。
加えて，~HTTPにおける~text~mediaは、［
`CR$P, `LF$P に，~octet `0D^X, `0A^X 【！ 13, 10】（同順）を利用する`~charset$
］に制限されない。
この，改行に関する柔軟性は、［
`表現$の中に， "`text^c" ~MIME型としてアテガわれた~text
］のみに適用され，［
"`multipart$c" 型や, `~payload本体$の外側の~HTTP要素（例：`~header$）
］には適用されない。
◎
MIME's canonical form requires that media subtypes of the "text" type use CRLF as the text line break. HTTP allows the transfer of text media with plain CR or LF alone representing a line break, when such line breaks are consistent for an entire representation. An HTTP sender MAY generate, and a recipient MUST be able to parse, line breaks in text media that consist of CRLF, bare CR, or bare LF. In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for CR and LF, respectively. This flexibility regarding line breaks applies only to text within a representation that has been assigned a "text" media type; it does not apply to "multipart" types or HTTP elements outside the payload body (e.g., header fields).
</p>

<p>
`表現$が`内容~符号法$により符号化される場合、下層の~dataは，符号化されるに先立って，上で定義した形にされる~OUGHT。
◎
If a representation is encoded with a content-coding, the underlying data ought to be in a form defined above prior to being encoded.
</p>

				</section>
				<section id="multipart.types">
<h5 title="Multipart Types">7.1.1.3. `multipart^c 型</h5>

<p>
~MIMEは、［
単独の`~message本体$の中に， 1 個以上の`表現$が~encapsulateされる
］ような，いくつもの
"`multipart^c" 型
を供する。
すべての "`multipart^c" 型は、`RFC2046/5.1.1$secにて定義される 共通な構文を共有し，`~MIME型$ 値の一部として 境界~parameterを内包する。
`~message本体$自身は、~protocol要素である
— `送信者$は、本体の各 部分~間の改行を表現するときは， `CRLF$P のみを`生成し$なければナラナイ。
◎
MIME provides for a number of "multipart" types — encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in Section 5.1.1 of [RFC2046], and include a boundary parameter as part of the media type value. The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.
</p>

<p>
~HTTP~message~frame法においては、
"`multipart^c" 境界が `~message本体$の長さの指示子として利用されることはない
— ~payloadを生成する／処理する実装により，利用されることはあっても。
例えば， "`multipart/form-data^c" 型は、`RFC7578$rに述べられるように，要請~内に~form~dataを運ばせるために よく利用される。
また， "`multipart/byteranges$c" 型は、一部の `206$st 応答に利用するためとして，この仕様に定義される。
◎
HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload. For example, the "multipart/form-data" type is often used for carrying form data in a request, as described in [RFC7578], and the "multipart/byteranges" type is defined by this specification for use in some 206 (Partial Content) responses (see Section 10.3.7).
</p>

				</section>
			</section>
			<section id="content.codings">
<h4 title="Content Codings">7.1.2. 内容~符号法</h4>

<p>
内容~符号法の値（ `content-coding$p ）は、［
`表現$に［
適用された／適用できる
］符号化法による形式変換
］を指示する。
内容~符号法は，首に、表現の下層の［
`~MIME型$の同一性, 情報
］を損なうことなく，表現を［
圧縮する／有用に形式変換する
］ことを許容するために利用される。
表現が，［
符号化形で格納され, 直に伝送され，最終-受信者によってのみ復号される
］ことは、~~頻繁にある。
◎
Content coding values indicate an encoding transformation that has been or can be applied to a representation. Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the representation is stored in coded form, transmitted directly, and only decoded by the final recipient.
</p>

<pre class="bnf">
`content-coding@p
    = `token$p
</pre>

<p>
すべての`内容~符号法$は，文字大小無視であり、
`7.1.2.4$sec に定義される
`内容~符号法~registry$cite
の中に登録される~OUGHT。
◎
All content codings are case-insensitive and ought to be registered within the "HTTP Content Coding Registry", as defined in Section 7.1.2.4 
</p>

<p>
各種 `内容~符号法$値は、［
`Accept-Encoding$h,
`Content-Encoding$h
］~header内で利用されるる。
◎
Content-coding values are used in the Accept-Encoding (Section 9.4.3) and Content-Encoding (Section 7.2.2) header fields.
</p>

<p>
この仕様では、次の内容~符号法 値が定義される：
◎
The following content-coding values are defined by this specification:
</p>

<div>
<table><thead><tr><td>名前
<td>説明d
</thead><tbody>

<tr><td>"`compress$c"
<td>~UNIX "compress" ~data形式 `Welch$r

<tr><td>"`deflate$c"
<td>"zlib" ~data形式 `RFC1950$r の内側の "deflate" 圧縮-済み~data `RFC1951$r

<tr><td>"`gzip$c"
<td>GZIP ~file形式 `RFC1952$r

<tr><td>"`identity$c"
<td>予約-済み

<tr><td>"`x-compress^c"
<td>非推奨d（ "`compress$c" の別名）

<tr><td>"`x-gzip^c"
<td>非推奨d（ "`gzip$c" の別名）

</tbody></table>

◎
Table 6
Name 	Description 	Ref.
compress 	UNIX "compress" data format [Welch] 	7.1.2.1
deflate 	"deflate" compressed data ([RFC1951]) inside the "zlib" data format ([RFC1950]) 	7.1.2.2
gzip 	GZIP file format [RFC1952] 	7.1.2.3
identity 	Reserved
x-compress 	Deprecated (alias for compress) 	7.1.2.1
x-gzip 	Deprecated (alias for gzip) 	7.1.2.3
</div>

				<section id="compress.coding">
<h5 title="Compress Coding">7.1.2.1. "`compress^c" 符号法</h5>

<p>
"`compress^c" 符号法は、共通的に［
~UNIX~file圧縮~program “compress”
］により生産される，［
適応的 LZW（ `Lempel-Ziv-Welch^en ）符号法 `Welch$r
］である。
`受信者$は、 "`x-compress^c" を "`compress^c" と等価と見なすベキである。
◎
The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program "compress". A recipient SHOULD consider "x-compress" to be equivalent to "compress".
</p>

				</section>
				<section id="deflate.coding">
<h5 title="Deflate Coding">7.1.2.2. "`deflate^c" 符号法</h5>

<p>
"`deflate^c" 符号法は、
“zlib” ~data形式 `RFC1950$r であり，［
LZ77 （ `Lempel-Ziv^en ）圧縮~algoと, Huffman 符号法が組合された， “deflate” 圧縮-済み~data~stream `RFC1951$r
］を包含する。
◎
The "deflate" coding is a "zlib" data format [RFC1950] containing a "deflate" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.
</p>

<p class="note">注記：
一部の適合しない実装は、
"`deflate^c" 圧縮-済み~dataを，zlib で包装せずに送信する。
◎
Note: Some non-conformant implementations send the "deflate" compressed data without the zlib wrapper.
</p>

				</section>
				<section id="gzip.coding">
<h5 title="Gzip Coding">7.1.2.3. "`gzip^c" 符号法</h5>

<p>
"`gzip^c" 符号法は、［
32-bit CRC（ `Cyclic Redundancy Check^en ）が伴われた LZ77 符号法
］であり，［
“gzip” ~file圧縮~program `RFC1952$r
］により共通的に生産される。
`受信者$は、 "`x-gzip^c" を "`gzip^c" と等価と見なすベキである。
◎
The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider "x-gzip" to be equivalent to "gzip".
</p>

				</section>
				<section id="content.coding.registry">
<h5 title="Content Coding Registry">7.1.2.4. 内容~符号法~registry</h5>

<p>
~IANAにより保守されている
`内容~符号法~registry$cite
は、`内容~符号法$~名を登録する。
◎
The "HTTP Content Coding Registry", maintained by IANA at &lt;https://www.iana.org/assignments/http-parameters/&gt;, registers content-coding names.
</p>

<p>
`内容~符号法$の登録には、次の~fieldを含めなければナラナイ
⇒＃
名前,
説明d,
仕様~textへの~pointer
◎
Content coding registrations MUST include the following fields:
• Name
• Description
• Pointer to specification text
</p>

<p>
`内容~符号法の名前$は、`転送~符号法の名前$と重合してはナラナイ
— 符号化法の形式変換（`内容~符号法$secに定義される各種 圧縮~符号法など）が一致している場合を除き。
◎
Names of content codings MUST NOT overlap with names of transfer codings (Section 7 of [Messaging]), unless the encoding transformation is identical (as is the case for the compression codings defined in Section 7.1.2).
</p>

<p>
この名前空間に追加される値は、
`IETF による考査$を要する。
また、`内容~符号法$secの目的に適合しなければナラナイ。
◎
Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of content coding defined in Section 7.1.2.
</p>

<p>
新たな内容~符号法は、アリなときは，［
その符号法の形式の中で発見-可能な，省略可能な各種~parameter
］で自己-記述的になる~OUGHT
— ~~通過中に失われるかもしれない，外部の~metadataに依拠するのではなく。
◎
New content codings ought to be self-descriptive whenever possible, with optional parameters discoverable within the coding format itself, rather than rely on external metadata that might be lost during transit.
</p>

				</section>
			</section>
			<section id="language.tags">
<h4 title="Language Tags">7.1.3. 言語~tag</h4>

<p>
`言語~tag^dfn
は、 `RFC5646$rにて定義されるように，［
他者と情報をやりとりするために，ヒトにより［
話され, 書かれ, あるいは伝達される
］自然~言語
］を識別する。
~computer言語は、明示的に除外される。
◎
A language tag, as defined in [RFC5646], identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.
</p>

<p>
~HTTPでは、言語~tagを［
`Accept-Language$h ／ `Content-Language$h
］~headerの中で利用する。
`Accept-Language$h は，より~~広い `language-range$p 生成規則を利用するように定義される一方、
`Content-Language$h は，次に定義する `language-tag$p 生成規則を利用する：
◎
HTTP uses language tags within the Accept-Language and Content-Language header fields. Accept-Language uses the broader language-range production defined in Section 9.4.4, whereas Content-Language uses the language-tag production defined below.
</p>

<pre class="bnf">
`language-tag@p
    = &lt;Language-Tag, `RFC5646/2.1$sec&gt;
</pre>

<div class="p">
<p>
言語~tagは、文字~hyphen（ "`-^c", `2D^X ）で互いに分離された， 1 個~以上の~subtag（文字大小無視）からなる並びである。
ほとんどの事例では、言語~tagは 次の並びからなる：
◎
A language tag is a sequence of one or more case-insensitive subtags, each separated by a hyphen character ("-", %x2D). In most cases, a language tag consists of＼
</p>
<ol>
	<li>
関係する言語の~~広い族を識別する，首な言語~subtag（例： "`en^c" ＝ 英語）
◎
a primary language subtag that identifies a broad family of related languages (e.g., "en" = English), which is＼
</li>
	<li>
その言語の範囲を［
精緻化する／~~狭める
］省略可能な一連の~subtag
（例： "`en-CA^c" は、~Canadaで会話される英語の一方言）
◎
optionally followed by a series of subtags that refine or narrow that language's range (e.g., "en-CA" = the variety of English as communicated in Canada).＼
</li>
</ol>

<p>
言語~tagの中では、`空白$は許容されない。
◎
Whitespace is not allowed within a language tag.＼
</p>
</div>

<div class="example">
<p>
~tagの例：
◎
Example tags include:
</p>

<pre class="lang-http">
fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
</pre>
</div>

<p>
更なる情報は、`RFC5646$rを見よ。
◎
See [RFC5646] for further information.
</p>

			</section>
			<section id="range.units">
<h4 title="Range Units">7.1.4. 範囲~単位</h4>

<p>
`表現~data$は、その~dataの［
`内容~符号法$／`~MIME型$
］に内来的な~address可能な構造上の単位があるときには、部分範囲に区分できる。
例えば，~octet（すなわち，~byte）境界は、すべての`表現~data$に共通な構造上の単位であり，~dataを成す一~区分-が［
~dataの始端／終端からの~offsetによる範囲を成す~byte列
］として識別されることを許容する。
◎
Representation data can be partitioned into subranges when there are addressable structural units inherent to that data's content coding or media type. For example, octet (a.k.a., byte) boundaries are a structural unit common to all representation data, allowing partitions of the data to be identified as a range of bytes at some offset from the start or end of that data.
</p>

<p>
この一般的な範囲~単位の観念は、次のために利用される：
◎
This general notion of a "range unit" is used in＼
</p>
<ul>
	<li>
`Accept-Ranges$h 応答~header内にて，`範囲~要請$の~supportを広告する。
◎
the Accept-Ranges (Section 11.4.1) response header field to advertise support for range requests,＼
</li>
	<li>
`Range$h 要請~header内にて，要請される`表現$の各~部位tが占める範囲を~~精確に~~述べる。
◎
the Range (Section 9.3) request header field to delineate the parts of a representation that are requested, and＼
</li>
	<li>
`Content-Range$h `~payload~header$内にて，`表現$のどの部位tが転送されているかを述べる。
◎
the Content-Range (Section 7.3.4) payload header field to describe which part of a representation is being transferred.
</li>
</ul>

<pre class="bnf">
`range-unit@p
    = `token$p
</pre>

<p>
すべての`範囲~単位$は文字大小無視であり、
`7.1.4.4$sec に定義される
`~HTTP範囲~単位~registry$cite
の中に登録される~OUGHT。
◎
All range unit names are case-insensitive and ought to be registered within the "HTTP Range Unit Registry", as defined in Section 7.1.4.4
</p>

<p>
この文書では、次の範囲~単位~名が定義される：
◎
The following range unit names are defined by this document:
</p>

<div>

<dl>
	<dt>`bytes@c</dt>
	<dd>
~octet列の範囲
— `~byte範囲$ —
を与える
</dd>

	<dt>`none@c</dt>
	<dd>
範囲~要請は~supportされないことを指示する~keywordとして予約される（ `Accept-Ranges$h を見よ）。
</dd>
</dl>
◎
Table 7
Range Unit Name 	Description 	Ref.
bytes 	a range of octets 	7.1.4.2
none 	reserved as keyword to indicate range requests are not supported 	11.4.1
</div>

				<section id="range.specifiers">
<h5 title="Range Specifiers">7.1.4.1. 範囲~指定子</h5>


<p>
範囲は、範囲~指定子（ `range-spec$p ）の集合（ `range-set$p ）, それと~pairにされた範囲~単位（ `range-unit$p ）の用語で表出される。
範囲~単位を成す名前は、［
自前の指定子において，どの種類の `range-spec$p が適用-可能になるか
］を決定する。
よって，次に与える文法は汎用である
— 各~範囲~単位は、［
`int-range$p,
`suffix-range$p,
`other-range$p
］がいつ許容されるかに関する要件を指定するものと期待される。
◎
Ranges are expressed in terms of a range unit paired with a set of range specifiers. The range unit name determines what kinds of range-spec are applicable to its own specifiers. Hence, the following gramar is generic: each range unit is expected to specify requirements on when int-range, suffix-range, and other-range are allowed.
</p>

<p id="rule.ranges-specifier">
`範囲~要請$は、［
単独の表現の中の， 1 個以上の範囲が成す集合
］を指定できる。
◎
A range request can specify a single range or a set of ranges within a single representation.
</p>

<pre class="bnf">
`ranges-specifier@p
    = `range-unit$p "=" `range-set$p
`range-set@p
    = 1#`range-spec$p
`range-spec@p
    = `int-range$p
    / `suffix-range$p
    / `other-range$p
</pre>

<p id="rule.int-range">
`int-range$p は、範囲を［
2 個の負でない整数
］または［
1 個の負でない整数から`表現~data$の終端まで
］として表出する。
範囲~単位は、これらの整数が何を意味するかを指定する（例：
先頭からの単位~offset,
その~offsetも範囲に含まれるかどうか,
等々を指示することもあろう）。
◎
An int-range is a range expressed as two non-negative integers or as one non-negative integer through to the end of the representation data. The range unit specifies what the integers mean (e.g., they might indicate unit offsets from the beginning, inclusive numbered parts, etc.).
</p>

<pre class="bnf">
`int-range@p
    = `first-pos$p "-" [ `last-pos$p ]
`first-pos@p
    = 1*`DIGIT$P
`last-pos@p
    = 1*`DIGIT$P
</pre>

<p>
`int-range$p は、［
`last-pos$p 値が在って, その値は `first-pos$p 未満である
］ならば，妥当でない。
◎
An int-range is invalid if the last-pos value is present and less than the first-pos.
</p>

<p id="rule.suffix-range">
`suffix-range$p は、`表現~data$の~~尾部を［
供された負でない（範囲~単位による）整数による最大~長さ
］で表出する範囲である。
言い換えれば、表現~dataを成す最後から `N^V 個の単位を表す。
◎
A suffix-range is a range expressed as a suffix of the representation data with the provided non-negative integer maximum length (in range units). In other words, the last N units of the representation data.
</p>

<pre class="bnf">
`suffix-range@p
    = "-" `suffix-length$p
`suffix-length@p
    = 1*`DIGIT$P
</pre>

<p id="rule.other-range">
`other-range$p 規則の文法は，ほぼ拘束されない
— ［
応用に特有な範囲~単位／
追加的な範囲~指定子を定義する将来の範囲~単位
］を許容する拡張能を供するためにあるので。
◎
To provide for extensibility, the other-range rule is a mostly unconstrained grammar that allows application-specific or future range units to define additional range specifiers.
</p>

<pre class="bnf">
`other-range@p
    = 1*( `21-2B^X / `2D-7E^X )
    ; 1*(<span class="comment" title="VCHAR excluding comma">~comma以外の `VCHAR$P</span>)
</pre>

				</section>
				<section id="byte.ranges">
<h5 title="Byte Ranges">7.1.4.2. ~byte範囲</h5>

<p>
範囲~単位 "`bytes$c" は、
`~byte範囲^dfn
— `表現~data$の~octet列を成す部分範囲 —
を表出するために利用される。
各~byte範囲は、`表現~data$の［
先頭から ( `int-range$p ）または終端から ( `suffix-range$p ）
］の，ある~offsetを指す整数~範囲として表出される。
~byte範囲は `other-range$p 指定子を利用しない。
◎
The "bytes" range unit is used to express subranges of a representation data's octet sequence. Each byte range is expressed as an integer range at some offset, relative to either the beginning (int-range) or end (suffix-range) of the representation data. Byte ranges do not use the other-range specifier.
</p>

<p>
`bytes$c における `int-range$p を成す［
`first-pos$p 値, `last-pos$p 値
］は、順に，範囲の［
最初の, 最後の
］~offsetを， 0 から数えた~byte数で与える。
すなわち、指定された~byte~~位置は範囲に含まれ， "`0^c" は先頭~byteを~~指す。
◎
The first-pos value in a bytes int-range gives the offset of the first byte in a range. The last-pos value gives the offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.
</p>

<p>
`表現~data$に`内容~符号法$が適用されている場合、各~byte範囲は，符号化された~byte列を~~基準に計算される
— 復号して得される下層の~byte列ではなく。
◎
If the representation data has a content coding applied, each byte range is calculated with respect to the encoded sequence of bytes, not the sequence of underlying bytes that would be obtained after decoding.
</p>

<div class="example">
<p>
~byte範囲~指定子の例：
◎
Examples of bytes range specifiers:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte（ 0 〜 499 番の~byte （ 0 番が先頭~byte — 以下同様））：
◎
The first 500 bytes (byte offsets 0-499, inclusive):
</p>

<pre>
bytes=0-499
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte（ 500 〜 999 番の~byte）：
◎
The second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-999
</pre>
	</li>
</ul>
</div>

<p>
`~client$は、`選定される表現$の~sizeを知ることなく，要請される~byte数を制限できる。
［
`last-pos$p 値が無い, または，その値が`表現~data$の現在の長さ以上
］の場合の`~byte範囲$は、`表現$の `first-pos$p 以降の~~部分として解釈される（すなわち，~serverは、 `last-pos$p の値を
( `選定された表現$の現在の長さ − 1 )
に置換する）。
◎
A client can limit the number of bytes requested without knowing the size of the selected representation. If the last-pos value is absent, or if the value is greater than or equal to the current length of the representation data, the byte range is interpreted as the remainder of the representation (i.e., the server replaces the value of last-pos with a value that is one less than the current length of the selected representation).
</p>

<p id="rule.ranges-specifier.suffix">
`suffix-range$p を利用すれば、`~client$は，`選定される表現$の最後の `N^V ~byte（ `N^V ~GT 0 ）を要請できる：
`選定された表現$が，指定された `suffix-length$p より短い場合、`表現$~~全体が利用される。
◎
A client can request the last N bytes (N > 0) of the selected representation using a suffix-range. If the selected representation is shorter than the specified suffix-length, the entire representation is used.
</p>

<div class="example">
<p>
例 — ここでは，表現の長さは 10000 であるものと見做す：
◎
Additional examples, assuming a representation of length 10000:
</p>
<ul>
	<li>
<p>
最後の 500 ~byte（ 9500 〜 9999 番の~byte）：
◎
The final 500 bytes (byte offsets 9500-9999, inclusive):
</p>

<pre>
bytes=-500
</pre>

<p>
または
◎
Or:
</p>

<pre>
bytes=9500-
</pre>

</li>
	<li>
<p>
［
最初, 最後
］の~byteのみ（ 0 番, 9999 番の~byte）：
◎
The first and last bytes only (bytes 0 and 9999):
</p>

<pre>
bytes=0-0,-1
</pre>
【！ Errata ID: 4472 Rejected】

	</li>
	<li>
<p>
［
最初, 真中, 最後
］の 1000 ~byte
◎
The first, middle, and last 1000 bytes:
</p>

<pre>
bytes= 0-999, 4500-5499, -1000
</pre>

	</li>
	<li>
<p>
妥当である（が，正準的でない）， 2 番目の 500 ~byte（ 500 〜 999 番の~byte）の指定：
◎
Other valid (but not canonical) specifications of the second 500 bytes (byte offsets 500-999, inclusive):
</p>

<pre>
bytes=500-600,601-999
bytes=500-700,601-999
</pre>
	</li>
</ul>
</div>

<div class="p">
<p>
`bytes$c における `range-set$p は、妥当かつ［
それを成す ある `range-spec$p は次のいずれかを満たす
］ときに限り，`満足可能$とされる：
</p>
<ul>
	<li>
`int-range$p であって，それを成す `first-pos$p は`表現$の現在の長さ未満である
</li>
	<li>
`suffix-range$p であって，それを成す `suffix-length$p は 0 でない
</li>
</ul>
◎
If a valid bytes range-set includes at least one range-spec with a first-pos that is less than the current length of the representation, or at least one suffix-range with a non-zero suffix-length, then the bytes range-set is satisfiable. Otherwise, the bytes range-set is unsatisfiable.
</div>

<p>
`選定された表現$の長さが 0 の場合、`満足可能$な形をとる `range-spec$p は，上の後者に限られる。
◎
If the selected representation has zero length, the only satisfiable form of range-spec is a suffix-range with a non-zero suffix-length.
</p>

<p>
~byte範囲 構文における［
`first-pos$p,
`last-pos$p,
`suffix-length$p
］は、~octet数を 10 進~数で表出する。
`~payload$の長さには定義済み上限は無いので、`受信者$は，［
~decimal数字列が巨大になり得ることや, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防がなければナラナイ。
◎
In the byte-range syntax, first-pos, last-pos, and suffix-length are expressed as decimal number of octets. Since there is no predefined limit to the length of a payload, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.
</p>

				</section>
				<section id="range.units.other">
<h5 title="Other Range Units">7.1.4.3. 他の範囲~単位</h5>

<p>
他の範囲~単位
— ~p-s-r-r-t, 等々の様な，形式に特有な境界 —
も，~HTTPにおいては応用~特有な目的に利用-可能になり得るが、実施においては，共通して利用されてはいない。
代替な範囲~単位の実装者は、それらが［
内容~符号法, 一般用~中継者
］とどう働くことになるか考慮する~OUGHT。
◎
Other range units, such as format-specific boundaries like pages, sections, records, rows, or time, are potentially usable in HTTP for application-specific purposes, but are not commonly used in practice. Implementors of alternative range units ought to consider how they would work with content codings and general-purpose intermediaries.
</p>

<p>
`範囲~単位$は拡張-可能に意図されている。
新たな`範囲~単位$は、~IANAにて登録される~OUGHT（ `7.1.4.4$sec を見よ）。
◎
Range units are intended to be extensible. New range units ought to be registered with IANA, as defined in Section 7.1.4.4.
</p>

				</section>
				<section id="range.unit.registry">
<h5 title="Range Unit Registry">7.1.4.4. 範囲~単位~registry</h5>

<p>
`~HTTP範囲~単位~registry$cite
にて保守されている~registryは、`範囲~単位$~名のための名前空間を定義し，対応する各~仕様を指す。
◎
The "HTTP Range Unit Registry" defines the namespace for the range unit names and refers to their corresponding specifications. It is maintained at &lt;https://www.iana.org/assignments/http-parameters&gt;.
</p>

<p>
~HTTP範囲~単位の登録は、次に挙げる~fieldを含まなければナラナイ
⇒＃
名前,
説明d,
仕様~textへの~pointer
◎
Registration of an HTTP Range Unit MUST include the following fields:
• Name
• Description
• Pointer to specification text
</p>

<p>
この名前空間に追加されることになる値は、
`IETF による考査$を要する。
◎
Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

				</section>
			</section>
		</section>
		<section id="representation.metadata">
<h3 title="Representation Metadata">7.2. 表現~metadata</h3>

<p>
`表現$についての~metadataを供する~headerは、
`表現~header^dfn
と呼ばれる。
~messageが`~payload本体$を内包するとき、一連の表現~headerは，［
~payload本体~内に同封される`表現~data$
］を解釈する方法を述べる。
`HEAD$m 要請に対する応答においては、一連の表現~headerは，［
その要請が `GET$m であったとするとき，~payload本体~内に同封されることになる表現~data
］について述べる。
◎
Representation header fields provide metadata about the representation. When a message includes a payload body, the representation header fields describe how to interpret the representation data enclosed in the payload body. In a response to a HEAD request, the representation header fields describe the representation data that would have been enclosed in the payload body if the same request had been a GET.
</p>

<p>
次の~headerは、表現~metadataを伝達する
⇒＃
`Content-Type$h,
`Content-Encoding$h,
`Content-Language$h,
`Content-Location$h
◎
The following header fields convey representation metadata:
◎
Table 8
Field Name 	Ref.
Content-Type 	7.2.1
Content-Encoding 	7.2.2
Content-Language 	7.2.3
Content-Length 	7.2.4
Content-Location 	7.2.5
</p>

			<section id="field.content-type">
<h4>7.2.1. `Content-Type^h</h4>

<p>
`Content-Type^h ~headerは、結付けられている`表現$
— ~message意味論に従って決定された，［
`~message~payload$内に同封された表現, または`選定された表現$
］ —
の`~MIME型$を指示する。
指示された~MIME型は、［
`Content-Encoding$h により指示される`内容~符号法$（たち）を復号した結果の~data
］の［
形式, および［
受信者は，それをどう処理するものと意図されているか
］］を，受信された~message意味論の視野の中で定義する。
◎
The "Content-Type" header field indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics. The indicated media type defines both the data format and how that data is intended to be processed by a recipient, within the scope of the received message semantics, after any content codings indicated by Content-Encoding are decoded.
</p>

<pre class="bnf">
`Content-Type@p
    = `media-type$p
</pre>

<div class="example">
<p>
【！ ~MIME型は 6.1.1 にて定義される。】
~headerの例：
◎
Media types are defined in Section 7.1.1. An example of the field is
</p>

<pre class="lang-http">
Content-Type: text/html; charset=ISO-8859-4
</pre>
</div>

<p>
［
`~payload本体$を包含している~message
］を`生成する$`送信者$は、［
自身が，同封された`表現$に意図された`~MIME型$について未知でない
］限り、その~message内に `Content-Type^h ~headerを`生成する$ベキである。
`受信者$は、~message内に `Content-Type^h ~headerが無い場合には，その~MIME型を［
"`application/octet-stream$c" `RFC2046$r であるものと見做す
］か, または
その~dataを精査して決定してもヨイ。
◎
A sender that generates a message containing a payload body SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient MAY either assume a media type of "application/octet-stream" ([RFC2046], Section 4.5.1) or examine the data to determine its type.
</p>

<p>
実施においては、`資源$の所有者は，［
`生成元~server$が［
所与の`表現$用に正しい `Content-Type^h を供する
］ように，常に適正に環境設定されている
］とは限らない。
一部の~UAは、`~payload$の内容を精査して，ある種の事例で，指定された型を上書きする（例えば `Sniffing$r を見よ）。
この “~MIME~sniff法” には、~dataについて不正な結論に至る~riskがあり，追加的な~security~riskに利用者を晒し得る（例： “特権拡大” ）。
更には、~data形式を精査して 送信者が意図する処理~modelを決定するのは，不可能である
— 多くの~data形式は、処理の意味論においてのみ相違するような，複数の`~MIME型$に合致する。
実装者には、そのような~sniff法を不能化する手段を供することが奨励される。
◎
In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine a payload's content and, in certain cases, override the received type (for example, see [Sniffing]). This "MIME sniffing" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., "privilege escalation"). Furthermore, it is impossible to determine the sender's intended processing model by examining the data format: many data formats match multiple media types that differ only in processing semantics. Implementers are encouraged to provide a means to disable such sniffing.
</p>

<p>
更には，
`Content-Type^h は`単数~field$として定義されるが、不正に複数回 `生成され$，その結果 `結合-$された`~field値$が~listのように出現することもある。
受信者は，この~errorを［
~listを成す構文~的に妥当な~memberのうち，最後のものを利用して取扱う
］よう試みることが多いが、一部の実装は異なる挙動で この~errorを取扱うかもしれず，［
相互運用能／~security
］の課題へ導くことに注意。
◎
Furthermore, although Content-Type is defined as a singleton field, it is sometimes incorrectly generated multiple times, resulting in a combined field value that appears to be a list. Recipients often attempt to handle this error by using the last syntactically valid member of the list, but note that some implementations might have different error handling behaviors, leading to interoperability and/or security issues.
</p>

			</section>
			<section id="field.content-encoding">
<h4>7.2.2. `Content-Encoding^h</h4>

<p>
`Content-Encoding^h ~headerは、［
当該の`~MIME型$に内来的なものを超えて，`表現$に適用された`内容~符号法$
］を指示し、従って，［［［
`Content-Type$h ~headerにより参照されている~MIME型
］による~data
］を得するために 適用する必要がある，復号の仕組み
］を指示する。
`Content-Encoding^h は、首に，［
その下層の~MIME型の同一性を損なうことなく，表現の~dataを圧縮できる
］ようにするために利用される。
◎
The "Content-Encoding" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
</p>

<pre class="bnf">
`Content-Encoding@p
    = #`content-coding$p
</pre>

<div class="example">
<p>
その利用~例：
◎
An example of its use is
</p>

<pre class="lang-http">
Content-Encoding: gzip
</pre>
</div>

<p>
`送信者$は、［
`表現$に一つ以上の符号化法を適用する
］ときには，［
各 `内容~符号法$を適用した順序で~listする，
`Content-Encoding^h ~header
］を`生成し$なければナラナイ。
"`identity$c" と命名される符号法は、
`Accept-Encoding$h における特別な役割に予約されており，内包するベキではない。
◎
If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named "identity" is reserved for its special role in Accept-Encoding, and thus SHOULD NOT be included.
</p>

<p>
［
符号化法の各種~parameterについての追加的な情報
］も［
この仕様では定義されない他の~header
］により供され得る。
◎
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h と違って，［
`Content-Encoding^h 内に~listされた符号法
］は、`表現$の特性である
— 表現は、符号化形の用語を通して定義される。
また，表現に関する他のすべての~metadataは、その~metadata定義にて注記されない限り，符号化形に関するものである。
表現が復号されるのは、概して，それを具現化する, またはそれに類する用法の~~直前に限られる。
◎
Unlike Transfer-Encoding (Section 6.1 of [Messaging]), the codings listed in Content-Encoding are a characteristic of the representation; the representation is defined in terms of the coded form, and all other metadata about the representation is about the coded form unless otherwise noted in the metadata definition. Typically, the representation is only decoded just prior to rendering or analogous usage.
</p>

<p>
［
常に圧縮されるような~data形式などの，`~MIME型$が含む内来的な符号化法
］は、それが［
いずれかの`内容~符号法$と たまたま同じ~algoである
］としても、
`Content-Encoding^h 内には再掲されない。
そのような内容~符号法が~listされるのは、`表現$を形成するときに，何らかの奇妙な理由から 二重に適用された場合に限られることになる。
同様に，`生成元~server$は、同じ~dataを［［
符号法が［
`Content-Type$h や `Content-Encoding^h
］の一部として定義されるかどうか
］においてのみ相違するような，複数の表現
］として発行することを選ぶかもしれない
— 一部の~UAは、応答ごとに取扱いを違えるように挙動するので（例： 内容を自動解凍して具現化する代わりに， “保存…” ~dialogを開く）。
◎
If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of Content-Type or Content-Encoding, since some user agents will behave differently in their handling of each response (e.g., open a "Save as ..." dialog instead of automatic decompression and rendering of content).
</p>

<p>
`生成元~server$は、［
要請~message内の`表現$が，受容-可能でない`内容~符号法$を持つ
］ときには， `415$st で応答してもヨイ。
◎
An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.
</p>

			</section>
			<section id="field.content-language">
<h4>7.2.3. `Content-Language^h</h4>

<p>
`Content-Language^h ~headerは、`表現$用に意図される視聴者の自然~言語（たち）を述べる。
これは、［
表現の中で利用される どの言語にも等価にならない
］場合もあることに注意。
◎
The "Content-Language" header field describes the natural language(s) of the intended audience for the representation. Note that this might not be equivalent to all the languages used within the representation.
</p>

<pre class="bnf">
`Content-Language@p
    = #`language-tag$p
</pre>

<p>
【！ 言語~tagは、6.1.3にて定義される。】
`Content-Language^h の首な目的は、利用者が，自身が選好する言語に則って，表現を識別したり相違化できるようにすることである。
◎
Language tags are defined in Section 7.1.3. The primary purpose of Content-Language is to allow a user to identify and differentiate representations according to the users' own preferred language.＼
</p>

<div class="example">
<p>
したがって、~Danish話者~向けのみを意図した内容に適切になる~fieldは：
◎
Thus, if the content is intended only for a Danish-literate audience, the appropriate field is
</p>

<pre class="lang-http">
Content-Language: da
</pre>
</div>

<p>
`Content-Language^h が指定されていない場合、［
内容は，すべての言語の視聴者~向けを意図する
］ことが，既定になる。
これは、送信者が［
内容は どの自然~言語にも特有でないと見なしているか，内容に意図された言語を知らない
］ことを意味するであろう。
◎
If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
</p>

<p>
［
複数の言語の視聴者~向けに意図される内容
］に対しては、複数の言語が~listされてもヨイ。
◎
Multiple languages MAY be listed for content that is intended for multiple audiences.＼
</p>

<div class="example">
<p>
例えば，
“ワイタンギ条約”
を，元の~Maoriと英語~versionで同時に呈示させたければ、次を用いることになろう：
◎
For example, a rendition of the "Treaty of Waitangi", presented simultaneously in the original Maori and English versions, would call for
</p>

<pre class="lang-http">
Content-Language: mi, en
</pre>
</div>

<p>
しかしながら、単に表現の中に 複数の言語が在るだけで，複数種の言語~話者~向けが意図されたことにはならない。
例えば、 “`A First Lesson in Latin^en” のような，英語~話者~向けが明瞭な 初学者~向けの言語~入門書であれば、 `Content-Language^h は "`en^c" のみを内包する方が適正になるであろう。
◎
However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include "en".
</p>

<p>
`Content-Language^h は、どの`~MIME型$に適用されてもヨイ
— ~textな文書のみに制限されない。
◎
Content-Language MAY be applied to any media type — it is not limited to textual documents.
</p>

			</section>
			<section id="field.content-length">
<h4>7.2.4. `Content-Length^h</h4>

<div class="p">
<p>
`Content-Length^h ~headerは、~messageに結付けられた`表現$を成す~dataの長さを，負でない~decimal整数による~octet数として指示する。
`Content-Length^h は：
◎
The "Content-Length" header field indicates the associated representation's data length as a decimal non-negative integer number of octets.＼
</p>
<ul>
	<li>
表現が当の~message内に転送されるときは、
`~message本体$の~frame法を区切るために利用できるよう（例： `Messaging/6.2$sec ），
同封された~dataの量を特定的に指す。
◎
When transferring a representation in a message, Content-Length refers specifically to the amount of data enclosed so that it can be used to delimit framing of the message body (e.g., Section 6.2 of [Messaging]).＼
</li>
	<li>
他の事例では、`選定された表現$の現在の長さを指示する
— `受信者$は、［
転送~時間を見積もる／以前に格納した表現と比較する
］ときに，それを利用できる。
◎
In other cases, Content-Length indicates the selected representation's current length, which can be used by recipients to estimate transfer time or compare to previously stored representations.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Length@p
    = 1*`DIGIT$P
</pre>

<div class="example">
<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Content-Length: 3495
</pre>
</div>

<p class="trans-note">【
構文としては、先頭の 0 も許容されている
— 例えば "`011^c" を数として解釈するときは、
11 と見なすと見受けられる（先頭の 0 の有無に応じて異なる数に解釈するような要件は、この仕様には無い）。
】</p>

<p>
`送信者$は
⇒
`Transfer-Encoding$h ~headerを包含する どの~messageにも，
`Content-Length^h ~headerを送信してはナラナイ。
◎
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
</p>

<div class="p">
<p>
`~UA$は：
◎
↓</p>
<ul>
	<li>
［
`Transfer-Encoding$h を送信しない
］かつ［
同封される`~payload本体$用の意味が，`要請~method$に定義されている
］ときは、要請~message内に `Content-Length^h を送信するベキである。
例えば， `POST$m 要請においては、
`Content-Length^h ~headerは，その値が 0 であっても，通常は送信される（値 0 は`~payload本体$が空であることを指示する）。
◎
A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body. For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body).＼
</li>
	<li>
［
要請~messageが`~payload本体$を包含しない
］かつ［
~method意味論からも そのような本体は見越されない
］ときは、
`Content-Length^h ~headerを送信するベキでない。
◎
A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.
</li>
</ul>
</div>

<p>
`~server$は：
◎
↓</p>
<ul>
	<li>
［
`HEAD$m 要請に対する応答
］内に `Content-Length^h ~headerを送信してもヨイ
— ただし，その際の`~field値$は、［
同じ要請に `GET$m ~methodが利用されたとするときに，応答の`~payload本体$~内に送信することになる~octet数
］に等しい，~decimal~~表現
］にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a response to a HEAD request (Section 8.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.
</li>
	<li>
［
条件付き `GET$m 要請に対する `304$st 応答
］内に `Content-Length^h ~headerを送信してもヨイ
— ただし，その際の`~field値$は、［
同じ要請に対し `200$st 応答を送信したとするときに，応答の`~payload本体$~内に送信することになる~octet数
］に等しい，~decimal~~表現にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 10.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.
</li>
	<li>
次のいずれかに該当する応答~内には，
`Content-Length^h ~headerを送信してはナラナイ
⇒＃
`1xx$st 応答／
`204$st 応答／
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 8.3.6).
</li>
</ul>

<p>
上に定義された各 事例を除き、
`Transfer-Encoding$h が無い下では，
`生成元~server$は［
`~header節$の送信を完了するに先立って，`~payload本体$~sizeが既知である
］ときには，
`Content-Length^h ~headerを送信するベキである。
これにより、`下流$の各`受信者$は，［
転送の進捗を計測する ／
受信される~messageがいつ完了するかを知る ／
追加的な要請~用に接続を後で再利用する
］ことが可能になる。
◎
Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.
</p>

<p>
`Content-Length^h に対する 0 以上のどの`~field値$も，妥当である。
［
`~payload$の長さに対する定義済み制限
］は無いので、`受信者$は，それを構文解析する際に［
~decimal数字列が巨大になり得ることや, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防がなければナラナイ（ `12.5$sec ）。
◎
Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 12.5).
</p>

<div class="p">
<p>
受信した~message内に `Content-Length^h ~headerが在って，［
その`~field値$は、~comma区切りの~list（ `5.5$sec ）として，複数個の同じ~decimal値からなる場合（例： `Content-Length: 42, 42^c ）
］†、`上流$の~message処理器が［
`Content-Length^h ~headerを重複して`生成し$たか, または`結合-$した
］ことを指示している。
そのような場合，`受信者$は、［
`~message本体$の長さを決定する ／ ~messageを回送する
］に先立って，次のいずれかを行わなければナラナイ：
◎
If a message is received that has a Content-Length header field value consisting of the same decimal value as a comma-separated list (Section 5.5) — for example, "Content-Length: 42, 42" — indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either＼
</p>
<ul>
	<li id="invalid-Content-Length">
~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
重複された値たち【！~field値】を［
その~decimal値を包含している， 1 個の妥当な `Content-Length^h ~header
］に置換する。
◎
replace the duplicated field values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.
</li>
</ul>

<p class="trans-note">【†
`Content-Length^h は`~listに基づく~field$ではないが、ここでは受容することも許容されている。
異なる数や妥当でない値が混じっている場合、~HTTP11においては，
<a href="~HTTPmsg#invalid-Content-Length">~message~frame法は妥当でない</a>
とされ，回復-不能な~errorになる。
】【†
同じ数を表現する異なる値（ "`042^c" と "`42^c" など）でも，同様になると思われる。
】</p>
</div>

			</section>
			<section id="field.content-location">
<h4>7.2.5. `Content-Location^h</h4>

<p>
`Content-Location^h ~headerは、［
この~messageの`~payload$内の`表現$に対応する，特定の`資源$
］用の識別子として利用できる`~URI$を参照する。
言い換えれば、この~messageの生成-時に，［
どこかから この~URIに向けて `GET$m 要請が遂行された
］ならば、それに対する `200$st 応答は，［
この~message内の~payloadに同封されるものと同じ表現
］を包含することになるであろう。
◎
The "Content-Location" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload. In other words, if one were to perform a GET request on this URI at the time of this message's generation, then a 200 (OK) response would contain the same representation that is enclosed as payload in this message.
</p>

<pre class="bnf">
`Content-Location@p
    = `absolute-URI$p / `partial-URI$p
</pre>

<p>
`~field値$は、`absolute-URI$p か `partial-URI$p をとる。
後者の事例では、参照先の~URIは，`~target~URI$に相対的になる（ `RFC3986/5$sec ）。
◎
The field value is either an absolute-URI or a partial-URI. In the latter case (Section 2.4), the referenced URI is relative to the target URI ([RFC3986], Section 5).
</p>

<p>
`Content-Location^h 値は、`~target~URI$に代わるものではない。
それは、`表現~metadata$である。
その構文と意味論は、［
~MIME本体 部分~用に定義される同じ名前の~header `RFC2557/4$sec
］と同じである。
しかしながら，~HTTP~messageにおける
`Content-Location^h の出現は、~HTTP受信者にとっては，ある特別な含意がある
—
◎
The Content-Location value is not a replacement for the target URI (Section 6.1). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in Section 4 of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.
</p>

<p>
それが， `2xx$st 応答~message内に内包されているならば、その`~field値$（を`絶対~形$へ変換した後の値）が：
◎
If Content-Location is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form)＼
</p>

<dl class="switch">
	<dt>
`~target~URI$と同じ~URIを指す場合：
◎
to a URI that is the same as the target URI, then＼
</dt>
	<dd>
<p>
`受信者$は、その`~payload$を［
`~messageの出生日時$で指示される時点における，その`資源$の現在の`表現$
］と見なしてもヨイ：
◎
the recipient MAY consider the payload to be a current representation of that resource at the time indicated by the message origination date.＼
</p>
		<ul>
			<li>
［
`GET$m ／ `HEAD$m
］要請に対しては、これは，［
`~server$により `Content-Location^h が供されなかったとき
］の既定の意味論と同じである。
◎
For a GET (Section 8.3.1) or HEAD (Section 8.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server.＼
</li>
			<li>
`PUT$m や `POST$m などの状態変更 要請に対しては、これは，［
`~server$の応答が，その`資源$の新たな`表現$を包含する
］ことを含意する
— それにより，［
動作についてのみを報告し得るような`表現$（例： “~~正常に~~処理されました。” ）
］との違いを判別できる。
これにより、著作~用の応用は、後続の `GET$m 要請を要することなく，その局所的な複製を更新できるようになる。
◎
For a state-changing request like PUT (Section 8.3.4) or POST (Section 8.3.3), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., "It worked!"). This allows authoring applications to update their local copies without the need for a subsequent GET request.
</li>
		</ul>
	</dd>

	<dt>
`~target~URI$と相違する`~URI$を指す場合：
◎
If Content-Location is included in a 2xx (Successful) response message and its field value refers to a URI that differs from the target URI, then＼
</dt>
	<dd>
<p>
`生成元~server$は、［
その~URIが，同封された`表現$に対応する異なる`資源$用の識別子である
］ことを主張している。
そのような主張-を信用できるのは、［
両~識別子が同じ資源~所有者を共有する
］ときに限られる
— それは、~HTTPを介しては~program的には決定できない：
◎
the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.
</p>

<p>
（以下、 `Content-Location^h `~field値$を単に `~field値^V と記す。）
</p>
		<ul>
			<li>
<p>
［
`GET$m ／ `HEAD$m
］要請に対する応答に対しては、これは，次の 2 つを指示する：
</p>
				<ul>
					<li>
`~target~URI$は、`内容~折衝$の~subjectである`資源$を指している。
</li>
					<li>
`~field値^V は、`選定された表現$用の，より特定な識別子である。
</li>
				</ul>

◎
• For a response to a GET or HEAD request, this is an indication that the target URI refers to a resource that is subject to content negotiation and the Content-Location field value is a more specific identifier for the selected representation.
</li>
			<li>
状態変更~methodに対する `201$st 応答に対しては、［
`Location$h `~field値$と一致する `~field値^V
］は，［
この【応答の】`~payload$は，新たに作成された`資源$の現在の`表現$である
］ことを指示する。
◎
• For a 201 (Created) response to a state-changing method, a Content-Location field value that is identical to the Location field value indicates that this payload is a current representation of the newly created resource.
</li>
			<li>
<p>
他の場合【他の応答に対しては？】、そのような `Content-Location^h は，次の 2 つを指示する：
◎
• Otherwise, such a Content-Location indicates that＼
</p>

				<ul>
					<li>
この【応答の】`~payload$は、要請された動作の状態sを報告している`表現$である。
◎
this payload is a representation reporting on the requested action's status and that＼
</li>
					<li>
同じ報告が、 `~field値^V に与えられた`~URI$においても（ `GET$m による未来の~access用に）可用である。
◎
the same report is available (for future access with GET) at the given URI.＼
</li>
				</ul>
<p>
例えば，［
`POST$m 要請を介して~~行われた購入~transaction
］は、［
`200$st 応答の`~payload$
］として，領収書を内包することもある
— このときの `~field値^V は、未来に 同じ領収書の複製を検索取得するための識別子を供する。
◎
For example, a purchase transaction made via a POST request might include a receipt document as the payload of the 200 (OK) response; the Content-Location field value provides an identifier for retrieving a copy of that same receipt in the future.
</p>
			</li>
		</ul>
	</dd>
</dl>

<p>
`Content-Location^h を要請~message内に送信する`~UA$は、その値が［
~UAが（その~UAにより~~行われた改変に先立って，）同封された`表現$の内容を~~元々得した所
］を指していることを言明している。
言い換えれば、~UAは，［
元の表現の~sourceへ戻る~link
］を供している。
◎
A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.
</p>

<div class="p">
<p>
要請~message内に `Content-Location^h ~fieldを受信した`生成元~server$は：
◎
An origin server that receives a Content-Location field in a request message＼
</p>
<ul>
	<li>
その情報を，~~一過性の要請~文脈として扱わなければナラナイ
— `表現$の一部として逐語的に保存されることになる~metadataとしてではなく。
◎
MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation.＼
</li>
	<li>
その文脈を，要請の処理を手引きするために利用したり, 他の利用のために保存してもヨイ
— ~source~linkや~version法~metadataの中など。
◎
An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata.＼
</li>
	<li>
しかしながら、そのような文脈~情報を，その要請の意味論を改めるために利用してはナラナイ。
◎
However, an origin server MUST NOT use such context information to alter the request semantics.
</li>
</ul>
</div>

<p>
例えば、~clientが，折衝された`資源$に対し `PUT$m 要請を為して、生成元~serverが，その `PUT$m を（~redirectionなしに）受容した場合、その資源の新たな状態は，その `PUT$m に給された一つの`表現$と整合するものと期待される。
`Content-Location^h は、［
折衝された表現のうち一つだけを更新する
］ための
“逆-内容~選定~識別子”
の形としては，利用できない
— ~UAがそのような意味論を求めていたなら、
`Content-Location^h の~URIに，直に `PUT$m を適用したであろう。
◎
For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.
</p>

			</section>
		</section>
		<section id="payload">
<h3 title="Payload">7.3. ~payload</h3>

<p>
~HTTP~messageには、`表現$の全部または一部を，~messageの
`~payload^dfn
として転送するものもある。
一部の事例では、~payloadは，［
結付けられている表現の~headerのみ（例： `HEAD$m に対する応答）
］を, あるいは［
`表現~data$の いくつかの部分のみ（例： `206$st ）
］を包含することもある。
◎
Some HTTP messages transfer a complete or partial representation as the message "payload". In some cases, a payload might contain only the associated representation's header fields (e.g., responses to HEAD) or only some part(s) of the representation data (e.g., the 206 (Partial Content) status code).
</p>

<p class="trans-note">【
“~payload” （ “積み荷” ）とは、後述の`~payload本体$と~messageを成す他の部分（~fieldたち）の総称（`表現$を成すもののうち，~message内に実際に伝送される~data）を指すようだ。
】</p>

<p>
結付けられている`表現$ではなく，~payloadについて特定的に述べる~headerを指して、
`~payload~header@
という。
それらは，~messageの構文解析に影響iするので、この仕様の他所にて定義される
⇒＃
`Content-Range$h,
`Trailer$h,
`Transfer-Encoding$h `Messaging$r
◎
Header fields that specifically describe the payload, rather than the associated representation, are referred to as "payload header fields". Payload header fields are defined in other parts of this specification, due to their impact on message parsing.
◎
Table 9
Field Name 	Ref.
Content-Range 	7.3.4
Trailer 	5.6.4
Transfer-Encoding 	Section 6.1 of [Messaging]
</p>

			<section id="payload.purpose">
<h4 title="Purpose">7.3.1. 目的</h4>

<div class="p">
<p>
要請における~payloadの目的は、~method意味論により定義される。
例えば：
◎
The purpose of a payload in a request is defined by the method semantics. For example,＼
</p>
<ul>
	<li>
`PUT$m 要請の~payload内の`表現$は、［
要請が成功裡に適用されたときに，`~target資源$に欲される状態
］を表現する一方で、
◎
a representation in the payload of a PUT request (Section 8.3.4) represents the desired state of the target resource if the request is successfully applied, whereas＼
</li>
	<li>
`POST$m 要請の~payload内の`表現$は、［
`~target資源$により処理されることになる情報
］を表現する。
◎
a representation in the payload of a POST request (Section 8.3.3) represents information to be processed by the target resource.
</li>
</ul>
</div>

<div class="p">
<p>
応答における~payloadの目的は、［
`要請~method$と`応答~状態s~code$
］の両者により定義される。
例えば：
◎
In a response, the payload's purpose is defined by both the request method and the response status code. For example,＼
</p>
<ul>
	<li>
`GET$m に対する `200$st 応答の~payloadは、［
`~messageの出生日時$の時点にて観測される，`~target資源$の現在の状態
］を表現する一方で、
◎
the payload of a 200 (OK) response to GET (Section 8.3.1) represents the current state of the target resource, as observed at the time of the message origination date (Section 11.1.1), whereas＼
</li>
	<li>
`POST$m に対する，同じ `200$st 応答の~payloadは、［
処理の結果
］を, あるいは［
処理を適用した後の，`~target資源$の新たな状態
］を表現することもある。
◎
the payload of the same status code in a response to POST might represent either the processing result or the new state of the target resource after applying the processing.＼
</li>
	<li>
~error状態s~codeを伴う応答~messageが包含する~payloadは、通例的に，［
その~error状態, および
その解決に示唆される次に行う手順
］について述べるような，~error条態を表現する。
◎
Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it.
</li>
</ul>
</div>

			</section>
			<section id="identifying.payload">
<h4 title="Identification">7.3.2. 識別</h4>

<p>
`~message~payload$内に［
完全または部分的な`表現$
］が転送されるときに、［
その表現に対応する`資源$用の識別子
］を［
送信者が給する, または受信者が決定する
］ことが望ましいことはよくある。
◎
When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation.
</p>

<p>
要請~messageに対しては：
◎
For a request message:
</p>
<ul class="switch">
	<li>
要請に `Content-Location$h ~headerが在る場合
⇒
`送信者$は，［
その~payloadが［
`Content-Location$h `~field値$により識別される`資源$
］の`表現$である
］ことを表明している。
しかしながら，そのような表明は、他の手段（この仕様では定義されない）により検証yされない限り，信用できない。
情報は、改訂~履歴~link用には，依然として有用になり得る。
◎
If the request has a Content-Location header field, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification). The information might still be useful for revision history links.
</li>
	<li>
他の場合
⇒
~payloadは識別されない。
◎
Otherwise, the payload is unidentified.
</li>
</ul>

<p>
応答~messageに対しては：
◎
For a response message, the following rules are applied in order until a match is found:
</p>
<ul class="switch">
	<li>
<p>
`要請~method$が［
`GET$m ／ `HEAD$m
］である場合、応答の`状態s~code$に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`200$st</dt>
			<dt>`204$st</dt>
			<dt>`206$st</dt>
			<dt>`304$st</dt>
			<dd>
~payloadは、［
`~target~URI$により識別される`資源$
］の`表現$である。
◎
If the request method is GET or HEAD and the response status code is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not Modified), the payload is a representation of the resource identified by the target URI (Section 6.5).
</dd>
			<dt>`203$st</dt>
			<dd>
~payloadは、［
`中継者$により改変されたか増強されて
］供された~~可能性もある，`~target資源$の`表現$である。
◎
If the request method is GET or HEAD and the response status code is 203 (Non-Authoritative Information), the payload is a potentially modified or enhanced representation of the target resource as provided by an intermediary.
</dd>
			<dt>その他</dt>
			<dd>
後続の規則への合致を試みる。
◎
↑↑</dd>
		</dl>
	</li>
	<li>
<p>
他の場合，応答に `Content-Location$h ~headerが在るならば、その`~field値$が，`~target~URI$と：
◎
↓</p>
		<ul class="switch">
			<li>
同じ~URIへの参照である場合
⇒
~payloadは、`~target資源$の`表現$である。
◎
If the response has a Content-Location header field and its field value is a reference to the same URI as the target URI, the payload is a representation of the target resource.
</li>
			<li>
<p>
異なる~URIへの参照である場合
⇒
`送信者$は、［
~payloadは，その`~field値$により識別される資源の`表現$である
］ことを表明している。
しかしながら，そのような表明は、他の手段（この仕様では定義されない）により検証yされない限り，信用できない。
◎
If the response has a Content-Location header field and its field value is a reference to a URI different from the target URI, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field value. However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification).
</p>

<p class="trans-note">【
~field値が妥当な~URI参照でない場合も，この場合に含まれるかどうかは、はっきりしない
— 下の “他の場合” と見做すか，~errorの取扱い（ `3.4$sec ）に従うことも考えられる。
】</p>
			</li>
		</ul>
	</li>
	<li>
他の場合
⇒
~payloadは、識別されない。
◎
Otherwise, the payload is unidentified.
</li>
</ul>

			</section>
			<section id="payload.body">
<h4 title="Payload Body">7.3.3. ~payload本体</h4>

<p>
~payload本体は［
要請／応答
］の~dataを包含する。
~payload本体は、~message本体（例： `Messaging/6$sec のそれ）とは別物である
—
`~message本体@
は，~payload本体が転送されるとき “伝送路~上” に現れるものであり、利用-中の~HTTP~versionに依存して，符号化されているかもしれない。
◎
The payload body contains the data of a request or response. This is distinct from the message body (e.g., Section 6 of [Messaging]), which is how the payload body is transferred "on the wire", and might be encoded, depending on the HTTP version in use.
</p>

<p class="trans-note">【
~payload本体は、
“`entity body^en（実体~本体）”
と称されることもある（特に， `RFC2616$r 世代の~RFCなどの過去の仕様）。
】</p>

<p>
~payload本体はまた、［
要請／応答
］の`表現~data$とは別物である
— `表現~data$は、 “伝送路~上” に出現するとは限らず，~protocolの運用から推定され得る。
◎
It is also distinct from a request or response's representation data (Section 7.1), which can be inferred from protocol operation, rather than necessarily appearing "on the wire."
</p>

<p>
~payload本体の有無は：
◎
↓</p>
<ul>
	<li>
要請においては、［
利用される要請~methodが，それ用の意味論を定義するかどうか
］に依存する。
◎
The presence of a payload body in a request depends on whether the request method used defines semantics for it.
</li>
	<li>
応答においては、［
それが応答している要請~method, 当の応答の`状態s~code$
］の両者に依存する。
◎
The presence of a payload body in a response depends on both the request method to which it is responding and the response status code (Section 10).
</li>
</ul>

<p>
特に：
◎
↓</p>
<ul>
	<li>
`HEAD$m 要請~methodに対する応答は、~payload本体を決して内包しない
— 何故なら、応答~headerたちが結付けられているとしても，それらは［
要請~methodが `GET$m であったとするときにとる値
］のみを指示するとされているので。
◎
Responses to the HEAD request method (Section 8.3.2) never include a payload body because the associated response header fields indicate only what their values would have been if the request method had been GET (Section 8.3.1).
</li>
	<li>
`CONNECT$m 要請~methodに対する `2xx$st 応答は、~payload本体を持たない代わりに，接続を`~tunnel$~modeに切替える。
◎
2xx (Successful) responses to a CONNECT request method (Section 8.3.6) switch the connection to tunnel mode instead of having a payload body.
</li>
	<li>
すべての［
`1xx$st／`204$st／`304$st 
］応答は、~payload本体を内包しない。
◎
All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a payload body.
</li>
	<li>
他のすべての応答は、~payload本体を~~実際に内包する
— 長さ 0 にもなり得るが。
◎
All other responses do include a payload body, although that body might be of zero length.
</li>
</ul>

			</section>
			<section id="field.content-range">
<h3 title="Content-Range">7.3.4. `Content-Range^h</h3>

<div class="p">
<p>
`Content-Range^h ~headerは、次を
指示する／供する
ために送信される：
◎
The "Content-Range" header field is＼
</p>
<ul>
	<li>
単独の部位tによる `206$st 応答において
⇒
その`~message~payload$として同封された［
`選定された表現$の部分的な範囲
］を指示する。
◎
sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message payload,＼
</li>
	<li>
`複部位$ `206$st 応答の各~部位tにおいて
⇒
各~本体~部位t内に同封された範囲を指示する。
◎
sent in each part of a multipart 206 response to indicate the range enclosed within each body part, and＼
</li>
	<li>
`416$st 応答において
⇒
`選定された表現$についての情報を供する。
◎
sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.
</li>
</ul>
</div>

<pre class="bnf">
`Content-Range@p
    = `range-unit$p `SP$P ( `range-resp$p / `unsatisfied-range$p )

`range-resp@p
    = `incl-range$p "/" ( `complete-length$p / "*" )
`incl-range@p
    = `first-pos$p "-" `last-pos$p
`unsatisfied-range@p
    = "*/" `complete-length$p

`complete-length@p
    = 1*`DIGIT$P
</pre>

<p>
`受信者$は、［
自身が解さない`範囲~単位$を伴う `Content-Range$h ~header
］を包含する`206$st 応答に対しては，それを格納-済み表現と結合し直そうと試みてはナラナイ。
その種の~messageを受信した`~proxy$は、それを`下流$へ回送するベキである。
◎
If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 7.1.4) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation. A proxy that receives such a message SHOULD forward it downstream.
</p>

<p>
`~byte範囲$に対しては、`送信者$は，［
抽出された範囲の表現
］の完全な長さを指示するベキである
— ［
その長さが未知, または それを決定するのが困難
］であるのでない限り。
`range-resp$p における，
`complete-length$p に代わる ~asterisk （ "`*^c" ）は、~headerが生成されたときに，表現の長さが未知であったことを指示する。
◎
For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character ("*") in place of the complete-length indicates that the representation length was unknown when the header field was generated.
</p>

<div class="example">
<p>
`送信者$が，［
`選定される表現$の完全な長さが 1234 ~byteである
］と既知であるときの例：
◎
The following example illustrates when the complete length of the selected representation is known by the sender to be 1234 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/1234
</pre>

<p>
完全な長さが未知であるときの例：
◎
and this second example illustrates when the complete length is unknown:
</p>

<pre class="lang-http">
Content-Range: bytes 42-1233/*
</pre>
</div>

<p>
［［
( `last-pos$p 値 ~LT `first-pos$p 値 ), または
( `complete-length$p 値 ~LTE `last-pos$p 値 )
］であるような `range-resp$p
］を包含するような `Content-Range$h `~field値$は、妥当でない。
妥当でない `Content-Range$h の`受信者$は、受信した内容と格納-済みな表現を結合し直そうと試みてはナラナイ。
◎
A Content-Range field value is invalid if it contains a range-resp that has a last-pos value less than its first-pos value, or a complete-length value less than or equal to its last-pos value. The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.
</p>

<p>
`~server$は、`~byte範囲$の要請に対する `416$st 応答を`生成する$ときには，［
`unsatisfied-range$p 値を伴う `Content-Range$h ~header
］を送信するベキである
— 次の例のように：
◎
A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:
</p>

<div class="example">
<pre class="lang-http">
Content-Range: bytes */1234
</pre>
</div>

<p>
`416$st 応答~内の `complete-length$p は、`選定された表現$の現在の長さを指示する。
◎
The complete-length in a 416 response indicates the current length of the selected representation.
</p>

<p>
`Content-Range$h ~headerは、その意味論を明示的に述べない`状態s~code$に対しては，意味を持たない。
この仕様においては、`状態s~code$
`206$st, `416$st 
のみが `Content-Range$h に対する意味を述べる。
◎
The Content-Range header field has no meaning for status codes that do not explicitly describe its semantic. For this specification, only the 206 (Partial Content) and 416 (Range Not Satisfiable) status codes describe a meaning for Content-Range.
</p>

<div class="example">
<p>
`選定された表現$が総計 1234 ~byteを包含するときの， `Content-Range$h 値の例：
◎
The following are examples of Content-Range values in which the selected representation contains a total of 1234 bytes:
</p>
<ul>
	<li>
<p>
最初の 500 ~byte:
◎
The first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 0-499/1234
</pre>
	</li>
	<li>
<p>
2 番目の 500 ~byte：
◎
The second 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-999/1234
</pre>
	</li>
	<li>
<p>
最初の 500 ~byteを除くすべて：
◎
All except for the first 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 500-1233/1234
</pre>
	</li>
	<li>
<p>
最後の 500 ~byte：
◎
The last 500 bytes:
</p>

<pre class="lang-http">
Content-Range: bytes 734-1233/1234
</pre>
	</li>
</ul>
</div>

			</section>
			<section id="multipart.byteranges">
<h4 title="Media Type multipart/byteranges">7.3.5. ~MIME型 "`multipart/byteranges^c"</h4>

<p>
`206$st 応答~messageが，複数の範囲からなる内容を内包するとき、それらの内容は，~MIME型
"`multipart/byteranges^c"
による
`複部位@
`~message本体$の中に，いくつかの本体~部位tとして伝送される（ `RFC2046/5.1$sec ）。
◎
When a 206 (Partial Content) response message includes the content of multiple ranges, they are transmitted as body parts in a multipart message body ([RFC2046], Section 5.1) with the media type of "multipart/byteranges".
</p>
<p>
"`multipart/byteranges$c" ~MIME型は、それぞれが自前の［
`Content-Type$h, `Content-Range$h
］~fieldを伴う， 1 個~以上の本体~部位tを内包する。
要求される境界~parameter（ `boundary parameter^en ）は、各~本体~部位tを分離するために利用される境界~文字列（ `boundary string^en ）を指定する。
◎
The multipart/byteranges media type includes one or more body parts, each with its own Content-Type and Content-Range fields. The required boundary parameter specifies the boundary string used to separate each body part.
</p>

<p>
実装~上の注記：
◎
Implementation Notes:
</p>
<ul>
	<li>
余分な `CRLF$P が本体~内の最初の境界~文字列に先行するかもしれない。
◎
Additional CRLFs might precede the first boundary string in the body.
</li>
	<li>
<p>
`RFC2046$r は，境界~文字列（ `boundary string^en †）を引用符で括ることも許可しているが、一部の既存の実装は，そのようにされた境界~文字列を不正に取扱う。
◎
Although [RFC2046] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
</p>

<p class="trans-note">【†
`RFC2046$r では “`boundary delimiter^en” と称されている。
下の例では `THIS_STRING_SEPARATES^c がそれに該当する。
】</p>
	</li>
	<li>
いくつもの［
~client／~server
］が， byteranges 仕様の早期の草案に合わせて~codeされており，
その~MIME型に `multipart/x-byteranges^c を利用していた
— それは、この型にほぼ互換である（が，~~完全にではない）。
◎
A number of clients and servers were coded to an early draft of the byteranges specification that used a media type of multipart/x-byteranges, which is almost (but not quite) compatible with this type.
</li>
</ul>

<p>
その名前にかかわらず、
"`multipart/byteranges$c" ~MIME型は，`~byte範囲$に制限されない。
◎
Despite the name, the "multipart/byteranges" media type is not limited to byte ranges.＼
</p>

<div class="example">
<p>
次の例は、 "`exampleunit^c" `範囲~単位$を利用する：
◎
The following example uses an "exampleunit" range unit:
</p>

<pre class="lang-http">
HTTP/1.1 206 Partial Content
Date: Tue, 14 Nov 1995 06:25:24 GMT
Last-Modified: Tue, 14 July 04:58:08 GMT
Content-Length: 2331785
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 1.2-4.3/25

...the first range...
--THIS_STRING_SEPARATES
Content-Type: video/example
Content-Range: exampleunit 11.2-14.3/25

...the second range
--THIS_STRING_SEPARATES--
</pre>
</div>

<p>
次の情報が、
`multipart/byteranges$c ~MIME型~用の登録~形として~serveする。
◎
The following information serves as the registration form for the multipart/byteranges media type.
</p>

<div>

<dl>
<dt>型~名
<dd>`multipart^c

<dt>下位型~名
<dd>`byteranges^c

<dt>要求される~parameter
<dd>`boundary^c

<dt>省略可能な~parameter
<dd>N/A

<dt>符号化法に対する考慮点
<dd>"`7bit^c", "`8bit^c", "`binary^c" のみ許可される

<dt>~securityの考慮点
<dd>`12$sec を見よ

<dt>相互運用能の考慮点
<dd>N/A

<dt>発行した仕様
<dd>この仕様（ `multipart/byteranges$c を見よ）

<dt>この~MIME型を利用する応用
<dd>単独の要請~内に複数の範囲を~supportする， HTTP ~component

<dt>`素片~識別子$に対する考慮点
<dd>N/A

<dt>追加的な情報
<dd>
	<dl>
	<dt>Deprecated alias names for this type:
	<dt>Magic number(s):
	<dt>File extension(s):
	<dt>Macintosh file type code(s):
	<dd>N/A
	</dl>

<dt>Person and email address to contact for further information:
<dd>`著作者の~address$に。

<dt>意図される用法
<dd>COMMON

<dt>用法~上の制約
<dd>N/A

<dt>著作者
<dd>`著作者の~address$に。

<dt>変更管理者
<dd>IESG
</dl>

◎
Type name:
• multipart
Subtype name:
• byteranges
Required parameters:
• boundary
Optional parameters:
• N/A
Encoding considerations:
• only "7bit", "8bit", or "binary" are permitted
Security considerations:
• see Section 12
Interoperability considerations:
• N/A
Published specification:
• This specification (see Section 7.3.5). 
Applications that use this media type:
• HTTP components supporting multiple ranges in a single request.
Fragment identifier considerations:
• N/A
Additional information:
• Deprecated alias names for this type:
•• N/A
• Magic number(s):
•• N/A
• File extension(s):
•• N/A
• Macintosh file type code(s):
•• N/A

Person and email address to contact for further information:
• See Authors' Addresses section.
Intended usage:
• COMMON
Restrictions on usage:
• N/A
Author:
• See Authors' Addresses section.
Change controller:
• IESG
</div>

			</section>
		</section>
		<section id="content.negotiation">
<h3 title="Content Negotiation">7.4. 内容の折衝</h3>

<p>
`生成元~server$は、応答にて伝達する~payload情報を表現するときに
— その情報が成功か~errorのいずれを指示するにしても —
いくつか異なる仕方を備えていることが多い
— 例えば，異なる［
形式／言語／符号化法
］で。
また，利用者／~UA ごとに［
能力, 特性, 選好
］も異なり得るので、［
可用な`表現$のうち，どれを送達するのが最良になるか
］も変わり得る。
この理由から、~HTTPは，`内容~折衝$用の仕組みをいくつか供する。
◎
When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings. Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver. For this reason, HTTP provides mechanisms for content negotiation.
</p>

<div class="p">
<p>
この仕様は、~protocolの中で可視にされ得るような，次の 3 種の~patternによる
`内容~折衝^dfn
を定義する：
◎
This specification defines three patterns of content negotiation that can be made visible within the protocol:＼
</p>
<ul>
	<li>
`~proactive折衝$
⇒
`~server$が、`~UA$が言明した選好に基づいて，`表現$を選定する。
◎
"proactive" negotiation, where the server selects the representation based upon the user agent's stated preferences,＼
</li>
	<li>
`~reactive折衝$
⇒
`~server$が、`~UA$向けに選んでもらう`表現$の~listを供する。
◎
"reactive" negotiation, where the server provides a list of representations for the user agent to choose from, and＼
</li>
	<li>
`要請~payload折衝$
⇒
`~UA$が、`~server$が過去の応答~内で言明した選好に基づいて，未来の要請~用の表現を選定する。
◎
"request payload" negotiation, where the user agent selects the representation for a future request based upon the server's stated preferences in past responses.＼
</li>
</ul>

<p>
他の~patternによる`内容~折衝$には、次のものが含まれる：
◎
Other patterns of content negotiation include＼
</p>
<ul>
	<li>
条件付き内容
⇒
`表現$は複数個の部分からなっていて、各部分は、~UAの各種~parameterに基づいて，選択的に具現化される。
◎
"conditional content", where the representation consists of multiple parts that are selectively rendered based on user agent parameters,＼
</li>
	<li>
作動中の内容
⇒
`表現$は~scriptを包含していて、それが、~UAの特性に基づいて，追加的な（より特定な）要請を為す。
◎
"active content", where the representation contains a script that makes additional (more specific) requests based on the user agent characteristics, and＼
</li>
	<li>
透過的な内容~折衝（ `Transparent Content Negotiation^en `RFC2295$r ）
⇒
`中継者$が、内容の選定を遂行する。
◎
"Transparent Content Negotiation" ([RFC2295]), where content selection is performed by an intermediary.＼
</li>
</ul>

<p>
これらの~patternは、排他的ではない
— それぞれ、適用能と実用性の引換関係にある。
◎
These patterns are not mutually exclusive, and each has trade-offs in applicability and practicality.
</p>
</div>

<p>
すべての事例において、~HTTPは，`資源$の意味論を自覚しないことに注意。
［
要請に対し応答する生成元~serverの［
時経過, および`内容~折衝$の様々な次元
］にわたる一貫性、したがって［
時経過にわたり資源に観測される，`表現$の “同じさ度合い”
］は、全面的に，［
それらの応答を選定したり, 生成する，実体／~algo
］により決定される。
◎
Note that, in all cases, HTTP is not aware of the resource semantics. The consistency with which an origin server responds to requests, over time and over the varying dimensions of content negotiation, and thus the "sameness" of a resource's observed representations over time, is determined entirely by whatever entity or algorithm selects or generates those responses.
</p>

			<section id="proactive.negotiation">
<h4 title="Proactive Negotiation">7.4.1. ~proactive折衝</h4>

<div class="p">
<p>
`~UA$により，要請~内に［
`~server$に所在する~algoに，選好される`表現$を選定するよう促す選好
］が送信されるような`内容~折衝$は、
`~proactive折衝^dfn
と呼ばれる（ “~server駆動な折衝” とも呼ばれる）。
この選定は、次の 2 つの比較対照に基づく：
◎
When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation). Selection is based on＼
</p>
<ul>
	<li>
応答に可用な`表現$（選好の次元は、言語, `内容~符号法$, 等々，多様になり得る）。
◎
the available representations for a response (the dimensions over which it might vary, such as language, content-coding, etc.) compared to＼
</li>
	<li>
要請~内に給される様々な情報。
これには、明示的な折衝~field（ `9.4$sec ）や，暗黙的な特性
— ~clientの~network~address, `User-Agent$h ~fieldの各部など —
も含まれる。
◎
various information supplied in the request, including both the explicit negotiation fields of Section 9.4 and implicit characteristics, such as the client's network address or parts of the User-Agent field.
</li>
</ul>
</div>

<div class="p">
<p>
~proactive折衝は、次のときに有利になる：
◎
Proactive negotiation is advantageous when＼
</p>
<ul>
	<li>
［
可用な`表現$の中から一つを選定するための~algo
］を，~UAに向けて述べるのが困難であるとき。
◎
the algorithm for selecting from among the available representations is difficult to describe to a user agent, or＼
</li>
	<li>
`~server$が，最初の応答に［
~UAにとって “最良と推測される” もの
］を送信することを欲するとき（利用者にとり，その推測で十分良いときに、後続の要請の往来による遅延を避けることを期待して）。
◎
when the server desires to send its "best guess" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the "best guess" is good enough for the user).＼
</li>
</ul>

<p>
`~UA$は、`~server$による推測を改善させるために，［
自身の選好を述べる`要請~header$
］を送信してもヨイ。
◎
In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.
</p>
</div>

<p>
~proactive折衝には、深刻な不利がある：
◎
Proactive negotiation has serious disadvantages:
</p>
<ul>
	<li>
`~server$にとっては、［
任意の利用者にとって，何が “最良” になるか
］を正確aに決定することは，不可能である
— そのためには、［
~UAに備わる能力,
応答に対し意図される利用（例： 利用者が求めているのは、~screen上で視る, 紙に印刷する のどっちか？）
］の両者について，完全な知識を要求することになるので。
◎
It is impossible for the server to accurately determine what might be "best" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?);
</li>
	<li>
~UAが 毎~要請ごとに，自身に備わる能力を述べるとするなら、とても非効率になり得る（ごく小さな割合の応答のみが複数個の`表現$を持つ下では）。
更に、利用者の~privacyに対する~riskも高める。
◎
Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy;
</li>
	<li>
［
`生成元~server$,
要請に対する応答を生成する~algo
］の実装が複雑化する。
◎
It complicates the implementation of an origin server and the algorithms for generating responses to a request; and,
</li>
	<li>
共用~cachingにおける応答の再利用-能が，制限される。
◎
It limits the reusability of responses for shared caching.
</li>
</ul>

<p>
`~UA$は、［
~proactive折衝による選好が一貫して尊守される
］ことに依拠できない
— `生成元~server$は、要請された`資源$用には ~proactive折衝を実装していなかったり，［
~UAの選好に適合しない応答を送信する方が， `406$st 応答を送信するより良い
］と裁定することもあるので。
◎
A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a 406 (Not Acceptable) response.
</p>

<p>
`Vary$h ~headerは、［
要請のどの部分の情報が，選定~algoに利用されるか
］を指示するために，［
~proactive折衝を~subjectとする応答
］内に送信されることが多い。
◎
A Vary header field (Section 11.1.4) is often sent in a response subject to proactive negotiation to indicate what parts of the request information were used in the selection algorithm.
</p>

			</section>
			<section id="reactive.negotiation">
<h4 title="Reactive Negotiation">7.4.2. ~reactive折衝</h4>

<div class="p">
<p>
`~reactive折衝^dfn
【“~~受け身の” 折衝】
においては、`表現$の選定は，~UAにより遂行される（ “~agent駆動な折衝” とも呼ばれる）。
すなわち，`~UA$は：
◎
With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent＼
</p>
<ol>
	<li>
`生成元~server$から［
代替~表現~用の`資源$の~listを包含する，初期~応答
］を受信した後に，（その`状態s~code$に関わらず）最良な応答~表現を選定する。
◎
after receiving an initial response from the origin server that contains a list of resources for alternative representations.＼
</li>
	<li>
初期~応答の表現で満足されない場合には、［
その応答~用の，異なる形による表現
］を得するために，［
~list内に内包された~metadataに基づいて選定される，一つ以上の代替~資源
］へ向けて， `GET$m 要請を遂行できる。
◎
If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response.＼
</li>
</ol>

<p>
代替の選定は、~UAにより自動的に遂行されることもあれば、利用者が，生成された（場合によっては~hypertextによる）~menuから手動で選定することもある。
◎
Selection of alternatives might be performed automatically by the user agent or manually by the user selecting from a generated (possibly hypertext) menu.
</p>
</div>

<div class="p">
<p>
上における表現は、一般には，応答の表現を指すことに注意
— `資源$の表現ではなく。
代替~表現は、［
それを供した応答が，次のいずれかの意味論を持つ
］場合に限り，`~target資源$の表現であると見なされる：
◎
Note that the above refers to representations of the response, in general, not representations of the resource. The alternative representations are only considered representations of the target resource if the response in which those alternatives are provided＼
</p>
<ul>
	<li>
~target資源の`表現$である（例： `GET$m 要請に対する `200$st 応答）
◎
has the semantics of being a representation of the target resource (e.g., a 200 (OK) response to a GET request) or＼
</li>
	<li>
~target資源~用の代替~表現への~linkを供する（例： `GET$m 要請に対する `300$st 応答）
◎
has the semantics of providing links to alternative representations for the target resource (e.g., a 300 (Multiple Choices) response to a GET request).
</li>
</ul>
</div>

<p>
`~server$は、［
代替~list以外の初期~表現を送信しないことを選ぶことにより，`~UA$による~reactive折衝を選好することを指示する
］こともある。
例えば，［
`300$st ／ `406$st を伴う応答
］内に~listされる代替は、［
利用者または~UAが~reactiveに選定を行い得るような，可用な`表現$
］についての情報を内包する。
◎
A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred. For example, the alternatives listed in responses with the 300 (Multiple Choices) and 406 (Not Acceptable) status codes include information about the available representations so that the user or user agent can react by making a selection.
</p>

<div class="p">
<p>
~reactive折衝は、次のときに有利になる：
◎
Reactive negotiation is advantageous＼
</p>
<ul>
	<li>
応答が、共通的に利用される次元（型【`~MIME型$】, 言語, 符号化法 など）にわたって，様々になり得るとき。
◎
when the response would vary over commonly used dimensions (such as type, language, or encoding),＼
</li>
	<li>
生成元~serverが、要請を精査しても，~UAに備わる能力を決定できないとき。
◎
when the origin server is unable to determine a user agent's capabilities from examining the request, and＼
</li>
	<li>
一般に、~server負荷を分散したり~network利用eを抑制するために，公共~cacheが利用されるとき。
◎
generally when public caches are used to distribute server load and reduce network usage.
</li>
</ul>
</div>

<p>
~reactive折衝には、代替~listを~UAへ伝送する~~手間を要する不利がある
— それは、［
~listを`~header節$~内に伝送し，代替-表現を得するために 2 度目の要請を要する
］場合に，利用者に知覚される待時間を~~増やす。
更には、この仕様は，自動~選定を~supportする仕組みは定義しない
— そのような仕組みを拡張として開発することも~~止めないが。
◎
Reactive negotiation suffers from the disadvantages of transmitting a list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation. Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension.
</p>

			</section>
			<section id="request.payload.negotiation">
<h4 title="Request Payload Negotiation">7.4.3. 要請~payload折衝</h4>

<p>
`~server$が応答~内に`内容~折衝$の選好を送信するとき、~listされた選好たちは，
`要請~payload折衝^dfn
と呼ばれる
— それらは、［
当の資源に対する後続の要請~用の~payloadとして適切なもの
］の選定に波及することが意図されるので。
例えば，
`Accept-Encoding$h ~fieldは、当の資源に対する後続の要請~用に選好される`内容~符号法$を指示するため，応答~内に送信され得る
`RFC7694$r
。
◎
When content negotiation preferences are sent in a server's response, the listed preferences are called request payload negotiation because they intend to influence selection of an appropriate payload for subsequent requests to that resource. For example, the Accept-Encoding field (Section 9.4.3) can be sent in a response to indicate preferred content codings for subsequent requests to that resource [RFC7694].
</p>

<aside>
<p class="note">
同様に， `RFC5789$r は、
`Accept-Patch$h 応答~headerを定義する
— それは、［
`PATCH$m 要請~内で受容される内容~型
］の発見を許容する。
◎
Similarly, Section 3.1 of [RFC5789] defines the "Accept-Patch" response header field which allows discovery of which content types are accepted in PATCH requests.
</p>
</aside>
			</section>
			<section id="quality.values">
<h4 title="Quality Values">7.4.4. 品質~値</h4>

<p>
この仕様が定義する内容~折衝~用の`~field$は、［
相対的な選好の “重み” を，結付けられる内容の種類にアテガう
］ために，［
`q$c と命名される（文字大小無視な）共通な~parameter
］を利用する。
この重みは、同じ~parameter名が，~server環境設定の中で［
資源~用に選定され得る様々な`表現$の，相対的な品質の重み
］をアテガうために 利用されることが多いため、
`品質~値^dfn
（ あるいは “`qvalue^en” ）と呼ばれる。
◎
The content negotiation fields defined by this specification use a common parameter, named "q" (case-insensitive), to assign a relative "weight" to the preference for that associated kind of content. This weight is referred to as a "quality value" (or "qvalue") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource.
</p>

<p>
重みは、範囲 0 〜 1 の実数に正規化される
— ここで，［
値 0.001 は最も選好されず，
値 1 は最も選好され，
値 0 は “受容-可能でない”
］ことを意味する。
`q$c ~parameterが無い場合の
`既定の重み@
は 1 とする。
◎
The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means "not acceptable". If no "q" parameter is present, the default weight is 1.
</p>

<pre class="bnf">
`weight@p
    = `OWS$p ";" `OWS$p "`q@c=" `qvalue$p
`qvalue@p
    = ( "0" [ "." 0*3DIGIT ] )
    / ( "1" [ "." 0*3("0") ] )
</pre>

<p>
`送信者$が，小数点の後に`生成する$品質値の桁~数は、 3 以下でなければナラナイ。
これらの値による利用者~環境設定も，同じやり方で制限される~OUGHT。
◎
A sender of qvalue MUST NOT generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.
</p>

			</section>
		</section>
	</section>
	<section id="methods">
<h2 title="Request Methods">8. 要請~method</h2>

【この節は、<a href="~HTTPrq#methods">別~pageにて</a>。】

	</section>
	<section id="request.header.fields">
<h2 title="Request Header Fields">9. 要請~header</h2>
【この節は、<a href="~HTTPrq#request.header.fields">別~pageにて</a>。】

	</section>
	<section id="status.codes">
<h2 title="Response Status Codes">10. 応答~状態s~code</h2>

【この節は、<a href="~HTTPrs#status.codes">別~pageにて</a>。】

	</section>
	<section id="response.header.fields">
<h2 title="Response Header Fields">11. 応答~header</h2>

【この節は、<a href="~HTTPrs#response.header.fields">別~pageにて</a>。】

	</section>
	<section id="security.considerations">
<h2 title="Security Considerations">12. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］向けに，~HTTP意味論, および［
~Internet越しに情報を転送するための，その利用
］に関連な，既知な~securityの懸念を伝えることを~~意図している。
［
~message構文／構文解析／~route法
］に関係する考慮点は、
`Messaging/11$sec
にて論じられる。
◎
This section is meant to inform developers, information providers, and users of known security concerns relevant to HTTP semantics and its use for transferring information over the Internet. Considerations related to message syntax, parsing, and routing are discussed in Section 11 of [Messaging].
</p>

<div class="p">
<p>
この節に挙げる考慮点は、網羅的ではない。
~HTTP意味論に関係する~securityの懸念のほとんどは、~protocolの~securityではなく，次についてである：
◎
The list of considerations below is not exhaustive. Most security concerns related to HTTP semantics are about＼
</p>
<ul>
	<li>
~server側~応用（~HTTP~interfaceの背後にある~code）の~secure化。
◎
securing server-side applications (code behind the HTTP interface),＼
</li>
	<li>
~HTTPを介して受信される~payloadに対する，~UAによる処理の~secure化。
◎
securing user agent processing of payloads received via HTTP, or＼
</li>
	<li>
一般における~Internetの~secureな利用。
◎
secure use of the Internet in general,＼
</li>
</ul>

<p>
様々な組織が、~Web応用における~securityの［
時事的な情報, および 現在の事実調査への~link
］を保守している。
（例： `OWASP$r）。
◎
rather than security of the protocol. Various organizations maintain topical information and links to current research on Web application security (e.g., [OWASP]).
</p>
</div>

		<section id="establishing.authority">
<h3 title="Establishing Authority">12.1. 権限の確立-法</h3>

<p>
~HTTPは、
`権限的な応答@
の観念に依拠する。
それは、［
応答~messageの出生時における`~target資源$の状態
］が与えられた下で
— 要請に対する，最も適切な応答になるように —
［
`~target~URI$の中で識別される`生成元~server$
］により決定される（または, ~directされる）応答である。
◎
HTTP relies on the notion of an authoritative response: a response that has been determined by (or at the direction of) the origin server identified within the target URI to be the most appropriate response for that request given the state of the target resource at the time of response message origination.
</p>

<p>
ある登録-済みな名前が `authority$p 成分~内に利用されるとき、
"`http$c" ~URI`~scheme$は，［
`権限的な応答$がどこで見出せるかを決定する
］ときに［
利用者に局所的な名前~解決~service
］に依拠する。
これは、利用者の［
~network~host~table／
~cacheされている名前／
名前~解決~library
］に対するどの攻撃も，
"`http$c" ~URI用に権限を確立する際の攻撃に繋がることを意味する。
同様に，［
利用者が~DNS（ `Domain Name Service^en ）用に選んだ~server
］, および［
解決の結果を得するときに用いた，~server階層
］は、［
~address対応付けの真正性
］に影響iし得る
— 真正性を改善する仕方の一つには、 DNSSEC（ `DNS Security Extensions^en, `RFC4033$r ）がある。
◎
When a registered name is used in the authority component, the "http" URI scheme (Section 2.5.1) relies on the user's local name resolution service to determine where it can find authoritative responses. This means that any attack on a user's network host table, cached names, or name resolution libraries becomes an avenue for attack on establishing authority for "http" URIs. Likewise, the user's choice of server for Domain Name Service (DNS), and the hierarchy of servers from which it obtains resolution results, could impact the authenticity of address mappings; DNS Security Extensions (DNSSEC, [RFC4033]) are one way to improve authenticity.
</p>

<p>
更には、~IP~addressが得された後に，
"`http$c" ~URI用に権限を確立することは、
Internet Protocol ~route法に対する攻撃に脆弱である。
◎
Furthermore, after an IP address is obtained, establishing authority for an "http" URI is vulnerable to attacks on Internet Protocol routing.
</p>

<div class="p">
<p>
"`https$c" `~scheme$は、前述したような［
権限を確立する際の，攻撃の可能性
］の多くを防ぐ（または少なくとも露呈する）ことを意図している
— 次がすべて満たされる限りにおいて：
◎
The "https" scheme (Section 2.5.2) is intended to prevent (or at least reveal) many of these potential attacks on establishing authority, provided that＼
</p>
<ul>
	<li>
折衝される接続は`~secure化$されている。
◎
the negotiated connection is secured and＼
</li>
	<li>
`~client$は、自身が通信している`~server$の識別情報を［
`~target~URI$の `authority$p 成分に合致するかどうか
］により，適正に検証yしている（ `6.3.3.3$sec ）。
◎
the client properly verifies that the communicating server's identity matches the target URI's authority component (Section 6.3.3.3).＼
</li>
</ul>

<p>
そのような検証yを正しく実装するのは、困難なこともある（ `Georgiev$r ）。
◎
Correctly implementing such verification can be difficult (see [Georgiev]).
</p>
</div>

<p>
所与の`生成元~server$用の権限は、~protocol拡張
— 例えば， `RFC7838$r —
を通して委譲できる。
同様に， `RFC8336$r の様な~protocol拡張により、［
ある接続に対し権限的と見なされる~server
］の集合を変更できる。
◎
Authority for a given origin server can be delegated through protocol extensions; for example, [RFC7838]. Likewise, the set of servers that a connection is considered authoritative for can be changed with a protocol extension like [RFC8336].
</p>

<p>
応答を［
共用~proxy~cacheなどの権限的でない源
］から供することは，［
処理能や可用性を改善するために有用になる
］ことが多いが、［
当の源を信用できるか、信用できない応答でも安全に利用できる
］場合までに限られる。
◎
Providing a response from a non-authoritative source, such as a shared proxy cache, is often useful to improve performance and availability, but only to the extent that the source can be trusted or the distrusted response can be safely used.
</p>

<div class="p">
<p>
あいにく、利用者に権限を通信することは 困難にもなり得る。
例えば，~phishingは、［
権限に対する利用者の知覚
］に対する攻撃である。
その知覚は、~hypertext内に類似な銘柄が呈示されることで，誤誘導され得る
— 場合によっては［
`authority$p 成分（権限）をごまかす `userinfo$p
］でも~~補強されて。
`~UA$は、~phishing攻撃による影響iを，次により抑制できる：
◎
Unfortunately, communicating authority to users can be difficult. For example, phishing is an attack on the user's perception of authority, where that perception can be misled by presenting similar branding in hypertext, possibly aided by userinfo obfuscating the authority component (see Section 2.5.1). User agents can reduce the impact of phishing attacks＼
</p>
<ul>
	<li>
利用者が何らかの動作をとるに先立って、`~target~URI$を，利用者から検分し易くする。
◎
by enabling users to easily inspect a target URI prior to making an action,＼
</li>
	<li>
`userinfo$p が在るときは、それを目立つ様に~~区別する（または却下する）。
◎
by prominently distinguishing (or rejecting) userinfo when present, and＼
</li>
	<li>
参照元の文書が［
未知な, あるいは信用できない
］源から来ている場合、自身に格納されている`資格証$や~cookieは送信しない。
◎
by not sending stored credentials and cookies when the referring document is from an unknown or untrusted source.
</li>
</ul>
</div>

		</section>
		<section id="risks.intermediaries">
<h3 title="Risks of Intermediaries">12.2. 中継者の~risk</h3>

<p>
~HTTP`中継者$は、内来的に，経路上の攻撃を成せる立場にある。
中継者が稼働する~systemが弱体化されると、深刻な［
~security／~privacy
］問題になり得る。
中継者は，［
~securityに関係する情報／
個々の［
利用者や組織
］についての個人-情報／
利用者と内容~providerに所属している~proprietary情報
］へも~accessし得るかもしれない。
弱体化された中継者, あるいは［
~securityや~privacy
］の考慮点に~~無関心に［
実装された／環境設定された
］中継者は、その引き換えに広範な攻撃に晒され得る。
◎
HTTP intermediaries are inherently situated for on-path attacks. Compromise of the systems on which the intermediaries run can result in serious security and privacy problems. Intermediaries might have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers. A compromised intermediary, or an intermediary implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.
</p>

<p>
`共用~cache$を包含する`中継者$は
— `Caching/7$sec にて述べられるように —
~cache汚染~攻撃に，とりわけ脆弱である。
◎
Intermediaries that contain a shared cache are especially vulnerable to cache poisoning attacks, as described in Section 7 of [Caching].
</p>

<p>
実装者たちは、［
設計と その~code化にあたっての裁定／
運用者に供する環境設定~option（とりわけ，既定の環境設定）
］による，~privacyや~securityに対する含意を考慮する必要がある。
◎
Implementers need to consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to operators (especially the default configuration).
</p>

<p>
利用者は、［
`中継者$は、それを稼働している者たち以上に信用に価し得るものにはならない
］ことを自覚する必要がある
— ~HTTP自身は、この問題を解決sできない。
◎
Users need to be aware that intermediaries are no more trustworthy than the people who run them; HTTP itself cannot solve this problem.
</p>

		</section>
		<section id="attack.pathname">
<h3 title="Attacks Based on File and Path Names">12.3. ~file名や~path名に基づく攻撃</h3>

<p>
`生成元~server$は、［
`~target~URI$から資源~表現への対応付け
］を管理するために，自身の局所的な~file~systemを用立てることが多い。
ほとんどの~file~systemは、悪意的な［
~file／~path
］名から保護されるように設計されていない。
したがって，生成元~serverは、`~target資源$を［
~file／~folder／~directory
］に対応付けるときに，［
~systemにおいて特別な有意性がある名前
］への~accessを避ける必要がある。
◎
Origin servers frequently make use of their local file system to manage the mapping from target URI to resource representations. Most file systems are not designed to protect against malicious file or path names. Therefore, an origin server needs to avoid accessing names that have a special significance to the system when mapping the target resource to files, folders, or directories.
</p>

<p>
例えば［
~UNIX, Microsoft Windows, その他の~OS
］は、
"`..^c" を［
現在の~levelより一つ上の~directoryを指示する，~path成分
］として利用することに加え，特別に命名された［
~path／~file
］名を［
~dataを~system機器へ送信する
］ために利用する。
類似な命名~慣行は、他の型の~storage~systemにも存在し得る。
同様に，局所的な~storage~systemは、次を取扱うときに，~securityよりも利用者への親切さを選好する厄介な傾向がある
⇒＃
妥当でない文字／
期待されない文字／
分解された文字の再組成／
文字大小無視な名前に対する 文字大小の正規化
◎
For example, UNIX, Microsoft Windows, and other operating systems use ".." as a path component to indicate a directory level above the current one, and they use specially named paths or file names to send data to system devices. Similar naming conventions might exist within other types of storage systems. Likewise, local storage systems have an annoying tendency to prefer user-friendliness over security when handling invalid or unexpected characters, recomposition of decomposed characters, and case-normalization of case-insensitive names.
</p>

<p>
そのような特別な名前に基づく攻撃は、［
~DoS （例： ~serverに COM ~portから読取るように~~仕向ける）
］や［
~serve用に意味されていない，環境設定や~source~fileの開示
］に力点を置く傾向にある。
◎
Attacks based on such special names tend to focus on either denial-of-service (e.g., telling the server to read from a COM port) or disclosure of configuration and source files that are not meant to be served.
</p>

		</section>
		<section id="attack.injection">
<h3 title="Attacks Based on Command, Code, or Query Injection">12.4. ~command／~code／~query の注入に基づく攻撃</h3>

<p>
`生成元~server$は、`~URI$の中の~parameterを，［
~system~serviceを識別する／
~database~entryを選定する／
~data源を選ぶ
］ための手段として，利用することが多い。
しかしながら、要請~内に受信される~dataは，信用できない。
攻撃者は、［［
~command呼出n／言語~解釈器／~database~interface
］を通して渡されたときに［
~command／~code／~query
］として誤解釈され得る
］ような~dataを包含させるために，どのような要請~data要素（~method, `~target~URI$, ~header, 本体）も構築できる。
◎
Origin servers often use parameters within the URI as a means of identifying system services, selecting database entries, or choosing a data source. However, data received in a request cannot be trusted. An attacker could construct any of the request data elements (method, target URI, header fields, or body) to contain data that might be misinterpreted as a command, code, or query when passed through a command invocation, language interpreter, or database interface.
</p>

<p>
共通的にある攻撃として，例えば~SQL注入は、［
`~target~URI$または~header（例： `Host$h, `Referer$h, 等々）のある部分
］の中に，追加的な~query言語を挿入する。
受信した~dataが SELECT 文0の中で直に利用された場合、~query言語は，~database~commandとして解釈され得る
— 単純な文字列~値としてではなく。
実装における この型の脆弱性は、防止するのは容易にもかかわらず，ごく ありふれている。
◎
For example, SQL injection is a common attack wherein additional query language is inserted within some part of the target URI or header fields (e.g., Host, Referer, etc.). If the received data is used directly within a SELECT statement, the query language might be interpreted as a database command instead of a simple string value. This type of implementation vulnerability is extremely common, in spite of being easy to prevent.
</p>

<p>
一般に，資源の実装は、［
指示命令として［
処理される／解釈される
］ような文脈
］においては，要請~dataの利用を避ける~OUGHT。
要請~dataの~parameterは、固定的な文字列と比較された上で，その比較の結果として動作する~OUGHT
— ［
信用できない~data用に準備されたものではない~interface
］を通して渡されるのではなく。
受信した~dataが固定的な~parameterに基づかない場合、誤解釈を避けるため，注意深く［
~filterする／符号化する
］~OUGHT。
◎
In general, resource implementations ought to avoid use of request data in contexts that are processed or interpreted as instructions. Parameters ought to be compared to fixed strings and acted upon as a result of that comparison, rather than passed through an interface that is not prepared for untrusted data. Received data that isn't based on fixed parameters ought to be carefully filtered or encoded to avoid being misinterpreted.
</p>

<p>
類似な考慮点は、［
いったん格納され，後で処理される
］ような要請~dataにも適用される
— ［
~log~fileの中／
監視-用~tool／
埋込d~scriptも許容する~data形式の中に内包されるとき
］など。
◎
Similar considerations apply to request data when it is stored and later processed, such as within log files, monitoring tools, or when included within a data format that allows embedded scripts.
</p>

		</section>
		<section id="attack.protocol.element.length">
<h3 title="Attacks via Protocol Element Length">12.5. ~protocol要素の長さを介した攻撃</h3>

<p>
~HTTPは，大方，文字で区切られる~textな~fieldを利用するので、構文解析器は，［
~~長大な（または とても遅い）~data~streamの送信に基づく攻撃
］に脆弱になることが多い
— 特に，実装が［
定義済みな長さ（`3.3$sec）がない~protocol要素
］を期待している所では。
◎
Because HTTP uses mostly textual, character-delimited fields, parsers are often vulnerable to attacks based on sending very long (or very slow) streams of data, particularly where an implementation is expecting a protocol element with no predefined length (Section 3.3).
</p>

<p>
相互運用能を促進するため、各種`~field$には，最小な~size上限について特定の推奨が為される（ `5.2$sec ）。
これらは、［
資源が制限された実装でも、~support可能になるような最小
］を与える推奨になるように選ばれている
— ほとんどの実装は，相当に高い上限を選ぶことになると期待されている。
◎
To promote interoperability, specific recommendations are made for minimum size limits on fields (Section 5.2). These are minimum recommendations, chosen to be supportable even by implementations with limited resources; it is expected that most implementations will choose substantially higher limits.
</p>

<p>
`~server$は、~messageの［
`~target~URI$が~~長過ぎる／要請の`~payload$が巨大~過ぎる
］場合には，（ `414$st ／ `413$st で）却下できる。
~HTTPの拡張 `RFC6585$r にも，［
容量~制限に関係する追加的な`状態s~code$
］が定義されている。
◎
A server can reject a message that has a target URI that is too long (Section 10.5.15) or a request payload that is too large (Section 10.5.14). Additional status codes related to capacity limits have been defined by extensions to HTTP [RFC6585].
</p>

<p>
`受信者$は、［
自身が処理する他の~protocol要素の限度
］を注意深く制限する~OUGHT。
それらには、［
`要請~method$,
応答~状態s句【 `reason-phrase$p 】,
`~field名$,
数量-値,
本体~chunk
］も含まれる。
そのような処理における制限の失敗は、~buffer~overflowや算術的な桁溢れ, あるいは~DoS攻撃への脆弱性を高める結果になり得る。
◎
Recipients ought to carefully limit the extent to which they process other protocol elements, including (but not limited to) request methods, response status phrases, field names, numeric values, and body chunks. Failure to limit such processing can result in buffer overflows, arithmetic overflows, or increased vulnerability to denial-of-service attacks.
</p>

		</section>
		<section id="compression.attacks">
<h3 title="Attacks using Shared-dictionary Compression">12.6. 辞書を共有している圧縮を利用する攻撃</h3>

<p>
暗号化された~protocolに対する攻撃には、動的な圧縮により作成される~sizeの相違を利用して，機密的な情報を露呈するものもある
— 例えば `BREACH$r
。
攻撃者が制御する内容と機密的な情報に同じ辞書を利用している動的な圧縮~algoは、前者の内容が後者の内容の一部に合致する場合，より効率的に圧縮することになる
— これらの攻撃は、そのような冗長性を作成することに依拠する。
◎
Some attacks on encrypted protocols use the differences in size created by dynamic compression to reveal confidential information; for example, [BREACH]. These attacks rely on creating a redundancy between attacker-controlled content and the confidential information, such that a dynamic compression algorithm using the same dictionary for both content will compress more efficiently when the attacker-controlled content matches parts of the confidential content.
</p>

<p>
~HTTP~messageは、圧縮され得る
— その仕方には、いくつかあり，次の利用も含まれる
⇒＃
~TLS圧縮,
`内容~符号法$,
`転送~符号法$,
拡張や~versionに特有な他の仕組み
◎
HTTP messages can be compressed in a number of ways, including using TLS compression, content-codings, transfer-codings, and other extension or version-specific mechanisms.
</p>

<p>
この~riskに対する最も効果的な軽減は、敏感な~dataに対しては圧縮を不能化するか,
敏感な~dataを攻撃者が制御する~dataから厳密に分離して，それらが同じ圧縮~辞書を共有し得ないようにすることである。
注意深い設計の下では、圧縮~schemeは，［
制限された利用事例においては，悪用-可能とは見なされない
］ような仕方で設計し得る
— ~HPACK `RFC7541$r など。
◎
The most effective mitigation for this risk is to disable compression on sensitive data, or to strictly separate sensitive data from attacker-controlled data so that they cannot share the same compression dictionary. With careful design, a compression scheme can be designed in a way that is not considered exploitable in limited use cases, such as HPACK ([RFC7541]).
</p>

		</section>
		<section id="personal.information">
<h3 title="Disclosure of Personal Information">12.7. 個人-情報の開示</h3>

<div class="p">
<p>
`~client$は，~~多量な個人-情報
— 次に挙げるもの含む —
を知る立場にあることが多いので、実装は，個人-情報が意図されずに開示されることを防止する必要がある：
</p>
<ul>
	<li>
資源とヤリトリするために，利用者から供される情報（例：
利用者の［
名前, 所在, ~mail~address, ~password, 暗号化~key, 等々
］）
</li>
	<li>
時経過にわたる，利用者の閲覧~活動についての情報（例： 履歴, ~bookmark, 等々）
</li>
</ul>
◎
Clients are often privy to large amounts of personal information, including both information provided by the user to interact with resources (e.g., the user's name, location, mail address, passwords, encryption keys, etc.) and information about the user's browsing activity over time (e.g., history, bookmarks, etc.). Implementations need to prevent unintentional disclosure of personal information.
</div>

		</section>
		<section id="privacy.of.server.log.information">
<h3 title="Privacy of Server Log Information">12.8. ~server~log情報の~privacy</h3>

<p>
`~server$は、［
期間に渡る利用者の要請についての個人-~data
］を保存する立場にあり，利用者の［
行動様式／関心事
］も識別し得る。
特に，［
`中継者$に集められた~log情報
］は、［
不特定多数の~siteにまたがる，~UAとのヤリトリの履歴
］を包含することが多く，個々の利用者を追跡し得る。
◎
A server is in the position to save personal data about a user's requests over time, which might identify their reading patterns or subjects of interest. In particular, log information gathered at an intermediary often contains a history of user agent interaction, across a multitude of sites, that can be traced to individual users.
</p>

<p>
~HTTP~log情報は，その資質からして機密的なので、その取扱いは，法律や規制により拘束されることが多い。
~log情報は、~secureに格納された上で，その分析に際しては適切な指針に従う必要がある。
［
個々の~entryの中の個人-情報の匿名化
］も補助になるが、一般に，本物の~log追跡から［
他の~access特性との相関
］に基づいて識別し直されるのを防ぐには十分でない。
そのようなわけで、［
特定の`~client$に対し~keyされた~access追跡
］の流出は，当の~keyが疑似匿名であっても安全とは言えない。
◎
HTTP log information is confidential in nature; its handling is often constrained by laws and regulations. Log information needs to be securely stored and appropriate guidelines followed for its analysis. Anonymization of personal information within individual entries helps, but it is generally not sufficient to prevent real log traces from being re-identified based on correlation with other access characteristics. As such, access traces that are keyed to a specific client are unsafe to publish even if the key is pseudonymous.
</p>

<p>
盗聴や不用意な流出の~riskを最小限にするため，個人識別可能な情報
— ［
利用者~識別子,
~IP~address,
利用者が供した `query$p ~parameter
］なども含む
— は、［
~security／ ~~監査（ `auditing^en ）／ 不正行為の~~規制（ `fraud control^en ）
などの，運用~上の必要性を~supportする
］ことが必要とされなくなり次第，~log情報から一掃される~OUGHT。
◎
To minimize the risk of theft or accidental publication, log information ought to be purged of personally identifiable information, including user identifiers, IP addresses, and user-provided query parameters, as soon as that information is no longer necessary to support operational needs for security, auditing, or fraud control.
</p>

		</section>
		<section id="sensitive.information.in.uris">
<h3 title="Disclosure of Sensitive Information in URIs">12.9. ~URI内の敏感な情報の開示</h3>

<p>
`~URI$は、~secureな資源を識別するものであっても，［
共有され, ~secure化されないもの
］になるように意図されている。
~URIは、［
~displayに示される／
~pageの印刷-時に各用紙に刷られる／
様々な未保護な~bookmark~list内に格納される
］ことが多い。
多くの［
~server／~proxy／~UA
］は、`~target~URI$を［
第三者主体から可視になり得る所
］に，~logしたり, 表示する。
したがって，［
敏感な ／ 個人識別可能な ／ 開示される~riskがある
］情報を~URIに内包することは、賢明でない。
◎
URIs are intended to be shared, not secured, even when they identify secure resources. URIs are often shown on displays, added to templates when a page is printed, and stored in a variety of unprotected bookmark lists. Many servers, proxies, and user agents log or display the target URI in places where it might be visible to third parties. It is therefore unwise to include information within a URI that is sensitive, personally identifiable, or a risk to disclose.
</p>

<p>
応用が［
利用者が供した情報から`~target~URI$を構築するような，~client側の仕組み
］
— `GET$m を利用している~formの~query~fieldなど —
を利用している場合、~URIの中に開示するには適切にならない，敏感になり得る~dataが供されるかもしれない。
そのような事例では、 `POST$m が選好されることが多い
— それは通例的に、~URIは構築しない代わりに，敏感になり得る~dataを~formの `POST$m 要請の本体~内に伝送するので。
しかしながら，これは、~cachingを邪魔することに加え，他であれば`安全$になる要請に安全でない~methodを利用する。
代替な対処法として、［
~URIを構築するに先立って，利用者が供した~dataを形式変換する／
敏感でない 共通的な値に限り内包するよう，当の~dataを~filterする
］などが挙げられる。
同様に【その上で？】，~queryの結果を（~serverが生成した）異なる~URIへ~redirectすれば、後の~linkから敏感になり得る~dataを除去して，後で再利用できる`~cache可能$な応答を供し得る。
◎
When an application uses client-side mechanisms to construct a target URI out of user-provided information, such as the query fields of a form using GET, potentially sensitive data might be provided that would not be appropriate for disclosure within a URI. POST is often preferred in such cases because it usually doesn't construct a URI; instead, POST of a form transmits the potentially sensitive data in the request body. However, this hinders caching and uses an unsafe method for what would otherwise be a safe request. Alternative workarounds include transforming the user-provided data prior to constructing the URI, or filtering the data to only include common values that are not sensitive. Likewise, redirecting the result of a query to a different (server-generated) URI can remove potentially sensitive data from later links and provide a cacheable response for later reuse.
</p>

<p>
`Referer$h ~headerは，要請を~~生じさせた文脈について ~target~siteに~~伝えるので、参照元~資源の~URI内に見出され得るような［
利用者の直前の閲覧~履歴についての情報, その他の個人-情報
］を露呈する~~可能性がある。
`Referer$h ~headerに対する制限は、その定義に述べたように，その~securityの考慮点の一部に取組む。
◎
Since the Referer header field tells a target site about the context that resulted in a request, it has the potential to reveal information about the user's immediate browsing history and any personal information that might be found in the referring resource's URI. Limitations on the Referer header field are described in Section 9.6.2 to address some of its security considerations.
</p>

		</section>
		<section id="fragment.disclosure">
<h3 title="Disclosure of Fragment after Redirects">12.10. ~redirect後の素片の開示</h3>

<p>
`~URI$参照の中で利用される`素片~識別子$は，要請~内には送信されないが、実装者は，［
それらが、応答の結果として，~UA, および稼働中のどの［
拡張／~script
］からも可視になる
］ことを自覚しておく~OUGHT。
特に，［
~redirectが生じて，元の要請の素片~識別子が `Location$h 内の新たな参照に継承される
］とき、これには，［
ある~siteの素片を別の~siteに開示する
］かもしれない効果がある。
最初の~siteが `fragment$p 内に個人-情報を利用している場合、他の~siteへの~redirectに際しては，［
【最初の `fragment^p と無関係な】（場合によっては空な） `fragment^p 成分を内包することにより，その継承を阻止する
］ことを確保する~OUGHT。
◎
Although fragment identifiers used within URI references are not sent in requests, implementers ought to be aware that they will be visible to the user agent and any extensions or scripts running as a result of the response. In particular, when a redirect occurs and the original request's fragment identifier is inherited by the new reference in Location (Section 11.1.2), this might have the effect of disclosing one site's fragment to another site. If the first site uses personal information in fragments, it ought to ensure that redirects to other sites include a (possibly empty) fragment component in order to block that inheritance.
</p>

		</section>
		<section id="disclosure.product.information">
<h3 title="Disclosure of Product Information">12.11. 製品~情報の開示</h3>

<p>
［
`User-Agent$h ／ `Via$h ／ `Server$h
］~headerは、［
当の`送信者$の~software~systemについての情報
］を露呈することが多い。
これは，理論においては、攻撃者が既知な~securityの穴を悪用し易くし得る
— 実施においては、攻撃者は，［
利用されている ~~見かけの~software~version
］に関わらず，~~可能性のある すべての穴を試行する傾向にあるが。
◎
The User-Agent (Section 9.6.3), Via (Section 6.6.1), and Server (Section 11.4.3) header fields often reveal information about the respective sender's software systems. In theory, this can make it easier for an attacker to exploit known security holes; in practice, attackers tend to try all potential holes regardless of the apparent software versions being used.
</p>

<p>
［
~network~firewallを通る~portalとして~serveする`~proxy$
］は、［
~firewallの背後の~hostを識別し得るような ~header情報
］の転送に関して，特別な予防策を~~講じる~OUGHT。
`Via$h ~headerは、［
敏感な~machine名を `pseudonym$p に置換する
］ことを`中継者$に許容する。
◎
Proxies that serve as a portal through a network firewall ought to take special precautions regarding the transfer of header information that might identify hosts behind the firewall. The Via header field allows intermediaries to replace sensitive machine names with pseudonyms.
</p>

		</section>
		<section id="fingerprinting">
<h3 title="Browser Fingerprinting">12.12. ~browser指紋収集</h3>

<p>
~browser指紋収集（ `fingerprinting^en ）は、［
一意な［
~UAの各種~特性からなる集合
］を通して、特定の~UAを，時経過にわたり識別する
］ための，様々な技法の~~総称である。
これらの特性には、~UAの［
~TCPの挙動,
備えている特能,
~scripting環境
］に関係する情報も含まれ得る
— 特に関心を引くものは、［
~HTTPを介して通信され得る，一意な【個別の~UAを一意に~~特定するような】特性の集合
］である。
指紋収集は，［
~UAの挙動を時経過にわたり追跡すること `Bujlow$r
］を
— 利用者が，他の形の~data~collection（例：~cookie）に対しては持ち得るような、対応する制御なしに —
可能化するので、~privacy懸念と見なされる。
多くの一般用~UA（すなわち，~web~browser）は、指紋収集を抑制する手順を踏んでいる。
◎
Browser fingerprinting is a set of techniques for identifying a specific user agent over time through its unique set of characteristics. These characteristics might include information related to its TCP behavior, feature capabilities, and scripting environment, though of particular interest here is the set of unique characteristics that might be communicated via HTTP. Fingerprinting is considered a privacy concern because it enables tracking of a user agent's behavior over time ([Bujlow]) without the corresponding controls that the user might have over other forms of data collection (e.g., cookies). Many general-purpose user agents (i.e., Web browsers) have taken steps to reduce their fingerprints.
</p>

<p>
いくつもの`要請~header$が、一意に足る指紋収集を可能化するような情報を，~serverに露呈し得る。
最も明らかなのは `From$h ~headerである
— それは、［
利用者から，自己の識別が欲されている
］ときに限り，送信されるものと期待されているが。
同様に， `Cookie$h ~headerは、［
再~識別を可能化するよう，故意に設計されている
］ので，指紋収集の懸念が適用されるのは［
~UAの環境設定により，~cookieが不能化-または制約されている状況
］に限られる。
◎
There are a number of request header fields that might reveal information to servers that is sufficiently unique to enable fingerprinting. The From header field is the most obvious, though it is expected that From will only be sent when self-identification is desired by the user. Likewise, Cookie header fields are deliberately designed to enable re-identification, so fingerprinting concerns only apply to situations where cookies are disabled or restricted by the user agent's configuration.
</p>

<p>
`User-Agent$h ~headerは、通例的に，他の特性と組合されたとき、特に，~UAが［
利用者の~systemや拡張についての過度の詳細
］を送信した場合に，［
特定の機器を一意に識別するに十分な情報
］を包含し得る。
しかしながら，それよりも［
利用者が まず予期しないであろう，一意な情報の源
］を成すものは、`~proactive折衝~header$であり，次が含まれる
⇒＃
`Accept$h ,
`Accept-Charset$h,
`Accept-Encoding$h,
`Accept-Language$h
◎
The User-Agent header field might contain enough information to uniquely identify a specific device, usually when combined with other characteristics, particularly if the user agent sends excessive details about the user's system or extensions. However, the source of unique information that is least expected by users is proactive negotiation (Section 9.4), including the Accept, Accept-Charset, Accept-Encoding, and Accept-Language header fields.
</p>

<p>
指紋収集の懸念に加えて，［
`Accept-Language$h ~headerの詳細な利用
］は、［
利用者が私的な資質と見なし得る情報
］を露呈し得る。
例えば，［
所与の言語~集合を解すること
］は、［
特定0の民族の成員であること
］に強く相関し得る。
~UAがとり得る，そのような~privacyの損失を制限する~approachとしては、~whitelist化された~siteを除き，
`Accept-Language$h の送信を省略することが挙げられる
— たぶん，［
言語~折衝を指示する `Vary$h ~header
］を検出した後のやりとりを介することが、有用になり得る。
◎
In addition to the fingerprinting concern, detailed use of the Accept-Language header field can reveal information the user might consider to be of a private nature. For example, understanding a given language set might be strongly correlated to membership in a particular ethnic group. An approach that limits such loss of privacy would be for a user agent to omit the sending of Accept-Language except for sites that have been whitelisted, perhaps via interaction after detecting a Vary header field that indicates language negotiation might be useful.
</p>

<p>
~privacyを強化するために`~proxy$が利用される環境においては、`~UA$は［
`~proactive折衝~header$の送信
］に保守的になる~OUGHT。
~headerの~~高度な環境設定-能を供する一般用`~UA$は、［
詳細が供され過ぎる結果，~privacyの損失に繋がり得る
］ことについて，利用者に伝える~OUGHT。
~~究極の~privacy~~保護措置として、~proxyは，中継される要請~内の`~proactive折衝~header$を~filterできる。
◎
In environments where proxies are used to enhance privacy, user agents ought to be conservative in sending proactive negotiation header fields. General-purpose user agents that provide a high degree of header field configurability ought to inform users about the loss of privacy that might result if too much detail is provided. As an extreme privacy measure, proxies could filter the proactive negotiation header fields in relayed requests.
</p>

		</section>
		<section id="security.validators">
<h3 title="Validator Retention">12.13. 検証子の維持</h3>

<p>
この仕様により定義される検証子は、［
`表現$の妥当性を確保する／
悪意的な変更に抗して防護する／
経路上の攻撃を検出する
］ものとして，意図されたものではない。
それらは~~最善でも、すべての参加者が~~順調に挙動する下で［
より効率的な~cache更新を可能化したり, 同時的 書込みをより~~適化する
］だけである。
~~最悪でも、条件は失敗し，~clientは［［
条件付きでない要請による~HTTP交換
］以上に有害にはならない，応答
］を受信するだけである。
◎
The validators defined by this specification are not intended to ensure the validity of a representation, guard against malicious changes, or detect on-path attacks. At best, they enable more efficient cache updates and optimistic concurrent writes when all participants are behaving nicely. At worst, the conditions will fail and the client will receive a response that is no more harmful than an HTTP exchange without conditional requests.
</p>

<p>
`entity-tag$p は、~privacy~riskを高める仕方で濫用され得る。
例えば，~siteが、［
利用者や~UA間で一意, かつ
意味論的に妥当でない
］ような `entity-tag$p を故意に構築して, ［
~cache可能かつ`鮮度維持期間$の長い，応答
］内に送信した上で，［
利用者／~UAを識別し直す手段として，今後の`条件付き要請$からその `entity-tag$p を読取る
］ことも，あり得る。
そのように識別する~tagは、［
~UAが元の~cache~entryを維持する限り，持続する
］ような，識別子になるであろう。
`表現$を~cacheする~UAは、利用者が，［
格納されている~cookieを~clearしたり，私的~閲覧~modeに変える
］などにより，~privacyを保守する動作を遂行したときには、その~cacheが［
~clearされる／置換される
］ことを確保する~OUGHT。
◎
An entity-tag can be abused in ways that create privacy risks. For example, a site might deliberately construct a semantically invalid entity-tag that is unique to the user or user agent, send it in a cacheable response with a long freshness time, and then read that entity-tag in later conditional requests as a means of re-identifying that user or user agent. Such an identifying tag would become a persistent identifier for as long as the user agent retained the original cache entry. User agents that cache representations ought to ensure that the cache is cleared or replaced whenever the user performs privacy-maintaining actions, such as clearing stored cookies or changing to a private browsing mode.
</p>

		</section>
		<section id="overlapping.ranges">
<h3 title="Denial-of-Service Attacks Using Range">12.14. 範囲を利用する~DoS攻撃</h3>

<p>
拘束されない複数~範囲の要請は、~DoS攻撃に~~感受性が~~高い
— 重合する多数の範囲を要請する労力は、要請された~dataを多数の部位tで~serveしようとするときに消費される［
時間, ~memory, 帯域幅
］に比較して僅かなので。
`~server$は、~~甚しい`範囲~要請$
— 3 個~以上が重合したり, 多数に細切れにされた範囲たちに対する要請 —
を［
無視する／
合体する／
却下する
］~OUGHT
— 特に，それらの範囲が~~明らかな理由なしに順不同で要請されたとき。
複部位を伴う範囲~要請は、~random~accessを~supportするように設計されていない。
◎
Unconstrained multiple range requests are susceptible to denial-of-service attacks because the effort required to request many overlapping ranges of the same data is tiny compared to the time, memory, and bandwidth consumed by attempting to serve the requested data in many parts. Servers ought to ignore, coalesce, or reject egregious range requests, such as requests for more than two overlapping ranges or for many small ranges in a single set, particularly when the ranges are requested out of order for no apparent reason. Multipart range requests are not designed to support random access.
</p>

		</section>
		<section id="security.auth">
<h3 title="Authentication Considerations">12.15. 認証の考慮点</h3>

<p>
~HTTP認証の論題については何もかも~securityの考慮点になるので、以下に挙げる考慮点は，網羅的ではない。
更には、［
一般的な，認証~frameworkに関する~securityの考慮点
］に制限されている
— 特定の`認証~scheme$について考え得る，あらゆる考慮点を論じるのではなく（それらは，各~schemeを定義する仕様にて文書~化される~OUGHT）。
様々な組織が，~Web応用の~securityについての時事的な情報や現在の事実調査への~linkを保守する（例： `OWASP$r ）
— 実施において見出される`認証~scheme$を［
実装する／利用する
］際に共通的な罠など。
◎
Everything about the topic of HTTP authentication is a security consideration, so the list of considerations below is not exhaustive. Furthermore, it is limited to security considerations regarding the authentication framework, in general, rather than discussing all of the potential considerations for specific authentication schemes (which ought to be documented in the specifications that define those schemes). Various organizations maintain topical information and links to current research on Web application security (e.g., [OWASP]), including common pitfalls for implementing and using the authentication schemes found in practice.
</p>

			<section id="confidentiality.of.credentials">
<h4 title="Confidentiality of Credentials">12.15.1. 資格証の機密性</h4>

<p>
~HTTP認証~frameworkは、［
`資格証$の機密性を保守するための，単独の仕組み
］は定義しない
— 代わりに、各 `認証~scheme$が［
伝送に先立って`資格証$が符号化される方法
］を定義する。
これは、将来における`認証~scheme$の開発に柔軟性を供する一方で、［
自前の機密性を供さない, あるいは
反射攻撃に対する保護には足らない
］ような既存の~schemeの保護には，必要十分でない。
更には，`~server$が［
個々の利用者に特有な`資格証$
］を期待する場合、それらの`資格証$の交換は，その利用者を識別する効果ももたらす
— `資格証$の中の内容が機密的であり続けるとしても。
◎
The HTTP authentication framework does not define a single mechanism for maintaining the confidentiality of credentials; instead, each authentication scheme defines how the credentials are encoded prior to transmission. While this provides flexibility for the development of future authentication schemes, it is inadequate for the protection of existing schemes that provide no confidentiality on their own, or that do not sufficiently protect against replay attacks. Furthermore, if the server expects credentials that are specific to each individual user, the exchange of those credentials will have the effect of identifying that user even if the content within credentials remains confidential.
</p>

<p>
~HTTPが供する［
`~field$の伝送における機密性
］は、下層［
~transport／~session
］~levelの接続の，各種~securityの~propertyに依存する。
言い換えれば、`~server$は，［
この~frameworkを利用して，~accessを認証-済み利用者のみに制限する場合
］には［
その接続が，利用する`認証~scheme$の資質に則って適正に`~secure化$される
］ことを確保する必要がある。
例えば、個々の利用者~認証に依存する~serviceは、［
`資格証$を交換するに先立って，接続が~TLS（ “Transport Layer Security”, `RFC8446$r ）により~secure化される
］ことを要求することが多い。
◎
HTTP depends on the security properties of the underlying transport- or session-level connection to provide confidential transmission of fields. In other words, if a server limits access to authenticated users using this framework, the server needs to ensure that the connection is properly secured in accordance with the nature of the authentication scheme used. For example, services that depend on individual user authentication often require a connection to be secured with TLS ("Transport Layer Security", [RFC8446]) prior to exchanging any credentials.
</p>

			</section>
			<section id="auth.credentials.and.idle.clients">
<h4 title="Credentials and Idle Clients">12.15.2. 資格証と遊休~client</h4>

<p>
既存の~HTTP `~client$／`~UA$が 認証~情報を維持する~~期間は、概して不定である。
~HTTPは、［
`生成元~server$が、`~client$に対し，~cacheされた`資格証$を破棄するように指令する
］ための仕組みは供さない
— この~protocolは、~UAが`資格証$を［
得する／管理する
］方法については~~関知しないので。
［
`資格証$を 失効させる／廃用にする ための仕組み
］は、`認証~scheme$定義の一部として指定し得る。
◎
Existing HTTP clients and user agents typically retain authentication information indefinitely. HTTP does not provide a mechanism for the origin server to direct clients to discard these cached credentials, since the protocol has no awareness of how credentials are obtained or managed by the user agent. The mechanisms for expiring or revoking credentials can be specified as part of an authentication scheme definition.
</p>

<p>
少なくとも，次に挙げる状況下においては、資格証の~cachingが，応用の~security~modelに干渉し得る：
◎
Circumstances under which credential caching can interfere with the application's security model include but are not limited to:
</p>
<ul>
	<li>
`~client$が期間を延長して遊休~中にあるときに、`~server$が，`~client$に対し［
再度，利用者に`資格証$の~~入力を促す
］よう望むことがあるとき。
◎
Clients that have been idle for an extended period, following which the server might wish to cause the client to re-prompt the user for credentials.
</li>
	<li>
応用は，~sessionの終了~指示（~page上の “~logout” や “~commit” ~buttonなど）を含んでいて、それにより，応用を成す~server側は［
`~client$が`資格証$を維持する理由は それ以上~無い
］ことを “知る” ようなとき。
◎
Applications that include a session termination indication (such as a "logout" or "commit" button on a page) after which the server side of the application "knows" that there is no further reason for the client to retain the credentials.
</li>
</ul>

<p>
`資格証$を~cacheする`~UA$には、［
~cacheされた`資格証$を，利用者による制御の下で破棄する
］ための［
~~簡単に~access可能な仕組み
］を供することが奨励される。
◎
User agents that cache credentials are encouraged to provide a readily accessible mechanism for discarding cached credentials under user control.
</p>

			</section>
			<section id="protection.spaces">
<h4 title="Protection Spaces">12.15.3. 保護~空間</h4>

<p>
`認証~scheme$のうち，［
もっぱら `realm$c の仕組みに依拠して`保護~空間$を確立するもの
］は、［
`生成元~server$上のすべての資源に対し，認証~用の`資格証$を公開する
］ことになる。
資源への認証-済み要請を成功裡に為した`~client$は、同じ`生成元~server$上の他の資源に対しても，同じ`資格証$を利用できる。
これは、［
ある資源が，他の資源~用の`資格証$を採取すること
］をアリにする。
◎
Authentication schemes that solely rely on the "realm" mechanism for establishing a protection space will expose credentials to all resources on an origin server. Clients that have successfully made authenticated requests with a resource can use the same authentication credentials for other resources on the same origin server. This makes it possible for a different resource to harvest authentication credentials for other resources.
</p>

<div class="p">
<p>
これは特に、［
`生成元~server$が、同じ`正準的~root~URI$の下で，複数の主体~用に資源を~hostするとき
］に，懸念される。
とり得る軽減策としては、次が挙げられる：
◎
This is of particular concern when an origin server hosts resources for multiple parties under the same canonical root URI (Section 9.5.2). Possible mitigation strategies include＼
</p>
<ul>
	<li>
認証~用の`資格証$への直接的な~accessを制約する（すなわち， `Authorization$h 要請~headerの内容を可用にしない）。
◎
restricting direct access to authentication credentials (i.e., not making the content of the Authorization request header field available), and＼
</li>
	<li>
異なる~host名（あるいは~port番号）を利用して，`保護~空間$を各~主体ごとに分離する。
◎
separating protection spaces by using a different host name (or port number) for each party.
</li>
</ul>
</div>

			</section>
			<section id="security.auth.add.resp">
<h4 title="Additional Response Fields">12.15.4. 追加的な応答~field</h4>

<p>
暗号化されてない~channel越しに送信される応答に情報を追加すると、~securityと~privacyに影響し得る。
［
`Authentication-Info$h ／ `Proxy-Authentication-Info$h
］~headerが在ること自体は、~HTTP認証が利用~中にあることを指示する。
`認証~scheme$に特有な~parameterの内容により，追加的な情報も公開され得る
— これらの~schemeの定義は、このことを考慮する必要がある。
◎
Adding information to responses that are sent over an unencrypted channel can affect security and privacy. The presence of the Authentication-Info and Proxy-Authentication-Info header fields alone indicates that HTTP authentication is in use. Additional information could be exposed by the contents of the authentication-scheme specific parameters; this will have to be considered in the definitions of these schemes.
</p>

			</section>
		</section>
	</section>
	<section id="IANA.considerations">
<h2 title="IANA Considerations">13. ~IANA考慮点</h2>

【この節は未訳。】

	</section>
	<section id="collected.abnf">
<h2 title="Collected ABNF">付録 A. 総集的~ABNF</h2>

【この節は未訳。】

	</section>
	<section id="changes.from.previous.rfcs">
<h2 title="Changes from previous RFCs">付録 B. 以前の~RFCからの変更点</h2>


		<section id="changes.from.rfc.2818">
<h3 title="Changes from RFC 2818">B.1. RFC 2818 からの変更点</h3>

<p lang="en-x-a0">None yet.</p>

		</section>
		<section id="changes.from.rfc.7230">
<h3 title="Changes from RFC 7230">B.2. RFC 7230 からの変更点</h3>

<p>
~HTTPの［
設計~目標,
歴史,
~architecture,
適合性の判定基準,
~protocol~version法,
~URI,
~message~route法,
`~header$
］を導入している各~節は、ここに移動された（実質上の変更点は無い）。
◎
The sections introducing HTTP's design goals, history, architecture, conformance criteria, protocol versioning, URIs, message routing, and header fields have been moved here (without substantive change).
</p>

<p>
［
`生成元$, および`生成元~server$への権限的な~access
］についての記述は、~TCPに基づくとは限らない［
代替な~service／~secure化された接続
］も織り込むため，［
"`http^c", "`https^c"
］両~URI用に拡張された。
（ § `http$c, § `https$c, `生成元$sec, `6.3.3$sec ）
◎
The description of an origin and authoritative access to origin servers has been extended for both "http" and "https" URIs to account for alternative services and secured connections that are not necessarily based on TCP. (Section 2.5.1, Section 2.5.2, Section 6.2, Section 6.3.3)
</p>

<p>
`~field値$は、今や複数個の~instanceを~commaで結合した後の値を指す
— それが他よりずっと共通的な利用なので。
単独の~header行lの値を指すときは、`~field行l値$を利用すること。
◎
"Field value" now refers to the value after multiple instances are combined with commas — by far the most common use. To refer to a single header line's value, use "field line value". (Section 5)
</p>

<p>
［
`media-type$p ／ `media-range$p ／ `expectation$p
］内の `parameters$p は、尾部にある 1 個以上の~semicolonを介して空になり得る。
（ `5.4.1.4$sec ）
◎
Parameters in media type, media range, and expectation can be empty via one or more trailing semicolons. (Section 5.4.1.4)
</p>

<p>
`~trailer$の意味論は、今や~chunked符号化法に特有なそれを超越している。
`~trailer$の利用は、次に限られるよう更に制限された：
`~trailer$としての生成は、送信者が［
当の`~field$が そのような用法を定義している
］ことを知っているときに限り許容される／
`~trailer$を`~header節$の中に併合することは、受信者が［
対応する~field定義は、そうするすることを許可していて，そうする方法を定義する
］ことを知っている場合に限り許容される。
他のすべての事例では、実装には，`~trailer$を併合する代わりに，別々に格納するか破棄することが奨励される。
（ `5.6.2$sec ）
◎
Trailer field semantics now transcend the specifics of chunked encoding. Use of trailer fields has been further limited to only allow generation as a trailer field when the sender knows the field defines that usage and to only allow merging into the header section if the recipient knows the corresponding field definition permits and defines how to merge. In all other cases, implementations are encouraged to either store the trailer fields separately or discard them instead of merging. (Section 5.6.2)
</p>

<p>
今や，`~trailer$たちは、利用-中の［
~HTTP~versionと~frame法
］により許容されるならば，複数個の`~trailer節$として出現し得る
— 各~節が受信されるに伴い，【！described as being】反復的に処理されるような。
（ `5.6.3$sec ）
◎
Trailer fields can now potentially appear as multiple trailer sections, if allowed by the HTTP version and framing in use, with processing described as being iterative as each section is received. (Section 5.6.3)
</p>

<p>
`絶対~形$による要請~URIの優先度を
— ~proxyの取扱いに揃えるため —
明示的に，`生成元~server$による `Host^h ~headerよりも高くした。
（ § `Host$h ）
◎
Made the priority of the absolute form of the request URI over the Host header by origin servers explicit, to align with proxy handling. (Section 6.5)
</p>

<p>
`Via^h ~fieldの `received-by$p 用の文法~定義は、［
~URI文法における `host$p に対する変更s `RFC3986$r
］に因り `RFC7230$r において拡げられたが，
`Via^h 用には望ましくない。
単純にするため， `received-by$p 生成規則から `uri-host$p を除去した
— それは、既存の `pseudonym$p 用の文法により包摂できるので。
特に，この変更により、［
`received-by$p において~host名に許容される文字の集合
］から，~commaが除去された。
（ § `Via$h ）
◎
The grammar definition for the Via field's "received-by" was expanded in 7230 due to changes in the URI grammar for host [RFC3986] that are not desirable for Via. For simplicity, we have removed uri-host from the received-by production because it can be encompassed by the existing grammar for pseudonym. In particular, this change removed comma from the allowed set of charaters for a host name in received-by. (Section 6.6.1)
</p>

<p>
状態s~code `308$st0 を追加した（以前は `RFC7538$r にて定義されていた）
— 状態s~code `301$st0, `302$st0, `307$st0 の近くに定義されるよう。
（ § `308^st0 ）
◎
Added status code 308 (previously defined in [RFC7538]) so that it's defined closer to status codes 301, 302, and 307. (Section 10.4.9)
</p>

<p>
状態s~code `422$st0 を追加した（以前は `RFC4918/11.2$sec にて定義されていた）
— それには、一般的な適用能があるので。
（ § `422^st0 ）
◎
Added status code 422 (previously defined in Section 11.2 of [RFC4918]) because of its general applicability. (Section 10.5.20)
</p>

<p>
【！重複】
◎
The description of an origin and authoritative access to origin servers has been extended for both "http" and "https" URIs to account for alternative services and secured connections that are not necessarily based on TCP. (Section 2.5.1, Section 2.5.2, Section 6.2, Section 6.3.3)
</p>


		</section>
		<section id="changes.from.rfc.7231">
<h3 title="Changes from RFC 7231">B.3. RFC 7231 からの変更点</h3>

<p>
実装が~supportすることになる最小な~URI長さは、今や推奨される。
（ `2.4$sec【！`2.5^sec】 ）
◎
Minimum URI lengths to be supported by implementations are now recommended. (Section 2.5)
</p>

<p>
~field値~内の制御-文字は、却下されるか `SP$P に対応付けられることを明確化した。
（ `5.4$sec ）
◎
Clarify that control characters in field values are to be rejected or mapped to SP. (Section 5.4)
</p>

<p>
［
`media-type$p ／ `media-range$p ／ `expectation$p
］内の `parameters$p は、尾部にある 1 個以上の~semicolonを介して空になり得る。
（ `5.4.1.4$sec ）
◎
Parameters in media type, media range, and expectation can be empty via one or more trailing semicolons. (Section 5.4.1.4)
</p>

<p>
用語 “実効~要請~URI” を “`~target~URI$” に置換した。
（ `6.1$sec ）
◎
The term "effective request URI" has been replaced with "target URI". (Section 6.1)
</p>

<p>
`範囲~単位$は、文字大小無視で比較するものとした。
（ `範囲~単位^sec）
◎
Range units are compared in a case insensitive fashion. (Section 7.1.4)
</p>

<p>
~clientによる再試行に対する制約は、実装の挙動を反映するよう~~緩めた。
（ `8.2.2$sec ）
◎
Restrictions on client retries have been loosened, to reflect implementation behavior. (Section 8.2.2)
</p>

<p>
［
`GET^m ／ `DELETE^m
］要請における本体は相互運用可能でないことを明確化した。
（ `8.3.1$sec ／ `8.3.5$sec ）
◎
Clarified that request bodies on GET and DELETE are not interoperable. (Section 8.3.1, Section 8.3.5)
</p>

<p>
`OPTIONS^m ~methodの記述から `Content-Length$h の設定についての過剰な要件を除去した。
（ `8.3.7$sec ）
◎
Removed a superfluous requirement about setting Content-Length from the description of the OPTIONS method. (Section 8.3.7)
</p>

<p>
RFC 2616 との互換性を得るため、
`Expect^h 用に，~listに基づく文法を復旧した（ `9.1.1$sec ）
◎
Restore list-based grammar for Expect for compatibility with RFC 2616. (Section 9.1.1)
</p>

<p>
［
`Accept$h ／ `Accept-Encoding$h
］を応答~message内にも許容するようにした
— 後者は `RFC7694$r が導入したとおりに。
（ `9.4$sec ）
◎
Allow Accept and Accept-Encoding in response messages; the latter was introduced by [RFC7694]. (Section 9.4)
</p>

<p>
~redirectされた要請【に対し，送信し直す要請】を作成する処理nを明確化した。
（ `10.4$sec ）
◎
The process of creating a redirected request has been clarified. (Section 10.4)
</p>

<p>
`Vary^h ~header内に［
"`*^c" が他の値とともに在るとき
］の意味論を明確化した。
（ `11.1.4$sec ）
◎
The semantics of "*" in the Vary header field when other values are present was clarified. (Section 11.1.4)
</p>

		</section>
		<section id="changes.from.rfc.7232">
<h3 title="Changes from RFC 7232">B.4. RFC 7232 からの変更点</h3>

<p>
`事前条件$は，今や、要請~本体が処理される前に
— 処理した結果，成功裡な応答になるかどうか待機することなく —
評価され得る。
（ `9.2.1$sec ）
◎
Preconditions can now be evaluated before the request body is processed rather than waiting until the response would otherwise be successful. (Section 9.2.1)
</p>

<p>
［
`If-Match$h ／ `If-Unmodified-Since$h
］に対する際どい事例の要件
— 検証に失敗したとき、~serverは，［
同じ変更~要請は すでに適用されたものと裁定したならば，
`2xx$st0 応答~内には検証子は送信しない
］とする要件 —
を除去した。
（ `9.2.3$sec, `9.2.6$sec ）
◎
Removed edge case requirement on If-Match and If-Unmodified-Since that a validator not be sent in a 2xx response when validation fails and the server decides that the same change request has already been applied. (Section 9.2.3 and Section 9.2.6)
</p>

<p>
`If-Unmodified-Since^h は、改変~時刻の概念が無い資源には，適用されないことを明確化した。
（ § `If-Unmodified-Since$h ）
◎
Clarified that If-Unmodified-Since doesn't apply to a resource without a concept of modification time. (Section 9.2.6)
</p>

		</section>
		<section id="changes.from.rfc.7233">
<h3 title="Changes from RFC 7233">B.5. RFC 7233 からの変更点</h3>

<p>
［
`range-unit$p,
`ranges-specifier$p
］文法を再構成して、
`bytes$c と他の（拡張）範囲~単位との間の人為的な区別を単純~化し，抑制した
— `範囲~単位$を汎用な `token$p として定義して，拡張（ `other-range$p ）を `range-spec$p の視野の中に置くことにより、
`other-range-unit^p の重合している文法は除去された。
これは，拡張~範囲~単位を含む すべての範囲~集合において、~list構文（~comma）の役割を
— 複数個の範囲の `range-set$p を指示するよう —
一義化する。
拡張~文法を範囲~指定子の中に移動することは、`~byte範囲$に特有な~protocolを別々に指定することも許容する。
◎
Refactored the range-unit and ranges-specifier grammars to simplify and reduce artificial distinctions between bytes and other (extension) range units, removing the overlapping grammar of other-range-unit by defining range units generically as a token and placing extensions within the scope of a range-spec (other-range). This disambiguates the role of list syntax (commas) in all range sets, including extension range units, for indicating a range-set of more than one range. Moving the extension grammar into range specifiers also allows protocol specific to byte ranges to be specified separately.
</p>

		</section>
		<section id="changes.from.rfc.7235">
<h3 title="Changes from RFC 7235">B.6. RFC 7235 からの変更点</h3>

<p lang="en-x-a0">None yet.</p>

		</section>
		<section id="changes.from.rfc.7538">
<h3 title="Changes from RFC 7538">B.7. RFC 7538 からの変更点</h3>

<p lang="en-x-a0">None yet.</p>

		</section>
		<section id="changes.from.rfc.7615">
<h3 title="Changes from RFC 7615">B.8. RFC 7615 からの変更点</h3>

<p lang="en-x-a0">None yet.</p>

		</section>
		<section id="changes.from.rfc.7694">
<h3 title="Changes from RFC 7694">B.9. RFC 7694 からの変更点</h3>

<p>
この仕様は、
`RFC7694$r により定義された拡張を含む
— その［
§ 例,
§ 配備~上の考慮点
］は、割愛するが。
◎
This specification includes the extension defined in [RFC7694], but leaves out examples and deployment considerations.
</p>

		</section>
	</section>
	<section id="change.log">
<h2 title="Change Log">付録 C. 変更~log</h2>

<p>
この節は、 RFC として発行する前に除去されることになる。
◎
This section is to be removed before publishing as an RFC.
</p>

【以下、この節は未訳。】

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
~HTTP11のこの版は、
`RFC1945$r,
`RFC2068$r,
`RFC2145$r,
`RFC2616$r
`RFC2818$r
に取り込まれた多くの貢献の上に築かれている。
~~価値ある貢献には、次に挙げる以前の策定者や編集者,
Working Group Chairs としてこの仕事を見渡した人達によるものも含まれる
⇒
`Tim Berners-Lee, Jean-François Groff, Ari Luotonen, Roy T. Fielding, Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter, Paul J. Leach, Eric Rescorla, and Yves Lafon^en
◎
This edition of the HTTP specification builds on the many contributions that went into RFC 1945, RFC 2068, RFC 2145, RFC 2616, and RFC 2818, including substantial contributions made by the previous authors, editors, and Working Group Chairs: Tim Berners-Lee, Jean-François Groff, Ari Luotonen, Roy T. Fielding, Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter, Paul J. Leach, Eric Rescorla, and Yves Lafon.
</p>

<p>
先立つ各~改訂の謝辞については `RFC7230/10$sec を見よ。
◎
See Section 10 of [RFC7230] for further acknowledgements from prior revisions.
</p>

<p>
加えて，この文書は、以前まで RFC 7235, RFC 2617 にて定義されていた~HTTP認証~frameworkを組入れた。
次の方々による，その仕様の作業に感謝する（さらなる謝辞については `RFC2617/5$sec を見よ）
⇒
`John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart^en
◎
In addition, this document has reincorporated the HTTP Authentication Framework, previously defined in RFC 7235 and RFC 2617. We thank John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for their work on that specification. See Section 6 of [RFC2617] for further acknowledgements.
</p>

<p>
`[newacks: New acks to be added here.]^en
</p>

	</section>
	<section id="rfc.authors">
<h2 title="Authors' Addresses">著作者の~address</h2>

<p lang="en-x-a0" style="white-space:pre;">
Roy T. Fielding (editor)
Adobe
345 Park Ave
San Jose, CA 95110
United States of America
Email: fielding@gbiv.com
URI: https://roy.gbiv.com/

Mark Nottingham (editor)
Fastly
Prahran, VIC
Australia
Email: mnot@mnot.net
URI: https://www.mnot.net/

Julian F. Reschke (editor)
greenbytes GmbH
Hafenweg 16
Muenster, 48155
Germany
Email: julian.reschke@greenbytes.de
URI: https://greenbytes.de/tech/webdav/
</p>

	</section>
</main></div>
