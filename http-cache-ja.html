<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Caching （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options
spec_title:HTTP Caching
spec_date:2020-08-09
trans_update:2020-08-10
source_checked:200307
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html
abbr_url:HTTPcache
spec_status:IETFID
no_original_dfn:true
ref_rfc:true
trans_1st_pub:2019-11-22


●●class_map

●●tag_map


●●original_id_map

●●mdn_urls
field.age:HTTP/Headers/Age
field.cache-control:HTTP/Headers/Cache-Control
field.pragma:HTTP/Headers/Pragma
field.warning:HTTP/Headers/Warning
field.expires:HTTP/Headers/Expires

●●link_map

h.Content-MD5:~RFCx/rfc2616#section-14.15

	●指令

qdir.max-age:#cache-request-directive.max-age
qdir.max-stale:#cache-request-directive.max-stale
qdir.min-fresh:#cache-request-directive.min-fresh
qdir.no-cache:#cache-request-directive.no-cache
qdir.no-store:#cache-request-directive.no-store
qdir.no-transform:#cache-request-directive.no-transform
qdir.only-if-cached:#cache-request-directive.only-if-cached

sdir.max-age:#cache-response-directive.max-age
sdir.must-revalidate:#cache-response-directive.must-revalidate
sdir.must-understand:#cache-response-directive.must-understand
sdir.no-cache:#cache-response-directive.no-cache
sdir.no-store:#cache-response-directive.no-store
sdir.no-transform:#cache-response-directive.no-transform
sdir.private:#cache-response-directive.private
sdir.proxy-revalidate:#cache-response-directive.proxy-revalidate
sdir.public:#cache-response-directive.public
sdir.s-maxage:#cache-response-directive.s-maxage

	●用語
~cache:~HTTPcache#cache
~cache指令:~HTTPcache#cache-directive
~cache制御~指令:~HTTPcache#cache-directive
切断されて:~HTTPcache#disconnected

検証:#validation.model
検証-:#validation.model
再検証-:#validation.model
再検証:#validation.model
	検証ng:#validation.model
	再検証ng:#validation.model
新鮮:~HTTPcache#fresh
	新鮮であるresponse_is_fresh
非新鮮:~HTTPcache#stale
鮮度:~HTTPcache#expiration.model
	#freshness
鮮度維持期間:~HTTPcache#freshness-lifetime
失効時刻:~HTTPcache#expiration-time
明示的な失効時刻:#explicit-expiration-time
経験的な失効時刻:#heuristic-expiration-time
経験的:#heuristic.freshness

齢:#age
要請~指令:#cache-request-directive
応答~指令:#cache-response-directive
~cache制御 応答~指令:#cache-response-directive
被選定:#selected-response
被選定~応答:#selected-response
~cache~key:#cache-key
無効化-:#invalidate
~cache制御~拡張:#cache.control.extensions
	~cache拡張~token
共有-:#shared-cache
	非~error状態s~code:#non-error-status-code

cite.~cache指令~registry:~IANA-a/http-cache-directives

	●§
1.3:#delta-seconds
3:#response.cacheability
3.1:#storing.fields
3.3:#caching.authenticated.responses
3.4:#combining.responses
4:#constructing.responses.from.caches
4.1:#caching.negotiated.responses
4.2.2:#heuristic.freshness
4.2.3:#age.calculations
4.2.4:#serving.stale.responses
4.3.4:#freshening.responses
4.4:#invalidation
5.2:#field.cache-control
5.5:#field.warning
6:#history.lists
7.2:#security.timing
A:#collected.abnf
B:#changes.from.rfc.7234
C.12:#change.log

Messaging/6.3:~HTTPmsg#message.body.length
Semantics/5.4:~HTTPsem#field.values
Semantics/9.2.2:~HTTPrq#precedence
	Semantics/9.3:~HTTPrq#field.range
Semantics/10.1:~HTTPrs#overview.of.status.codes
Semantics/10.3.7.3:~HTTPrs#combining.byte.ranges
	＊？Messaging/13.1:~HTTPsem#field.connection
Semantics/謝辞:~HTTPsem#acks
Semantics/著作者の~address:~HTTPsem#rfc.authors

	●変数
V.齢~値:#age_value
V.滞在~時間:#resident_time
V.現在時:#now
V.現在~齢:#current_age
V.要請~時刻:#request_time
V.応答~時刻:#response_time
V.修正済み初期~齢:#corrected_initial_age
V.見かけ齢:#apparent_age

V.修正済み齢~値:#corrected_age_value
V.日時~値:#date_value
V.鮮度維持期間:#freshness_lifetime
V.応答~遅延:#response_delay
	V.response_is_fresh:#response_is_fresh

●●section_map

1:#caching
1.1:##intro.requirements
1.2:#notation
1.3:#delta-seconds
2:#caching.overview
3:#response.cacheability
3.2:#incomplete.responses
3.3:#caching.authenticated.responses
3.4:#combining.responses
4:#constructing.responses.from.caches
4.1:#caching.negotiated.responses
4.2:#expiration.model
4.2.1:#calculating.freshness.lifetime
4.2.2:#heuristic.freshness
4.2.3:#age.calculations
4.2.4:#serving.stale.responses
4.3:#validation.model
4.3.1:#validation.sent
4.3.2:#validation.received
4.3.3:#validation.response
4.3.4:#freshening.responses
4.3.5:#head.effects
4.4:#invalidation
5:#header.field.definitions
5.1:#field.age
5.2:#field.cache-control
5.2.1:#cache-request-directive
5.2.1.1:#cache-request-directive.max-age
5.2.1.2:#cache-request-directive.max-stale
5.2.1.3:#cache-request-directive.min-fresh
5.2.1.4:#cache-request-directive.no-cache
5.2.1.5:#cache-request-directive.no-store
5.2.1.6:#cache-request-directive.no-transform
5.2.1.7:#cache-request-directive.only-if-cached
5.2.2:#cache-response-directive
5.2.2.1:#cache-response-directive.must-revalidate
5.2.2.2:#cache-response-directive.must-understand
5.2.2.3:#cache-response-directive.no-cache
5.2.2.4:#cache-response-directive.no-store
5.2.2.5:#cache-response-directive.no-transform
5.2.2.6:#cache-response-directive.public
5.2.2.7:#cache-response-directive.private
5.2.2.8:#cache-response-directive.proxy-revalidate
5.2.2.9:#cache-response-directive.max-age
5.2.2.10:#cache-response-directive.s-maxage
5.2.3:#cache.control.extensions
5.3:#field.expires
5.4:#field.pragma
5.5:#field.warning
6:#history.lists
7:#security.considerations
7.2:#security.timing
8:#iana.considerations
	8.1:#
	8.2:#
	8.3:#
9:#rfc.references
A:#collected.abnf
B:#changes.from.rfc.7234
C.12:#change.log


Acknowledgments
Index
Authors' Addresses

●●words_table1

●●words_table

	●cache（時間
同期調整:skew::~::スキュー
失効時刻:expiration time::~
失効時期:expiry::~
時間帯:time zone::~
時間:time::~
	秒数:time in seconds:~
	足した:plusした:~
齢:age::~
経過-:pass:~
delta:
現在時:now:~
鮮度維持期間:freshness lifetime::~
分解能:resolution:~
総和:sum:~

	1 年:one-year
	~~期間:time
	~~未来でない:equal to or earlier than
	~~過去:less than
	ずっと早くに:far sooner
	一年以内:no more than a year in the future
	境に:before, or after
	旧:old
	無限:infinity
	迅速に:promptly
	UTC
	NTP

	●cache
refresh:::更新::リフレッシュ
reload:::再読み込み::リロード
	^en:canned
新鮮:fresh::~
	新鮮~化-:freshen
	新鮮~化法:freshening
非新鮮:stale::~
鮮度:freshness::~
切断-:disconnect:~
検証子:validator::~
検証ng:validating::検証
再検証-:revalidate::~
再検証ng:revalidating::再検証
有効:valid::~
再検証:revalidation::~
私用:private::~::プライベート
修正済み:corrected:~
滞在:resident:~
滞在-:reside:~
識別情報:identity:~

	完全なものに:complete
	`max^op:If the result is negative, the result is replaced by zero
	格納する前に:before storage

	●保安
増幅-:amplify:~
魅力的:attractive:~
配布-:distribute:~


	●仕様
略語:abbreviation:~
	最低限の:worst-case
都合よく:convenientに:~
契約:contract:~
否定的:negative:~
今日:today:~
素材:material:~
	再利用-法:reusing
下位system:subsystem:下位 system:下位システム
検査ng:checking:検査
見かけ:apparent:~
特質:property:~:::プロパティ
誤理解:misunderstanding:~
	~~処理:operation
	~~可能性:potential
	~~報告もなく実行されなかった:silently unexecuted
	~~妨げ:inhibit
	~~実用的な:sensible
	~~普段より:-
	~~確信を持てる:confident in
	かどうかが一貫でない:inconsistently
	ように見えても:believe
	一助:help
	不正になる可能性がある:possible incorrectness introduced
	付け加える~~可能性がある:expose additional potential
	判っている:have been demonstrated
	受信された／今の:presented
	度を越して:extremely
	必要とされない:not necessarily
	波及-:influence
	目的を以って:purposeful
	確からしい:plausible
	緊密に連携する:good internal connectivity
	考えられ:thought
	該当する:appropriate
	逆に:conversely
	重視され:matter す
	~~伝える:tell
	~~挙げられた:nominate
	広く行き渡って:widespread
	面する:surface

	●未分類
並替える:reorderする:並び替える
不揮発:non-volatile:~
揮発:volatile:~
提示-:present:~
通過中:transit 中:~
抹消:evict:~
金融取引:financial transaction:~
割合:fraction:~
返信:reply:~
	現在:current:~
接触-:contact:~
変形-:transform:~
最新状態:up to date:~
単方向:unidirectional:~
地域的:local:~:::ローカル
	置換:replacement
asset::::アセット
帯域外の:out-of-band:~
素早く:quickに:~
合成-:synthesize:~
消費器:consumer::~
消費:consumption:~

	^en:double keying
	member
	拾える:gleanできる
	“戻る” "Back"
	そのまま書き出:write through
	保持:hold
	欠く:missing
	渡り歩く:travels through
	通過:pass through
	通過中:in transit
	過ぎていない:earlier than or equal to
	発する:emit

	●言い換え
	表示し直す:redisplay
	再利用-可能:reusable
	より強い:stronger
	強く禁制され:have stronger prohibitions
	生じる:create
	格納できる:caching of
	引数を伴う:qualified form
	引数を伴わない:unqualified／:unqualified form

	●指示語
	A:first
	B:second
	ある種の:some
	こともある:sometimes
	それ以外の:remaining
	~~以前に:earlier
	より大きい:greater
	一部分:part
	作り上げ:make
	全体が収まる:wholly within
	全面的に／全く:entirely
	大部分:Much of
	残りの部分:rest

●●ref_normative

[Messaging]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP/1.1 Messaging”, Internet-Draft (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-messaging-latest.html
[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, ~RFC2119, March 1997
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, ~RFC3986, January 2005
[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, ~RFC5234, January 2008
[RFC7405]
    Kyzivat, P., “Case-Sensitive String Support in ABNF”, ~RFC7405, December 2014
[RFC8174]
    Leiba, B., “Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words”, BCP 14, ~RFC8174, May 2017
[Semantics]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP Semantics”, Internet-Draft (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
[USASCII]
    American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI X3.4, 1986.

●●ref_informative

[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, ~RFC2616, June 1999
[RFC5861]
    Nottingham, M., “HTTP Cache-Control Extensions for Stale Content”, ~RFC5861, April 2010
[RFC5905]
    Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, “Network Time Protocol Version 4: Protocol and Algorithms Specification”, ~RFC5905, June 2010
[RFC6265]
    Barth, A., “HTTP State Management Mechanism”, ~RFC6265, April 2011
[RFC7234]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP): Caching”, ~RFC7234, June 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, ~RFC8126, June 2017


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による， Internet-Draft
<a href="~SPEC_URL">HTTP Caching</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
発行者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	7234 （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集
	R. Fielding, Editor (Adobe)
	M. Nottingham, Editor (Fastly)
	J. Reschke, Editor (greenbytes)

履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache
commit 履歴
	<a href="https://github.com/httpwg/http-core/commits/master">GitHub</a>
HTTP working group mailing list
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
Draft HTTP Core Documents
	https://github.com/httpwg/http-core

</script>

</head>
<body>


<header>
	<hgroup>
<h1 title="HTTP Semantics">HTTP キャッシュ法（ Caching ）</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、分散型の協調的な~hypertext情報~system用の，`~stateless$な応用~levelの~protocolである。
この文書は、 ~HTTP~cacheと~~関連の［
~cacheの挙動を制御する／
~cache可能な応答~messageを指示する
］各種~headerを定義する。
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.
</p>

<p>
この文書は、 `RFC7234$r を廃用にする。
◎
This document obsoletes RFC 7234.
</p>

	</section>
	<section id="rfc.note.1">
<h2 title="Editorial Note">編集上の注記</h2>

<p>
この注記は、~RFCとして発行する前に除去されることになる。
◎
This note is to be removed before publishing as an RFC.
</p>

<p>
この草案について論を交わす場, この草案の~source~codeや課題~listは、冒頭の仕様~metadataから見出せる。
◎
Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;https://lists.w3.org/Archives/Public/ietf-http-wg/&gt;.
◎
Working Group information can be found at &lt;https://httpwg.org/&gt;; source code and issues list for this draft can be found at &lt;https://github.com/httpwg/http-core&gt;.
</p>

<p>
この草案における変更点は、 `C.12$sec に要約されている。
◎
The changes in this draft are summarized in Appendix C.12.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>に委譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en-x-a0">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に委譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="caching">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、［
~networkに基づく，~hypertext情報~system
］と柔軟にヤリトリするために［
拡張-可能な意味論, および自己-記述的な~message
］を利用する，`~stateless$な応用~levelの［
要請, 応答
］~protocolである。
~HTTPは、次に挙げる［
`~HTTP11$仕様を総集的に形成する一連の文書
］により定義される
⇒＃
<a href="~HTTPsem">~HTTP意味論</a> `Semantics$r,
~HTTP~cache法（この文書）,
<a href="~HTTPmsg">~HTTP11~message法</a> `Messaging$r
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP is defined by a series of documents that collectively form the HTTP/1.1 specification:
• "HTTP Semantics" [Semantics]
• "HTTP Caching" (this document)
• "HTTP/1.1 Messaging" [Messaging]
</p>

<p>
~HTTPは、概して，分散型の情報~system用に利用される
— 応答~cacheをそこで利用すれば、処理能は改善され得る。
この文書は、~HTTPに関係する，応答~messageの~cache法と再利用-法を成す側面を定義する。
◎
HTTP is typically used for distributed information systems, where the use of response caches can improve performance. This document defines aspects of HTTP related to caching and reusing response messages.
</p>

<p>
~HTTP
`~cache@
は、応答~messageの局所的な格納域であり，その中に格納される~messageたちの［
~storage, 検索取得, 削除
］を制御する下位systemである。
~cacheは、未来の等価な要請に対する［
応答~時間や~network帯域幅の消費
］を抑制するために，~cache可能な応答を格納する。
どの［
`~client$／`~server$
］も，~cacheを利用してヨイ
— `~tunnel$として動作している~serverは、~cacheを利用し得ないが。
◎
An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. A cache stores cacheable responses to reduce the response time and network bandwidth consumption on future equivalent requests. Any client or server MAY use a cache, though a server that is acting as a tunnel cannot.
</p>

<p>
`共用~cache@
は、［
複数の利用者が再利用するための応答
］を格納する~cacheである
— それは、（常にではないが）通例的に，`中継者$の一部分として配備される。
対照的に，
`私用~cache@
は、単独の利用者ごとに専用であり，~UAの~componentとして配備されることが多い。
◎
A shared cache is a cache that stores responses for reuse by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary. A private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.
</p>

<p>
~HTTP~cachingの目標は、先立つ応答~messageを再利用して，現在の要請を満足することにより、処理能を有意に改善することである。
~cacheは、自身に格納-済みな応答を
— `鮮度$secにて定義されるように —
`検証$（`生成元~server$による［
この要請~用の~cache済み応答が有効であり続ける
］かどうかの検査ng
）を伴わずに再利用できるならば，`新鮮$であると見なす。
したがって，`新鮮$な応答は、~cacheがそれを再利用する度に，遅延, ~network~overheadの両者を抑制し得る。
~cache済み応答は、`新鮮$でないときでも，［
`検証$により新鮮~化できる／生成元~serverが可用でない
］ときは再利用できることもある（ `4.2.4$sec ）。
◎
HTTP caching's goal is significantly improving performance by reusing a prior response message to satisfy a current request. A cache considers a stored response "fresh", as defined in Section 4.2, if it can be reused without "validation" (checking with the origin server to see if the cached response remains valid for this request). A fresh response can therefore reduce both latency and network overhead each time the cache reuses it. When a cached response is not fresh, it might still be reusable if validation can freshen it (Section 4.3) or if the origin is unavailable (Section 4.2.4).
</p>

<p class="trans-note">【
この仕様の語 “格納-済み（ `stored^en ）” は、 “~cacheに格納-済み” の略記として用いられている。
“~cache済み（ `cached^en ）” も同義と見受けられる。
】</p>

<p>
この文書は、 `RFC7234$r を廃用にする
— 変更点は、 `B$sec に要約されている。
◎
This document obsoletes RFC 7234, with the changes being summarized in Appendix B.
</p>

		<section id="intro.requirements">
<h3 title="Requirements Notation">1.1. 要件の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
適合性の判定基準, ~errorの取扱いに関する考慮点は、
`適合性$sec `Semantics$r
に定義される。
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
◎
Section 3 of [Semantics] defines conformance criteria and contains considerations regarding error handling.
</p>

		</section>
		<section id="notation">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#syntax-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
`A$sec にて、すべての~list演算子を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
◎
It also uses a list extension, defined in Section 5.5 of [Semantics], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition).＼
◎
Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
</p>

<p>
次に挙げる規則は `Semantics$r にて定義される
⇒＃
`HTTP-date$p,
`OWS$p,
`field-name$p,
`quoted-string$p,
`token$p,
◎
[Semantics] defines the following rules:
◎
HTTP-date     = &lt;HTTP-date, see [Semantics], Section 5.4.1.5&gt;
OWS           = &lt;OWS, see [Semantics], Section 1.6.1&gt;
field-name    = &lt;field-name, see [Semantics], Section 5.3&gt;
quoted-string = &lt;quoted-string, see [Semantics], Section 5.4.1.2&gt;
token         = &lt;token, see [Semantics], Section 5.4.1.1&gt;
</p>

		</section>
		<section id="delta-seconds">
<h3 title="Delta Seconds">1.3. ~delta秒</h3>

<p>
`delta-seconds$p 規則は、秒数を表現する，負でない整数を指定する。
◎
The delta-seconds rule specifies a non-negative integer, representing time in seconds.
</p>

<pre class="bnf">
`delta-seconds@p
    = 1*`DIGIT$P
</pre>

<p>
`受信者$は、［
`delta-seconds$p 値を構文解析して~binary形に変換する
］際には，［
少なくとも 31~bit以上, かつ負でない整数の範囲をとる，算術~型
］を利用する~OUGHT。
`delta-seconds$p 値を受信した~cacheは、その値が［
自身が表現できる最~大な整数より大きい, または
自身による後続の計算にて桁溢れする
］場合には，［
2147483648（ 2 の 31 乗）, または
都合よく表現できる最~大な正な整数
］と見なさなければナラナイ。
◎
A recipient parsing a delta-seconds value and converting it to binary form ought to use an arithmetic type of at least 31 bits of non-negative integer range. If a cache receives a delta-seconds value greater than the greatest integer it can represent, or if any of its subsequent calculations overflows, the cache MUST consider the value to be 2147483648 (2^31) or the greatest positive integer it can conveniently represent.
</p>

<p class="note">注記：
ここでの値 2147483648 は、歴史的な理由による
— それは無限（ 68 年~以上）を表現する。
この値は~binary形として格納される必要はない
— 実装は、［
その数を直に表現できないような算術~型により計算が遂行される
］ときでも、桁溢れが生じた場合には， `canned^en 文字列†として生産できる。
ここで~~重視されるのは、桁溢れが検出され，今後の計算において負な値に扱われないことである。
【† ある上限~整数を表現する定義済み文字列（ `canned data^en ／ “缶詰にされた” ）？】
◎
Note: The value 2147483648 is here for historical reasons, represents infinity (over 68 years), and does not need to be stored in binary form; an implementation could produce it as a canned string if any overflow occurs, even if the calculations are performed with an arithmetic type incapable of directly representing that number. What matters here is that an overflow be detected and not treated as a negative value in later calculations.
</p>

		</section>
	</section>
	<section id="caching.overview">
<h2 title="Overview of Cache Operation">2. ~cache運用の概観</h2>

<p>
~cacheを適正に運用することで、~HTTP転送の意味論（ `Semantics$r ）を保全しつつ，すでに~cache内に保持されている情報の転送を抑制できるようになる。
~HTTPにおける~cachingは，全面的に`任意選択^2119な特能であるが、［
~cache済み応答を再利用することは望ましいものであり、そのような再利用は，それを防止するような［
要件や局所的な環境設定
］が無ければ，既定の挙動である
］ものと見做せる。
したがって，~HTTP~cacheに課される要件は、~cacheに対し，［
特定0の応答を，常に格納して再利用する
］ことを義務付けるのではなく，［
再利用できない応答を格納すること ／
格納-済み応答を不適切に再利用すること
］を防止することに力点が置かれる。
◎
Proper cache operation preserves the semantics of HTTP transfers ([Semantics]) while reducing the transfer of information already held in the cache. Although caching is an entirely OPTIONAL feature of HTTP, it can be assumed that reusing a cached response is desirable and that such reuse is the default behavior when no requirement or local configuration prevents it. Therefore, HTTP cache requirements are focused on preventing a cache from either storing a non-reusable response or reusing a stored response inappropriately, rather than mandating that caches always store and reuse particular responses.
</p>

<p>
`~cache~key@
の基底を成すものは、格納-済み応答を検索取得するために利用された［
`要請~method$,
`~target~URI$
］である
— ~methodは、［
その応答は，どの状況下で要請を満足するために利用できるか
］を決定する。
しかしながら，今日における多くの~HTTP~cacheの共通的な利用では、［
`GET$m に対する応答のみを~cacheして，他の~methodは回送している
］ので，~cache~keyとして~URIしか利用していない。
◎
The base cache key comprises the request method and target URI used to retrieve the stored response; the method determines under which circumstances that response can be used to satisfy a request. However, many HTTP caches in common use today only cache GET responses, and therefore only use the URI as the cache key, forwarding other methods.
</p>

<p>
`~target資源$【！要請~target】が`内容~折衝$の~subjectである場合、~cacheは，それ用に複数の応答を格納するかもしれない。
~cacheは、元の要請の`選定用~header$の値も
— `4.1$sec に従って —
~cache~keyの中に組入れることにより，これらの応答を相違化する。
◎
If a request target is subject to content negotiation, the cache might store multiple responses for it. Caches differentiate these responses by incorporating values of the original request's selecting header fields into the cache key as well, as per Section 4.1.
</p>

<p>
~cacheは、~cache~keyの中に追加的な素材を組入れるかもしれない。
例えば，~UA~cacheは、ある種の~privacy~riskを避けるため，参照元~siteの同一性も内包して~cache~keyを “二重化する” かもしれない（ `7.2$sec を見よ）。
◎
Caches might incorporate additional material into the cache key. For example, user agent caches might include the referring site's identity, thereby "double keying" the cache to avoid some privacy risks (see Section 7.2).
</p>

<p>
~cacheが最も共通的に格納するのは、検索取得~要請に対する成功裡な結果
— すなわち、 `GET$m 要請に対する `200$st 応答であって，`~target資源$の`表現$を包含するもの —
である。
しかしながら，［
~redirect／
否定的な結果（例： `404$st ）／
`不完全$【または部分的】な結果（例： `206$st ）／
`GET$m 以外の~methodに対する応答
］を格納することもアリである
— 当の~methodの定義が、そのような~cache法を許容していて，~cache~key用の利用に相応しい何かを定義するならば。
◎
Most commonly, caches store the successful result of a retrieval request: i.e., a 200 (OK) response to a GET request, which contains a representation of the target resource (Section 8.3.1 of [Semantics]). However, it is also possible to store redirects, negative results (e.g., 404 (Not Found)), incomplete results (e.g., 206 (Partial Content)), and responses to methods other than GET if the method's definition allows such caching and defines something suitable for use as a cache key.
</p>

<p>
~cacheは、［
`生成元~server$に接触できないか, 要請を回送する経路を見出せなくなった
］とき，
`切断されて@
いるとされる。
`切断されて$いる~cacheであっても、一部の状況下では`非新鮮$な応答を~serveし得る（ `4.2.4$sec ）。
◎
A cache is disconnected when it cannot contact the origin server or otherwise find a forward path for a request. A disconnected cache can serve stale responses in some circumstances (Section 4.2.4).
</p>

	</section>
	<section id="response.cacheability">
<h2 title="Storing Responses in Caches">3. ~cache内への応答の格納-法</h2>

<p>
要請に対する応答を~cacheが格納し得るのは、次のいずれも満たされる場合に限られる
— 他の応答は格納してはナラナイ：
◎
A cache MUST NOT store a response to a request unless:
</p>
<ul>
	<li>
~cacheは、`要請~method$を解する。†
◎
the request method is understood by the cache;
</li>
	<li>
応答は`最終-応答$である。
◎
the response status code is final (see Section 10 of [Semantics]);
</li>
	<li>
`応答~状態s~code$は［
`206$st0 ／ `304$st0
］であるか, または
`must-understand$sdir ~cache指令が在って，~cacheは`応答~状態s~code$を解する。†
◎
if the response status code is 206 or 304, or the "must-understand" cache directive (see Section 5.2) is present: the cache understands the response status code;
</li>
	<li>
応答~内に `no-store$sdir `~cache指令$は無い。
◎
the "no-store" cache directive is not present in the response (see Section 5.2);
</li>
	<li>
<p>
~cacheが`共用~cache$である場合は、次のいずれも満たされる：
◎
↓</p>
		<ul>
			<li>
`private$sdir 応答~指令は、応答~内に無いか，応答~内に在って［
`共用~cache$が改変された応答を格納する
］ことを許容する
◎
if the cache is shared: the "private" response directive is either not present or allows a shared cache to store a modified response; see Section 5.2.2.7);
</li>
			<li>
［
要請~内に `Authorization$h ~headerは無い
］または［
要請~内に［
`共用~cache$に~cacheすることを明示的に許容する応答~指令
］が在る（ `3.3$sec を見よ）
］
◎
if the cache is shared: the Authorization header field is not present in the request (see Section 9.5.3 of [Semantics]) or a response directive is present that explicitly allows shared caching (see Section 3.3); and,
</li>
		</ul>
	</li>
	<li>
<p>
応答は、次に挙げるいずれかを包含する：
◎
the response contains at least one of:
</p>
		<ul>
			<li>
`public$sdir 応答~指令
◎
a public response directive (see Section 5.2.2.6);
</li>
			<li>
`共用~cache$でない場合に限り：
`private$sdir 応答~指令
◎
a private response directive, if the cache is not shared (see Section 5.2.2.7);
</li>
			<li>
`Expires$h ~header
◎
an Expires header field (see Section 5.3);
</li>
			<li>
`max-age$sdir 応答~指令
◎
a max-age response directive (see Section 5.2.2.9);
</li>
			<li>
`共用~cache$である場合に限り：
`s-maxage$sdir 応答~指令
◎
if the cache is shared, an s-maxage response directive (see Section 5.2.2.10);
</li>
			<li>
~cacheされることを許容する，`~cache制御~拡張$
◎
a Cache Control Extension that allows it to be cached (see Section 5.2.3); or,
</li>
			<li>
`経験的に~cache可能$であるものと定義された`状態s~code$
◎
a status code that is defined as heuristically cacheable (see Section 4.2.2).
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`~cache制御~拡張$は、上に挙げた どの要件も上書きし得る。
◎
Note that a cache-control extension can override any of the requirements listed; see Section 5.2.3.
</p>

<p>†
この文脈においては、~cacheは，［
`要請~method$／`応答~状態s~code$
を認識した上で，［
指定された，~cachingに関係する挙動
］すべてを実装する
］ならば、それを “解する” とされる。
◎
In this context, a cache has "understood" a request method or a response status code if it recognizes it and implements all specified caching-related behavior.
</p>

<p class="note">注記：
通常の運用においては、一部の~cacheは，~cache検証子も`明示的な失効時刻$も無い応答を，格納しない
— そのような応答は、通例的に，格納しても有用にならないので。
しかしながら、~cacheがそのような応答を格納することも，禁制されない。
◎
Note that, in normal operation, some caches will not store a response that has neither a cache validator nor an explicit expiration time, as such responses are not usually useful to store. However, caches are not prohibited from storing such responses.
</p>

		<section id="storing.fields">
<h3 title="Storing Header and Trailer Fields">3.1. ~header／~trailerの格納-法</h3>

<p>
~cacheは、応答を格納するときには，受信した~headerすべてを
— 認識しないものも含めて —
含めなければナラナイ。
これは、新たな~HTTP~header~fieldが成功裡に配備できることを確約する。
しかしながら，次に挙げる例外がある：
◎
Caches MUST include all received header fields — including unrecognised ones — when storing a response; this assures that new HTTP header fields can be successfully deployed. However, the following exceptions are made:
</p>
<ul>
	<li>
［
`Connection$h ~header, その`~field値$に~listされた名前の~field
］は、~messageを回送する前に除去することが要求される（
§ `Connection$h
【！Section 13.1 of [Messaging]】
）。
これは、格納する前にそうするよう実装してもヨイ。
◎
The Connection header field and fields whose names are listed in it are required by Section 13.1 of [Messaging] to be removed before forwarding the message. This MAY be implemented by doing so before storage.
</li>
	<li>
同様に，一部の~fieldの意味論は、~messageを回送する前に除去するよう要求する
— これは、格納する前にそうするよう実装してもヨイ。
例えば，
§ `Connection$h【！Section 13.1 of [Messaging]】
に挙げられたものなど。
◎
Likewise, some fields' semantics require them to be removed before forwarding the message, and this MAY be implemented by doing so before storage; see Section 13.1 of [Messaging] for some examples.
</li>
	<li>
~clientの~proxy環境設定に特有な~headerは、格納してはナラナイ
— ただし、~cacheが当の~proxyの識別情報を~cache~keyの中に組入れる場合は除く。
これは、実質的に，次に挙げるものに制限される
⇒＃
`Proxy-Authenticate$h,
`Proxy-Authentication-Info$h,
`Proxy-Authorization$h
◎
Header fields that are specific to a client's proxy configuration MUST NOT be stored, unless the cache incorporates the identity of the proxy into the cache key. Effectively, this is limited to Proxy-Authenticate (Section 11.3.2 of [Semantics]), Proxy-Authentication-Info (Section 11.3.4 of [Semantics]), and Proxy-Authorization (Section 9.5.4 of [Semantics]).
</li>
</ul>

<p>
~cacheは、~trailerを［
~headerとは別々に格納しても，破棄しても
］ヨイ。
~cacheは、~trailerを~headerと`結合-$してはナラナイ。
◎
Caches MAY either store trailer fields separate from header fields, or discard them. Caches MUST NOT combine trailer fields with header fields.
</p>

		</section>
		<section id="incomplete.responses">
<h3 title="Storing Incomplete Responses">3.2. 不完全な応答の格納-法</h3>

<p>
~cacheは、［
`要請~method$は `GET$m, かつ
`応答~状態s~code$は `200$st, かつ
応答の`~header節$については~~全体が受信された
］場合には，`完全$でない応答~本体を
— 格納される応答を不完全であると記録した上で —
格納してもヨイ。
同様に， `206$st 応答についても、それが`不完全$な `200$st 応答であったかのように格納してヨイ。
しかしながら~cacheは、［
`Range$h, `Content-Range$h
］~headerを~supportしない, または［
それらの~headerに利用される`範囲~単位$を解さない
］ならば，内容が［
`不完全$／`部分的$
］な応答を格納してはナラナイ。
◎
If the request method is GET, the response status code is 200 (OK), and the entire response header section has been received, a cache MAY store a response body that is not complete (Section 2.1 of [Semantics]) if the stored response is recorded as being incomplete. Likewise, a 206 (Partial Content) response MAY be stored as if it were an incomplete 200 (OK) response. However, a cache MUST NOT store incomplete or partial-content responses if it does not support the Range and Content-Range header fields or if it does not understand the range units used in those fields.
</p>

<p class="trans-note">【
すなわち，格納-済み応答においては、`不完全$か`部分的$かは区別されず，いずれにせよ（`部分的な応答$であるかのように）範囲を記録することになる。
】</p>

<p>
~cacheは、［
後続して`範囲~要請$を為すことにより得られた成功裡な応答
］を［
`3.4$sec に従って，格納-済み応答たちと結合する
］ことにより，`不完全$な格納-済み応答を`完全$なものにしてもヨイ。
◎
A cache MAY complete a stored incomplete response by making a subsequent range request (Section 9.3 of [Semantics]) and combining the successful response with the stored response, as defined in Section 3.4.＼
</p>

<p>
~cacheは、次のいずれかに該当する場合を除き，`不完全$な応答を 要請に対する回答に利用してはナラナイ：
◎
A cache MUST NOT use an incomplete response to answer requests unless＼
</p>
<ul>
	<li>
応答は【前~段落に述べたように】完全なものにされた。
◎
the response has been made complete, or＼
</li>
	<li>
当の要請は、部分的【`範囲~要請$】であって，［
`不完全$な応答の中に全体が収まるような範囲
］を指定している。
`~client$へ送信する`不完全$な応答は、状態s~code `206$st を利用して，明示的に`部分的な応答$であるものと~markしなければナラナイ。
◎
the request is partial and specifies a range wholly within the incomplete response. A cache MUST NOT send a partial response to a client without explicitly marking it using the 206 (Partial Content) status code.
</li>
</ul>

		</section>
		<section id="caching.authenticated.responses">
<h3 title="Storing Responses to Authenticated Requests">3.3. 認証-済み要請に対する応答の格納-法</h3>


<div class="p">
<p>
`共用~cache$は、［
`Authorization$h ~headerを伴う要請に対する~cache済み応答
］を利用して，後続の要請を満足してはナラナイ
— ただし、次がすべて満たされる場合は除く：
</p>
<ul>
	<li>
当の応答は， `Cache-Control$h ~fieldを包含していて、その`~field値$は，［
当の応答を格納することを許容する`応答~指令$
］を伴う
</li>
	<li>
~cacheは、前項に該当するどの指令に対しても，［
その指令よる，当の応答に対する要件
］に適合する
</li>
</ul>
◎
A shared cache MUST NOT use a cached response to a request with an Authorization header field (Section 9.5.3 of [Semantics]) to satisfy any subsequent request unless the response contains a Cache-Control field with a response directive (Section 5.2.2) that allows it to be stored by a shared cache and the cache conforms to the requirements of that directive for that response.
</div>

<p>
この仕様においては、次に挙げる`応答~指令$に，そのような効果がある
⇒＃
`must-revalidate$sdir,
`public$sdir,
`s-maxage$sdir
◎
In this specification, the following response directives have such an effect: must-revalidate (Section 5.2.2.1), public (Section 5.2.2.6), and s-maxage (Section 5.2.2.10).
</p>

		</section>
		<section id="combining.responses">
<h3 title="Combining Partial Content">3.4. 部分的な内容の結合-法</h3>

<p>
応答は、接続が尚早に~closeされた, または
要請が 1 個~以上の `Range$p 指定子を利用した場合に、`部分的$な表現のみを転送することがある。
そのような転送が何度か行われたとき、~cacheは，同じ表現のいくつかの範囲を受信し得る。
~cacheは、これらの範囲を，［
それらすべてが同じ`強い検証子$を共有する, かつ
~cacheが `Semantics/10.3.7.3$sec に与える~client要件に準拠する
］ならば、単独の格納-済み応答に結合して，その応答を今後の要請を満足するために再利用してもヨイ。
◎
A response might transfer only a partial representation if the connection closed prematurely or if the request used one or more Range specifiers (Section 9.3 of [Semantics]). After several such transfers, a cache might have received several ranges of the same representation. A cache MAY combine these ranges into a single stored response, and reuse that response to satisfy later requests, if they all share the same strong validator and the cache complies with the client requirements in Section 10.3.7.3 of [Semantics].
</p>

<p>
~cacheは，［
新たな応答と 1 個~以上の格納-済み応答とを結合する
］ときは、新たな応答~内に供された他の~header
— ただし， `Content-Range$h は除く —
で，［
格納-済み応答~内の対応する~headerすべての~instance
］を置換しなければナラナイ。
◎
When combining the new response with one or more stored responses, a cache MUST use the header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.
</p>

		</section>
	</section>
	<section id="constructing.responses.from.caches">
<h2 title="Constructing Responses from Caches">4. ~cacheからの応答の構築-法</h2>

<p>
受信した `要請^V に対し，~cacheが自身に格納-済みな応答（以下，単に `応答^V ）を再利用できるためには、次のすべてが満たされなければナラナイ：
◎
When presented with a request, a cache MUST NOT reuse a stored response, unless:
</p>
<ul>
	<li>
`応答^V の`~target~URI$と `要請^V に提示されたそれが合致する。
◎
The presented target URI (Section 6.1 of [Semantics]) and that of the stored response match, and
</li>
	<li>
`応答^V に結付けられている要請~methodは、 `応答^V を `要請^V 用に利用することを許容している。
◎
the request method associated with the stored response allows it to be used for the presented request, and
</li>
	<li>
`応答^V に~~挙げられた どの`選定用~header$（もしあれば）も，
`要請^V に提示されたそれに合致する（ `4.1$sec を見よ）
◎
selecting header fields nominated by the stored response (if any) match those presented (see Section 4.1), and
</li>
	<li>
`応答^V は成功裡に`検証-$されている, または
`応答^V は、 `no-cache$sdir 応答~cache指令を包含しない。
◎
the stored response does not contain the no-cache cache directive (Section 5.2.2.3), unless it is successfully validated (Section 4.3), and
</li>
	<li>
<p>
`応答^V は、次のいずれかを満たす：
◎
the stored response is either:
</p>
		<ul>
			<li>
`新鮮$である。
◎
fresh (see Section 4.2), or
</li>
			<li>
`非新鮮$であっても~serveすることが許容されている（ `4.2.4$sec ）。

◎
allowed to be served stale (see Section 4.2.4), or
</li>
			<li>
成功裡に`検証-$されている。
◎
successfully validated (see Section 4.3).
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
`~cache制御~拡張$は、上に挙げた どの要件も上書きし得る。
◎
Note that a cache-control extension can override any of the requirements listed; see Section 5.2.3.
</p>

<p>
~cacheは：
</p>
<ul>
	<li>
`検証$を伴わない要請を満足するために，格納-済み応答を利用するときには、［
格納-済み応答の `現在~齢$V に等しい値にされた `Age$h ~header
］を，応答~内に`生成し$なければナラナイ
— 応答~内にその~headerが在るならそれを置換して。
`4.2.3$sec を見よ。
◎
When a stored response is used to satisfy a request without validation, a cache MUST generate an Age header field (Section 5.1), replacing any present in the response with a value equal to the stored response's current_age; see Section 4.2.3.
</li>
	<li>
<p>
`安全$でない~methodを伴う要請に対しては、`生成元~server$に向けて，そのまま書き出さなければナラナイ
— すなわち，~cacheには、［
要請が回送されて, 対応する応答が受信される
］までは、そのような要請に対する返信を`生成する$ことは，許容されない。
◎
A cache MUST write through requests with methods that are unsafe (Section 8.2.1 of [Semantics]) to the origin server; i.e., a cache is not allowed to generate a reply to such a request before having forwarded the request and having received a corresponding response.
</p>

<p>
注記：
`安全$でない要請は、すでに格納-済みな応答を無効化し得る
— `4.4$sec を見よ。
◎
Also, note that unsafe requests might invalidate already-stored responses; see Section 4.4.
</p>
	</li>
	<li>
相応しい格納-済み応答が複数あるときは、（ `Date$h ~headerにより決定される）最も近過去のものを利用しなければナラナイ。
また，要請に
"`Cache-Control: max-age=0^c", あるいは
"`Cache-Control: no-cache^c"
を伴わせた上で回送して、利用する応答を一義化できる。
◎
When more than one suitable response is stored, a cache MUST use the most recent one (as determined by the Date header field). It can also forward the request with "Cache-Control: max-age=0" or "Cache-Control: no-cache" to disambiguate which response to use.
</li>
	<li>
`時計$が可用でないときは、格納-済み応答を，`再検証-$することなく利用してはナラナイ
— どの利用においても。
◎
A cache that does not have a clock available MUST NOT use stored responses without revalidating them upon every use.
</li>
</ul>

		<section id="caching.negotiated.responses">
<h3 title="Calculating Cache Keys with Vary">4.1. `Vary^h による~cache~keyの計算-法</h3>

<p>
~cacheが［
格納-済み応答により満足できるような，要請
］を受信したとき，その応答に `Vary$h ~headerが在る場合には、［
その`~field値$に~~挙げられた，すべての`選定用~header$
］について［
元の要請（すなわち，格納-済み応答に結付けられているもの）と
今の要請が，以下に述べるように合致する
］場合を除き，その応答を利用してはナラナイ：
◎
When a cache receives a request that can be satisfied by a stored response that has a Vary header field (Section 11.1.4 of [Semantics]), it MUST NOT use that response unless all the selecting header fields nominated by the Vary header field match in both the original request (i.e., that associated with the stored response), and the presented request.
</p>
<ul>
	<li>
<p>
所与の`選定用~header$に対し， 2 つの要請のそれが互いに合致するための必要十分条件は、［
それぞれの要請に，次に挙げるいくつかを適用することにより、一方の要請の`~field値$を他方のそれに変形できるとき
］と定義される：
◎
The selecting header fields from two requests are defined to match if and only if those in the first request can be transformed to those in the second request by applying any of:
</p>
		<ul>
			<li>
~headerの構文にて許容される所で，空白を追加する／除去する。
◎
• adding or removing whitespace, where allowed in the header field's syntax
</li>
			<li>
同じ`~field名$を伴う複数の~headerを`結合-$する。
【！ `Semantics/5.4$sec  Semantics/5.1？ 】
◎
• combining multiple header fields with the same field name (see Section 5.4 of [Semantics])
</li>
			<li>
両~headerの`~field値$を、［
~headerの仕様に則って，意味論が一致することが既知である
］ような仕方で正規化する（例：［
順序が有意でない所では，`~field値$を並替える
］, ［
文字大小無視と定義されている所では，小文字（または大文字）のみに正規化する
］, 等々）。
◎
• normalizing both header field values in a way that is known to have identical semantics, according to the header field's specification (e.g., reordering field values when order is not significant; case-normalization, where values are defined to be case-insensitive)
</li>
		</ul>
	</li>
	<li>
（正規化を終えた後に，）対象の~headerが片方の要請にだけ在る場合、合致しないとする。
◎
If (after any normalization that might take place) a header field is absent from a request, it can only match another request if it is also absent there.
</li>
	<li>
どちらかの要請に `Vary$h ~headerが在って，その`~field値$を成す ある~memberに "`*^c" が在る場合、常に合致しない。
◎
A Vary header field value containing a member "*" always fails to match.
</li>
</ul>

<p>
格納-済み応答のうち，すべての`選定用~header$について合致するものは、
`被選定~応答@
と呼ばれる。
◎
The stored response with matching selecting header fields is known as the selected response.
</p>

<p>
複数の`被選定~応答$（ `Vary$h ~headerを伴わない応答も含む）が可用な場合、~cacheは，利用する 1 つを選ぶ必要がある。
`選定用~header$がそのための既知な仕組みを備える場合（例： `Accept$h や それに類する要請~header上の，`品質値$）、その仕組みが，選好される応答を選定するために利用されてもヨイ
— それ以外の所では、 `4$sec に従って（ `Date$h ~headerにより決定される）最も近過去の応答が利用される。
◎
If multiple selected responses are available (potentially including responses without a Vary header field), the cache will need to choose one to use. When a selecting header field has a known mechanism for doing so (e.g., qvalues on Accept and similar request header fields), that mechanism MAY be used to select preferred responses; of the remainder, the most recent response (as determined by the Date header field) is used, as per Section 4.
</p>

<p>
実施においては、応答~上に `Vary$h ~headerを送信するかどうかが一貫でない資源もあることに注意。
~cache内に所与の`~target~URI$用の応答が複数あって，
`Vary$h ~headerが省略されたものも混じっている場合、可用な空でない~field値のうち最も近過去なものを利用して，当の要請~用に適切な応答を選定するベキである。
◎
Note that in practice, some resources might send the Vary header field on responses inconsistently. When a cache has multiple responses for a target URI, and one or more omits the Vary header field, it SHOULD use the most recent non-empty value available to select an appropriate response for the request.
</p>

<p>
可用な`被選定~応答$が無い場合、~cacheは，提示された要請を満足できない
— その場合、概して，要請~内に示される`生成元~server$へ回送される（場合によっては条件付きにして — `検証$secを見よ）。
◎
If no selected response is available, the cache cannot satisfy the presented request. Typically, it is forwarded to the origin server in a (possibly conditional; see Section 4.3) request.
</p>

		</section>
		<section id="expiration.model">
<h3 title="Freshness">4.2. 鮮度</h3>

<p>
`齢$が`鮮度維持期間$を超過していない応答は、
`新鮮@
（ fresh ）であるとされる。
逆に，それを超過した応答は、
`非新鮮@
（ stale ）とされる。
◎
A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.
</p>

<p class="trans-note">【
この定義は，超過したかどうかを計算できることが前提にある。
（`4.2.4$sec の記述に従うなら、計算できない場合は，新鮮と見なされる？）
】</p>

<p>
応答の
`鮮度維持期間@
とは、［
それが`生成元~server$により`生成され$た時刻から，その`失効時刻$まで
］の~~期間である。
`失効時刻@
とは、それを過ぎて以降は，［
格納-済み応答は、更なる`検証$を伴わない限り，~cacheにより利用できない
］とされる時刻である。
`明示的な失効時刻@
とは、`生成元~server$が意図する`失効時刻$である。
一方で，
`経験的な失効時刻@
とは、`明示的な失効時刻$が可用でないときに，~cacheによりアテガわれる`失効時刻$である。
◎
A response's freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.
</p>

<p>
応答の
`齢@
とは、`生成元~server$により［
それが`生成され$た, もしくは
成功裡に`検証-$された
］ときから，経過した時間である。
◎
A response's age is the time that has passed since it was generated by, or successfully validated with, the origin server.
</p>

<p>
~cache内の応答は、`新鮮$である間は［
`生成元~server$に接触することなく，後続の要請を満足する
］ために利用でき、それにより，効率性を改善させる。
◎
When a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.
</p>

<p>
`生成元~server$にとり，`鮮度$を決定するための首な仕組みは、［
`Expires$h ~header, または
`max-age$sdir 応答~指令
］を利用して，未来の`明示的な失効時刻$を供することである。
一般に，`生成元~server$は、［［
およそ，それまでは［
`表現$が意味論的に有意な仕方で変化しない
］と見込まれる
］ような、未来の`失効時刻$
］を，`明示的な失効時刻$として応答にアテガうことになる。
◎
The primary mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using either the Expires header field (Section 5.3) or the max-age response directive (Section 5.2.2.9). Generally, origin servers will assign future explicit expiration times to responses in the belief that the representation is not likely to change in a semantically significant way before the expiration time is reached.
</p>

<p>
`生成元~server$が、~cacheに対し，毎~要請ごとの`検証$を強制したいときには、過去を~~指す`明示的な失効時刻$をアテガって，応答がすでに`非新鮮$であることを指示できる。
準拠~cacheは、通常は，`非新鮮$な~cache済み応答を
— 後続の要請~用に再利用する前に —
`検証-$することになる（`4.2.4$sec を見よ）。
◎
If an origin server wishes to force a cache to validate every request, it can assign an explicit expiration time in the past to indicate that the response is already stale. Compliant caches will normally validate a stale cached response before reusing it for subsequent requests (see Section 4.2.4).
</p>

<p>
`生成元~server$は，`明示的な失効時刻$を常に供するとは限らないので、~cacheには，一定の状況下で，`失効時刻$を決定する経験則を利用することも許容される（ `4.2.2$sec を見よ）。
◎
Since origin servers do not always provide explicit expiration times, caches are also allowed to use a heuristic to determine an expiration time under certain circumstances (see Section 4.2.2).
</p>

<p>
応答は、［
`鮮度維持期間$V ~GT `現在~齢$V
］であるとき，
<dfn id="response_is_fresh">`新鮮$である</dfn>
ものと決定される。
◎
The calculation to determine if a response is fresh is:
◎
response_is_fresh = (freshness_lifetime &gt; current_age)
◎
freshness_lifetime is defined in Section 4.2.1; current_age is defined in Section 4.2.3.
</p>

<p>
`~client$は、［
`max-age$qdir や `min-fresh$qdir
］要請~指令を送信して，対応する応答に対する`鮮度$の計算を［
拘束する／緩める
］ことができる。
しかしながら，~cacheには、それらを尊守することは要求されてはいない。
◎
Clients can send the max-age or min-fresh request directives (Section 5.2.1) to constrain or relax freshness calculations for the corresponding response. However, caches are not required to honor them.
</p>

<p>
`日時$の構文解析-法に共通的にある問題を避けるため、~cache`受信者$は，鮮度を計算するときには：
◎
When calculating freshness, to avoid common problems in date parsing:
</p>
<ul>
	<li>
すべての`日時$ 形式は，文字大小区別として指定されているが、［
`day, week, time-zone^en
］の名前†は，文字大小無視で照合するベキである。
【† `day-name$p, `GMT$p の他に `month$p も含まれる？】
◎
• Although all date formats are specified to be case-sensitive, a cache recipient SHOULD match day, week, and time-zone names case-insensitively.
</li>
	<li>
自身の内部~実装による時刻の分解能が `HTTP-date$p 値のそれより粗い場合、構文解析した `Expires$h 日時を，［
受信した値を超えない最も近い時刻
］として，内部的に表現しなければナラナイ。【！＊】
◎
• If a cache recipient's internal implementation of time has less resolution than the value of an HTTP-date, the recipient MUST internally represent a parsed Expires date as the nearest time equal to or earlier than the received value.
</li>
	<li>
地域的な時間帯を，［
`齢$や`失効時刻$
］の［
計算, および比較
］に波及させてはナラナイ。
◎
• A cache recipient MUST NOT allow local time zones to influence the calculation or comparison of an age or expiration time.
</li>
	<li>
失効時刻の計算-時には、［［
"`GMT^c", "`UTC^c"
以外の時間帯 略語
］が伴われた`日時$
］は，無効と見なすベキである。
◎
• A cache recipient SHOULD consider a date with a zone abbreviation other than GMT or UTC to be invalid for calculating expiration.
</li>
</ul>

<p class="note">注記：
鮮度が適用されるのは、~cache運用に限られる
— 表示の~refreshや, `資源$の~reloadを~UAに強制する用途には利用できない。
~cacheと履歴の仕組みとの相違点は、 `6$sec に説明される。
◎
Note that freshness applies only to cache operation; it cannot be used to force a user agent to refresh its display or reload a resource. See Section 6 for an explanation of the difference between caches and history mechanisms.
</p>

			<section id="calculating.freshness.lifetime">
<h4 title="Calculating Freshness Lifetime">4.2.1. 鮮度維持期間の計算</h4>

<p>
~cacheは、［
次のうち，最初に合致する項目
］にて与える値を利用して，応答の`鮮度維持期間$を計算できる（その計算結果は、
`鮮度維持期間@V
と称される）：
◎
A cache can calculate the freshness lifetime (denoted as freshness_lifetime) of a response by using the first match of:
</p>
<ul>
	<li>
~cacheは`共有-$されている, かつ
`s-maxage$sdir 応答~指令が在る場合
⇒
その値
◎
• If the cache is shared and the s-maxage response directive (Section 5.2.2.10) is present, use its value, or
</li>
	<li>
`max-age$sdir 応答~指令が在る場合
⇒
その値
◎
• If the max-age response directive (Section 5.2.2.9) is present, use its value, or
</li>
	<li>
`Expires$h 応答~headerが在る場合
⇒
その値 ~MINUS `Date$h 応答~headerの値
◎
• If the Expires response header field (Section 5.3) is present, use its value minus the value of the Date response header field, or
</li>
	<li>
他の場合
⇒
応答~内には`明示的な失効時刻$は無い。
`経験的$な`鮮度維持期間$が適用-可能になり得る。
◎
• Otherwise, no explicit expiration time is present in the response. A heuristic freshness lifetime might be applicable; see Section 4.2.2.
</li>
</ul>

<p class="note">注記：
この計算は，時計~同期調整に脆弱でない
— すべての情報は、`生成元~server$から来るので。
◎
Note that this calculation is not vulnerable to clock skew, since all of the information comes from the origin server.
</p>

<p>
所与の指令~用の値が複数~在る場合（例：
複数の `Expires$h ~header,
複数の "`Cache-Control: max-age^c" 指令）、その指令の値は，無効と見なされる。
~cacheは、応答の`鮮度$~情報が無効な場合には，それを`非新鮮$と見なすことが奨励される。
◎
When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives), the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale.
</p>

			</section>
			<section id="heuristic.freshness">
<h4 title="Calculating Heuristic Freshness">4.2.2. 鮮度の経験的な計算-法</h4>

<p>
`生成元~server$は，常に`明示的な失効時刻$を供するとは限らない。
したがって，時刻が明示的に指定されていないときは、~cacheは，［
確からしい`失効時刻$を見積もる
］ために［
他の~header`~field値$（ `Last-Modified$h による時刻など）を利用する~algo
］を使役して，`経験的な失効時刻$をアテガってもヨイ。
この仕様は，特定の~algoは供さないが、それらの結果に対する~~最低限の拘束を課す。
◎
Since origin servers do not always provide explicit expiration times, a cache MAY assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other header field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but does impose worst-case constraints on their results.
</p>

<p>
~cacheは、格納-済み応答~内に`明示的な失効時刻$が在るときには，`鮮度$を決定する経験則を利用してはナラナイ。
何故なら， `3$sec による要件が意味するのは、経験則を利用し得るのは，明示的な鮮度を伴わない応答のうち［
`状態s~code$が
`経験的に~cache可能@
であると定義されたもの（例： `Semantics/10.1$sec ）／
明示的に`~cache可能$であると~markされたもの（例： `public$sdir 応答~指令により）
］に限られることなので。
◎
A cache MUST NOT use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3, this means that heuristics can only be used on responses without explicit freshness whose status codes are defined as "heuristically cacheable" (e.g., see Section 10.1 of [Semantics]), and those responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a "public" response directive).
</p>

<p>
以前までの仕様は、`応答~状態s~code$が`経験的に~cache可能$であることを， “既定で~cache可能” と称していたことに注意。
◎
Note that in previous specifications heuristically cacheable response status codes were called "cacheable by default."
</p>

<p>
応答に `Last-Modified$h ~headerが在る場合、~cacheには，［
その時刻から現在時までの時区間に対する ある割合
］を超えないような，経験的な失効~値を利用することが奨励される。
この割合の代表的な設定は `10%^ 程度になるであろう。
◎
If the response has a Last-Modified header field (Section 11.2.2 of [Semantics]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.
</p>

<p class="note">注記：
`RFC2616/13.9$sec では、［
~query成分を伴う~URI（すなわち， `?^c を包含する~URI）
］に対しては，~cacheによる`経験的$な鮮度の計算-法を禁制していたが、実施においては，これは広範に実装されていない。
したがって，`生成元~server$には、~cachingを防止したいと望む場合には，明示的な指令を送信することが奨励される（例：
`Cache-Control: no-cache^c
）。
◎
Note: Section 13.9 of [RFC2616] prohibited caches from calculating heuristic freshness for URIs with query components (i.e., those containing '?'). In practice, this has not been widely implemented. Therefore, origin servers are encouraged to send explicit directives (e.g., Cache-Control: no-cache) if they wish to prevent caching.
</p>

			</section>
			<section id="age.calculations">
<h4 title="Calculating Age">4.2.3. 齢の計算-法</h4>

<p>
`Age$h ~headerは、［
応答~messageが~cacheから得されるときに，見積もられた`齢$を伝達する
］ために利用される。
`Age$h ~header`~field値$は、~cacheにより見積もられた，［
`生成元~server$が，その応答を［
`生成し$た, または`検証-$した
］ときからの秒~数
］である。
したがって `Age^h 値は、応答が［
`生成元~server$からの経路~沿いにある，各~cache
］に滞在していた時間の総和と［
~network経路に沿って通過中の時間
］を足したものである。
◎
The Age header field is used to convey an estimated age of the response message when obtained from a cache. The Age field value is the cache's estimate of the number of seconds since the origin server generated or validated the response. The Age value is therefore the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the time it has been in transit along network paths.
</p>

<p>
`齢$の計算には次の~dataが利用される：
◎
Age calculation uses the following data:
</p>

<dl>
	<dt>【まず，以下の記述に利用される語の意味を補足する：】</dt>
	<dd class="trans-note">
		<dl>
			<dt>`応答^V</dt>
			<dd>
齢を計算する対象の，格納-済み応答。
</dd>
			<dt>`要請^V</dt>
			<dd>
`応答^V を格納-済みにさせた要請。
（原文の記述からは，はっきりしないが、成功裡に再検証させた要請があれば，それを指すようにも思われる。）
</dd>
			<dt>`~host^V</dt>
			<dd>
当の~cacheを使役している~HTTP通信の参加者。
</dd>
			<dt>`時計^V</dt>
			<dd>
`~host^V に局所的な時計。
</dd>

		</dl>
	</dd>

	<dt>`齢~値@V</dt>
	<dd>
`応答^V の `Age$h ~headerの値を，算術~演算に適切な形で表す値
— 可用でない場合†は 0。
【† 例えば、最も上流の~cacheが，その応答の再利用を初めて試みるとき】
◎
The term "age_value" denotes the value of the Age header field (Section 5.1), in a form appropriate for arithmetic operation; or 0, if not available.
</dd>

	<dt>`日時~値@V</dt>
	<dd>
`応答^V の `Date$h ~headerの値を，算術~演算に適切な形で表す値。
この~headerの定義, および それを伴わない応答に関する要件は、
§ `Date$h を見よ。
◎
The term "date_value" denotes the value of the Date header field, in a form appropriate for arithmetic operations. See Section 11.1.1 of [Semantics] for the definition of the Date header field, and for requirements regarding responses without it.
</dd>

	<dt>`現在時@V</dt>
	<dd>
`~host^V がこの計算を遂行している時点での， `時計^V の現在の値。
`~host^V は、［
NTP `RFC5905$r, または何らかの類似な~protocol
］を利用して， `時計^V を UTC（協定世界時, `Coordinated Universal Time^en ）に同期させる~OUGHT。
◎
The term "now" means "the current value of the clock at the host performing the calculation". A host ought to use NTP ([RFC5905]) or some similar protocol to synchronize its clocks to Coordinated Universal Time.
</dd>

	<dt>`要請~時刻@V</dt>
	<dd>
`要請^V が受信された時点での， `時計^V の値。
◎
The current value of the clock at the host at the time the request resulting in the stored response was made.
</dd>

	<dt>`応答~時刻@V</dt>
	<dd>
`応答^V が受信された時点での， `時計^V の値。
◎
The current value of the clock at the host at the time the response was received.
</dd>
</dl>

<p>
`応答^V の`齢$は、全く独立な 2 つの仕方で計算できる：
◎
A response's age can be calculated in two entirely independent ways:
</p>
<ul>
	<li>
`見かけ齢@V
⇒
`時計^V と`生成元~server$の`時計$とが，適度にきちんと同期されている場合に限り、次で与えられる
⇒
`max^op( 0, `応答~時刻$V ~MINUS `日時~値$V )
◎
the "apparent_age": response_time minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.
</li>
	<li>
<p>
`修正済み齢~値@V
⇒
`応答^V の経路~沿いにある どの~cacheも`~HTTP11$以上を実装する場合に限り、次で与えられる
⇒
`齢~値$V ~PLUS `応答~遅延^V；
`応答~遅延^V = ( `応答~時刻$V ~MINUS `要請~時刻$V )
</p>

<p>
~cacheは、この値を［
`応答^V が受信された時刻ではなく， `要請^V が起動された時刻
］から相対的に解釈しなければナラナイ。
◎
the "corrected_age_value", if all of the caches along the response path implement HTTP/1.1 or greater. A cache MUST interpret this value relative to the time the request was initiated, not the time that the response was received.
• apparent_age = max(0, response_time - date_value);
• response_delay = response_time - request_time;
• corrected_age_value = age_value + response_delay;
</p>
	</li>
</ul>

<p>
これらは，次のように結合される
⇒
`修正済み初期~齢@V = `max^op( `見かけ齢$V, `修正済み齢~値$V )
◎
These are combined as
• corrected_initial_age = max(apparent_age, corrected_age_value);
</p>

<p>
…ただし、~cacheが `Age$h ~headerの値（ `齢~値$V ）に~~確信を持てる場合（例えば，`応答^V の `Via$h ~header内に~HTTP10を示唆する hop がないなど）には、
`修正済み初期~齢$V の代わりに `修正済み齢~値$V を利用してもヨイ。
◎
unless the cache is confident in the value of the Age header field (e.g., because there are no HTTP/1.0 hops in the Via header field), in which case the corrected_age_value MAY be used as the corrected_initial_age.
</p>

<p>
以上により， `応答^V の `現在~齢$V を計算できる
— ［
`応答^V が`生成元~server$により最後に`検証-$されたとき
］から `修正済み初期~齢$V までの時間（秒）を加算して
⇒＃
`滞在~時間@V = `現在時$V ~MINUS `応答~時刻$V；
`現在~齢@V = `修正済み初期~齢$V ~PLUS `滞在~時間$V
◎
The current_age of a stored response can then be calculated by adding the time (in seconds) since the stored response was last validated by the origin server to the corrected_initial_age.
• resident_time = now - response_time;
• current_age = corrected_initial_age + resident_time;
</p>

			</section>
			<section id="serving.stale.responses">
<h4 title="Serving Stale Responses">4.2.4. 非新鮮な応答の~serve法</h4>

<p>
応答が`非新鮮$であるとは、［
明示的な失効時期~情報が在る, または
失効時期の`経験的$な計算が許容されている
］ものであって，`鮮度$の計算に則って`新鮮$でないとされたものになる。
◎
A "stale" response is one that either has explicit expiry information or is allowed to have heuristic expiry calculated, but is not fresh according to the calculations in Section 4.2.
</p>

<div class="p">
<p>
~cacheは、~protocol内の明示的な`~cache指令$
— 例えば，次に挙げる指令 —
により禁制されている場合は，`非新鮮$な応答を`生成し$てはナラナイ：
</p>
<ul><li>`no-store$qdir ／ `no-cache$qdir 要請~cache指令
</li><li>`no-store$sdir ／ `no-cache$sdir 応答~cache指令
</li><li>`must-revalidate$sdir 応答~cache指令
</li><li>適用-可能な `s-maxage$sdir ／ `proxy-revalidate$sdir 応答~cache指令
</li></ul>

◎
A cache MUST NOT generate a stale response if it is prohibited by an explicit in-protocol directive (e.g., by a "no-store" or "no-cache" cache directive, a "must-revalidate" cache-response-directive, or an applicable "s-maxage" or "proxy-revalidate" cache-response-directive; see Section 5.2.2).
</div>

<p>
~cacheは、次のいずれかに該当する場合を除き，`非新鮮$な応答を生成してはナラナイ：
◎
A cache MUST NOT generate a stale response unless＼
</p>
<ul>
	<li>
`切断されて$いる
◎
it is disconnected or＼
</li>
	<li>
そうすることが~clientまたは生成元~serverにより明示的に許可されている
— 例
⇒＃
`max-stale$qdir 要請~指令により／
拡張~指令により（ `RFC5861$r に定義されるものなど）／
帯域外の契約に則った環境設定により
◎
doing so is explicitly permitted by the client or origin server (e.g., by the max-stale request directive in Section 5.2.1, by extension directives such as those defined in [RFC5861], or by configuration in accordance with an out-of-band contract).
</li>
</ul>

			</section>
		</section>
		<section id="validation.model">
<h3 title="Validation">4.3. 検証</h3>

<div class="p">
<p>
~cacheが，［
要請された~URI用に 1 個以上の格納-済み応答が在る
］が、それらのどれをも~serveできないときは（例：
それらが`新鮮$でないとき, または
1 つに選定できない（ `4.1$sec を見よ）ことから
）、要請を回送する際に，`条件付き要請$の仕組みを利用して、`内方$にある次の~serverに，次を行う機会を与えることができる：
◎
When a cache has one or more stored responses for a requested URI, but cannot serve any of them (e.g., because they are not fresh, or one cannot be selected; see Section 4.1), it can use the conditional request mechanism Section 9.2 of [Semantics] in the forwarded request to give the next inbound server an opportunity＼
</p>
<ul>
	<li>
利用する有効な格納-済み応答を選定する。
◎
to select a valid stored response to use,＼
</li>
	<li>
処理nにおいて格納-済み~metadataを更新する。
◎
updating the stored metadata in the process, or＼
</li>
	<li>
格納-済み応答（たち）を新たな応答で置換する。
◎
to replace the stored response(s) with a new response.＼
</li>
</ul>

<p>
この処理nは、格納-済み応答の［
`検証ng^dfn ／
`再検証ng^dfn
］として知られている。
◎
This process is known as "validating" or "revalidating" the stored response.
</p>
</div>

			<section id="validation.sent">
<h4 title="Sending a Validation Request">4.3.1. 検証~要請の送信</h4>

<p>
~cacheは，`検証$用に`条件付き要請$を生成するときは、満足しようと試みている要請から開始するか，あるいは要請を独立に起動している場合は、格納-済み応答を利用して要請を合成する
— ［
`~method$,
`~target~URI$,
`Vary$h ~headerにより識別される要請~headerたち（`4.1$sec ）
］を複製することにより。
◎
When generating a conditional request for validation, a cache starts with either a request it is attempting to satisfy, or — if it is initiating the request independently — it synthesises a request using a stored response by copying the method, target URI, and request header fields identified by the Vary header field Section 4.1.
</p>

<p>
次に、1 つ以上の`事前条件~header$で，その要請を更新する。
これらは、同じ~cache~keyを持つ格納-済み応答（たち）を~sourceとする`検証子$~metadataを包含する。
◎
It then updates that request with one or more precondition header fields. These contain validator metadata sourced from stored response(s) that have the same cache key.
</p>

<p>
次に，`事前条件~header$は、`受信者$たちにより［
`資源$の現在の`表現$に等価な格納-済み応答が在るかどうか
］を決定するために比較される。
◎
The precondition header fields are then compared by recipients to determine whether any stored response is equivalent to a current representation of the resource.
</p>

<p>
そのような`検証子$の一つは、 `Last-Modified$h ~headerにて与えられる時刻印である
— それは、［
応答を`検証-$するために
`If-Modified-Since$h ~headerにて
］, あるいは［
`表現$を選定するために
`If-Unmodified-Since$h ／ `If-Range$h ~headerにて
］，利用できる（すなわち，~clientは、以前に得した［
その時刻印を伴う`表現$
］を，特に指している）。
◎
One such validator is the timestamp given in a Last-Modified header field (Section 11.2.2 of [Semantics]), which can be used in an If-Modified-Since header field for response validation, or in an If-Unmodified-Since or If-Range header field for representation selection (i.e., the client is referring specifically to a previously obtained representation with that timestamp).
</p>

<p>
`検証子$には、 `ETag$h ~field内に与えられる `entity-tag$p もある。
1 個~以上の格納-済み応答を指示する 1 個~以上の `entity-tag$p を、［
応答を`検証-$するためとして
`If-None-Match$h ~headerにて
］, あるいは［
`表現$を選定するためとして［
`If-Match$h ／ `If-Range$h
］~headerにて
］，利用できる（すなわち，~clientは、以前に得した［
~listされた `entity-tag$p を伴う， 1 個~以上の`表現$
］を，特に指している）。
◎
Another validator is the entity-tag given in an ETag field (Section 11.2.3 of [Semantics]). One or more entity-tags, indicating one or more stored responses, can be used in an If-None-Match header field for response validation, or in an If-Match or If-Range header field for representation selection (i.e., the client is referring specifically to one or more previously obtained representations with the listed entity-tags).
</p>

			</section>
			<section id="validation.received">
<h4 title="Handling a Received Validation Request">4.3.2. 受信された検証~要請の取扱い</h4>

<p>
要請の`連鎖$沿いにある 各`~client$は，自前の~cacheを備えることもあるので、`中継者$における~cacheが［
他の（`外方$にある）~cacheから`条件付き要請$を受信する
］ことは，共通的にある。
同様に，一部の~UAは、［
近過去に改変された`表現$に対しては ~data転送を制限する／
`部分的$に検索取得された表現の転送を完了する
］ために，`条件付き要請$を用立てる。
◎
Each client in the request chain may have its own cache, so it is common for a cache at an intermediary to receive conditional requests from other (outbound) caches. Likewise, some user agents make use of conditional requests to limit data transfers to recently modified representations or to complete the transfer of a partially retrieved representation.
</p>

<div class="p">
<p>
要請を受信した~cacheは、［
自身に格納-済みな［
`200$st ／ `206$st
］応答を再利用することで，それを満足できる
］ならば，［
要請~内に見出された`条件付き要請~header$たちによる`事前条件$のうち，自身に適用-可能なもの
］を［
`被選定~応答$の中に包含されている対応する`検証子$たち
］に対し評価するベキである
— ただし、次のいずれかに該当する事前条件は、評価してはナラナイ：
◎
If a cache receives a request that can be satisfied by reusing one of its stored 200 (OK) or 206 (Partial Content) responses, the cache SHOULD evaluate any applicable conditional header field preconditions received in that request with respect to the corresponding validators contained within the selected response.＼
A cache MUST NOT evaluate conditional header fields that＼
</p>
<ul>
	<li>
`生成元~server$に限り適用されるもの
◎
only apply to an origin server,＼
</li>
	<li>
当の要請は、次のいずれかに該当する
⇒＃
その意味論は、~cache済み応答では満足し得ない／
その`~target資源$用の格納-済み応答は無い
◎
occur in a request with semantics that cannot be satisfied with a cached response,＼
or occur in a request with a target resource for which it has no stored responses;＼
</li>
</ul>

<p>
これらの事前条件は、他の何らかの（`内方$にある）~server向けに意図されている見込みが高いので。
◎
such preconditions are likely intended for some other (inbound) server.
</p>

</div>

<p>
~cacheによる`条件付き要請$の適正な評価は、［
受信された`事前条件~header$たち, およびそれらの優先順（ `Semantics/9.2.2$sec ）
］に依存する。
条件付き~header［
`If-Match$h ／ `If-Unmodified-Since$h 
］は、~cacheには適用-可能でない。
◎
The proper evaluation of conditional requests by a cache depends on the received precondition header fields and their precedence, as defined in Section 9.2.2 of [Semantics]. The If-Match and If-Unmodified-Since conditional header fields are not applicable to a cache.
</p>

<p>
`If-None-Match$h ~headerを包含する要請は、［
`~client$が，自前の格納-済み応答（たち）と~cacheに格納-済みな`被選定~応答$（たち）とを
— 後者が何であれ —
比較して`検証-$するよう求めている
］ことを指示する。
その`~field値$が［
"`*^c" である, または［
`entity-tag$p の~listであって，そのうち いずれかが［
格納-済みな`被選定~応答$の `entity-tag$p
］に合致する
【すなわち，評価の結果が偽になる】
］］場合、~cache`受信者$は
— その合致した応答を送信する代わりに — 
（その応答の~metadataを利用して，） `304$st 応答を`生成する$ベキである。
◎
A request containing an If-None-Match header field (Section 9.2.4 of [Semantics]) indicates that the client wants to validate one or more of its own stored responses in comparison to whichever stored response is selected by the cache. If the field value is "*", or if the field value is a list of entity-tags and at least one of them matches the entity-tag of the selected stored response, a cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) instead of sending that stored response.
</p>

<div class="p">
<p>
~cacheは、［
`If-None-Match$h による`entity-tag$p の~list
— 以下， `L^V と記す —
を包含する要請
］用に，自前の格納-済み応答たちを`再検証-$するものと裁定したときには：
◎
When a cache decides to revalidate its own stored responses for a request that contains an If-None-Match list of entity-tags,＼
</p>
<ul>
	<li>
要請を回送する際に，その `If-None-Match$h ~header`~field値$を［
`L^V と［
各［
自前の格納-済み応答（`新鮮$か否かを問わず）
］の `entity-tag$p たちからなる~list
］とを結合した結果の和集合
］に置換して送信してもヨイ
— ただし，
◎
the cache MAY combine the received list with a list of entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement If-None-Match header field value in the forwarded request.＼
</li>
	<li>
`部分的$な内容を包含するような格納-済み応答の `entity-tag$p は、この和集合からは除外しなければナラナイ
— ただし，要請が`範囲~要請$であり，その部分的な格納-済み応答で全部的に満足されることになる場合は除く。
◎
If a stored response contains only partial content, the cache MUST NOT include its entity-tag in the union unless the request is for a range that would be fully satisfied by that partial stored response.＼
</li>
	<li>
回送した要請に対する応答 `R^V が［
`304$st である, かつ
`ETag$h ~headerを伴う, かつ
その`~field値$は `L^V 内に無い `entity-tag$p を含む
］場合、［
その `entity-tag$p に対応する格納-済み応答
］を再利用しつつ, `R^V の~metadataでそれを更新した上で（ `4.3.4$sec ），~clientに対し `200$st 応答を`生成し$なければナラナイ
◎
If the response to the forwarded request is 304 (Not Modified) and has an ETag field value with an entity-tag that is not in the client's list, the cache MUST generate a 200 (OK) response for the client by reusing its corresponding stored response, as updated by the 304 response metadata (Section 4.3.4).
</li>
</ul>
</div>

<div class="p">
<p>
`If-None-Match$h ~headerは無いが
`If-Modified-Since$h ~headerは包含する要請は、［
`~client$は、自前の格納-済み応答（たち）について，その改変~日時を`検証-$するよう求めている
］ことを指示する。
~cache`受信者$は、格納-済みな`被選定~応答$
— 以下 `R^V と記す —
について，［
次に従って決定される時刻
］が在って［
`If-Modified-Since^h ~headerの値による時刻
］を過ぎていない
］ならば、（ `R^V の~metadataを利用して，） `304$st 応答を`生成する$ベキである：
◎
If an If-None-Match header field is not present, a request containing an If-Modified-Since header field (Section 9.2.5 of [Semantics]) indicates that the client wants to validate one or more of its own stored responses by modification date. A cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) if one of the following cases is true:＼
</p>

<ol>
	<li>
`R^V に `Last-Modified$h ~fieldが在るならば、その`~field値$による時刻
◎
1) the selected stored response has a Last-Modified field value that is earlier than or equal to the conditional timestamp;＼
</li>
	<li>
他の場合， `R^V に `Date$h ~fieldが在るならば、その`~field値$による時刻
◎
2) no Last-Modified field is present in the selected stored response, but it has a Date field value that is earlier than or equal to the conditional timestamp; or,＼
</li>
	<li>
他の場合，~cacheにて `R^V を受信した時刻が記録されて［
いるならば，その時刻 ／
いないならば，時刻は無い
］
◎
3) neither Last-Modified nor Date is present in the selected stored response, but the cache recorded it as having been received at a time earlier than or equal to the conditional timestamp.
</li>
</ol>

</div>

<p>
`範囲~要請$に対する`部分的な応答$を実装する~cacheは、
`範囲~要請^sec `Semantics$r にて定義されるように，受信した `If-Range$h ~headerを自身に格納-済みな`被選定~応答$に関して評価する必要もある。
◎
A cache that implements partial responses to range requests, as defined in Section 9.3 of [Semantics], also needs to evaluate a received If-Range header field (Section 9.2.7 of [Semantics]) regarding its selected stored response.
</p>

			</section>
			<section id="validation.response">
<h4 title="Handling a Validation Response">4.3.3. 検証~応答の取扱い</h4>

<p>
~cacheによる［
`条件付き要請$に対する応答
］の取扱いは、その状態s~codeに依存する：
◎
Cache handling of a response to a conditional request depends upon its status code:
</p>
<ul>
	<li>
`応答~状態s~code$ `304$st は、格納-済み応答を［
更新できる／再利用できる
］ことを指示する。
◎
• A 304 (Not Modified) response status code indicates that the stored response can be updated and reused; see Section 4.3.4.
</li>
	<li>
全部的な応答（すなわち，`~payload本体$を伴うもの）は、［
`条件付き要請$~内に~~挙げられた，どの格納-済み応答
］も相応しくないことを指示する。
代わりに，~cacheは、要請を満足するために，その全部的な応答を利用しなければナラナイ
— また、格納-済み応答（たち）を置換してもヨイ。
◎
• A full response (i.e., one with a payload body) indicates that none of the stored responses nominated in the conditional request is suitable. Instead, the cache MUST use the full response to satisfy the request and MAY replace the stored response(s).
</li>
	<li>
<p>
しかしながら，~cacheは、［
応答の`検証$を試みている間に `5xx$st 応答を受信した
］ときには，次のいずれかを行える：
◎
• However, if a cache receives a 5xx (Server Error) response while attempting to validate a response, it can either＼
</p>
		<ul>
			<li>
要請している~clientへ，この `5xx^st0 応答を回送する。
◎
forward this response to the requesting client, or＼
</li>
			<li>
~serverが応答-に失敗したかのように動作する。
この場合、以前に格納-済みな応答を送信してもヨイ（`4.2.4$sec を見よ）。
◎
act as if the server failed to respond. In the latter case, the cache MAY send a previously stored response (see Section 4.2.4).
</li>
		</ul>
	</li>
</ul>

			</section>
			<section id="freshening.responses">
<h4 title="Freshening Stored Responses upon Validation">4.3.4. 検証にあたっての，格納-済み応答の新鮮~化法</h4>

<p>
`304$st 応答
— 以下，この節を通して `304 応答^V と記す —
を受信した~cacheは、適用~可能な`~cache~key$用の格納-済み `200$st 応答
— 以下，それらの集合を `S^V と記す —
が 1 個~以上あるときは、~cacheは，［
`S^V の中のどれを， `304 応答^V から供された新たな情報により更新する
］ことになるか識別して，それを行う必要がある。
◎
When a cache receives a 304 (Not Modified) response and already has one or more stored 200 (OK) responses for the applicable cache key, the cache needs to identify which (if any) are to be updated by the new information provided, and then do so.
</p>

<p>
更新~対象として選定される格納-済み応答（たち）は、 `304 応答^V の検証子に応じて，次で与えられる：
◎
The stored response(s) to update are identified by using the first match (if any) of:
</p>

<dl class="switch">
	<dt>
`304 応答^V は`強い検証子$を包含する場合：
◎
If the new response contains a strong validator (see Section 11.2.1 of [Semantics]), then＼
</dt>
	<dd>
その強い検証子が，更新する`選定された表現$を識別する
— すなわち、 `S^V 内の 同じ強い検証子を伴うものは，すべて更新するものと識別される。
◎
that strong validator identifies the selected representation for update. All the stored responses with the same strong validator are identified for update.＼
</dd>
	<dd>
そのような格納-済み応答が無い場合、~cacheは， `304 応答^V を どの格納-済み応答の更新にも利用してはナラナイ。
【この記述から、仮に `304 応答^V が弱い検証子も包含していたとしても，次項は適用されないと見受けられる。】
◎
If none of the stored responses contain the same strong validator, then the cache MUST NOT use the new response to update any stored responses.
</dd>

	<dt>
`304 応答^V は`弱い検証子$を包含する場合：
◎
If the new response contains a weak validator＼
</dt>
	<dd>
`S^V 内にその検証子に合致するものがあれば、それらのうち最も近過去のものが，更新するものと識別される。
◎
and that validator corresponds to one of the cache's stored responses, then the most recent of those matching stored responses is identified for update.
</dd>

	<dt>
`304 応答^V は`検証子$を含まない場合：
◎
If the new response does not include any form of validator＼
</dt>
	<dd>
（例えば、~clientが `Last-Modified$h 応答~header以外の~sourceから， `If-Modified-Since$h 要請を`生成し$たなど。）
◎
(such as where a client generates an If-Modified-Since request from a source other than the Last-Modified response header field),＼
</dd>
	<dd>
`S^V が唯一つの格納-済み応答からなる, かつ
その応答も`検証子$を欠如するならば、その応答が，更新するものと識別される。
◎
and there is only one stored response, and that stored response also lacks a validator, then that stored response is identified for update.
</dd>
</dl>

<p>
~cacheは、更新するものと識別された各 格納-済み応答 `応答^V に対し，次をしなければナラナイ
⇒
`304 応答^V 内に供された各~header `h^V に対し
⇒
`応答^V 内の［
`h^V に対応する~headerの~instanceたち
］を `h^V で置換する
— ただし、次に挙げる例外は除く：
◎
For each stored response identified for update, the cache MUST use the header fields provided in the 304 (Not Modified) response to replace all instances of the corresponding header fields in the stored response, with the following exceptions:
</p>
<ul>
	<li>
`3.1$sec による~headerの格納に対する例外は、~headerの更新にも適用される。
◎
The exceptions to header field storage in Section 3.1 also apply to header field updates.
</li>
	<li>
次に挙げる~headerを更新してはナラナイ
⇒＃
`Content-Encoding$h,
`Content-Length$h,
`Content-MD5$h `RFC2616$r,
`Content-Range$h,
`ETag$h
◎
Caches MUST NOT update the following header fields: Content-Encoding, Content-Length, Content-MD5 (Section 14.15 of [RFC2616]), Content-Range, ETag.
</li>
</ul>

			</section>
			<section id="head.effects">
<h4 title="Freshening Responses with HEAD">4.3.5. `HEAD^m による応答の新鮮~化法</h4>

<div class="p">
<p>
`HEAD$m ~methodに対する応答は、本体を欠如することを除き，［
`GET$m による等価な要請により為される応答
］と一致する。
この `HEAD$m 応答の特質を、次の場合に［
~cacheされた `GET$m 応答を無効化したり更新する
］ことに利用できる：
◎
A response to the HEAD method is identical to what an equivalent request made with a GET would have been, except it lacks a body. This property of HEAD responses can be used to invalidate or update a cached GET response＼
</p>
<ul>
	<li>
より効率的な条件付き `GET$m 要請の仕組みが（格納-済み応答~内に`検証子$が無いことに因り）可用でない場合。
◎
if the more efficient conditional GET request mechanism is not available (due to no validators being present in the stored response) or＼
</li>
	<li>
`表現$が変更されたときでも，その本体の伝送は欲されない場合。
◎
if transmission of the representation body is not desired even if it has changed.
</li>
</ul>
</div>

<p>
~cacheが［
ある`~target~URI$に対し，`内方$へ `HEAD$m 要請を為してから、
`200$st 応答
— 以下 `HEAD 応答^V と記す —
を受信した
］ときは、［
その要請~用に選定し得た，自身に格納-済みな［
`GET$m に対する応答
］］のそれぞれを，更新するか, または無効化するベキである（ `4.1$sec を見よ）。
すなわち，…
◎
When a cache makes an inbound HEAD request for a target URI and receives a 200 (OK) response, the cache SHOULD update or invalidate each of its stored GET responses that could have been selected for that request (see Section 4.1).
</p>

<div class="p">
<p>
~cacheは、選定し得た，各 格納-済み応答 `応答^V に対し：
◎
For each of the stored responses that could have been selected,＼
</p>

<ol>
	<li>
<p>
次のいずれも満たされるならば、下に述べるように `応答^V を更新するベキである：
</p>
		<ul>
			<li>
受信したどの`検証子~header$（ `ETag$h, `Last-Modified$h ）に対しても，
`応答^V, `HEAD 応答^V には その~headerが在って, 両者の値は合致する。
</li>
			<li>
`HEAD 応答^V, `応答^V に `Content-Length$h ~headerが在って, 両者の値は合致する。
</li>
		</ul>
◎
if the stored response and HEAD response have matching values for any received validator fields (ETag and Last-Modified) and, if the HEAD response has a Content-Length header field, the value of Content-Length matches that of the stored response, the cache SHOULD update the stored response as described below;＼
</li>
	<li>
他の場合、 `応答^V を`非新鮮$であると見なすベキである。
◎
otherwise, the cache SHOULD consider the stored response to be stale.
</li>
</ol>
</div>

<p>
~cacheが［
格納-済み応答 `応答^V  を `HEAD 応答^V 内に供された~metadataで更新する
］ときは、次をしなければナラナイ
⇒
`HEAD 応答^V 内に供された各~header `~header^V に対し（ `4.3.4$sec による例外の~subjectになる~headerは除く）
⇒
`~header^V は `Cache-Control$h ~headerにより制約されるものでないならば
⇒
`応答^V 内に `~header^V と同じ名前の~headerたちが
⇒＃
在るならば それらを `~header^V で置換する／
無いならば `応答^V の`~header節$に `~header^V を付加する
◎
If a cache updates a stored response with the metadata provided in a HEAD response, the cache MUST use the header fields provided in the HEAD response to replace all instances of the corresponding header fields in the stored response (subject to the exceptions in Section 4.3.4) and append new header fields to the stored response's header section unless otherwise restricted by the Cache-Control header field.
</p>

			</section>
		</section>
		<section id="invalidation">
<h3 title="Invalidation">4.4. 無効化</h3>

<p>
［
`PUT$m, `POST$m, `DELETE$m
］などの`安全$でない要請~methodは，`生成元~server$上の状態を変更する~~可能性があるので、介在している~cacheは，格納-済みな応答を無効化して自身の内容を最新状態に保つことが要求される。
所与の~URIを
`無効化-@
するとは、~cacheは，［
格納-済み応答のうち，その`~target~URI$が所与の~URIに合致するもの
］を［
すべて除去する
］か［
すべて “無効” と~markして、後続の要請に対する応答として送信できるようになる前に，`検証$を義務付ける
］ことを意味する。
◎
Because unsafe request methods (Section 8.2.1 of [Semantics]) such as PUT, POST or DELETE have the potential for changing state on the origin server, intervening caches are required to invalidate stored responses to keep their contents up to date. Invalidate means that the cache will either remove all stored responses whose target URI matches the given URI, or will mark them as "invalid" and in need of a mandatory validation before they can be sent in response to a subsequent request.
</p>

<p class="note">注記：
これは、~~該当するすべての応答を大域的に無効化することは保証しない。
状態変更~要請が無効化するのは、それが渡り歩く~cache内の応答に限られることになろう。
◎
Note that this does not guarantee that all appropriate responses are invalidated globally; a state-changing request would only invalidate responses in the caches it travels through.
</p>

<div class="p">
<p>
~cacheは、［
`安全$でない／安全かどうか未知である
］要請~methodに対する応答~内に，非~error `状態s~code$
— `2xx$st または `3xx$st —
を受信したときには：
</p>
<ul>
	<li>
その`~target~URI$を`無効化-$しなければナラナイ。
</li>
	<li>
<p>
加えて，要請~methodが`安全$でない場合には、［
`Location$h ／ `Content-Location$h
］応答~headerによる `URI^V についても，［
`URI^V, `~target~URI$
］の~host部分が互いに：
</p>
		<ul>
			<li>
一致するならば、
`URI^V を`無効化-$しなければナラナイ。
</li>
			<li>
一致しないならば、
`URI^V を`無効化-$してはナラナイ
— これは、~DoS攻撃を防止する一助になる。
</li>
		</ul>
	</li>
</ul>

◎
A cache MUST invalidate the target URI (Section 6.1 of [Semantics]) and the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.
◎
However, a cache MUST NOT invalidate a URI from a Location or Content-Location response header field if the host part of that URI differs from the host part in the target URI (Section 6.1 of [Semantics]). This helps prevent denial-of-service attacks.
◎
A cache MUST invalidate the target URI (Section 5.1 of [Semantics]) when it receives a non-error response to a request with a method whose safety is unknown.
◎
Here, a "non-error response" is one with a 2xx (Successful) or 3xx (Redirection) status code.
</div>

		</section>
	</section>
	<section id="header.field.definitions">
<h2 title="Field Definitions">5. ~field定義</h2>

<p>
この節では、次に挙げる［
~cache法に関係する各種~HTTP`~field$
］の構文と意味論を定義する
— これらの位置付けは、廃用にされた `Warning^h を除き，どれも `標準^i （ `standard^en ）である
⇒＃
`Age$h,
`Cache-Control$h,
`Expires$h,
`Pragma$h,
`Warning$h
◎
This section defines the syntax and semantics of HTTP fields related to caching.
◎
Table 1
Field Name 	Status 	Ref.

Age 	standard 	5.1
Cache-Control 	standard 	5.2
Expires 	standard 	5.3
Pragma 	standard 	5.4
Warning 	obsoleted 	5.5
</p>

		<section id="field.age">
<h3>5.1. `Age^h</h3>

<p>
`Age$h ~headerは、応答の`齢$を伝達する。
それは、送信者により `4.2.3$sec に従って見積もられた［
当の応答が`生成元~server$にて，`生成され$たか, 成功裡に`検証-$された
］ときからの時間を与える。
◎
The "Age" header field conveys the sender's estimate of the time since the response was generated or successfully validated at the origin server. Age values are calculated as specified in Section 4.2.3.
</p>

<pre class="bnf">
`Age@p
    = `delta-seconds$p
</pre>

<p>
`Age$h `~field値$は、秒数を表現する負でない整数である（ `1.3$sec を見よ）。
◎
The Age field value is a non-negative integer, representing time in seconds (see Section 1.3).＼
</p>

<p>
~cacheは、次に該当する応答は，`非新鮮$と見なすベキである
⇒
`Age^h ~fieldが在って，その`~field値$は妥当でない（すなわち，~listまたは負でない整数~以外の何かを包含する）
◎
A cache SHOULD consider a response to be stale if an Age field is present and its value is invalid (i.e., contains a list or something other than a non-negative integer).
</p>

<p>
【応答の受信者にとっては，】
`Age$h ~headerが在ることは、この要請に対する応答が，`生成元~server$により［
`生成され$ていない／`検証-$されていない
］ことを含意する。
しかしながら， `Age$h ~headerを欠如するからといって、生成元が接触されたことを含意するとは限らない
— 応答は， `Age^h を実装しない~HTTP10~cacheから受信されることもあるので。
◎
The presence of an Age header field implies that the response was not generated or validated by the origin server for this request. However, lack of an Age header field does not imply the origin was contacted, since the response might have been received from an HTTP/1.0 cache that does not implement Age.
</p>

		</section>
		<section id="field.cache-control">
<h3>5.2. `Cache-Control^h</h3>

<p>
`Cache-Control^h ~headerは、
`~cache制御~指令@†
— ［
要請／応答
］の`連鎖$沿いにある~cacheたちの挙動を制御するための指令（ `directive^en ） —
を~listするために利用される。
そのような指令は，単方向であり、要請~内にそれが在っても，対する応答~内に同じ指令が［
在る／繰返される
］ことは含意しない。
◎
The "Cache-Control" header field is used to list directives for caches along the request/response chain. Such cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is present in the response, or to be repeated in it.
</p>

<div class="trans-note">
<p>【†
単に［
“指令” ／ “~cache指令”
］とも称される。
あるいは
“`Cache-Control^h 指令”
とも称される（他の仕様が
“~cache制御~指令”
を利用する，他の何らかの~headerを定義する可能性も排除されないが）。
［
要請／応答
］内に指定される~cache指令は、［
“`要請~指令$” ／ “`応答~指令$”
］とも称される。
】</p>

</div>

<p>
他所で定義される `Cache-Control$h 指令の取扱い法についての情報は、`~cache制御~拡張$secを見よ。
◎
See Section 5.2.3 for information about how Cache-Control directives defined elsewhere are handled.
</p>

<p class="note">注記：
~HTTP10~cacheには、 `Cache-Control$h を実装しないものもある。
◎
Note: Some HTTP/1.0 caches might not implement Cache-Control.
</p>

<p>
`~proxy$は、自身が回送する~message内にある どの`~cache指令$も
— 自身が［
~cacheを実装するかどうか, その指令を有意に~cacheに適用できるかどうか
］に関わらず —
通過させなければナラナイ。
指令は、［
要請／応答
］の`連鎖$沿いにある すべての`受信者$に適用されるかもしれず，特定の~cacheのみを~targetにできないので。
◎
A proxy, whether or not it implements a cache, MUST pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might apply to all recipients along the request/response chain. It is not possible to target a directive to a specific cache.
</p>

<p>
`~cache指令$は、文字大小無視 `token$p により識別され，引数（省略可）もとり得る。
引数には，［
`token$p, `quoted-string$p
］どちらの構文も利用し得る。
`受信者$は、この仕様が定義する指令に対しては，（引数を定義するものであれば）両~構文とも受容する~OUGHT
— 生成において片方が要求されているものもあるが。
◎
Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument that can use both token and quoted-string syntax. For the directives defined below that define arguments, recipients ought to accept both forms, even if a specific form is required for generation.
</p>

<pre class="bnf">
`Cache-Control@p
    = #`cache-directive$p

`cache-directive@p
    = `token$p [ "=" ( `token$p / `quoted-string$p ) ]
</pre>

<p>
以下では、次に挙げる`~cache指令$が定義される
— 他が言明されない限り、これらには引数は定義されない（許容されない）：
◎
For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.
</p>

<div>

<table><thead><tr><td>要請~cache指令
<td>応答~cache指令
</thead>

<tbody><tr><td>`max-age$qdir
<td>`max-age$sdir

<tr><td>`max-stale$qdir
<td>—

<tr><td>`min-fresh$qdir
<td>—

<tr><td>—
<td>`must-revalidate$sdir

<tr><td>—
<td>`must-understand$sdir

<tr><td>`no-cache$qdir
<td>`no-cache$sdir

<tr><td>`no-store$qdir
<td>`no-store$sdir

<tr><td>`no-transform$qdir
<td>`no-transform$sdir

<tr><td>`only-if-cached$qdir
<td>—

<tr><td>—
<td>`private$sdir

<tr><td>—
<td>`proxy-revalidate$sdir

<tr><td>—
<td>`public$sdir

<tr><td>—
<td>`s-maxage$sdir

</tbody></table>

◎
Table 2
Cache Directive 	Ref.
max-age 	Section 5.2.1.1, Section 5.2.2.9
max-stale 	Section 5.2.1.2
min-fresh 	Section 5.2.1.3
must-revalidate 	Section 5.2.2.1
must-understand 	Section 5.2.2.2
no-cache 	Section 5.2.1.4, Section 5.2.2.3
no-store 	Section 5.2.1.5, Section 5.2.2.4
no-transform 	Section 5.2.1.6, Section 5.2.2.5
only-if-cached 	Section 5.2.1.7
private 	Section 5.2.2.7
proxy-revalidate 	Section 5.2.2.8
public 	Section 5.2.2.6
s-maxage 	Section 5.2.2.10
</div>

			<section id="cache-request-directive">
<h4 title="Request Cache-Control Directives">5.2.1. 要請 `Cache-Control^h 指令</h4>

<p>
この節は、各種~cache要請~指令を定義する。
これらは助言的である
— ~cacheは、これらを実装してもヨイが，要求されてはいない。
◎
This section defines cache request directives. They are advisory; caches MAY implement them, but are not required to.
</p>

				<section id="cache-request-directive.max-age">
<h5>5.2.1.1. `max-age^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
`delta-seconds$p
</pre>

<p>
`max-age^qdir 要請~指令は、［
`~client$は、`齢$が指定された秒~数~以下の応答を選好する
］ことを指示する。
`max-stale^qdir 要請~指令も在る場合を除き、~clientは，`非新鮮$な応答は受信したくないと望んでいる。
◎
The "max-age" request directive indicates that the client prefers a response whose age is less than or equal to the specified number of seconds. Unless the max-stale request directive is also present, the client does not wish to receive a stale response.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-age^dir=5</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-age^dir="5"</samp>
）を`生成し$てはナラナイ。
◎
This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender MUST NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.max-stale">
<h5>5.2.1.2. `max-stale^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
`delta-seconds$p
</pre>

<p>
`max-stale^qdir 要請~指令は、次を指示する
⇒
`~client$は、`鮮度維持期間$を超過した応答を，引数に値が［
在るならば それに指定された秒~数まで受容する用意がある／
無いならば `齢$を問わず，`非新鮮$な応答を受容することになる
］
◎
The "max-stale" request directive indicates that the client will accept a response that has exceeded its freshness lifetime. If a value is present, then the client is willing to accept a response that has exceeded its freshness lifetime by no more than the specified number of seconds. If no value is assigned to max-stale, then the client will accept a stale response of any age.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-stale^dir=10</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-stale^dir="10"</samp>
）を`生成し$てはナラナイ。
◎
This directive uses the token form of the argument syntax: e.g., 'max-stale=10' not 'max-stale="10"'. A sender MUST NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.min-fresh">
<h5>5.2.1.3. `min-fresh^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
`delta-seconds$p
</pre>

<p>
`min-fresh^qdir 要請~指令は、［
`~client$は，［
`鮮度維持期間$が，指定された秒数を応答の現在の`齢$に足した結果~以上
］である応答を選好する
］ことを指示する。
すなわち，~clientは、少なくとも指定された秒~数までは，応答が`新鮮$であり続けるよう求めている。
◎
The "min-fresh" request directive indicates that the client prefers a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-fresh^dir=20</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-fresh^dir="20"</samp>
）を`生成し$てはナラナイ。
◎
This directive uses the token form of the argument syntax: e.g., 'min-fresh=20' not 'min-fresh="20"'. A sender MUST NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.no-cache">
<h5>5.2.1.4. `no-cache^qdir</h5>

<p>
`no-cache^qdir 要請~指令は、［
`~client$は、［
格納-済み応答は、`生成元~server$上で成功裡に`検証-$されない限り，要請を満足するために利用しない
］ことを選好する
］ことを指示する。
◎
The "no-cache" request directive indicates that the client prefers stored response not be used to satisfy the request without successful validation on the origin server.
</p>

				</section>
				<section id="cache-request-directive.no-store">
<h5>5.2.1.5. `no-store^qdir</h5>

<div class="p">
<p>
`no-store^qdir 要請~指令は、［
`私用~cache$, `共用~cache$
］のどちらにも適用され，［
~cacheは、この要請, 対する応答
］を成す どの部分も，格納してはナラナイ
］ことを指示する
— すなわち，~cacheは：
◎
The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache＼
</p>
<ul>
	<li>
不揮発 記憶域に意図的にその情報を格納してはナラナイ。
◎
MUST NOT intentionally store the information in non-volatile storage, and＼
</li>
	<li>
それを回送したならば、アリな限り迅速に, その情報を揮発 記憶域から除去することに極力努めなければナラナイ。
◎
MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</li>
</ul>

</div>

<p>
この指令は、~privacyを確保するための仕組みとして，依拠-可能でも, 足るものでも<strong>ない</strong>。
特に、悪意的な, あるいは弱体化された~cacheは，この指令を認識しなかったり順守しないかもしれず、通信~networkは，盗聴に脆弱になるかもしれない。
◎
This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>

<p class="note">注記：
この指令を包含する要請が，~cacheに格納-済みな応答により満足された場合、
`no-store^qdir 要請~指令は，その格納-済み応答には適用されない。
◎
Note that if a request containing this directive is satisfied from a cache, the no-store request directive does not apply to the already stored response.
</p>

				</section>
				<section id="cache-request-directive.no-transform">
<h5>5.2.1.6. `no-transform^qdir</h5>

<p>
`no-transform^qdir 要請~指令は、［
`~client$は、`~payload$を`形式変換-$するのは避けるよう，`中継者$たちに依頼している
］ことを指示する。
◎
The "no-transform" request directive indicates that the client is asking for intermediaries to avoid transforming the payload, as defined in Section 6.7.2 of [Semantics].
</p>

				</section>
				<section id="cache-request-directive.only-if-cached">
<h5>5.2.1.7. `only-if-cached^qdir</h5>

<p>
`only-if-cached^qdir 要請~指令は、［
`~client$は、格納-済み応答を得することのみを望む
］ことを指示する。
この要請を尊守する~cacheは、その受信に対し，［
要請による他の拘束に整合な，格納-済み応答
］を利用して応答するか， `504$st で応答するベキである。
◎
The "only-if-cached" request directive indicates that the client only wishes to obtain a stored response. Caches that honor this request directive SHOULD, upon receiving it, either respond using a stored response consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status code.
</p>

				</section>
			</section>
			<section id="cache-response-directive">
<h4 title="Response Cache-Control Directives">5.2.2. 応答 `Cache-Control^h 指令</h4>

<p>
この節は、各種 ~cache応答~指令を定義する。
~cacheは、この節に定義される `Cache-Control$h 指令を順守しなければナラナイ。
◎
This section defines cache response directives. A cache MUST obey the Cache-Control directives defined in this section.
</p>

				<section id="cache-response-directive.must-revalidate">
<h5>5.2.2.1. `must-revalidate^sdir</h5>

<p>
`must-revalidate^sdir 応答~指令は、［
~cacheは、`非新鮮$になった応答を
— それが`生成元~server$により成功裡に`検証-$されるまでは —
別の要請を満足するために再利用してはナラナイ
］ことを指示する。
◎
The "must-revalidate" response directive indicates that once the response has become stale, a cache MUST NOT reuse that response to satisfy another request until it has been successfully validated by the origin, as defined by Section 4.3.
</p>

<p>
`must-revalidate^sdir 指令は、ある種の~protocol特能~用に依拠-可能な運用を~supportするために，必要とされる。
~cacheは、どのような状況下でも， `must-revalidate^sdir 指令を順守しなければナラナイ。
特に，~cacheは、`切断されて$いる場合には
— `非新鮮$になった応答は再利用せずに —
`504$st 応答を`生成し$なければナラナイ。
◎
The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances a cache MUST obey the must-revalidate directive; in particular, if a cache is disconnected, the cache MUST generate a 504 (Gateway Timeout) response rather than reuse the stale response.
</p>

<p>
`~server$が `must-revalidate^sdir 指令を利用するのは、［
`表現$に対する要請の`検証$に失敗した結果が，不正な運用になる
］とき
— ~~報告もなく実行されなかった金融取引など —
そのときに限られる~OUGHT。
◎
The must-revalidate directive ought to be used by servers if and only if failure to validate a request on the representation could cause incorrect operation, such as a silently unexecuted financial transaction.
</p>

<p>
`must-revalidate^sdir 指令は、`共用~cache$が［
`Authorization$h ~headerを包含している要請に対し，応答を再利用する
］ことも許可する
— それは、再検証に対する要件（ `3.3$sec ）の~subjectになる。
◎
The must-revalidate directive also permits a shared cache to reuse a response to a request containing an Authorization header field, subject to the above requirement on revalidation (Section 3.3).
</p>

				</section>
				<section id="cache-response-directive.must-understand">
<h5>5.2.2.2. `must-understand^sdir</h5>

<p>
`must-understand^sdir 応答~指令は、応答を格納できる~cacheは［
応答の状態s~code用の要件を解する, かつ それに適合するもの
］に制限されることを指示する。
応答~状態s~codeを解さない~cacheは、
`must-understand^sdir 指令を包含する応答を格納してはナラナイ。
◎
The "must-understand" response directive limits caching of the response to a cache that understands and conforms to the requirements for that response's status code. A cache MUST NOT store a response containing the must-understand directive if the cache does not understand the response status code.
</p>

				</section>
				<section id="cache-response-directive.no-cache">
<h5>5.2.2.3. `no-cache^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
#`field-name$p
</pre>

<p>
引数を伴わない `no-cache^sdir 応答~指令は、［
応答は、`検証$用に回送して成功裡に応答を受信しない限り，他の要請を満足するために利用してはナラナイ
］ことを指示する。
◎
The "no-cache" response directive, in its unqualified form (without an argument), indicates that the response MUST NOT be used to satisfy any other request without forwarding it for validation and receiving a successful response; see Section 4.3.
</p>

<p>
これにより，`生成元~server$は、［
~cacheが`非新鮮$な応答を送信するよう環境設定されていた
］としても，［
~cacheが~serverに接触しないまま，その種の応答を要請を満足するために利用する
］ことを防止できるようになる。
◎
This allows an origin server to prevent a cache from using the response to satisfy a request without contacting it, even by caches that have been configured to send stale responses.
</p>

<div class="p">
<p>
`no-cache^sdir 応答~指令が，引数に 1 個~以上の`~field名$を~listしている場合、次を指示する
⇒
~cacheは、当の応答に次のいずれかを施したならば，それを
— ~cachingに対する他の制約の~subjectになる下で —
後続の要請を満足するために利用してもヨイ：
</p>
<ul>
	<li>
送信する【！subsequent】応答からは、~listされた~headerすべてを除外する
</li>
	<li>
当の応答は、`生成元~server$により成功裡に`再検証-$された（それらの~fieldは、更新されるか除去された）
</li>
</ul>
◎
The qualified form of no-cache response directive, with an argument that lists one or more field names, indicates that a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching, if the listed header fields are excluded from the subsequent response or the subsequent response has been successfully revalidated with the origin server (updating or removing those fields).＼
</div>

<p>
これにより，`生成元~server$は、応答~内における一定の~headerの再利用を
— 応答を成す残りの部分を~cacheするのは許容しつつ —
防止できるようになる。
◎
This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.
</p>

<p>
引数に与え得る`~field名$は、この仕様が定義するものに制限されない。
~field名は、文字大小無視である。
◎
The field names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>

<p>
この指令は、引数の構文として `quoted-string$p を利用する
— 送信者は、 `token$p 形を`生成する$ベキでない（引用符が不要に見える，単独の~entryからなる~listであっても）。
◎
This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).
</p>

<p class="note">注記：
多くの~HTTP10~cacheの実装に移植（ `back-port^en ）されてはいるが、中には，この指令を認識しない, あるいは順守しない~HTTP10~cacheもある。
また，引数を伴う `no-cache^sdir 応答~指令は、~cacheからは，引数を伴わずに受信したかのように取扱われることが多い
— すなわち，引数を伴うものに対する特別な取扱いは、広範に実装されていない。
◎
Note: Although it has been back-ported to many implementations, some HTTP/1.0 caches will not recognize or obey this directive. Also, the qualified form of the directive is often handled by caches as if an unqualified no-cache directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>

				</section>
				<section id="cache-response-directive.no-store">
<h5>5.2.2.4. `no-store^sdir</h5>

<div class="p">
<p>
`no-store^sdir 応答~指令は、［
~cacheは、［
直の†要請, 応答
］を成す どの部分も格納してはナラナイ
］こと, および［
当の応答を利用して他の要請を満足してはナラナイ
］を指示する。
【† 当の応答を生じさせた要請が記憶域に残っている場合、それも抹消することと見受けられる。】
◎
The "no-store" response directive indicates that a cache MUST NOT store any part of either the immediate request or response, and MUST NOT use the response to satisfy any other request.
</p>

<p>
この指令は、［
`私用~cache$, `共用~cache$
］のどちらにも適用される
— ここでの格納してはナラナイとは、~cacheは：
◎
This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache＼
</p>
<ul>
	<li>
不揮発 記憶域に意図的にその情報を格納してはナラナイ。
◎
MUST NOT intentionally store the information in non-volatile storage, and＼
</li>
	<li>
それを回送したならば、アリな限り迅速に, その情報を揮発 記憶域から除去することに極力努めなければナラナイ。
◎
MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</li>
</ul>
</div>

<p>
この指令は、~privacyを確保するための仕組みとして，依拠-可能でも, <strong>足るものでもない</strong>。
特に、悪意的な, あるいは弱体化された~cacheは，この指令を認識しなかったり, 順守しないかもしれず、通信~networkは，盗聴に対し脆弱になるかもしれない。
◎
This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>

				</section>
				<section id="cache-response-directive.no-transform">
<h5>5.2.2.5. `no-transform^sdir</h5>

<p>
`no-transform^sdir 応答~指令は、［
`中継者$は（~cacheを実装するかどうかに関わらず），`~payload$を`形式変換-$してはナラナイ
］ことを指示する。
◎
The "no-transform" response directive indicates that an intermediary (regardless of whether it implements a cache) MUST NOT transform the payload, as defined in Section 6.7.2 of [Semantics].
</p>

				</section>
				<section id="cache-response-directive.public">
<h5>5.2.2.6. `public^sdir</h5>

<p>
`public^sdir 応答~指令は、~cacheは，当の応答を格納してもヨイことを指示する
— 当の応答が `3$sec に定義される拘束の~subjectであり，そうするのは禁制される場合でも。
言い換えれば， `public^sdir は、応答は~cache可能であるものと明示的に~markする。
例えば， `public^dir は、`共用~cache$が［
`Authorization$h ~headerを包含している要請に対し，応答を再利用する
］ことを許可する（ `3.3$sec ）
◎
The "public" response directive indicates that a cache MAY store the response even if it would otherwise be prohibited, subject to the constraints defined in Section 3. In other words, public explicitly marks the response as cacheable. For example, public permits a shared cache to reuse a response to a request containing an Authorization header field (Section 3.3).
</p>

<p class="note">注記：
`3$sec に則って すでに`~cache可能$である応答には、
`public^sdir 指令を追加することは必要とされない。
◎
Note that it is unnecessary to add the public directive to a response that is already cacheable according to Section 3.
</p>

<p>
`public^sdir 指令を伴う応答は、明示的な鮮度~情報が無いならば，`経験的に~cache可能$になる。
◎
If a response with the public directive has no explicit freshness information, it is heuristically cacheable (Section 4.2.2).
</p>

				</section>
				<section id="cache-response-directive.private">
<h5>5.2.2.7. `private^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
#`field-name$p
</pre>

<p>
引数を伴わない `private^sdir 応答~指令は、［
`共用~cache$は、応答を格納してはナラナイ
］ことを指示する（すなわち、応答は、単独の利用者~用に意図されている）。
それはまた、［
`私用~cache$は
— `3$sec に定義される拘束の~subjectになる下で —
応答を格納してもヨイ
］ことを指示する
— 他により，［
当の応答は、`私用~cache$において`経験的に~cache可能$でない
］とされていても。
◎
The unqualified "private" response directive indicates that a shared cache MUST NOT store the response (i.e., the response is intended for a single user). It also indicates that a private cache MAY store the response, subject the constraints defined in Section 3, even if the response would not otherwise be heuristically cacheable by a private cache.
</p>

<p>
`private^sdir 応答~指令が，引数に 1 個~以上の`~field名$を~listしている場合、［
~listされた~fieldに限り，単独の利用者に制限される
］ことを指示する。
`共用~cache$は、~listされた~fieldを
— それらが元の応答に在っても —
格納してはナラナイが，［
それら以外の，応答~messageを成す残りの部分
］は
— `3$sec に定義される拘束の~subjectになる下で —
格納してもヨイ。
◎
If a qualified private response directive is present, with an argument that lists one or more field names, then only the listed fields are limited to a single user: a shared cache MUST NOT store the listed fields if they are present in the original response, but MAY store the remainder of the response message without those fields, subject the constraints defined in Section 3.
</p>

<p>
引数に与え得る`~field名$は、この仕様が定義する それらに制限されない。
~field名は、文字大小無視である。
◎
The field names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>

<p>
この指令は、引数の構文として `quoted-string$p を利用する：
送信者は `token$p 形を`生成する$ベキでない（引用符が不要に見える，単独の~entryからなる~listであっても）。
◎
This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).
</p>

<p class="note">注記：
`private^sdir の利用eは、応答を格納できるかどうかを制御するだけであり，~message内容の~privacyを確保するものではない。
また，引数を伴う `private^sdir 応答~指令は、~cacheからは，引数を伴わずに受信したかのように取扱われることが多い
— すなわち，引数を伴うものに対する特別な取扱いは、広範に実装されていない。
◎
Note: This usage of the word "private" only controls where the response can be stored; it cannot ensure the privacy of the message content. Also, the qualified form of the directive is often handled by caches as if an unqualified private directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>

				</section>
				<section id="cache-response-directive.proxy-revalidate">
<h5>5.2.2.8. `proxy-revalidate^sdir</h5>

<p>
`proxy-revalidate^sdir 応答~指令は、［
`共用~cache$は、`非新鮮$になった応答を
— それが`生成元~server$により成功裡に`検証-$されるまでは —
別の要請を満足するために再利用してはナラナイ
］ことを指示する。
これは、`私用~cache$には適用されないことを除いて，
`must-revalidate$sdir 応答~指令に相似的である。
◎
The "proxy-revalidate" response directive indicates that once the response has become stale, a shared cache MUST NOT reuse that response to satisfy another request until it has been successfully validated by the origin, as defined by Section 4.3. This is analogous to must-revalidate (Section 5.2.2.1), except that proxy-revalidate does not apply to private caches.
</p>

<p class="note">注記：
`proxy-revalidate^dir それ自体は、応答は~cache可能であることは含意しない。
例えば， `public$sdir 指令と組合せることで、応答を~cacheするのは許容しつつ，`共用~cache$に限り`非新鮮$なったそれを`再検証-$するよう要求することもできる。
◎
Note that "proxy-revalidate" on its own does not imply that a response is cacheable. For example, it might be combined with the public directive (Section 5.2.2.6), allowing the response to be cached while requiring only a shared cache to revalidate when stale.
</p>

				</section>
				<section id="cache-response-directive.max-age">
<h5>5.2.2.9. `max-age^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
`delta-seconds$p
</pre>

<p>
`max-age$sdir 応答~指令は、次を指示する
⇒
当の応答は、［
その`齢$が指定された秒~数を超えた後は，`非新鮮$になる
］と見なされる
◎
The "max-age" response directive indicates that the response is to be considered stale after its age is greater than the specified number of seconds.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-age^dir=5</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-age^dir="5"</samp>
）を`生成し$てはナラナイ。
◎
This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender MUST NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-response-directive.s-maxage">
<h5>5.2.2.10. `s-maxage^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="bnf">
`delta-seconds$p
</pre>

<p>
`s-maxage^sdir 応答~指令は、`共用~cache$に対しては，次を指示する
⇒
［
この指令により指定された最大~齢
］は［
`max-age$sdir 指令／ `Expires$h ~header
］により指定された最大~齢
］を上書きする
◎
The "s-maxage" response directive indicates that, for a shared cache, the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header field.
</p>

<p>
`s-maxage^sdir 応答~指令は、`共用~cache$に対しては，
`proxy-revalidate$sdir 応答~指令の意味論を組入れる。
すなわち，`共用~cache$は、
`s-maxage^dir を伴う`非新鮮$になった応答を
— それが`生成元~server$により成功裡に`検証-$されるまでは —
別の要請を満足するために再利用してはナラナイ。
この指令はまた、`共用~cache$が［
`Authorization$h ~headerを包含している要請に対し，応答を再利用する
］ことも許可する
— それは、［
上述した最大~齢に対する要件, 再検証に対する要件（ `3.3$sec ）
］の~subjectになる。
◎
The s-maxage directive incorporates the proxy-revalidate (Section 5.2.2.8) response directive's semantics for a shared cache. A shared cache MUST NOT reuse a stale response with s-maxage to satisfy another request until it has been successfully validated by the origin, as defined by Section 4.3. This directive also permits a shared cache to reuse a response to a request containing an Authorization header field, subject to the above requirements on maximum age and revalidation (Section 3.3).
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`s-maxage^dir=10</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`s-maxage^dir="10"</samp>
）を`生成し$てはナラナイ。
◎
This directive uses the token form of the argument syntax: e.g., 's-maxage=10' not 's-maxage="10"'. A sender MUST NOT generate the quoted-string form.
</p>

				</section>
			</section>
			<section id="cache.control.extensions">
<h4 title="Cache Control Extensions">5.2.3. ~cache制御~拡張</h4>

<p>
`Cache-Control$h ~headerは、［
それぞれが値（省略可）を伴い得るような， 1 個~以上の~cache拡張~token
］の利用を通して拡張できる。
~cacheは、認識できない`~cache指令$を無視しなければナラナイ。
◎
The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional value. A cache MUST ignore unrecognized cache directives.
</p>

<p>
~cacheの挙動~変更-を要求しない拡張（ “`informational^en” 拡張）
を、他の指令の意味論を変更することなく，追加できる。
◎
Informational extensions (those that do not require a change in cache behavior) can be added without changing the semantics of other directives.
</p>

<div class="p">
<p>
挙動を変更する拡張（ “`behavioral^en” 拡張）は、既存の`~cache指令$に基づく挙動に対する改変子として動作するように設計されている
— すなわち，新旧 両~指令が給されたときは、次のようになる：
◎
Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the old directive are supplied, such that＼
</p>
<ul>
	<li>
新~指令を解さない応用は、既定で，旧~指令により指定される挙動になる。
◎
applications that do not understand the new directive will default to the behavior specified by the old directive, and＼
</li>
	<li>
新~指令を解する応用は、それを，旧~指令に結付けられた要件を改変するものとして認識する。
◎
those that understand the new directive will recognize it as modifying the requirements associated with the old directive.＼
</li>
</ul>

<p>
このようにして、配備された~cacheを壊すことなく，既存の~cache制御~指令を拡張できるようになる。
◎
In this way, extensions to the existing cache-control directives can be made without breaking deployed caches.
</p>
</div>

<div class="example">
<p>
例えば、 `community^dir と呼ばれる，新たな応答~指令を仮に考える。
それは，［
`private$sdir 指令に対する改変子
］として動作し、`私用~cache$に加えて，［
ある “community” の~member間に限り`共有-$されるような，どの~cache
］も［
応答を~cacheすることが許容される
］とする。
`生成元~server$は、［
“XYZ” community が，彼らの`共用~cache$において［
さもなければ `private$sdir になるような応答
］を利用する
］ことを許容したいと望むなら、次のように［
`XYZ^c を値にとる `community^dir
］を含ませる：
◎
For example, consider a hypothetical new response directive called "community" that acts as a modifier to the private directive: in addition to private caches, any cache that is shared only by members of the named community is allowed to cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including
</p>

<pre class="lang-http">
Cache-Control: private, community="XYZ"
</pre>

<p>
そのような`~cache制御~拡張$ `community^dir を認識する~cacheは、その拡張に則って，自身の挙動を広げられる。
`community^dir 拡張を認識しない~cacheは、それを無視して，
`private$sdir 指令を固守することになる。
◎
A cache that recognizes such a community cache-extension could broaden its behavior in accordance with that extension. A cache that does not recognize the community cache-extension would ignore it and adhere to the private directive.
</p>
</div>

<p>
新たな拡張~指令は、次を定義することを考慮する~OUGHT：
◎
New extension directives ought to consider defining:
</p>
<ul>
	<li>
その指令が複数~個 指定されたとき，何を意味するか？
◎
• What it means for a directive to be specified multiple times,
</li>
	<li>
その指令が引数をとらないのは いつか？
引数が在るときは何を意味するか？
◎
• When the directive does not take an argument, what it means when an argument is present,
</li>
	<li>
その指令が引数を要求するのは いつか？
引数を欠くときは何を意味するか？
◎
• When the directive requires an argument, what it means when it is missing,
</li>
	<li>
その指令は［
要請のみ, あるいは応答のみ
］に特有か？
両者に利用できるか？
◎
• Whether the directive is specific to requests, responses, or able to be used in either.
</li>
</ul>

			</section>
			<section id="section-5.2.4">
<h4 title="Cache Directive Registry">5.2.4. ~cache指令~registry</h4>

<p>
`~cache指令$用の名前空間を定義するための
`~cache指令~registry$cite
が、新たに作成され，保守されている。
◎
The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry" defines the namespace for the cache directives. It has been created and is now maintained at &lt;https://www.iana.org/assignments/http-cache-directives&gt;.
</p>

<p>
登録にあたっては，次の~fieldが含まれなければナラナイ：
◎
A registration MUST include the following fields:
</p>
<ul>
	<li>
当の`~cache指令$の名前
◎
• Cache Directive Name
</li>
	<li>
仕様~textへの~pointer
◎
• Pointer to specification text
</li>
</ul>

<p>
この名前空間に追加される値は
`IETF による考査$を要する。
◎
Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

			</section>
		</section>
		<section id="field.expires">
<h3>5.3. `Expires^h</h3>

<p>
`Expires^h ~headerは、［
それ以降は 応答が`非新鮮$になると見なされる，日時／時刻
］を与える。
鮮度~modelについての更なる論点は、`鮮度$secを見よ。
◎
The "Expires" header field gives the date/time after which the response is considered stale. See Section 4.2 for further discussion of the freshness model.
</p>

<p>
`Expires^h ~headerが在ることは、［
元の`資源$が，その時刻を境に変化したり, 存在するようになる／しなくなる
］ことを含意するものではない。
◎
The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.
</p>

<p>
`Expires^h は、
`HTTP-date$p による時刻印を値にとる。
◎
The Expires value is an HTTP-date timestamp, as defined in Section 5.4.1.5 of [Semantics].
</p>

【！ Errata ID: 4479 Rejected 】

<pre class="bnf">
`Expires@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
例：
◎
For example
</p>

<pre class="lang-http">
Expires: Thu, 01 Dec 1994 16:00:00 GMT
</pre>

</div>

<p>
~cache`受信者$は、形式が無効な日時を，値 "`0^c" に解釈しなければナラナイ
— これは、過去の時刻を表現する（すなわち， “すでに失効した”）。
◎
A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
</p>

<p>
応答が `max-age$sdir 指令を伴う `Cache-Control$h ~headerを内包する場合、`受信者$は `Expires^h ~headerを無視しなければナラナイ。
同様に，応答が `s-maxage$sdir 指令を内包する場合、`共用~cache$受信者は， `Expires^h ~headerを無視しなければナラナイ。
いずれの場合も、 `Expires^h の値は，もっぱら［
`Cache-Control$h ~headerをまだ実装していない`受信者$
］用に意図されたものである。
◎
If a response includes a Cache-Control field with the max-age directive (Section 5.2.2.9), a recipient MUST ignore the Expires field. Likewise, if a response includes the s-maxage directive (Section 5.2.2.10), a shared cache recipient MUST ignore the Expires field. In both these cases, the value in Expires is only intended for recipients that have not yet implemented the Cache-Control field.
</p>

<div class="p">
<p>
`時計$を備えていない`生成元~server$は、
`Expires^h ~headerを`生成し$てはナラナイ
— ただし、その値が次のいずれかの値をとる場合は除く：
◎
An origin server without a clock MUST NOT generate an Expires field unless its value＼
</p>
<ul>
	<li>
過去の固定的な時刻を表現する（ “常に，すでに失効している” ）。
◎
represents a fixed time in the past (always expired) or＼
</li>
	<li>
依拠-可能な`時計$を備える［
~system／【ヒトでない】利用者
］により，`資源$に結付けられた値。
◎
its value has been associated with the resource by a system or user with a reliable clock.
</li>
</ul>
</div>

<p>
歴史的に，~HTTPは、
`Expires^h `~field値$に対し，一年以内の未来にすることを要求していた。
長い`鮮度維持期間$は，もはや禁制されなくなったが、度を越して巨大な値は 問題を起こすことが判っているので（例：時刻~値~用の 32 ~bit整数の利用に因る，時計の桁溢れ），多くの~cacheは それより ずっと早くに応答を抹消する。
◎
Historically, HTTP required the Expires field value to be no more than a year in the future. While longer freshness lifetimes are no longer prohibited, extremely large values have been demonstrated to cause problems (e.g., clock overflows due to use of 32-bit integers for time values), and many caches will evict a response far sooner than that.
</p>

		</section>
		<section id="field.pragma">
<h3>5.4. `Pragma^h</h3>

<p>
`Pragma^h ~headerは、~HTTP10~cache用に定義された
— `~client$が， `no-cache^dir 要請も指定できるようにするために（ `Cache-Control$h が定義されたのは、~HTTP11になってからなので）。
◎
The "Pragma" header field was defined for HTTP/1.0 caches, so that clients could specify a "no-cache" request (as Cache-Control was not defined until HTTP/1.1).
</p>

<p>
しかしながら、 `Cache-Control$h の~supportは，今や広く行き渡っている。
よって、この仕様は `Pragma^h を非推奨にする。
◎
However, support for Cache-Control is now widespread. As a result, this specification deprecates Pragma.
</p>

<p class="note">注記：
応答においては、
<code>Pragma: `no-cache^dir</code>
の意味が指定されることは決してない
— それは，応答における
<code>Cache-Control: `no-cache$sdir</code>
に代わる依拠-可能な置換を供さない。
◎
Note: Because the meaning of "Pragma: no-cache" in responses was never specified, it does not provide a reliable replacement for "Cache-Control: no-cache" in them.
</p>

		</section>
		<section id="field.warning">
<h3>5.5. `Warning^h</h3>

<p>
`Warning^h ~headerは、［
`状態s~code$内に反映されないこともあるような，~messageの状態sや`形式変換$についての追加的な情報
］を運ぶために利用されていた。
この仕様は、これを廃用にする
— 広範に生成されたり, 利用者が面するものではないので。
それが運んでいた情報は、 `Age$h などの他の~headerを精査すれば拾える。
◎
The "Warning" header field was used to carry additional information about the status or transformation of a message that might not be reflected in the status code. This specification obsoletes it, as it is not widely generated or surfaced to users. The information it carried can be gleaned from examining other header fields, such as Age.
</p>

		</section>
	</section>
	<section id="history.lists">
<h2 title="Relationship to Applications">6. 応用との関係性</h2>

<p>
~HTTPを利用している応用は、追加的な形の~cache法を指定することが多い。
例えば，~web~browserは、履歴の仕組みを備えることが多い
— ある~sessionにおいて，~~以前に検索取得した表現を表示し直すような、
“戻る” ~buttonを利用できるなど。
◎
Applications using HTTP often specify additional forms of caching. For example, Web browsers often have history mechanisms such as "Back" buttons that can be used to redisplay a representation retrieved earlier in a session.
</p>

<p>
同様に，~page~viewの中の画像 その他の~assetの~cache法を実装する~Web~browserもある
— それらには、~HTTP~cache法の意味論を尊守するものも，しないものもある。
◎
Likewise, some Web browsers implement caching of images and other assets within a page view; they may or may not honor HTTP caching semantics.
</p>

<p>
この仕様における要件は、［
応用が，~HTTP~cacheから~dataを検索取得した後にどう利用するか
］に適用することは，必要とされない。
すなわち、履歴の仕組みは，以前の表現を
— それが失効しようが —
表示でき、応用は，~cacheされた~dataを
— それが鮮度維持期間を超えていようが —
他の仕方で利用できる。
◎
The requirements in this specification do not necessarily apply to how applications use data after it is retrieved from a HTTP cache. That is, a history mechanism can display a previous representation even if it has expired, and an application can use cached data in other ways beyond its freshness lifetime.
</p>

<p>
このことは、応用が~HTTP~cache法を織り込むことを禁制するものではない
— 例えば，履歴の仕組みは、次を行うかもしれない
⇒＃
~viewは非新鮮であることを利用者に~~伝える／
~cache指令（例： `Cache-Control: no-store^c ）を尊守する
◎
This does not prohibit the application from taking HTTP caching into account; for example, a history mechanism might tell the user that a view is stale, or it might honor cache directives (e.g., Cache-Control: no-store).
</p>

	</section>
	<section id="security.considerations">
<h2 title="Security Considerations">7. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］向けに，
~HTTP~cache法に特有な，既知な~securityの懸念を伝えることを~~意図している。
より一般的な~securityの考慮点は、
`Messaging$r, `Semantics$r
にて取組まれている。
◎
This section is meant to inform developers, information providers, and users of known security concerns specific to HTTP caching. More general security considerations are addressed in HTTP messaging [Messaging] and semantics [Semantics].
</p>

<p>
~cacheは、脆弱性を付け加える~~可能性がある
— ~cacheの内容は、悪意的な悪用にとって魅力的な~targetを表現するので。
~cacheの内容は，~HTTP要請が完了した後も持続するので、利用者からは~networkから情報が除去されたように見えても、~cacheに対する攻撃により，長期間 情報を露呈する。
したがって，~cache内容は、敏感な情報として保護される必要がある。
◎
Caches expose additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents need to be protected as sensitive information.
</p>

		<section id="n-cache-poisoning">
<h3 title="Cache Poisoning">7.1. ~cache汚染</h3>

<p>
様々な攻撃が，`共用~cache$内に格納されることにより増幅され得る。
そのような “~cache汚染” 攻撃は、［
多数の`~client$に向けて悪意的な`~payload$を配布する
］ような~cacheを利用する。
それは、攻撃者が［
実装の欠陥, 特権拡大, その他の技法
］を利用して，そのような応答を~cacheの中へ挿入できるときには、とりわけ効果的になる。
◎
Various attacks might be amplified by being stored in a shared cache. Such "cache poisoning" attacks use the cache to distribute a malicious payload to many clients, and are especially effective when an attacker can use implementation flaws, elevated privileges, or other techniques to insert such a response into a cache.
</p>

<p>
~cache汚染に共通的にある攻撃~行路の一つは、`~proxy$と`~UA$における~message構文解析-法の相違点を悪用するものである
— ~HTTP11に関連な要件については、
`Messaging/6.3$sec
を見よ。
◎
One common attack vector for cache poisoning is to exploit differences in message parsing on proxies and in user agents; see Section 6.3 of [Messaging] for the relevant requirements regarding HTTP/1.1.
</p>

		</section>
		<section id="security.timing">
<h3 title="Timing Attacks">7.2. 計時~攻撃</h3>

<p>
~cacheの首な利用の一つは，処理能を最適化することにあるので、そのような利用は，以前に どの資源が要請されたかについての情報を “漏洩し得る” 。
◎
Because one of the primary uses of a cache is to optimise performance, its use can "leak" information about what resources have been previously requested.
</p>

<p>
例えば、利用者がある~site A を訪問して，利用者の~browserが A からの応答をいくつか~cacheしてから，別の~site B へ~navigateしたとするとき、~site B は，~site A に存在すると知っている応答を読込もうと試みれる。
それが，~~普段より素早く読込まれた場合、~site B は，利用者が~site A を
— ~site A のある特定の~pageさえも —
訪問したものと見做せる。
◎
For example, if a user visits a site and their browser caches some of its responses, and then navigates to a second site, that site can attempt to load responses it knows exists on the first site. If they load quickly, it can be assumed that the user has visited that site, or even a specific page on it.
</p>

<p>
そのような “計時~攻撃” は、~cache~keyにもっと情報を追加することで軽減し得る
— （上に述べた攻撃を防止するために）参照元~site【すなわち~referrer】の同一性を追加するなど。
これは、 “~keyの二重化（ `double keying^en ）” と呼ばれることもある。
◎
Such "timing attacks" can be mitigated by adding more information to the cache key, such as the identity of the referring site (to prevent the attack described above). This is sometimes called "double keying."
</p>

		</section>
		<section id="n-caching-of-sensitive-information">
<h3 title="Caching of Sensitive Information">7.3. 敏感な情報の~cache法</h3>

<p>
実装や配備における欠陥（あるいは~cache運用の誤理解）は、私用と考えられる敏感な情報（例：認証~用の資格証）を~cacheすることへ導き、権限付与されていない主体に公開されるかもしれない。
◎
Implementation and deployment flaws (as well as misunderstanding of cache operation) might lead to caching of sensitive information (e.g., authentication credentials) that is thought to be private, exposing it to unauthorized parties.
</p>

<p class="note">注記：
`Set-Cookie$h 応答~header `RFC6265$r は、~cachingを~~妨げない
— `Set-Cookie$h ~headerを伴う~cache可能な応答は、~cacheに対する後続の要請を満足するために利用できる（また，利用されることが多い）。
`~server$には、これらの応答の~cachingを制御したいときには，適切な `Cache-Control$h 応答~headerを発することが，奨励される。
◎
Note that the Set-Cookie response header field [RFC6265] does not inhibit caching; a cacheable response with a Set-Cookie header field can be (and often is) used to satisfy subsequent requests to caches. Servers who wish to control caching of these responses are encouraged to emit appropriate Cache-Control response header fields.
</p>

		</section>
	</section>
	<section id="iana.considerations">
<h2 title="IANA Considerations">8. ~IANA考慮点</h2>

【この節は未訳。】

	</section>
	<section id="collected.abnf">
<h2 title="Collected ABNF">付録 A. 総集的~ABNF</h2>

【この節は未訳。】

	</section>
	<section id="changes.from.rfc.7234">
<h2 title="Changes from RFC 7234">付録 B. RFC 7234 からの変更点</h2>

<p>
`Age$h ~header［
の値が妥当でない／が複数個ある
］場合の取扱いを明確化した。
（ § `Age$h ）
◎
Handling invalid and multiple Age header field values has been clarified. (Section 5.1)
</p>

<p>
この仕様により定義される~cache指令のうち一部には、今や
`quoted-string$p 形による値を生成することに対し，より強く禁制される
— さもなければ，相互運用能の問題が生じることが見出されたので。
拡張~cache指令の消費器には、［
`token$p, `quoted-string$p
］両~形とも受容することはもはや要求されないが、
未知な拡張に対しては依然として，それらを適正に構文解析する必要がある。
（ `5.2$sec ）
◎
Some cache directives defined by this specification now have stronger prohibitions against generating the quoted form of their values, since this has been found to create interoperability problems. Consumers of extension cache directives are no longer required to accept both token and quoted-string forms, but they still need to parse them properly for unknown extensions. (Section 5.2)
</p>

<p>
`public$sdir,
`private$sdir
~cache指令を［
どの条件~下でも応答を再利用-可能にしない
］よう明確化した。
【！5.2.2#cache-response-directive】
◎
The "public" and "private" cache directives were clarified, so that they do not make responses reusable under any condition. (Section 5.2.2)
</p>

<p>
`must-understand$sdir ~cache指令が導入された。
~cacheには，それが無い場合には、新たな応答~状態s~codeの意味論を解することは，もはや要求されない。
◎
The "must-understand" cache directive was introduced; caches are no longer required to understand the semantics of new response status codes unless it is present. (Section 5.2.2.2)
</p>

<p>
`Warning$h 応答~headerは廃用にされた。
`Warning^h が~supportする情報の大部分は、応答を精査すれば拾える
— それ以外の各種 `warn-code^p も有用にはなり得るが，全面的に助言的であり、実施においては，~cacheや中継者は `Warning^h を追加していなかった。
（ `5.5$sec ）
◎
The Warning response header was obsoleted. Much of the information supported by Warning could be gleaned by examining the response, and the remaining warn-codes — although potentially useful — were entirely advisory. In practice, Warning was not added by caches or intermediaries. (Section 5.5)
</p>

	</section>
	<section id="change.log">
<h2 title="Change Log">付録 C. 変更~log</h2>

<p>
この節は、 RFC として発行する前に除去されることになる。
【以下、この節は未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
`Semantics/謝辞$sec を見よ。
◎
See Appendix "Acknowledgments" of [Semantics].
</p>

	</section>
	<section id="rfc.authors">
<h2 title="Authors' Addresses">著作者の~address</h2>

<p>
`Semantics/著作者の~address$sec と同じ
【なので、この訳では省略する。】
</p>

	</section>
</main></div>
