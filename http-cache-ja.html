<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTTP Caching （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="http-common.css" type="text/css" />

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options
spec_title:HTTP Caching
spec_date:2019-11-20
trans_update:2019-11-22
source_checked:191120
page_state_key:HTTP
original_url:https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html
abbr_url:HTTPcache
spec_status:IETFID
no_original_dfn:true
trans_1st_pub:2019-11-22


●●class_map

●●tag_map


●●original_id_map

●●link_map

	●指令

qdir.max-age:#cache-request-directive.max-age
qdir.max-stale:#cache-request-directive.max-stale
qdir.min-fresh:#cache-request-directive.min-fresh
qdir.no-cache:#cache-request-directive.no-cache
qdir.no-store:#cache-request-directive.no-store
qdir.no-transform:#cache-request-directive.no-transform
qdir.only-if-cached:#cache-request-directive.only-if-cached

sdir.max-age:#cache-response-directive.max-age
sdir.must-revalidate:#cache-response-directive.must-revalidate
sdir.no-cache:#cache-response-directive.no-cache
sdir.no-store:#cache-response-directive.no-store
sdir.no-transform:#cache-response-directive.no-transform
sdir.private:#cache-response-directive.private
sdir.proxy-revalidate:#cache-response-directive.proxy-revalidate
sdir.public:#cache-response-directive.public
sdir.s-maxage:#cache-response-directive.s-maxage

	●用語
~cache:~HTTPcache#cache
~cache指令:~HTTPcache#cache-directive
~cache制御~指令:~HTTPcache#cache-directive
切断されて:~HTTPcache#disconnected

検証:#validation.model
検証-:#validation.model
検証ng:#validation.model
再検証-:#validation.model
再検証:#validation.model
再検証ng:#validation.model
	validation
新鮮:~HTTPcache#fresh
	新鮮であるresponse_is_fresh
非新鮮:~HTTPcache#stale
鮮度:~HTTPcache#expiration.model
	#freshness
鮮度維持期間:~HTTPcache#freshness-lifetime
失効時刻:~HTTPcache#expiration-time
明示的な失効時刻:#explicit-expiration-time
経験的な失効時刻:#heuristic-expiration-time
経験的な:#heuristic-expiration-time
齢:#age
~cache制御 応答~指令:#cache-response-directive
被選定:#selected-response
被選定~応答:#selected-response
~cache~key:#cache-key
無効化-:#invalidate
~cache制御~拡張:#cache.control.extensions
	~cache拡張~token
共有-:#shared-cache
	非~error状態s~code:#non-error-status-code

cite.~cache指令~登記簿:~IANA-a/http-cache-directives

	不完全な応答:#incomplete.responses

	●§
1.3:#delta-seconds
3:#response.cacheability
3.2:#caching.authenticated.responses
3.3:#combining.responses
4:#constructing.responses.from.caches
4.1:#caching.negotiated.responses
4.2.2:#heuristic.freshness
4.2.3:#age.calculations
4.2.4:#serving.stale.responses
4.3.4:#freshening.responses
4.4:#invalidation
5.5:#header.warning
6:#history.lists
7.2:#security.timing
A:#collected.abnf
B:#changes.from.rfc.7234
C:#change.log


Messaging/9.3:~HTTPmsg#associating.response.to.request
Messaging/6.3:~HTTPmsg#message.body.length
Semantics/8.2.2:~HTTPrq#precedence
	Semantics/8.3:~HTTPrq#header.range
Semantics/9.1:~HTTPrs#overview.of.status.codes
Semantics/9.3.7.3:~HTTPrs#combining.byte.ranges
Semantics/謝辞:~HTTPsem#acks
Semantics/著作者の~address:~HTTPsem#rfc.authors

	●変数
V.齢~値:#age_value
V.滞在~時間:#resident_time
V.現在時:#now
V.現在~齢:#current_age
V.要請~時刻:#request_time
V.応答~時刻:#response_time
V.修正済み初期~齢:#corrected_initial_age
V.見かけ齢:#apparent_age

V.修正済み齢~値:#corrected_age_value
V.日時~値:#date_value
V.鮮度維持期間:#freshness_lifetime
V.応答~遅延:#response_delay
	V.response_is_fresh:#response_is_fresh

●●section_map

1:#caching
1.1:##intro.requirements
1.2:#notation
1.3:#delta-seconds
2:#caching.overview
3:#response.cacheability
3.1:#incomplete.responses
3.2:#caching.authenticated.responses
3.3:#combining.responses
4:#constructing.responses.from.caches
4.1:#caching.negotiated.responses
4.2:#expiration.model
4.2.1:#calculating.freshness.lifetime
4.2.2:#heuristic.freshness
4.2.3:#age.calculations
4.2.4:#serving.stale.responses
4.3:#validation.model
4.3.1:#validation.sent
4.3.2:#validation.received
4.3.3:#validation.response
4.3.4:#freshening.responses
4.3.5:#head.effects
4.4:#invalidation
5:#header.field.definitions
5.1:#header.age
5.2:#header.cache-control
5.2.1:#cache-request-directive
5.2.1.1:#cache-request-directive.max-age
5.2.1.2:#cache-request-directive.max-stale
5.2.1.3:#cache-request-directive.min-fresh
5.2.1.4:#cache-request-directive.no-cache
5.2.1.5:#cache-request-directive.no-store
5.2.1.6:#cache-request-directive.no-transform
5.2.1.7:#cache-request-directive.only-if-cached
5.2.2:#cache-response-directive
5.2.2.1:#cache-response-directive.must-revalidate
5.2.2.2:#cache-response-directive.no-cache
5.2.2.3:#cache-response-directive.no-store
5.2.2.4:#cache-response-directive.no-transform
5.2.2.5:#cache-response-directive.public
5.2.2.6:#cache-response-directive.private
5.2.2.7:#cache-response-directive.proxy-revalidate
5.2.2.8:#cache-response-directive.max-age
5.2.2.9:#cache-response-directive.s-maxage
5.2.3:#cache.control.extensions
5.3:#header.expires
5.4:#header.pragma
5.5:#header.warning
6:#history.lists
7:#security.considerations
7.2:#security.timing
8:#iana.considerations
	8.1:#
	8.2:#
	8.3:#
9:#rfc.references
A:#collected.abnf
B:#changes.from.rfc.7234
C:#change.log

    C.1.   Between RFC7234 and draft 00
    C.2.   Since draft-ietf-httpbis-cache-00
    C.3.   Since draft-ietf-httpbis-cache-01
    C.4.   Since draft-ietf-httpbis-cache-02
    C.5.   Since draft-ietf-httpbis-cache-03

Acknowledgments
Index
Authors' Addresses

●●words_table1
5861:https://tools.ietf.org/html/rfc5861

●●words_table

	●cache（時間
同期調整:skew::~::スキュー
失効時刻:expiration time::~
失効時期:expiry::~
時間帯:time zone::~
時間:time::~
経過時間:amount of time:~
	秒数:time in seconds:~
	足した:plusした:~
齢:age::~
経過-:pass:~
delta:
現在時:now:~
鮮度維持期間:freshness lifetime::~
計時:timing:~
分解能:resolution:~

	1 年:one-year
	~~期間:time
	~~未来でない:equal to or earlier than
	~~過去:less than
	ずっと早くに:far sooner
	一年以内:no more than a year in the future
	境に:before, or after
	旧:old
	無限:infinity
	迅速に:promptly
	UTC
	NTP

	●cache
refresh:::更新::リフレッシュ
reload:::再読み込み::リロード
	＊
canned:
新鮮:fresh::~
非新鮮:stale::~
新鮮化-:freshen::~
	新鮮化-法:freshening
鮮度:freshness::~
切断-:disconnect:~
検証ng:validating::検証
検証子:validator::~
再検証-:revalidate::~
再検証ng:revalidating::検証
有効:valid::~
再検証:revalidation::~
私用:private::~::プライベート
修正済み:corrected:~
滞在:resident:~
滞在-:reside:~


	●保安
増幅-:amplify:~
漏洩-:leak::~
攻撃路:attack vector::~
魅力的:attractive:~
配布-:distribute:~


	●仕様
略語:abbreviation:~
	最低限の:worst-case
都合よく:convenientに:~
契約:contract:~
否定的:negative:~
今日:today:~
素材:material:~
	再利用-法:reusing
下位system:subsystem:下位 system:下位システム
検査ng:checking:検査
見かけ:apparent:~
特質:property:~:::プロパティ
誤理解:misunderstanding:~
	~~処理:operation
	~~可能性:potential
	~~報告もなく実行されなかった:silently unexecuted
	~~妨げ:inhibit
	~~実用的な:sensible
	~~普段より:very
	~~本質的:essence
	~~確信を持てる:confident in
	かどうかが一貫でない:inconsistently
	ように見えても:believe
	一助:help
	不正になる可能性がある:possible incorrectness introduced
	付け加える~~可能性がある:expose additional potential
	判っている:have been demonstrated
	受信された／今の:presented
	度を越して:extremely
	必要とされない:not necessarily
	波及-:influence
	目的を以って:purposeful
	確からしい:plausible
	緊密に連携する:good internal connectivity
	考えられ:thought
	該当する:appropriate
	逆に:conversely
	重視され:matter す
	~~伝える:tell
	~~対して:with respect to
	~~挙げられた:nominate
	広く行き渡って:widespread
	面する:surface

	●未分類
並替える:reorderする:並び替える
不揮発:non-volatile:~
揮発:volatile:~
提示-:present:~
通過中:transit 中:~
抹消:evict:~
金融取引:financial transaction:~
割合:fraction:~
返信:reply:~
	現在:current:~
接触-:contact:~
変形-:transform:~
最新状態:up to date:~
非負:non-negative:~
単方向:unidirectional:~
地域的:local:~:::ローカル
	置換:replacement
asset::::アセット
帯域外の:out-of-band:~
素早く:quickに:~
合成-:synthesise:~

	^en:double keying
	member
	拾える:gleanできる:~
	“戻る” "Back"
	そのまま書き出:write through
	保持:hold
	欠く:missing
	正:positive
	渡り歩く:travels through
	通過:pass through
	通過中:in transit
	過ぎていない:earlier than or equal to
	発する:emit
	表示し直す:redisplay

	●指示語
	A:first
	B:second
	ある種の:some
	こともある:sometimes
	それ以外の:remaining
	~~以前に:earlier
	より大きい:greater
	一部分:part
	作り上げ:make
	全体が収まる:wholly within
	全面的に／全く:entirely
	大部分:Much of
	残りの部分:rest


●●ref_normative

[Messaging]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP/1.1 Messaging” (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-messaging-latest.html
[RFC2119]
    Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, ~RFC2119, March 1997
[RFC3986]
    Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, ~RFC3986, January 2005
[RFC5234]
    Crocker, D., Ed. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, ~RFC5234, January 2008
[RFC7405]
    Kyzivat, P., “Case-Sensitive String Support in ABNF”, ~RFC7405, December 2014
[Semantics]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “HTTP Semantics” (work in progress). URL: https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html
[USASCII]
    American National Standards Institute, “Coded Character Set -- 7-bit American Standard Code for Information Interchange”, ANSI X3.4, 1986.

●●ref_informative

[RFC2616]
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, ~RFC2616, June 1999
[RFC5861]
    Nottingham, M., “HTTP Cache-Control Extensions for Stale Content”, ~RFC5861, April 2010
[RFC5905]
    Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, “Network Time Protocol Version 4: Protocol and Algorithms Specification”, ~RFC5905, June 2010
[RFC6265]
    Barth, A., “HTTP State Management Mechanism”, ~RFC6265, April 2011
[RFC7234]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP): Caching”, ~RFC7234, June 2014
[RFC8126]
    Cotton, M., Leiba, B., and T. Narten, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, ~RFC8126, June 2017


●●trans_metadata
<p>
~THIS_PAGEは、
<a href="https://www.ietf.org/">IETF</a>
による， Internet-Draft
<a href="~SPEC_URL">HTTP Caching</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
発行者
	HTTP Working Group
位置付け
	Internet-Draft
廃用
	7234 （承認されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集
	R. Fielding, Editor (Adobe)
	M. Nottingham, Editor (Fastly)
	J. Reschke, Editor (greenbytes)

履歴
	<a href="https://github.com/httpwg/http-core/commits/master">GitHub</a>
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache
HTTP working group mailing list
	ietf-http-wg@w3.org (<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>)
Draft HTTP Core Documents
	https://github.com/httpwg/http-core

</script>

</head>
<body>


<header>
	<hgroup>
<h1 title="HTTP Semantics">HTTP キャッシュ法（ Caching ）</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、分散型の協調的な~hypertext情報~system用の，`~stateless$な応用~levelの~protocolである。
この文書は、 ~HTTP~cacheと~~関連の［
~cacheの挙動を制御する／
~cache可能な応答~messageを指示する
］各種~headerを定義する。
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.
</p>

<p>
この文書は、 `RFC7234$r を廃用にする。
◎
This document obsoletes RFC 7234.
</p>

	</section>
	<section id="rfc.note.1">
<h2 title="Editorial Note">編集上の注記</h2>

<p>
この注記は、~RFCとして発行する前に除去されることになる。
◎
This note is to be removed before publishing as an RFC.
</p>

<p>
この草案について論を交わす場, この草案の~source~codeや課題~listは、冒頭の仕様~metadataから見出せる。
◎
Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at &lt;https://lists.w3.org/Archives/Public/ietf-http-wg/&gt;.
◎
Working Group information can be found at &lt;https://httpwg.org/&gt;; source code and issues list for this draft can be found at &lt;https://github.com/httpwg/http-core&gt;.
</p>

<p>
この草案における変更点は、 `C$sec 【！C.8】に要約されている。
◎
The changes in this draft are summarized in Appendix C.8.
</p>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
<a href="~HTTPcommon#status-draft">~HTTP共通~page</a>に委譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en-x-a0">
Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="~HTTPcommon#copyright-notice">~HTTP共通~page</a>に委譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="caching">
<h2 title="Introduction">1. 序論</h2>

<p>
~HTTP（ `Hypertext Transfer Protocol^en ）は、［
~networkに基づく，~hypertext情報~system
］と柔軟にヤリトリするために［
拡張-可能な意味論, および自己記述的な~message
］を利用する，`~stateless$な応用~levelの［
要請, 応答
］~protocolである。
~HTTPは、次に挙げる［
`~HTTP11$仕様を総集的に形成する一連の文書
］により定義される
⇒＃
<a href="~HTTPsem">~HTTP意味論</a> `Semantics$r,
~HTTP~cache法（この文書）,
<a href="~HTTPmsg">~HTTP11~message法</a> `Messaging$r
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive messages for flexible interaction with network-based hypertext information systems. HTTP is defined by a series of documents that collectively form the HTTP/1.1 specification:
• "HTTP Semantics" [Semantics]
• "HTTP Caching" (this document)
• "HTTP/1.1 Messaging" [Messaging]
</p>

<p>
~HTTPは、概して，分散型の情報~system用に利用され、そこでの処理能は，応答~cacheの利用により改善し得る。
この文書は、~HTTPに関係する，応答~messageの~cache法と再利用-法を成す側面を定義する。
◎
HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. This document defines aspects of HTTP related to caching and reusing response messages.
</p>

<p>
~HTTP
`~cache@
は、応答~messageの局所的な格納域であり，その中に格納される~messageたちの［
蓄積, 検索取得, 削除
］を制御する下位systemである。
~cacheは、未来の等価な要請に対する［
応答~時間や~network帯域幅の消費量
］を抑制するために，~cache可能な応答を格納する。
どの［
`~client$／`~server$
］も，~cacheを使役してヨイ
— `~tunnel$として動作する~serverは、~cacheを利用できないが。
◎
An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server that is acting as a tunnel.
</p>

<p>
`共用~cache@
は，複数の利用者により再利用されるような応答を格納する~cacheである
— それは、（常にではないが）通例的に，`中継者$の一部分として配備される。
対照的に，
`私用~cache@
は、単独の利用者ごとに専用であり，~UAの~componentとして配備されることが多い。
◎
A shared cache is a cache that stores responses to be reused by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary. A private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.
</p>

<p>
~HTTPにおける~cachingの目標は、先立つ応答~messageを再利用して，現在の要請を満足することにより、処理能を有意に改善することである。
【†~cacheに】格納-済みな応答は
— `鮮度$secにて定義されるように —
応答が`検証$（`生成元~server$による［
この要請~用の~cache済み応答が有効であり続ける
］かどうかの検査ng
）を伴わずに再利用できるとき，`新鮮$であると見なされる。
したがって，`新鮮$な応答は、再利用される度に，遅延, ~network~overheadの両者を抑制し得る。
~cache済み応答が`新鮮$でないときでも，［
`検証$により新鮮化できる, または
生成元~serverが可用でない
］ときは、依然として再利用できることもある（ `4.2.4$sec ）。
◎
The goal of caching in HTTP is to significantly improve performance by reusing a prior response message to satisfy a current request. A stored response is considered "fresh", as defined in Section 4.2, if the response can be reused without "validation" (checking with the origin server to see if the cached response remains valid for this request). A fresh response can therefore reduce both latency and network overhead each time it is reused. When a cached response is not fresh, it might still be reusable if it can be freshened by validation (Section 4.3) or if the origin is unavailable (Section 4.2.4).
</p>

<p class="trans-note">【†
この仕様の語 “格納-済み（ stored ）” は、 “~cacheに格納-済み” の略記として用いられている。
“~cache済み（ cached ）” も同義と見受けられる。
】</p>

<p>
この文書は、 `RFC7234$r を廃用にする
— 変更点は、 `B$sec に要約されている。
◎
This document obsoletes RFC 7234, with the changes being summarized in Appendix B.
</p>

		<section id="intro.requirements">
<h3 title="Requirements Notation">1.1. 要件の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#requirements-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
適合性の判定基準, ~errorの取扱いに関する考慮点は、
`適合性$sec `Semantics$r
に定義される。
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
◎
Conformance criteria and considerations regarding error handling are defined in Section 3 of [Semantics].
</p>

		</section>
		<section id="notation">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
<a href="~HTTPcommon#syntax-notation">~HTTP共通~page</a>
に委譲。
】</p>

<p>
`A$sec にて、すべての~list演算子を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], extended with the notation for case-sensitivity in strings defined in [RFC7405].
◎
It also uses a list extension, defined in Section 12 of [Semantics], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition).＼
◎
Appendix A shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
</p>

<p>
次に挙げる規則は `Semantics$r にて定義される
⇒＃
`HTTP-date$p,
`OWS$p,
`field-name$p,
`quoted-string$p,
`token$p,
◎
The rules below are defined in [Semantics]:
◎
HTTP-date     = &lt;HTTP-date, see [Semantics], Section 10.1.1.1&gt;
OWS           = &lt;OWS, see [Semantics], Section 11.1&gt;
field-name    = &lt;field-name, see [Semantics], Section 4.1&gt;
quoted-string = &lt;quoted-string, see [Semantics], Section 4.2.3.2&gt;
token         = &lt;token, see [Semantics], Section 4.2.3.1&gt;
</p>

		</section>
		<section id="delta-seconds">
<h3 title="Delta Seconds">1.3. ~delta秒</h3>

<p>
`delta-seconds$p 規則は、秒数を表現する，非負~整数を指定する。
◎
The delta-seconds rule specifies a non-negative integer, representing time in seconds.
</p>

<pre class="ABNF">
`delta-seconds@p
    = 1*`DIGIT$P
</pre>

<p>
`受信者$は、［
`delta-seconds$p 値を構文解析して~binary形に変換する
］際には，［
少なくとも 31~bit以上, かつ非負~整数の範囲をとる，算術~型
］を利用する~OUGHT。
`delta-seconds$p 値を受信した~cacheは、その値が［
自身が表現できる最大の整数より大きい, または
自身による後続の計算にて桁溢れする
］場合には，［
2147483648（ 2 の 31 乗）, または
都合よく表現できる最大の正~整数
］と見なさなければナラナイ。
◎
A recipient parsing a delta-seconds value and converting it to binary form ought to use an arithmetic type of at least 31 bits of non-negative integer range. If a cache receives a delta-seconds value greater than the greatest integer it can represent, or if any of its subsequent calculations overflows, the cache MUST consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.
</p>

<p class="note">注記：
ここでの値 2147483648 は、歴史的な理由による
— それは実質的に無限（ 68 年~以上）を表現する。
この値は~binary形として格納される必要はない
— 実装は、［
その数を直接的に表現できないような算術~型により計算が遂行される
］ときでも、桁溢れが生じた場合には，~canned文字列†として生産できる。
ここで~~重視されるのは、桁溢れが検出され，今後の計算において負~値に扱われないことである。
【† 単に，その数を表現する文字列？ または、ある上限~整数を表現する定義済み文字列？】
◎
Note: The value 2147483648 is here for historical reasons, effectively represents infinity (over 68 years), and does not need to be stored in binary form; an implementation could produce it as a canned string if any overflow occurs, even if the calculations are performed with an arithmetic type incapable of directly representing that number. What matters here is that an overflow be detected and not treated as a negative value in later calculations.
</p>

		</section>
	</section>
	<section id="caching.overview">
<h2 title="Overview of Cache Operation">2. ~cache運用の概観</h2>

<p>
~cacheを適正に運用することで、~HTTP転送の意味論（ `Semantics$r ）を保全しつつ，すでに~cache内に保持されている情報の転送を抑制できるようになる。
~HTTPにおける~cachingは，全面的に`任意選択^2119な特能であるが、［
~cache済み応答を再利用することは望ましいものであり、そのような再利用は，それを防止するような［
要件や局所的な環境設定
］が無ければ，既定の挙動である
］ものと見做せる。
したがって，~HTTP~cacheに課される要件は、~cacheに対し，［
特定0の応答を，常に格納して再利用する
］ことを義務付けるのではなく，［
再利用できない応答を格納すること ／
格納-済み応答を不適切に再利用すること
］を防止することに力点が置かれる。
◎
Proper cache operation preserves the semantics of HTTP transfers ([Semantics]) while reducing the transfer of information already held in the cache. Although caching is an entirely OPTIONAL feature of HTTP, it can be assumed that reusing a cached response is desirable and that such reuse is the default behavior when no requirement or local configuration prevents it. Therefore, HTTP cache requirements are focused on preventing a cache from either storing a non-reusable response or reusing a stored response inappropriately, rather than mandating that caches always store and reuse particular responses.
</p>

<p>
`~cache~key@
の基底を成すものは、格納-済み応答を検索取得するために利用された［
`要請~method$,
`~target~URI$
］である
— ~methodは、［
その応答は，どの状況下で要請を満足するために利用できるか
］を決定する。
しかしながら，今日における多くの~HTTP~cacheの共通的な利用では、［
`GET$m に対する応答のみを~cacheして，他の~methodは回送している
］ので，~cache~keyとして~URIしか利用していない。
◎
The base cache key consists of the request method and target URI used to retrieve the stored response; the method determines under which circumstances that response can be used to satisfy a request. However, many HTTP caches in common use today only cache GET responses, and therefore only use the URI as the cache key, forwarding other methods.
</p>

<p>
`要請~target$が`内容~折衝$の~subjectである場合、~cacheは，それ用に複数の応答を格納するかもしれない。
~cacheは、元の要請の`選定用~header$の値も
— `4.1$sec に従って —
~cache~keyの中に組入れることにより，これらの応答を相違化する。
◎
If a request target is subject to content negotiation, the cache might store multiple responses for it. Caches differentiate these responses by incorporating values of the original request's selecting header fields into the cache key as well, as per Section 4.1.
</p>

<p>
更には、~cacheは，~cache~keyの中に追加的な素材を組入れるかもしれない。
例えば，~UA~cacheは、ある種の~privacy~riskを避けるため，参照元~siteの同一性も内包して~cache~keyを “二重化する” かもしれない（ `7.2$sec を見よ）。
◎
Furthermore, caches might incorporate additional material into the cache key. For example, user agent caches might include the referring site's identity, thereby "double keying" the cache to avoid some privacy risks (see Section 7.2).
</p>

<p>
~cacheが最も共通的に格納するのは、検索取得~要請に対する成功裡な結果
— すなわち、 `GET$m 要請に対する `200$st 応答であって，
`要請~target$により識別された資源の表現を包含するもの —
である。
しかしながら，［
~redirect／
否定的な結果（例： `404$st ）／
不完全【または部分的】な結果（例： `206$st ）／
`GET$m 以外の~methodに対する応答
］を格納することもアリである
— 当の~methodの定義が、そのような~cache法を許容していて，~cache~key用の利用に相応しい何かを定義するならば。
◎
Most commonly, caches store the successful result of a retrieval request: i.e., a 200 (OK) response to a GET request, which contains a representation of the resource identified by the request target (Section 7.3.1 of [Semantics]). However, it is also possible to store redirects, negative results (e.g., 404 (Not Found)), incomplete results (e.g., 206 (Partial Content)), and responses to methods other than GET if the method's definition allows such caching and defines something suitable for use as a cache key.
</p>

<p>
~cacheは、［
`生成元~server$に接触できない, あるいは所与の要請を回送する経路を見出せなくなった
］とき，
`切断されて@
いるとされる。
`切断されて$いる~cacheであっても、一部の状況下では`非新鮮$な応答を~serveし得る（ `4.2.4$sec ）。
◎
A cache is disconnected when it cannot contact the origin server or otherwise find a forward path for a given request. A disconnected cache can serve stale responses in some circumstances (Section 4.2.4).
</p>

	</section>
	<section id="response.cacheability">
<h2 title="Storing Responses in Caches">3. ~cache内への応答の格納-法</h2>

<p>
要請に対する応答を~cacheが格納し得るのは、次のいずれも満たされる場合に限られる
— 他の応答は格納してはナラナイ：
◎
A cache MUST NOT store a response to any request, unless:
</p>

<ul>
	<li>
~cacheは、`要請~method$を解する。†
◎
The request method is understood by the cache, and
</li>
	<li>
応答は最終~応答（ `Messaging/9.3$sec ）である（その`状態s~code$は `1xx$st0 でない）。
◎
the response status code is final (see Section 9.3 of [Messaging]), and
</li>
	<li>
~cacheは、`応答~状態s~code$を解する。†
◎
the response status code is understood by the cache, and
</li>
	<li>
応答~内に， `no-store$sdir `~cache指令$は出現していない。
◎
the "no-store" cache directive (see Section 5.2) does not appear in the response, and
</li>
	<li>
<p>
~cacheは`共用~cache$でないか, または［
`共用~cache$であって，次のいずれも満たされる
］：
◎
↓</p>
		<ul>
			<li>
応答~内に `private$sdir 応答~指令は出現していない。
◎
the "private" response directive (see Section 5.2.2.6) does not appear in the response, if the cache is shared, and
</li>
			<li>
要請~内に `Authorization$h ~headerは出現していない
— ただし、応答により明示的に格納-が許容されている場合を除く（ `3.2$sec を見よ）。
◎
the Authorization header field (see Section 8.5.3 of [Semantics]) does not appear in the request, if the cache is shared, unless the response explicitly allows it (see Section 3.2), and
</li>
		</ul>
	</li>
	<li>
<p>
応答は、次のいずれかを満たす：
◎
the response either:
</p>
		<ul>
			<li>
`Expires$h ~headerを包含している。
◎
contains an Expires header field (see Section 5.3), or
</li>
			<li>
`max-age$sdir 応答~指令を包含している。
◎
contains a max-age response directive (see Section 5.2.2.8), or
</li>
			<li>
`s-maxage$sdir 応答~指令を包含している, かつ ~cacheは`共有-$されている。
◎
contains a s-maxage response directive (see Section 5.2.2.9) and the cache is shared, or
</li>
			<li>
［
~cacheされることを許容する，`~cache制御~拡張$
］を包含している。
◎
contains a Cache Control Extension (see Section 5.2.3) that allows it to be cached, or
</li>
			<li>
`状態s~code$により，`経験的に~cache可能$であるものと定義されている。
◎
has a status code that is defined as heuristically cacheable (see Section 4.2.2), or
</li>
			<li>
`public$sdir 応答~指令を包含している。
◎
contains a public response directive (see Section 5.2.2.5).
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
上に挙げた，どの要件も，`~cache制御~拡張$により上書きされ得る。
◎
Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.
</p>

<p>†
この文脈においては、~cacheは，［
`要請~method$／`応答~状態s~code$
を認識した上で，［
指定された，~cachingに関係する挙動
］すべてを実装する
］ならば、それを “解する” とされる。
◎
In this context, a cache has "understood" a request method or a response status code if it recognizes it and implements all specified caching-related behavior.
</p>

<p class="note">注記：
通常の運用においては、一部の~cacheは，~cache検証子も`明示的な失効時刻$も無い応答を，格納しない
— そのような応答は、通例的に，格納しても有用にならないので。
しかしながら、~cacheがそのような応答を格納することも，禁制されない。
◎
Note that, in normal operation, some caches will not store a response that has neither a cache validator nor an explicit expiration time, as such responses are not usually useful to store. However, caches are not prohibited from storing such responses.
</p>

		<section id="incomplete.responses">
<h3 title="Storing Incomplete Responses">3.1. 不完全な応答の格納-法</h3>

<p>
応答~messageは、接続が~closeされるに先立って［
~frame法により指示される すべての~octet
］が可用にされたならば，完全であると見なされる。
［
明示的な~frame法が供されない下で，接続の~closeにより終端された応答~message
］は、［
`不完全$な応答と判別-不能であろうが，完全であると見なされる
］ことに注意（ `Messaging/6.3$sec を見よ）。
~cacheは、当の接続の終了は~errorであると検出した場合には，~closeで終了された応答を不完全であると見なすベキである。
［
尚早な終了による結果、応答が不正に~cacheされる
］のを避けたいと望む~serverは、明示的な~frame法の下で，応答を送信するベキである。
◎
A response message is considered complete when all of the octets indicated by its framing are available. Note that, when no explicit framing is provided, a response message that is ended by the connection's close is considered complete even though it might be indistinguishable from an incomplete response (see [Messaging], Section 6.3). A cache SHOULD consider a close-terminated response incomplete if the connection termination is detected to be an error. A server that wishes to avoid premature termination resulting in an incorrect cached response SHOULD send the response with explicit framing.
</p>

<p>
［
`要請~method$は `GET$m, かつ
`応答~状態s~code$は `200$st, かつ
応答の`~header節$については~~全体が受信された
］場合、~cacheは，不完全な応答~message本体を
— 格納される応答を不完全であると記録した上で —
格納してもヨイ。
同様に， `206$st 応答についても、それが不完全な `200$st 応答であったかのように格納してヨイ。
しかしながら~cacheは、［
`Range$h, `Content-Range$h
］~headerを~supportしない, または［
それらの~headerに利用される`範囲~単位$を解さない
］ならば，内容が［
不完全／`部分的$
］な応答を格納してはナラナイ。
◎
If the request method is GET, the response status code is 200 (OK), and the entire response header section has been received, a cache MAY store an incomplete response message body if the stored response is recorded as incomplete. Likewise, a 206 (Partial Content) response MAY be stored as if it were an incomplete 200 (OK) response. However, a cache MUST NOT store incomplete or partial-content responses if it does not support the Range and Content-Range header fields or if it does not understand the range units used in those fields.
</p>

<div class="p">
<p>
~cacheは：
◎
↓</p>

<ul>
	<li>
［
後続して`範囲~要請$を為すことにより得られた成功裡な応答
］を［
`3.3$sec に従って，格納-済み応答たちと結合する
］ことにより、不完全な格納-済み応答を完全にしてもヨイ。
◎
A cache MAY complete a stored incomplete response by making a subsequent range request (Section 8.3 of [Semantics]) and combining the successful response with the stored response, as defined in Section 3.3.＼
</li>
	<li>
応答が
【前項のように】
完全に作り上げられるか，または［
要請は，部分的【`範囲~要請$】であって［
不完全な応答の中に全体が収まるような範囲
］を指定している
］のでない限り、不完全な応答を，要請に対する回答として利用してはナラナイ。
◎
A cache MUST NOT use an incomplete response to answer requests unless the response has been made complete or the request is partial and specifies a range that is wholly within the incomplete response.＼
</li>
	<li>
`部分的な応答$を`~client$へ送信するときは、状態s~code `206$st を利用するなどにより，明示的に【不完全であるものと】~markしなければナラナイ。
◎
A cache MUST NOT send a partial response to a client without explicitly marking it as such using the 206 (Partial Content) status code.
</li>
</ul>

</div>

		</section>
		<section id="caching.authenticated.responses">
<h3 title="Storing Responses to Authenticated Requests">3.2. 認証-済み要請に対する応答の格納-法</h3>

<p>
`共用~cache$は、［
`Authorization$h ~headerを伴う要請に対する~cache済み応答
］を利用して，後続の要請を満足してはナラナイ
— ただし、［
そのような応答を格納することを許容する応答~指令
］が在る場合は除く。
◎
A shared cache MUST NOT use a cached response to a request with an Authorization header field (Section 8.5.3 of [Semantics]) to satisfy any subsequent request unless a response directive that allows such responses to be stored is present.
</p>

<p>
この仕様においては、次に挙げる `Cache-Control$h 応答~指令に，そのような効果がある
⇒＃
`must-revalidate$sdir,
`public$sdir,
`s-maxage$sdir
◎
In this specification, the following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
</p>

		</section>
		<section id="combining.responses">
<h3 title="Combining Partial Content">3.3. 部分的な内容の結合-法</h3>

<p>
応答は、接続が尚早に~closeされた, または
要請が 1 個~以上の `Range$p 指定子を利用した場合に、`部分的$な表現のみを転送することがある。
そのような転送が何度か行われたとき、~cacheは，同じ表現のいくつかの範囲を受信し得る。
~cacheは、これらの範囲を，［
それらすべてが同じ`強い検証子$を共有する, かつ
~cacheが `Semantics/9.3.7.3$sec に与える~client要件に準拠する
］ならば、単独の格納-済み応答に結合して，その応答を今後の要請を満足するために再利用してもヨイ。
◎
A response might transfer only a partial representation if the connection closed prematurely or if the request used one or more Range specifiers (Section 8.3 of [Semantics]). After several such transfers, a cache might have received several ranges of the same representation. A cache MAY combine these ranges into a single stored response, and reuse that response to satisfy later requests, if they all share the same strong validator and the cache complies with the client requirements in Section 9.3.7.3 of [Semantics].
</p>

<p>
~cacheは，［
新たな応答と 1 個~以上の格納-済み応答とを結合する
］ときは、新たな応答~内に供された他の~header
— ただし， `Content-Range$h は除く —
で，［
格納-済み応答~内の対応ng~headerすべての~instance
］を置換しなければナラナイ。
◎
When combining the new response with one or more stored responses, a cache MUST use the header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.
</p>

		</section>
	</section>
	<section id="constructing.responses.from.caches">
<h2 title="Constructing Responses from Caches">4. ~cacheからの応答の構築-法</h2>

<p>
受信された `要請^V に対し、~cacheが，自身に格納-済みな応答（以下，単に `応答^V ）を再利用できるためには、次のすべてが満たされなければナラナイ：
◎
When presented with a request, a cache MUST NOT reuse a stored response, unless:
</p>

<ul>
	<li>
`応答^V の `実効~要請~URI$と, `要請^V に提示されたそれが合致する。
◎
The presented effective request URI (Section 5.4 of [Semantics]) and that of the stored response match, and
</li>
	<li>
`応答^V に結付けられている要請~methodは、 `応答^V を `要請^V 用に利用することを許容している。
◎
the request method associated with the stored response allows it to be used for the presented request, and
</li>
	<li>
`応答^V に~~挙げられた どの`選定用~header$（もしあれば）も，
`要請^V に提示されたそれに合致する（ `4.1$sec を見よ）
◎
selecting header fields nominated by the stored response (if any) match those presented (see Section 4.1), and
</li>
	<li>
`応答^V は成功裡に`検証-$されている, または
`応答^V は、 `no-cache$sdir 応答~cache指令を包含しない。
◎
the stored response does not contain the no-cache cache directive (Section 5.2.2.2), unless it is successfully validated (Section 4.3), and
</li>
		</ul>
	</li>
	<li>
<p>
`応答^V は、次のいずれかを満たす：
◎
the stored response is either:
</p>
		<ul>
			<li>
`新鮮$である。
◎
fresh (see Section 4.2), or
</li>
			<li>
`非新鮮$であっても~serveすることが許容されている（ `4.2.4$sec ）。

◎
allowed to be served stale (see Section 4.2.4), or
</li>
			<li>
成功裡に`検証-$されている。
◎
successfully validated (see Section 4.3).
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
上に挙げた，どの要件も，`~cache制御~拡張$により上書きされ得る。
◎
Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.
</p>

<p>
~cacheは：
</p>

<ul>
	<li>
`検証$を伴わない要請を満足するために，格納-済み応答を利用するときには、［
格納-済み応答の `現在~齢$V に等しい値にされた `Age$h ~header
］を，応答~内に`生成し$なければナラナイ
— 応答~内にその~headerが在るならそれを置換して。
`4.2.3$sec を見よ。
◎
When a stored response is used to satisfy a request without validation, a cache MUST generate an Age header field (Section 5.1), replacing any present in the response with a value equal to the stored response's current_age; see Section 4.2.3.
</li>
	<li>
<p>
`安全$でない~methodを伴う要請に対しては、`生成元~server$に向けて，そのまま書き出さなければナラナイ
— すなわち，~cacheには、［
要請が回送されて, 対応ng応答が受信される
］までは、そのような要請に対する返信を`生成する$ことは，許容されない。
◎
A cache MUST write through requests with methods that are unsafe (Section 7.2.1 of [Semantics]) to the origin server; i.e., a cache is not allowed to generate a reply to such a request before having forwarded the request and having received a corresponding response.
</p>

<p>
注記：
`安全$でない要請は、すでに格納-済みな応答を無効化し得る
— `4.4$sec を見よ。
◎
Also, note that unsafe requests might invalidate already-stored responses; see Section 4.4.
</p>
	</li>
	<li>
相応しい格納-済み応答が複数あるときは、（ `Date$h ~headerにより決定される）最も近過去のものを利用しなければナラナイ。
また、要請に
"`Cache-Control: max-age=0^c", あるいは
"`Cache-Control: no-cache^c"
を伴わせた上で，回送して、利用する応答を一義化できる。
◎
When more than one suitable response is stored, a cache MUST use the most recent one (as determined by the Date header field). It can also forward the request with "Cache-Control: max-age=0" or "Cache-Control: no-cache" to disambiguate which response to use.
</li>
	<li>
`時計$が可用でないときは、格納-済み応答を，`再検証-$することなく利用してはナラナイ
— どの利用においても。
◎
A cache that does not have a clock available MUST NOT use stored responses without revalidating them upon every use.
</li>
</ul>

		<section id="caching.negotiated.responses">
<h3 title="Calculating Cache Keys with Vary">4.1. `Vary^h による~cache~keyの計算-法</h3>

<p>
~cacheが［
格納-済み応答により満足できるような，要請
］を受信したとき，その応答に `Vary$h ~headerが在る場合には、［
その~header値に~~挙げられた，すべての`選定用~header$
］について，［
元の要請（すなわち，格納-済み応答に結付けられているもの）と
今の要請が，以下に述べるように合致する
］場合を除き、その応答を利用してはナラナイ：
◎
When a cache receives a request that can be satisfied by a stored response that has a Vary header field (Section 10.1.4 of [Semantics]), it MUST NOT use that response unless all of the selecting header fields nominated by the Vary header field match in both the original request (i.e., that associated with the stored response), and the presented request.
</p>

<ul>
	<li>
<p>
所与の`選定用~header$に対し， 2 つの要請のそれが互いに合致するための必要十分条件は、［
それぞれの要請に，次に挙げるいくつかを適用することにより、一方の要請の`~header値$を他方のそれに変形できるとき
］と定義される：
◎
The selecting header fields from two requests are defined to match if and only if those in the first request can be transformed to those in the second request by applying any of the following:
</p>

		<ul>
			<li>
~headerの構文にて許容される所で，空白を追加する／除去する。
◎
• adding or removing whitespace, where allowed in the header field's syntax
</li>
			<li>
同じ`~header名$の，複数の`~header値$を`結合-$する。
◎
• combining multiple header fields with the same field name (see Section 4.2 of [Semantics])
</li>
			<li>
両~header値を、［
~headerの仕様に則って，意味論が一致することが既知である
］ような仕方で正規化する（例：［
順序が有意でない所では，`~header値$を並替える
］, ［
文字大小無視と定義されている所では，小文字（または大文字）のみに正規化する
］, 等々）。
◎
• normalizing both header field values in a way that is known to have identical semantics, according to the header field's specification (e.g., reordering field values when order is not significant; case-normalization, where values are defined to be case-insensitive)
</li>
		</ul>
	</li>
	<li>
（正規化を終えた後に，）対象の~headerが片方の要請のみに在る場合は、合致しないものとする。
◎
If (after any normalization that might take place) a header field is absent from a request, it can only match another request if it is also absent there.
</li>
	<li>
`Vary$h ~header値 "`*^c" は、常に合致しない。
【他方のそれも "`*^c" であっても】
◎
A Vary header field-value of "*" always fails to match.
</li>
</ul>

<p>
格納-済み応答のうち，すべての`選定用~header$について合致するものは、
`被選定~応答@
と呼ばれる。
◎
The stored response with matching selecting header fields is known as the selected response.
</p>

<p>
複数の`被選定~応答$（ `Vary$h ~headerを伴わない応答も含む）が可用な場合、~cacheは，利用する 1 つを選ぶ必要がある。
`選定用~header$がそのための既知な仕組みを備える場合（例： `Accept$h や それに類する要請~header上の，`品質値$）、その仕組みが，選好される応答を選定するために利用されてもヨイ
— それ以外の所では、 `4$sec に従って（ `Date$h ~headerにより決定される）最も近過去の応答が利用される。
◎
If multiple selected responses are available (potentially including responses without a Vary header field), the cache will need to choose one to use. When a selecting header field has a known mechanism for doing so (e.g., qvalues on Accept and similar request header fields), that mechanism MAY be used to select preferred responses; of the remainder, the most recent response (as determined by the Date header field) is used, as per Section 4.
</p>

<p>
実施においては、応答~上に `Vary$h ~headerを送信するかどうかが一貫でない資源もあることに注意。
~cache内に所与の`~target~URI$用の応答が複数あって，
`Vary$h ~headerが省略されたものも混じっている場合、可用な空でない値のうち最も近過去なものを利用して，当の要請用に適切な応答を選定するベキである。
◎
Note that in practice, some resources might send the Vary header field on responses inconsistently. When a cache has multiple responses for a given target URI, and one or more omits the Vary header field, it SHOULD use the most recent non-empty value available to select an appropriate response for the request.
</p>

<p>
可用な`被選定~応答$が無い場合、~cacheは，提示された要請を満足できない
— その場合、概して，要請~内に示される`生成元~server$へ回送される（場合によっては条件付きにして — `検証$secを見よ）。
◎
If no selected response is available, the cache cannot satisfy the presented request. Typically, it is forwarded to the origin server in a (possibly conditional; see Section 4.3) request.
</p>

		</section>
		<section id="expiration.model">
<h3 title="Freshness">4.2. 鮮度</h3>

<p>
`齢$が`鮮度維持期間$を超過していない応答は、
`新鮮@
（ fresh ）であるとされる。
逆に，それを超過した応答は、
`非新鮮@
（ stale ）とされる。
◎
A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.
</p>

<p class="trans-note">【
この定義は，超過したかどうかを計算できることが前提にある。
（`4.2.4$sec の記述に従うなら、計算できない場合は，新鮮と見なされる？）
】</p>

<p>
応答の
`鮮度維持期間@
とは、［
それが`生成元~server$により`生成され$た時刻から，その`失効時刻$まで
］の~~期間である。
`失効時刻@
とは、それを過ぎて以降は，［
格納-済み応答は、更なる`検証$を伴わない限り，~cacheにより利用できない
］とされる時刻である。
`明示的な失効時刻@
とは、`生成元~server$が意図する`失効時刻$である。
一方で，
`経験的な失効時刻@
とは、`明示的な失効時刻$が可用でないときに，~cacheによりアテガわれる`失効時刻$である。
◎
A response's freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.
</p>

<p>
応答の
`齢@
とは、`生成元~server$により［
それが`生成され$た, もしくは
成功裡に`検証-$された
］ときから，経過した時間である。
◎
A response's age is the time that has passed since it was generated by, or successfully validated with, the origin server.
</p>

<p>
~cache内の応答は、`新鮮$である間は［
`生成元~server$に接触することなく，後続の要請を満足する
］ために利用でき、それにより，効率性を改善させる。
◎
When a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.
</p>

<p>
`生成元~server$にとり，`鮮度$を決定するための首な仕組みは、［
`Expires$h ~header, または
`max-age$sdir 応答~指令
］を利用して，未来の`明示的な失効時刻$を供することである。
一般に，`生成元~server$は、［［
およそ，それまでは［
`表現$が意味論的に有意な仕方で変化しない
］と見込まれる
］ような、未来の`失効時刻$
］を，`明示的な失効時刻$として応答にアテガうことになる。
◎
The primary mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using either the Expires header field (Section 5.3) or the max-age response directive (Section 5.2.2.8). Generally, origin servers will assign future explicit expiration times to responses in the belief that the representation is not likely to change in a semantically significant way before the expiration time is reached.
</p>

<p>
`生成元~server$が、~cacheに対し，毎~要請ごとの`検証$を強制したいときには、過去を~~指す`明示的な失効時刻$をアテガって，応答がすでに`非新鮮$であることを指示できる。
準拠~cacheは、通常は，`非新鮮$な~cache済み応答を［
後続の要請~用に再利用する
］前に，`検証-$することになる（`4.2.4$sec を見よ）。
◎
If an origin server wishes to force a cache to validate every request, it can assign an explicit expiration time in the past to indicate that the response is already stale. Compliant caches will normally validate a stale cached response before reusing it for subsequent requests (see Section 4.2.4).
</p>

<p>
`生成元~server$は，［
常に，`明示的な失効時刻$を供する
］わけではないので、~cacheには，一定の状況下で，`失効時刻$を決定する経験則を利用することも許容される（ `4.2.2$sec を見よ）。
◎
Since origin servers do not always provide explicit expiration times, caches are also allowed to use a heuristic to determine an expiration time under certain circumstances (see Section 4.2.2).
</p>

<p>
応答は、
<span class="expression">
( `鮮度維持期間$V &gt; `現在~齢$V )
</span>
であるとき，
<dfn id="response_is_fresh">`新鮮$である</dfn>
ものと決定される。
◎
The calculation to determine if a response is fresh is:
◎
response_is_fresh = (freshness_lifetime &gt; current_age)
◎
freshness_lifetime is defined in Section 4.2.1; current_age is defined in Section 4.2.3.
</p>

<p>
`~client$は、［
`max-age$qdir や `min-fresh$qdir
］要請~指令を送信して，対応ng応答に対する`鮮度$の計算を［
拘束する／緩める
］ことができる。
しかしながら，~cacheには、それらを尊守することは要求されてはいない。
◎
Clients can send the max-age or min-fresh request directives (Section 5.2.1) to constrain or relax freshness calculations for the corresponding response. However, caches are not required to honor them.
</p>

<p>
`日時$の構文解析-法に共通的にある問題を避けるため、~cache`受信者$は，鮮度を計算するときには：
◎
When calculating freshness, to avoid common problems in date parsing:
</p>

<ul>
	<li>
すべての`日時$ 形式は，文字大小区別として指定されているが、［
`day, week, time-zone^en
］の名前†は，文字大小無視で照合するベキである。
【† `day-name$p, `GMT$p の他に `month$p も含まれる？ 】
◎
• Although all date formats are specified to be case-sensitive, a cache recipient SHOULD match day, week, and time-zone names case-insensitively.
</li>
	<li>
自身の内部~実装による時刻の分解能が `HTTP-date$p 値のそれより粗い場合、構文解析した `Expires$h 日時を，［
受信された値を超えない最も近い時刻
］として，内部的に表現しなければナラナイ。【！＊】
◎
• If a cache recipient's internal implementation of time has less resolution than the value of an HTTP-date, the recipient MUST internally represent a parsed Expires date as the nearest time equal to or earlier than the received value.
</li>
	<li>
地域的な時間帯を，［
`齢$や`失効時刻$
］の［
計算, および比較
］に波及させてはナラナイ。
◎
• A cache recipient MUST NOT allow local time zones to influence the calculation or comparison of an age or expiration time.
</li>
	<li>
失効時刻の計算-時には、［［
"`GMT^c", "`UTC^c"
以外の時間帯 略語
］が伴われた`日時$
］は，無効と見なすベキである。
◎
• A cache recipient SHOULD consider a date with a zone abbreviation other than GMT or UTC to be invalid for calculating expiration.
</li>
</ul>

<p class="note">注記：
鮮度が適用されるのは、~cache運用に限られる
— 表示の~refreshや, `資源$の~reloadを~UAに強制する用途には利用できない。
~cacheと履歴の仕組みとの相違点は、 `6$sec に説明される。
◎
Note that freshness applies only to cache operation; it cannot be used to force a user agent to refresh its display or reload a resource. See Section 6 for an explanation of the difference between caches and history mechanisms.
</p>

			<section id="calculating.freshness.lifetime">
<h4 title="Calculating Freshness Lifetime">4.2.1. 鮮度維持期間の計算</h4>

<p>
~cacheは、次のうち，最初に合致する項目による値を利用して，応答の`鮮度維持期間$を計算できる（その計算結果は、
`鮮度維持期間@V
と称される）：
◎
A cache can calculate the freshness lifetime (denoted as freshness_lifetime) of a response by using the first match of the following:
</p>

<ul>
	<li>
~cacheは`共有-$されている, かつ
`s-maxage$sdir 応答~指令が在る場合：
その値。
◎
• If the cache is shared and the s-maxage response directive (Section 5.2.2.9) is present, use its value, or
</li>
	<li>
`max-age$sdir 応答~指令が在る場合：
その値。
◎
• If the max-age response directive (Section 5.2.2.8) is present, use its value, or
</li>
	<li>
`Expires$h 応答~headerが在る場合：
<span class="expression">(その値) − (`Date$h 応答~headerの値)</span>
。
◎
• If the Expires response header field (Section 5.3) is present, use its value minus the value of the Date response header field, or
</li>
	<li>
他の場合：
応答~内には`明示的な失効時刻$は無い。
`経験的な$`鮮度維持期間$が適用-可能になり得る
— `4.2.2$sec を見よ。
◎
• Otherwise, no explicit expiration time is present in the response. A heuristic freshness lifetime might be applicable; see Section 4.2.2.
</li>
</ul>

<p class="note">注記：
この計算は，時計~同期調整に脆弱でない
— すべての情報は、`生成元~server$から来るので。
◎
Note that this calculation is not vulnerable to clock skew, since all of the information comes from the origin server.
</p>

<p>
所与の指令~用の値が複数~在る場合（例：
複数の `Expires$h ~header,
複数の "`Cache-Control: max-age^c" 指令）、その指令の値は，無効と見なされる。
~cacheは、応答の`鮮度$~情報が無効な場合には，それを`非新鮮$と見なすことが奨励される。
◎
When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives), the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale.
</p>

			</section>
			<section id="heuristic.freshness">
<h4 title="Calculating Heuristic Freshness">4.2.2. 鮮度の経験的な計算-法</h4>

<p>
`生成元~server$は，常に`明示的な失効時刻$を供するわけではない。
したがって，明示的な時刻が指定されていないときは、~cacheは，［
確からしい`失効時刻$を見積もる
］ために［
他の~header値（ `Last-Modified$h による時刻など）を利用する~algo
］を使役して，`経験的な失効時刻$をアテガってもヨイ。
この仕様は，特定の~algoは供さないが、それらの結果に対する~~最低限の拘束を課す。
◎
Since origin servers do not always provide explicit expiration times, a cache MAY assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other header field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but does impose worst-case constraints on their results.
</p>

<p>
~cacheは、格納-済み応答~内に`明示的な失効時刻$が在るときには，`鮮度$を決定する経験則を利用してはナラナイ。
何故なら， `3$sec による要件が実質的に意味するのは、経験則を利用し得るのは，明示的な鮮度を伴わない応答のうち［
`状態s~code$が
`経験的に~cache可能^dfn
である（例： `Semantics/9.1$sec を見よ）ものと定義された応答, あるいは
明示的に~cache可能であると~markされた応答（例： `public$sdir 応答~指令により）
］に限られることなので。
◎
A cache MUST NOT use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3, this means that, effectively, heuristics can only be used on responses without explicit freshness whose status codes are defined as "heuristically cacheable" (e.g., see Section 9.1 of [Semantics]), and those responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a "public" response directive).
</p>

<p>
以前までの仕様は、経験的に~cache可能な`応答~状態s~code$を， “既定で~cache可能” と称していたことに注意。
◎
Note that in previous specifications heuristically cacheable response status codes were called "cacheable by default."
</p>

<p>
応答に `Last-Modified$h ~headerが在る場合、~cacheには，［
その時刻から現在時までの時区間に対する ある割合
］を超えないような，`経験的な$失効~値を利用することが奨励される。
この割合の代表的な設定は `10%^ 程度になるであろう。
◎
If the response has a Last-Modified header field (Section 10.2.2 of [Semantics]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.
</p>

<p class="note">注記：
`RFC2616/13.9$sec では、［
~query成分を伴う~URI（すなわち， `?^c を包含する~URI）
］に対しては，~cacheによる経験的な鮮度の計算-法を禁制していたが、実施においては，これは広範に実装されていない。
したがって，`生成元~server$には、~cachingを妨げたいと望む場合には，明示的な指令を送信することが奨励される（例：
`Cache-Control: no-cache^c
）。
◎
Note: Section 13.9 of [RFC2616] prohibited caches from calculating heuristic freshness for URIs with query components (i.e., those containing '?'). In practice, this has not been widely implemented. Therefore, origin servers are encouraged to send explicit directives (e.g., Cache-Control: no-cache) if they wish to preclude caching.
</p>

			</section>
			<section id="age.calculations">
<h4 title="Calculating Age">4.2.3. 齢の計算-法</h4>

<p>
`Age$h ~headerは、［
応答~messageが~cacheから得られるときに，見積もられた`齢$を伝達する
］ために利用される。
`Age$h ~headerの値は、~cacheにより見積もられた，［
その応答が`生成元~server$により［
`生成され$た, または`検証-$された
］ときからの秒~数
］である。
~~本質的に， `Age^h 値は、応答が［
`生成元~server$からの経路~沿いにある，各~cache
］に滞在していた時間と［
~network経路に沿って通過中の経過時間
］を足したものである。
◎
The Age header field is used to convey an estimated age of the response message when obtained from a cache. The Age field value is the cache's estimate of the number of seconds since the response was generated or validated by the origin server. In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.
</p>

<p>
`齢$の計算には次の~dataが利用される：
◎
The following data is used for the age calculation:
</p>

<dl>
	<dt>【まず，以下の記述に用いられている語の意味を補足する：】</dt>
	<dd class="trans-note">
		<dl>
			<dt>`応答^V</dt>
			<dd>
齢を計算する対象の，格納-済み応答。
</dd>
			<dt>`要請^V</dt>
			<dd>
`応答^V を格納-済みにさせた要請。
（原文の記述からは，はっきりしないが、成功裡に再検証させた要請があれば，それを指すようにも思われる。）
</dd>
			<dt>`~host^V</dt>
			<dd>
当の~cacheを使役している~HTTP通信の参加者。
</dd>
			<dt>`時計^V</dt>
			<dd>
`~host^V に局所的な時計。
</dd>

		</dl>
	</dd>

	<dt>`齢~値@V</dt>
	<dd>
`応答^V の `Age$h ~headerの値を，算術~演算に適切な形で表す値
— 可用でない場合†は 0。
【† 例えば、最も上流の~cacheが，その応答の再利用を初めて試みるとき】
◎
The term "age_value" denotes the value of the Age header field (Section 5.1), in a form appropriate for arithmetic operation; or 0, if not available.
</dd>

	<dt>`日時~値@V</dt>
	<dd>
`応答^V の `Date$h ~headerの値を，算術~演算に適切な形で表す値。
この~headerの定義, および それを伴わない応答に関する要件は、
§ `Date$h を見よ。
◎
The term "date_value" denotes the value of the Date header field, in a form appropriate for arithmetic operations. See Section 10.1.1.2 of [Semantics] for the definition of the Date header field, and for requirements regarding responses without it.
</dd>

	<dt>`現在時@V</dt>
	<dd>
`~host^V がこの計算を遂行している時点での， `時計^V の現在の値。
`~host^V は、［
NTP `RFC5905$r, または何らかの類似な~protocol
］を利用して， `時計^V を UTC（協定世界時, `Coordinated Universal Time^en ）に同期させる~OUGHT。
◎
The term "now" means "the current value of the clock at the host performing the calculation". A host ought to use NTP ([RFC5905]) or some similar protocol to synchronize its clocks to Coordinated Universal Time.
</dd>

	<dt>`要請~時刻@V</dt>
	<dd>
`要請^V が受信された時点での， `時計^V の値。
◎
The current value of the clock at the host at the time the request resulting in the stored response was made.
</dd>

	<dt>`応答~時刻@V</dt>
	<dd>
`応答^V が受信された時点での， `時計^V の値。
◎
The current value of the clock at the host at the time the response was received.
</dd>
</dl>

<p>
`応答^V の`齢$は、全く独立な 2 つの仕方で計算できる：
◎
A response's age can be calculated in two entirely independent ways:
</p>

<div class="p">

<dl>
	<dt><span class="expression">
`見かけ齢@V = max( 0, `応答~時刻$V − `日時~値$V )
</span></dt>
	<dd>
`時計^V と, `生成元~server$の`時計$とが、適度によく同期されているならば。
【！負の結果は 0 に置換される。】
</dd>

	<dt>
<span class="expression">
`修正済み齢~値@V = `齢~値$V + `応答~遅延^V
</span>;<span class="expression">
`応答~遅延^V = ( `応答~時刻$V − `要請~時刻$V )
</span>
</dt>
	<dd>
【！ 応答~遅延 = 応答~時刻 − 要請~時刻】
`応答^V の経路~沿いにある すべての~cacheが，`~HTTP11$以上を実装するならば。
~cacheは、この値を，［
`応答^V が受信された時刻ではなく， `要請^V が起動された時刻
］から相対的に解釈しなければナラナイ。
</dd>
</dl>

	<div lang="en">

<p>
the "apparent_age": response_time minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.
</p>

<p>
the "corrected_age_value", if all of the caches along the response path implement HTTP/1.1 or greater. A cache MUST interpret this value relative to the time the request was initiated, not the time that the response was received. 
</p>

<pre>
apparent_age = max(0, response_time - date_value);

response_delay = response_time - request_time;
corrected_age_value = age_value + response_delay;
</pre>
	</div>
</div>

<p>
これらは，次のように結合される：
◎
These are combined as
</p>

<p>
<span class="expression">
`修正済み初期~齢@V = max( `見かけ齢$V, `修正済み齢~値$V )
</span>
◎
corrected_initial_age = max( apparent_age, corrected_age_value );
</p>

<p>
…ただし、~cacheが `Age$h ~headerの値（ `齢~値$V ）に~~確信を持てる場合（例えば，`応答^V の `Via$h ~header内に~HTTP10を示唆する hop がないなど）には、
`修正済み初期~齢$V の代わりに `修正済み齢~値$V を利用してもヨイ。
◎
unless the cache is confident in the value of the Age header field (e.g., because there are no HTTP/1.0 hops in the Via header field), in which case the corrected_age_value MAY be used as the corrected_initial_age.
</p>

<p>
しかる後、 `応答^V の `現在~齢$V を計算できる
— `応答^V が`生成元~server$により
最後に`検証-$されたときから `修正済み初期~齢$V までの経過時間（秒）を加えて：
◎
The current_age of a stored response can then be calculated by adding the amount of time (in seconds) since the stored response was last validated by the origin server to the corrected_initial_age.
</p>

<p>
<span class="expression">
`滞在~時間@V = `現在時$V − `応答~時刻$V
</span><br />
<span class="expression">
`現在~齢@V = `修正済み初期~齢$V + `滞在~時間$V
</span>
◎
resident_time = now - response_time;
◎
current_age = corrected_initial_age + resident_time;
</p>

			</section>
			<section id="serving.stale.responses">
<h4 title="Serving Stale Responses">4.2.4. 非新鮮な応答の~serve法</h4>

<p>
応答が`非新鮮$であるとは、［
明示的な失効時期~情報が在る, または
失効時期の経験的な計算が許容されている
］ものであって，`鮮度$の計算に則って`新鮮$でないとされたものになる。
◎
A "stale" response is one that either has explicit expiry information or is allowed to have heuristic expiry calculated, but is not fresh according to the calculations in Section 4.2.
</p>

<div class="p">
<p>
~cacheは、~protocol内の明示的な`~cache指令$
— 例えば，次に挙げる指令 —
により禁制されている場合は，`非新鮮$な応答を`生成し$てはナラナイ：
</p>

<ul><li>`no-store$qdir ／ `no-cache$qdir 要請~cache指令
</li><li>`no-store$sdir ／ `no-cache$sdir 応答~cache指令
</li><li>`must-revalidate$sdir 応答~cache指令
</li><li>適用-可能な `s-maxage$sdir ／ `proxy-revalidate$sdir 応答~cache指令
</li></ul>

◎
A cache MUST NOT generate a stale response if it is prohibited by an explicit in-protocol directive (e.g., by a "no-store" or "no-cache" cache directive, a "must-revalidate" cache-response-directive, or an applicable "s-maxage" or "proxy-revalidate" cache-response-directive; see Section 5.2.2).
</div>

<p>
~cacheは、次のいずれかに該当する場合を除き，`非新鮮$な応答を生成してはナラナイ：
◎
A cache MUST NOT generate a stale response unless＼
</p>

<ul>
	<li>
`切断されて$いる
◎
it is disconnected or＼
</li>
	<li>
そうすることが~clientまたは生成元~serverにより明示的に許可されている
— 例
⇒＃
`max-stale$qdir 要請~指令により／
拡張~指令により（ `RFC5861$r に定義されるものなど）／
帯域外の契約に則った環境設定により
◎
doing so is explicitly permitted by the client or origin server (e.g., by the max-stale request directive in Section 5.2.1, by extension directives such as those defined in [RFC5861], or by configuration in accordance with an out-of-band contract).
</li>
</ul>

			</section>
		</section>
		<section id="validation.model">
<h3 title="Validation">4.3. 検証</h3>

<div class="p">
<p>
~cacheが，［
要請された~URI用に 1 個以上の格納-済み応答が在る
］が、それらのどれをも~serveできないときは（例：
それらが`新鮮$でないとき, または
1 つに選定できない（ `4.1$sec を見よ）ことから
）、要請を回送する際に，`条件付き要請$の仕組みを利用して、`内方$にある次の~serverに，次を行う機会を与えることができる：
◎
When a cache has one or more stored responses for a requested URI, but cannot serve any of them (e.g., because they are not fresh, or one cannot be selected; see Section 4.1), it can use the conditional request mechanism Section 8.2 of [Semantics] in the forwarded request to give the next inbound server an opportunity＼
</p>

<ul>
	<li>
利用する有効な格納-済み応答を選定する。
◎
to select a valid stored response to use,＼
</li>
	<li>
処理nにおいて格納-済み~metadataを更新する。
◎
updating the stored metadata in the process, or＼
</li>
	<li>
格納-済み応答（たち）を新たな応答で置換する。
◎
to replace the stored response(s) with a new response.＼
</li>
</ul>

<p>
この処理nは、格納-済み応答の［
`検証ng^dfn ／
`再検証ng^dfn
］として知られている。
◎
This process is known as "validating" or "revalidating" the stored response.
</p>
</div>

			<section id="validation.sent">
<h4 title="Sending a Validation Request">4.3.1. 検証~要請の送信</h4>

<p>
~cacheは，`検証$用に`条件付き要請$を生成するときは、満足しようと試みている要請から開始するか，あるいは要請を独立に起動している場合は、格納-済み応答を利用して要請を合成する
— ［
`~method$,
`request-target$p,
`Vary$h ~headerにより識別される要請~headerたち（`4.1$sec ）
］を複製することにより。
◎
When generating a conditional request for validation, a cache starts with either a request it is attempting to satisfy, or — if it is initiating the request independently — it synthesises a request using a stored response by copying the method, request-target, and request header fields identified by the Vary header field Section 4.1.
</p>

<p>
次に、1 つ以上の`事前条件~header$で，その要請を更新する。
これらは、同じ~cache~keyを持つ格納-済み応答（たち）を~sourceとする`検証子$~metadataを包含する。
◎
It then updates that request with one or more precondition header fields. These contain validator metadata sourced from stored response(s) that have the same cache key.
</p>

<p>
次に，`事前条件~header$は、`受信者$たちにより［
`資源$の現在の`表現$に等価な格納-済み応答が在るかどうか
］を決定するために比較される。
◎
The precondition header fields are then compared by recipients to determine whether any stored response is equivalent to a current representation of the resource.
</p>

<p>
そのような`検証子$の一つは、 `Last-Modified$h ~headerにて与えられる時刻印である
— それは、［
応答を`検証-$するために
`If-Modified-Since$h ~headerにて
］, あるいは［
`表現$を選定するために
`If-Unmodified-Since$h ／ `If-Range$h ~headerにて
］，利用できる（すなわち，~clientは、以前に得られた［
その時刻印を伴う`表現$
］を，特に指している）。
◎
One such validator is the timestamp given in a Last-Modified header field (Section 10.2.2 of [Semantics]), which can be used in an If-Modified-Since header field for response validation, or in an If-Unmodified-Since or If-Range header field for representation selection (i.e., the client is referring specifically to a previously obtained representation with that timestamp).
</p>

<p>
`検証子$には、 `ETag$h ~header内に与えられる `entity-tag$p もある。
1 個~以上の格納-済み応答を指示する 1 個~以上の `entity-tag$p を、［
応答を`検証-$するためとして
`If-None-Match$h ~headerにて
］, あるいは［
`表現$を選定するためとして
`If-Match$h ／ `If-Range$h
~headerにて
］，利用できる（すなわち，~clientは、以前に得られた［
~listされた `entity-tag$p を伴う， 1 個~以上の`表現$
］を，特に指している）。
◎
Another validator is the entity-tag given in an ETag header field (Section 10.2.3 of [Semantics]). One or more entity-tags, indicating one or more stored responses, can be used in an If-None-Match header field for response validation, or in an If-Match or If-Range header field for representation selection (i.e., the client is referring specifically to one or more previously obtained representations with the listed entity-tags).
</p>

			</section>
			<section id="validation.received">
<h4 title="Handling a Received Validation Request">4.3.2. 受信された検証~要請の取扱い</h4>

<p>
要請の`連鎖$沿いにある 各`~client$は，自前の~cacheを備えることもあるので、`中継者$における~cacheが［
他の（`外方$にある）~cacheから`条件付き要請$を受信する
］ことは，共通的にある。
同様に，一部の~UAは、［
近過去に改変された`表現$に対しては ~data転送を制限する／
`部分的$に検索取得された表現の転送を完了する
］ために，`条件付き要請$を用立てる。
◎
Each client in the request chain may have its own cache, so it is common for a cache at an intermediary to receive conditional requests from other (outbound) caches. Likewise, some user agents make use of conditional requests to limit data transfers to recently modified representations or to complete the transfer of a partially retrieved representation.
</p>

<div class="p">
<p>
要請を受信した~cacheは、［
自身に格納-済みな［
`200$st ／ `206$st
］応答を再利用することで，それを満足できる
］ならば，［
要請~内に見出された`条件付き要請~header$たちによる`事前条件$のうち，自身に適用-可能なもの
］を［
`被選定~応答$の中に包含されている対応ng`検証子$たち
］に対し評価するベキである
— ただし、次のいずれかに該当する事前条件は、評価してはナラナイ：
◎
If a cache receives a request that can be satisfied by reusing one of its stored 200 (OK) or 206 (Partial Content) responses, the cache SHOULD evaluate any applicable conditional header field preconditions received in that request with respect to the corresponding validators contained within the selected response.＼
A cache MUST NOT evaluate conditional header fields that are＼
</p>

<ul>
	<li>
`生成元~server$のみに適用-可能であるもの
◎
only applicable to an origin server,＼
</li>
	<li>
~cache済み応答により満足し得ない意味論を伴うもの
◎
found in a request with semantics that cannot be satisfied with a cached response, or＼
</li>
	<li>
~target`資源$のうち格納-済み応答が無いものに適用されるもの
◎
applied to a target resource for which it has no stored responses;＼
</li>
</ul>

<p>
これらの事前条件は、他の何らかの（`内方$にある）~server向けに意図されている見込みが高いので。
◎
such preconditions are likely intended for some other (inbound) server.
</p>

</div>

<p>
~cacheによる`条件付き要請$の適正な評価は、［
受信された`事前条件~header$たち, およびそれらの優先順（ `Semantics/8.2.2$sec ）
］に依存する。
条件付き~header［
`If-Match$h ／ `If-Unmodified-Since$h 
］は、~cacheには適用-可能でない。
◎
The proper evaluation of conditional requests by a cache depends on the received precondition header fields and their precedence, as defined in Section 8.2.2 of [Semantics]. The If-Match and If-Unmodified-Since conditional header fields are not applicable to a cache.
</p>

<p>
`If-None-Match$h ~headerを包含する要請は、［
`~client$が，自前の格納-済み応答（たち）と~cacheに格納-済みな`被選定~応答$（たち）とを
— 後者が何であれ —
比較して`検証-$するよう求めている
］ことを指示する。
その`~header値$が［
"`*^c" である, または［
`entity-tag$p の~listであって，そのうち いずれかが［
格納-済みな`被選定~応答$の `entity-tag$p
］に合致する
【すなわち，評価の結果が偽になる】
］］場合、~cache`受信者$は
— その合致した応答を送信する代わりに — 
（その応答の~metadataを利用して，） `304$st 応答を`生成する$ベキである。
◎
A request containing an If-None-Match header field (Section 8.2.4 of [Semantics]) indicates that the client wants to validate one or more of its own stored responses in comparison to whichever stored response is selected by the cache. If the field-value is "*", or if the field-value is a list of entity-tags and at least one of them matches the entity-tag of the selected stored response, a cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) instead of sending that stored response.
</p>

<div class="p">
<p>
~cacheは、［
`If-None-Match$h による`entity-tag$p の~list
— 以下， `L^V と記す —
を包含する要請
］用に，自前の格納-済み応答たちを`再検証-$するものと裁定したときには：
◎
When a cache decides to revalidate its own stored responses for a request that contains an If-None-Match list of entity-tags,＼
</p>

<ul>
	<li>
要請を回送する際に，その `If-None-Match$h ~header値を，［
`L^V と［
各［
自前の格納-済み応答（`新鮮$か否かを問わず）
］の `entity-tag$p たちからなる~list
］とを結合した結果の和集合
］に置き換えて送信してもヨイ
— ただし，
◎
the cache MAY combine the received list with a list of entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement If-None-Match header field value in the forwarded request.＼
</li>
	<li>
`部分的$な内容を包含するような格納-済み応答の `entity-tag$p は、この和集合からは除外しなければナラナイ
— ただし，要請が`範囲~要請$であり，その部分的な格納-済み応答で全部的に満足されることになる場合は除く。
◎
If a stored response contains only partial content, the cache MUST NOT include its entity-tag in the union unless the request is for a range that would be fully satisfied by that partial stored response.＼
</li>
	<li>
回送した要請に対する応答 `R^V が，［
`304$st である, かつ
`ETag$h ~headerを伴う, かつ
その~header値は `L^V 内に無い `entity-tag$p を含む
］場合、その `entity-tag$p に対応ng格納-済み応答を再利用しつつ,
`R^V の~metadataで更新した上で（ `4.3.4$sec ）、~clientに対し `200$st 応答を`生成し$なければナラナイ
◎
If the response to the forwarded request is 304 (Not Modified) and has an ETag header field value with an entity-tag that is not in the client's list, the cache MUST generate a 200 (OK) response for the client by reusing its corresponding stored response, as updated by the 304 response metadata (Section 4.3.4).
</li>
</ul>
</div>

<div class="p">
<p>
`If-None-Match$h ~headerは無いが
`If-Modified-Since$h ~headerは包含する要請は、［
`~client$は、自前の格納-済み応答（たち）について，その改変~日時を`検証-$するよう求めている
］ことを指示する。
~cache`受信者$は、格納-済みな`被選定~応答$
— 以下 `R^V と記す —
について，［
次に従って決定される時刻
］が在って［
`If-Modified-Since^h ~headerの値による時刻
］を過ぎていない
］ならば、（ `R^V の~metadataを利用して，） `304$st 応答を`生成する$ベキである：
◎
If an If-None-Match header field is not present, a request containing an If-Modified-Since header field (Section 8.2.5 of [Semantics]) indicates that the client wants to validate one or more of its own stored responses by modification date. A cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) if one of the following cases is true:＼
</p>

<ol>
	<li>
`R^V に `Last-Modified$h ~headerが在るならば、その値による時刻
◎
1) the selected stored response has a Last-Modified field-value that is earlier than or equal to the conditional timestamp;＼
</li>
	<li>
他の場合， `R^V に `Date$h ~headerが在るならば、その値による時刻
◎
2) no Last-Modified field is present in the selected stored response, but it has a Date field-value that is earlier than or equal to the conditional timestamp; or,＼
</li>
	<li>
他の場合，~cacheにて `R^V を受信した時刻が記録されて［
いるならば，その時刻 ／
いないならば，時刻は無い
］
◎
3) neither Last-Modified nor Date is present in the selected stored response, but the cache recorded it as having been received at a time earlier than or equal to the conditional timestamp.
</li>
</ol>

</div>

<p>
`範囲~要請$に対する`部分的な応答$を実装する~cacheは、
`範囲~要請^sec `Semantics$r にて定義されるように，受信された `If-Range$h ~headerを自身に格納-済みな`被選定~応答$に~~対して評価する必要もある。
◎
A cache that implements partial responses to range requests, as defined in Section 8.3 of [Semantics], also needs to evaluate a received If-Range header field (Section 8.2.7 of [Semantics]) with respect to its selected stored response.
</p>

			</section>
			<section id="validation.response">
<h4 title="Handling a Validation Response">4.3.3. 検証~応答の取扱い</h4>

<p>
~cacheによる［
`条件付き要請$に対する応答
］の取扱いは、その状態s~codeに依存する：
◎
Cache handling of a response to a conditional request is dependent upon its status code:
</p>

<ul>
	<li>
`応答~状態s~code$ `304$st は、格納-済み応答を［
更新できる／再利用できる
］ことを指示する。
◎
• A 304 (Not Modified) response status code indicates that the stored response can be updated and reused; see Section 4.3.4.
</li>
	<li>
全部的な応答（すなわち，`~payload本体$を伴うもの）は、［
`条件付き要請$~内に~~挙げられた，どの格納-済み応答
］も相応しくないことを指示する。
代わりに，~cacheは、要請を満足するために，その全部的な応答を利用しなければナラナイ
— また、格納-済み応答（たち）を置換してもヨイ。
◎
• A full response (i.e., one with a payload body) indicates that none of the stored responses nominated in the conditional request is suitable. Instead, the cache MUST use the full response to satisfy the request and MAY replace the stored response(s).
</li>
	<li>
<p>
しかしながら，~cacheは、［
応答の`検証$を試みている間に `5xx$st 応答を受信した
］ときには，次のいずれかを行える：
◎
• However, if a cache receives a 5xx (Server Error) response while attempting to validate a response, it can either＼
</p>
		<ul>
			<li>
要請している~clientへ，この `5xx^st0 応答を回送する。
◎
forward this response to the requesting client, or＼
</li>
			<li>
~serverが応答-に失敗したかのように動作する。
この場合、以前に格納-済みな応答を送信してもヨイ（`4.2.4$sec を見よ）。
◎
act as if the server failed to respond. In the latter case, the cache MAY send a previously stored response (see Section 4.2.4).
</li>
		</ul>
	</li>
</ul>

			</section>
			<section id="freshening.responses">
<h4 title="Freshening Stored Responses upon Validation">4.3.4. 検証にあたっての，格納-済み応答の新鮮化-法</h4>

<p>
`304$st 応答
— 以下，この節を通して `304 応答^V と記す —
を受信した~cacheは、適用~可能な`~cache~key$用の格納-済み `200$st 応答
— 以下，それらの集合を `S^V と記す —
が 1 個~以上あるときは、~cacheは，［
`S^V の中のどれを， `304 応答^V から供された新たな情報により更新する
］ことになるか識別して，それを行う必要がある。
◎
When a cache receives a 304 (Not Modified) response and already has one or more stored 200 (OK) responses for the applicable cache key, the cache needs to identify which (if any) are to be updated by the new information provided, and then do so.
</p>

<p>
更新~対象として選定される格納-済み応答（たち）は、 `304 応答^V の検証子に応じて，次で与えられる：
◎
The stored response(s) to update are identified by using the first match (if any) of the following:
</p>

<dl class="switch">
	<dt>
`304 応答^V は`強い検証子$を包含する場合：
◎
If the new response contains a strong validator (see Section 10.2.1 of [Semantics]), then＼
</dt>
	<dd>
その強い検証子が，更新する`選定された表現$を識別する
— すなわち、 `S^V 内の，同じ強い検証子を伴うものすべてが，更新するものと識別される。
◎
that strong validator identifies the selected representation for update. All of the stored responses with the same strong validator are identified for update.＼
</dd>
	<dd>
そのような格納-済み応答が無い場合、~cacheは， `304 応答^V を どの格納-済み応答の更新にも利用してはナラナイ。
【この記述から、仮に `304 応答^V が弱い検証子も包含していたとしても，次項は適用されないと見受けられる。】
◎
If none of the stored responses contain the same strong validator, then the cache MUST NOT use the new response to update any stored responses.
</dd>

	<dt>
`304 応答^V は`弱い検証子$を包含する場合：
◎
If the new response contains a weak validator＼
</dt>
	<dd>
`S^V 内にその検証子に合致するものがあれば、それらのうち最も近過去のものが，更新するものと識別される。
◎
and that validator corresponds to one of the cache's stored responses, then the most recent of those matching stored responses is identified for update.
</dd>

	<dt>
`304 応答^V は`検証子$を含まない場合：
◎
If the new response does not include any form of validator＼
</dt>
	<dd>
（例えば、~clientが `Last-Modified$h 応答~header以外の~sourceから， `If-Modified-Since$h 要請を`生成し$たなど。）
◎
(such as in the case where a client generates an If-Modified-Since request from a source other than the Last-Modified response header field),＼
</dd>
	<dd>
`S^V が唯一つの格納-済み応答からなる, かつ
その応答も`検証子$を欠如するならば、その応答が，更新するものと識別される。
◎
and there is only one stored response, and that stored response also lacks a validator, then that stored response is identified for update.
</dd>
</dl>

<p>
~cacheは、更新するものと識別された各 格納-済み応答 `応答^V に対し，次をしなければナラナイ
⇒
`304 応答^V 内に供された各~header `h^V に対し：
`応答^V 内の［
`h^V に対応する~headerの~instanceたち
］を `h^V で置換する
◎
For each stored response identified for update, the cache MUST use the header fields provided in the 304 (Not Modified) response to replace all instances of the corresponding header fields in the stored response.
</p>

			</section>
			<section id="head.effects">
<h4 title="Freshening Responses with HEAD">4.3.5. `HEAD^m による応答の新鮮化-法</h4>

<div class="p">
<p>
`HEAD$m ~methodに対する応答は、本体を欠如することを除き，［
`GET$m による等価な要請により為される応答
］と一致する。
この `HEAD$m 応答の特質を、次の場合に［
~cacheされた `GET$m 応答を無効化したり更新する
］ことに利用できる：
◎
A response to the HEAD method is identical to what an equivalent request made with a GET would have been, except it lacks a body. This property of HEAD responses can be used to invalidate or update a cached GET response＼
</p>

<ul>
	<li>
より効率的な条件付き `GET$m 要請の仕組みが（格納-済み応答~内に`検証子$が無いことに因り）可用でない場合。
◎
if the more efficient conditional GET request mechanism is not available (due to no validators being present in the stored response) or＼
</li>
	<li>
`表現$が変更されたときでも，その本体の伝送は欲されない場合。
◎
if transmission of the representation body is not desired even if it has changed.
</li>
</ul>
</div>

<p>
~cacheが［
所与の`要請~target$用に，`内方$へ `HEAD$m 要請を為してから、
`200$st 応答
— 以下 `HEAD 応答^V と記す —
を受信した
］ときは、［
その要請~用に選定し得た，自身に格納-済みな［
`GET$m に対する応答
］］のそれぞれを，更新するか, または無効化するベキである（ `4.1$sec を見よ）。
すなわち，…
◎
When a cache makes an inbound HEAD request for a given request target and receives a 200 (OK) response, the cache SHOULD update or invalidate each of its stored GET responses that could have been selected for that request (see Section 4.1).
</p>

<div class="p">
<p>
~cacheは、選定し得た，各 格納-済み応答 `応答^V に対し：
◎
For each of the stored responses that could have been selected,＼
</p>

<ol>
	<li>
<p>
次のいずれも満たされるならば、下に述べるように `応答^V を更新するベキである：
</p>
		<ul>
			<li>
受信されたどの`検証子~header$（ `ETag$h, `Last-Modified$h ）に対しても，
`応答^V, `HEAD 応答^V に その~headerが在って, 両者の値は合致する。
</li>
			<li>
`HEAD 応答^V, `応答^V に `Content-Length$h ~headerが在って, 両者の値は合致する。
</li>
		</ul>
◎
if the stored response and HEAD response have matching values for any received validator fields (ETag and Last-Modified) and, if the HEAD response has a Content-Length header field, the value of Content-Length matches that of the stored response, the cache SHOULD update the stored response as described below;＼
</li>
	<li>
他の場合、 `応答^V を`非新鮮$であると見なすベキである。
◎
otherwise, the cache SHOULD consider the stored response to be stale.
</li>
</ol>
</div>

<p>
~cacheが［
格納-済み応答 `応答^V を
`HEAD 応答^V 内に供された~metadataで更新する
］ときは、次をしなければナラナイ
⇒
`HEAD 応答^V 内に供された各~header `~header^V に対し
⇒
`~header^V は `Cache-Control$h ~headerにより制約されるものでないならば
⇒
`応答^V 内に `~header^V と同じ名前の~headerたちが
⇒＃
在るならば それらを `~header^V で置換する／
無いならば `応答^V の`~header節$に `~header^V を付加する
◎
If a cache updates a stored response with the metadata provided in a HEAD response, the cache MUST use the header fields provided in the HEAD response to replace all instances of the corresponding header fields in the stored response and append new header fields to the stored response's header section unless otherwise restricted by the Cache-Control header field.
</p>

			</section>
		</section>
		<section id="invalidation">
<h3 title="Invalidation">4.4. 無効化</h3>

<p>
［
`PUT$m, `POST$m, `DELETE$m
］などの，`安全$でない要請~methodは、`生成元~server$上の状態を変更する~~可能性があるので、介在している~cacheは，それらを利用して 自身の内容を最新状態に保つことができる。
◎
Because unsafe request methods (Section 7.2.1 of [Semantics]) such as PUT, POST or DELETE have the potential for changing state on the origin server, intervening caches can use them to keep their contents up to date.
</p>

<div class="p">
<p>
~cacheは、［
`安全$でない, または安全かどうか未知である
］ような要請~methodに対する応答~内に，非~error `状態s~code$
— `2xx$st または `3xx$st —
を受信したときには：
</p>

<ul>
	<li>
`実効~要請~URI$を`無効化-$しなければナラナイ。
</li>
	<li>
<p>
加えて，要請~methodが`安全$でない場合には、［
`Location$h ／ `Content-Location$h
］応答~headerによる `URI^V についても，［
`URI^V, `実効~要請~URI$
］の~host部分が互いに：
</p>
		<ul>
			<li>
同じならば、
`URI^V を`無効化-$しなければナラナイ。
</li>
			<li>
同じでないならば、
`URI^V を`無効化-$してはナラナイ
— これは、~DoS攻撃を防止する一助になる。
</li>
		</ul>
	</li>
</ul>

◎
A cache MUST invalidate the effective Request URI (Section 5.4 of [Semantics]) as well as the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.
◎
However, a cache MUST NOT invalidate a URI from a Location or Content-Location response header field if the host part of that URI differs from the host part in the effective request URI (Section 5.4 of [Semantics]). This helps prevent denial-of-service attacks.
◎
A cache MUST invalidate the effective request URI (Section 5.4 of [Semantics]) when it receives a non-error response to a request with a method whose safety is unknown.
</div>

<div class="p">
<p>
ここでの，~URIを
`無効化-@
するとは、~cacheが［
その~URIに関係する，すべての格納-済み応答
］に対し，次のいずれかを行うことを意味する：
◎
Here, a "non-error response" is one with a 2xx (Successful) or 3xx (Redirection) status code. "Invalidate" means that the cache will either＼
</p>

<ul>
	<li>
該当する応答をすべて除去する。
◎
remove all stored responses related to the effective request URI or＼
</li>
	<li>
該当する応答を “無効” と~markした上で、後続の要請に対する応答として送信できるようになる前に，`検証$を義務付ける。
◎
will mark these as "invalid" and in need of a mandatory validation before they can be sent in response to a subsequent request.
</li>
</ul>

</div>

<p class="note">注記：
これは、~~該当するすべての応答が無効化されることを保証しない。
例えば，状態変更~要請は、それが渡り歩く~cache内の応答については，無効化するであろうが、他の~cache内の関連な応答は，依然として格納されたままになるであろう。
◎
Note that this does not guarantee that all appropriate responses are invalidated. For example, a state-changing request might invalidate responses in the caches it travels through, but relevant responses still might be stored in other caches that it has not.
</p>

		</section>
	</section>
	<section id="header.field.definitions">
<h2 title="Header Field Definitions">5. ~headerの定義</h2>

<p>
この節では、次に挙げる［
~cache法に関係する各種~HTTP~header
］の構文と意味論を定義する
— これらの位置付けは、廃用にされた `Warning^h を除き，どれも `標準^i （ `standard^en ）である
⇒＃
`Age$h,
`Cache-Control$h,
`Expires$h,
`Pragma$h,
`Warning$h
◎
This section defines the syntax and semantics of HTTP header fields related to caching.
◎
Table 1
Header Field Name 	Status 	Reference

Age 	standard 	Section 5.1
Cache-Control 	standard 	Section 5.2
Expires 	standard 	Section 5.3
Pragma 	standard 	Section 5.4
Warning 	obsoleted 	Section 5.5
</p>

		<section id="header.age">
<h3>5.1. `Age^h</h3>

<p>
`Age$h ~headerは、送信者により `4.2.3$sec に従って見積もられた［
応答が`生成元~server$にて，`生成され$た／成功裡に`検証-$された
］ときからの経過時間
— `齢$ —
を伝達する。
◎
The "Age" header field conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server. Age values are calculated as specified in Section 4.2.3.
</p>

<pre class="ABNF">
`Age@p
    = `delta-seconds$p
</pre>

<p>
`Age$h `~header値$は、秒数を表現する非負~整数である（ `1.3$sec を見よ）。
◎
The Age field-value is a non-negative integer, representing time in seconds (see Section 1.3).
</p>

<p>
【応答の受信者にとっては，】
`Age$h ~headerの存在pは、この要請に対する応答が，`生成元~server$により［
`生成され$ていない／`検証-$されていない
］ことを含意する。
しかしながら， `Age$h ~headerを欠如するからといって、生成元が接触されたことを含意するとは限らない
— 応答は， `Age^h を実装しない~HTTP10~cacheから受信されることもあるので。
◎
The presence of an Age header field implies that the response was not generated or validated by the origin server for this request. However, lack of an Age header field does not imply the origin was contacted, since the response might have been received from an HTTP/1.0 cache that does not implement Age.
</p>

		</section>
		<section id="header.cache-control">
<h3>5.2. `Cache-Control^h</h3>

<p>
`Cache-Control^h ~headerは、
`~cache制御~指令@†
— ［
要請／応答
］の`連鎖$沿いにある~cacheたちの挙動を制御するための指令（ `directive^en ） —
を指定するために利用される。
そのような指令は，単方向であり、要請~内にそれが在っても，対する応答~内に同じ指令が［
在る／繰返される
］ことは含意しない。
◎
The "Cache-Control" header field is used to specify directives for caches along the request/response chain. Such cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is present in the response, or to be repeated in it.
</p>

<div class="trans-note">
<p>【†
単に［
“指令” ／ “~cache指令”
］とも称される。
あるいは
“`Cache-Control^h 指令”
とも称される（他の仕様が
“~cache制御~指令”
を利用する，他の何らかの~headerを定義する可能性も排除されないが）。
［
要請／応答
］内に指定される~cache指令は、［
“要請~指令” ／ “応答~指令”
］とも称される。
】</p>

</div>

<p>
他所で定義される `Cache-Control$h 指令の取扱い法についての情報は、`~cache制御~拡張$secを見よ。
◎
See Section 5.2.3 for information about how Cache-Control directives defined elsewhere are handled.
</p>

<p class="note">注記：
~HTTP10~cacheには、 `Cache-Control$h を実装しないものもある。
◎
Note: Some HTTP/1.0 caches might not implement Cache-Control.
</p>

<p>
`~proxy$は、自身が回送する~message内にある どの`~cache指令$も
— 自身が［
~cacheを実装するかどうか, その指令を有意に~cacheに適用できるかどうか
］に関わらず —
通過させなければナラナイ。
指令は、［
要請／応答
］の`連鎖$沿いにある すべての`受信者$に適用-可能になるかもしれず，特定の~cacheのみを~targetにできないので。
◎
A proxy, whether or not it implements a cache, MUST pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to target a directive to a specific cache.
</p>

<div class="p">
<p>
`~cache指令$は、文字大小無視 `token$p により識別され，引数（省略可）もとり得る。
引数には，［
`token$p, `quoted-string$p
］どちらの構文も利用し得る。
`受信者$は：
◎
Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument, that can use both token and quoted-string syntax.＼
</p>

<ul>
	<li>
この仕様が定義する指令に対しては、（引数を定義するものであれば）両~構文とも受容する~OUGHT
— 片方が選好されると文書化されているものもあるが。
◎
For the directives defined below that define arguments, recipients ought to accept both forms, even if one is documented to be preferred.＼
</li>
	<li>
この仕様が定義しない指令に対しては、両~構文とも受容しなければナラナイ。
◎
For any directive not defined by this specification, a recipient MUST accept both forms.
</li>
</ul>
</div>

<pre class="ABNF">
`Cache-Control@p
    = 1#`cache-directive$p

`cache-directive@p
    = `token$p [ "=" ( `token$p / `quoted-string$p ) ]
</pre>

<p>
特に言明されない限り、以下に定義される`~cache指令$には，引数は定義されない（許容されない）。
◎
For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.
</p>

<div>

<table><thead><tr><td>要請~cache指令
<td>応答~cache指令
</thead>

<tbody><tr><td>`max-age$qdir
<td>`max-age$sdir

<tr><td>`max-stale$qdir
<td>—

<tr><td>`min-fresh$qdir
<td>—

<tr><td>—
<td>`must-revalidate$sdir

<tr><td>`no-cache$qdir
<td>`no-cache$sdir

<tr><td>`no-store$qdir
<td>`no-store$sdir

<tr><td>`no-transform$qdir
<td>`no-transform$sdir

<tr><td>`only-if-cached$qdir
<td>—

<tr><td>—
<td>`private$sdir

<tr><td>—
<td>`proxy-revalidate$sdir

<tr><td>—
<td>`public$sdir

<tr><td>—
<td>`s-maxage$sdir

</tbody></table>

◎
Table 2
Cache Directive 	Reference
max-age 	Section 5.2.1.1, Section 5.2.2.8
max-stale 	Section 5.2.1.2
min-fresh 	Section 5.2.1.3
must-revalidate 	Section 5.2.2.1
no-cache 	Section 5.2.1.4, Section 5.2.2.2
no-store 	Section 5.2.1.5, Section 5.2.2.3
no-transform 	Section 5.2.1.6, Section 5.2.2.4
only-if-cached 	Section 5.2.1.7
private 	Section 5.2.2.6
proxy-revalidate 	Section 5.2.2.7
public 	Section 5.2.2.5
s-maxage 	Section 5.2.2.9
</div>

			<section id="cache-request-directive">
<h4 title="Request Cache-Control Directives">5.2.1. 要請 `Cache-Control^h 指令</h4>

<p>
この節は、各種~cache要請~指令を定義する。
これらは助言的である
— ~cacheは、これらを実装してもヨイが，要求されてはいない。
◎
This section defines cache request directives. They are advisory; caches MAY implement them, but are not required to.
</p>

				<section id="cache-request-directive.max-age">
<h5>5.2.1.1. `max-age^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
`delta-seconds$p
</pre>

<p>
`max-age^qdir 要請~指令は、［
`~client$は、`齢$が指定された秒~数~以下の応答を選好する
］ことを指示する。
`max-stale^qdir 要請~指令も在る場合を除き、~clientは，`非新鮮$な応答は受信したくないと望んでいる。
◎
The "max-age" request directive indicates that the client prefers a response whose age is less than or equal to the specified number of seconds. Unless the max-stale request directive is also present, the client does not wish to receive a stale response.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-age^dir=5</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-age^dir="5"</samp>
）を`生成する$ベキでない。
◎
This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender SHOULD NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.max-stale">
<h5>5.2.1.2. `max-stale^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
`delta-seconds$p
</pre>

<p>
`max-stale^qdir 要請~指令は、［
`~client$は、指定された~~延長~時間まで，`鮮度維持期間$を超過した応答を受容する用意がある
］ことを指示する。
~~延長~時間は、［
引数に値が在るならば それに指定された秒~数 ／
他の場合は 無限
］になる。
◎
The "max-stale" request directive indicates that the client is willing to accept a response that has exceeded its freshness lifetime. If a value is present, then the client is willing to accept a response that has exceeded its freshness lifetime by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-stale^dir=10</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-stale^dir="10"</samp>
）を`生成する$ベキでない。
◎
This directive uses the token form of the argument syntax: e.g., 'max-stale=10' not 'max-stale="10"'. A sender SHOULD NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.min-fresh">
<h5>5.2.1.3. `min-fresh^qdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
`delta-seconds$p
</pre>

<p>
`min-fresh^qdir 要請~指令は、［
`~client$は，［
`鮮度維持期間$が，指定された秒数を応答の現在の`齢$に足した結果~以上
］である応答を選好する
］ことを指示する。
すなわち，~clientは、少なくとも指定された秒~数までは，応答が`新鮮$であり続けるよう求めている。
◎
The "min-fresh" request directive indicates that the client prefers a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-fresh^dir=20</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-fresh^dir="20"</samp>
）を`生成する$ベキでない。
◎
This directive uses the token form of the argument syntax: e.g., 'min-fresh=20' not 'min-fresh="20"'. A sender SHOULD NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-request-directive.no-cache">
<h5>5.2.1.4. `no-cache^qdir</h5>

<p>
`no-cache^qdir 要請~指令は、［
`~client$は、［
格納-済み応答は、`生成元~server$上で成功裡に`検証-$されない限り，要請を満足するために利用しない
］ことを選好する
］ことを指示する。
◎
The "no-cache" request directive indicates that the client prefers stored response not be used to satisfy the request without successful validation on the origin server.
</p>

				</section>
				<section id="cache-request-directive.no-store">
<h5>5.2.1.5. `no-store^qdir</h5>

<div class="p">
<p>
`no-store^qdir 要請~指令は、［
`私用~cache$, `共用~cache$
］のどちらにも適用され，［
~cacheは、この要請, 対する応答
］を成す どの部分も，格納してはナラナイ
］ことを指示する
— すなわち，~cacheは：
◎
The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache＼
</p>

<ul>
	<li>
不揮発 記憶域に意図的にその情報を格納してはナラナイ。
◎
MUST NOT intentionally store the information in non-volatile storage, and＼
</li>
	<li>
それを回送したならば、アリな限り迅速に, その情報を揮発 記憶域から除去することに極力努めなければナラナイ。
◎
MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</li>
</ul>

</div>

<p>
この指令は、~privacyを確保するための仕組みとして，依拠-可能でも, 足るものでも<strong>ない</strong>。
特に、悪意的な, あるいは弱体化された~cacheは，この指令を認識しなかったり順守しないかもしれず、通信~networkは，盗聴に脆弱になるかもしれない。
◎
This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>

<p class="note">注記：
この指令を包含する要請が，~cacheに格納-済みな応答により満足された場合、
`no-store^qdir 要請~指令は，その格納-済み応答には適用されない。
◎
Note that if a request containing this directive is satisfied from a cache, the no-store request directive does not apply to the already stored response.
</p>

				</section>
				<section id="cache-request-directive.no-transform">
<h5>5.2.1.6. `no-transform^qdir</h5>

<p>
`no-transform^qdir 要請~指令は、［
`~client$は、［
`中継者$たちは（~cacheを実装するかどうかに関わらず），`~payload$を`形式変換-$するのを避ける
］よう依頼している
］ことを指示する。
◎
The "no-transform" request directive indicates that the client is asking for intermediares (whether or not they implement a cache) to avoid transforming the payload, as defined in Section 5.5.2 of [Semantics].
</p>

				</section>
				<section id="cache-request-directive.only-if-cached">
<h5>5.2.1.7. `only-if-cached^qdir</h5>

<p>
`only-if-cached^qdir 要請~指令は、［
`~client$は、格納-済み応答を得ることのみを望む
］ことを指示する。
この要請を尊守する~cacheは、その受信に対し，［
要請による他の拘束に整合な，格納-済み応答
］を利用して応答するか， `504$st で応答するベキである。
◎
The "only-if-cached" request directive indicates that the client only wishes to obtain a stored response. Caches that honor this request directive SHOULD, upon receiving it, either respond using a stored response that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status code.
</p>

				</section>
			</section>
			<section id="cache-response-directive">
<h4 title="Response Cache-Control Directives">5.2.2. 応答 `Cache-Control^h 指令</h4>

<p>
この節は、各種 ~cache応答~指令を定義する。
~cacheは、この節に定義される `Cache-Control$h 指令の要件を順守しなければナラナイ。
◎
This section defines cache response directives. A cache MUST obey the requirements of the Cache-Control directives defined in this section.
</p>

				<section id="cache-response-directive.must-revalidate">
<h5>5.2.2.1. `must-revalidate^sdir</h5>

<p>
`must-revalidate^sdir 応答~指令は、［
~cacheは、`非新鮮$になった応答を他の要請を満足するために
— それを`検証$用に回送して，成功裡に応答を受信しない限り —
利用してはナラナイ
］ことを指示する。
◎
The "must-revalidate" response directive indicates that once it has become stale, the response MUST NOT be used to satisfy any other request without forwarding it for validation and receiving a successful response; see Section 4.3.
</p>

<p>
`must-revalidate^sdir 指令は、ある種の~protocol特能~用に依拠-可能な運用を~supportするために，必要とされる。
~cacheは、どのような状況下でも， `must-revalidate^sdir 指令を順守しなければナラナイ
— 特に，~cacheは、`切断されて$いる場合には， `504$st 応答を`生成し$なければナラナイ。
◎
The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances a cache MUST obey the must-revalidate directive; in particular, if a cache is disconnected, it MUST generate a 504 (Gateway Timeout) response.
</p>

<p>
`~server$が `must-revalidate^sdir 指令を利用するのは、［
`表現$に対する要請の`検証$に失敗した結果が，不正な運用になる
］とき
— ~~報告もなく実行されなかった金融取引など —
そのときに限られる~OUGHT。
◎
The must-revalidate directive ought to be used by servers if and only if failure to validate a request on the representation could result in incorrect operation, such as a silently unexecuted financial transaction.
</p>

<p>
`must-revalidate^sdir 指令には、［
格納-済み応答を利用して， `Authorization$h ~headerを伴う要請を満足する
］ことを許容する効果もある。
`3.2$sec を見よ。
◎
The must-revalidate directive also has the effect of allowing a stored response to be used to satisfy a request with an Authorization header field; see Section 3.2.
</p>

				</section>
				<section id="cache-response-directive.no-cache">
<h5>5.2.2.2. `no-cache^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
#`field-name$p
</pre>

<p>
【引数を伴わない】
`no-cache^sdir 応答~指令は、［
応答は、`検証$用に回送して成功裡に応答を受信しない限り，他の要請を満足するために利用してはナラナイ
］ことを指示する。
◎
The "no-cache" response directive indicates that the response MUST NOT be used to satisfy any other request without forwarding it for validation and receiving a successful response; see Section 4.3.
</p>

<p>
これにより，`生成元~server$は、［
~cacheが`非新鮮$な応答を送信するように環境設定されていたとしても，~cacheが~serverに接触しないまま，要請を満足するために その種の応答を利用する
］ことを，防止できるようになる。
◎
This allows an origin server to prevent a cache from using it to satisfy a request without contacting it, even by caches that have been configured to send stale responses.
</p>

<div class="p">
<p>
`no-cache^sdir 応答~指令が，【その引数により】
1 個~以上の`~header名$を指定する場合、~cacheは：
◎
If the no-cache response directive specifies one or more field-names, then＼
</p>

<ul>
	<li>
~cachingに対する他の制約の~subjectの下で、その応答を，後続の要請を満足するために利用してもヨイ。
◎
a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching.＼
</li>
	<li>
しかしながら，引数に~listされた どの~headerも、`生成元~server$上での成功裡な`再検証$を伴わないまま，後続の要請に対する応答~内に送信してはナラナイ。
◎
However, any header fields in the response that have the field-name(s) listed MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server.＼
</li>
</ul>

<p>
これにより，`生成元~server$は、応答~内における一定の~headerの再利用を，応答の残りの部分の~cachingは許容しつつ，防止できるようになる。
◎
This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.
</p>
</div>

<p>
引数に与え得る~header名は、この仕様が定義する それらに制限されない。
~header名は、文字大小無視である。
◎
The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>

<p>
この指令は、引数の構文として `quoted-string$p を利用する：
送信者は `token$p 形を`生成する$ベキでない（引用符が不要に見える，単独の~entryからなる~listであっても）。
◎
This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).
</p>

<p class="note">注記：
多くの~HTTP10~cacheの実装に移植（ back-port ）されてはいるが、中には，この指令を認識しない, あるいは順守しない~HTTP10~cacheもある。
また、引数をとる【！ header名を伴う】 `no-cache^sdir 応答~指令は、~cacheからは，引数なしの【！unqualified】 `no-cache^sdir 指令が受信されたかのように取扱われることが多い
— すなわち，引数~付き【！qualified form】に対する特別な取扱いは、広範に実装されていない。
◎
Note: Although it has been back-ported to many implementations, some HTTP/1.0 caches will not recognize or obey this directive. Also, no-cache response directives with field-names are often handled by caches as if an unqualified no-cache directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>

				</section>
				<section id="cache-response-directive.no-store">
<h5>5.2.2.3. `no-store^sdir</h5>

<div class="p">
<p>
`no-store^sdir 応答~指令は、［
~cacheは、［
直の†要請, 応答
］を成す どの部分も格納してはナラナイ
］こと, および［
当の応答を利用して他の要請を満足してはナラナイ
］を指示する。
【† 当の応答を生じさせた要請が記憶域に残っている場合、それも抹消することと見受けられる。】
◎
The "no-store" response directive indicates that a cache MUST NOT store any part of either the immediate request or response, and MUST NOT use the response to satisfy any other request.
</p>

<p>
この指令は、［
`私用~cache$, `共用~cache$
］のどちらにも適用される
— ここでの格納してはナラナイとは、~cacheは：
◎
This directive applies to both private and shared caches. "MUST NOT store" in this context means that the cache＼
</p>

<ul>
	<li>
不揮発 記憶域に意図的にその情報を格納してはナラナイ。
◎
MUST NOT intentionally store the information in non-volatile storage, and＼
</li>
	<li>
それを回送したならば、アリな限り迅速に, その情報を揮発 記憶域から除去することに極力努めなければナラナイ。
◎
MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
</li>
</ul>
</div>

<p>
この指令は、~privacyを確保するための仕組みとして，依拠-可能でも, <strong>足るものでもない</strong>。
特に、悪意的な, あるいは弱体化された~cacheは，この指令を認識しなかったり, 順守しないかもしれず、通信~networkは，盗聴に対し脆弱になるかもしれない。
◎
This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
</p>

				</section>
				<section id="cache-response-directive.no-transform">
<h5>5.2.2.4. `no-transform^sdir</h5>

<p>
`no-transform^sdir 応答~指令は、［
`中継者$は（~cacheを実装するかどうかに関わらず），`~payload$を`形式変換-$してはナラナイ
］ことを指示する。
◎
The "no-transform" response directive indicates that an intermediary (regardless of whether it implements a cache) MUST NOT transform the payload, as defined in Section 5.5.2 of [Semantics].
</p>

				</section>
				<section id="cache-response-directive.public">
<h5>5.2.2.5. `public^sdir</h5>

<p>
`public^sdir 応答~指令は、［
どの~cacheも，応答を格納してもヨイ
］ことを指示する
— 応答が［
通常は~cache可能でない, あるいは
`私用~cache$においてのみ~cache可能である
］ときでも。
（［
`Authorization$h を包含する要請に対する応答
］における `public^sdir の利用に関係する，追加的な詳細は、 `3.2$sec を見よ。
［
`状態s~code$が`経験的に~cache可能$であると定義されていないことに因り，通常は格納されないような応答
］に， `public^sdir がどう影響するかについての詳細は、`3$sec を見よ。）
◎
The "public" response directive indicates that any cache MAY store the response, even if the response would normally be non-cacheable or cacheable only within a private cache. (See Section 3.2 for additional details related to the use of public in response to a request containing Authorization, and Section 3 for details of how public affects responses that would normally not be stored, due to their status codes not being defined as heuristically cacheable; see Section 4.2.2.)
</p>

【！ Errata ID: 4616 Rejected】

				</section>
				<section id="cache-response-directive.private">
<h5>5.2.2.6. `private^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
#`field-name$p
</pre>

<p>
`private^sdir 応答~指令は［
応答~messageは、単独の利用者~用に意図されているものであり，`共用~cache$により格納されてはナラナイ
］ことを指示する。
`私用~cache$は、応答を格納して，今後の要請に対しそれを再利用してもヨイ
— 応答が通常は~cache可能でないとしても。
◎
The "private" response directive indicates that the response message is intended for a single user and MUST NOT be stored by a shared cache. A private cache MAY store the response and reuse it for later requests, even if the response would normally be non-cacheable.
</p>

<p>
`private^sdir 応答~指令に， 1 個~以上の`~header名$が~listされている場合、この要件は，
それらの~header名に結付けられた`~header値$に制限される。
すなわち，`共用~cache$は、それらの~header名を持つ~headerたちを格納してはナラナイ一方で、応答~messageの残りの部分は，格納してもヨイ。
◎
If the private response directive specifies one or more field-names, this requirement is limited to the field-values associated with the listed response header fields. That is, a shared cache MUST NOT store the specified field-names(s), whereas it MAY store the remainder of the response message.
</p>

<p>
引数に与え得る~header名は、この仕様が定義する それらに制限されない。
~header名は、文字大小無視である。
◎
The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.
</p>

<p>
この指令は、引数の構文として `quoted-string$p を利用する：
送信者は `token$p 形を`生成する$ベキでない（引用符が不要に見える，単独の~entryからなる~listであっても）。
◎
This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).
</p>

<p class="note">注記：
`private^sdir の利用eは、応答を格納できるかどうかのみを制御する
— それは，~message内容の~privacyを確保するものではない。
また、引数をとる【！ header名を伴う】 `private^sdir 応答~指令は、~cacheからは，引数なしの【！ unqualified】 `private^sdir が受信されたかのように取扱われることが多い
— すなわち，引数~付き【！qualified】の形に対する特別な取扱いは、広範に実装されていない。
◎
Note: This usage of the word "private" only controls where the response can be stored; it cannot ensure the privacy of the message content. Also, private response directives with field-names are often handled by caches as if an unqualified private directive was received; i.e., the special handling for the qualified form is not widely implemented.
</p>

				</section>
				<section id="cache-response-directive.proxy-revalidate">
<h5>5.2.2.7. `proxy-revalidate^sdir</h5>

<p>
`proxy-revalidate^sdir 応答~指令は、`私用~cache$には適用されないことを除いて，
`must-revalidate$sdir 応答~指令と同じ意味を持つ。
◎
The "proxy-revalidate" response directive has the same meaning as the must-revalidate response directive, except that it does not apply to private caches.
</p>

				</section>
				<section id="cache-response-directive.max-age">
<h5>5.2.2.8. `max-age^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
`delta-seconds$p
</pre>

<p>
`max-age$sdir 応答~指令は、［
応答は，［
その`齢$が 指定された秒~数を超えた後は，`非新鮮$になる
］と見なされる
］ことを指示する。
◎
The "max-age" response directive indicates that the response is to be considered stale after its age is greater than the specified number of seconds.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`max-age^dir=5</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`max-age^dir="5"</samp>
）を`生成する$ベキでない。
◎
This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age="5"'. A sender SHOULD NOT generate the quoted-string form.
</p>

				</section>
				<section id="cache-response-directive.s-maxage">
<h5>5.2.2.9. `s-maxage^sdir</h5>

<p>
引数の構文：
◎
Argument syntax:
</p>

<pre class="ABNF">
`delta-seconds$p
</pre>

<p>
`s-maxage^sdir 応答~指令は、［
`共用~cache$においては、［
この指令により指定された最大~齢
］が，［
`max-age$sdir 指令／ `Expires$h ~header
により指定された最大~齢
］を上書きする
］ことを指示する。
`s-maxage^sdir 指令は、 `proxy-revalidate$sdir 応答~指令の意味論も含意する。
◎
The "s-maxage" response directive indicates that, in shared caches, the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header field. The s-maxage directive also implies the semantics of the proxy-revalidate response directive.
</p>

<p>
`s-maxage^sdir【！`must-revalidate^sdir 】 指令には、［
格納-済み応答を利用して， `Authorization$h ~headerを伴う要請を満足する
］ことを許容する効果もある。
`3.2$sec を見よ。
◎
The must-revalidate directive also has the effect of allowing a stored response to be used to satisfy a request with an Authorization header field; see Section 3.2.
</p>

<p>
この指令は、引数~構文として `token$p 形（例：
<samp>`s-maxage^dir=10</samp>
）を利用する。
送信者は、 `quoted-string$p 形（例：
<samp>`s-maxage^dir="10"</samp>
）を`生成する$ベキでない。
◎
This directive uses the token form of the argument syntax: e.g., 's-maxage=10' not 's-maxage="10"'. A sender SHOULD NOT generate the quoted-string form.
</p>

				</section>
			</section>
			<section id="cache.control.extensions">
<h4 title="Cache Control Extensions">5.2.3. ~cache制御~拡張</h4>

<p>
`Cache-Control$h ~headerは［
それぞれが値（省略可）を伴い得るような， 1 個~以上の~cache拡張~token
］の利用を通して拡張できる。
~cacheは、認識できない`~cache指令$を無視しなければナラナイ。
◎
The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional value. A cache MUST ignore unrecognized cache directives.
</p>

<p>
~cacheの挙動~変更-を要求しない拡張（ “`informational^en” 拡張）
を、他の指令の意味論を変更することなく，追加できる。
◎
Informational extensions (those that do not require a change in cache behavior) can be added without changing the semantics of other directives.
</p>

<div class="p">
<p>
挙動を変更する拡張（ “`behavioral^en” 拡張）は、既存の`~cache指令$に基づく挙動に対する改変子として動作するように設計されている
— すなわち，新旧 両~指令が給されたときは、次のようになる：
◎
Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the old directive are supplied, such that＼
</p>

<ul>
	<li>
新~指令を解さない応用は、既定で，旧~指令により指定される挙動になる。
◎
applications that do not understand the new directive will default to the behavior specified by the old directive, and＼
</li>
	<li>
新~指令を解する応用は、それを，旧~指令に結付けられた要件を改変するものとして認識する。
◎
those that understand the new directive will recognize it as modifying the requirements associated with the old directive.＼
</li>
</ul>

<p>
このようにして、配備された~cacheを壊すことなく，既存の~cache制御~指令を拡張できるようになる。
◎
In this way, extensions to the existing cache-control directives can be made without breaking deployed caches.
</p>
</div>

<div class="example">
<p>
例えば、 `community^dir と呼ばれる，新たな応答~指令を仮に考える。
それは，［
`private$sdir 指令に対する改変子
］として動作し、`私用~cache$に加えて，［
ある “community” の~member間に限り`共有-$されるような，どの~cache
］も［
応答を~cacheすることが許容される
］とする。
`生成元~server$は、［
“XYZ” community が，彼らの`共用~cache$において［
さもなければ `private$sdir になるような応答
］を利用する
］ことを許容したいと望むなら、次のように［
`XYZ^c を値にとる `community^dir
］を含ませる：
◎
For example, consider a hypothetical new response directive called "community" that acts as a modifier to the private directive: in addition to private caches, any cache that is shared only by members of the named community is allowed to cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including
</p>

<pre class="http-code">
Cache-Control: private, community="XYZ"
</pre>

<p>
そのような`~cache制御~拡張$ `community^dir を認識する~cacheは、その拡張に則って，自身の挙動を広げられる。
`community^dir 拡張を認識しない~cacheは、それを無視して，
`private$sdir 指令を固守することになる。
◎
A cache that recognizes such a community cache-extension could broaden its behavior in accordance with that extension. A cache that does not recognize the community cache-extension would ignore it and adhere to the private directive.
</p>
</div>

<p>
新たな拡張~指令は、次を定義することを考慮する~OUGHT：
◎
New extension directives ought to consider defining:
</p>

<ul>
	<li>
その指令が複数~個 指定されたとき，何を意味するか？
◎
• What it means for a directive to be specified multiple times,
</li>
	<li>
その指令が引数をとらないのは いつか？
引数が在るときは何を意味するか？
◎
• When the directive does not take an argument, what it means when an argument is present,
</li>
	<li>
その指令が引数を要求するのは いつか？
引数を欠くときは何を意味するか？
◎
• When the directive requires an argument, what it means when it is missing,
</li>
	<li>
その指令は［
要請のみ, あるいは応答のみ
］に特有か？
両者に利用できるか？
◎
• Whether the directive is specific to requests, responses, or able to be used in either.
</li>
</ul>

			</section>
			<section id="section-5.2.4">
<h4 title="Cache Directive Registry">5.2.4. ~cache指令~登記簿</h4>

<p>
`~cache指令$用の名前空間を定義するための
`~cache指令~登記簿$cite
が、新たに作成され，保守されている。
◎
The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry" defines the namespace for the cache directives. It has been created and is now maintained at &lt;https://www.iana.org/assignments/http-cache-directives&gt;.
</p>

<p>
登録にあたっては，次の~fieldが含まれなければナラナイ：
◎
A registration MUST include the following fields:
</p>

<ul>
	<li>
当の`~cache指令$の名前
◎
• Cache Directive Name
</li>
	<li>
仕様~textへの~pointer
◎
• Pointer to specification text
</li>
</ul>

<p>
この名前空間に追加される値は
`IETF による考査$を要する。
◎
Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).
</p>

			</section>
		</section>
		<section id="header.expires">
<h3>5.3. `Expires^h</h3>

<p>
`Expires^h ~headerは、［
それ以降は 応答が`非新鮮$になると見なされる，日時／時刻
］を与える。
鮮度~modelについての更なる論点は、`鮮度$secを見よ。
◎
The "Expires" header field gives the date/time after which the response is considered stale. See Section 4.2 for further discussion of the freshness model.
</p>

<p>
`Expires$h ~headerの存在pは、［
元の`資源$が，その時刻を境に変化したり, 存在するようになる／しなくなる
］ことを含意するものではない。
◎
The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.
</p>

<p>
`Expires$h は、
`HTTP-date$p による時刻印を値にとる。
◎
The Expires value is an HTTP-date timestamp, as defined in Section 10.1.1.1 of [Semantics].
</p>

【！ Errata ID: 4479 Rejected 】

<pre class="ABNF">
`Expires@p
    = `HTTP-date$p
</pre>

<div class="example">
<p>
例：
◎
For example
</p>

<pre class="http-code">
Expires: Thu, 01 Dec 1994 16:00:00 GMT
</pre>

</div>

<p>
~cache`受信者$は、形式が無効な日時を，値 "`0^c" に解釈しなければナラナイ
— これは、過去の時刻を表現する（すなわち， “すでに失効した”）。
◎
A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
</p>

<p>
応答が `max-age$sdir 指令を伴う `Cache-Control$h ~headerを内包する場合、`受信者$は `Expires$h ~headerを無視しなければナラナイ。
同様に，応答が `s-maxage$sdir 指令を内包する場合、`共用~cache$受信者は， `Expires$h ~headerを無視しなければナラナイ。
いずれの場合も、 `Expires$h の値は，もっぱら［
`Cache-Control$h ~headerをまだ実装していない`受信者$
］用に意図されたものである。
◎
If a response includes a Cache-Control field with the max-age directive (Section 5.2.2.8), a recipient MUST ignore the Expires field. Likewise, if a response includes the s-maxage directive (Section 5.2.2.9), a shared cache recipient MUST ignore the Expires field. In both these cases, the value in Expires is only intended for recipients that have not yet implemented the Cache-Control field.
</p>

<div class="p">
<p>
`時計$を備えていない`生成元~server$は、
`Expires$h ~headerを`生成し$てはナラナイ
— ただし、その値が次のいずれかの値をとる場合は除く：
◎
An origin server without a clock MUST NOT generate an Expires field unless its value＼
</p>

<ul>
	<li>
過去の固定的な時刻を表現する（ “常に，すでに失効している” ）。
◎
represents a fixed time in the past (always expired) or＼
</li>
	<li>
依拠-可能な`時計$を備える［
~system／【ヒトでない】利用者
］により，`資源$に結付けられた値。
◎
its value has been associated with the resource by a system or user with a reliable clock.
</li>
</ul>
</div>

<p>
歴史的に，~HTTPは、
`Expires$h `~header値$が，一年以内の未来になることを要求していた。
長い`鮮度維持期間$は，もはや禁制されなくなったが、度を越して巨大な値は，問題を起こすことが判っているので（例：時刻~値~用の 32 ~bit整数の利用に因る，時計の桁溢れ）、多くの~cacheは，それより ずっと早くに応答を抹消する。
◎
Historically, HTTP required the Expires field-value to be no more than a year in the future. While longer freshness lifetimes are no longer prohibited, extremely large values have been demonstrated to cause problems (e.g., clock overflows due to use of 32-bit integers for time values), and many caches will evict a response far sooner than that.
</p>

		</section>
		<section id="header.pragma">
<h3>5.4. `Pragma^h</h3>

<p>
`Pragma^h ~headerは、~HTTP10~cache用に定義された
— `~client$が， `no-cache^dir 要請も指定できるようにするために（ `Cache-Control$h は、~HTTP11まで，定義されていなかったので）。
◎
The "Pragma" header field was defined for HTTP/1.0 caches, so that clients could specify a "no-cache" request (as Cache-Control was not defined until HTTP/1.1).
</p>

<p>
しかしながら， `Cache-Control$h の~supportは、今や広く行き渡っている。
よって、この仕様は `Pragma^h を非推奨にする。
◎
However, support for Cache-Control is now widespread. As a result, this specification deprecates Pragma.
</p>

<p class="note">注記：
応答においては、
<code>Pragma: `no-cache^dir</code>
の意味が指定されことは決してない
— それは，応答における
<code>Cache-Control: `no-cache$sdir</code>
に代わる依拠-可能な置換を供さない。
◎
Note: Because the meaning of "Pragma: no-cache" in responses was never specified, it does not provide a reliable replacement for "Cache-Control: no-cache" in them.
</p>

		</section>
		<section id="header.warning">
<h3>5.5. `Warning^h</h3>

<p>
`Warning^h ~headerは、［
`状態s~code$内に反映されないこともあるような，~messageの状態sや`形式変換$についての追加的な情報
］を運ぶために利用されていた。
この仕様は、これを廃用にする
— 広範に生成されたり, 利用者が面するものではないので。
それが運んでいた情報は、 `Age$h などの他の~headerを精査すれば拾える。
◎
The "Warning" header field was used to carry additional information about the status or transformation of a message that might not be reflected in the status code. This specification obsoletes it, as it is not widely generated or surfaced to users. The information it carried can be gleaned from examining other header fields, such as Age.
</p>

		</section>
	</section>
	<section id="history.lists">
<h2 title="Relationship to Applications">6. 応用との関係性</h2>

<p>
~HTTPを利用している応用は、追加的な形の~cache法を指定することが多い。
例えば，~web~browserは、履歴の仕組みを備えることが多い
— ある~sessionにおいて，~~以前に検索取得した表現を表示し直すような、
“戻る” ~buttonを利用できるなど。
◎
Applications using HTTP often specify additional forms of caching. For example, Web browsers often have history mechanisms such as "Back" buttons that can be used to redisplay a representation retrieved earlier in a session.
</p>

<p>
同様に，~page~viewの中の画像 その他の~assetの~cache法を実装する~Web~browserもある
— それらには、~HTTP~cache法の意味論を尊守するものも，しないものもある。
◎
Likewise, some Web browsers implement caching of images and other assets within a page view; they may or may not honor HTTP caching semantics.
</p>

<p>
この仕様における要件は、［
応用が，~HTTP~cacheから~dataを検索取得した後にどう利用するか
］に適用することは，必要とされない。
すなわち、履歴の仕組みは，以前の表現を
— それが失効しようが —
表示でき、応用は，~cacheされた~dataを
— それが鮮度維持期間を超えていようが —
他の仕方で利用できる。
◎
The requirements in this specification do not necessarily apply to how applications use data after it is retrieved from a HTTP cache. That is, a history mechanism can display a previous representation even if it has expired, and an application can use cached data in other ways beyond its freshness lifetime.
</p>

<p>
このことは、応用が~HTTP~cache法を織り込むことを禁制するものではない
— 例えば，履歴の仕組みは、［
~viewは非新鮮である／
~cache指令を尊守するかもしれない（例： `Cache-Control: no-store^c ）
］ことを利用者に~~伝えるかもしれない。
◎
This does not prohibit the application from taking HTTP caching into account; for example, a history mechanism might tell the user that a view is stale, or it might honor cache directives (e.g., Cache-Control: no-store).
</p>

	</section>
	<section id="security.considerations">
<h2 title="Security Considerations">7. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］向けに，
~HTTP~cache法に特有な，既知な~securityの懸念を伝えることを~~意図している。
より一般的な~securityの考慮点は、
`Messaging$r, `Semantics$r
にて取組まれている。
◎
This section is meant to inform developers, information providers, and users of known security concerns specific to HTTP caching. More general security considerations are addressed in HTTP messaging [Messaging] and semantics [Semantics].
</p>

<p>
~cacheは、脆弱性を付け加える~~可能性がある
— ~cacheの内容は、悪意的な悪用にとって魅力的な~targetを表現するので。
~cacheの内容は，~HTTP要請が完了した後も持続するので、利用者からは~networkから情報が除去されたように見えても、~cacheに対する攻撃により，長期間 情報を露呈する。
したがって，~cache内容は、敏感な情報として保護される必要がある。
◎
Caches expose additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents need to be protected as sensitive information.
</p>

		<section id="n-cache-poisoning">
<h3 title="Cache Poisoning">7.1. ~cache汚染</h3>

<p>
様々な攻撃が，`共用~cache$内に格納されることにより増幅され得る。
そのような “~cache汚染” 攻撃は、［
多数の`~client$に向けて悪意的な`~payload$を配布する
］ような~cacheを利用する。
それは、攻撃者が［
実装の欠陥, 特権拡大, その他の技法
］を利用して，そのような応答を~cacheの中へ挿入できるときには、とりわけ効果的になる。
◎
Various attacks might be amplified by being stored in a shared cache. Such "cache poisoning" attacks use the cache to distribute a malicious payload to many clients, and are especially effective when an attacker can use implementation flaws, elevated privileges, or other techniques to insert such a response into a cache.
</p>

<p>
~cache汚染に共通的にある攻撃路の一つは、`~proxy$と`~UA$における~message構文解析-法の相違点を悪用するものである
— ~HTTP11に関連な要件については、
`Messaging/6.3$sec
を見よ。
◎
One common attack vector for cache poisoning is to exploit differences in message parsing on proxies and in user agents; see Section 6.3 of [Messaging] for the relevant requirements regarding HTTP/1.1.
</p>

		</section>
		<section id="security.timing">
<h3 title="Timing Attacks">7.2. 計時~攻撃</h3>

<p>
~cacheの首な利用の一つは，処理能を最適化することにあるので、そのような利用は，以前に どの資源が要請されたかについての情報を “漏洩し得る” 。
◎
Because one of the primary uses of a cache is to optimise performance, its use can "leak" information about what resources have been previously requested.
</p>

<p>
例えば、利用者がある~site A を訪問して，利用者の~browserが A からの応答をいくつか~cacheしてから，別の~site B へ~navigateしたとするとき、~site B は，~site A に存在すると知っている応答を読込もうと試みれる。
それが，~~普段より素早く読込まれた場合、~site B は，利用者が~site A を
— ~site A のある特定の~pageさえも —
訪問したものと見做せる。
◎
For example, if a user visits a site and their browser caches some of its responses, and then navigates to a second site, that site can attempt to load responses that it knows exists on the first site. If they load very quickly, it can be assumed that the user has visited that site, or even a specific page on it.
</p>

<p>
そのような “計時~攻撃” は、~cache~keyにもっと情報を追加することで軽減し得る
— （上に述べた攻撃を防止するために）参照元~site【すなわち~referrer】の同一性を追加するなど。
これは、 “~keyの二重化（ `double keying^en ）” と呼ばれることもある。
◎
Such "timing attacks" can be mitigated by adding more information to the cache key, such as the identity of the referring site (to prevent the attack described above). This is sometimes called "double keying."
</p>

		</section>
		<section id="n-caching-of-sensitive-information">
<h3 title="Caching of Sensitive Information">7.3. 敏感な情報の~cache法</h3>

<p>
実装や配備における欠陥（あるいは~cache運用の誤理解）は、私用と考えられる敏感な情報（例：認証~資格証）の~cachingを導き、権限付与されていない主体に公開されるかもしれない。
◎
Implementation and deployment flaws (as well as misunderstanding of cache operation) might lead to caching of sensitive information (e.g., authentication credentials) that is thought to be private, exposing it to unauthorized parties.
</p>

<p class="note">注記：
`Set-Cookie$h 応答~header `RFC6265$r は、~cachingを~~妨げない
— `Set-Cookie$h ~headerを伴う~cache可能な応答は、~cacheに対する後続の要請を満足するために利用できる（また，利用されることが多い）。
`~server$には、これらの応答の~cachingを制御したいときには，適切な `Cache-Control$h 応答~headerを発することが，奨励される。
◎
Note that the Set-Cookie response header field [RFC6265] does not inhibit caching; a cacheable response with a Set-Cookie header field can be (and often is) used to satisfy subsequent requests to caches. Servers who wish to control caching of these responses are encouraged to emit appropriate Cache-Control response header fields.
</p>

		</section>
	</section>
	<section id="iana.considerations">
<h2 title="IANA Considerations">8. ~IANA考慮点</h2>

【この節は未訳。】

	</section>
	<section id="collected.abnf">
<h2 title="Collected ABNF">付録 A. 総集的~ABNF</h2>

【この節は未訳。】

	</section>
	<section id="changes.from.rfc.7234">
<h2 title="Changes from RFC 7234">付録 B. RFC 7234 からの変更点</h2>

<p>
`Warning$h 応答~headerは廃用にされた。
`Warning^h が~supportする情報の大部分は、応答を精査すれば拾える
— それ以外の各種 `warn-code^p も、有用にはなり得るが，全面的に助言的であり、実施においては，~cacheや中継者により追加されていなかった。
（ `5.5$sec ）
◎
The Warning response header was obsoleted. Much of the information supported by Warning could be gleaned by examining the response), and the remaining warn-codes — although potentially useful — were entirely advisory, and in practice were not added by caches or intermediaries. (Section 5.5)
</p>

	</section>
	<section id="change.log">
<h2 title="Change Log">付録 C. 変更~log</h2>

<p>
この節は、 RFC として発行する前に除去されることになる。
【以下、この節は未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
`Semantics/謝辞$sec を見よ。
◎
See Appendix "Acknowledgments" of [Semantics].
</p>

	</section>
	<section id="rfc.authors">
<h2 title="Authors' Addresses">著作者の~address</h2>

<p>
`Semantics/著作者の~address$sec と同じ
【なので、この訳では省略する。】
</p>

	</section>
</main></div>
