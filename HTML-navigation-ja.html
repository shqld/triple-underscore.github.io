<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Browsing the Web（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style type="text/css">
.js {
	color: green;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'browsing-the-web',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'hm': // HTTP method
	text = `\`<code class="method">${key}</code>\``;
	break;
case 'sc': // url scheme
	text = key.replace(/_/g, ':');
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2019-06-28
trans_update:2019-06-28
source_checked:180622
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsing-the-web.html
site_nav:browsers,network,html
nav_prev:HISTORY
nav_next:WAPI
trans_1st_pub:2017-01-01


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
dir:directive
ps:pseudo
jv:js-value
sl:js-slot
jA:abstract
jT:js-type
v:value
hst:status

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
E:code
dir:code
ps:code
sl:span
jA:span
jv:code
jT:code
hst:code
v:code
V:var
i:i
sub:sub
cite:cite

●●original_urls
offline:https://html.spec.whatwg.org/multipage/offline.html

●●words_table

	●network／保安／navi
TLS:
DNS:
Content-Type:
HTTP_S:HTTP(S) 
Location:
download::::ダウンロード
mail::::メール
payload::::ペイロード
redirect::::リダイレクト
caching-strategy:caching strategy:::キャッシュ方策
disposition:
service-worker:service worker
	~navigate法:navigating
	~network用:networking
referrer::::リファラ
load:
unload:
	~unload法:unloading:
部位:part:~
refresh:

	~secure化:secured
sandbox::::サンドボックス
	~sandbox法:sandboxing
非冪等:non-idempotent:~
阻止d:Blocked::阻止される::ブロックされる
許容ed:Allowed::許容される
強制的:forcible:~
悪用-:exploit:~
騙す:trickする:~
危険:dangerous:~

	●環境 ／ 閲覧
id:
	予約-済み:reserved
標的:target::~::ターゲット
	-:delta
	-:jump
補助:auxiliary::~
閲覧:browsing::~

再読込み:reload::再読み込み::リロード
	-:component
成熟-:mature::~

走査する:traverseする::辿る
走査した:traverseした::辿った
走査:traversal::辿り
終了入子:termination nesting:終了入れ子
族:family::~
回復可能:salvage 可能:~

閉じる:closeする::~
開く:openする::~

	●IDL / js / event
欄:field::~::フィールド
	用の~listenerがある:listen
	scripting::::スクリプト処理
	発火-済み:fired
中途完了:abrupt completion::~

	●データ／構文／操作
EOF:
	LF
	LINE FEED
Record:
BOM:
hash:
percent-::: %-
options:::option 集
tokenizer:::token 化器:トークン化器:トークナイザ
開始tag:start tag:開始 tag::開始タグ
整形式性:well-formedness::~
下位型:subtype::~
素の:plain::~

未設定:unset::~
	On getting／On setting

同等:equal::~

作成時の:creation::~
解析器:parser::~::パーサ
直列形の:serialized::~::シリアル形の
同型:isomorphic::~

	●一般処理
	reinvoke:再び呼出す
片付け:cleanup::~
	中止-法:aborting
timer::::タイマー
準備度:readiness:~
増分的:incremental:~
	他を阻まない:non-blocking
	unsuccessful
静止-:pause:~
続行-:proceed:~
	cancelation


変化あり:changed:~
持続化-:persist:~
持続的な:persisted:~
復旧-:restore::~
復旧:restoration::~
	-:step labeled

	●UI
	右~click:right-click
	media::::メディア
modal::::モーダル
prompt:
scrolling::::スクロール処理
	~scroll可能域:scrollable region
書字方向性:directionality:~
	制御
逐次的:sequential:~
上端:top:~
開始位置:beginning:~
始点:starting point:~
autofill:

	●仕様
選択肢:option:~:::オプション
外部的:external:~
自立的:stand-alone:~
在来の:preexisting:~
整合的に:consistent mannerで:~
文書化-:document:~
	actually
	-:default
	でき:possible
	なければその前に:potentially before
	ほぼ間違いなく:certainly
	他にない:nothing conspires
	同じものを与える下で:setup
	対になる:for that matter
	いらつく／紛らわしい／的外れである: annoying, deceptive, or pointless
	そうな:likely
	~~真の:real
	担当:responsible／responsibility
	:optionally
	今の所は:in the meantime

	●仕様（動詞
	強く:highly
	unspecified

確認-:confirm:~
確認:confirmation:~
	（確認を）とる:ask
	食い違いが生じる:disagree
拒否-:refuse:~
手渡す:handする:取り扱わせる
究明:investigation:~
注目:attention:~
判定-:judge:~
	-:defer
指名-:designate:~
修正-:fix:~
	-:decide
	関心を失った:no longer interested in:
	面した:in the face of
	かいくぐる:evade
	ことにされた:supposed
	ことになった場合:face
	するよりも，~~寛容でない:are less permissive compared to doing 〜 instead
	選ぶ:choose
	したい所:hope
	-:threaded through

	●未分類（動詞
合成-:synthesize::~
表示中:showing:~
消滅-:disappear:~
埋めた:fillした:~
切替えた:switchした:切り替えた
折返す:wrapする:折り返す
発した:emitした:~

	-:store
	登録-済み:registered
	引く:brought
	待たれる:pending
	引用用の:quoting
		成す:comprise
	消え去る:going away
	終え:finish:
	間に挟む:intervening
	戻-:back
	結果を得る:dereference

	●未分類
	-:mark
open:
iframe-srcdoc:iframe srcdoc
table
	PI
	POST:
PLAINTEXT:
古典:classic::~::クラシック
hyperlink::::ハイパーリンク
id:
feed-viewer::::配信ビューア
offline::::オフライン
package::::パッケージ
	multipart
連続的:contiguous:~

	時間長:amount of time
	-:parameter
	Atom
	seamless:
	time:
	word processor
	~unload中の~openは無視する:ignore-opens-during-unload
	それ用の処理器:word processor


	●指示語
最近の:latest:~
	aforementioned
	続けて:in a row
	まるごと:altogether
	以前の:previous
	先頭の:leading
	前もって:prior
	前／後:back or forwards
	早期の:earlier
	最終的に:eventual
	最初に:in the first place
	箇所 place
	:two
	何らかの:some sort of

●●original_id_map


	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts


●●words_table1

src-embed:src
src-iframe:src
src-img:src
src-media:src

javascript:<code class="scheme">javascript:</code>


●●link_map



	●idl
E.SecurityError:~WEBIDL#securityerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebSocket:~WEBSOCKET#websocket
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLsse#eventsource
I.History:~HISTORY#history-3
I.WebSocket:~WEBSOCKET#websocket
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy

~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

I.BeforeUnloadEvent:#beforeunloadevent
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit

I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest

m.WebSocket:~WEBSOCKET#dom-websocket
m.cancelable:~DOM4#dom-event-cancelable
m.document.domain:~ORIGIN#dom-document-domain
m.document.title:~HTMLdom#dom-document-title
m.history.state:~HISTORY#dom-history-state
m.location.assign:~HISTORY#dom-location-assign
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.persisted:#dom-pagetransitionevent-persisted
m.preventDefault:~DOM4#dom-event-preventdefault
m.pushState:~HISTORY#dom-history-pushstate
m.replaceState:~HISTORY#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.state:#dom-popstateevent-state
m.type:~DOM4#dom-event-type
m.window.open:~WINDOW#dom-window-open
m.opener:~BROWSERS#dom-window-opener

l.auto:~HISTORY#dom-scrollrestoration-auto
l.manual:~HISTORY#dom-scrollrestoration-manual


et.abort:~HTMLindex#event-abort
et.beforeunload:~HTMLindex#event-beforeunload
et.hashchange:~HTMLindex#event-hashchange
et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.unload:~HTMLindex#event-unload

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.a:~HEtextlevel#the-a-element
e.input:~HEinput#the-input-element
e.textarea:~HEforms#the-textarea-element

e.img:~HEimages#the-imge-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element

a.autoplay:~HEmedia#attr-media-autoplay
a.dir:~HTMLdom#the-dir-attribute
a.href:~HTMLlinks#attr-hyperlink-href
a.name:~HTMLobs#attr-a-name
a.type:~HEinput#attr-input-type
a.~src-embed:~HEembed#attr-embed-src
a.~src-iframe:~HEembed#attr-iframe-src
a.~src-img:~HEimages#attr-img-src
a.~src-media:~HEmedia#attr-media-src

sc.about_blank:~HTMLdep#about:blank
sc.mailto_:~IETF/rfc6068#section-2
sc.javascript_:#javascript-protocol
~javascript~URL要請を実行する:#javascript-protocol
	l.javascript:#javascript-protocol

hst.204:~RFC7231#section-6.3.5
hst.205:~RFC7231#section-6.3.6


c.application/atom+xml:~HTMLindex#application/atom+xml
c.multipart/x-mixed-replace:~HTMLLS/iana.html#multipart/x-mixed-replace
c.text/cache-manifest:~HTMLLS/iana.html#text/cache-manifest
c.text/css:~HTMLindex#text/css
bl.text/html:~HTMLLS/iana.html#text/html
c.text/plain:~IETF/rfc2046#section-4.1.3
c.text/vtt:~HTMLindex#text/vtt

h.Content-Disposition:~IETF/rfc6266
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
	https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header-dfn
h.Refresh:~HTMLLS/iana.html#refresh

v.off:~HTMLautofill#attr-fe-autocomplete-off
ps.target:~HTMLselectors#selector-target

非~文書~内容として取扱う:#navigate-non-Document

	●用語
なければその前に:#_potentially-before
~app~cache用:#_for-app-cache

~source閲覧文脈:#source-browsing-context
V.S:#source-browsing-context
V.B:#_target-browsing-context
~navigate:#navigate
~navi:#navigate
~navigate応答を処理する:#process-a-navigate-response
~navigate~fetchを処理する:#process-a-navigate-fetch
~navigate~URL~schemeを処理する:#process-a-navigate-url-scheme
自己~naviを明示的に上書き:#explicit-self-navigation-override
素片へ~navigateする:#scroll-to-fragid
素片へ~scrollしようと試行する:#try-to-scroll-to-the-fragment
素片へ~scrollする:#scroll-to-the-fragment-identifier

履歴を走査する:#traverse-the-history
~entryを更新する:#entry-update
明示的に~supportされる~JSON~MIME型:#explicitly-supported-json-mime-type
明示的に~supportされる~XML~MIME型:#explicitly-supported-xml-mime-type

成熟-:#concept-navigate-mature
~plugin文書:#plugin-document
標的~要素:#target-element
終了入子~level:#termination-nesting-level

指示された要素を見出す:#find-a-potential-indicated-element
doc.指示された部位:#the-indicated-part-of-the-document
doc.~unload発火-済み~flag:#fired-unload
doc.~page表示中~flag:#page-showing
doc.回復可能~状態:#concept-document-salvageable
文書を中止する:#abort-a-document
文書を中止-:#abort-a-document
文書の読込ngを停止する:#stop-document-loading
文書を初期化する:#initialise-the-document-object
doc.初期化-:#initialise-the-document-object
文書を~unloadする:#unload-a-document
文書の~unloadを~promptする:#prompt-to-unload-a-document
~unloadは利用者から拒否された:#refused-to-allow-the-document-to-be-unloaded
文書~unload時の片付け手続き:#unloading-document-cleanup-steps
~unload中の文書の可視性~変化-時の手続き:#unloading-document-visibility-change-steps

新たな~pageで~session履歴を更新する:#update-the-session-history-with-the-new-page
~session履歴~文書の可視性を変更する手続き:#session-history-document-visibility-change-steps

i.置換を可能化する:#replacement-enabled
i.例外を可能化する:#exceptions-enabled
i.履歴~navi:#history-navigation-flag
i.~eventは他を阻まない:#non-blocking-events-flag

再読込みから誘発された:#reload-triggered-navigation
持続的な利用者~状態を復旧-:#restore-persisted-user-state
~inline内容を表示する:#read-ua-inline

	#read-html
	#read-xml
	#read-plugin
	#read-media
	#read-text
	#hand-off-to-external-software
	~HISTORY#history-notes
	#navigate-fragid-step
	#read-multipart-x-mixed-replace


	●BROWSERS
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にして:~BROWSERS#browsing-context-nested-through
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈~名:~BROWSERS#browsing-context-name
閲覧文脈~視野~生成元:~BROWSERS#browsing-context-scope-origin
~load~event遅延~中~mode:~BROWSERS#delaying-load-events-mode
作動中の文書:~BROWSERS#active-document
閲覧文脈にて作動中の文書を設定する:~BROWSERS#set-the-active-document
~navigateすることは許容されて:~BROWSERS#allowed-to-navigate
作成-:~BROWSERS#creating-a-new-browsing-context
文書~族:~BROWSERS#document-family

~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
文書を破棄する:~WINDOW#discard-a-document

持続的な利用者~状態:~HISTORY#an-entry-with-persisted-user-state
~session履歴:~HISTORY#session-history
~session履歴~entry:~HISTORY#session-history-entry
履歴を前／後に走査する:~HISTORY#traverse-the-history-by-a-delta
現在の~entry:~HISTORY#current-entry
最近の~entry:~HISTORY#latest-entry
直列形の状態:~HISTORY#serialized-state
~scroll復旧~mode:~HISTORY#scroll-restoration-mode

生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
不透明な生成元:~ORIGIN#concept-origin-opaque
文書~用に~sandbox法を実装する:~ORIGIN#implement-the-sandboxing
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag

sl.Window:~WINDOW#concept-windowproxy-window


	●HTMLINFRA
~Content-Type~metadata:~HTMLurl#content-type
型~情報:~HTMLurl#content-type
	相対的に構文解析-:~HTMLurl#resolve-a-url
	結果の~URL~record:~HTMLurl#resulting-url-record
	~scheme~data:~HTMLurl#concept-url-scheme-data

	~HTML文書:~HTMLINFRA#html-documents
即時:~HTMLINFRA#immediately
並列的:~HTMLINFRA#in-parallel
~plugin:~HTMLINFRA#plugin
~secure化でき:~HTMLINFRA#concept-plugin-secure
~target上書き:~HTMLINFRA#concept-event-target-override
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications



	●WAPI
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event-loop:~WAPI#event-loop
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
環境~設定群~obj:~WAPI#environment-settings-object
大域~obj:~WAPI#global-object
履歴~走査~task源:~WAPI#history-traversal-task-source
~network用~task源:~WAPI#networking-task-source
~script:~WAPI#concept-script
~scriptingが不能化されている:~WAPI#concept-bc-noscript
~scriptは不能化され:~WAPI#concept-bc-noscript
静止-:~WAPI#pause
古典~scriptを作成する:~WAPI#creating-a-classic-script
古典~scriptを走らす:~WAPI#run-a-classic-script
既定の古典~script~fetch~options:~WAPI#default-classic-script-fetch-options

環境:~WAPI#environment
enV.~HTTPS状態:~WAPI#https-state
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.~id:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~service-worker:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url
環境を破棄する手続き:~WAPI#environment-discarding-steps
新たな~JS~realmを作成する:~WAPI#creating-a-new-javascript-realm

~unload中の~openは無視する~counter:~HTMLdynamic#ignore-opens-during-unload-counter
登録-済み~handler:~HTMLnavigator#dom-navigator-registerprotocolhandler


	●FETCH
~fetch~scheme:~FETCH#fetch-scheme
~HTTP_S~scheme:~FETCH#http-scheme
~fetch:~FETCH#concept-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~ok状態s:~FETCH#ok-status
~header~list:~FETCH#concept-header-list
応答を処理する:~FETCH#process-response
要請:~FETCH#concept-request
~network~error:~FETCH#concept-network-error
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.~referrer:~FETCH#concept-request-referrer
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.置換する~client~id:~FETCH#concept-request-replaces-client-id
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.~URL:~FETCH#concept-request-url
rq.~URL~list:~FETCH#concept-request-url-list
rq.現在の~URL:~FETCH#concept-request-current-url
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.生成元:~FETCH#concept-request-origin
rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.再読込み~navi~flag:~FETCH#concept-request-reload-navigation-flag
rq.履歴~navi~flag:~FETCH#concept-request-history-navigation-flag

応答:~FETCH#concept-response
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.~Location~header~URL:~FETCH#concept-response-location-url
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status

	●他HTML

doc.~referrer施策:~HTMLdom#concept-document-referrer-policy
doc.~HTTPS状態:~HTMLdom#concept-document-https-state
doc.~referrer:~HTMLdom#the-document's-referrer
	'
作動中の構文解析器:~HTMLdom#active-parser
現在の文書の準備度:~HTMLdom#current-document-readiness

共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps

消滅させる:~WEBSOCKET#make-disappear
強制的に閉じる:~HTMLsse#concept-eventsource-forcibly-close

~HTML構文解析器:~HTMLparsing#html-parser
~PLAINTEXT状態:~HTMLparsing#plaintext-state
構文解析器を中止する:~HTMLparsing#abort-a-parser
~HTML構文解析器~内で:~HTMLparsing#parser-appcache
入力~byte~stream:~HTMLparsing#the-input-byte-stream
構文解析を停止した:~HTMLparsing#stop-parsing
停止-:~HTMLparsing#stop-parsing
~tokenizer:~HTMLparsing#tokenization

st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)

~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
利用者による作動化により誘発され:~HTMLinteraction#triggered-by-user-activation

~XML構文解析器:~HTMLxml#xml-parser
~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	内容を具現化するのに失敗する:~HEembed#sandboxPluginEmbed

~form提出:~HTMLforms#concept-form-submit
再設定~algo:~HTMLforms#concept-form-reset-control
~autofill欄~名:~HTMLautofill#autofill-field-name

~downloadとして:~HTMLlinks#as-a-download
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2
具現化されて:~HTMLrendering#being-rendered
作動中の~timer~list:~HTMLGAPI#list-of-active-timers


	●他
sub.大小無視:~INFRA#ascii-case-insensitive
同型に復号する:~INFRA#isomorphic-decode

~tree順序:~DOM4#concept-tree-order
~ID:~DOM4#concept-id
doc.内容~型:~DOM4#concept-document-content-type
doc.種別:~DOM4#concept-document-type
doc.~URL:~DOM4#concept-document-url
doc.文字~符号化法:~DOM4#concept-document-encoding
	~HTMLdep#document's-character-encoding
 '
~tree内:~DOM4#in-a-document-tree
~eventを作成する:~DOM4#concept-event-create
配送する:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element

~URLを直列化する:~URL1#concept-url-serializer
~URL:~URL1#concept-url
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
同等な~URL:~URL1#concept-url-equals
~URL~record:~URL1#concept-url

~UTF-8復号する:~ENCODING#utf-8-decode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

疑似類:~SELECTORS4#pseudo-class
表示域:~CSS2VISUREN#viewport
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view
開始位置へ~scroll:~CSSOMVIEW#scroll-to-the-beginning-of-the-document

~MIME型:~MIMESNIFF#mime-type
~JSON~MIME型:~MIMESNIFF#json-mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
V.資源から算出された~MIME型:#_computed-mime-type

文書の~CSP~listを初期化する:~CSP3#initialize-document-csp
~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-request
~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-response

応答からの特能~施策で文書のそれを初期化する:~FEATUREPOLICY#initialize-from-response

中途完了:~TC39#sec-completion-record-specification-type
現在の~Realm~Record:~TC39#current-realm
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.Type:~TC39#sec-ecmascript-data-types-and-values


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
Loading Web pages 章の
<a href="~SPEC_URL">Browsing the Web</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1 title="Browsing the Web">7.8. Web の閲覧</h1>
	</hgroup>

</header>

<hr>

<main id="MAIN" hidden>

		<section id="browsing-the-web">
<h2 title="Browsing the Web">7.8. ~webの閲覧</h2>

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="navigating-across-documents">
<h3 title="Navigating across documents">7.8.1. 文書から文書への~navigate法</h3>

<p>
ある種の動作は、`閲覧文脈$を新たな資源へ`~navigate$させる。
~UAは、この仕様に定義されるそれに加えて，利用者に閲覧文脈を明示的に~navigateさせる様々な仕方を供してもヨイ。
◎
Certain actions cause the browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.
</p>

<p class="example">
例えば 次のものは、閲覧文脈を~navigateさせ得る
⇒＃
`~hyperlinkを追う$,
`~form提出$,
`window.open()$m ~method,
`location.assign()$m ~method
◎
For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause a browsing context to navigate.
</p>

<p class="note">注記：
資源を識別するために必要とされる情報は、資源の~URLのみに限られない。
例えば、~HTTP `POST^hm を利用する~form提出は、~HTTP［
~method, ~payload
］も情報として有することになる。
類似的に，`~iframe-srcdoc文書$は、自身が利用する~dataを知る必要がある。
◎
A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method and payload. Similarly, an iframe srcdoc document needs to know the data it is to use.
</p>

<p>
`~navi$には常に、
`~source閲覧文脈@
と呼ばれる，その開始-を担当していた`閲覧文脈$が孕まれる。
◎
Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.
</p>

<p class="trans-note">【
すなわち、`~navi$~algoは，~source閲覧文脈を明示的に与えずに呼出されることもあるが、その場合でも，~source閲覧文脈は その箇所の文脈から暗黙的に決定される。
】</p>

<p class="XXX">
<a href="~HTMLissue/1130">issue #1130</a>
にて説明されるように、閲覧文脈を~sourceとして利用するのは，正しい~architectureとは言えないかもしれない。
◎
As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.
</p>

<div class="algorithm">

<div class="p">
<p>
閲覧文脈を資源へ
`~navigate@
する~algoは、次を入力にとり，以下を走らすモノトスル：
</p>

<ul><li>`S$V （`~source閲覧文脈$）
</li><li>%B （~navigateされる`閲覧文脈$）
</li><li>%資源 （~navigate先とされる資源または その~URL）
</li><li>%例外~可能化~flag ~IN { `例外を可能化する@i, ε }（省略時は ε ）
</li><li>%置換~可能化~flag ~IN { `置換を可能化する$i, ε }（省略時は ε ）
</li></ul>

<p class="trans-note">【
以下，この節を通して、記号 `S$V, %B は，順に［
`~source閲覧文脈$, ~navigateされる`閲覧文脈$
］を意図して与えられている入力を表す。
これらは同じ閲覧文脈を指す場合もある。
】【
%置換~可能化~flag
は，原文には明示的に記されていないが、この~algoを呼出している一部の箇所から，入力として与えられている。
】</p>

◎
To navigate a browsing context browsingContext to a resource resource, optionally with an exceptions enabled flag, the user agent must run these steps:
</div>

<ol>
	<li>
%~navi ~LET この`~navi$~algoの~instance
◎
↓</li>
	<li>
~IF［
%資源 は`~URL$である
］
⇒
%資源 ~SET 次のようにされた 新たな`要請$
⇒
`~URL$rq ~SET %資源
◎
If resource is a URL, then set resource to a new request whose url is resource.
</li>
	<li>
~IF［
%資源 は`要請$である
］~AND［
%~navi は
`再読込みから誘発された@
ものである
］
⇒
%資源 の`再読込み~navi~flag$rq ~SET ~T
◎
If resource is a request and this is a reload-triggered navigation, then set resource's reload-navigation flag. 
</li>
	<li id="sandboxLinks">
<p>
~IF［
`S$V は， %B を`~navigateすることは許容されて$いない
］：
◎
If the source browsing context is not allowed to navigate browsingContext, then:
</p>
		<ol>
			<li>
~IF［
%例外~可能化~flag ~EQ `例外を可能化する$i
］
⇒
~THROW `SecurityError$E
◎
If the exceptions enabled flag is set, then throw a "SecurityError" DOMException.
</li>
			<li>
<p>
~ELSE
⇒
~UAは［
新たな, または `S$V の`~top-level閲覧文脈$
］内に %資源 を開くような選択肢を利用者に提供してもヨイ
— その事例では、~UAは、利用者から指名された`~top-level閲覧文脈$を，利用者がそれを独立に要請したかのように %資源 へ`~navigate$するモノトスル。
◎
Otherwise, the user agent may instead offer to open resource in a new top-level browsing context or in the top-level browsing context of the source browsing context, at the user's option, in which case the user agent must navigate that designated top-level browsing context to resource as if the user had requested it independently.
</p>

<p class="note">注記：
しかしながら，そうすることは、危険にもなり得る
— それは、利用者が［
作者による，内容を~sandbox化する明示的な要請
］を上書きすることを意味するので。
◎
Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.
</p>

<p class="trans-note">【
選択肢を提供しない場合、（原文の “`instead^en” を “`SecurityError^E の代わりに” と解釈するならば）最初の段と同じく `SecurityError$E になると思われるが，はっきりしない。
】</p>

			</li>
		</ol>
	</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれも満たすような，［
%B を~navigateしようとする在来の %試み
］がある
］…：
</p>

<ul><li>%試み における`~source閲覧文脈$ ~EQ %B
</li><li>%試み は `文書を~unloadする$~algoを現在~走らせている
</li></ul>

<p>
…ならば
⇒
~RET
— %試み やそれが走らせている~algoは、影響されない。
</p>

◎
If there is a preexisting attempt to navigate browsingContext, and the source browsing context is the same as browsingContext, and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.
</li>
	<li>
~IF［
%文書 に対し，`文書の~unloadを~promptする$~algoが走っている
］
⇒
~RET
— その~algoは、影響されない。
◎
If the prompt to unload algorithm is being run for the active document of browsingContext, then return without affecting the prompt to unload algorithm.
</li>
	<li id="navigate-fragid-step">
<p>
~IF［
%~navi は`再読込みから誘発された$ものではない
］~AND［
%資源 は`要請$である
］：
</p>
		<ol>
			<li>
%~URL ~LET %資源 の`~URL$rq
</li>
			<li>
~IF［
( %~URL, %文書 の`~URL$doc ) は `素片は除外する^i 下で`同等な~URL$である
］
⇒
~IF［
%~URL の`素片$url ~NEQ ~NULL
］
⇒＃
`素片へ~navigateする$( %B, %~URL, %置換~可能化~flag )；
~RET
</li>
		</ol>
◎
If this is not a reload-triggered navigation, resource is a request, resource's url equals browsingContext's active document's URL with exclude fragments flag set, and resource's url's fragment is non-null, then navigate to that fragment, with replacement enabled if this was invoked with replacement enabled, and return.
</li>
	<li>
<p>
%B を~navigateしようとする在来の
~EACH( %試み )
に対し：
</p>
		<ol>
			<li>
~IF［
%試み はすでに`成熟-$している
］
⇒
~CONTINUE
</li>
			<li>
%試み を取消す
— %試み により開始された`~fetch$ ~algoの~instanceも含めて
</li>
			<li>
~IF［
%試み は，すでに新たな`文書$を作成して`初期化-$docした
］
⇒
`文書を中止する$( その文書 )
</li>
		</ol>

<p>
（`成熟-$した %試み に対しては、`~session履歴~entry$がすでにあるので，後で`新たな~pageで~session履歴を更新する$~algoの中で取扱われる。）
</p>

◎
Cancel any preexisting but not yet mature attempt to navigate browsingContext, including canceling any instances of the fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document object, abort that Document also. (Navigation attempts that have matured already have session history entries, and are therefore handled during the update the session history with the new page algorithm, later.)
</li>
	<li>
<p>
`文書の~unloadを~promptする$( %文書 )
⇒
~IF［
%文書 の`~unloadは利用者から拒否された$
］
⇒
~RET
◎
Prompt to unload the active document of browsingContext. If the user refused to allow the document to be unloaded, then return.
</p>

<p>
この段を走らせている間に %~navi が取消されたとしても、`文書の~unloadを~promptする$~algoは，完了するモノトスル。
◎
If this instance of the navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.
</p>
	</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort the active document of browsingContext.
</li>
	<li>
<p>
~IF［
%B は`入子の閲覧文脈$である
］
⇒
%B を`~load~event遅延~中~mode$にする
◎
If browsingContext is a nested browsing context, then put it in the delaying load events mode.
</p>

<p>
~UAは、後に， %~navi が［
`成熟-$した ／ 
すべて走らせ終えた ／
取消された ／
中止された
］時点
— いずれかが最初に生じた時点 —
で， %B を`~load~event遅延~中~mode$から外すモノトスル。
◎
The user agent must take this nested browsing context out of the delaying load events mode when this navigation algorithm later matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.
</p>

	</li>
	<li>
%~navi種別 ~LET ［
%~navi は`~form提出$~algoの結果として呼出されたならば `form-submission^l ／
~ELSE_ `other^l
］
◎
Let navigationType be "form-submission" if the navigation algorithm was invoked as a result of the form submission algorithm, and "other" otherwise.
</li>
	<li>
~RET
— ただし、以降の手続きは`並列的$に継続する。
それは、必要とされるなら %資源 を得ようと試みる。
◎
Return to whatever algorithm invoked the navigation steps and continue running these steps in parallel.
◎
This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:
</li>
	<li>
<p>
~IF［
%資源 は`応答$である
］：
</p>

<ol><li>`~navigate応答を処理する$( ~NULL, %資源, %~navi種別, `S$V, %B )
</li><li>~RET
</li></ol>
◎
If resource is a response
◎
Run process a navigate response with null, resource, navigationType, the source browsing context, and browsingContext.
</li>
	<li>
~Assert：
%資源 は`要請$である
【この段は訳者による補完。】
◎
↓</li>
	<li>
%~scheme ~LET %資源 の`~URL$rqの`~scheme$url
◎
↓</li>
	<li>
<p>
~IF［
%~scheme ~EQ `javascript^l
］：
◎
If resource is a request whose url's scheme is "javascript"
</p>
		<ol>
			<li>
<p>
`~DOM操作~task源$から，次を走らす`~taskを~queueする$
— この`~task$には %B にて`作動中の文書$ が結付けられるとする：
◎
Queue a task, on the DOM manipulation task source and associated with the active document of browsingContext, to run these steps:
</p>
				<ol>
					<li>
%応答 ~LET `~javascript~URL要請を実行する$( %資源, `S$V, %B )
◎
Let response be the result of executing a javascript: URL request given resource, the source browsing context, and browsingContext.
</li>
					<li>
`~navigate応答を処理する$( %資源, %応答, %~navi種別, `S$V, %B )
◎
Run process a navigate response with resource, response, navigationType, the source browsing context, and browsingContext.
</li>
				</ol>

<p class="example">
よって，例えば `a$e 要素の `href$a 属性に対する `javascript_$sc ~URLが評価されるのは、その`~hyperlinkを追う$ときに限られることになる。
一方で、 `iframe$e 要素 %E の `~src-iframe$a 属性における その種の~URLは、
%E が設定しておかれるときに， %E が`入子にしている閲覧文脈$ %C の文脈~下で評価される。
結果の返り値が文字列であったなら， %C の`文書$を置換する（したがって %C の`~window$も変更する）ことになる。
◎
So for example a javascript: URL in an href attribute of an a element would only be evaluated when the link was followed, while such a URL in the src attribute of an iframe element would be evaluated in the context of the iframe's own nested browsing context when the iframe is being set up. Once evaluated, its return value (if it was a string) would replace that browsing context's Document, thus also changing the Window object of that browsing context.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELIF …
【`~app~cache用$の条件と処理】
◎
If resource is to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is fast, and the user agent is not in a mode where it will avoid using application caches
◎
• Fetch resource from the most appropriate application cache of those that match.
◎
For example, imagine an HTML page with an associated application cache displaying an image and a form, where the image is also used by several other application caches. If the user right-clicks on the image and chooses "View Image", then the user agent could decide to show the image from any of those caches, but it is likely that the most useful cache for the user would be the one that was used for the aforementioned HTML page. On the other hand, if the user submits the form, and the form does a POST submission, then the user agent will not use an application cache at all; the submission will be made to the network.
◎
This still needs to be integrated with the Fetch standard. [FETCH]
</li>
	<li>
~ELIF［
%~scheme ~IN { `~fetch~scheme$ }
］
⇒
`~navigate~fetchを処理する$( %要請, `S$V, %B, %~navi種別 )
◎
If resource is a request whose url's scheme is a fetch scheme
◎
• Run process a navigate fetch given resource, the source browsing context, browsingContext, and navigationType.
</li>
	<li>
~ELSE
⇒
`~navigate~URL~schemeを処理する$( %要請 の`~URL$rq, %B )
◎
Otherwise, resource is a request whose url's scheme is neither "javascript" nor a fetch scheme
◎
• Run process a navigate URL scheme given resource's url and browsingContext.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~navigate~fetchを処理する@
ときは、所与の
( `要請$ %要請, `~source閲覧文脈$ `S$V, `閲覧文脈$ %B, 文字列 %~navi種別 )
に対し，次を走らす：
◎
To process a navigate fetch, given a request request, browsing context sourceBrowsingContext, browsing context browsingContext, and string navigationType, run these steps:
</p>

<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
<p>
%要請 を次のように設定する：
</p>

<ul><li>`~client$rq ~SET `S$V にて`作動中の文書$に`関連な設定群~obj$
</li><li>`行先$rq ~SET `document^l
</li><li>`~mode$rq ~SET `navigate^l
</li><li>`資格証~mode$rq ~SET `include^l
</li><li>`~URL資格証~利用~flag$rq ~SET ~T,
</li><li>`~redirect~mode$rq ~SET `manual^l
</li><li>`置換する~client~id$rq ~SET %B にて`作動中の文書$に`関連な設定群~obj$の`~id$enV
</li></ul>
◎
Set request's client to sourceBrowsingContext's active document's relevant settings object, destination to "document", mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and replaces client id to browsingContext's active document's relevant settings object's id.
</li>
	<li>
~IF［
%B は`子~閲覧文脈$である
］
⇒
~IF［
%B を`入子にして$いる`閲覧文脈~容器$の`閲覧文脈~視野~生成元$ %O ~NEQ ε
］
⇒
%要請 の`生成元$rq ~SET %O
◎
If browsingContext is a child browsing context and the browsing context container of browsingContext has a browsing context scope origin, then set request's origin to that browsing context scope origin.
</li>
	<li>
%予約-済み環境 ~LET ~NULL
◎
Let done be false and reservedEnvironment be null.
</li>
	<li>
<p id="navigate-redirect-step">
~WHILE 無条件：
◎
While done is false:
</p>
		<ol>
			<li>
%現在の~URL ~LET ［
%応答 ~NEQ ~NULL ならば %応答 の`~Location~header~URL$rs ／
~ELSE_ %要請 の`現在の~URL$rq
］
◎
Let currentURL be response's location URL, if response is not null, and request's current URL otherwise.
</li>
			<li>
<p>
~IF［
%予約-済み環境 ~NEQ ~NULL
］~AND［
( %現在の~URL の`生成元$url, %予約-済み環境 の`作成時の~URL$enVの`生成元$url )
は`同一-生成元$でない
］：
◎
If reservedEnvironment is not null and currentURL's origin is not the same as reservedEnvironment's creation URL's origin, then:
</p>
				<ol>
					<li>
%予約-済み環境 用に`環境を破棄する手続き$を走らす
◎
Run the environment discarding steps for reservedEnvironment.
</li>
					<li>
%予約-済み環境 ~SET ~NULL
◎
Set reservedEnvironment to null.
</li>
				</ol>
			</li>
			<li>
~IF［
%予約-済み環境 ~EQ ~NULL
］
⇒
%予約-済み環境 ~SET 次のようにされた新たな`環境$
⇒＃
`~id$enV ~SET 一意かつ不透明な文字列,
`~target閲覧文脈$enV ~SET %B
◎
If reservedEnvironment is null, then set reservedEnvironment to a new environment whose id is a unique opaque string and target browsing context is browsingContext.
</li>
			<li>
<p>
%予約-済み環境 の`作成時の~URL$enV ~SET %現在の~URL
◎
Set reservedEnvironment's creation URL to currentURL.
</p>

<p class="note">注記：
%予約-済み環境 の`作動中の~service-worker$enVは、要請~URLが~service-worker登録に合致するならば，~fetchの間に
<a href="~SW1#on-fetch-request-algorithm">~fetchを取扱う~algo</a>の中で設定される。
`SW$r
◎
The created environment's active service worker is set in the Handle Fetch algorithm during the fetch if the request URL matches a service worker registration. [SW]
</p>
			</li>
			<li>
%要請 の`予約-済み~client$rq ~SET %予約-済み環境
◎
Set request's reserved client to reservedEnvironment.
</li>
			<li>
~IF［
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, %~navi種別, `S$V, %B )
`CSP$r
の結果 ~EQ `阻止d^i
］
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
If the Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, navigationType, sourceBrowsingContext, and browsingContext, then set response to a network error and set done to true. [CSP]
◎
Otherwise:
</li>
			<li>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET %要請 を用いて`~fetch$した結果
◎
If response is null, fetch request.
</li>
			<li>
~ELSE
⇒
%応答 ~SET `~HTTP~redirect~fetch$( %要請, %応答 ) を遂行した結果
◎
Otherwise, perform HTTP-redirect fetch using request and response.
</li>
			<li>
`~network用~task源$上の［
%応答 に対し`応答を処理する$
］`~task$を待機する
◎
Wait for the task on the networking task source to process response and set response to the result.
</li>
			<li>
~IF［
%応答 の`~Location~header~URL$rsは`~URL$であって，その`~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~CONTINUE
◎
If response does not have a location URL or the location URL is not a URL whose scheme is an HTTP(S) scheme, then set done to true.
</li>
			<li>
~BREAK
◎
↑</li>
		</ol>

<p class="note">注記：
~naviは、~redirectを手動で取扱う。
~naviが、~web~platformにおいて `mailto_$sc の類の~URLへの~redirectを~careする唯一の箇所なので。
◎
Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.
</p>

	</li>
	<li>
%所在 ~LET %応答 の`~Location~header~URL$rs
◎
↓</li>
	<li>
~IF［
%所在 ~EQ `失敗^i
］
⇒
%応答 ~SET `~network~error$
◎
If response's location URL is failure, then set response to a network error.
</li>
	<li>
<p>
~ELIF［
%所在 は`~URL$である
］
⇒
%所在 の`~scheme$url に応じて：
</p>
		<dl class="switch">
			<dt>`blob^l</dt>
			<dt>`file^l</dt>
			<dt>`filesystem^l</dt>
			<dt>`javascript^l</dt>
			<dd>
%応答 ~SET `~network~error$
</dd>

			<dt>`~fetch~scheme$である</dt>
			<dd>
<ol ><li>%新~要請 ~LET 新たな`要請$
</li><li>%新~要請 の`~URL$rq ~SET %所在
</li><li>`~navigate~fetchを処理する$( %新~要請, `S$V, %B, %~navi種別 )
</li></ol>
			</dd>

			<dt>その他</dt>
			<dd>
`~navigate~URL~schemeを処理する$( %所在, %B )
</dd>

		</dl>

◎
Otherwise, if response has a location URL that is a URL whose scheme is "blob", "file", "filesystem", or "javascript", then set response to a network error.
◎
Otherwise, if response has a location URL that is a URL whose scheme is a fetch scheme, then run process a navigate fetch with a new request whose url is response's location URL, sourceBrowsingContext, browsingContext, and navigationType.
◎
Otherwise, if response has a location URL that is a URL, run the process a navigate URL scheme given response's location URL and browsingContext.
</li>
	<li>
【`~app~cache用$の処理】
◎
Fallback in prefer-online mode: If response was not fetched from an application cache, and was to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is prefer-online, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the response identified by the URL in question from the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The user agent may indicate to the user that the original page load failed, and that the page used was a previously cached response.
◎
Fallback for fallback entries: If response was not fetched from an application cache, and was to be fetched using `GET`, and its URL matches the fallback namespace of one or more relevant application caches, and the most appropriate application cache of those that match does not have an entry in its online safelist that has the same origin as response's URL and that is a prefix match for response's URL, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the fallback response specified for the fallback namespace in question. If multiple application caches match, the user agent must use the fallback of the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The document's URL, if appropriate, will still be the originally requested URL, not the fallback URL, but the user agent may indicate to the user that the original page load failed, that the page used was a fallback response, and what the URL of the fallback response actually is.
• Run process a navigate response given request, response, navigationType, the source browsing context, browsingContext, and reservedEnvironment.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~navigate応答を処理する@
ときは、所与の
( `要請$または ~NULL %要請, `応答$ %応答, 文字列 %~navi種別, `閲覧文脈$ `S$V, `閲覧文脈$ %B, `環境$ %予約-済み環境 （省略時は ε ）)
に対し，次を走らす：
◎
To process a navigate response, given null or a request request, a response response, a string navigationType, two browsing contexts source and browsingContext, and an optional environment reservedEnvironment, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If any of the following are true, then display the inline content with an appropriate error shown to the user, with the newly created Document object's origin set to a new opaque origin, run the environment discarding steps for reservedEnvironment, and return.
</p>
		<ul>
			<li>
%応答 は`~network~error$である
◎
response is a network error.
</li>
			<li class="XXX">
TODO：
ここで `X-Frame-Options^h の処理を定義する（
<a href="~HTMLissue/1230">issue #1230</a>
にて追跡されている）。
◎
TODO: Define X-Frame-Options processing here (tracked as issue #1230).
</li>
			<li>
`~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？$
( %要請, %~navi種別, %応答, `S$V, %B ) `CSP$r
の結果 ~EQ `阻止d^i
◎
The Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, response, navigationType, source, and browsingContext. [CSP]
</li>
			</ul>
<div>
<p>
…ならば：
</p>

<ol ><li>適切な~errorを利用者に示すような，`~inline内容を表示する$
</li><li>前段により作成された`文書$の`生成元$ ~SET 新たな`不透明な生成元$
</li><li>%予約-済み環境 用に`環境を破棄する手続き$を走らす
</li><li>~RET
</li></ol>
◎
↑</div>

<p class="note">注記：
`Fetch^cite `FETCH$r
により定義される~network~error
— ~DNSや~TLS ~errorなど —
が伝播される所は，ここであり、利用者に表示されることになる。
◎
This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to users. [FETCH]
</p>
	</li>
	<li>
~IF［
%応答 の`状態s$rs ~IN { `204$hst, `205$hst }
］
⇒
~RET
◎
If response's status is 204 or 205, then return.
</li>
	<li>
<p>
~IF［
%応答 内に `Content-Disposition$h ~headerがあって，それは
`attachment^c ~disposition型を指定している
］：
</p>
<ol ><li>%応答 を`~downloadとして$取扱う
</li><li>~RET
</li></ol>
◎
If response has an `Content-Disposition` header specifying the attachment disposition type, then handle it as a download and return.
</li>
	<li id="_computed-mime-type">
%~MIME型 ~LET %応答 から`算出される~MIME型$
◎
Let type be the computed type of response.
</li>
	<li>
<p>
~IF［
~UAは［
%~MIME型 の資源に対しては［
`閲覧文脈$内に内容を具現化する以外の何らかの仕組み
］を利用して処理する
］ように環境設定されている
］：
</p>

<ol><li>%応答 が表現している %~MIME型 の資源を`非~文書~内容として取扱う$
</li><li>~RET
</li></ol>
◎
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:
</li>
	<li>
<p>
%~MIME型 に応じて：
◎
↑</p>

		<dl class="switch">
			<dt>
`~HTML~MIME型$
◎
an HTML MIME type
</dt>
			<dd>
<a href="#read-html">~HTML文書~節</a>
に与える手続きに従う
◎
Follow the steps given in the HTML document section, and then, once they have completed, return.
</dd>
			<dt>
`~XML~MIME型$であって, `明示的に~supportされる~XML~MIME型$でない
◎
an XML MIME type that is not an explicitly supported XML MIME type
</dt>
			<dd>
<a href="#read-xml">~XML文書~節</a>
に与える手続きに従う
◎
Follow the steps given in the XML document section, and then, once they have completed, return.
</dd>
			<dt>
`~JS~MIME型$
◎
a JavaScript MIME type
</dt>
			<dt>
`~JSON~MIME型$であって, `明示的に~supportされる~JSON~MIME型$でない
◎
a JSON MIME type that is not an explicitly supported JSON MIME type
</dt>
			<dt>`text/cache-manifest$c</dt>
			<dt>`text/css$c</dt>
			<dt>`text/plain$c</dt>
			<dt>`text/vtt$c</dt>
			<dd>
<a href="#read-text">素の~text~file節</a>
に与える手続きに従う
◎
Follow the steps given in the plain text file section, and then, once they have completed, return..
</dd>
			<dt>`multipart/x-mixed-replace$c</dt>
			<dd>
<a href="#read-multipart-x-mixed-replace">`multipart/x-mixed-replace^c 節</a>
に与える手続きに従う
◎
Follow the steps given in the multipart/x-mixed-replace section, and then, once they have completed, return.
</dd>
			<dt>
~supportされる［
画像 ／ 動画 ／ 音声
］型
◎
A supported image, video, or audio type
</dt>
			<dd>
<a href="#read-media">媒体~節</a>
に与える手続きに従う
◎
Follow the steps given in the media section, and then, once they have completed, return.
</dd>
			<dt>
内容を %B 内に具現化するときに外部~appを利用するような型
◎
A type that will use an external application to render the content in browsingContext
</dt>
			<dd>
<a href="#read-plugin">~plugin節</a>
に与える手続きに従う
◎
Follow the steps given in the plugin section, and then, once they have completed, return.
</dd>
			<dt>その他</dt>
			<dd>
%応答 が表現している %~MIME型 の資源を`非~文書~内容として取扱う$
◎
↓</dd>
		</dl>
<p>
上の~~目的においては：
◎
↓</p>
		<ul>
			<li>
<p>
次に該当する`~XML~MIME型$は、
`明示的に~supportされる~XML~MIME型@
とされる：
◎
An explicitly supported XML MIME type is an XML MIME type＼
</p>

				<ul>
					<li>
~UAが内容を具現化するときに，外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような`~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの（例： 組込みの Atom ~feed-viewerを備える~Web~browserは `application/atom+xml$c ~MIME型を明示的に~supportするとされる）
◎
one for which the user agent has dedicated processing rules (e.g. a Web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type), or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
			<li>
<p>
次に該当する`~JSON~MIME型$は、
`明示的に~supportされる~JSON~MIME型@
とされる：
◎
An explicitly supported JSON MIME type is a JSON MIME type＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような `~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの
◎
one for which the user agent has dedicated processing rules, or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
前~段が完了するまで待機する
◎
↑</li>
</ol>
</div>

<div class="algorithm">
<p>
~naviにおいて所与の %~MIME型 の %資源 を
`非~文書~内容として取扱う@
ときは：
◎
Non-document content:＼
</p>
<ol>
	<li>
<p>
~IF［
~UAは、 %~MIME型 の資源を何らかの~inline内容として表示する
］
⇒
%資源 による`~inline内容を表示する$
◎
If, given type, the new resource is to be handled by displaying some sort of inline content,＼
</p>

<div class="example">
<p>
例えば、次に該当するとき：
</p>

<ul ><li>~UAは、 %資源 の内容を~nativeに具現化する
</li><li>%~MIME型 は~supportされないことを示す~error~message
</li></ul>
◎
e.g., a native rendering of the content or an error message because the specified type is not supported, then display the inline content, and then return.
</div>
	</li>
	<li>
<p>
~ELSE（ %~MIME型 の資源は 当の`閲覧文脈$に影響しない ）
⇒
%資源 を
<a href="#hand-off-to-external-software">適切に処理する</a>
</p>

<div class="example">
<p>
例えば、次に該当するとき：
</p>

<ul ><li>%資源 を外部~appに手渡す
</li><li>%資源 は未知な型であり，`~downloadとして$処理する
</li></ul>
</div>

◎
Otherwise, the document's type is such that the resource will not affect browsingContext, e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed as a download. Process the resource appropriately.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`~navigate~URL~schemeを処理する@
ときは、所与の
( `~URL$ %~url, `閲覧文脈$ %B )
に対し，次を走らす：
◎
To process a navigate URL scheme, given a URL url and browsing context browsingContext, run these steps:
</p>

<ol>
	<li>
~IF［
%~url は、 %B に影響しない仕組みを用いて取扱われるものである（ %~url の`~scheme$urlは外部的に取扱われるものである）
］
⇒
~RET
— 代わりに，<a href="#hand-off-to-external-software">その仕組みを続行する</a>
◎
If url is to be handled using a mechanism that does not affect browsingContext, e.g., because url's scheme is handled externally, then proceed with that mechanism instead.
</li>
	<li>
<p>
~ELIF［
%~url は、何らかの~inline内容を表示して取扱われるものである
］
⇒
その`~inline内容を表示する$
— 例えば：
</p>

<ul ><li>指定された~schemeは~supportされる~protocolでないことを示す~error~message, あるいは
</li><li>利用者が 所与の~scheme用の`登録-済み~handler$を選定できるようにするための~inline~prompt
</li></ul>

<p class="note">注記：
登録-済み~handlerが利用されている事例では、`~navigate$は，新たな~URLで再び呼出されることになる。
</p>

◎
Otherwise, url is to be handled by displaying some sort of inline content, e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme. Display the inline content.
◎
In the case of a registered handler being used, navigate will be invoked with a new URL.
</li>
</ol>
</div>

<p>
~UAは、資源の［
~URL／~data
］を
<dfn id="hand-off-to-external-software">外部~software~packageに取扱わせる</dfn>
ときは（例： `mailto_$sc ~URLを~mail~clientに手渡す ／ Word 文書をそれ用の処理器に手渡すなど）：
◎
When a resource is handled by passing its URL or data to an external software package separate from the user agent (e.g. handing a mailto: URL to a mail client, or a Word document to a word processor),＼
</p>

<ul>
	<li>
対象の~softwareを悪用しようと試みる~riskを軽減するよう試みるべきである。
例えば［
`~source閲覧文脈$にて`作動中の文書$の`生成元$には、指定された~softwareを呼出すことは許容される
］かどうか，利用者に確認するよう~promptするなどにより。
◎
user agents should attempt to mitigate the risk that this is an attempt to exploit the target software, e.g. by prompting the user to confirm that the source browsing context's active document's origin is to be allowed to invoke the specified software.＼
</li>
	<li>
特に，`~navigate$~algoが`利用者による作動化により誘発され$たものではない場合、~UAは
— 前もって利用者に確認をとることなく —
外部~software~packageを呼出すべきでない。
◎
In particular, if the navigate algorithm, when it was invoked, was not triggered by user activation, the user agent should not invoke the external software package without prior user confirmation.
</li>
</ul>

<p class="example">
例えば，~target~softwareの~URL~handler内には、［
ある敵対的~pageが，~linkを~clickするよう利用者を騙す
］ように悪用できる脆弱性があるかもしれない。
◎
For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
</p>

<div class="algorithm">
<p>
`~javascript~URL要請を実行する@
ときは、所与の
( `要請$ %要請, `S$V, %B )
に対し，次を走らす：
◎
To execute a javascript: URL request, given a request request, and two browsing contexts source and browsingContext, run these steps:
</p>

<ol id="concept-js-deref">
	<li>
%応答 ~LET 次のようにされた新たな`応答$
⇒
`状態s$rs ~SET `204$hst
◎
Let response be a response whose status is 204.
</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次の両者とも満たされる
］…：
◎
If both of the following are true:
</p>
		<ul>
			<li>
<p>
( `S$V にて`作動中の文書$の`生成元$, %文書 の`生成元$ )
は`同一-生成元$である
◎
source's active document's origin is same origin with browsingContext's active document's origin.
</p>

<p class="XXX">
<a href="~HTMLissue/2591">issue #2591</a>
にて説明されるように、この段は働かないため，~security上の課題がある。
◎
As explained in issue #2591 this step does not work and presents a security issue.
</p>
			</li>
			<li>
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, `other^l, `S$V, %B )
の結果 ~EQ `許容ed^i
`CSP$r
◎
The Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Allowed" when executed upon request, "other", source, and browsingContext. [CSP]
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%~script~source ~LET `~URLを直列化する$( %要請 の`~URL$rq )
◎
Let urlString be the result of running the URL serializer on request's url.
</li>
			<li>
%~script~source ~SET %~script~source から先頭の `javascript:^l を除去した結果
◎
Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.
</li>
			<li>
%~script~source ~SET `文字列を~byte列に~percent-復号する$( %~script~source )
◎
Let scriptSource be the UTF-8 decoding of the string percent decoding of encodedScriptSource.
</li>
			<li>
%~script~source ~SET `~UTF-8復号する$( %~script~source )
◎
↑</li>
			<li>
%文書 の`~URL$doc を %要請 の`~URL~list$rqに付加する
◎
Append the browsingContext's active document's URL URL list.
</li>
			<li>
%設定群 ~LET %文書 に`関連な設定群~obj$
◎
Let settings be browsingContext's active document's relevant settings object.
</li>
			<li>
%~script ~LET
`古典~scriptを作成する$( 次に与える引数たち )
⇒＃
%~script~source,
%設定群,
%設定群 の`~API用~基底~URL$enV,
`既定の古典~script~fetch~options$
◎
Let baseURL be settings's API base URL.
◎
Let script be the result of creating a classic script given scriptSource, settings, baseURL, and the default classic script fetch options.
</li>
			<li>
%評価~状態s ~LET `古典~scriptを走らす$( %~script )
◎
Let evaluationStatus be the result of running the classic script script.
</li>
			<li>
%結果 ~LET ［
次が満たされるならば `undefined^jv ／
~ELSE_ %評価~状態s . `Value^sl
］
⇒
［
%評価~状態s は`中途完了$である
］~OR［
%評価~状態s . `Value^sl ~EQ `empty^jv
］
◎
Let result be undefined if evaluationStatus is an abrupt completion or evaluationStatus.[[Value]] is empty, or evaluationStatus.[[Value]] otherwise.
</li>
			<li>
<div class="p">
<p>
~IF［
`Type$jA( %結果 ) ~EQ `String^jT
］：
</p>
				<ol>
					<li>
%応答 ~SET 次のようにされた新たな`応答$
⇒＃
`本体$rs ~SET %結果†,
`~HTTPS状態$rs ~SET %設定群 の`~HTTPS状態$enV,
</li>
					<li>
%応答 の`~header~list$rs ~SET 次の~headerからなる`~header~list$
⇒＃
( `Content-Type^h / `text/html$bl ),
( `Referrer-Policy$h / %設定群 の`~referrer施策$enV )
</li>
				</ol>
◎
If Type(result) is String, then set response to a response whose header list consists of `Content-Type`/`text/html` and `Referrer-Policy`/settings's referrer policy, whose body is result, and whose HTTPS state is settings's HTTPS state.
</div>

<p class="warning">†
~JS文字列 %結果 と応答の`本体$rsを成す~byte列との間の正確な変換は、まだ指定されていない。
~UAの挙動が更に究明されるのが待たれる。
<a href="~HTMLissue/1129">issue #1129</a>
を見よ。
◎
The exact conversion between the JavaScript string result and the bytes that comprise a response body is not yet specified, pending further investigation into user agent behavior. See issue #1129.
</p>
		</ol>
	</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

<p class="XXX">
上にて~linkした特定の課題に加えて、
`issue tracker^en には， `javascript_$sc ~URLの仕様について様々な問題を文書化している
`<a href="https://github.com/whatwg/html/labels/topic%3A%20javascript%3A%20URLs">専用の~label</a>^
］がある。
◎
In addition to the specific issues linked above, javascript: URLs have a dedicated label on the issue tracker documenting various problems with their specification.
</p>
</div>

<hr>

<div class="algorithm">
<p>
以下の一部の節は、ある種の事例で上の~algoから呼出され，次に与える
`文書を初期化する@
手続きを利用する。
それは、所与の
（ `文書$ %文書, ~NULL または`要請$ %要請, `応答$ %応答, `閲覧文脈$ %B, `環境$ %予約-済み環境 （省略時は ε ） )
に対し，次を走らす：
◎
Some of the sections below, to which the above algorithm defers in certain cases, use the following steps to initialize the Document object, given a Document object document, null or a request request, a response response, a browsing context browsingContext, and an optional environment reservedEnvironment:
</p>

<p class="XXX">
それらの各~節は、まだ，この~algoを適切な引数を渡して明示的に~callしておらず、代わりに名前でしか参照していない。
これは修正したい所だが、今の所は，それらを呼出している`~navigate応答を処理する$における引数がここに渡されるべきであると解されたし。
◎
The sections below do not yet explicitly call this algorithm, passing along the appropriate arguments. Instead, they just reference it by name. We hope to fix this, but in the meantime, understand that the arguments should be threaded through from process a navigate response to here.
</p>

<ol>
	<li>
<p>
~IF［
次のすべてが満たされる
］…：
</p>

<ul ><li>%B の`~session履歴$は、 %B の`作成-$時に追加された `about_blank$sc `文書$ %D のみからなる
</li><li>%置換~可能化~flag ~EQ `置換を可能化する$i
</li><li>( %D の生成元, %文書 の生成元 ) は`同一-生成元$である
</li></ul>

<p>
…ならば
⇒
何もしない
</p>

◎
If browsingContext's only entry in its session history is the about:blank Document that was added when browsingContext was created, and navigation is occurring with replacement enabled, and that Document has the same origin as document, then do nothing.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で，`新たな~JS~realmを作成する$
⇒＃
大域~obj用に 新たな `Window$I ~objを作成する,
大域 `this^jv 束縛には %B の `WindowProxy$I ~objを利用する
◎
Let realm execution context be the result of creating a new JavaScript realm with the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
			<li>
`~window用に環境~設定群~objを設定しておく$( %~realm実行~文脈, %予約-済み環境 )
◎
Set up a window environment settings object with realm execution context and reservedEnvironment, if present.
</li>
		</ol>
	</li>
	<li id="set-the-document's-address">
%文書 の`~URL$doc ~SET ［
%要請 ~NEQ ~NULL ならば %要請 の`現在の~URL$rq ／
~ELSE_ %応答 の`~URL$rs
］
◎
If request is non-null, then set document's URL to request's current URL.
◎
Otherwise, set document's URL to response's URL.
</li>
	<li>
%文書 の`~HTTPS状態$doc ~SET %応答 の`~HTTPS状態$rs
◎
Set document's HTTPS state to the HTTPS state of response.
</li>
	<li>
%文書 の`~referrer施策$doc ~SET %応答 の
<a href="~REFERRER-POLICY#parse-referrer-policy-from-header">`Referrer-Policy^h ~headerを構文解析-</a>した結果
`REFERRERPOLICY$r
◎
Set document's referrer policy to the result of parsing the `Referrer-Policy` header of response. [REFERRERPOLICY]
</li>
	<li>
`文書の~CSP~listを初期化する$( %文書, %応答, %要請 )
`CSP$r
◎
Initialize a Document's CSP list given document, response, and request. [CSP]
</li>
	<li>
<p>
~IF［
%要請 ~NEQ ~NULL
］
⇒
%文書 の`~referrer$doc ~SET
%要請 の`~referrer$rq %~referrer は`~URL~record$であるならば
`~URLを直列化する$( %~referrer ) ／
~ELSE_ 空~文字列
◎
If request is non-null, then set document's referrer to the serialization of request's referrer, if request's referrer is a URL record, and the empty string otherwise.
</p>

<p class="note">注記：
`FETCH$r により、`要請$の`~referrer$rq は，この時点で［
`~URL~record$ または `no-referrer^l
］になる。
◎
Per Fetch a request's referrer will be either a URL record or "no-referrer" at this point.
</p>
	</li>
	<li>
`文書~用に~sandbox法を実装する$( %文書, %B )
◎
Implement the sandboxing for document.
</li>
	<li>
<p>
`応答からの特能~施策で文書のそれを初期化する$( %応答, %文書 )
`FEATUREPOLICY$r
◎
Initialize a document's feature policy from a response given document and response. [FEATUREPOLICY]
</p>

<div class="note">

<p>注記：
`応答からの特能~施策で文書のそれを初期化する$ ~algoは、 %文書 の`生成元$を用立てる。
`閲覧文脈~容器$の`~node文書$に対し `document.domain$m が利用されていた場合、その`生成元$は
【入子にされている】 %文書 の`生成元$と`同じ生成元~domain$にはなり得ない
— この手続きが走るのは， %文書 が初期化されるときであり、この時点では まだ %文書 の `document.domain$m は利用され得ないので。
したがって，特能~施策の検査は、`同一-生成元$かどうか検査するよりも，~~寛容でない。
◎
The initialize a document's feature policy from a response algorithm makes use of document's origin. If document.domain has been used for the browsing context container's node document, then its origin cannot be same origin-domain with document's origin, because these steps run when document is initialized, so it cannot itself yet have used document.domain. Note that this means that Feature Policy checks are less permissive compared to doing a same origin check instead.
</p>

<p>
これの動作~例は、下を見よ。
◎
See below for some examples of this in action.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%応答 には `Refresh$h ~headerはある
］：
◎
If response has a `Refresh` header, then:
</p>

		<ol>
			<li>
%値 ~LET `同型に復号する$( `Refresh^h の値 )
◎
Let value be the isomorphic decoding of the value of the header.
</li>
			<li>
`共用~宣言的~refresh手続き$( %文書, %値 )
を走らす
◎
Run the shared declarative refresh steps with document and value.
</li>
		</ol>

<p class="XXX">
`Refresh$h ~headerが複数あるときの取扱いは、現時点では，まだ指定していない。
これは
<a href="~HTMLissue/2900">issue #2900</a>
にて追跡されている。
◎
We do not currently have a spec for how to handle multiple `Refresh` headers. This is tracked as issue #2900.
</p>

	</li>
</ol>
</div>

<div class="example">
<p>
次の例では、子~文書には `PaymentRequest$I の利用は許容されない
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$であっても。
子~文書が初期化された時点では、 `document.domain$m は 親~文書にのみ設定されていて，子~文書にはまだ設定されてない。
◎
In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.
</p>

<pre class="html-code">
&lt;!-- https://foo.example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
</pre>

<pre class="html-code">
&lt;!-- https://bar.example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com'; /* <span class="comment">
これは、文書が初期化された後に起こる。
◎
This happens after the document is initialized
</span> */
 new PaymentRequest(…); /* <span class="comment">
利用は許容されない
◎
Not allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="example">

<p>
次の例では、子~文書には `PaymentRequest$I の利用は<em>許容される</em>
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$でなくとも。
子~文書が初期化される時点では，どちらの文書にも まだ `document.domain$m は設定されていないので、`同じ生成元~domain$の検査は，通常の`同一-生成元$の検査に~fall-backする。
◎
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.
</p>

<pre class="html-code">
&lt;!-- https://example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
子~文書は、下の~scriptが走る前の，この時点では初期化されている。
◎
The child document is now initialized, before the script below is run.
</span> --&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
</pre>

<pre class="html-code">
&lt;!-- https://example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 new PaymentRequest(…); /* <span class="comment">
利用は許容される
◎
Allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="algorithm">
<div class="p">
<p>
下の各~節の一部にて，~UAが
`新たな~pageで~session履歴を更新する@
よう要求されたときは、`~network用~task源$から次を走らす`~taskを~queueする$モノトスル
— その~taskを（新たな~entryではなく）`現在の~entry$の`文書$に結付けた上で：
</p>

<p>
【この手続きには、次に挙げる暗黙の入力がある：】
</p>

<ul ><li>%~navi （この~algoを呼出した`~navi$~algoの~instance）
</li><li>%B （ %~navi により~navigateされている`閲覧文脈$）
</li><li>%履歴 （ %B の`~session履歴$）
</li><li>%更新する~entry （%~navi は %履歴 内のある
`~entryを更新する@
ために起動されたならば，その~entry ／
~ELSE_ ε
）
</li><li>%資源~URL （ %~navi に渡された %資源 は`~URL$であるならば それ ／ ~ELSE_ ε）
</li><li>%資源 （ %~navi による~navigate先の資源）
</li><li>%文書 （ %資源 を表現している新たな`文書$）
</li><li>%置換~可能化~flag （ %~navi に渡されたそれ）
</li></ul>

◎
Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page. When a user agent is required to do this, it must queue a task on the networking task source, associated with the Document object of the current entry (not the new one), to run the following steps:
</div>

<ol>
	<li>
`文書を~unloadする$( %履歴 の`現在の~entry$の`文書$ )
◎
Unload the Document object of the current entry.
</li>
	<li>
~IF［
前~段の~unloadを走らせている間に %~navi は取消された
］
⇒
~RET
⇒
~unloadは走らせ終えるモノトスルが、
%~navi は，この段を超えて走らせないモノトスル。
（特に，ここで %~navi が取消されても、一例として，文書や その子孫を~unloadする一部として生じている ~event配送-や~script実行は，中止されない。）
◎
If this instance of the navigation algorithm is canceled while this step is running the unload a document algorithm, then the unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)
</li>
	<li>
<p>
~IF［
%更新する~entry ~NEQ ε
］：
◎
If the navigation was initiated for entry update of an entry
</p>
		<ol>
			<li>
%履歴 内の
~EACH( %~entry )
に対し
⇒
~IF［
%~entry の`文書$ ~EQ %更新する~entry の`文書$
］
⇒
%~entry の`文書$ ~SET %文書
◎
Replace the Document of the entry being updated, and any other entries that referenced the same document as that entry, with the new Document.
</li>
			<li>
`履歴を走査する$( %更新する~entry )
◎
Traverse the history to the new entry.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
<p>
%新~entry ~LET %資源 とその文書を表現する，次のものからなる新たな`~session履歴~entry$：
</p>

<ul ><li>`文書$ ~SET %文書
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `auto$l
</li><li>`~URL$ ~SET %文書 の`~URL$doc 【この項目は、この訳による推定（~URLは必須なので）。】
</li></ul>

◎
↓</li>
			<li>
<p>
~IF［
%資源~URL ~NEQ ε
］~AND［
%資源~URL ~EQ %B にて`作動中の文書$の`~URL$doc
］：
◎
If the navigation was initiated with a URL that equals the browsing context's active document's URL
</p>
				<ol>
					<li>
%履歴 の`現在の~entry$を %新~entry に置換する
◎
Replace the current entry with a new entry representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
`履歴を走査する$( %新~entry )
◎
Traverse the history to the new entry.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise
</p>
				<ol>
					<li>
<p>
%履歴 内の`現在の~entry$より後の~entryは すべて除去する
◎
Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
					</li>
					<li>
%文書 の `History$I ~objの末尾に %新~entry を付加する
◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
`履歴を走査する$( %新~entry, %置換~可能化~flag )
◎
Traverse the history to the new entry. If the navigation was initiated with replacement enabled, then the traversal must itself be initiated with replacement enabled.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
この時点で、 %~navi は
`成熟-@
したとされる。
◎
The navigation algorithm has now matured.
</li>
	<li>
`素片へ~scrollしようと試行する$( %文書 )
◎
Try to scroll to the fragment for the Document.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`素片へ~scrollしようと試行する@
ときは、所与の
( `文書$ %文書 )
に対し，次の手続きを`並列的$に遂行する：
◎
To try to scroll to the fragment for a Document document, perform the following steps in parallel:
</p>

<ol>
	<li>
実装が定義する時間長だけ待機する
（この段は、~UAが処理能の懸念に面したとき，利用者~体験を最適化できるようにするためにある。）
◎
Wait for an implementation-defined amount of time. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)
</li>
	<li>
<p>
`~network用~task源$から次を走らす`~taskを~queueする$：
◎
Queue a task on the networking task source to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%文書 用の構文解析器は無い
</li><li>%文書 用の構文解析器は`構文解析を停止した$
</li><li>~UAには、［
利用者が`素片$urlへ~scrollすることに関心を失った
］と予見する理由がある
</li></ul>

<p>
…ならば
⇒
~RET
</p>

◎
If document has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then abort these steps.
</li>
			<li>
%文書 の`~URL$doc内に与えられる`素片へ~scrollする$
◎
Scroll to the fragment given in document's URL.＼
</li>
			<li>
~IF［
前~段の結果 %文書 内の`指示された部位$docを見出せなかった
］
⇒
`素片へ~scrollしようと試行する$( %文書 )
◎
If this does not find an indicated part of the document, then try to scroll to the fragment for document.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="read-html">
<h3 title="Page load processing model for HTML files">7.8.2. ~HTML~file用の~page読込n処理~model</h3>

<div class="algorithm">
<p>
~HTML文書を `閲覧文脈$内に読込むことになるときは、~UAは 次を走らす`~taskを~queueする$モノトスル：
◎
When an HTML document is to be loaded in a browsing context, the user agent must queue a task to＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `text/html^l
◎
set its content type to "text/html",＼
</li>
	<li>
`文書を初期化する$( %文書, … )
◎
initialize the Document object, and finally＼
</li>
	<li>
%解析器 ~LET 新たな`~HTML構文解析器$
◎
create an HTML parser and＼
</li>
	<li>
%解析器 を %文書 に結付ける
◎
associate it with the Document.＼
</li>
</ol>
</div>

<p>
~fetchingを走らせている間に`~network用~task源$から
`~task~queue$に入れられる各`~task$は、~fetchされた~byte列で
%解析器 への`入力~byte~stream$を埋めた上で，
%解析器 に入力~streamの適切な処理を遂行させるモノトスル。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</p>

<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理-の一部は、資源の~~真の `~Content-Type~metadata$ から見出される文字~符号化法~情報に依拠する
— `資源から算出された~MIME型$V は、その目的には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>

<p>
可用な~byte列が尽きたときは、~UAは， %解析器 が暗黙の~EOF文字を処理する`~taskを~queueする$モノトスル
— それは、最終的に `load$et ~eventを発火させることになる。
◎
When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</p>

<p>
~UAは、`文書$が作成された後, かつ ~scriptが実行される前の, ほぼ間違いなく %解析器 が`停止-$する前に，`新たな~pageで~session履歴を更新する$モノトスル。
◎
After creating the Document object, but before any script execution, certainly before the parser stops, the user agent must update the session history with the new page.
</p>

<p class="note">注記：
【`~app~cache用$の注記】
◎
Application cache selection happens in the HTML parser.
</p>

<p>
この節にて言及した各~taskの`~task源$は、`~network用~task源$にするモノトスル。
◎
The task source for the two tasks mentioned in this section must be the networking task source.
</p>

			</section>
			<section id="read-xml">
<h3 title="Page load processing model for XML files">7.8.3. ~XML~file用の~page読込n処理~model</h3>

<p>
~XML~fileを~inlineに表示することになった場合、~UAは，次に挙げる各種 仕様に定義される要件に従うモノトスル
⇒＃
`XML^cite `XML$r,
`Namespaces in XML^cite `XMLNS$r,
`XML Media Types^cite `RFC7303$r,
`DOM^cite `DOM$r,
関連な他の`文書$を作成するための仕様と対応する`~XML構文解析器$
◎
When faced with displaying an XML file inline, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications to create a Document object and a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</p>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p> 

<p>
~UAは、`文書$ %文書 を作成したときは：
◎
↓</p>

<ul>
	<li>
次を走らすモノトスル
⇒
`文書を初期化する$( %文書, … )
◎
After the Document is created, the user agent must initialize the Document object.
</li>
	<li>
上に挙げた各 仕様の規則に則って，文字~符号化法を決定するときには、実際の~HTTP~headerや他の~metadataのうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものを利用した上で、
%文書 の`文字~符号化法$docは，そのように確立された符号化法に設定するモノトスル。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
【`~app~cache用$の処理~要件】
◎
If the document element, as parsed according to XML cited above, is found to be an html element with an attribute manifest whose value is not the empty string, then, as soon as the element is inserted into the document, the user agent must parse the value of that attribute relative to that element's node document, and if that is successful, must apply the URL serializer algorithm to the resulting URL record with the exclude fragment flag set to obtain manifest URL, and then run the application cache selection algorithm with manifest URL as the manifest URL, passing in the newly-created Document. Otherwise, if the attribute is absent, its value is the empty string, or parsing its value fails, then as soon as the document element is inserted into the document, the user agent must run the application cache selection algorithm with no manifest, and passing in the Document.
◎
Because the processing of the manifest attribute happens only once the document element is parsed, any URLs referenced by processing instructions before the document element (such as &lt;?xml-stylesheet?&gt; PIs) will be fetched from the network and cannot be cached.
</li>
	<li>
<p>
%文書 を伴う`新たな~pageで~session履歴を更新する$モノトスル
— その時機は：
</p>

<ul ><li>文書が完全に構文解析される前でもヨイ（したがって `増分的に具現化する^i ことになる）。
</li><li>どの~script実行よりも前にするモノトスル。
</li></ul>

◎
Then, with the newly created Document, the user agent must update the session history with the new page. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.
</li>
	<li>
構文解析-時の~error（例えば ~XML名前空間 整形式性~error）に際しては、
%文書 を変異して~inlineに報告してもヨイ。
◎
Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the Document.
</li>
</ul>

			</section>
			<section id="read-text">
<h3 title="Page load processing model for text files">7.8.4. ~text~file用の~page読込n処理~model</h3>

<div class="algorithm">
<p>
素の~text文書を `閲覧文脈$内に読込むことになるときは、~UAは，次を走らす`~taskを~queueする$モノトスル：
◎
When a plain text document is to be loaded in a browsing context, the user agent must queue a task to＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
◎
set its content type to the computed MIME type of the resource (type in the navigate algorithm),＼
</li>
	<li>
`文書を初期化する$( %文書, … )
◎
initialize the Document object,＼
</li>
	<li>
%構文解析器 ~SET 新たな`~HTML構文解析器$
◎
create an HTML parser,＼
</li>
	<li>
%構文解析器 を %文書 に結付ける
◎
associate it with the Document,＼
</li>
	<li>
%構文解析器 は、その~tokenizerが すでに次を順に行ったかのようにしておく
⇒＃
~tag名 `pre^l の開始tag~tokenを発した；
1 個の文字 U+000A （LF）を発した；
`~PLAINTEXT状態$に切替えた
◎
act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state.＼
</li>
</ol>
</div>

<p>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に入れられる各`~task$は、
%構文解析器 の`入力~byte~stream$を~fetchされた~byte列で埋めて，
%構文解析器 に入力~streamの適切な処理を遂行させるモノトスル。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</p>

<p>
素の~text文書である %資源 に対しては、次に挙げる要件が~UAに課される：
◎
↓</p>

<ul>
	<li>
%資源 の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、 `資源から算出された~MIME型$V の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (type in the navigate algorithm).
</li>
	<li>
%資源 の`文字~符号化法$docは、 %資源 の復号-時に利用された文字~符号化法に設定するモノトスル。
◎
The document's character encoding must be set to the character encoding used to decode the document.
</li>
	<li>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</li>
	<li>
可用な~byte列が尽きたときは、
構文解析器が暗黙の~EOF文字を処理する`~taskを~queueする$モノトスル
— それは、最終的に
`load$et ~eventを発火させることになる。
◎
When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
<p>
%資源 から`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，`新たな~pageで~session履歴を更新する$モノトスル。
◎
After creating the Document object, but potentially before the page has finished parsing, the user agent must update the session history with the new page.
</p>

<p class="trans-note">【
“`なければその前に@”
— 原文の “`, but potentially before^en” の意図が［
要件の一部 ／
可能性があることを示す単なる説明 ／
終える前にそうしてよいことの明示的な許可
］のどれなのか はっきりしないが、同じ要件~文の一部として `but^en 節の中に記されているので，要件と解釈する下で和訳している。
】</p>
	</li>
	<li>
<p>
%文書 の `head$e 要素に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
~scriptを供する,
%文書 に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、 RFC 3676 の `Format=Flowed^c 特能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
</ul>

<p>
この節に言及した 2 つの~taskの`~task源$は、`~network用~task源$にするモノトスル。
◎
The task source for the two tasks mentioned in this section must be the networking task source.
</p>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h3 title="Page load processing model for multipart/x-mixed-replace resources">7.8.5. `multipart/x-mixed-replace^c 資源~用の~page読込n処理~model</h3>

<p>
型 `multipart/x-mixed-replace$c を伴う資源を `閲覧文脈$内に読込むことになるときは、~UAは，次に従うモノトスル：
◎
When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must＼
</p>

<ul>
	<li>
`RFC2046$r による `multipart^c 型~用の規則を利用して資源を構文解析する。
◎
parse the resource using the rules for multipart types. [RFC2046]
</li>
	<li>
資源から得られる
~EACH( %本体~部位 )
に対し，出現順に 次を走らす
⇒
次を除いて、この節を呼出した`~navi$と同じものを与える下で，`~navigate応答を処理する$
⇒
%応答 の本体には %本体~部位 を利用する。
また、これまでの~~反復で，`文書$が作成され`初期化-$docされていた場合は、
`置換を可能化する$i
◎
For each body part obtained from the resource, the user agent must run process a navigate response using the new body part and the same browsing context, with replacement enabled if a previous body part from the same resource resulted in a Document object being created and initialized, and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.
</li>
	<li>
前項による，［
各 本体~部位を，完全に自立的な資源であったかのように処理する目的
］においては、各 本体~部位に対し［
それに後続する境界に達した所で，当の資源~用の~byte列は尽きた
］かのように動作する。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</li>
</ul>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、各~本体~部位が読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>

			</section>
			<section id="read-media">
<h3 title="Page load processing model for media">7.8.6. 媒体~用の~page読込n処理~model</h3>

<div class="algorithm">
<p>
［
画像 ／ 動画 ／ 音声
］資源を `閲覧文脈$内に読込むことになるときは、~UAは 次をするべきである：
◎
When an image, video, or audio resource is to be loaded in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
◎
set its content type to the computed MIME type of the resource (type in the navigate algorithm),＼
</li>
	<li>
`文書を初期化する$( %文書, … )
◎
initialize the Document object,＼
</li>
	<li>
%文書 に `html$e 要素を付加する
◎
append an html element to the Document,＼
</li>
	<li>
`html$e 要素に `head$e 要素, `body$e 要素を順に付加する
◎
append a head element and a body element to the html element,＼
</li>
	<li>
<p>
`body$e 要素に［
資源の媒体に応じて，次の表の 2 列目に与えられる要素
］を付加する：
</p>

<table><thead><tr><th>媒体~型
<th>要素
<th>属性
</thead>

<tbody><tr><td>画像
<td>`img$e
<td>`~src-img$a

<tr><td>動画
<td>`video$e
<td>`~src-media$a

<tr><td>音声
<td>`audio$e
<td>`~src-media$a

</tbody></table>

◎
append an element host element for the media, as described below, to the body element,＼
</li>
	<li>
前~段で付加した要素の［
対応する，前~段の表の 3 列目の属性
］の値 ~SET 資源の~address
◎
and set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
Type of media | Element for the media | Appropriate attribute
Image | img | src
Video | video | src
Audio | audio | src
</li>
</ol>
</div>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
~pageを構文解析し終えて`なければその前に$，`新たな~pageで~session履歴を更新する$モノトスル。
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.
</p>

<p>
~UAは、`文書$の `head$e 要素に内容を追加してもヨイ ／
%~host要素 に内容~属性を追加してもヨイ
— 例：
~stylesheetへの~link ／
~scriptを供する ／
文書に `title$e を与える ／
媒体を `autoplay$a にする
等々。
◎
User agents may add content to the head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>

			</section>
			<section id="read-plugin">
<h3 title="Page load processing model for content that uses plugins">7.8.7. ~pluginを利用する内容~用の~page読込n処理~model</h3>

<div class="algorithm">
<p>
外部~資源を具現化することを要する資源を，`閲覧文脈$内に読込むことになるときは、~UAは 次をするべきである：
◎
When a resource that requires an external resource to be rendered is to be loaded in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document and＼
</li>
	<li>
%文書 を
`~plugin文書@
とする
◎
mark it as being a plugin document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
◎
set its content type to the computed MIME type of the resource (type in the navigate algorithm),＼
</li>
	<li>
`文書を初期化する$( %文書, … )
◎
initialize the Document object,＼
</li>
	<li>
`文書$に `html$e 要素を付加する
◎
append an html element to the Document,＼
</li>
	<li>
`html$e 要素に `head$e 要素, `body$e 要素を順に付加する
◎
append a head element and a body element to the html element,＼
</li>
	<li>
`body$e 要素に `embed$e 要素を付加する
◎
append an embed to the body element,＼
</li>
	<li>
`embed$e 要素の `~src-embed$a 属性を資源の~addressに設定する
◎
and set the src attribute of the embed element to the address of the resource.
</li>
</ol>
</div>

<p class="note">注記：
用語 `~plugin文書$は、［
`iframe$e を利用しても， `plugin-types^dir 指令をかいくぐることはできない
］ことを確保する仕組みの一部として， `CSP$r により利用される。
◎
The term plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used to evade plugin-types directives. [CSP]
</p>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
~pageを構文解析し終えて`なければその前に$，`新たな~pageで~session履歴を更新する$モノトスル。
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.
</p>

<p>
~UAは［
`文書$の `head$e 要素 ／
`embed$e 要素の属性
］に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, or attributes to the embed element, e.g. to link to a style sheet or to give the document a title.
</p>

<p id="sandboxPluginNavigate" class="note">注記：
［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN `文書$の`作動中の~sandbox法~flag集合$
］の下で［
関連な`~plugin$を`~secure化でき$なかった
］場合には、合成された `embed$e 要素は，
<a href="~HEembed#sandboxPluginEmbed">内容を具現化するのに失敗する</a>ことになる。
◎
If the Document's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized embed element will fail to render the content if the relevant plugin cannot be secured.
</p>

			</section>
			<section id="read-ua-inline">
<h3 title="Page load processing model for inline content that doesn't have a DOM">7.8.8. ~DOMを有さない~inline内容~用の~page読込n処理~model</h3>

<div class="algorithm">
<p>
~UAは、~pageを`閲覧文脈$内に~inlineに表示するときは、次をするべきである：
◎
When the user agent is to display a user agent page inline in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `text/html^l
◎
set its content type to "text/html",＼
</li>
	<li>
`文書を初期化する$( %文書, … )
◎
initialize the Document object,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
and then either＼
</p>
		<ul>
			<li>
%文書 を［
`文書$の通常の具現化~規則を利用して具現化されない
］ような~customな具現化に結付ける
◎
associate that Document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
それが~UAが具現化しようと求める内容を表現する
］ように変異させる。
◎
mutate that Document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
</ol>
</div>

<p>
~UAは、~pageが設定しておかれたなら，`構文解析を停止した$かのように動作するモノトスル。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
~pageを完全に設定して`なければその前に$，`新たな~pageで~session履歴を更新する$モノトスル。
◎
After creating the Document object, but potentially before the page has been completely set up, the user agent must update the session history with the new page.
</p>

			</section>
			<section id="scroll-to-fragid">
<h3 title="Navigating to a fragment">7.8.9. 素片への~navigate法</h3>

<div class="algorithm">
<p>
~UAは，素片へ~navigateすることになったときは、所与の
( `閲覧文脈$ %B, `~URL$ %~URL, %置換~可能化~flag )
に対し，次を走らすモノトスル：
◎
When a user agent is supposed to navigate to a fragment, optionally with replacement enabled, then the user agent must run the following steps:
</p>

<ol>
	<li>
~Assert：
%~URL の`素片$url ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%履歴 ~LET %B の`~session履歴$
◎
↓</li>
	<li>
<p>
~IF［
%置換~可能化~flag ~EQ ε
］
⇒
%履歴 内から， %履歴 の`現在の~entry$より後の~entryはすべて除去する
◎
If not with replacement enabled, then remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
	</li>
	<li>
%B の`~top-level閲覧文脈$の`文書~族$内の
~EACH( `文書$ %D )
に対し
⇒
%D に結付けられている`履歴~走査~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
	<li>
<p>
%~entry ~LET 当の資源とその文書を表現する，次のものからなる新たな`~session履歴~entry$：
</p>

<ul ><li>`文書$ ~SET %B にて`作動中の文書$
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `現在の~entry$のそれ
</li><li>`~URL$ ~SET %~URL
</li></ul>

<p>
%~entry の~titleは未設定のままにする
</p>

◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and current entry's scroll restoration mode. Its URL must be set to the address to which the user agent was navigating. The title must be left unset.
</li>
	<li>
`History$I ~objの末尾に %~entry を付加する
◎
↑</li>
	<li>
<p>
`履歴を走査する$( %~entry, %置換~可能化~flag, `~eventは他を阻まない$i )
◎
Traverse the history to the new entry, with replacement enabled if this was invoked with replacement enabled, and with the non-blocking events flag set.＼
</p>

<p class="note">注記：
これは、今や文書の`~URL$docになった %~URL の`素片へ~scrollする$ことになる。
素片が指す`~ID$を有する要素が まだ構文解析されていないため，~scrollできなかった場合、代わりに，元の`~navi$~algoから呼ばれる［
`新たな~pageで~session履歴を更新する$~algo
］の最後の方で，~scrollingが~careされることになる。
◎
This will scroll to the fragment given in what is now the document's URL.
◎
If the scrolling fails because the relevant ID has not yet been parsed, then the original navigation algorithm will take care of the scrolling instead, as the last few steps of its update the session history with the new page algorithm.
</p>
	</li>
</ol>
</div>

<hr>

<div class="algorithm">
<p>
%文書 の
`素片へ~scrollする@
よう要求されたときは、~UAは，次を行うモノトスル：
◎
When the user agent is required to scroll to the fragment and＼
</p>

<ol>
	<li>
%部位 ~LET %文書 内の`指示された部位$doc
◎
the indicated part of the document,＼
</li>
	<li>
~IF［
%部位 ~EQ ε
］~OR［
%部位 は`具現化されて$いない
］
⇒
~RET
◎
if any, is being rendered,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
the user agent must either＼
</p>
		<ul>
			<li>
下に述べるように，文書の~scroll位置を %部位 に変更する。
◎
change the scrolling position of the document using the following algorithm,＼
</li>
			<li>
%部位 に利用者の注目を引くような他の何らかの動作を遂行する。
◎
or perform some other action such that the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not being rendered, then the user agent must do nothing.＼
</li>
		</ul>
	</li>
</ol>

<!-- 初期時は null なので不要な記述 -->
</div>

<div class="algorithm">
<p>
`文書$ %文書 の~scroll位置を %部位 に変更するときは：
◎
The aforementioned algorithm is as follows:
</p>

<ol>
	<li>
%文書 の`標的~要素$ ~SET ~NULL
◎
If there is no indicated part of the document, set the Document's target element to null.
</li>
	<li>
<p>
%部位 に応じて：
</p>

		<dl class="switch">
			<dt>`文書の上端^i
◎
If the indicated part of the document is the top of the document, then:
</dt>
			<dd>
%文書 の`開始位置へ~scroll$する `CSSOMVIEW$r
◎
Set the Document's target element to null.
◎
Scroll to the beginning of the document for the Document. [CSSOMVIEW]
</dd>

			<dt>要素である
◎
Otherwise:
</dt>
			<dd>
				<ol>
					<li>
%文書 の`標的~要素$ ~SET %部位
◎
Let target be element that is the indicated part of the document.
◎
Set the Document's target element to target.
</li>
					<li>
%部位 を`~viewの中へ~scrollする$( `auto^l, `start^l, `nearest^l )
`CSSOMVIEW$r
◎
Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest". [CSSOMVIEW]
</li>
					<li>
`~objを~focusする$( %部位, %文書 の`表示域$ )
◎
Run the focusing steps for target, with the Document's viewport as the fallback target.
</li>
					<li>
%文書 における`逐次的~focus~naviの始点$ ~SET %部位
◎
Move the sequential focus navigation starting point to target.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<p>
`文書$ %文書 内の
`指示された部位@doc
は、`素片$urlがあれば，それが指示するものになる。
`素片$urlから~nodeにどう対応付けるかの意味論は、
%文書 が利用している`~MIME型$を定義する仕様により定義される（例えば、`~XML~MIME型$用の`素片$urlの処理は `RFC7303$r が担当する）。
◎
The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]
</p>

<p>
各 `文書$には、 `target$ps 疑似類を定義するために利用される
`標的~要素@
がある。
それは、初期~時は~NULLであり，上の~algoで更新される。
◎
There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.
</p>

<div class="algorithm">
<p>
~HTML文書（および， `~HTML~MIME型$ ） %文書 に対しては、
%文書 内の`指示された部位$docを決定するときは，次の処理~modelに従うモノトスル。
◎
For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of the document is.
</p>

<ol>
	<li>
%素片 ~LET %文書 の`~URL$docの`素片$url
◎
Let fragment be the document's URL's fragment.
</li>
	<li>
~Assert：
%素片 ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
~IF［
%素片 ~EQ 空~文字列
］
⇒
~RET `文書の上端^i
◎
If fragment is the empty string, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with fragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
%素片~byte列 ~SET `文字列を~byte列に~percent-復号する$( %素片 )
◎
Let fragmentBytes be the result of string percent decoding fragment.
</li>
	<li>
%復号-済み素片 ~LET `~BOMはそのままに~UTF-8復号する$( %素片~byte列 )
◎
Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %復号-済み素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with decodedFragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
~IF［
%復号-済み素片 ~EQ`大小無視$sub `top^l
］
⇒
~RET `文書の上端^i
◎
If decodedFragment is an ASCII case-insensitive match for the string top, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~RET ε
◎
There is no indicated part of the document.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`指示された要素を見出す@
ときは、所与の
( `文書$ %文書, 文字列 %素片 )
に対し，次を走らす：
◎
To find a potential indicated element given a string fragment, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`~tree内$に［
`~ID$ ~EQ %素片
］を満たす要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.
</li>
	<li>
~IF［
%文書 の`~tree内$に［
`name$a 属性を有していて，その値 ~EQ %素片
］を満たす `a$e 要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an a element in the document tree that has a name attribute whose value is equal to fragment, then return the first such element in tree order. 
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<p>
この節に言及した~taskの`~task源$は
`~DOM操作~task源$にするモノトスル。
◎
The task source for the task mentioned in this section must be the DOM manipulation task source.
</p>

			</section>
			<section id="history-traversal">
<h3 title="History traversal">7.8.10. 履歴の走査</h3> 

<div class="algorithm">
<div class="p">
<p>
`履歴を走査する@
ときは、所与の：
</p>

<ul ><li>`~session履歴~entry$ %~entry
</li><li>%置換~可能化~flag ~IN { `置換を可能化する@i, ε }（省略時は ε ）
</li><li>%~eventは他を阻まない~flag ~IN { `~eventは他を阻まない@i, ε }（省略時は ε ）
</li><li>%履歴~navi~flag ~IN { `履歴~navi@i, ε } （省略時は ε ）
</li></ul>

<p>
に対し，次を走らすモノトスル：
</p>
◎
To traverse the history to a session history entry entry, optionally with replacement enabled, optionally with the non-blocking events flag set, and optionally with the history-navigation flag set:
</div>

<p class="note">注記：
この~algoは、明示的に`履歴を前／後に走査する$ときのみならず，他の状況においても呼出される
— 例えば、閲覧文脈を`~navigate$するときに，`新たな~pageで~session履歴を更新する$一部として。
◎
This algorithm is not just invoked when explicitly going back or forwards in the session history — it is also invoked in other situations, for example when navigating a browsing context, as part of updating the session history with the new page.
</p>

<ol>
	<li>
%履歴 ~LET %~entry が属する`~session履歴$
◎
↓</li>
	<li>
%B ~LET %履歴 を有する`閲覧文脈$
◎
↓</li>
	<li>
<p>
~IF［
%~entry はもはや`文書$を保持していない
］：
◎
If entry no longer holds a Document object, then:
</p>
		<ol>
			<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒
`~URL$rq ~SET %~entry の`~URL$
◎
Let request be a new request whose url is entry's URL.
</li>
			<li>
~IF［
%履歴~navi~flag ~EQ `履歴~navi$i
］
⇒
%要請 の`履歴~navi~flag$rq ~SET ~T
◎
If the history-navigation flag is set, then set request's history-navigation flag.
</li>
			<li>
<p>
`~entryを更新する$ためとして，［
%~entry を最初に作成したときに利用した`~source閲覧文脈$
］を %要請 へ`~navigate$する（これは、`置換を可能化する$i 下では決して起こらない）
◎
Navigate the browsing context to request to perform an entry update of entry. The navigation must be done using the same source browsing context as was used the first time entry was created. (This can never happen with replacement enabled.)
</p>

<p class="note">注記：
`~navigate$ ~algoは、走査を完了するために，この~algoを再び呼出す
— その時点で %~entry は`文書$を保持することになる。
◎
The "navigate" algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point entry holds a Document object.
</p>

<p class="note">注記：
資源が非冪等~動作を利用して得られたものであった場合（ 例えば `POST^hm による~form提出）や, 資源はもはや可用でない場合（例えば~computerは今や~offlineになっていて，~pageも~cacheされていないため）など、再度そこへ~navigateできないこともある。
この事例では、~naviの結果は，以前と異なる~pageになる
— 例えば，問題を説明する~error~messageや, ~formを再度~提出する~UIを提供するなど。
◎
If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.
</p>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%現~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
~IF［
%現~entry の~titleは［
`pushState()$m ／ `replaceState()$m
］~methodにより設定されていない
］
⇒
%現~entry の~title ~SET `document.title$m ~IDL属性の値を取得した結果
◎
If the current entry's title was not set by the pushState() or replaceState() methods, then set its title to the value returned by the document.title IDL attribute.
</li>
	<li>
適切になる, かつ ~UAが持続化するよう望む状態があれば、それらを反映するように，%現~entry を更新する
—
この~entryは、`持続的な利用者~状態$を伴うものとされる。
◎
If appropriate, update the current entry in the browsing context's Document object's History object to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
%現~文書 ~LET %現~entry の`文書$（ ~EQ %B にて`作動中の文書$）
◎
↓</li>
	<li>
<p>
~IF［
%文書 ~NEQ %現~文書
］：
◎
If entry has a different Document object than the current entry, then run the following substeps:
</p>
		<ol>
			<li>
%B の`~top-level閲覧文脈$の`文書~族$内の
~EACH( `文書$ )
に対し
⇒
`文書$に結付けられている`履歴~走査~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
<p>
~IF［
( %文書 の`生成元$, %現~文書 の`生成元$ )
は`同一-生成元$でない
］：
◎
If the origin of entry's Document object is not the same as the origin of the current entry's Document object, then run the following subsubsteps:
</p>
				<ol>
					<li>
%履歴 内の
~EACH( ~entry %e )
に対し
⇒
~IF［
( %e の`文書$の`生成元$, %現~文書 の`生成元$ )
は`同一-生成元$である
］~AND［
%e は %現~entry と連続的である
【<a href="~HISTORY#_contiguous">~~参照</a>】
］
⇒
%e の`閲覧文脈~名$ ~SET %B の`閲覧文脈~名$
◎
The current browsing context name must be stored with all the entries in the history that are associated with Document objects with the same origin as the active document and that are contiguous with the current entry.
</li>
					<li id="resetBCName">
~IF［
%B は`~top-level閲覧文脈$である
］~AND［
%B は`補助~閲覧文脈$でない
］
⇒
%B の`閲覧文脈~名$ ~SET 空~文字列
◎
If the browsing context is a top-level browsing context, but not an auxiliary browsing context, then set the browsing context's name to the empty string.
</li>
				</ol>
			</li>
			<li id="appcache-history-2">
`閲覧文脈にて作動中の文書を設定する$( %B, %文書 )
◎
Set the active document of the browsing context to entry's Document object.
</li>
			<li>
<p>
~IF［
%~entry の`閲覧文脈~名$ ~NEQ ε
］：
◎
If entry has a browsing context name, then run the following subsubsteps:
</p>
				<ol>
					<li>
%B の`閲覧文脈~名$ ~SET %~entry の`閲覧文脈~名$
◎
Set the browsing context's browsing context name to entry's browsing context name.
</li>
					<li>
%履歴 内の
~EACH( ~entry %e )
に対し
⇒
~IF［
( %e の`文書$の`生成元$, %文書 の`生成元$ )
は`同一-生成元$である
］~AND［
%e は %~entry と連続的である
］
⇒
%e の`閲覧文脈~名$ ~SET ε
◎
Clear any browsing context names of all entries in the history that are associated with Document objects with the same origin as the new active document and that are contiguous with entry.
</li>
				</ol>
			</li>
			<li id="history-autocomplete">
%文書 内の
~EACH( ~form~control %E )
に対し
⇒
~IF［
%E の`~autofill欄~名$ ~EQ `off$v
］
⇒
%E の`再設定~algo$を呼出す
◎
If entry's Document object has any form controls whose autofill field name is "off", invoke the reset algorithm of each of those elements.
</li>
			<li>
<p>
~IF［
%文書 の`現在の文書の準備度$ ~EQ `complete^l
］
⇒
`~DOM操作~task源$から，次を走らす`~taskを~queueする$：
◎
If the current document readiness of entry's Document object is "complete", then queue a task to run the following subsubsteps:
</p>
				<ol>
					<li>
~IF［
%文書 の`~page表示中~flag$doc ~EQ ~T
］
⇒
~RET
◎
If the Document's page showing flag is true, then abort these steps.
</li>
					<li>
%文書 の`~page表示中~flag$doc ~SET ~T
◎
Set the Document's page showing flag to true.
</li>
					<li>
<p>
`適用-可能な仕様$により定義されている
`~session履歴~文書の可視性を変更する手続き@
があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any session history document visibility change steps for Document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用-に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
					</li>
					<li>
%文書 に`関連な大域~obj$に向けて，名前 `pageshow$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒＃
`persisted$m 属性 ~SET ~T
◎
Fire an event named pageshow at the Document object's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true, and legacy target override flag set.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~URL$doc ~SET %~entry の`~URL$
◎
Set the document's URL to entry's URL.
</li>
	<li>
%~hash変化あり ~LET ~F
◎
↓</li>
	<li>
~IF［
%~entry の~URLの`素片$url ~NEQ %現~entry の`素片$url
］~AND［
%文書 ~EQ %現~文書
］
⇒＃
%~hash変化あり ~LET ~T；
%旧~URL ~LET %現~entry の~URL；
%新~URL ~LET %~entry の~URL
◎
If entry has a URL whose fragment differs from that of the current entry's when compared in a case-sensitive manner, and the two share the same Document object, then let hash changed be true, and let old URL be the current entry's URL and new URL be entry's URL. Otherwise, let hash changed be false.
</li>
	<li>
~IF［
%置換~可能化~flag ~EQ `置換を可能化する$i
］
⇒
%履歴 内で %~entry の直前にある~entryを除去する
◎
If the traversal was initiated with replacement enabled, remove the entry immediately before the specified entry in the session history.
</li>
	<li>
~IF［
%~entry は`持続的な利用者~状態$を伴わない
］~AND［
%~entry の`~URL$の`素片$url ~NEQ ~NULL
］
⇒
`素片へ~scrollする$
◎
If entry is not an entry with persisted user state, but its URL's fragment is non-null, then scroll to the fragment.
</li>
	<li>
%履歴 の`現在の~entry$ ~SET %~entry
◎
Set the current entry to entry.
</li>
	<li>
%状態 ~LET %~entry の`直列形の状態$
◎
↓</li>
	<li>
~IF［
%状態 ~NEQ ~NULL
］
⇒
%状態 ~SET `StructuredDeserialize$jA( %状態, `現在の~Realm~Record$ )
⇒
例外が投出されたときは、~catchして
⇒
%状態 ~SET ~NULL （例外は無視する）
◎
Let targetRealm be the current Realm Record.
◎
If entry has serialized state, then let state be StructuredDeserialize(entry's serialized state, targetRealm). If this throws an exception, catch it, ignore the exception, and let state be null.
◎
Otherwise, let state be null.
</li>
	<li>
`history.state$m ~SET %状態
◎
Set history.state to state.
</li>
	<li>
%状態~変化あり ~LET ［
%文書 の`最近の~entry$ ~NIN { ε, %~entry } ならば ~T ／
~ELSE_ ~F
］
◎
Let state changed be true if entry's Document object has a latest entry, and that entry is not entry; otherwise let it be false.
</li>
	<li>
%文書 の`最近の~entry$ ~SET %~entry
◎
Set entry's Document object's latest entry to entry.
</li>
	<li>
~IF［
%~eventは他を阻まない~flag ~EQ ε
］
⇒
下に与える下位手続き (A) を`即時$に走らす
◎
If the non-blocking events flag is not set, then run the following substeps immediately.＼
</li>
	<li>
~ELSE（ `~eventは他を阻まない$i ）
⇒
`~DOM操作~task源$から，下に与える下位手続き (A) を走らす`~taskを~queueする$
◎
Otherwise, the non-blocking events flag flag is set; queue a task to run the following substeps instead.
</li>
</ol>

<p>
下位手続き (A) は、次を走らすとする：
◎
↑</p>

<ol>
	<li>
~IF［
%状態~変化あり ~EQ ~T
］
⇒
%文書 に`関連な大域~obj$に向けて，名前 `popstate$et の`~eventを発火する$
— `PopStateEvent$I を利用し，次のように初期化して
⇒＃
`state$m 属性 ~SET %状態
◎
If state changed is true, then fire an event named popstate at the Document object's relevant global object, using PopStateEvent, with the state attribute initialized to state.
</li>
	<li>
~IF［
%~entry は`持続的な利用者~状態$を伴う
］
⇒
~UAは、`持続的な利用者~状態を復旧-$して，
%文書 と その具現化の側面を更新してもヨイ
◎
If entry is an entry with persisted user state, then the user agent may restore persisted user state and update aspects of the document and its rendering.
</li>
	<li>
~IF［
%~hash変化あり ~EQ ~T
］
⇒
%B の`~window$に向けて，名前 `hashchange$et の`~eventを発火する$
— `HashChangeEvent$I を利用し，次のように初期化して
⇒＃
`oldURL$m 属性 ~SET %旧~URL,
`newURL$m 属性 ~SET %新~URL
◎
If hash changed is true, then fire an event named hashchange at the browsing context's Window object, using HashChangeEvent, with the oldURL attribute initialized to old URL and the newURL attribute initialized to new URL.
◎
↑↑
The task source for the tasks mentioned above is the DOM manipulation task source.
</li>
</ol>

</div>

				<section id="persisted-user-state-restoration">
<h4 title="Persisted user state restoration">7.8.10.1. 持続的な利用者~状態の復旧</h4>

<div class="algorithm">
<p>
~UAは、`~session履歴~entry$ %~entry から
`持続的な利用者~状態を復旧-@
するときは，次の手続きを即時に走らすモノトスル：
◎
When the user agent is to restore persisted user state from a history entry, it must run the following steps immediately:
</p>

<ol>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
<p>
~IF［
%~entry の`~scroll復旧~mode$ ~EQ `manual$l
］
⇒
~UAは、［
%文書 ／ %文書 の~scroll可能域
］用の~scroll位置を復旧するべきでない
— ただし、~scroll可能域のうち，その~scroll復旧が［
%文書 が`入子にして$いる`閲覧文脈$の`~session履歴~entry$の`~scroll復旧~mode$
］により制御されているものは除く
</p>

<p>
~ELSE
⇒
~UAは、~scroll位置を復旧してもヨイ
</p>

◎
If the entry has a scroll restoration mode, let scrollRestoration be that. Otherwise let scrollRestoration be "auto"
◎
If scrollRestoration is "manual" the user agent should not restore the scroll position for the Document or any of its scrollable regions, with the exception of any nested browsing contexts whose scroll restoration is controlled by their own history entry's scroll restoration mode, otherwise, it may do so.
</li>
	<li>
任意選択で
⇒
%文書 とその具現化の他の側面を更新する
— 一例として，~UAが以前に記録した~form欄の値など。
◎
Optionally, update other aspects of the document and its rendering, for instance values of form fields, that the user agent had previously recorded.
</li>
</ol>
</div>

<p class="note">注記：
持続的~状態が，そのような~controlにおける利用者~入力の書字方向性を含む場合、これには，次に該当する要素の `dir$a 属性を更新することも含まれる
⇒
`textarea$e 要素 ／
`input$e 要素のうち［
その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］を満たすもの
◎
This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in either the Text state or the Search state, if the persisted state includes the directionality of user input in such controls.
</p>

<p class="note">注記：
~UAが~scroll位置を復旧しないことは、~scroll位置が特定0の値（例： (0,0) ）に~~維持されることを含意するものではない。
実際の~scroll位置は［
~naviの種別や, ~UAによる~caching-strategy
］に依存する。
なので、~web~appは，特定0の~scroll位置に決まるとは見做せない
— ~appには、自身が求めるものに設定することが督促される。
◎
Not restoring the scroll position by user agent does not imply that the scroll position will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.
</p>

				</section>
				<section id="the-popstateevent-interface">
<h4 title="The PopStateEvent interface">7.8.10.2. `PopStateEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `PopStateEventInit$I eventInitDict)]
interface `PopStateEvent@I : `Event$I {
  readonly attribute any `state$m;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any state = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `state$m</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>
</dl>

<dl class="idl-def">
	<dt>`state@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The state attribute must return the value it was initialized to.＼
</dd>
	<dd>
この~event用の文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>
</dl>

				</section>
				<section id="the-hashchangeevent-interface">
<h4 title="The HashChangeEvent interface">7.8.10.3. `HashChangeEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `HashChangeEventInit$I eventInitDict)]
interface `HashChangeEvent@I : `Event$I {
  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `oldURL$m</dt>
	<dd>
履歴を走査する直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event . `newURL$m</dt>
	<dd>
履歴を走査した直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>`oldURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The oldURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を走査する直前の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>`newURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The newURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を走査した直後の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>

				</section>
				<section id="the-pagetransitionevent-interface">
<h4 title="The PageTransitionEvent interface">7.8.10.4. `PageTransitionEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `PageTransitionEventInit$I eventInitDict)]
interface `PageTransitionEvent@I : `Event$I {
  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event . `persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
~pageが新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の~pageが最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、この~pageは，利用者がこの~pageに~navigateして戻った場合に（その~pageを回復可能でなくするものが他になければ）再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page.
</dd>
	<dd>
<p>
~pageを回復可能でなくするものには次が含まれる：
</p>

<ul ><li>`beforeunload$et ~event用の~listenerがあるとき
</li><li>`unload$et ~event用の~listenerがあるとき
</li><li>回復可能でない `iframe$e があるとき
</li><li>作動中の `WebSocket$I ~objがあるとき
</li><li>`文書を中止-$したとき
</li></ul>

◎
Things that can cause the page to be unsalvageable include:

• Listening for beforeunload events
• Listening for unload events
• Having iframes that are not salvageable
• Active WebSocket objects
• Aborting a Document 
</dd>

</dl>

<dl class="idl-def">
	<dt>`persisted@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The persisted attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

				</section>
			</section>
			<section id="unloading-documents">
<h3 title="Unloading documents">7.8.11. 文書の~unload法</h3>

<div>
<p>
`文書$は、次のものを持つ：
</p>

<dl>
	<dt>`回復可能~状態@doc</dt>
	<dd>
初期~時には ~T になるモノトスル。
</dd>

	<dt>`~unload発火-済み~flag@doc</dt>
	<dd>
初期~時には ~F になるモノトスル。
</dd>

	<dt>`~page表示中~flag@doc</dt>
	<dd>
初期~時には ~F になるモノトスル。
この~flagは、~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受取る（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受取ったり，その逆が生じることは決してない）ことを確保するために利用される。
</dd>
</dl>

◎
A Document has a salvageable state, which must initially be true, a fired unload flag, which must initially be false, and a page showing flag, which must initially be false. The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</div>

<p>
各`~event-loop$は、
`終了入子~level@
と呼ばれる~counterを有する
— 初期~時には 0 になるモノトスル。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<div class="algorithm">
<p>
`文書の~unloadを~promptする@
ときは、所与の
( `文書$ %文書, %再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To prompt to unload, given a Document object document and optionally a recursiveFlag, run these steps:
</p>

<ol>
	<li>
`~event-loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by 1.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase the document's ignore-opens-during-unload counter by 1.
</li>
	<li>
%event ~LET `~eventを作成する$( `BeforeUnloadEvent$I )
◎
Let event be the result of creating an event using BeforeUnloadEvent.
</li>
	<li>
%event の属性を次のように初期化する
⇒＃
`type$m ~SET `beforeunload$et,
`cancelable$m ~SET ~T
◎
Initialize event's type attribute to beforeunload and its cancelable attribute true.
</li>
	<li>
%文書 に`関連な大域~obj$に向けて %event を`配送する$
◎
Dispatch: Dispatch event at document's relevant global object.
</li>
	<li>
`~event-loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by 1.
</li>
	<li>
~IF［
%event 配送-時に何らかの~event~listenerが誘発された
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If any event listeners were triggered by the earlier dispatch step, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
次のいずれも満たされる
］…：
◎
↓</p>
		<ul>
			<li>
`~sandbox化( ~modal )~flag$ ~NIN %文書 の`作動中の~sandbox法~flag集合$
◎
If document's active sandboxing flag set does not have its sandboxed modals flag set, and＼
</li>
			<li>
［
%event の `returnValue$m 属性 ~NEQ 空~文字列
］~OR［
%event は取消された
］
◎
the returnValue attribute of the event object is not the empty string, or if the event was canceled, then＼
</li>
		</ul>
<p>
…ならば
⇒
~UAは、利用者に， %文書 の~unloadを望むかどうか確認をとってもヨイ：
◎
the user agent may ask the user to confirm that they wish to unload the document.
</p>

<p class="note">注記：
利用者に示される~messageは、~custom化することはできず，~UAにより決定される。
特に、 `returnValue$m 属性の実際の値は無視される。
◎
The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.
</p>
		<ul>
			<li>
~UAは，そうすることが利用者にとって［
いらつく／紛らわしい／的外れである
］と判定したときは、利用者に確認をとらないことが奨励される。
単純な経験則として、利用者が %文書 とやりとりしていなければ，とらないことが挙げられる。
◎
The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless. A simple heuristic might be that if the user has not interacted with the document, the user agent would not ask for confirmation before unloading it.
</li>
			<li>
~UAは，利用者に確認をとる場合には、利用者からの応答を待機している間，`静止-$するモノトスル。
◎
If the user agent asks the user for confirmation, it must pause while waiting for the user's response.
</li>
			<li>
利用者から~page~naviの確認をとれなかった場合、 %文書 の
`~unloadは利用者から拒否された@
とされる。
◎
If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
<p>
%文書 の`子孫~閲覧文脈~list$ 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
Let descendants be the list of the descendant browsing contexts of document.
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書の~unloadを~promptする$( %作動中の文書, `再帰的^i )
⇒
~IF［
%作動中の文書 の`~unloadは利用者から拒否された$
］
⇒
~BREAK
（ %文書 についても暗黙的に`~unloadは利用者から拒否された$ことになる）
◎
Prompt to unload browsingContext's active document with the recursiveFlag set. If the user refused to allow the document to be unloaded, then the user implicitly also refused to allow document to be unloaded; break.
</li>
					<li>
~IF［
%作動中の文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of browsingContext's active document is false, then set the salvageable state of document to false.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease the document's ignore-opens-during-unload counter by 1.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`文書を~unloadする@
ときは、所与の
( `文書$ %文書, %再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To unload a Document document, optionally given a recursiveFlag:
</p>

<ol>
	<li>
`~event-loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by one.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase document's ignore-opens-during-unload counter by one.
</li>
	<li>
<p>
~IF［
%文書 の`~page表示中~flag$doc ~EQ ~T
］：
◎
If document's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the pagehide event and don't rerun the unloading document visibility change steps).
</p>
		<ol>
			<li>
%文書 の`~page表示中~flag$doc ~SET ~F
◎
Set document's page showing flag to false.
</li>
			<li>
%文書 に`関連な大域~obj$に向けて，名前 `pagehide$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒
`persisted$m 属性 ~SET %文書 の`回復可能~状態$doc
◎
Fire an event named pagehide at document's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true if document's salvageable state is true, and false otherwise, and legacy target override flag set.
</li>
			<li>
<p>
`適用-可能な仕様$により定義される
`~unload中の文書の可視性~変化-時の手続き@
があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document visibility change steps for document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用-に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%文書 の`~unload発火-済み~flag$doc ~EQ ~F
］
⇒
%文書 に`関連な大域~obj$に向けて，名前 `unload$et の`~eventを発火する$( `~targetを上書きする^i )
◎
Unload event: If document's fired unload flag is false, then fire an event named unload at document's relevant global object, with legacy target override flag set.
</li>
	<li>
`~event-loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by one.
</li>
	<li>
~IF［
前~前~段にて，何らかの~event~listenerが誘発された
］
⇒＃
%文書 の`回復可能~状態$doc ~SET ~F；
%文書 の`~unload発火-済み~flag$doc ~SET ~T
◎
If any event listeners were triggered by the earlier unload event step, then set document's salvageable state to false and set document's fired unload flag to true.
</li>
	<li>
この仕様も含む`適用-可能な仕様$にて定義される
`文書~unload時の片付け手続き$があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document cleanup steps for document that are defined by this specification and other applicable specifications.
</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
%子孫~list ~LET %文書 の`子孫~閲覧文脈~list$
◎
Let descendants be the list of the descendant browsing contexts of document.
</li>
			<li>
<p>
%子孫~list 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書を~unloadする$( %作動中の文書, `再帰的^i )
◎
Unload the active document of browsingContext with the recursiveFlag set.
</li>
					<li>
~IF［
%作動中の文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of the active document of browsingContext is false, then set the salvageable state of document to false also.
</li>
				</ol>
			</li>
			<li>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
`文書を破棄する$( %文書 )
◎
If document's salvageable state is false, then discarddocument.
</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease document's ignore-opens-during-unload counter by one.
</li>
</ol>
</div>

<div class="algorithm">
<p>
`適用-可能な仕様$は、
`文書~unload時の片付け手続き@
を定義できる。
この仕様が定義する`文書~unload時の片付け手続き$は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a Document document:
</p>

<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
~EACH( `WebSocket$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`消滅させる$
◎
For each WebSocket object webSocket whose relevant global object is window, make disappear webSocket.
</li>
	<li>
~IF［
前~段により影響された `WebSocket$I ~objはある
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If this affected any WebSocket objects, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］：
◎
If document's salvageable state is false, then:
</p>
		<ol>
			<li>
~EACH( `EventSource$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に閉じる$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%文書 の`~window$の`作動中の~timer~list$を空にする
◎
Empty window's list of active timers.
</li>
		</ol>
	</li>
</ol>
</div>

				<section id="the-beforeunloadevent-interface">
<h4 title="The BeforeUnloadEvent interface">7.8.11.1. `BeforeUnloadEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>

<p class="note">注記：
`BeforeUnloadEvent$I に特有な初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I
~interfaceは、旧来の~interfaceである
— それは、~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定することで
`文書の~unloadを~promptする$処理を制御できるようにする。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するべきである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>`returnValue@m</dt>
	<dd>
この属性は、`文書の~unloadを~promptする$処理-を制御する。
◎
The returnValue attribute controls the process of prompting to unload.＼
</dd>
	<dd>
~eventの作成-時には、この属性は空~文字列に設定されるモノトスル。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、この属性に最後に設定された値を返すモノトスル。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、この属性を所与の値に設定するモノトスル。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、もっぱら歴史的な理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
			<section id="aborting-a-document-load">
<h3 title="Aborting a document load">7.8.12. 文書~読込nの中止-法</h3>

<div class="algorithm">
<p>
`文書を中止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To abort a Document document:
</p>

<ol>
	<li>
<p>
%文書 が`属する閲覧文脈$の
~EACH( `子~閲覧文脈$ %子 )
に対し：
</p>
		<ol>
			<li>
%子~文書 ~LET %子 にて`作動中の文書$
</li>
			<li>
`文書を中止する$( %子~文書 )
</li>
			<li>
~IF［
%子~文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Abort the active documents of every child browsing context. If this results in any of those Document objects having their salvageable state set to false, then set document's salvageable state to false also.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceたちがある
］
⇒
</p>
		<ol>
			<li>
<p>
それらを取消す
— 以降
⇒＃
それらに対し`~queueされ$る`~task$は破棄する ／
それらに対し~networkから受信される更なる~dataは破棄する
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Cancel any instances of the fetch algorithm in the context of document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 には`作動中の構文解析器$がある
］：
</p>
		<ol>
			<li>
その`構文解析器を中止する$
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>
◎
If document has an active parser, then abort that parser and set document's salvageable state to false.
</li>
</ol>
</div>

<p>
~UAは、利用者が明示的に`文書を中止する$~algoを呼出すことを許容してもヨイ。
利用者がそれをした場合、その`文書$が`作動中の文書$であるならば、~UAは，`文書を中止する$~algoを呼出す前に，次を走らす`~taskを~queueする$べきである
⇒
その`文書$に`関連な大域~obj$に向けて，名前 `abort$et の`~eventを発火する$
◎
User agents may allow users to explicitly invoke the abort a document algorithm for a Document. If the user does so, then, if that Document is an active document, the user agent should queue a task to fire an event named abort at that Document object's relevant global object before invoking the abort algorithm.
</p>

<div class="algorithm">
<p>
`文書の読込ngを停止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To stop document loading given a Document object document, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not an active document, then return.
</li>
	<li>
%閲覧文脈 ~LET %文書 が`属する閲覧文脈$
◎
Let browsingContext be document's browsing context.
</li>
	<li>
~IF［
%閲覧文脈 を`~navigate$しようとする既存の試みがある
］~AND［
その試みは`文書を~unloadする$~algoを現在~走らせていない
］
⇒
その`~navi$を取消す
◎
If there is an existing attempt to navigate browsingContext and that attempt is not currently running the unload a document algorithm, then cancel that navigation.
</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="offline">
<h2 title="Offline Web applications">7.9. ~offline~Web~app</h2>

<p class="critical">
この特能は、~Web~platformから除去されつつある過程にある（何年もかかるであろう）。
今では、~offline~Web~app特能は，利用しないことが強く奨励される。
代わりに、~service-worker `SW$r を利用すること。
◎
This feature is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using any of the offline Web application features at this time is highly discouraged. Use service workers instead. [SW]
</p>

<p class="trans-note">【
以下、この節の内容は未訳。
このサイトのこの仕様の和訳における
`~app~cache用@
…
と記された箇所も未訳であり、実際の原文では，この節にて定義される各種~用語を利用する内容が記述されている。
言い換えれば、和訳は，~UAがこの節に述べられる機能を~supportしていないかのように単純~化して記述している。
】</p>

		</section>
</main>

