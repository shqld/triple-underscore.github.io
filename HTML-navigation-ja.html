<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Browsing the Web（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'browsing-the-web',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'hm': // HTTP method
	text = `\`<code class="method">${key}</code>\``;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'sf': // structured fields
	text = `<sub>sf-</sub>${text}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2020-09-10
trans_update:2020-09-11
source_checked:200818
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsing-the-web.html
site_nav:browsers,network,html
nav_prev:HISTORY
nav_next:WAPI
trans_1st_pub:2017-01-01


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
dir:directive
ps:pseudo
jv:js-value
sl:js-slot
jA:abstract
jT:js-type
v:value
hst:status

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
E:code
dir:code
ps:code
sl:span
jA:span
jv:code
jT:code
hst:code
v:code
V:var
i:i
hH:i
sub:sub
cite:cite

●●original_urls
offline:https://html.spec.whatwg.org/multipage/offline.html

●●words_table

	●network／保安／navi
TLS:
DNS:
Content-Type:
X-Frame-Options:
HTTP_S:HTTP(S) 
COOP:
Location:
mail::::メール
payload::::ペイロード
caching-strategy:caching strategy:::キャッシュ方策
disposition:
	~navigate法:navigating
	~network用:networking
load:
unload:
	~unload法:unloading:
部位:part:~
refresh:
強制d:forced:強制
	~secure化:secured
非冪等:non-idempotent:~
	阻止される^i:Blocked
	許容される^i:Allowed
強制的:forcible:~
悪用-:exploit:~
騙す:trickする:~
危険:dangerous:~
flags:::flag 群:フラグ群
施行:enforcement:~
	同一-生成元かどうか:same-originness

	●環境 ／ 閲覧
id:
agent:
iframe:
標的:target::~::ターゲット
補助:auxiliary::~
閲覧:browsing::~
類似生成元:similar-origin::~::類似オリジン
埋込元:embedder::埋め込み元
再読込み:reload::再読み込み::リロード
	-:component
成熟-:mature::~
現任の:incumbent:~

辿る:traverseする::~
辿った:traverseした::~
辿り:traversal::~
終了入子:termination nesting:終了入れ子
族:family::~
回復可能:salvage 可能:~
閉じる:closeする::~
開く:openする::~
opener:::open 元
open:
切替n:switch:切り替え

	-:delta
	-:jump

	●IDL / js / event
欄:field::~::フィールド
	用の~listenerがある:listen
	scripting::::スクリプト処理
	発火-済み:fired
中途完了:abrupt completion::~

	●データ／構文／操作
EOF:
	LF
	LINE FEED
Record:
BOM:
hash:
percent-::: %-
comma::::カンマ
tokenizer:::token 化器:トークン化器:トークナイザ
開始tag:start tag::開始 tag:開始タグ
整形式性:well-formedness::~
下位型:subtype::~
未設定:unset::~
	On getting／On setting
同等:equal::~

作成時の:creation::~
解析器:parser::~::パーサ
直列形の:serialized::~::シリアル形の
同型:isomorphic::~
和集合:union::~
分割-:split:~
区切られ:delimitされ:~
形:form:~

	●一般処理
片付け:cleanup::~
timer::::タイマー
準備度:readiness:~
増分的:incremental:~
静止-:pause:~
続行-:proceed:~
変化あり:changed:~
持続化-:persist:~
持続的な:persisted:~
復旧-:restore::~
復旧:restoration::~
最終-:final:~
params::::パラメタ群
時刻:time:~
処置先:disposition::~

	-:step labeled
	cancelation
	中止-法:aborting
	reinvoke:再び呼出す
	他を阻まない:non-blocking
	unsuccessful
	最終的に:eventual
	最終的に:ultimately
	渡-:pass
	以降:onward
	終わらす:finish

	●UI
	右~click:right-click
	media::::メディア
modal::::モーダル
prompt:
scrolling::::スクロール処理
	~scroll可能域:scrollable region
書字方向性:directionality::~
	制御
逐次的:sequential:~
開始位置:beginning:~
始点:starting point:~
autofill:
一過:transient::~

	●仕様
選択肢:option:~:::オプション
外部的:external:~
自立的:stand-alone:~
在来の:preexisting:~
整合的に:consistent mannerで:~
文書化-:document:~
固守:adherence:~
白紙状態:clean slate:~
確認-:confirm:~
確認:confirmation:~
	（確認を）とる:ask
	食い違いが生じる:disagree
拒否-:refuse:~
手渡す:handする:取り扱わせる
究明:investigation:~
注目:attention:~
判定-:judge:~
	-:defer
指名-:designate:~
修正-:fix:~
意向:intention:~
細やか:granular:~
変種:variant:~

	actually
	-:default
	でき:possible
	なければその前に:potentially before
	ほぼ間違いなく:certainly
	他にない:nothing conspires
	同じものを与える下で:setup
	対になる:for that matter
	いらつく／紛らわしい／的外れである: annoying, deceptive, or pointless
	そうな:likely
	~~真の:real
	担当:responsible／responsibility
	:optionally
	今の所は:in the meantime
	両立:simultaneously
	〜性:〜ness
	強く:highly
	unspecified
	-:decide
	関心を失った:no longer interested in:
	面した:in the face of
	かいくぐる:evade
	ことにされた:supposed
	ことになった場合:face
	するよりも，~~寛容でない:are less permissive compared to doing 〜 instead
	選ぶ:choose
	したい所:hope
	-:threaded through
	指すもの:pointer
	割かれる:concerned with
	なり得る:potentially
	課され:impose
	結果になる:conclude
	~~指定していない:not prepared
	処する:deal with
	取って代わる:supersede
	紛らわしく:confused
	許容されない:disallowed
	示す:illustrate

	●未分類
合成-:synthesize::~
表示中:showing:~
消滅-:disappear:~
埋めた:fillした:~
切替えた:switchした:切り替えた
折返す:wrapする:折り返す
発した:emitした:~
iframe-srcdoc:iframe srcdoc
table
	PI
	POST:
PLAINTEXT:
古典:classic::~::クラシック
id:
feed-viewer::::配信ビューア
offline::::オフライン
package::::パッケージ
	multipart
連続的:contiguous:~

	-:store
	登録-済み:registered
	引く:brought
	待たれる:pending
	引用用の:quoting
		成す:comprise
	消え去る:going away
	終え:finish:
	間に挟む:intervening
	戻-:back
	結果を得る:dereference
	-:mark
	時間長:amount of time
	-:parameter
	Atom
	seamless:
	time:
	word processor
	~unload中の~openは無視する:ignore-opens-during-unload
	それ用の処理器:word processor
	現れる:appearする
	表:table

	●変数
X:
	`S$V:sourceBrowsingContext
	%B:browsingContext
	%~navi~params:navigationParams
	%~navi~COOP:navigationCOOP
	%~navi種別:navigationType
	%~sandbox~flags:sandboxFlags
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%予約-済み環境:reservedEnvironment
	%作動中の文書~navi生成元~activeDocumentNavigationOrigin
	%内容~型:contentType
	%応答~COOP:responseCOOP
	%~COOP施行~結果:coopEnforcementResult
	%応答~生成元:responseOrigin
	-:responseRequiresBrowsingContexGroupSwitch（誤）
	-:responseRequiresBrowsingContextGroupSwitch
	%最終-~sandbox~flags:finalSandboxFlags
	%最終-応答~生成元:finalResponseOrigin
	%現任の~navi生成元:incumbentNavigationOrigin
	%現在の~URL:currentURL
	%親~環境:parentEnvironment
	%~X~frame~options:xFrameOptions
	%生~X~frame~options:rawXFrameOptions
	%応答:response
	%行先~生成元:destinationOrigin
	%施策:policy
	%値:value
	%容器~文書:containerDocument
	%容器~閲覧文脈:containerBC
	%生成元~隔離を要請する:requestsOI
	%生成元~隔離~header:oiHeader

	●指示語
最近の:latest:~
	aforementioned
	続けて:in a row
	以前の:previous
	すでに:previously
	先頭の:leading
	前もって:prior
	前／後:back or forwards
	-:earlier
	最初に:in the first place
	箇所:place
	:two
	何らかの:some sort of
	かなりの部分:much of
	次:next
	ここ:this point
	1 個の:lone


●●words_table1

about_blank:about:blank
mailto_:mailto:
javascript_:javascript:

src-embed:src
src-iframe:src
src-img:src
src-media:src

	javascript:<code class="scheme">javascript:</code>

●●original_id_map

	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts

●●mdn_urls
beforeunloadevent:API/BeforeUnloadEvent
hashchangeevent:API/HashChangeEvent
	hashchangeeventinit:API/HashChangeEventInit
pagetransitionevent:API/PageTransitionEvent
	pagetransitioneventinit:API/PageTransitionEventInit
popstateevent:API/PopStateEvent
	popstateeventinit:API/PopStateEventInit

●●link_map

	●idl
E.SecurityError:~WEBIDL#securityerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebSocket:~WEBSOCKET#websocket
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLsse#eventsource
I.History:~HISTORY#history-3
I.WebSocket:~WEBSOCKET#websocket
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
	I.Document:~HTMLdom#document → 文書
~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

I.BeforeUnloadEvent:#beforeunloadevent
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit

I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest

m.cancelable:~DOM4#dom-event-cancelable
m.document.domain:~ORIGIN#dom-document-domain
m.document.title:~HTMLdom#dom-document-title
m.history.state:~HISTORY#dom-history-state
m.location.assign:~HISTORY#dom-location-assign
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.persisted:#dom-pagetransitionevent-persisted
m.preventDefault:~DOM4#dom-event-preventdefault
m.pushState:~HISTORY#dom-history-pushstate
m.replaceState:~HISTORY#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.state:#dom-popstateevent-state
m.type:~DOM4#dom-event-type
m.window.open:~WINDOW#dom-window-open
m.opener:~BROWSERS#dom-window-opener

l.auto:~HISTORY#dom-scrollrestoration-auto
l.manual:~HISTORY#dom-scrollrestoration-manual


et.abort:~HTMLindex#event-abort
et.beforeunload:~HTMLindex#event-beforeunload
et.hashchange:~HTMLindex#event-hashchange
et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.unload:~HTMLindex#event-unload

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.a:~HEtextlevel#the-a-element
e.input:~HEinput#the-input-element
e.script:~HEscripting#the-script-element
e.textarea:~HEforms#the-textarea-element

e.img:~HEimages#the-imge-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element

a.autoplay:~HEmedia#attr-media-autoplay
a.dir:~HTMLdom#the-dir-attribute
a.href:~HTMLlinks#attr-hyperlink-href
a.name:~HTMLobs#attr-a-name
a.type:~HEinput#attr-input-type
a.~src-embed:~HEembed#attr-embed-src
a.~src-iframe:~HEembed#attr-iframe-src
a.~src-img:~HEimages#attr-img-src
a.~src-media:~HEmedia#attr-media-src

sc.~about_blank:~HTMLdep#about:blank
sc.~mailto_:~RFCx/rfc6068#section-2
sc.~javascript_:#javascript-protocol
l.javascript:#javascript-protocol

hst.204:~HTTPrs#status.204
	~RFC7231#section-6.3.5
hst.205:~HTTPrs#status.205
	~RFC7231#section-6.3.6

dir.frame-ancestors:~CSP3#frame-ancestors

c.application/atom+xml:~HTMLindex#application/atom+xml
c.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
c.text/cache-manifest:~HTMLiana#text/cache-manifest
c.text/css:~HTMLindex#text/css
bl.text/html:~HTMLiana#text/html
c.text/plain:~RFCx/rfc2046#section-4.1.3
c.text/vtt:~HTMLindex#text/vtt

h.Content-Type:~HTTPsem#field.content-type
h.Content-Disposition:~RFCx/rfc6266
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
	https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header-dfn
h.Refresh:~HTMLiana#refresh
h.X-Frame-Options:~HTMLiana#x-frame-options
h.Origin-Isolation:~HTMLiana#origin-isolation-2

v.off:~HTMLautofill#attr-fe-autocomplete-off
ps.target:~HTMLselectors#selector-target

l.unsafe-none:~ORIGIN#coop-unsafe-none


	●用語
なければその前に:#_potentially-before
~app~cache用:#_for-app-cache

~source閲覧文脈:#source-browsing-context
	%S:#source-browsing-context
~navi~params:#navigation-params
nvP.閲覧文脈:#navigation-params-browsing-context
nvP.要請:#navigation-params-request
nvP.応答:#navigation-params-response
nvP.生成元:#navigation-params-origin
nvP.最終-~sandbox~flag集合:#navigation-params-sandboxing
nvP.非同一-生成元~opener施策:#navigation-params-coop
nvP.予約-済み環境:#navigation-params-reserved-environment
nvP.閲覧文脈の切替nが必要:#navigation-params-bc-switch-needed
nvP.履歴~取扱い:#navigation-params-hh

履歴を取扱うときの挙動:#history-handling-behavior
i.既定:#hh-default
i.~entry更新:#hh-entry-update
i.再読込み:#hh-reload
i.置換-:#hh-replace

~navigate:#navigate
~navi:#navigate
~navigate応答を処理する:#process-a-navigate-response
~navigate~fetchを処理する:#process-a-navigate-fetch
~navigate~URL~schemeを処理する:#process-a-navigate-url-scheme
自己~naviを明示的に上書き:#explicit-self-navigation-override
素片へ~navigateする:#navigate-fragid
素片へ~scrollしようと試行する:#try-to-scroll-to-the-fragment
素片へ~scrollする:#scroll-to-the-fragment-identifier

履歴を辿る:#traverse-the-history
明示的に~supportされる~JSON~MIME型:#explicitly-supported-json-mime-type
明示的に~supportされる~XML~MIME型:#explicitly-supported-xml-mime-type

成熟-:#concept-navigate-mature
~plugin文書:#plugin-document
標的~要素:#target-element
終了入子~level:#termination-nesting-level

i.非~文書~内容として取扱う:#navigate-non-Document
指示された要素を見出す:#find-a-potential-indicated-element

doc.指示された部位:#the-indicated-part-of-the-document
doc.~unload発火-済み~flag:#fired-unload
doc.~page表示中~flag:#page-showing
doc.回復可能~状態:#concept-document-salvageable
文書を中止する:#abort-a-document
文書を中止-:#abort-a-document
文書の読込ngを停止する:#stop-document-loading
文書を作成して初期化する:#initialise-the-document-object
作成して初期化-:#initialise-the-document-object

完全に読込まれた:#completely-loaded
完全に読込まれた時刻:#completely-loaded-time
読込ngを完全に終わらす:#completely-finish-loading
文書を~unloadする:#unload-a-document
文書の~unloadを~promptする:#prompt-to-unload-a-document
~unloadは利用者から拒否された:#refused-to-allow-the-document-to-be-unloaded
文書~unload時の片付け手続き:#unloading-document-cleanup-steps
~unload中の文書の可視性~変化-時の手続き:#unloading-document-visibility-change-steps

新たな~pageで~session履歴を更新する:#update-the-session-history-with-the-new-page
~session履歴~文書の可視性を変更する手続き:#session-history-document-visibility-change-steps

V.履歴~取扱い:#navigation-hh
V.履歴の取扱い:#traverse-history-hh
V.例外を可能化する:#exceptions-enabled
V.~eventは他を阻まない:#nonblockingevents
V.明示的な履歴~navi:#explicithistorynavigation

持続的な利用者~状態を復旧-:#restore-persisted-user-state
~inline内容を表示する:#read-ua-inline

~HTML文書が読込まれる:#navigate-html
	#read-html
	#read-xml
	#read-plugin
	#read-media
	#read-text
	#hand-off-to-external-software
	~HISTORY#history-notes
	#navigate-fragid-step
	#read-multipart-x-mixed-replace

~navi応答の~X-Frame-Optionsに対する固守を検査する:#check-a-navigation-response's-adherence-to-x-frame-options


	●用語（HTML

即時:~HTMLINFRA#immediately
並列的:~HTMLINFRA#in-parallel
~plugin:~HTMLINFRA#plugin
~secure化でき:~HTMLINFRA#concept-plugin-secure
~target上書き:~HTMLINFRA#concept-event-target-override
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications

~Content-Type~metadata:~HTMLurl#content-type
型~情報:~HTMLurl#content-type
	相対的に構文解析-:~HTMLurl#resolve-a-url
	結果の~URL~record:~HTMLurl#resulting-url-record
	~scheme~data:~HTMLurl#concept-url-scheme-data
	~HTML文書:~HTMLINFRA#html-documents

一過な作動化:~HTMLinteraction#transient-activation


閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
bc.容器:~BROWSERS#bc-container
容器~文書:~BROWSERS#bc-container-document
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈~名:~BROWSERS#browsing-context-name
閲覧文脈~視野~生成元:~BROWSERS#browsing-context-scope-origin
~load~event遅延-中:~BROWSERS#delaying-load-events-mode
作動中の文書:~BROWSERS#active-document
作動中の~window:~BROWSERS#active-window
閲覧文脈にて作動中の文書を設定する:~BROWSERS#set-the-active-document
~navigateすることは許容されて:~BROWSERS#allowed-to-navigate
作成-時:~BROWSERS#creating-a-new-browsing-context
文書~族:~BROWSERS#document-family
生成元を決定する:~BROWSERS#determining-the-origin
tbcG.~group:~BROWSERS#tlbc-group

~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
文書を破棄する:~WINDOW#discard-a-document
破棄-:~WINDOW#a-browsing-context-is-discarded

持続的な利用者~状態:~HISTORY#an-entry-with-persisted-user-state
~session履歴:~HISTORY#session-history
~session履歴~entry:~HISTORY#session-history-entry
履歴を前／後に辿る:~HISTORY#traverse-the-history-by-a-delta
現在の~entry:~HISTORY#current-entry
最近の~entry:~HISTORY#latest-entry
直列形の状態:~HISTORY#serialized-state
~scroll復旧~mode:~HISTORY#scroll-restoration-mode

生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
不透明な生成元:~ORIGIN#concept-origin-opaque
bc.~sandbox法~flags:~ORIGIN#concept-bc-sandboxing-flags
~sandbox法~flag集合:~ORIGIN#sandboxing-flag-set
強制d~sandbox法~flag集合:~ORIGIN#forced-sandboxing-flag-set
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag
作成時の~sandbox法~flagsを決定する:~ORIGIN#determining-the-creation-sandboxing-flags
非同一-生成元~opener施策を得する:~ORIGIN#obtain-coop
非同一-生成元~opener施策:~ORIGIN#cross-origin-opener-policy
非同一-生成元~opener施策の施行~結果:~ORIGIN#coop-enforcement-result
cooP.閲覧文脈~groupの切替nが必要:~ORIGIN#coop-enforcement-bcg-switch
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.非同一-生成元~opener施策:~ORIGIN#coop-enforcement-coop
応答の非同一-生成元~opener施策を施行する:~ORIGIN#coop-enforce

~navi応答の埋込元~施策に対する固守を検査する:~ORIGIN#check-a-navigation-response's-adherence-to-its-embedder-policy
~navi応答~用に利用する閲覧文脈を得する:~ORIGIN#obtain-browsing-context-navigation
埋込元~施策を得する:~ORIGIN#obtain-an-embedder-policy

sl.Window:~WINDOW#concept-windowproxy-window

~iframe~load~event手続き:~HEembed#iframe-load-event-steps

	●WAPI
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
現任の設定群~obj:~WAPI#incumbent-settings-object
類似生成元~window~agentを得する:~WAPI#obtain-similar-origin-window-agent
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task
大域~taskを~queueする:~WAPI#queue-a-global-task
環境~設定群~obj:~WAPI#environment-settings-object
大域~obj:~WAPI#global-object
履歴~辿り~task源:~WAPI#history-traversal-task-source
~network用~task源:~WAPI#networking-task-source
~script:~WAPI#concept-script
静止-:~WAPI#pause
古典~scriptを作成する:~WAPI#creating-a-classic-script
古典~scriptを走らす:~WAPI#run-a-classic-script
既定の古典~script~fetch~options:~WAPI#default-classic-script-fetch-options

環境:~WAPI#environment
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.~id:~WAPI#concept-environment-id
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~secureな文脈:~WAPI#secure-context

環境を破棄する手続き:~WAPI#environment-discarding-steps
新たな~JS~realmを作成する:~WAPI#creating-a-new-javascript-realm

~unload中の~openは無視する~counter:~HTMLdynamic#ignore-opens-during-unload-counter
登録-済み~handler:~HTMLnavigator#dom-navigator-registerprotocolhandler


	●FETCH
~ABNF:~FETCH#abnf
~fetch~scheme:~FETCH#fetch-scheme
~HTTP_S~scheme:~FETCH#http-scheme
~fetch:~FETCH#concept-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~ok状態s:~FETCH#ok-status
有構造~headerを取得する:~FETCH#concept-header-list-get-structured-header
~header~list:~FETCH#concept-header-list
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split
応答を処理する:~FETCH#process-response
非同一-生成元~資源~施策~検査:~FETCH#cross-origin-resource-policy-check
要請:~FETCH#concept-request
~network~error:~FETCH#concept-network-error
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.~referrer:~FETCH#concept-request-referrer
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.置換する~client~id:~FETCH#concept-request-replaces-client-id
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.~URL:~FETCH#concept-request-url
rq.~URL~list:~FETCH#concept-request-url-list
rq.現在の~URL:~FETCH#concept-request-current-url
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.生成元:~FETCH#concept-request-origin
rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.再読込み~navi~flag:~FETCH#concept-request-reload-navigation-flag
rq.履歴~navi~flag:~FETCH#concept-request-history-navigation-flag

応答:~FETCH#concept-response
rs.~Location~header~URL:~FETCH#concept-response-location-url
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.~CSP~list:~FETCH#concept-response-csp-list

	●他HTML

doc.~referrer施策:~HTMLdom#concept-document-referrer-policy
doc.非同一-生成元~opener施策:~HTMLdom#concept-document-coop
doc.埋込元~施策:~HTMLdom#concept-document-embedder-policy
doc.~referrer:~HTMLdom#the-document's-referrer
doc.許可~施策:~HTMLdom#concept-document-permissions-policy
作動中の構文解析器:~HTMLdom#active-parser
現在の文書の準備度:~HTMLdom#current-document-readiness

共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps

消滅させる:~WEBSOCKET#make-disappear
強制的に閉じる:~HTMLsse#concept-eventsource-forcibly-close

~HTML構文解析器:~HTMLparsing#html-parser
~PLAINTEXT状態:~HTMLparsing#plaintext-state
構文解析器を中止する:~HTMLparsing#abort-a-parser
~HTML構文解析器~内で:~HTMLparsing#parser-appcache
入力~byte~stream:~HTMLparsing#the-input-byte-stream
構文解析を停止した:~HTMLparsing#stop-parsing
停止-:~HTMLparsing#stop-parsing
~tokenizer:~HTMLparsing#tokenization

st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)

~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
利用者による作動化により誘発され:~HTMLinteraction#triggered-by-user-activation

~XML構文解析器:~HTMLxml#xml-parser
~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	内容を具現化するのに失敗する:~HEembed#sandboxPluginEmbed

~form提出:~HTMLforms#concept-form-submit
再設定~algo:~HTMLforms#concept-form-reset-control
~autofill欄~名:~HTMLautofill#autofill-field-name

~downloadとして:~HTMLlinks#as-a-download
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2
~downloadは許容される:~HTMLlinks#allowed-to-download

具現化されて:~HTMLrendering#being-rendered
作動中の~timer~list:~HTMLGAPI#list-of-active-timers

作動中の構文解析器は中止された？:~HTMLdynamic#active-parser-was-aborted

	●外部
実装定義:~INFRA#implementation-defined

sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
同型に復号する:~INFRA#isomorphic-decode
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
和集合:~INFRA#set-union
~size:~INFRA#list-size

sf.真偽値:~HEADER-STRUCTURE#sf-boolean

~tree順序:~DOM4#concept-tree-order
~ID:~DOM4#concept-id
doc.内容~型:~DOM4#concept-document-content-type
doc.種別:~DOM4#concept-document-type
doc.~URL:~DOM4#concept-document-url
doc.文字~符号化法:~DOM4#concept-document-encoding
~tree内:~DOM4#in-a-document-tree
~eventを作成する:~DOM4#concept-event-create
配送する:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
局所~名:~DOM4#concept-element-local-name

~URLを直列化する:~URL1#concept-url-serializer
~URL:~URL1#concept-url
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
同等な~URL:~URL1#concept-url-equals
~URL~record:~URL1#concept-url

~UTF-8復号する:~ENCODING#utf-8-decode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

疑似類:~SELECTORS4#pseudo-class
表示域:~CSS2VISUREN#viewport
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view
開始位置へ~scroll:~CSSOMVIEW#scroll-to-the-beginning-of-the-document

~MIME型:~MIMESNIFF#mime-type
~JSON~MIME型:~MIMESNIFF#json-mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
資源から算出された~MIME型:#_computed-mime-type

文書の~CSP~listを初期化する:~CSP3#initialize-document-csp
~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-request
~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-response
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set

応答から閲覧文脈~用の許可~施策を作成する:~PERMISSIONS-POLICY#create-from-response
~headerから~referrer施策を構文解析する:~REFERRER-POLICY#parse-referrer-policy-from-header
中途完了:~TC39#sec-completion-record-specification-type
現在の~Realm~Record:~TC39#current-realm
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.Type:~TC39#sec-ecmascript-data-types-and-values


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Browsing the web</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1 title="Browsing the web">7.10. web の閲覧</h1>
	</hgroup>

</header>

<hr>

<main id="MAIN" hidden>

		<section id="browsing-the-web">
<h2 title="Browsing the web">7.10. ~webの閲覧</h2>

			<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="navigating-across-documents">
<h3 title="Navigating across documents">7.10.1. 文書から文書への~navigate法</h3>

<p>
ある種の動作は、`閲覧文脈$を新たな資源へ`~navigate$させる。
~UAは、この仕様に定義されるそれに加えて，閲覧文脈を明示的に~navigateさせる様々な仕方を利用者~向けに供してもヨイ。
◎
Certain actions cause the browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.
</p>

<p class="example">
例えば 次のものは、閲覧文脈を~navigateさせ得る
⇒＃
`~hyperlinkを追う$,
`~form提出$,
`window.open()$m ~method,
`location.assign()$m ~method
◎
For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause a browsing context to navigate.
</p>

<p class="note">注記：
資源を識別するために必要とされる情報は、資源の~URLのみに限られない。
例えば、~HTTP `POST^hm を利用する~form提出は、~HTTP［
~method, ~payload
］も情報として有することになる。
同様に，`~iframe-srcdoc文書$は、自身が利用する~dataを知る必要がある。
◎
A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method and payload. Similarly, an iframe srcdoc document needs to know the data it is to use.
</p>

<p>
~navi処理nのかなりの部分は、新たな`文書$をどう作成するか決定することに割かれる。
それは、最終的には，`作成して初期化-$する~algo内で起こる。
この~algoに渡す~parameterたちは、次に挙げる`~item$sctからなる`構造体$
`~navi~params@
を介して追跡される：
◎
Much of the navigation process is concerned with determining how to create a new Document, which ultimately happens in the create and initialize a Document object algorithm. The parameters to this algorithm are tracked via a navigation params struct, which has the following items:
</p>
<dl class="def-list">
	<dt>
`要請@nvP
◎
request
</dt>
	<dd>
~NULL ／ 当の~naviを開始した`要請$
◎
null or a request that started the navigation
</dd>

	<dt>
`応答@nvP
◎
response
</dt>
	<dd>
最終的な~navigate先を与える`応答$（`~network~error$にもなり得る）
◎
a response that ultimately was navigated to (potentially a network error)
</dd>

	<dt>
`生成元@nvP
◎
origin
</dt>
	<dd>
新たな`文書$用に利用する`生成元$
◎
an origin to use for the new Document
</dd>

	<dt>
`最終-~sandbox~flag集合@nvP
◎
final sandboxing flag set
</dt>
	<dd>
新たな`文書$に課される`~sandbox法~flag集合$
◎
a sandboxing flag set to impose on the new Document
</dd>

	<dt>
`非同一-生成元~opener施策@nvP
◎
cross-origin opener policy
</dt>
	<dd>
新たな`文書$用に利用される`非同一-生成元~opener施策$
◎
a cross-origin opener policy to use for the new Document
</dd>

	<dt>
`予約-済み環境@nvP
◎
reserved environment
</dt>
	<dd>
~NULL ／ 新たな`文書$用に予約される`環境$
◎
null or an environment reserved for the new Document
</dd>

	<dt>
`閲覧文脈@nvP
◎
browsing context
</dt>
	<dd>
~navigateされる`閲覧文脈$（が、下を見よ【どこ？】）
◎
the browsing context to be navigated (but see below)
</dd>

	<dt>
`閲覧文脈の切替nが必要@nvP
◎
browsing context switch needed
</dt>
	<dd>
次を指示する真偽値
⇒
当の~naviは、所与の`閲覧文脈$nvPを`破棄-$して，新たな閲覧文脈を作成する結果になるベキかどうか
◎
a boolean indicating whether or not the navigation should conclude by discarding the given browsing context and creating a new one
</dd>

	<dt>
`履歴~取扱い@nvP
◎
history handling
</dt>
	<dd>
`履歴を取扱うときの挙動$を与える。
◎
a history handling behavior
</dd>
</dl>

<p class="note">注記：
この標準においては、`~navi~params$を成す各`~item$sctは，作成-時から変異することはない
— 以降，他の~algoへ渡されるのみである。
◎
Once a navigation params struct is created, this standard does not mutate any of its items. They are only passed onward to other algorithms.
</p>

<p>
`~session履歴$は、`文書$が作成された後に更新される。
`履歴を取扱うときの挙動@
は、［
~navi処理nを全体を通して欲される，~session履歴~更新の種別
］を追跡するために利用され，次のいずれかを値にとる：
◎
After Document creation, the session history gets updated. A history handling behavior is used to track the desired type of session history update throughout the navigation process. It is one of the following:
</p>
<dl class="def-list">
	<dt>
`既定@i
◎
"default"
</dt>
	<dd>
定例の~navi
— ~session履歴に新たな~entryを追加する。
◎
A regular navigation which adds a new entry to the session history.
</dd>
	<dt>
`~entry更新@i
◎
"entry update"
</dt>
	<dd>
既存の`~session履歴~entry$への~navi
— その~entryの`文書$が，すでに<a href="~WINDOW#discard-a-document">破棄されて</a>いた場合に利用され、その文書を作成し直す。
◎
A navigation to an existing session history entry to recreate that entry's Document, which was previously discarded.
</dd>
	<dt>
`再読込み@i
◎
"reload"
</dt>
	<dd>
現在の~pageを再読込みして，`現在の~entry$を置換することが意図される~navi。
◎
A navigation intended to reload the current page and replace the current session history entry.
</dd>
	<dt>
`置換-@i
◎
"replace"
</dt>
	<dd>
再読込みでないが，`現在の~entry$を置換することになる~navi。
◎
A non-reload navigation that will replace the current session history entry.
</dd>
</dl>

<p>
`~navi$には常に、
`~source閲覧文脈@
と呼ばれる，その開始-を担当していた`閲覧文脈$が孕まれる。
◎
Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.
</p>

<p class="trans-note">【
すなわち、`~navigate$する~algoは，~source閲覧文脈を明示的に与えずに呼出されることもあるが、その場合でも，~source閲覧文脈は その箇所の文脈から暗黙的に指定される（例：要素から誘発される~naviにおける~source閲覧文脈は、要素の`~node文書$が`属する閲覧文脈$になろう）。
】</p>

<p class="XXX">
<a href="~HTMLissue/1130">課題 #1130</a>
にて説明されるように、閲覧文脈を~sourceとして利用するのは，正しい~architectureとは言えないかもしれない。
◎
As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.
</p>

<div class="algo">

<div class="p">
<p>
`閲覧文脈$ %B を %資源 へ
`~navigate@
する~algoは、次も入力にとり，以下を走らすモノトスル：
</p>
<ul>
	<li>
真偽値
`例外を可能化する@V
（省略時は ~F ）
</li>
	<li>
`履歴を取扱うときの挙動$
`履歴~取扱い@V
（省略時は `既定$i ）
</li>
	<li>
`~source閲覧文脈$ %S
【上述したように、これは省略され得る】
</li>
</ul>

<p class="trans-note">【
以下，この節を通して、［
%S は`~source閲覧文脈$,
%B は~navigateされる`閲覧文脈$（`~navi~params$の`閲覧文脈$nvP）
］を意図して与えられた入力を表すことにする。
これらは、同じ閲覧文脈を指す場合もある。
】</p>

◎
To navigate a browsing context browsingContext to a resource resource, with an optional boolean exceptionsEnabled (default false) and an optional history handling behavior historyHandling (default "default"):
</div>
<ol>
	<li>
%~navi ~LET この`~navi$~algoの~instance
◎
↓</li>
	<li>
~IF［
%資源 は`~URL$である
］
⇒
%資源 ~SET 次のようにされた 新たな`要請$
⇒
`~URL$rq ~SET %資源
◎
If resource is a URL, then set resource to a new request whose url is resource.
</li>
	<li>
~IF［
%資源 は`要請$である
］~AND［
`履歴~取扱い$V ~EQ `再読込み$i
］
⇒
%資源 の`再読込み~navi~flag$rq ~SET ~T
◎
If resource is a request and historyHandling is "reload", then set resource's reload-navigation flag.
</li>
	<li id="sandboxLinks">
<p>
~IF［
%S は， %B を`~navigateすることは許容されて$いない
］：
◎
If the source browsing context is not allowed to navigate browsingContext, then:
</p>
		<ol>
			<li>
~IF［
`例外を可能化する$V ~EQ ~T
］
⇒
~THROW `SecurityError$E
◎
If exceptionsEnabled is given and is true, then throw a "SecurityError" DOMException.
</li>
			<li>
<p>
~ELSE
⇒
~UAは、［［
新たな, または %S の
］`~top-level閲覧文脈$内に %資源 を開くような選択肢
］を利用者に提供してもヨイ
— その事例では、~UAは、利用者から指名された`~top-level閲覧文脈$を，利用者がそれを独立に要請したかのように %資源 へ`~navigate$するモノトスル。
◎
Otherwise, the user agent may instead offer to open resource in a new top-level browsing context or in the top-level browsing context of the source browsing context, at the user's option, in which case the user agent must navigate that designated top-level browsing context to resource as if the user had requested it independently.
</p>

<p class="note">注記：
しかしながら，そうすることは、危険にもなり得る
— それは、利用者が［
作者による，内容を~sandbox化する明示的な要請
］を上書きすることを意味するので。
◎
Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.
</p>

<p class="trans-note">【
選択肢を提供しない場合、（原文の “`instead^en” を “`SecurityError^E の代わりに” と解釈するなら）最初の段と同じく `SecurityError$E になると見受けられる。
】</p>

			</li>
		</ol>
	</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれも満たすような，［
%B を~navigateしようとする在来の %試み
］がある
］…：
</p>

<ul><li>%試み における`~source閲覧文脈$ ~EQ %B
</li><li>%試み は `文書を~unloadする$~algoを現在~走らせている
</li></ul>

<p>
…ならば
⇒
~RET
— %試み やそれが走らせている~algoは、影響されない。
</p>

◎
If there is a preexisting attempt to navigate browsingContext, and the source browsing context is the same as browsingContext, and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.
</li>
	<li>
~IF［
%文書 に対し，`文書の~unloadを~promptする$~algoが走っている
］
⇒
~RET
— その~algoは、影響されない。
◎
If the prompt to unload algorithm is being run for the active document of browsingContext, then return without affecting the prompt to unload algorithm.
</li>
	<li id="navigate-fragid-step">
<p>
~IF［
`履歴~取扱い$V ~NEQ `再読込み$i
］~AND［
%資源 は`要請$である
］：
◎
If historyHandling is not "reload", resource is a request,＼
</p>
		<ol>
			<li>
%~URL ~LET %資源 の`~URL$rq
◎
↓</li>
			<li>
~IF［
( %~URL, %文書 の`~URL$doc ) は `素片は除外する^i 下で`同等な~URL$である
］
⇒
~IF［
%~URL の`素片$url ~NEQ ~NULL
］
⇒＃
`素片へ~navigateする$( %B, %~URL, `履歴~取扱い$V )；
~RET
◎
resource's url equals browsingContext's active document's URL with exclude fragments flag set, and resource's url's fragment is non-null, then:
• Navigate to that fragment given historyHandling.
• Return.
</li>
		</ol>
	</li>
	<li>
%作動中の文書~navi生成元 ~LET %B にて`作動中の文書$の`生成元$
◎
Let activeDocumentNavigationOrigin be the origin of the active document of browsingContext.
</li>
	<li>
%現任の~navi生成元 ~LET %~navi に孕まれる `script$e 要素が［
在るならば `現任の設定群~obj$の`生成元$ ／
無いならば %~navi を起動した要素の`~node文書$の`生成元$
］
◎
Let incumbentNavigationOrigin be the origin of the incumbent settings object, or if no script was involved, the origin of the node document of the element that initiated the navigation.
</li>
	<li>
<p>
%B を~navigateしようとする在来の
~EACH( %試み )
に対し：
</p>
		<ol>
			<li>
~IF［
%試み はすでに`成熟-$している
］
⇒
~CONTINUE
</li>
			<li>
%試み を取消す
— %試み により開始された`~fetch$ ~algoの~instanceも含めて
</li>
			<li>
~IF［
%試み は，すでに新たな`文書$を`作成して初期化-$した
］
⇒
`文書を中止する$( その文書 )
</li>
		</ol>

<p>
（`成熟-$した %試み に対しては、`~session履歴~entry$がすでにあるので，後で`新たな~pageで~session履歴を更新する$~algoの中で取扱われる。）
</p>

◎
Cancel any preexisting but not yet mature attempt to navigate browsingContext, including canceling any instances of the fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document object, abort that Document also. (Navigation attempts that have matured already have session history entries, and are therefore handled during the update the session history with the new page algorithm, later.)
</li>
	<li>
<p>
`文書の~unloadを~promptする$( %文書 )
⇒
~IF［
%文書 の`~unloadは利用者から拒否された$
］
⇒
~RET
◎
Prompt to unload the active document of browsingContext. If the user refused to allow the document to be unloaded, then return.
</p>

<p>
この段を走らせている間に %~navi が取消されたとしても、`文書の~unloadを~promptする$~algoは，完了するモノトスル。
◎
If this instance of the navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.
</p>
	</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort the active document of browsingContext.
</li>
	<li>
<p>
~IF［
%B は`子~閲覧文脈$である
］：
</p>
		<ol>
			<li>
%B の`~load~event遅延-中$ ~SET ~T
</li>
			<li>
後に %~navi が［
`成熟-$した ／ 
すべて走らせ終えた ／
取消された ／
中止された
］時点
— いずれかが最初に生じた時点 —
で，次を走らすようにしておく
⇒
%B の`~load~event遅延-中$ ~SET ~F
</li>
		</ol>

◎
If browsingContext is a child browsing context, then put it in the delaying load events mode.
◎
The user agent must take this child browsing context out of the delaying load events mode when this navigation algorithm later matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.
</li>
	<li>
%~navi種別 ~LET ［
%~navi は`~form提出$~algoの結果として呼出されたならば `form-submission^l ／
~ELSE_ `other^l
］
◎
Let navigationType be "form-submission" if the navigation algorithm was invoked as a result of the form submission algorithm, and "other" otherwise.
</li>
	<li>
%~sandbox~flags ~LET `作成時の~sandbox法~flagsを決定する$( %B, %B の`容器$bc )
◎
Let sandboxFlags be the result of determining the creation sandboxing flags given browsingContext and browsingContext's container.
</li>
	<li>
~RET
— ただし、以降の手続きは`並列的$に継続する。
それは、必要とされるなら %資源 を得しようと試みる。
◎
Return to whatever algorithm invoked the navigation steps and continue running these steps in parallel.
◎
This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:
</li>
	<li>
<p>
~IF［
%資源 は`応答$である
］：
◎
If resource is a response
</p>
		<ol>
			<li>
~Assert：
%B は`~top-level閲覧文脈$でない。
◎
Assert: browsingContext is not a top-level browsing context.
</li>
			<li>
%最終-~sandbox~flags ~LET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%資源 の`強制d~sandbox法~flag集合$
◎
Let finalSandboxFlags be the union of browsingContext's sandboxing flags and resource's forced sandboxing flag set.
</li>
			<li>
%応答~生成元 ~LET `生成元を決定する$( 次に挙げる引数 )
⇒＃
%B,
%資源 の`~URL$rs,
%最終-~sandbox~flags,
%現任の~navi生成元,
%作動中の文書~navi生成元
◎
Let responseOrigin be the result of determining the origin given browsingContext, resource's url, finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.
</li>
	<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET %資源,
`生成元$nvP ~SET %応答~生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET `unsafe-none$l,
`予約-済み環境$nvP ~SET ~NULL,
`閲覧文脈$nvP ~SET %B,
`閲覧文脈の切替nが必要$nvP ~SET ~F
`履歴~取扱い$nvP ~SET `履歴~取扱い$V
◎
Let navigationParams be a new navigation params whose request is null, response is resource, origin is responseOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is "unsafe-none", reserved environment is null, browsing context is browsingContext, browsing context switch needed is false, and history handling is historyHandling.
</li>
	<li>
`~navigate応答を処理する$( %~navi種別, %S, %~navi~params )
◎
Run process a navigate response with navigationType, the source browsing context, and navigationParams.
</li>
			<li>
~RET
◎
↓</li>
		</ol>
	</li>
	<li>
~Assert：
%資源 は`要請$である。
【この段は訳者による補完】
◎
↓</li>
	<li>
%~scheme ~LET %資源 の`~URL$rqの`~scheme$url
◎
↓</li>
	<li>
<p>
~IF［
%~scheme ~EQ `javascript$l
］：
◎
If resource is a request whose url's scheme is "javascript"
</p>
		<ol>
			<li>
<p>
次の手続きを走らす`大域~taskを~queueする$( `~DOM操作~task源$, %B にて`作動中の~window$ )：
◎
Queue a global task on the DOM manipulation task source given browsingContext's active window to run these steps:
</p>
				<ol>
					<li>
%応答 ~LET `~javascript_$sc ~URLによる要請を実行する( %資源, %S, %B )
◎
Let response be the result of executing a javascript: URL request given resource, the source browsing context, and browsingContext.
</li>
					<li>
%最終-~sandbox~flags ~LET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%応答 の`強制d~sandbox法~flag集合$
◎
Let finalSandboxFlags be the union of browsingContext's sandboxing flags and response's forced sandboxing flag set.
</li>
					<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET %資源,
`応答$nvP ~SET %応答,
`生成元$nvP ~SET %作動中の文書~navi生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET %B の`作動中の文書$の`非同一-生成元~opener施策$doc,
`予約-済み環境$nvP ~SET ~NULL,
`閲覧文脈$nvP ~SET %B,
`閲覧文脈の切替nが必要$nvP ~SET ~F,
`履歴~取扱い$nvP ~SET `履歴~取扱い$V
◎
Let navigationParams be a new navigation params whose request is resource, response is response, origin is activeDocumentNavigationOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is browsingContext's active document's cross-origin opener policy, reserved environment is null, browsing context is browsingContext, browsing context switch needed is false, and history handling is historyHandling.
</li>
					<li>
`~navigate応答を処理する$( %~navi種別, %S, %~navi~params )
◎
Run process a navigate response with navigationType, the source browsing context, and navigationParams.
</li>
				</ol>

<p class="example">
よって，例えば `a$e 要素の `href$a 属性に対する `~javascript_$sc ~URLが評価されるのは、その`~hyperlinkを追う$ときに限られることになる。
一方で、 `iframe$e 要素 %E の `~src-iframe$a 属性における その種の~URLは、
%E が設定しておかれるときに， %E が`入子にしている閲覧文脈$ %C の文脈~下で評価される。
結果の返り値が文字列であったなら，
%C にて`作動中の文書$を置換する（したがって %C に対応している`~window$も変更する）ことになる。
◎
So for example a javascript: URL in an href attribute of an a element would only be evaluated when the link was followed, while such a URL in the src attribute of an iframe element would be evaluated in the context of the iframe's nested browsing context when the iframe is being set up. Once evaluated, its return value (if it was a string) would replace that browsing context's active document, thus also changing the corresponding Window object.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELIF …
【`~app~cache用$の条件と処理】
◎
If resource is to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is fast, and the user agent is not in a mode where it will avoid using application caches
• Fetch resource from the most appropriate application cache of those that match.
• For example, imagine an HTML page with an associated application cache displaying an image and a form, where the image is also used by several other application caches. If the user right-clicks on the image and chooses "View Image", then the user agent could decide to show the image from any of those caches, but it is likely that the most useful cache for the user would be the one that was used for the aforementioned HTML page. On the other hand, if the user submits the form, and the form does a POST submission, then the user agent will not use an application cache at all; the submission will be made to the network.
• This still needs to be integrated with the Fetch standard. [FETCH]
</li>
	<li>
~ELIF［
%~scheme は`~fetch~scheme$である
］
⇒
`~navigate~fetchを処理する$( 次に挙げる引数 )
⇒＃
%資源,
%S,
%B,
%~navi種別,
%~sandbox~flags,
%現任の~navi生成元,
%作動中の文書~navi生成元,
`履歴~取扱い$V
◎
If resource is a request whose url's scheme is a fetch scheme
• Run process a navigate fetch given resource, the source browsing context, browsingContext, navigationType, sandboxFlags, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling.
</li>
	<li>
~ELSE
⇒
`~navigate~URL~schemeを処理する$( %資源 の`~URL$rq, %B )
◎
Otherwise, resource is a request whose url's scheme is neither "javascript" nor a fetch scheme
• Run process a navigate URL scheme given resource's url and browsingContext.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate~fetchを処理する@
ときは、所与の
⇒＃
`要請$ %要請,
`~source閲覧文脈$ %S,
`閲覧文脈$ %B,
文字列 %~navi種別,
`~sandbox法~flag集合$ %~sandbox~flags
`生成元$ %現任の~navi生成元,
`生成元$ %作動中の文書~navi生成元,
`履歴を取扱うときの挙動$ %履歴~取扱い
◎終
に対し，次を走らす：
◎
To process a navigate fetch, given a request request, two browsing contexts sourceBrowsingContext and browsingContext, a string navigationType, a sandboxing flag set sandboxFlags, two origins incumbentNavigationOrigin and activeDocumentNavigationOrigin, and a history handling behavior historyHandling:
</p>

<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%要請 の
⇒＃
`~client$rq ~SET %S にて`作動中の文書$に`関連な設定群~obj$,
`行先$rq ~SET `document^l,
`~mode$rq ~SET `navigate^l,
`資格証~mode$rq ~SET `include^l,
`~URL資格証~利用~flag$rq ~SET ~T,
`~redirect~mode$rq ~SET `manual^l,
`置換する~client~id$rq ~SET %B にて`作動中の文書$に`関連な設定群~obj$の`~id$enV
◎
Set request's client to sourceBrowsingContext's active document's relevant settings object, destination to "document", mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and replaces client id to browsingContext's active document's relevant settings object's id.
</li>
	<li>
<p>
~IF［
%B の`容器$bc %容器 ~NEQ ~NULL
］：
◎
If browsingContext's container is non-null:
</p>
		<ol>
			<li>
~IF［
%容器 の`閲覧文脈~視野~生成元$ %O ~NEQ ε
］
⇒
%要請 の`生成元$rq ~SET %O
◎
If the browsingContext's container has a browsing context scope origin, then set request's origin to that browsing context scope origin.
</li>
			<li>
%要請 の`行先$rq ~SET %容器 の`局所~名$
◎
Set request's destination to browsingContext's container's local name.
</li>
		</ol>
	</li>
	<li>
%予約-済み環境 ~LET ~NULL
◎
Let reservedEnvironment be null.
</li>
	<li>
%応答~生成元 ~LET ~NULL
◎
Let responseOrigin be null.
</li>
	<li>
%~COOP施行~結果 ~LET 次のようにされた新たな`非同一-生成元~opener施策の施行~結果$
⇒＃
`閲覧文脈~groupの切替nが必要$cooP ~SET ~F,
`生成元$cooP ~SET %B にて`作動中の文書$の`生成元$,
`非同一-生成元~opener施策$cooP ~SET %B にて`作動中の文書$の`非同一-生成元~opener施策$doc
◎
Let coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context group switch is false, origin is browsingContext's active document's origin, and cross-origin opener policy is browsingContext's active document's cross-origin opener policy.
</li>
	<li>
%最終-~sandbox~flags ~LET 空な`~sandbox法~flag集合$
◎
Let finalSandboxFlags be an empty sandboxing flag set.
</li>
	<li>
%応答~COOP ~LET `unsafe-none$l
◎
Let responseCOOP be "unsafe-none".
</li>
	<li>
<p id="navigate-redirect-step">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%現在の~URL ~LET ［
%応答 ~NEQ ~NULL ならば %応答 の`~Location~header~URL$rs ／
~ELSE_ %要請 の`現在の~URL$rq
］
◎
Let currentURL be response's location URL, if response is not null, and request's current URL otherwise.
</li>
			<li>
<p>
~IF［
%予約-済み環境 ~NEQ ~NULL
］~AND［
( %現在の~URL の`生成元$url, %予約-済み環境 の`作成時の~URL$enVの`生成元$url )
は`同一-生成元$でない
］：
◎
If reservedEnvironment is not null and currentURL's origin is not the same as reservedEnvironment's creation URL's origin, then:
</p>
				<ol>
					<li>
%予約-済み環境 用に`環境を破棄する手続き$を走らす
◎
Run the environment discarding steps for reservedEnvironment.
</li>
					<li>
%予約-済み環境 ~SET ~NULL
◎
Set reservedEnvironment to null.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%予約-済み環境 ~EQ ~NULL
］：
◎
If reservedEnvironment is null, then:
</p>
				<ol>
					<li>
%~top-level作成時の~URL ~LET %現在の~URL
◎
Let topLevelCreationURL be currentURL.
</li>
					<li>
%~top-level生成元 ~LET ~NULL
◎
Let topLevelOrigin be null.
</li>
					<li>
<p>
~IF［
%B は`~top-level閲覧文脈$でない
］：
◎
If browsingContext is not a top-level browsing context, then:
</p>
						<ol>
							<li>
%親~環境 ~LET %B の`容器$bcに`関連な設定群~obj$
◎
Let parentEnvironment be browsingContext's container's relevant settings object.
</li>
							<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL＼
</li>
							<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
and topLevelOrigin to parentEnvironment's top-level origin.
</li>
						</ol>
					</li>
					<li>
<p>
%予約-済み環境 ~SET 次のようにされた新たな`環境$
⇒＃
`~id$enV ~SET 一意かつ不透明な文字列,
`~target閲覧文脈$enV ~SET %B,
`作成時の~URL$enV ~SET %現在の~URL,
`~top-level作成時の~URL$enV ~SET %~top-level作成時の~URL,
`~top-level生成元$enV ~SET %~top-level生成元
◎
Set reservedEnvironment to a new environment whose id is a unique opaque string, target browsing context is browsingContext, creation URL is currentURL, top-level creation URL is topLevelCreationURL, and top-level origin is topLevelOrigin.
</p>

<p class="note">注記：
ここで作成した環境の`作動中の~sw$enVは、要請~URLが~sw登録に合致するならば，~fetchの間に
<a href="~SW1#on-fetch-request-algorithm">~fetchを取扱う~algo</a>の中で設定される。
`SW$r
◎
The created environment's active service worker is set in the Handle Fetch algorithm during the fetch if the request URL matches a service worker registration. [SW]
</p>
					</li>
				</ol>
			</li>
			<li>
%要請 の`予約-済み~client$rq ~SET %予約-済み環境
◎
Set request's reserved client to reservedEnvironment.
</li>
			<li>
~IF［
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, %~navi種別, %S, %B )
`CSP$r
の結果 ~EQ `阻止される^i
］
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
If the Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, navigationType, sourceBrowsingContext, and browsingContext, then set response to a network error and break. [CSP]
</li>
			<li>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET %要請 を用いて`~fetch$した結果
◎
Otherwise:
◎
If response is null, fetch request.
</li>
			<li>
~ELSE
⇒
%応答 ~SET `~HTTP~redirect~fetch$( %要請, %応答 ) を遂行した結果
◎
Otherwise, perform HTTP-redirect fetch using request and response.
</li>
			<li>
`~network用~task源$上の［
%応答 に対し`応答を処理する$
］`~task$を待機する
◎
Wait for the task on the networking task source to process response and set response to the result.
</li>
			<li>
%最終-~sandbox~flags ~SET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%応答 の`強制d~sandbox法~flag集合$
◎
Set finalSandboxFlags to the union of browsingContext's sandboxing flags and response's forced sandboxing flag set.
</li>
			<li>
%応答~生成元 ~SET `生成元を決定する$( 次に挙げる引数 )
⇒＃
%B,
%要請 の`~URL$rq,
%最終-~sandbox~flags,
%現任の~navi生成元,
%作動中の文書~navi生成元
◎
Set responseOrigin to the result of determining the origin given browsingContext, request's url, finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.
</li>
			<li>
<p>
~IF［
%B は`~top-level閲覧文脈$である
］：
◎
If browsingContext is a top-level browsing context, then:
</p>
				<ol>
					<li>
%応答~COOP ~SET `非同一-生成元~opener施策を得する$( %応答, %予約-済み環境 )
◎
Set responseCOOP to the result of obtaining a cross-origin opener policy given response and reservedEnvironment.
</li>
					<li>
<p>
~IF［
%~sandbox~flags は空でない
］~AND［
%応答~COOP ~NEQ `unsafe-none$l
］
⇒＃
%応答 ~SET 適切な`~network~error$；
~BREAK
◎
If sandboxFlags is not empty and responseCOOP is not "unsafe-none", then set response to an appropriate network error and break.
</p>

<p class="note">注記：
この結果は~network~errorになる
— 非同一-生成元~opener施策を利用している応答に対し，［
白紙状態を供すること,
その応答へ~navigateした結果を~sandbox化すること
］は、両立し得ないので。
◎
This results in a network error as one cannot simultaneously provide a clean slate to a response using cross-origin opener policy and sandbox the result of navigating to that response.
</p>
					</li>
					<li>
%~COOP施行~結果 ~SET `応答の非同一-生成元~opener施策を施行する$( %B, %応答~生成元, %応答~COOP, %~COOP施行~結果 )
◎
Set coopEnforcementResult to the result of enforcing the response's cross-origin opener policy given browsingContext, responseOrigin, responseCOOP, and coopEnforcementResult.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%B は`子~閲覧文脈$である
］：
◎
If response is not a network error, browsingContext is a child browsing context,＼
</p>
				<ol>
					<li>
%容器 ~LET %B の`容器~文書$
◎
↓</li>
					<li>
~IF［
`非同一-生成元~資源~施策~検査$( %容器 の`生成元$, %容器 に`関連な設定群~obj$, %要請 の`行先$rq, %応答, ~T )
~EQ `阻止される^i
］
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
and the result of performing a cross-origin resource policy check with browsingContext's container document's origin, browsingContext's container document's relevant settings object, request's destination, response, and true is blocked, then set response to a network error and break.
</li>
				</ol>

<p class="note">注記：
ここでは
— ~naviの`~source閲覧文脈$（ %S ）ではなく —
%B の`親~閲覧文脈$に対し，埋込まれた内容が同一-生成元かどうか~careするので、
%容器 に対し，`非同一-生成元~資源~施策~検査$を走らす。
◎
Here we're running the cross-origin resource policy check against the parent browsing context rather than sourceBrowsingContext. This is because we care about the same-originness of the embedded content against the parent context, not the navigation source.
</p>
			</li>
			<li>
~IF［
%応答 の`~Location~header~URL$rsは`~URL$であって，その`~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~CONTINUE
◎
If response does not have a location URL or the location URL is not a URL whose scheme is an HTTP(S) scheme, then break.
</li>
			<li>
~BREAK
◎
↑</li>
		</ol>

<p class="note">注記：
~naviは、~redirectを手動で取扱う。
~naviが、~web~platformにおいて `~mailto_$sc の類の~URLへの~redirectを~careする唯一の箇所なので。
◎
Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.
</p>

	</li>
	<li>
%所在 ~LET %応答 の`~Location~header~URL$rs
◎
↓</li>
	<li>
~IF［
%所在 ~EQ `失敗^i
］
⇒
%応答 ~SET `~network~error$
◎
If response has a location URL that is failure, then set response to a network error.
</li>
	<li>
<p>
~ELIF［
%所在 は`~URL$である
］
⇒
%所在 の`~scheme$url に応じて：
</p>
		<dl class="switch">
			<dt>`blob^l</dt>
			<dt>`file^l</dt>
			<dt>`filesystem^l</dt>
			<dt>`javascript^l</dt>
			<dd>
%応答 ~SET `~network~error$
</dd>

			<dt>`~fetch~scheme$である</dt>
			<dd>
				<ol>
					<li>
%新~要請 ~LET 新たな`要請$
</li>
					<li>
%新~要請 の`~URL$rq ~SET %所在
</li>
					<li>
`~navigate~fetchを処理する$( 次に挙げる引数 )
⇒＃
%新~要請,
%S,
%B,
%~navi種別,
%~sandbox~flags,
%現任の~navi生成元,
%作動中の文書~navi生成元,
%履歴~取扱い
</li>
					<li>
~RET
</li>
				</ol>
			</dd>

			<dt>その他</dt>
			<dd>
				<ol>
					<li>
`~navigate~URL~schemeを処理する$( %所在, %B )
</li>
					<li>
~RET
</li>
				</ol>
			</dd>
		</dl>

◎
Otherwise, if response has a location URL that is a URL whose scheme is "blob", "file", "filesystem", or "javascript", then set response to a network error.
◎
Otherwise, if response has a location URL that is a URL whose scheme is a fetch scheme, then run process a navigate fetch with a new request whose url is response's location URL, sourceBrowsingContext, browsingContext, navigationType, sandboxFlags, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling, and return.
◎
Otherwise, if response has a location URL that is a URL, run the process a navigate URL scheme given response's location URL and browsingContext, and return.
</li>
	<li>
【`~app~cache用$の処理】
◎
Fallback in prefer-online mode: If response was not fetched from an application cache, and was to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is prefer-online, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the response identified by the URL in question from the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The user agent may indicate to the user that the original page load failed, and that the page used was a previously cached response.
◎
Fallback for fallback entries: If response was not fetched from an application cache, and was to be fetched using `GET`, and its URL matches the fallback namespace of one or more relevant application caches, and the most appropriate application cache of those that match does not have an entry in its online safelist that has the same origin as response's URL and that is a prefix match for response's URL, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the fallback response specified for the fallback namespace in question. If multiple application caches match, the user agent must use the fallback of the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The document's URL, if appropriate, will still be the originally requested URL, not the fallback URL, but the user agent may indicate to the user that the original page load failed, that the page used was a fallback response, and what the URL of the fallback response actually is.
</li>
	<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET %要請,
`応答$nvP ~SET %応答,
`生成元$nvP ~SET %応答~生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET %応答~COOP,
`予約-済み環境$nvP ~SET %予約-済み環境,
`閲覧文脈$nvP ~SET %B,
`閲覧文脈の切替nが必要$nvP ~SET %~COOP施行~結果 の`閲覧文脈~groupの切替nが必要$cooP,
`履歴~取扱い$nvP ~SET %履歴~取扱い
◎
Let navigationParams be a new navigation params whose request is request, response is response, origin is responseOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is responseCOOP, reserved environment is reservedEnvironment, browsing context is browsingContext, browsing context switch needed is coopEnforcementResult's needs a browsing context group switch, and history handling is historyHandling.
</li>
	<li>
`~navigate応答を処理する$( %~navi種別, %S, %~navi~params )
◎
Run process a navigate response with navigationType, the source browsing context, and navigationParams.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate応答を処理する@
ときは、所与の
( 文字列 %~navi種別, `閲覧文脈$ %S, `~navi~params$ %~navi~params )
に対し，次を走らす：
◎
To process a navigate response, given a string navigationType, a browsing context source, and a navigation params navigationParams:
</p>
<ol>
	<li>
%応答 ~LET %~navi~params の`応答$nvP
◎
Let response be navigationParams's response.
</li>
	<li>
%B ~LET %~navi~params の`閲覧文脈$nvP
◎
Let browsingContext be navigationParams's browsing context.
</li>
	<li>
<p>
%失敗 ~LET 次の下位手続きを走らせた結果：
◎
Let failure be false.
</p>
		<ol>
			<li>
~IF［
%応答 は`~network~error$である
］
⇒
~RET ~T
◎
If response is a network error, then set failure to true.
</li>
			<li>
~IF［
`~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？$( %~navi~params の`要請$nvP, %~navi種別, %応答, %S, %B )
【！原文は %~navi種別, %応答 の順序が逆】
~EQ `阻止される^i
］
`CSP$r
⇒
~RET ~T
◎
Otherwise, if the result of should navigation response to navigation request of type from source in target be blocked by Content Security Policy? given navigationParams's request, response, navigationType, source, and browsingContext is "Blocked", then set failure to true. [CSP]
</li>
			<li>
~IF［
`~navi応答の埋込元~施策に対する固守を検査する$( %応答, %B ) ~EQ ~F
］
⇒
~RET ~T
◎
Otherwise, if the result of checking a navigation response's adherence to its embedder policy given response and browsingContext is false, then set failure to true.
</li>
			<li>
~IF［
`~navi応答の~X-Frame-Optionsに対する固守を検査する$( %応答, %B, %~navi~params の`生成元$nvP ) ~EQ ~F
］
⇒
~RET ~T
◎
Otherwise, if the result of checking a navigation response's adherence to `X-Frame-Options` given response, browsingContext, and navigationParams's origin is false, then set failure to true.
</li>
			<li>
~RET ~F
◎
↑↑</li>
		</ol>
	<li>
<p>
~IF［
%失敗 ~EQ ~T
］：
◎
If failure is true, then:
</p>
			<ol>
				<li>
`~inline内容を表示する$( %B )
◎
Display the inline content with an appropriate error shown to the user given browsingContext.
</li>
				<li>
%~navi~params の`予約-済み環境$nvP用に`環境を破棄する手続き$を走らす
◎
Run the environment discarding steps for navigationParams's reserved environment.
</li>
				<li>
~RET
◎
Return.
</li>
			</ol>

<p class="note">注記：
`Fetch^cite `FETCH$r
により定義される~network~error
— ~DNSや~TLS ~errorなど —
が伝播される所は，ここであり、利用者に表示されることになる。
◎
This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to users. [FETCH]
</p>
	</li>
	<li>
~IF［
%応答 の`状態s$rs ~IN { `204$hst, `205$hst }
］
⇒
~RET
◎
If response's status is 204 or 205, then return.
</li>
	<li>
<p>
~IF［
%応答 内に `Content-Disposition$h ~headerがあって，それは
`attachment^c ~disposition型を指定している
］：
◎
If response has a `Content-Disposition` header specifying the attachment disposition type, then:
</p>
		<ol>
			<li>
~IF［
`~downloadは許容される$( %S, %B ) ~EQ ~T
］
⇒
%応答 を`~downloadとして$取扱う
◎
If the result of running the allowed to download given source and browsingContext is true, then handle response as a download.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<dfn id="_computed-mime-type">%~MIME型</dfn>
~LET %応答 から`算出される~MIME型$
◎
Let type be the computed type of response.
</li>
	<li>
~IF［
~UAは［
%~MIME型 の資源に対しては［
`閲覧文脈$内に内容を具現化する以外の何らかの仕組み
］を利用して処理する
］ように環境設定されている
］
⇒
~GOTO `非~文書~内容として取扱う$i
◎
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step.＼
</li>
	<li>
<p>
%~page読込n手続き ~LET %~MIME型 に応じて：
◎
Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:
</p>
		<dl class="switch">
			<dt>
`~HTML~MIME型$
◎
an HTML MIME type
</dt>
			<dd>
<a href="#read-html">§ ~HTML文書</a>
に与える手続き
【！#navigate-html】
◎
Follow the steps given in the HTML document section providing navigationParams. Once the steps have completed, return.
</dd>
			<dt>
`~XML~MIME型$であって, `明示的に~supportされる~XML~MIME型$でない
◎
an XML MIME type that is not an explicitly supported XML MIME type
</dt>
			<dd>
<a href="#read-xml">§ ~XML文書</a>
に与える手続き
◎
Follow the steps given in the XML document section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>
`~JS~MIME型$
◎
a JavaScript MIME type
</dt>
			<dt>
`~JSON~MIME型$であって, `明示的に~supportされる~JSON~MIME型$でない
◎
a JSON MIME type that is not an explicitly supported JSON MIME type
</dt>
			<dt>`text/cache-manifest$c</dt>
			<dt>`text/css$c</dt>
			<dt>`text/plain$c</dt>
			<dt>`text/vtt$c</dt>
			<dd>
<a href="#read-text">§ 素な~text~file</a>
に与える手続き
◎
Follow the steps given in the plain text file section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>`multipart/x-mixed-replace$c</dt>
			<dd>
<a href="#read-multipart-x-mixed-replace">§ `multipart/x-mixed-replace^c</a>
に与える手続き
◎
Follow the steps given in the multipart/x-mixed-replace section providing navigationParams. Once the steps have completed, return.
</dd>
			<dt>
~supportされる［
画像 ／ 動画 ／ 音声
］型
◎
A supported image, video, or audio type
</dt>
			<dd>
<a href="#read-media">§ ~media</a>
に与える手続き
◎
Follow the steps given in the media section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>
内容を %B 内に具現化するときに外部~appを利用するような型
◎
A type that will use an external application to render the content in browsingContext
</dt>
			<dd>
<a href="#read-plugin">§ ~plugin</a>
に与える手続き
◎
Follow the steps given in the plugin section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>その他</dt>
			<dd>
ε
◎
↓</dd>
		</dl>
<p>
上の~~目的においては：
◎
↓</p>
		<ul>
			<li>
<p>
次に該当する`~XML~MIME型$は、
`明示的に~supportされる~XML~MIME型@
とされる：
◎
An explicitly supported XML MIME type is an XML MIME type＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに，外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような`~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの（例： 組込みの Atom ~feed-viewerを備える~web~browserは `application/atom+xml$c ~MIME型を明示的に~supportするとされる）
◎
one for which the user agent has dedicated processing rules (e.g., a web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type), or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
			<li>
<p>
次に該当する`~JSON~MIME型$は、
`明示的に~supportされる~JSON~MIME型@
とされる：
◎
An explicitly supported JSON MIME type is a JSON MIME type＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような `~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの
◎
one for which the user agent has dedicated processing rules, or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%~page読込n手続き ~NEQ ε
］：
</p>
		<ol>
			<li>
%~page読込n手続き( %~navi~params, %~MIME型 )
</li>
			<li>
前~段が完了するまで待機する
</li>
			<li>
~RET
</li>
		</ol>
◎
↑</li>
	<li>
<p>
`非~文書~内容として取扱う@i：
◎
Non-document content:＼
</p>
		<ol>
			<li>
<p>
~IF［
~UAは、 %~MIME型 の資源を何らかの~inline内容として表示する
］
⇒
%資源 による`~inline内容を表示する$( %B )
</p>

<p class="example">
例えば、次に該当するとき
⇒＃
~UAは、 %資源 の内容を~nativeに具現化する／
%~MIME型 は~supportされないことを示す~error~message
</p>
◎
If, given type, the new resource is to be handled by displaying some sort of inline content,＼
e.g., a native rendering of the content or an error message because the specified type is not supported, then＼
display the inline content given browsingContext, and then return.
</li>
			<li>
<p>
~ELSE（ %~MIME型 の資源は %B に影響しない ）
⇒
%資源 を
<a href="#hand-off-to-external-software">適切に処理する</a>
</p>

<p class="example">
例えば、次に該当するとき
⇒＃
%資源 を外部~appに手渡す／
%資源 は未知な型であり，`~downloadとして$処理する
</p>
◎
Otherwise, the document's type is such that the resource will not affect browsingContext,＼
e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed as a download.＼
Process the resource appropriately.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate~URL~schemeを処理する@
ときは、所与の
( `~URL$ %~url, `閲覧文脈$ %B )
に対し，次を走らす：
◎
To process a navigate URL scheme, given a URL url and browsing context browsingContext, run these steps:
</p>

<ol>
	<li>
~IF［
%~url は［
%B に影響しない仕組みを利用して取扱われるもの
］である（ %~url の`~scheme$urlは外部的に取扱われるものである）
］
⇒
~RET
— 代わりに，<a href="#hand-off-to-external-software">その仕組みを続行する</a>
◎
If url is to be handled using a mechanism that does not affect browsingContext,＼
e.g., because url's scheme is handled externally, then＼
proceed with that mechanism instead.
</li>
	<li>
<p>
~ELSE（ %~url は、何らかの~inline内容を表示して取扱われるものである）
⇒
その`~inline内容を表示する$( %B )
◎
Otherwise, url is to be handled by displaying some sort of inline content,＼
e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme.＼
Display the inline content given browsingContext.
</p>

<p class="example">
例えば
⇒＃
指定された~schemeは~supportされる~protocolでないことを示す~error~message／
利用者が 所与の~scheme用の`登録-済み~handler$を選定できるようにするための~inline~prompt
◎
↑</p>

<p class="note">注記：
登録-済み~handlerが利用されている事例では、`~navigate$は，新たな~URLで再び呼出されることになる。
◎
In the case of a registered handler being used, navigate will be invoked with a new URL.
</p>
	</li>
</ol>
</div>

<p>
~UAは、資源の［
~URL／~data
］を
<dfn id="hand-off-to-external-software">外部~software~packageに取扱わせる</dfn>
ときは（例： `~mailto_$sc ~URLを~mail~clientに手渡す ／ Word 文書をそれ用の処理器に手渡すなど）：
◎
When a resource is handled by passing its URL or data to an external software package separate from the user agent＼
(e.g. handing a mailto: URL to a mail client, or a Word document to a word processor),＼
</p>

<ul>
	<li>
対象の~softwareを悪用しようと試みる~riskを軽減するよう試みるベキである。
例えば［
`~source閲覧文脈$にて`作動中の文書$の`生成元$には、指定された~softwareを呼出すことは許容される
］かどうか，利用者に確認するよう~promptするなどにより。
◎
user agents should attempt to mitigate the risk that this is an attempt to exploit the target software, e.g. by prompting the user to confirm that the source browsing context's active document's origin is to be allowed to invoke the specified software.＼
</li>
	<li>
特に，`~navigate$~algoが［
`~source閲覧文脈$にて`作動中の~window$の`一過な作動化$ ~EQ ~F
］のときに呼出された場合、~UAは
— 前もって利用者に確認をとることなく —
外部~software~packageを呼出すベキでない。
◎
In particular, if the navigate algorithm was invoked when source browsing context's active window does not have transient activation, the user agent should not invoke the external software package without prior user confirmation.
</li>
</ul>

<p class="example">
例えば，~target~softwareの~URL~handler内には、［
ある敵対的~pageが，~linkを~clickするよう利用者を騙す
］ように悪用できる脆弱性があるかもしれない。
◎
For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
</p>

<div class="algo">
<p>
`~javascript_@sc
~URLによる要請を実行するときは、所与の
( `要請$ %要請, %S, %B )
に対し，次を走らす：
◎
To execute a javascript: URL request, given a request request and two browsing contexts source and browsingContext, run these steps:
</p>

<ol id="concept-js-deref">
	<li>
%応答 ~LET 次のようにされた新たな`応答$
⇒
`状態s$rs ~SET `204$hst
◎
Let response be a response whose status is 204.
</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次の両者とも満たされる
］…：
◎
If both of the following are true:
</p>
		<ul>
			<li>
<p>
( %S にて`作動中の文書$の`生成元$, %文書 の`生成元$ )
は`同一-生成元$である
◎
source's active document's origin is same origin with browsingContext's active document's origin.
</p>

<p class="XXX">
<a href="~HTMLissue/2591">課題 #2591</a>
にて説明されるように、この段は働かないため，~securityの課題がある。
◎
As explained in issue #2591 this step does not work and presents a security issue.
</p>
			</li>
			<li>
次の結果 ~EQ `許容される^i
⇒
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, `other^l, %S, %B )
`CSP$r
◎
The Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Allowed" when executed upon request, "other", source, and browsingContext. [CSP]
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%~script~source ~LET `~URLを直列化する$( %要請 の`~URL$rq )
◎
Let urlString be the result of running the URL serializer on request's url.
</li>
			<li>
%~script~source ~SET %~script~source から先頭の `javascript:^l を除去した結果
◎
Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.
</li>
			<li>
%~script~source ~SET `文字列を~byte列に~percent-復号する$( %~script~source )
◎
Let scriptSource be the UTF-8 decoding of the percent-decoding of encodedScriptSource.
</li>
			<li>
%~script~source ~SET `~UTF-8復号する$( %~script~source )
◎
↑</li>
			<li>
%文書 の`~URL$docを %要請 の`~URL~list$rqに付加する
◎
Append browsingContext's active document's URL to request's URL list.
</li>
			<li>
%設定群 ~LET %文書 に`関連な設定群~obj$
◎
Let settings be browsingContext's active document's relevant settings object.
</li>
			<li>
%~script ~LET
`古典~scriptを作成する$( 次に挙げる引数 )
⇒＃
%~script~source,
%設定群,
%設定群 の`~API用~基底~URL$enV,
`既定の古典~script~fetch~options$
◎
Let baseURL be settings's API base URL.
◎
Let script be the result of creating a classic script given scriptSource, settings, baseURL, and the default classic script fetch options.
</li>
			<li>
%評価~状態s ~LET `古典~scriptを走らす$( %~script )
◎
Let evaluationStatus be the result of running the classic script script.
</li>
			<li>
%結果 ~LET ［
次が満たされるならば `undefined^jv ／
~ELSE_ %評価~状態s . `Value^sl
］
⇒
［
%評価~状態s は`中途完了$である
］~OR［
%評価~状態s . `Value^sl ~EQ `empty^jv
］
◎
Let result be undefined if evaluationStatus is an abrupt completion or evaluationStatus.[[Value]] is empty, or evaluationStatus.[[Value]] otherwise.
</li>
			<li>
<div class="p">
<p>
~IF［
`Type$jA( %結果 ) ~EQ `String^jT
］：
</p>
				<ol>
					<li>
%応答 ~SET 新たな`応答$
</li>
					<li>
%応答 の`本体$rs ~SET %結果†
</li>
					<li>
%応答 の`~header~list$rs ~SET 次の~headerからなる`~header~list$
⇒＃
( `Content-Type$h / `text/html$bl ),
( `Referrer-Policy$h / %設定群 の`~referrer施策$enV )
</li>
				</ol>
◎
If Type(result) is String, then set response to a response whose header list consists of `Content-Type`/`text/html` and `Referrer-Policy`/settings's referrer policy, and whose body is result.
</div>

<p class="warning">†
文字列 %結果 と応答の`本体$rsを成す~byte列との間の正確な変換は、まだ指定されていない。
~UAの挙動が更に究明されるのが待たれる。
<a href="~HTMLissue/1129">課題 #1129</a>
を見よ。
◎
The exact conversion between the string result and the bytes that comprise a response body is not yet specified, pending further investigation into user agent behavior. See issue #1129.
</p>
		</ol>
	</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

<p class="XXX">
上にて~linkした特定の課題に加えて、
`issue tracker^en には， `~javascript_$sc ~URLの仕様について様々な問題を文書化している
`<a href="https://github.com/whatwg/html/labels/topic%3A%20javascript%3A%20URLs">専用の~label</a>^
］がある。
◎
In addition to the specific issues linked above, javascript: URLs have a dedicated label on the issue tracker documenting various problems with their specification.
</p>
</div>

<hr>

<div class="algo">
<p>
以下の一部の節は、ある種の事例で上の~algoから呼出され，次に与える
`文書を作成して初期化する@
手続きを利用する。
それは、所与の
( `種別$doc %種別, `内容~型$doc %内容~型, `~navi~params$ %~navi~params )
に対し，次を走らす：
◎
Some of the sections below, to which the above algorithm defers in certain cases, use the following steps to create and initialize a Document object, given a type type, content type contentType, and navigation params navigationParams:
</p>
<ol>
	<li>
%B ~LET %~navi~params の`閲覧文脈$nvP
◎
Let browsingContext be navigationParams's browsing context.
</li>
	<li>
~IF［
%~navi~params の`閲覧文脈の切替nが必要$nvP ~EQ ~T
］
⇒
%B ~SET `~navi応答~用に利用する閲覧文脈を得する$( %B, %~navi~params の`最終-~sandbox~flag集合$nvP, %~navi~params の`非同一-生成元~opener施策$nvP )
◎
If navigationParams's browsing context switch needed is true, then set browsingContext to the result of the obtain a browsing context to use for a navigation response algorithm, given browsingContext, navigationParams's final sandboxing flag set, and navigationParams's cross-origin opener policy.
</li>
	<li>
<p>
%許可~施策 ~LET
`応答から閲覧文脈~用の許可~施策を作成する$( %B, %~navi~params の`生成元$nvP, %~navi~params の`応答$nvP )
`PERMISSIONSPOLICY$r
◎
Let permissionsPolicy be the result of creating a permissions policy from a response given browsingContext, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]
</p>

<div class="note">
<p>注記：
ここで`応答から閲覧文脈~用の許可~施策を作成する$ときは、渡された`生成元$を用立てる。
%B の`容器~文書$に対し `document.domain$m が利用されていた場合、
【以下で作成され，入子にされる文書】 %文書 の`生成元$と渡された生成元は，`同じ生成元~domain$にはなり得ない
— この手続きは %文書 が作成される前に走るので、この時点では まだ %文書 の `document.domain$m は利用し得ないので。
したがって，許可~施策の検査は、`同一-生成元$かどうか検査するよりも，~~寛容でない。
◎
The creating a permissions policy from a response algorithm makes use of the passed origin. If document.domain has been used for browsingContext's container document, then its origin cannot be same origin-domain with the passed origin, because these steps run before the document is created, so it cannot itself yet have used document.domain. Note that this means that Permissions Policy checks are less permissive compared to doing a same origin check instead.
</p>

<p>
これの動作~例は、下を見よ。
◎
See below for some examples of this in action.
</p>
</div>

	</li>
	<li>
%作成時の~URL ~LET %~navi~params の`応答$nvPの`~URL$rs
◎
Let creationURL be navigationParams's response's URL.
</li>
	<li>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］
⇒
%作成時の~URL ~SET %~navi~params の`要請$nvPの`現在の~URL$rq
◎
If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
</li>
	<li>
<p>
~IF［
次がすべて満たされる
］…：
</p>

<ul><li>%B の`~session履歴$は、 %B の`作成-時$に追加された初期 `~about_blank$sc `文書$ %D のみからなる
</li><li>%~navi~params の`履歴~取扱い$nvP ~EQ `置換-$i
</li><li>( %D の`生成元$, %~navi~params の`生成元$nvP ) は`同じ生成元~domain$である
</li></ul>

<p>
…ならば
⇒
何もしない
</p>
◎
If browsingContext's only entry in its session history is the initial about:blank Document that was added when that browsing context was created, and navigationParams's history handling is "replace", and that Document's origin is same origin-domain with navigationParams's origin, then do nothing.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%生成元~隔離~header ~LET
%応答 の`~header~list$rsから`有構造~headerを取得する$( `Origin-Isolation$h, `~item^i )
◎
Let oiHeader be the result of getting a structured field value given `Origin-Isolation` and "item" from response's header list.
</li>
			<li>
%生成元~隔離を要請する ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%生成元~隔離~header ~NEQ ~NULL
］~AND［
%生成元~隔離~header[ 0 ] ~EQ `真偽値$sf ~T
］
◎
Let requestsOI be true if oiHeader is not null and oiHeader[0] is the boolean true; otherwise false.
</li>
			<li>
~IF［
%予約-済み環境 は`~secureな文脈$enVでない
］
⇒
%生成元~隔離を要請する ~SET ~F
◎
If reservedEnvironment is a non-secure context, then set requestsOI to false.
</li>
			<li>
%~agent ~LET `類似生成元~window~agentを得する$( %~navi~params の`生成元$nvP, %B の`~group$tbcG, %生成元~隔離を要請する )
◎
Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOI.
</li>
			<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で，
%~agent 内で`新たな~JS~realmを作成する$
⇒＃
大域~obj用に新たな `Window$I ~objを作成する【すなわち， %B にて`作動中の~window$になる】,
大域 `this^jv 束縛には %B の `WindowProxy$I ~objを利用する
◎
Let realm execution context be the result of creating a new JavaScript realm given agent and the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
			<li>
%~top-level作成時の~URL ~LET %作成時の~URL
◎
Let topLevelCreationURL be creationURL.
</li>
			<li>
%~top-level生成元 ~LET %~navi~params の`生成元$nvP【！原文：リンク誤り】
◎
Let topLevelOrigin be navigationParams's origin.
</li>
			<li>
<p>
~IF［
%B は`~top-level閲覧文脈$でない
］：
◎
If browsingContext is not a top-level browsing context, then:
</p>
				<ol>
					<li>
%親~環境 ~LET %B の`容器$bcに`関連な設定群~obj$
◎
Let parentEnvironment be browsingContext's container's relevant settings object.
</li>
					<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL.
</li>
					<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
Set topLevelOrigin to parentEnvironment's top-level origin.
</li>
				</ol>
			</li>
			<li>
`~window用に環境~設定群~objを設定しておく$( 次に挙げる引数 )
⇒＃
%~realm実行~文脈,
%~navi~params の`予約-済み環境$nvP,
%~top-level作成時の~URL,
%~top-level生成元
◎
Set up a window environment settings object with realm execution context, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.
</li>
		</ol>
	</li>
	<li>
%文書 ~LET 次のようにされた新たな`文書$
⇒＃
`種別$doc ~SET %種別,
`内容~型$doc ~SET %内容~型,
`生成元$ ~SET %~navi~params の`生成元$nvP,
`許可~施策$doc ~SET %許可~施策,
`作動中の~sandbox法~flag集合$ ~SET %~navi~params の`最終-~sandbox~flag集合$nvP,
`非同一-生成元~opener施策$doc ~SET %~navi~params の`非同一-生成元~opener施策$nvP
◎
Let document be a new Document, whose type is type, content type is contentType, origin is navigationParams's origin, permissions policy is permissionsPolicy, active sandboxing flag set is navigationParams's final sandboxing flag set, and cross-origin opener policy is navigationParams's cross-origin opener policy.
</li>
	<li id="set-the-document's-address">
%文書 の`~URL$doc ~SET %作成時の~URL
◎
Set document's URL to creationURL.
</li>
	<li>
%文書 の`~referrer施策$doc ~SET `~headerから~referrer施策を構文解析する$( %~navi~params の`応答$nvPの `Referrer-Policy^h ~header )【！＊】
`REFERRERPOLICY$r
◎
Set document's referrer policy to the result of parsing the `Referrer-Policy` header of navigationParams's response. [REFERRERPOLICY]
</li>
	<li>
%文書 の`埋込元~施策$doc ~SET `埋込元~施策を得する$( %~navi~params の`応答$nvP )
◎
Set document's embedder policy to the result of obtaining an embedder policy from navigationParams's response.
</li>
	<li>
`文書の~CSP~listを初期化する$( %文書, %~navi~params の`応答$nvP, %~navi~params の`要請$nvP )
`CSP$r
◎
Initialize a Document's CSP list given document, navigationParams's response, and navigationParams's request. [CSP]
</li>
	<li>
<p>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］：
◎
If navigationParams's request is non-null, then:
</p>
		<ol>
			<li>
%文書 の`~referrer$doc ~SET 空~文字列
◎
Set document's referrer to the empty string.
</li>
			<li>
%~referrer ~LET %~navi~params の`要請$nvPの`~referrer$rq
◎
Let referrer be navigationParams's request's referrer.
</li>
			<li>
<p>
~IF［
%~referrer は`~URL~record$である
］
⇒
%文書 の`~referrer$doc ~SET `~URLを直列化する$( %~referrer )
◎
If referrer is a URL record, then set document's referrer to the serialization of referrer.
</p>

<p class="note">注記：
`FETCH$r により、
%~referrer は，この時点で［
`~URL~record$／ `no-referrer^l
］になる。
◎
Per Fetch, referrer will be either a URL record or "no-referrer" at this point.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~navi~params の`応答$nvPには `Refresh$h ~headerは在る
］：
◎
If navigationParams's response has a `Refresh` header, then:
</p>

		<ol>
			<li>
%値 ~LET `同型に復号する$( `Refresh^h の値 )
◎
Let value be the isomorphic decoding of the value of the header.
</li>
			<li>
`共用~宣言的~refresh手続き$( %文書, %値 )
◎
Run the shared declarative refresh steps with document and value.
</li>
		</ol>

<p class="XXX">
`Refresh$h ~headerが複数あるときの取扱いは、現時点では，まだ指定していない。
これは
<a href="~HTMLissue/2900">課題 #2900</a>
にて追跡されている。
◎
We do not currently have a spec for how to handle multiple `Refresh` headers. This is tracked as issue #2900.
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="example">
<p>
次の例では、子~文書には `PaymentRequest$I の利用は許容されない
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$であっても。
子~文書が初期化された時点では、 `document.domain$m は 親~文書にのみ設定されていて，子~文書にはまだ設定されてない。
◎
In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.
</p>

<pre class="lang-html">
&lt;!-- https://foo.example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
</pre>

<pre class="lang-html">
&lt;!-- https://bar.example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com'; /* <span class="comment">
これは、文書が初期化された後に起こる。
◎
This happens after the document is initialized
</span> */
 new PaymentRequest(…); /* <span class="comment">
利用は許容されない
◎
Not allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="example">

<p>
次の例では、子~文書には `PaymentRequest$I の利用は<em>許容される</em>
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$でなくとも。
子~文書が初期化される時点では，どちらの文書にも まだ `document.domain$m は設定されていないので、`同じ生成元~domain$の検査は，通常の`同一-生成元$の検査に~fall-backする。
◎
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.
</p>

<pre class="lang-html">
&lt;!-- https://example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
子~文書は、下の~scriptが走る前の，この時点では初期化されている。
◎
The child document is now initialized, before the script below is run.
</span> --&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
</pre>

<pre class="lang-html">
&lt;!-- https://example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 new PaymentRequest(…); /* <span class="comment">
利用は許容される
◎
Allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="algo">
<div class="p">
<p>
以下の各~節にて，
`新たな~pageで~session履歴を更新する@
よう要求される所では、所与の
( `~navi~params$ %~navi~params, `文書$ %新たな文書 )
に対し，次を走らすモノトスル：
</p>
<ol>
	<li>
%~navi ~LET この~algoを呼出した`~navi$~algoの~instance
</li>
	<li>
%B ~LET %~navi~params の`閲覧文脈$nvP
</li>
	<li>
%履歴 ~LET %B の`~session履歴$
</li>
	<li>
%大域~obj ~LET %履歴 の`現在の~entry$の（ %新たな文書 でない）`文書$に`関連な大域~obj$
</li>
	<li>
下に与える下位手続きを走らす`大域~taskを~queueする$( `~network用~task源$, %大域~obj )
</li>
</ol>
<p class="trans-note">【
引数 %新たな文書 , および
%~navi, %B
は、この訳による補完。
】</p>
◎
Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page, given some navigation params navigationParams. When a user agent is required to do this, it must queue a global task on the networking task source, given the relevant global object of the Document object of the current entry (not the new one), to run the following steps:
</div>

<p>
上で利用される下位手続きは：
</p>
<ol>
	<li>
`文書を~unloadする$( %履歴 の`現在の~entry$の`文書$ )
◎
Unload the Document object of the current entry.
</li>
	<li>
~IF［
前~段の~unloadを走らせている間に %~navi は取消された
］
⇒
~RET
⇒
~unloadは走らせ終えるモノトスルが、
%~navi は，この段を超えて走らせないモノトスル。
（特に，ここで %~navi が取消されても、一例として，文書や その子孫を~unloadする一部として生じている ~event配送-や~script実行は，中止されない。）
◎
If this instance of the navigation algorithm is canceled while this step is running the unload a document algorithm, then the unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)
</li>
	<li>
<p>
~IF［
%~navi~params の`履歴~取扱い$nvP ~IN { `再読込み$i, `~entry更新$i }
］：
◎
If navigationParams's history handling is "reload" or "entry update"
</p>
		<ol>
			<li>
%更新する~entry ~SET その~entry
</li>
			<li>
%履歴 内の
~EACH( %~entry )
に対し
⇒
~IF［
%~entry の`文書$ ~EQ %更新する~entry の`文書$
］
⇒
%~entry の`文書$ ~SET %新たな文書
◎
Replace the Document of the entry being updated, and any other entries that referenced the same document as that entry, with the new Document.
</li>
			<li>
%更新する~entry へ`履歴を辿る$
◎
Traverse the history to the new entry.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
<p>
%新たな~entry ~LET 次のものからなる（ %新たな文書 とその~~元になった資源を表現する）新たな`~session履歴~entry$：
</p>

<ul ><li>`文書$ ~SET %新たな文書
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `auto$l
</li><li>`~URL$ ~SET %新たな文書 の`~URL$doc 【この項目は、この訳による推定（~URLは必須なので）。】
</li></ul>

◎
↓</li>
			<li>
<p>
~IF［
%~navi に渡された引数 %資源 は`~URL$である
］~AND［
( %資源, %B にて`作動中の文書$の`~URL$doc )
は`同等な~URL$である
］：
◎
If the navigation was initiated with a URL that equals the browsing context's active document's URL
</p>
				<ol>
					<li>
%履歴 の`現在の~entry$を %新たな~entry に置換する
◎
Replace the current entry with a new entry representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
%新たな~entry へ`履歴を辿る$
◎
Traverse the history to the new entry.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise
</p>
				<ol>
					<li>
<p>
%履歴 内の`現在の~entry$より後の~entryは すべて除去する
◎
Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
					</li>
					<li>
%新たな文書 の `History$I ~objの末尾に %新たな~entry を付加する
◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
%新たな~entry へ`履歴を辿る$
— 次を与える下で
⇒＃
`履歴の取扱い$V ~SET %~navi~params の`履歴~取扱い$nvP
◎
Traverse the history to the new entry, with historyHandling set to navigationParams's history handling.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
この時点で、 %~navi は
`成熟-@
したとされる。
【！ %新たな文書 が`属する閲覧文脈$ ~NEQ ~NULL になる】
◎
The navigation algorithm has now matured.
</li>
	<li>
`素片へ~scrollしようと試行する$( %新たな文書 )
◎
Try to scroll to the fragment for the Document.
</li>
</ol>
</div>

<div class="algo">

<p>
`素片へ~scrollしようと試行する@
ときは、所与の
( `文書$ %文書 )
に対し，次の手続きを`並列的$に遂行する：
◎
To try to scroll to the fragment for a Document document, perform the following steps in parallel:
</p>

<ol>
	<li>
`実装定義$な時間長だけ待機する
（この段は、~UAが処理能の懸念に面したとき，利用者~体験を最適化できるようにするためにある。）
◎
Wait for an implementation-defined amount of time. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)
</li>
	<li>
<p>
次を走らす`大域~taskを~queueする$( `~network用~task源$, %文書 に`関連な大域~obj$ ）：
◎
Queue a global task on the networking task source given document's relevant global object to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%文書 用の構文解析器は無い
</li><li>%文書 用の構文解析器は`構文解析を停止した$
</li><li>~UAには、［
利用者が`素片$urlへ~scrollすることに関心を失った
］と予見する理由がある
</li></ul>

<p>
…ならば
⇒
~RET
</p>

◎
If document has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then abort these steps.
</li>
			<li>
%文書 の`~URL$doc内に与えられる`素片へ~scrollする$
◎
Scroll to the fragment given in document's URL.＼
</li>
			<li>
~IF［
前~段の結果 %文書 内の`指示された部位$docを見出せなかった
］
⇒
`素片へ~scrollしようと試行する$( %文書 )
◎
If this does not find an indicated part of the document, then try to scroll to the fragment for document.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="read-html">
<h3 title="Page load processing model for HTML files">7.10.2. ~HTML~file用の~page読込n処理~model</h3>

<div class="algo">
<p>
`~HTML文書が読込まれる@
ことになるときは、~UAは，所与の
( `~navi~params$ %~navi~params )
に対し，`~network用~task源$から次を走らす`~taskを~queueする$モノトスル：
◎
When an HTML document is to be loaded, given navigation params navigationParams, the user agent must queue a task on the networking task source to:
</p>

<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— この構文解析器に対しては
⇒
~fetchingを走らせている間に`~network用~task源$から
`~task~queue$に入れられる各`~task$は、~fetchされた~byte列で構文解析器への`入力~byte~stream$を埋めた上で，構文解析器に入力~streamの適切な処理を遂行させるモノトスル。
◎
Create an HTML parser and associate it with the document.＼
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</p>

<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理nの一部は、資源の~~真の `~Content-Type~metadata$ から見出される文字~符号化法~情報に依拠する
— `資源から算出された~MIME型$は、その目的には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>
	</li>
</ol>
</div>

<p>
加えて、~UAは次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
可用な~byte列が尽きたときは、次を走らす（これは、最終的に `load$et ~eventを発火させることになる）
⇒
構文解析器が暗黙の~EOF文字を処理するための
`大域~taskを~queueする$( `~network用~task源$, 新たに作成された`文書$に`関連な大域~obj$ )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given the newly-created Document's relevant global object for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
`文書$ %文書 を作成した後, かつ ~scriptが実行される前の, ほぼ間違いなく構文解析器が`停止-$する前に
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but before any script execution, certainly before the parser stops, the user agent must update the session history with the new page given navigationParams.
</li>
</ul>

<p class="note">注記：
【`~app~cache用$の注記】
◎
Application cache selection happens in the HTML parser.
</p>

			</section>
			<section id="read-xml">
<h3 title="Page load processing model for XML files">7.10.3. ~XML~file用の~page読込n処理~model</h3>

<div class="algo">
<p>
~XML~fileを~inlineに表示することになった場合、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し、次に挙げる各種 仕様に定義される要件に従う下で
⇒＃
`XML^cite `XML$r,
`Namespaces in XML^cite `XMLNS$r,
`XML Media Types^cite `RFC7303$r,
`DOM^cite `DOM$r,
関連な他の`文書$を作成するための仕様と対応する`~XML構文解析器$
◎終
次を行うモノトスル：
◎
When faced with displaying an XML file inline, provided navigation params navigationParams and a string type, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications＼
</p>
<ol>
	<li>
`文書を作成して初期化する$( `xml^l, %~MIME型, %~navi~params )
◎
to create and initialize a Document object given "xml", type, and navigationParams.＼
</li>
	<li>
対応する`~XML構文解析器$を作成する
◎
They must also create a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</li>
</ol>
</div>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p>

<p>
~UAは、`文書$ %文書 を作成したときは：
◎
↓</p>

<ul>
	<li>
上に挙げた各 仕様の規則に則って，文字~符号化法を決定するときには、実際の~HTTP~headerや他の~metadataのうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものを利用した上で、
%文書 の`文字~符号化法$docは，そのように確立された符号化法に設定するモノトスル。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
【`~app~cache用$の処理~要件】
◎
If the document element, as parsed according to XML cited above, is found to be an html element with an attribute manifest whose value is not the empty string, then, as soon as the element is inserted into the document, the user agent must parse the value of that attribute relative to that element's node document, and if that is successful, must apply the URL serializer algorithm to the resulting URL record with the exclude fragment flag set to obtain manifest URL, and then run the application cache selection algorithm with manifest URL as the manifest URL, passing in the newly-created Document. Otherwise, if the attribute is absent, its value is the empty string, or parsing its value fails, then as soon as the document element is inserted into the document, the user agent must run the application cache selection algorithm with no manifest, and passing in the Document.
◎
Because the processing of the manifest attribute happens only once the document element is parsed, any URLs referenced by processing instructions before the document element (such as &lt;?xml-stylesheet?&gt; PIs) will be fetched from the network and cannot be cached.
</li>
	<li>
<p>
次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
</p>

<p>
その時機は
⇒＃
文書が完全に構文解析される前でもヨイ（したがって `増分的に具現化する^i ことになる）／
どの~script実行よりも前に行うモノトスル
</p>

◎
Then, with the newly created Document, the user agent must update the session history with the new page given navigationParams. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.
</li>
	<li>
構文解析-時の~error（例えば ~XML名前空間 整形式性~error）に際しては、
%文書 を変異して~inlineに報告してもヨイ。
◎
Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the Document.
</li>
</ul>

			</section>
			<section id="read-text">
<h3 title="Page load processing model for text files">7.10.4. ~text~file用の~page読込n処理~model</h3>

<div class="algo">
<p>
素な~text文書を読込むことになるときは、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し、`~network用~task源$から，次を走らす`~taskを~queueする$モノトスル：
◎
When a plain text document is to be loaded, provided navigation params navigationParams and a string type, the user agent must queue a task on the networking task source to:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— この構文解析器は：
◎
Create an HTML parser and associate it with the document.＼
</p>
		<ul>
			<li>
その~tokenizerが すでに次を順に行ったかのようにしておく
⇒＃
~tag名 `pre^l の開始tag~tokenを発した；
1 個の文字 <span class="code-point">U+000A</span> （LF）を発した；
`~PLAINTEXT状態$に切替えた
◎
Act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state.＼
</li>
			<li>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に入れられる各`~task$は、構文解析器の`入力~byte~stream$を~fetchされた~byte列で埋めて，構文解析器に入力~streamの適切な処理を遂行させるモノトスル。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
		</ul>
	</li>
</ol>
</div>

<p>
素な~text文書である %資源 に対しては、次に挙げる要件が~UAに課される：
◎
↓</p>

<ul>
	<li>
%資源 の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、`資源から算出された~MIME型$の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (i.e., type).
</li>
	<li>
%資源 の`文字~符号化法$docは、 %資源 の復号-時に利用された文字~符号化法に設定するモノトスル。
◎
The document's character encoding must be set to the character encoding used to decode the document.
</li>
	<li>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</li>
	<li>
可用な~byte列が尽きたときは、次を走らすモノトスル（これは、最終的に `load$et ~eventを発火させることになる）
⇒
構文解析器が暗黙の~EOF文字を処理するための
`大域~taskを~queueする$( `~network用~task源$, 新たに作成された`文書$に`関連な大域~obj$ )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given the newly-created Document's relevant global object for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
<p>
%資源 から`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished parsing, the user agent must update the session history with the new page given navigationParams.
</p>

<p class="trans-note">【
“`なければその前に@”
— 原文の “`, but potentially before^en” の意図が［
要件の一部 ／
可能性があることを示す単なる説明 ／
終える前にそうしてよいことの明示的な許可
］のどれなのか はっきりしないが、同じ要件~文の一部として `but^en 節の中に記されているので，要件と解釈する下で和訳している。
】</p>
	</li>
	<li>
<p>
%文書 の `head$e 要素に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
~scriptを供する,
%文書 に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、 RFC 3676 の `Format=Flowed^c 特能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
</ul>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h3 title="Page load processing model for multipart/x-mixed-replace resources">7.10.5. `multipart/x-mixed-replace^c 資源~用の~page読込n処理~model</h3>

<p>
型 `multipart/x-mixed-replace$c を伴う資源を `閲覧文脈$内に読込むことになるときは、~UAは次に従うモノトスル：
◎
When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must＼
↓parse the resource using the rules for multipart types. [RFC2046]
</p>

<p class="XXX">
この~algoには`~navi~params$が渡されるが、それを正確に どう利用するかは，明瞭でない。
◎
This algorithm is passed navigation params, but it's unclear how exactly to use them.
</p>

<ul>
	<li>
`RFC2046$r による `multipart^c 型~用の規則を利用して資源を構文解析する。
◎
↑</li>
	<li>
資源から得された
~EACH( %本体~部位 )
に対し，出現順に 次を走らす
⇒
次を除いて、この節を呼出した`~navi$と同じものを与える下で，`~navigate応答を処理する$
⇒
%応答 の本体には %本体~部位 を利用する。
加えて、これまでの~~反復で ある`文書$を`作成して初期化-$していた場合、
`履歴~取扱い$nvPを `置換-$i に設定する下で行うとする。
◎
For each body part obtained from the resource, the user agent must run process a navigate response using the new body part and the same browsing context, with history handling set to "replace" if a previous body part from the same resource resulted in a creating and initializing a Document object, and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.
</li>
	<li>
前項による，［
各 本体~部位を，完全に自立的な資源であったかのように処理する目的
］においては、各 本体~部位に対し［
それに後続する境界に達した所で，当の資源~用の~byte列は尽きた
］かのように動作する。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</li>
</ul>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、各~本体~部位が読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>

			</section>
			<section id="read-media">
<h3 title="Page load processing model for media">7.10.6. ~media用の~page読込n処理~model</h3>

<div class="algo">
<p>
［
画像 ／ 動画 ／ 音声
］資源を読込むことになるときは、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，次を行うベキである：
◎
When an image, video, or audio resource is to be loaded, provided navigation params navigationParams and a string type, the user agent should:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 に `html$e 要素を付加する
◎
Append an html element to document.
</li>
	<li>
`html$e 要素に `head$e 要素を付加する
◎
Append a head element to the html element.
</li>
	<li>
`html$e 要素に `body$e 要素を付加する
◎
Append a body element to the html element.
</li>
	<li>
<p>
`body$e 要素に［
資源の~mediaに応じて，次の表の 2 列目に与えられる要素
］を付加する：
</p>

<table><thead><tr><th>~media型
<th>要素
<th>属性
</thead>

<tbody><tr><td>画像
<td>`img$e
<td>`~src-img$a

<tr><td>動画
<td>`video$e
<td>`~src-media$a

<tr><td>音声
<td>`audio$e
<td>`~src-media$a

</tbody></table>

◎
Append an element host element for the media, as described below, to the body element.
</li>
	<li>
前~段で付加した要素の［
対応する，前~段の表の 3 列目の属性
］の値 ~SET 資源の~address
◎
Set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
Type of media | Element for the media | Appropriate attribute
Image | img | src
Video | video | src
Audio | audio | src
</li>
</ol>
</div>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page given navigationParams.
</p>

<p>
~UAは、`文書$の `head$e 要素に内容を追加してもヨイ ／
%~host要素 に内容~属性を追加してもヨイ
— 例：
~stylesheetへの~link ／
~scriptを供する ／
文書に `title$e を与える ／
~mediaを `autoplay$a にする
等々。
◎
User agents may add content to the head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>

			</section>
			<section id="read-plugin">
<h3 title="Page load processing model for content that uses plugins">7.10.7. ~pluginを利用する内容~用の~page読込n処理~model</h3>

<div class="algo">
<p>
外部~資源を具現化することを要する資源を読込むことになるときは、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，次を行うベキである：
◎
When a resource that requires an external resource to be rendered is to be loaded, provided navigation params navigationParams and a string type, the user agent should:
</p>

<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParmas.
</li>
	<li>
%文書 を
`~plugin文書@
とする
◎
Mark document as being a plugin document
</li>
	<li>
`文書$に `html$e 要素を付加する
◎
Append an html element to document.
</li>
	<li>
`html$e 要素に `head$e 要素を付加する
◎
Append a head element to the html element.
</li>
	<li>
`html$e 要素に `body$e 要素を付加する
◎
Append a body element to the html element.
</li>
	<li>
`body$e 要素に `embed$e 要素を付加する
◎
Append an embed to the body element
</li>
	<li>
`embed$e 要素の `~src-embed$a 属性を資源の~addressに設定する
◎
Set the src attribute of the embed element to the address of the resource.
</li>
</ol>
</div>

<p class="note">注記：
用語 `~plugin文書$は、次を確保する仕組みの一部として，
`CSP$r により利用される
⇒
`iframe$e を利用しても，
`plugin-types^dir 指令をかいくぐることはできない
◎
The term plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used to evade plugin-types directives. [CSP]
</p>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page given navigationParams.
</p>

<p>
~UAは［
`文書$の `head$e 要素 ／
`embed$e 要素の属性
］に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, or attributes to the embed element, e.g. to link to a style sheet or to give the document a title.
</p>

<p id="sandboxPluginNavigate" class="note">注記：
［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN `文書$の`作動中の~sandbox法~flag集合$
］の下で［
関連な`~plugin$を`~secure化でき$なかった
］場合には、合成された `embed$e 要素は，
<a href="~HEembed#sandboxPluginEmbed">内容を具現化するのに失敗する</a>ことになる。
◎
If the Document's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized embed element will fail to render the content if the relevant plugin cannot be secured.
</p>

			</section>
			<section id="read-ua-inline">
<h3 title="Page load processing model for inline content that doesn't have a DOM">7.10.8. ~DOMを有さない~inline内容~用の~page読込n処理~model</h3>

<div class="algo">
<p>
~UAは、~pageを~inlineに表示するときは、供された
( `閲覧文脈$ %B )
に対し，次を行うベキである：
◎
When the user agent is to display a user agent page inline, provided a browsing context browsingContext, the user agent should:
</p>

<ol>
	<li>
<p>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET ~NULL†,
`生成元$nvP ~SET 新たな`不透明な生成元$,
`最終-~sandbox~flag集合$nvP ~SET 空~集合,
`非同一-生成元~opener施策$nvP ~SET `unsafe-none$l,
`予約-済み環境$nvP ~SET ~NULL ,
`閲覧文脈$nvP ~SET %B,
`閲覧文脈の切替nが必要$nvP ~SET ~F
◎
Let navigationParams be a new navigation params whose request is null, response is null, origin is a new opaque origin, final sandboxing flag set is an empty set, cross-origin opener policy is "unsafe-none", reserved environment is null, browsing context is browsingContext, and browsing context switch needed is false.
</p>

<p class="XXX">†
次の段で~callされる~algoは、 ~NULL にされた`応答$nvPを どう処するか~~指定していない。
おそらく，代わりになる応答を合成するベキである。
◎
The algorithm called in the next step is not prepared to deal with a null response. Probably we should synthesize one instead.
</p>
	</li>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
次のいずれかを行う：
◎
Either＼
</p>
		<ul>
			<li>
%文書 を［
`文書$の通常の具現化~規則を利用して具現化されない
］ような~customな具現化に結付ける
◎
associate document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
それが~UAが具現化しようと求める内容を表現する
］よう変異させる
◎
mutate document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
</ol>
</div>

<p>
~UAは、~pageが設定しておかれたなら，`構文解析を停止した$かのように動作するモノトスル。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache用$の処理~要件】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, passing in the newly-created Document.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを完全に設定して`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has been completely set up, the user agent must update the session history with the new page given navigationParams.
</p>

			</section>
			<section id="scroll-to-fragid">
<h3 title="Navigating to a fragment">7.10.9. 素片への~navigate法</h3>

<div class="algo">
<p>
`素片へ~navigateする@
ときは、所与の
( `閲覧文脈$ %B, `~URL$ %~URL, `履歴を取扱うときの挙動$ %履歴~取扱い )
に対し，次を走らすモノトスル：
◎
To navigate to a fragment, with a history handling behavior historyHandling:
</p>

<ol>
	<li>
~Assert：
%~URL の`素片$url ~NEQ ~NULL
【この段, および引数 %B, %~URL は、この訳による補完。】
</li>
	<li>
%履歴 ~LET %B の`~session履歴$
◎
↓</li>
	<li>
<p>
~IF［
%履歴~取扱い ~NEQ `置換-$i
］
⇒
%履歴 内から， %履歴 の`現在の~entry$より後の~entryはすべて除去する
◎
If historyHandling is not "replace", then remove all the entries in the browsing context's session history after the current entry. (If the current entry is the last entry in the session history, then no entries are removed.)
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
	</li>
	<li>
%B の`~top-level閲覧文脈$の`文書~族$内の
~EACH( `文書$ %D )
に対し
⇒
%D に結付けられている`履歴~辿り~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
	<li>
<p>
%~entry ~LET 当の資源とその文書を表現する，次のものからなる新たな`~session履歴~entry$：
</p>
<ul ><li>`文書$ ~SET %B にて`作動中の文書$
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `現在の~entry$のそれ
</li><li>`~URL$ ~SET %~URL
</li></ul>

<p>
%~entry の~titleは未設定のままにする
</p>

◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and current entry's scroll restoration mode. Its URL must be set to the address to which the user agent was navigating. The title must be left unset.
</li>
	<li>
`History$I ~objの末尾に %~entry を付加する
◎
↑</li>
	<li>
<p>
%~entry へ`履歴を辿る$
— 次を与える下で
⇒＃
`履歴の取扱い$V ~SET %履歴~取扱い,
`~eventは他を阻まない$V ~SET ~T
◎
Traverse the history to the new entry, with historyHandling set to historyHandling and with nonBlockingEvents set to true.＼
</p>

<p class="note">注記：
これは、今や文書の`~URL$docになった %~URL の`素片へ~scrollする$ことになる。
素片が指す`~ID$を有する要素が まだ構文解析されていないため，~scrollできなかった場合、代わりに，元の`~navi$~algoから呼ばれる［
`新たな~pageで~session履歴を更新する$~algo
］の最後の方で，~scrollingが~careされることになる。
◎
This will scroll to the fragment given in what is now the document's URL.
◎
If the scrolling fails because the relevant ID has not yet been parsed, then the original navigation algorithm will take care of the scrolling instead, as the last few steps of its update the session history with the new page algorithm.
</p>
	</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
%文書 の
`素片へ~scrollする@
よう要求されたときは、~UAは，次を行うモノトスル：
◎
When the user agent is required to scroll to the fragment and＼
</p>

<ol>
	<li>
%部位 ~LET %文書 内の`指示された部位$doc
◎
the indicated part of the document,＼
</li>
	<li>
~IF［
%部位 ~EQ ε
］~OR［
%部位 は`具現化されて$いない
］
⇒
~RET
◎
if any, is being rendered,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
the user agent must either＼
</p>
		<ul>
			<li>
下に述べるように，文書の~scroll位置を %部位 に変更する。
◎
change the scrolling position of the document using the following algorithm,＼
</li>
			<li>
%部位 に利用者の注目を引くような他の何らかの動作を遂行する。
◎
or perform some other action such that the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not being rendered, then the user agent must do nothing.＼
</li>
		</ul>
	</li>
</ol>

<!-- 初期時は null なので不要な記述 -->
</div>

<div class="algo">
<p>
`文書$ %文書 の~scroll位置を %部位 に変更するときは：
◎
The aforementioned algorithm is as follows:
</p>

<ol>
	<li>
%文書 の`標的~要素$ ~SET ~NULL
◎
If there is no indicated part of the document, set the Document's target element to null.
</li>
	<li>
<p>
%部位 に応じて：
</p>

		<dl class="switch">
			<dt>`文書の上端^i
◎
If the indicated part of the document is the top of the document, then:
</dt>
			<dd>
%文書 の`開始位置へ~scroll$する `CSSOMVIEW$r
◎
Set the Document's target element to null.
◎
Scroll to the beginning of the document for the Document. [CSSOMVIEW]
</dd>

			<dt>要素である
◎
Otherwise:
</dt>
			<dd>
				<ol>
					<li>
%文書 の`標的~要素$ ~SET %部位
◎
Let target be element that is the indicated part of the document.
◎
Set the Document's target element to target.
</li>
					<li>
%部位 を`~viewの中へ~scrollする$( `auto^l, `start^l, `nearest^l )
`CSSOMVIEW$r
◎
Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest". [CSSOMVIEW]
</li>
					<li>
`~objを~focusする$( %部位, %文書 の`表示域$ )
◎
Run the focusing steps for target, with the Document's viewport as the fallback target.
</li>
					<li>
%文書 における`逐次的~focus~naviの始点$ ~SET %部位
◎
Move the sequential focus navigation starting point to target.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<p>
`文書$ %文書 内の
`指示された部位@doc
は、`素片$urlがあれば，それが指示するものになる。
`素片$urlから~nodeにどう対応付けるかの意味論は、
%文書 が利用している`~MIME型$を定義する仕様により定義される（例えば、`~XML~MIME型$用の`素片$urlの処理は `RFC7303$r が担当する）。
◎
The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]
</p>

<p>
各 `文書$には、 `target$ps 疑似類を定義するために利用される
`標的~要素@
がある。
それは、初期~時は~NULLであり，上の~algoで更新される。
◎
There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.
</p>

<div class="algo">
<p>
~HTML文書（および， `~HTML~MIME型$ ） %文書 に対しては、
%文書 内の`指示された部位$docを決定するときは，次の処理~modelに従うモノトスル。
◎
For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of the document is.
</p>

<ol>
	<li>
%素片 ~LET %文書 の`~URL$docの`素片$url
◎
Let fragment be the document's URL's fragment.
</li>
	<li>
~Assert：
%素片 ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
~IF［
%素片 ~EQ 空~文字列
］
⇒
~RET `文書の上端^i
◎
If fragment is the empty string, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with fragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
%素片~byte列 ~SET `文字列を~byte列に~percent-復号する$( %素片 )
◎
Let fragmentBytes be the result of percent-decoding fragment.
</li>
	<li>
%復号-済み素片 ~LET `~BOMはそのままに~UTF-8復号する$( %素片~byte列 )
◎
Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %復号-済み素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with decodedFragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
~IF［
%復号-済み素片 ~EQ`大小無視$sub `top^l
］
⇒
~RET `文書の上端^i
◎
If decodedFragment is an ASCII case-insensitive match for the string top, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~RET ε
◎
There is no indicated part of the document.
</li>
</ol>
</div>

<div class="algo">
<p>
`指示された要素を見出す@
ときは、所与の
( `文書$ %文書, 文字列 %素片 )
に対し，次を走らす：
◎
To find a potential indicated element given a string fragment, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`~tree内$に［
`~ID$ ~EQ %素片
］を満たす要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.
</li>
	<li>
~IF［
%文書 の`~tree内$に［
`name$a 属性を有していて，その値 ~EQ %素片
］を満たす `a$e 要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an a element in the document tree that has a name attribute whose value is equal to fragment, then return the first such element in tree order. 
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

			</section>
			<section id="history-traversal">
<h3 title="History traversal">7.10.10. 履歴の辿り</h3> 

<div class="algo">
<div class="p">
<p>
`~session履歴~entry$ %~entry へ
`履歴を辿る@
する~algoは、次も入力にとり，以下を走らすモノトスル：
</p>
<ul>
	<li>
`履歴を取扱うときの挙動$
`履歴の取扱い@V
（省略時は `既定$i ）
</li>
	<li>
真偽値
`~eventは他を阻まない@V
（省略時は ~F ）
</li>
	<li>
真偽値
`明示的な履歴~navi@V
（省略時は ~F ）
</li>
</ul>
◎
To traverse the history to a session history entry entry, with an optional history handling behavior historyHandling (default "default"), an optional boolean nonBlockingEvents (default false), and an optional boolean explicitHistoryNavigation (default false):
</div>

<p class="note">注記：
この~algoは、明示的に`履歴を前／後に辿る$ときのみならず，他の状況においても呼出される
— 例えば、閲覧文脈を`~navigate$するときに，`新たな~pageで~session履歴を更新する$一部として。
◎
This algorithm is not just invoked when explicitly going back or forwards in the session history — it is also invoked in other situations, for example when navigating a browsing context, as part of updating the session history with the new page.
</p>

<ol>
	<li>
%履歴 ~LET %~entry が属する`~session履歴$
◎
↓</li>
	<li>
%B ~LET %履歴 を有する`閲覧文脈$
◎
↓</li>
	<li>
<p>
~IF［
%~entry はもはや`文書$を保持していない
］：
◎
If entry no longer holds a Document object, then:
</p>
		<ol>
			<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒
`~URL$rq ~SET %~entry の`~URL$
◎
Let request be a new request whose url is entry's URL.
</li>
			<li>
~IF［
`明示的な履歴~navi$V ~EQ ~T
］
⇒
%要請 の`履歴~navi~flag$rq ~SET ~T
◎
If explicitHistoryNavigation is true, then set request's history-navigation flag.
</li>
			<li>
~Assert：
`履歴の取扱い$V ~EQ `置換-$i
◎
Assert: historyHandling is not "replace".
</li>
			<li>
<p>
%B を %要請 へ`~navigate$する
— 次を与える下で
⇒＃
`履歴~取扱い$V ~SET `~entry更新$i
`~source閲覧文脈$ ~SET %~entry を最初に作成したときに利用した`~source閲覧文脈$
◎
Navigate the browsing context to request with historyHandling set to "entry update". The navigation must be done using the same source browsing context as was used the first time entry was created.
</p>

<p class="note">注記：
`~navigate$ ~algoは、辿りを完了するために，この~algoを再び呼出す
— その時点で %~entry は`文書$を保持することになる。
◎
The "navigate" algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point entry holds a Document object.
</p>

<p class="note">注記：
資源が非冪等~動作を利用して得されたものであった場合（ 例えば `POST^hm による~form提出）や, 資源はもはや可用でない場合（例えば~computerは今や~offlineになっていて，~pageも~cacheされていないため）など、再度そこへ~navigateできないこともある。
この事例では、~naviの結果は，以前と異なる~pageになる
— 例えば，問題を説明する~error~messageや, ~formを再度~提出する~UIを提供するなど。
◎
If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.
</p>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%現~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
~IF［
%現~entry の~titleは［
`pushState()$m ／ `replaceState()$m
］~methodにより設定されていない
］
⇒
%現~entry の~title ~SET `document.title$m ~IDL属性の値を取得した結果
◎
If the current entry's title was not set by the pushState() or replaceState() methods, then set its title to the value returned by the document.title IDL attribute.
</li>
	<li>
適切になる, かつ ~UAが持続化するよう望む状態があれば、それらを反映するように，%現~entry を更新する
—
この~entryは、`持続的な利用者~状態$を伴うものとされる。
◎
If appropriate, update the current entry in the browsing context's Document object's History object to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
%現~文書 ~LET %現~entry の`文書$（ ~EQ %B にて`作動中の文書$）
◎
↓</li>
	<li>
<p>
~IF［
%文書 ~NEQ %現~文書
］：
◎
If entry has a different Document object than the current entry, then run the following substeps:
</p>
		<ol>
			<li>
%B の`~top-level閲覧文脈$の`文書~族$内の
~EACH( `文書$ )
に対し
⇒
`文書$に結付けられている`履歴~辿り~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
<p>
~IF［
( %文書 の`生成元$, %現~文書 の`生成元$ )
は`同一-生成元$でない
］：
◎
If the origin of entry's Document object is not the same as the origin of the current entry's Document object, then run the following subsubsteps:
</p>
				<ol>
					<li>
%履歴 内の
~EACH( ~entry %e )
に対し
⇒
~IF［
( %e の`文書$の`生成元$, %現~文書 の`生成元$ )
は`同一-生成元$である
］~AND［
%e は %現~entry と連続的である
【<a href="~HISTORY#_contiguous">~~参照</a>】
］
⇒
%e の`閲覧文脈~名$ ~SET %B の`閲覧文脈~名$
◎
The current browsing context name must be stored with all the entries in the history that are associated with Document objects with the same origin as the active document and that are contiguous with the current entry.
</li>
					<li id="resetBCName">
~IF［
%B は`~top-level閲覧文脈$である
］~AND［
%B は`補助~閲覧文脈$でない
］
⇒
%B の`閲覧文脈~名$ ~SET 空~文字列
◎
If the browsing context is a top-level browsing context, but not an auxiliary browsing context, then set the browsing context's name to the empty string.
</li>
				</ol>
			</li>
			<li id="appcache-history-2">
`閲覧文脈にて作動中の文書を設定する$( %B, %文書 )
◎
Set the active document of the browsing context to entry's Document object.
</li>
			<li>
<p>
~IF［
%~entry の`閲覧文脈~名$ ~NEQ ε
］：
◎
If entry has a browsing context name, then run the following subsubsteps:
</p>
				<ol>
					<li>
%B の`閲覧文脈~名$ ~SET %~entry の`閲覧文脈~名$
◎
Set the browsing context's browsing context name to entry's browsing context name.
</li>
					<li>
%履歴 内の
~EACH( ~entry %e )
に対し
⇒
~IF［
( %e の`文書$の`生成元$, %文書 の`生成元$ )
は`同一-生成元$である
］~AND［
%e は %~entry と連続的である
］
⇒
%e の`閲覧文脈~名$ ~SET ε
◎
Clear any browsing context names of all entries in the history that are associated with Document objects with the same origin as the new active document and that are contiguous with entry.
</li>
				</ol>
			</li>
			<li id="history-autocomplete">
%文書 内の
~EACH( ~form~control %E )
に対し
⇒
~IF［
%E の`~autofill欄~名$ ~EQ `off$v
］
⇒
%E の`再設定~algo$を呼出す
◎
If entry's Document object has any form controls whose autofill field name is "off", invoke the reset algorithm of each of those elements.
</li>
			<li>
<p>
~IF［
%文書 の`現在の文書の準備度$ ~EQ `complete^l
］
⇒
次を走らす`大域~taskを~queueする$( `~DOM操作~task源$, %~entry の`文書$に`関連な大域~obj$ )：
◎
If the current document readiness of entry's Document object is "complete", then queue a global task on the DOM manipulation task source given entry's Document's relevant global object to run the following subsubsteps:
</p>
				<ol>
					<li>
~IF［
%文書 の`~page表示中~flag$doc ~EQ ~T
］
⇒
~RET
◎
If the Document's page showing flag is true, then abort these steps.
</li>
					<li>
%文書 の`~page表示中~flag$doc ~SET ~T
◎
Set the Document's page showing flag to true.
</li>
					<li>
<p>
`適用-可能な仕様$により定義されている
`~session履歴~文書の可視性を変更する手続き@
があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any session history document visibility change steps for Document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
					</li>
					<li>
%文書 に`関連な大域~obj$に向けて，名前 `pageshow$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒＃
`persisted$m 属性 ~SET ~T
◎
Fire an event named pageshow at the Document object's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true, and legacy target override flag set.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~URL$doc ~SET %~entry の`~URL$
◎
Set the document's URL to entry's URL.
</li>
	<li>
%~hash変化あり ~LET ~F
◎
↓</li>
	<li>
~IF［
%~entry の~URLの`素片$url ~NEQ【！identical】 %現~entry の`素片$url
］~AND［
%文書 ~EQ %現~文書
］
⇒＃
%~hash変化あり ~LET ~T；
%旧~URL ~LET %現~entry の~URL；
%新~URL ~LET %~entry の~URL
◎
If entry has a URL whose fragment is not identical to that of the current entry's, and the two share the same Document object, then let hash changed be true, and let old URL be the current entry's URL and new URL be entry's URL. Otherwise, let hash changed be false.
</li>
	<li>
~IF［
`履歴の取扱い$V ~EQ `置換-$i
］
⇒
%履歴 内で %~entry の直前にある~entryを除去する
◎
If historyHandling is "replace", then remove the entry immediately before the specified entry in the session history.
</li>
	<li>
~IF［
%~entry は`持続的な利用者~状態$を伴わない
］~AND［
%~entry の`~URL$の`素片$url ~NEQ ~NULL
］
⇒
`素片へ~scrollする$
◎
If entry is not an entry with persisted user state, but its URL's fragment is non-null, then scroll to the fragment.
</li>
	<li>
%履歴 の`現在の~entry$ ~SET %~entry
◎
Set the current entry to entry.
</li>
	<li>
%状態 ~LET %~entry の`直列形の状態$
◎
↓</li>
	<li>
~IF［
%状態 ~NEQ ~NULL
］
⇒
%状態 ~SET `StructuredDeserialize$jA( %状態, `現在の~Realm~Record$ )
⇒
例外が投出されたときは、~catchして
⇒
%状態 ~SET ~NULL （例外は無視する）
◎
Let targetRealm be the current Realm Record.
◎
If entry has serialized state, then let state be StructuredDeserialize(entry's serialized state, targetRealm). If this throws an exception, catch it, ignore the exception, and let state be null.
◎
Otherwise, let state be null.
</li>
	<li>
`history.state$m ~SET %状態
◎
Set history.state to state.
</li>
	<li>
%状態~変化あり ~LET ［
%文書 の`最近の~entry$ ~NIN { ε, %~entry } ならば ~T ／
~ELSE_ ~F
］
◎
Let state changed be true if entry's Document object has a latest entry, and that entry is not entry; otherwise let it be false.
</li>
	<li>
%文書 の`最近の~entry$ ~SET %~entry
◎
Set entry's Document object's latest entry to entry.
</li>
	<li>
<p>
`~eventは他を阻まない$V に応じて：
◎
↓</p>
		<ul>
			<li>
~F
⇒
下に与える下位手続き (A) を`即時$に走らす
◎
If nonBlockingEvents is false, then run the following substeps immediately.＼
</li>
			<li>
~T
⇒
下に与える下位手続き (A) を走らす`大域~taskを~queueする$( `~DOM操作~task源$, %~entry の`文書$に`関連な大域~obj$ )
◎
Otherwise, queue a global task on the DOM manipulation task source given entry's Document's relevant global object to run the following substeps instead.
</li>
		</ul>
<p>
下位手続き (A) は、次を走らすとする：
◎
↑</p>
		<ol>
			<li>
~IF［
%状態~変化あり ~EQ ~T
］
⇒
%文書 に`関連な大域~obj$に向けて，名前 `popstate$et の`~eventを発火する$
— `PopStateEvent$I を利用し，次のように初期化して
⇒＃
`state$m 属性 ~SET %状態
◎
If state changed is true, then fire an event named popstate at the Document object's relevant global object, using PopStateEvent, with the state attribute initialized to state.
</li>
			<li>
~IF［
%~entry は`持続的な利用者~状態$を伴う
］
⇒
~UAは、`持続的な利用者~状態を復旧-$して，
%文書 と その具現化の側面を更新してもヨイ
◎
If entry is an entry with persisted user state, then the user agent may restore persisted user state and update aspects of the document and its rendering.
</li>
			<li>
~IF［
%~hash変化あり ~EQ ~T
］
⇒
%B にて`作動中の~window$に向けて，名前 `hashchange$et の`~eventを発火する$
— `HashChangeEvent$I を利用し，次のように初期化して
⇒＃
`oldURL$m 属性 ~SET %旧~URL,
`newURL$m 属性 ~SET %新~URL
◎
If hash changed is true, then fire an event named hashchange at the browsing context's active window, using HashChangeEvent, with the oldURL attribute initialized to old URL and the newURL attribute initialized to new URL.
</li>
		</ol>
	</li>
</ol>
</div>

				<section id="persisted-user-state-restoration">
<h4 title="Persisted user state restoration">7.10.10.1. 持続的な利用者~状態の復旧</h4>

<div class="algo">
<p>
~UAは、`~session履歴~entry$ %~entry から
`持続的な利用者~状態を復旧-@
するときは，次の手続きを即時に走らすモノトスル：
◎
When the user agent is to restore persisted user state from a history entry, it must run the following steps immediately:
</p>

<ol>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
<p>
~IF［
%~entry の`~scroll復旧~mode$ ~EQ `manual$l
］
⇒
~UAは、［
%文書 ／ %文書 の~scroll可能域
］用の~scroll位置を復旧するベキでない
— ただし、~scroll可能域のうち，その~scroll復旧が［
%文書 が`属する閲覧文脈$の ある`子~閲覧文脈$の`~session履歴~entry$の`~scroll復旧~mode$
］により制御されているものは除く
</p>

<p>
~ELSE
⇒
~UAは、~scroll位置を復旧してもヨイ
</p>

◎
If the entry has a scroll restoration mode, let scrollRestoration be that. Otherwise let scrollRestoration be "auto"
◎
If scrollRestoration is "manual", then the user agent should not restore the scroll position for the Document or any of its scrollable regions, with the exception of any child browsing contexts of Document's browsing context whose scroll restoration is controlled by their own history entry's scroll restoration mode, otherwise, it may do so.
</li>
	<li>
任意選択で
⇒
%文書 とその具現化の他の側面を更新する
— 一例として，~UAが以前に記録した~form欄の値など。
◎
Optionally, update other aspects of the document and its rendering, for instance values of form fields, that the user agent had previously recorded.
</li>
</ol>
</div>

<p class="note">注記：
持続的~状態が，そのような~controlにおける利用者~入力の書字方向性を含む場合、これには，次に該当する要素の `dir$a 属性を更新することも含まれる
⇒
`textarea$e 要素 ／
`input$e 要素のうち［
その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］を満たすもの
◎
This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in either the Text state or the Search state, if the persisted state includes the directionality of user input in such controls.
</p>

<p class="note">注記：
~UAが~scroll位置を復旧しないことは、~scroll位置が特定0の値（例： (0,0) ）に~~維持されることを含意するものではない。
実際の~scroll位置は［
~naviの種別や, ~UAによる~caching-strategy
］に依存する。
なので、~web~appは，特定0の~scroll位置に決まるとは見做せない
— ~appには、自身が求めるものに設定することが督促される。
◎
Not restoring the scroll position by user agent does not imply that the scroll position will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.
</p>

				</section>
				<section id="the-popstateevent-interface">
<h4 title="The PopStateEvent interface">7.10.10.2. `PopStateEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `PopStateEvent@I : `Event$I {
  constructor(DOMString %type, optional `PopStateEventInit$I %eventInitDict = {});

  readonly attribute any `state$m;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any state = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `state$m</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>
</dl>

<dl class="idl-def">
	<dt>`state@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The state attribute must return the value it was initialized to.＼
</dd>
	<dd>
この~event用の文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>
</dl>

				</section>
				<section id="the-hashchangeevent-interface">
<h4 title="The HashChangeEvent interface">7.10.10.3. `HashChangeEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `HashChangeEvent@I : `Event$I {
  constructor(DOMString %type, optional `HashChangeEventInit$I %eventInitDict = {});

  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `oldURL$m</dt>
	<dd>
履歴を辿る直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event . `newURL$m</dt>
	<dd>
履歴を辿った直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>`oldURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The oldURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を辿る直前の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>`newURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The newURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を辿った直後の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>

				</section>
				<section id="the-pagetransitionevent-interface">
<h4 title="The PageTransitionEvent interface">7.10.10.4. `PageTransitionEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `PageTransitionEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageTransitionEventInit$I %eventInitDict = {});

  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event . `persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
~pageが新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の~pageが最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、この~pageは，利用者がこの~pageに~navigateして戻った場合に（その~pageを回復可能でなくするものが他になければ）再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page.
</dd>
	<dd>
<p>
~pageを回復可能でなくするものには次が含まれる：
</p>

<ul ><li>`beforeunload$et ~event用の~listenerがあるとき
</li><li>`unload$et ~event用の~listenerがあるとき
</li><li>回復可能でない `iframe$e があるとき
</li><li>作動中の `WebSocket$I ~objがあるとき
</li><li>`文書を中止-$したとき
</li></ul>

◎
Things that can cause the page to be unsalvageable include:

• Listening for beforeunload events
• Listening for unload events
• Having iframes that are not salvageable
• Active WebSocket objects
• Aborting a Document 
</dd>

</dl>

<dl class="idl-def">
	<dt>`persisted@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The persisted attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

				</section>
			</section>
			<section id="loading-documents">
<h4 title="Loading documents">7.10.11 文書の読込n法</h4>

<p>
各 `文書$には
`完全に読込まれた時刻@
（ある時刻または ~NULL ）があり、初期~時には ~NULL とする。
◎
A Document has a completely loaded time (a time or null), which is initially null.
</p>

<p>
所与の`文書$は、`完全に読込まれた時刻$ ~NEQ ~NULL ならば
`完全に読込まれた@
ものと見なされる。
◎
A Document is considered completely loaded if its completely loaded time is non-null.
</p>

<div class="algo">
<p>
`文書$ %文書 の
`読込ngを完全に終わらす@
ときは：
◎
To completely finish loading a Document document:
</p>
<ol>
	<li>
~Assert：
%文書 が`属する閲覧文脈$ ~NEQ ~NULL
◎
Assert: document's browsing context is non-null.
</li>
	<li>
%文書 の`完全に読込まれた時刻$ ~SET 現在の時刻
◎
Set document's completely loaded time to the current time.
</li>
	<li>
%容器 ~LET %文書が`属する閲覧文脈$の`容器$bc
◎
Let container be document's browsing context's container.
</li>
	<li>
~IF［
%容器 は `iframe$e 要素である
］
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %容器 )
⇒
`~iframe~load~event手続き$( %容器 )
◎
If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.
</li>
	<li>
~ELIF［
%容器 ~NEQ ~NULL
］
⇒
次を走らす`要素~taskを~queueする$ `~DOM操作~task源$, %容器 )
⇒
%容器 に向けて名前 `load$et の`~eventを発火する$
◎
Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
</li>
</ol>
</div>

			</section>
			<section id="unloading-documents">
<h3 title="Unloading documents">7.10.12. 文書の~unload法</h3>

<div>
<p>
`文書$は、次のものを持つ：
</p>

<dl>
	<dt>`回復可能~状態@doc</dt>
	<dd>
初期~時には ~T になるモノトスル。
</dd>

	<dt>`~unload発火-済み~flag@doc</dt>
	<dd>
初期~時には ~F になるモノトスル。
</dd>

	<dt>`~page表示中~flag@doc</dt>
	<dd>
初期~時には ~F になるモノトスル。
この~flagは、~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受取る（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受取ったり，その逆が生じることは決してない）ことを確保するために利用される。
</dd>
</dl>

◎
A Document has a salvageable state, which must initially be true, a fired unload flag, which must initially be false, and a page showing flag, which must initially be false. The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</div>

<p>
各`~event~loop$は、
`終了入子~level@
と呼ばれる~counterを有する
— 初期~時には 0 になるモノトスル。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<div class="algo">
<p>
`文書の~unloadを~promptする@
ときは、所与の
( `文書$ %文書, %再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To prompt to unload, given a Document object document and optionally a recursiveFlag, run these steps:
</p>

<ol>
	<li>
`~event~loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by 1.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase the document's ignore-opens-during-unload counter by 1.
</li>
	<li>
%event ~LET `~eventを作成する$( `BeforeUnloadEvent$I )
◎
Let event be the result of creating an event using BeforeUnloadEvent.
</li>
	<li>
%event の属性を次のように初期化する
⇒＃
`type$m ~SET `beforeunload$et,
`cancelable$m ~SET ~T
◎
Initialize event's type attribute to beforeunload and its cancelable attribute true.
</li>
	<li>
%文書 に`関連な大域~obj$に向けて %event を`配送する$
◎
Dispatch: Dispatch event at document's relevant global object.
</li>
	<li>
`~event~loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by 1.
</li>
	<li>
~IF［
%event 配送-時に何らかの~event~listenerが誘発された
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If any event listeners were triggered by the earlier dispatch step, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
次のいずれも満たされる
］…：
◎
↓</p>
		<ul>
			<li>
`~sandbox化( ~modal )~flag$ ~NIN %文書 の`作動中の~sandbox法~flag集合$
◎
If document's active sandboxing flag set does not have its sandboxed modals flag set, and＼
</li>
			<li>
［
%event の `returnValue$m 属性 ~NEQ 空~文字列
］~OR［
%event は取消された
］
◎
the returnValue attribute of the event object is not the empty string, or if the event was canceled, then＼
</li>
		</ul>
<p>
…ならば
⇒
~UAは、利用者に， %文書 の~unloadを望むかどうか確認をとってもヨイ：
◎
the user agent may ask the user to confirm that they wish to unload the document.
</p>

<p class="note">注記：
利用者に示される~messageは、~custom化することはできず，~UAにより決定される。
特に、 `returnValue$m 属性の実際の値は無視される。
◎
The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.
</p>
		<ul>
			<li>
~UAは，そうすることが利用者にとって［
いらつく／紛らわしい／的外れである
］と判定したときは、利用者に確認をとらないことが奨励される。
単純な経験則として、利用者が %文書 とやりとりしていなければ，とらないことが挙げられる。
◎
The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless. A simple heuristic might be that if the user has not interacted with the document, the user agent would not ask for confirmation before unloading it.
</li>
			<li>
~UAは，利用者に確認をとる場合には、利用者からの応答を待機している間，`静止-$するモノトスル。
◎
If the user agent asks the user for confirmation, it must pause while waiting for the user's response.
</li>
			<li>
利用者から~page~naviの確認をとれなかった場合、 %文書 の
`~unloadは利用者から拒否された@
とされる。
◎
If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
<p>
%文書 の`子孫~閲覧文脈~list$ 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
Let descendants be the list of the descendant browsing contexts of document.
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書の~unloadを~promptする$( %作動中の文書, `再帰的^i )
⇒
~IF［
%作動中の文書 の`~unloadは利用者から拒否された$
］
⇒
~BREAK
（ %文書 についても暗黙的に`~unloadは利用者から拒否された$ことになる）
◎
Prompt to unload browsingContext's active document with the recursiveFlag set. If the user refused to allow the document to be unloaded, then the user implicitly also refused to allow document to be unloaded; break.
</li>
					<li>
~IF［
%作動中の文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of browsingContext's active document is false, then set the salvageable state of document to false.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease the document's ignore-opens-during-unload counter by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書を~unloadする@
ときは、所与の
( `文書$ %文書, %再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To unload a Document document, optionally given a recursiveFlag:
</p>

<ol>
	<li>
`~event~loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by one.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase document's ignore-opens-during-unload counter by one.
</li>
	<li>
<p>
~IF［
%文書 の`~page表示中~flag$doc ~EQ ~T
］：
◎
If document's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the pagehide event and don't rerun the unloading document visibility change steps).
</p>
		<ol>
			<li>
%文書 の`~page表示中~flag$doc ~SET ~F
◎
Set document's page showing flag to false.
</li>
			<li>
%文書 に`関連な大域~obj$に向けて，名前 `pagehide$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒
`persisted$m 属性 ~SET %文書 の`回復可能~状態$doc
◎
Fire an event named pagehide at document's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true if document's salvageable state is true, and false otherwise, and legacy target override flag set.
</li>
			<li>
<p>
`適用-可能な仕様$により定義される
`~unload中の文書の可視性~変化-時の手続き@
があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document visibility change steps for document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用-に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%文書 の`~unload発火-済み~flag$doc ~EQ ~F
］
⇒
%文書 に`関連な大域~obj$に向けて，名前 `unload$et の`~eventを発火する$( `~targetを上書きする^i )
◎
Unload event: If document's fired unload flag is false, then fire an event named unload at document's relevant global object, with legacy target override flag set.
</li>
	<li>
`~event~loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by one.
</li>
	<li>
~IF［
前~前~段にて，何らかの~event~listenerが誘発された
］
⇒＃
%文書 の`回復可能~状態$doc ~SET ~F；
%文書 の`~unload発火-済み~flag$doc ~SET ~T
◎
If any event listeners were triggered by the earlier unload event step, then set document's salvageable state to false and set document's fired unload flag to true.
</li>
	<li>
この仕様も含む`適用-可能な仕様$にて定義される
`文書~unload時の片付け手続き$があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document cleanup steps for document that are defined by this specification and other applicable specifications.
</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
%子孫~list ~LET %文書 の`子孫~閲覧文脈~list$
◎
Let descendants be the list of the descendant browsing contexts of document.
</li>
			<li>
<p>
%子孫~list 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書を~unloadする$( %作動中の文書, `再帰的^i )
◎
Unload the active document of browsingContext with the recursiveFlag set.
</li>
					<li>
~IF［
%作動中の文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of the active document of browsingContext is false, then set the salvageable state of document to false also.
</li>
				</ol>
			</li>
			<li>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
`文書を破棄する$( %文書 )
◎
If document's salvageable state is false, then discarddocument.
</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease document's ignore-opens-during-unload counter by one.
</li>
</ol>
</div>

<div class="algo">
<p>
`適用-可能な仕様$は、
`文書~unload時の片付け手続き@
を定義できる。
この仕様が定義する`文書~unload時の片付け手続き$は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a Document document:
</p>

<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
~EACH( `WebSocket$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`消滅させる$
◎
For each WebSocket object webSocket whose relevant global object is window, make disappear webSocket.
</li>
	<li>
~IF［
前~段により影響された `WebSocket$I ~objはある
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If this affected any WebSocket objects, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］：
◎
If document's salvageable state is false, then:
</p>
		<ol>
			<li>
~EACH( `EventSource$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に閉じる$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%文書 の`~window$の`作動中の~timer~list$を空にする
◎
Empty window's list of active timers.
</li>
		</ol>
	</li>
</ol>
</div>

				<section id="the-beforeunloadevent-interface">
<h4 title="The BeforeUnloadEvent interface">7.10.12.1. `BeforeUnloadEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>

<p class="note">注記：
`BeforeUnloadEvent$I に特有な初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I
~interfaceは、旧来の~interfaceである
— それは、~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定することで
`文書の~unloadを~promptする$処理を制御できるようにする。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するベキである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>`returnValue@m</dt>
	<dd>
この属性は、`文書の~unloadを~promptする$処理nを制御する。
◎
The returnValue attribute controls the process of prompting to unload.＼
</dd>
	<dd>
~eventの作成-時には、この属性は空~文字列に設定されるモノトスル。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、この属性に最後に設定された値を返すモノトスル。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、この属性を所与の値に設定するモノトスル。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、もっぱら歴史的な理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
			<section id="aborting-a-document-load">
<h3 title="Aborting a document load">7.10.13. 文書~読込nの中止-法</h3>

<div class="algo">
<p>
`文書を中止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To abort a Document document:
</p>

<ol>
	<li>
<p>
%文書 が`属する閲覧文脈$の
~EACH( `子~閲覧文脈$ %子 )
に対し：
</p>
		<ol>
			<li>
%子~文書 ~LET %子 にて`作動中の文書$
</li>
			<li>
`文書を中止する$( %子~文書 )
</li>
			<li>
~IF［
%子~文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Abort the active documents of every child browsing context. If this results in any of those Document objects having their salvageable state set to false, then set document's salvageable state to false also.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceたちがある
］
⇒
</p>
		<ol>
			<li>
<p>
それらを取消す
— 以降
⇒＃
それらに対し`~queueされ$る`~task$は破棄する ／
それらに対し~networkから受信される更なる~dataは破棄する
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Cancel any instances of the fetch algorithm in the context of document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 には`作動中の構文解析器$がある
］：
◎
If document has an active parser, then:
</p>
		<ol>
			<li>
%文書 の`作動中の構文解析器は中止された？$ ~SET ~T
◎
Set document's active parser was aborted to true.
</li>
			<li>
その`構文解析器を中止する$
◎
Abort that parser.
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは、利用者が明示的に`文書を中止する$~algoを呼出すことを許容してもヨイ。
利用者がそれをした場合、その`文書$が`作動中の文書$であるならば、~UAは，`文書を中止する$~algoを呼出す前に，次を走らす`~taskを~queueする$ベキである
⇒
その`文書$に`関連な大域~obj$に向けて，名前 `abort$et の`~eventを発火する$
◎
User agents may allow users to explicitly invoke the abort a document algorithm for a Document. If the user does so, then, if that Document is an active document, the user agent should queue a task to fire an event named abort at that Document object's relevant global object before invoking the abort algorithm.
</p>

<div class="algo">
<p>
`文書の読込ngを停止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To stop document loading given a Document object document, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not an active document, then return.
</li>
	<li>
%閲覧文脈 ~LET %文書 が`属する閲覧文脈$
◎
Let browsingContext be document's browsing context.
</li>
	<li>
~IF［
%閲覧文脈 を`~navigate$しようとする既存の試みがある
］~AND［
その試みは`文書を~unloadする$~algoを現在~走らせていない
］
⇒
その`~navi$を取消す
◎
If there is an existing attempt to navigate browsingContext and that attempt is not currently running the unload a document algorithm, then cancel that navigation.
</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
</ol>
</div>

			</section>
			<section id="the-x-frame-options-header">
<h4 title="The X-Frame-Options header">7.10.14 `X-Frame-Options^h ~header</h4>

<p>
`X-Frame-Options$h ~HTTP応答~headerは、［
`文書$は`子~閲覧文脈$の内側に どう読込まれてもよいか
］を制御する，旧来の仕方である。
それは、［
同じ状況に対し，もっと細やかな制御を供する
`frame-ancestors$dir ~CSP指令 `CSP$r
］により，廃用にされた。
それは、元々は
`HTTP Header Field X-Frame-Options^cite `RFC7034$r
にて定義されたが，ここでの定義と処理~modelは、その文書に取って代わる。
◎
The `X-Frame-Options` HTTP response header is a legacy way of controlling whether and how a Document may be loaded inside of a child browsing context. It is obsoleted by the frame-ancestors CSP directive, which provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. [CSP] [RFC7034]
</p>

<p class="note">注記：
特に，
`HTTP Header Field X-Frame-Options^cite
は、その~header値~用の変種として `ALLOW-FROM^bl も指定したが，それは実装されていない。
◎
In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be implemented.
</p>

<p class="note">注記：
下に与える処理~modelにより、
`X-Frame-Options$h ~headerは，同じ`応答$内に
~CSP `frame-ancestors$dir 指令も利用された場合には無視される。
◎
Per the below processing model, if both a CSP frame-ancestors directive and an `X-Frame-Options` header are used in the same response, then `X-Frame-Options` is ignored.
</p>

<p>
［
~web開発者／適合性~検査器
］向けとして，その値の`~ABNF$は：
◎
For web developers and conformance checkers, its value ABNF is:
</p>

<pre class="bnf">
X-Frame-Options = "DENY" / "SAMEORIGIN"
</pre>

<div class="algo">
<p>
`~navi応答の~X-Frame-Optionsに対する固守を検査する@
ときは、所与の
( `応答$ %応答, `閲覧文脈$ %B, `生成元$ %行先~生成元 )
に対し：
◎
To check a navigation response's adherence to `X-Frame-Options`, given a response response, a browsing context browsingContext, and an origin destinationOrigin:
</p>
<ol>
	<li>
~IF［
%B は`子~閲覧文脈$でない
］
⇒
~RET ~T
◎
If browsingContext is not a child browsing context, then return true.
</li>
	<li>
<p>
%応答 の`~CSP~list$rsを成す
~EACH( %施策 )
に対し：
◎
For each policy of response's CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^bl
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
`frame-ancestors$dir 指令 ~IN %施策 の`指令~集合$
］
⇒
~RET ~T
◎
If policy's directive set contains a frame-ancestors directive, then return true.
</li>
		</ol>
	</li>
	<li>
%生~X~frame~options ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `X-Frame-Options$h )
◎
Let rawXFrameOptions be the result of getting, decoding, and splitting `X-Frame-Options` from response's header list.
</li>
	<li>
<p>
~IF［
%生~X~frame~options ~EQ ~NULL
］
⇒
~RET ~T
</p>
<p class="trans-note">【
この段は、この訳による補完（ %応答 内に `X-Frame-Options$h は無い）。
】</p>
	</li>
	<li>
%~X~frame~options ~LET 新たな`集合$
◎
Let xFrameOptions be a new set.
</li>
	<li>
%生~X~frame~options を成す
~EACH( %値 )
に対し
⇒
%~X~frame~options に次の結果を`付加する$set
⇒
`~ASCII小文字~化する$( %値 ) 
◎
For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.
</li>
	<li>
<p>
~IF［
%~X~frame~options の`~size$ ~GT 1
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~X~frame~options を成す
~EACH( %値 )
に対し
⇒
~IF［
%値 ~IN { `deny^bl, `allowall^bl, `sameorigin^bl }
］
⇒
~RET ~F
◎
If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then return false.
</p>

<p class="note">注記：
ここでの意向は、
`X-Frame-Options$h が［
妥当な何かを行おうと試行しているが，紛らわしく現れる
］場合には，それを適用する際に 【埋込もうとする】どの試みも阻止することにある。
◎
The intention here is to block any attempts at applying `X-Frame-Options` which were trying to do something valid, but appear confused.
</p>

<p class="note">注記：
旧来の `ALLOWALL^bl 値による処理~modelに対する影響iは、ここに限られる。
◎
This is the only impact of the legacy `ALLOWALL` value on the processing model.
</p>
			</li>
			<li>
<p>
~RET ~T
◎
If xFrameOptions's size is greater than 1, then return true.
</p>

<p class="note">注記：
~headerは、複数個の妥当でない値を包含している
— この場合、~headerが まるごと省略されていたときと同じ仕方で扱う。
◎
This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~X~frame~options[ 0 ] ~EQ `deny^bl
］
⇒
~RET ~F
◎
If xFrameOptions[0] is "deny", then return false.
</li>
	<li>
<p>
~IF［
%~X~frame~options[ 0 ] ~EQ `sameorigin^bl
］：
◎
If xFrameOptions[0] is "sameorigin", then:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
</p>
				<ol>
					<li>
%容器~文書 ~LET %B の`容器~文書$
</li>
					<li>
~IF［
%容器~文書 ~EQ ~NULL
］
⇒
~BREAK
</li>
					<li>
~IF［
( %容器~文書 の`生成元$, %行先~生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
</li>
					<li>
%B ~LET %容器~文書 が`属する閲覧文脈$
</li>
					<li>
~IF［
%B ~EQ ~NULL
］
⇒
~BREAK
</li>
				</ol>
◎
Let containerDocument be browsingContext's container document.
◎
While containerDocument is not null:
• If containerDocument's origin is not same origin with destinationOrigin, then return false.
• Let containerBC be containerDocument's browsing context.
• Set containerDocument to containerBC's container document, if containerBC is non-null; otherwise, null.
</li>
		</ol>
	</li>
	<li>
<p>
~RET ~T
◎
Return true.
</p>

<p class="note">注記：
ここまで達した場合、妥当でない 1 個の値からなる（旧来の［
`ALLOWALL^bl ／ `ALLOW-FROM^bl
］形も該当する）
— この場合、~headerは まるごと省略されていたかのように扱う。
◎
If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.
</p>
	</li>
</ol>
</div>

<hr>

<div class="example">

<p>
この~header用の様々な値の処理を
— 不適合tなものも含め —
次の表に示す：
◎
The following table illustrates the processing of various values for the header, including non-conformant ones:
</p>

<div>
<table><thead><tr><th>`X-Frame-Options$h
<th>妥当？
<th>結果

</thead><tbody><tr><td>`DENY^bl
<td>✅
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN^bl
<td>✅
<td>同一-生成元なら埋込みは許容される

<tr><td>`INVALID^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOWALL^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOW-FROM=https://example.com/^bl
<td>❌
<td>埋込みは許容される（どこからでも）

</tbody></table>
◎
`X-Frame-Options`	Valid	Result
`DENY`	✅	embedding disallowed
`SAMEORIGIN`	✅	same-origin embedding allowed
`INVALID`	❌	embedding allowed
`ALLOWALL`	❌	embedding allowed
`ALLOW-FROM=https://example.com/`	❌	embedding allowed (from anywhere)
</div>

</div>

<div class="example">

<p>
複数の値を孕んでいる，様々な不適合tな事例がどう処理されるかを，次の表に示す：
◎
The following table illustrates how various non-conformant cases involving multiple values are processed:
</p>

<div>

<table><thead>
<tr><th>`X-Frame-Options$h
<th>結果
</thead><tbody>

<tr><td>`SAMEORIGIN, SAMEORIGIN^bl
<td>同一-生成元なら埋込みは許容される

<tr><td>`SAMEORIGIN, DENY^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN,^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, ALLOWALL^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL,^bl
<td>埋込みは許容されない

<tr><td>`INVALID, INVALID^bl
<td>埋込みは許容される

</tbody></table>

◎
`X-Frame-Options`	Result
`SAMEORIGIN, SAMEORIGIN`	same-origin embedding allowed
`SAMEORIGIN, DENY`	embedding disallowed
`SAMEORIGIN,`	embedding disallowed
`SAMEORIGIN, ALLOWALL`	embedding disallowed
`SAMEORIGIN, INVALID`	embedding disallowed
`ALLOWALL, INVALID`	embedding disallowed
`ALLOWALL,`	embedding disallowed
`INVALID, INVALID`	embedding allowed
</div>

<p>
値たちが［
~commaで区切られた値を伴う 1 個の~header,
複数個の~header
］どちらで送達されようが，得される結果は同じになる。
◎
The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple headers.
</p>
</div>

			</section>
		</section>
		<section id="offline">
<h2 title="Offline web applications">7.11. ~offline~web~app</h2>

<p class="critical">
この特能は、~web~platformから除去されつつある過程にある（何年もかかるであろう）。
今では、~offline~web~app特能は，利用しないことが強く奨励される。
代わりに、~sw `SW$r を利用すること。
◎
This feature is in the process of being removed from the web platform. (This is a long process that takes many years.) Using any of the offline web application features at this time is highly discouraged. Use service workers instead. [SW]
</p>

<p class="trans-note">【
以下、この節の内容は未訳。
このサイトのこの仕様の和訳における
`~app~cache用@
…
と記された箇所も未訳であり、実際の原文では，この節にて定義される各種~用語を利用する内容が記述されている。
言い換えれば、和訳は，~UAがこの節に述べられる機能を~supportしていないかのように単純~化して記述している。
】</p>

		</section>
</main>
