<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">

<title>Subresource Integrity</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

i {
	text-decoration: underline;
}

.hash-func {
	font-family: sans-serif0, sans-serif;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'sc':
	text = `${key}:`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2016-06-23
trans_update:2017-12-04
source_checked:160622
page_state_key:WEBAPPSEC
original_url:https://www.w3.org/TR/2016/REC-SRI-20160623/
		original_url:https://w3c.github.io/webappsec-subresource-integrity/
		original_url:https://www.w3.org/TR/SRI/

spec_status:REC
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2014-2016,use
trans_1st_pub:2016-06-22


●●class_map
P:production
h:header
e:element
a:attr
et:event-type
hS:hash-func
dir:directive
v:value
sc:scheme

●●tag_map
p:var
P:code
h:code
e:code
a:code
et:code
I:code
m:code
dir:code
sc:code
v:code
c:code
s:samp
hS:span
V:var
i:i
em:em

●●words_table


	ABNF:
	Section:#1
	Service Worker

tab::::タブ
bookmarklet:
command-line:command line::コマンド行::コマンドライン
framework::::フレームワーク
	Document
	MIME


	●network
CDN:
log-in::::ログイン
payload::::ペイロード
中継:intermediate::~
大域一意:globally unique::~
要請者:requestor::~::リクエスト者

符号法:coding::~::コーディング
低速:slow:~
優先度:priority:~
優先-:prioritize:~

	:loading
	経路上で:in-flight:

	●保安
	CORS-enabled
	NIST
	Integrity
	SHA-1
	SHA-384
	SHA384
	MD5
pin:
base64:
username::::
digest::::ダイジェスト
hash::::ハッシュ
hashing::::ハッシュ
衝突:collision::~
衝突耐性:collision-resistant::~
推測-:guess:~
推定-:surmise:~
認証-:authenticate::~
警告:warning:~
注視-:watch:~
洞察:insight:~
	洞察を得る:gain some insight into
読取る:readする::読み取る
読取れる:readできる::読み取れる
管理者:administrator::~
弱い:weakな::~
最強:strongest::~
弱体化-:compromise::~
弱体化:compromise::~
暗号上の:cryptographic::~
暗号用:cryptographic::~
汚染:poisoning::~
高特権:high-privilege::~
総当たり:brute-force::~
	総当たり:brute-forcing
式:expression:~
適格:eligible::~
露呈-:reveal::~
騙せる:trickできる::~
	~secure化法:securing
	~secureでない:insecure
	~secureな文脈:Secure Context

	●仕様
utility::::ユーティリティ
切替えれ:switchでき:切り替えれ
即応性:agility:~
機敏:agile:~
	機敏に対応できる:provide agility
古い:older:~
拒否-:refuse:~
拡げる:expandする:~
枠組み:scheme:~
定期的:regular basis:~
煮詰める:boil downする:~
移行-:migrate::~
稀:rare:~
選択肢:option:~
直面-:face:~

	評価し直-:re-evaluate
	無論:of course:もちろん
	咎め無く:impunity
	対象にしている:meant to
	対象範囲 this coverage
	し続ける:stay aware
	多様な:wide variety of
	現時点では:at the moment
	縛られることなく:being held back by
	〜ない見込みが高い:unlikely:
	着想を得ている:heavily inspired
	無論:of course
	~~主要な:key
	~~判明した:show
	~~実際に:in fact

	●未分類
一重引用符:single quote::~
印字可能:printing:~
準備-:prepare:~
改ざん:alter:~
構成-:compose:~
確認-:confirm:~
解析:analytics:~
分割-:split:~
発見:discovery:~
全世界の:globally-distributed:~
代用-:substitute::~
繰返し:repeatedly:繰り返し

	文法~上の:grammatical
	走っている:running
	期待される値:expectedValue
	~metadata~list:metadataList
	新~algo:newAlgorithm
	現~algo:currentAlgorithm
	解析済み~metadata:parsedMetadata
	実~値:actualValue

	最終的:eventual
	New
	alg:
	良好な~~基準:good baseline
	basis
	broken
	とらえ:catch
	content-coding
	content-encoding

	encodedResult
	good
	hi
	in-order
	least
	line:
	moreover
	most
	note
	part
	per
	piece
	provided

	refer
	remain
	shown
	space
	src
	stay
	~~十分:sufficient
	surmise
	sync
	taint
	time
	uRI
	不幸な~~形に~unfortunate ways
	unsupported
	val
	wide
	自身が通話相手だと信じる~serverが~~本物である:indeed speaking with the server it believes it’s talking to
	~全体を通してthroughout:

	-:perhaps
	かなりの部分:much of
	ごく:quite
	ずっと:much
	たまたま:happen
	なり次第:begin
	広く:broadly
	予め算出-:precompute
	二次的な:secondary
	伝える:informする
	何でもできる:do absolutely anything else
	前:previous
	加えて:additionally
	し続ける:stays in
	壊れて:broken
	抗して:against
	指す:pointed~to
	指す:refer
	更には:moreover
	書-:write
	直前の:immediately precede
	相応の確証を得られる:fairly certain
	種々の／様々な:a variety of
	選ぶ:choose
	ことごとく:every


●●original_id_map


●●words_table1


RFC6454:RFC6454-ja.html
CSP2:CSP-ja.html
	HTML50:https://www.w3.org/TR/html5


●●link_map



I.HTMLLinkElement:~HEmetadata#htmllinkelement
I.HTMLScriptElement:~HEscripting#htmlscriptelement

P.alg:#_alg
P.val:#_val
P.opt:#_opt

P.integrity-metadata:#_integrity-metadata
P.hash-with-options:#_hash-with-options
P.option-expression:#_option-expression
P.hash-expression:#_hash-expression
P.hash-source:~CSP2#hash_source
	P.hash-source:~CSP3#grammardef-hash-source
P.hash-algo:~CSP2#hash_algo
	P.hash-algo:~CSP3#grammardef-hash-algo
P.base64-value:~CSP2#base64_value
	P.base64-value:~CSP3#grammardef-base64-value

P.VCHAR:#dfn-vchar
P.WSP:#dfn-wsp

a.integrity:#the-integrity-attribute
m.integrity:#element-interface-extensions

e.script:~HEscripting#the-script-element
e.link:~HEmetadata#the-link-element

et.error:~HTMLindex#event-error

hS.SHA-256:#dfn-sha-2
hS.SHA-384:#dfn-sha-2
hS.SHA-512:#dfn-sha-2
hS.SHA-2:#dfn-sha-2
~digest:#dfn-digest
V.…( ~digest )…:#dfn-digest
~base64符号化法:#dfn-base64-encoding
getPrioritizedHashFunction:#dfn-getprioritizedhashfunction-a-b
	#dfn-getprioritizedhashfunction？
完全性~metadata:#dfn-integrity-metadata
適用-:#apply-algorithm-to-response
完全性~検証に適格:#is-response-eligible-for-integrity-validation
最も強い~metadataを取得-:#get-the-strongest-metadata-from-set
構文解析-:#parse-metadata

	#does-response-match-metadatalist
	#hash-collision-attacks
	#non-secure-contexts-remain-non-secure
生成元:#dfn-origin
	base64 encoding:dfn-base64-encoding
表現~data:~HTTPsem#representation.data
	~RFC7231#section-3
	#dfn-representation-data
内容~符号法:~HTTPsem#content.codings
	~RFC7231#section-3.1.2.1
	#dfn-content-encoding

h.Content-Encoding:~HTTPsem#field.content-encoding
h.Cache-Control:~HTTPcache#field.cache-control
	h.Cache-Control:~RFC7234#section-5.2
dir.no-transform:~HTTPcache#cache-response-directive.no-transform
	dir.no-transform:~RFC7234#section-5.2.1.6

~secureな文脈:~SECURE-CONTEXT#secure-contexts

~fetch:~FETCH#concept-fetch
	pinned public keys:~RFCx/rfc7469
rq.
	要請の一部:~FETCH#concept-request-integrity-metadata
	応答~種別:~FETCH#concept-response-type
rs.種別:~FETCH#concept-response-type
rs.本体:~FETCH#concept-response-body
	:http://www.w3.org/Security/wiki/Same_Origin_Policy
	:~CSP2#source-list-syntax


~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
	~HTML50/infrastructure.html#split-a-string-on-spaces

反映する:~HTMLcdom#reflect
	~HTML50/infrastructure.html#reflect
~CORS設定群~属性:~HTMLurl#cors-settings-attributes
	~HTML50/infrastructure.html#cors-settings-attributes
資源を得しようと試みる:~HEmetadata#fetch-and-process-the-linked-resource
	~HTML50/document-metadata.html#concept-link-obtain


●●spec_metadata


このバージョン
	https://www.w3.org/TR/2016/REC-SRI-20160623/

最新発行バージョン
	https://www.w3.org/TR/SRI/

編集者草案
	https://w3c.github.io/webappsec-subresource-integrity/

実装報告
	https://github.com/w3c/webappsec-subresource-integrity/wiki/Links

以前のバージョン
	https://www.w3.org/TR/2016/PR-SRI-20160510/

編集
	<a href="http://devd.me">Devdatta Akhawe</a>, Dropbox, Inc., <a href="mailto:dev.akhawe@gmail.com">dev.akhawe@gmail.com</a>
	<a href="https://frederik-braun.com/">Frederik Braun</a>, Mozilla, <a href="mailto:fbraun@mozilla.com">fbraun@mozilla.com</a>
	<a href="https://fmarier.org">François Marier</a>, Mozilla, <a href="mailto:francois@mozilla.com">francois@mozilla.com</a>
	<a href="https://joelweinberger.us/">Joel Weinberger</a>, Google, Inc., <a href="mailto:jww@google.com">jww@google.com</a>

Participate:
	<a href="https://github.com/w3c/webappsec-subresource-integrity">We are on Github.</a>
	<a href="https://github.com/w3c/webappsec-subresource-integrity/issues">File a bug.</a>
	<a href="https://github.com/w3c/webappsec-subresource-integrity/commits/gh-pages">Commit history.</a>
	<a href="https://lists.w3.org/Archives/Public/public-webappsec/">Mailing list</a>: <a href="mailto:public-webappsec@w3.org?subject=%5BSRI%5D">public-webappsec@w3.org</a> (<a href="mailto:public-webappsec-request@w3.org?subject=subscribe">subscribe</a>)

<a href="https://www.w3.org/2016/SRI-errata.html">正誤表</a>
	この文書に対する修正があれば掲載されます。

<a href="https://www.w3.org/Consortium/Translation/">各国語翻訳（非規範的）</a>
	英語版のみがこの仕様の規範的バージョンです。


●●ref_normative
[ABNF]
    D. Crocker, Ed.; P. Overell. IETF. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[CORS]
    Anne van Kesteren. W3C. Cross-Origin Resource Sharing. 16 January 2014. W3C Recommendation. URL: http://www.w3.org/TR/cors/ 
[FETCH]
    Anne van Kesteren. WHATWG. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[MIMETYPE]
    Ned Freed; Nathaniel S. Borenstein. IETF. Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. Draft Standard. URL: https://tools.ietf.org/html/rfc2046 
[RFC2119]
    S. Bradner. IETF. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC4648]
    Simon Josefsson. IETF. The Base16, Base32, and Base64 Data Encodings. Proposed Standard. URL: https://tools.ietf.org/html/rfc4648 
[RFC6454]
    A. Barth. IETF. The Web Origin Concept. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. IETF. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告として公開された
<a href="~SPEC_URL">Subresource Integrity</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>



<body>

<header>



	<hgroup>
<h1 id="title">下位資源の完全性 — Subresource Integrity</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この仕様は、［
~fetchした資源は，期待されない操作により送達されていない
］ことを，~UAが検証yできるようにする仕組みを定義する。
◎
This specification defines a mechanism by which user agents may verify that a fetched resource has been delivered without unexpected manipulation.
</p>
	</section>
	<section id="status">

~STATUSofTHIS

<p>
<!-- 
これは編集者草案の~~公の複製です…
 -->
この節では、発行時点における…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
この文書は
<a href="http://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>
により勧告として~~発行されました。
◎
This document was published by the Web Application Security Working Group as a Recommendation. If you wish to make comments regarding this document, please send them to public-webappsec@w3.org (subscribe, archives) with [SRI] at the start of your email's subject. All comments are welcome.
 </p>

<p>
W3C は、この勧告に指定される機能性は，
<a href="https://fetch.spec.whatwg.org/">Fetch 仕様</a>
に対する変更からは影響されないものと期待しています。
Working Group は、この仕様に~~影響を及ぼすような
Fetch 仕様とその課題を追跡し続けることになります。
◎
W3C expects the functionality specified in this Recommendation will not be affected by changes to Fetch. The Working Group will continue to track the Fetch specification and document issues that impact this specification.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web上の~siteや~appが，単独の生成元のみからの資源で構成されることは稀である。
例えば，作者は、多様な［
~service／ ~CDN （ Content Delivery Network, “内容~送達~network” ）
］から，~scriptや~stylesheetを~pullする
— 作者は、送達された表現が［
読込まれるものと自身が期待するものと，~~実際に~~相違ない
］ことを信用しなければナラナイ。
攻撃者が，敵対的~serverからの内容を~downloadするよう 利用者を騙せる場合（
<a href="~RFCx/rfc1035">DNS</a>
汚染, その他の手段を介して）、作者にできる手立てはない。
同様に、~CDN~server上の~fileを置換できる攻撃者は，任意な内容を注入できる能を有する。
◎
Sites and applications on the web are rarely composed of resources from only a single origin. For example, authors pull scripts and styles from a wide variety of services and content delivery networks, and must trust that the delivered representation is, in fact, what they expected to load. If an attacker can trick a user into downloading content from a hostile server (via DNS poisoning, or other such means), the author has no recourse. Likewise, an attacker who can replace the file on the Content Delivery Network (CDN) server has the ability to inject arbitrary content.
</p>

<p>
この~riskの一部は、資源を~secure~channel
—
<a href="~RFCx/rfc5246">TLS</a>,
<a href="~RFCx/rfc6797">HSTS</a>,
<a href="~RFCx/rfc7469">pinned public keys</a>
—
越しに送達することで 軽減される。
~UAは、自身が通話相手と信じる~serverが~~本物であることについて，相応の~~確証を得られるので。
しかしながら，これらの仕組みが認証するのは、`内容ではなく^em，`~serverに限られる^em。
~serverへの~accessを有する攻撃者（あるいは管理者）は、咎め無く内容を操作できる。
理想は、作者が~serverの~keyを~pin†できるのみならず，`内容^emについても資源~表現の~~同一性が確保されるよう~pinして，`そのような表現に限って^em読込んで実行できるようにすることである。
◎
Delivering resources over a secure channel mitigates some of this risk: with TLS, HSTS, and pinned public keys, a user agent can be fairly certain that it is indeed speaking with the server it believes it’s talking to. These mechanisms, however, authenticate only the server, not the content. An attacker (or administrator) with access to the server can manipulate content with impunity. Ideally, authors would not only be able to pin the keys of a server, but also pin the content, ensuring that an exact representation of a resource, and only that representation, loads and executes.
</p>

<p class="trans-note">【†
“~keyを~pinする”
— 相手（ ~server ）の身元を随時確認できるよう，その証明情報の “真正な写し” （ ~key ）を手元（ ~UA側）に “ピン留め” しておく。
<small >（したがって、（万全を期すためには）最初に “写し” を得る段階で，その真正性が確保される必要がある。）</small>
】</p>

<p>
この文書は、そのような検証の枠組みを指定する。
また、二つの~HTML要素
— `script$e, `link$e —
を `integrity$a 属性で拡張する。
この属性は、作者が読込むものと期待する資源の表現に対する，暗号用~hashを包含する。
一例として、作者は［
ある~frameworkを，自前の生成元では~hostせずに 共用~serverから読込みたい
］と望んでいるとする。
`https://example.com/example-framework.js^s
に`期待される^em `SHA-384$hS ~hashとして`~digest$
`Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7^s
を指定することは、~UAが、その~URLから読込む~dataが包含している~JSを実行する前に，~dataが期待されている~hashに合致するかどうか検証yできることを意味する。
この完全性~検証yは、攻撃者により資源が悪意的な内容で代用される~riskを，有意に抑制する。
◎
This document specifies such a validation scheme, extending two HTML elements with an integrity attribute that contains a cryptographic hash of the representation of the resource the author expects to load. For instance, an author may wish to load some framework from a shared server rather than hosting it on their own origin. Specifying that the expected SHA-384 hash of https://example.com/example-framework.js is Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7 means that the user agent can verify that the data it loads from that URL matches that expected hash before executing the JavaScript it contains. This integrity verification significantly reduces the risk that an attacker can substitute malicious content.
</p>

<div class="example">

<p>
例えば `script^e 要素に次の様に~hashを追加すれば、~UAへ向けて ~hashを通信できる：
◎
This example can be communicated to a user agent by adding the hash to a script element, like so:
</p>

<pre class="lang-html">
&lt;script src="https://example.com/example-framework.js"
        integrity="sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7"
        crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>
</div>

<p>
無論、~scriptだけが 完全性~検証からの便益を得られる応答~種別ではない。
ここで指定される枠組みは、 `link^e にも適用され、また，この仕様の将来の~versionでは、対象範囲を拡げる見込みが高い。
◎
Scripts, of course, are not the only response type which would benefit from integrity validation. The scheme specified here also applies to link and future versions of this specification are likely to expand this coverage.
</p>

		<section id="goals">
<h3 title="Goals">1.1. 目標</h3>

<ol>
	<li>
第三者主体~serviceが弱体化されても，自動的に その~scriptを含む~siteまで ことごとく弱体化されるべきでない。
内容~作者が、自身が読込む内容に対する期待を指定できる仕組みを与える
— 例えば、当の~URLにたまたま あてがわれた `~~任意の^em ~scriptではなく，`特定の^em ~scriptに限って読込めるような。
◎
Compromise of a third-party service should not automatically mean compromise of every site which includes its scripts. Content authors will have a mechanism by which they can specify expectations for content they load, meaning for example that they could load a specific script, and not any script that happens to have a particular URL.
</li>
	<li>
検証yの仕組みは、受信された応答が妥当でないときは，それを作者に伝えるような、~errorを報告する機能性を備えるべきである。
◎
The verification mechanism should have error-reporting functionality which would inform the author that an invalid response was received.
</li>
</ol>

		</section>
		<section id="use-casesexamples">
<h3 title="Use Cases/Examples">1.2. 利用事例と例</h3>

			<section id="resource-integrity">
<h4 title="Resource Integrity">1.2.1 資源の完全性</h4>

<ul>
	<li>
<p>
作者は、全世界の利用者のために処理能を改善するため，~CDNを利用したいと望んでいるとする。
しかしながら、［
~CDNの~serverが，作者が`期待する~codeのみ^emを送達する
］ことを確保することも重要である。
~CDNが弱体化されて（あるいは期待されない悪意的な挙動により），~siteが不幸な~~形に変えられてしまう~riskを軽減するためには、~pageに含まれる `link$e 要素に，次の`完全性~metadata$を追加する：
◎
An author wishes to use a content delivery network to improve performance for globally-distributed users. It is important, however, to ensure that the CDN’s servers deliver only the code the author expects them to deliver. To mitigate the risk that a CDN compromise (or unexpectedly malicious behavior) would change that site in unfortunate ways, the following integrity metadata is added to the link element included on the page:
</p>

<pre class="lang-html">
&lt;link
    rel="stylesheet"
    href="https://site53.example.net/style.css"
    integrity="sha384-`…( ~digest )…$V"
    crossorigin="anonymous"
&gt;
</pre>

	</li>
	<li>
<p>
作者は、第三者主体が解析~service用に供した~JSを~pageに含めるよう求めているとする。
注意深く考査された~codeのみ 実行されることを確保するためには、~scriptに対する`完全性~metadata$を生成して，それを `script$e 要素に追加する：
◎
An author wants to include JavaScript provided by a third-party analytics service. To ensure that only the code that has been carefully reviewed is executed, the author generates integrity metadata for the script, and adds it to the script element:
</p>

<pre class="lang-html">
&lt;script
    src="https://analytics-r-us.example.com/v1.0/include.js"
    integrity="sha384-`…( ~digest )…$V"
    crossorigin="anonymous"
&gt;&lt;/script&gt;
</pre>
	</li>
	<li>
~UAは、高特権な~HTML文脈（例えば, ~browserの新たな~tab~page）内で走っている~JS~codeが，表示される前に操作されないことを確保したいと望む。
`完全性~metadata$は、改ざんされた~JSが そのような高特権な文脈~下で走る~riskを軽減する。
◎
A user agent wishes to ensure that JavaScript code running in high-privilege HTML contexts (for example, a browser’s New Tab page) aren’t manipulated before display. Integrity metadata mitigates the risk that altered JavaScript will run in these pages’ high-privilege contexts.
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>


<p class="trans-note">【
この節の他の内容は
<a href="w3c-common-ja.html#conformance">W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<!-- 


As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

The key words MAY, MUST, and SHOULD are to be interpreted as described in [RFC2119].

Conformance requirements phrased as algorithms or specific steps can be implemented in any manner, so long as the end result is equivalent. In particular, the algorithms defined in this specification are intended to be easy to understand and are not intended to be performant. Implementers are encouraged to optimize.


-->

		<section id="key-concepts-and-terminology">
<h3 title="Key Concepts and Terminology">2.1. ~~主要な概念と各種用語</h3>

<p>
この節では、文書~全体を通して利用されるいくつかの用語を定義する。
◎
This section defines several terms used throughout the document.
</p>

<p>
用語
`~digest@
は、任意な~data~blockに暗号用~hash関数を適用した結果を~base64に符号化した結果を指す。
◎
The term digest refers to the base64-encoded result of executing a cryptographic hash function on an arbitrary block of data.
</p>

<p>
用語
`生成元@
は、 `RFC6454$r にて定義される。
◎
The term origin is defined in the Origin specification. [RFC6454]
</p>

<p>
資源の［
`表現~data$,
`内容~符号法$（ `Content-Encoding$h ）
］は、
`RFC7231$r
<!-- 
~RFC7231#section-3
 -->
にて定義される。
◎
The representation data and content encoding of a resource are defined by RFC7231, section 3. [RFC7231]
</p>

<p>
`~base64符号化法@
は、
`RFC4648$r <a href="~RFCx/rfc4648#section-4">§ 4</a>
にて定義される。
◎
A base64 encoding is defined in RFC 4648, section 4. [RFC4648]
</p>

<p>
`SHA-256^hS, `SHA-384^hS, `SHA-512^hS
は、暗号用~hash関数
`SHA-2@hS
の一部を成し、
NIST
“<a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">FIPS PUB 180-4: Secure Hash Standard (SHS)</a>”
にて定義される。
◎
The SHA-256, SHA-384, and SHA-512 are part of the SHA-2 set of cryptographic hash functions defined by the NIST in “FIPS PUB 180-4: Secure Hash Standard (SHS)”.
</p>

		</section>
		<section id="grammatical-concepts">
<h3 title="Grammatical Concepts">2.2. 文法~上の概念</h3>

<p class="trans-note">【
この節の内容は、関連な節に直に記すことにする。
】
◎
The Augmented Backus-Naur Form (ABNF) notation used in this document is specified in RFC5234. [ABNF]
◎
Appendix B.1 of [ABNF] defines VCHAR (printing characters).
◎
WSP (white space) characters are defined in Section 2.4.1 Common parser idioms of the HTML 5 specification as White_Space characters.
</p>

		</section>
	</section>
	<section id="framework">
<h2 title="Framework">3. ~framework</h2>

<div class="p">
<p>
ここで指定する 完全性~検証yの仕組みは、次の処理-を煮詰める：
</p>

<ul ><li>資源から ~~十分に強い暗号用~digestを生成する。
</li><li>生成した~digestを，応答を検証yするために利用できるよう，~UAへ伝送する。
</li></ul>
◎
The integrity verification mechanism specified here boils down to the process of generating a sufficiently strong cryptographic digest for a resource, and transmitting that digest to a user agent so that it may be used to verify the response.
</div>

		<section id="integrity-metadata">
<h3 title="Integrity metadata">3.1. 完全性~metadata</h3>

<p>
応答の完全性を検証yするため、~UAは，
<a href="~FETCH#concept-request-integrity-metadata">要請の一部</a>
として，
`完全性~metadata@
を要求する。
この~metadataは、次の情報~片からなる：
◎
To verify the integrity of a response, a user agent requires integrity metadata as part of the request. This metadata consists of the following pieces of information:
</p>

<div>

<ul><li>暗号用~hash関数（ `alg@P ）
</li><li>`~digest$（ `val@P ）
</li><li>各種~option（ `opt@P ）
</li></ul>
◎
cryptographic hash function (“alg”)
digest (“val”)
options (“opt”)
</div>

<p>
これらのうち，~hash関数と~digestは、供されなければナラナイ
— 応答の完全性を検証するためには必須なので。
◎
The hash function and digest MUST be provided in order to validate a response’s integrity.
</p>

<p class="note">注記：
現時点では，定義された~optionはないが、この仕様の将来の~versionにて~optionは定義され得る
— MIME 型 `MIMETYPE$r など。
◎
At the moment, no options are defined. However, future versions of the spec may define options, such as MIME types [MIMETYPE].
</p>


<p>
この~metadataは、~CSP
<a href="~CSP2#source-list-syntax">§ ~source~list構文</a>
の `hash-source$P と同じ形式に符号化されなければナラナイ（ただし、一重引用符は含めない）。
◎
This metadata MUST be encoded in the same format as the hash-source (without the single quotes) in section 4.2 of the Content Security Policy Level 2 specification.
</p>

<div class="example">
<p>
例えば、~script資源の内容が文字列
`alert(\'Hello, world.\');^l
で，作者が~hash関数として `SHA-384$hS を選んだなら、~base64に符号化された結果の~digestは、
`H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO^s
になる。
これは、次のように符号化できる：
◎
For example, given a script resource containing only the string alert(\'Hello, world.\');, an author might choose SHA-384 as a hash function. H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO is the base64-encoded digest that results. This can be encoded as follows:
</p>

<pre class="lang-http">
sha384-H8BRh8j48O9oYatfu5AZzq6A9RINhZO5H16dQZngK7T62em8MUt1FLm52t+eX6xO
</pre>

</div>

<div class="note">
<p>注記：
~digestを生成するために利用できる~utilityは、いくつもある。
例えば
<a href="https://www.openssl.org/">OpenSSL</a>
は、ごく共通に可用である。
この節の例は、次の~command-lineによる結果である：
◎
Digests may be generated using any number of utilities. OpenSSL, for example, is quite commonly available. The example in this section is the result of the following command line:
</p>

<pre class="lang-other">
echo -n "alert('Hello, world.');" | \
   openssl dgst -sha384 -binary | \
   openssl base64 -A
</pre>

</div>


		</section>
		<section id="cryptographic-hash-functions">
<h3 title="Cryptographic hash functions">3.2. 暗号用~hash関数</h3>

<p>
適合t~UAは、要請の`完全性~metadata$の一部として利用する暗号用~hash関数として
`SHA-256$hS, `SHA-384$hS, `SHA-512$hS
を~supportするモノトスル。
また、追加的な~hash関数も~supportしてヨイ。
◎
Conformant user agents MUST support the SHA-256, SHA-384 and SHA-512 cryptographic hash functions for use as part of a request’s integrity metadata and MAY support additional hash functions.
</p>

<div class="p">
<p>
~UAは、自身が~supportする~hashing関数を，次にしたがって制約するベキである（
<a href="#hash-collision-attacks">~hash衝突~攻撃</a>
を見よ）：
</p>

<ul ><li> `MD5^hS や `SHA-1^hS の様な弱いことが既知なものは~supportしない。
</li><li>衝突耐性があることが既知なものに限る。
</li><li>~supportしている~hashing関数を定期的に評価し直して、~secureでなくなったものは非推奨にする。
</li></ul>

◎
User agents SHOULD refuse to support known-weak hashing functions like MD5 or SHA-1 and SHOULD restrict supported hashing functions to those known to be collision-resistant. Additionally, user agents SHOULD re-evaluate their supported hash functions on a regular basis and deprecate support for those functions that have become insecure. See Hash collision attacks.
</div>


			<section id="agility">
<h4 title="Agility">3.2.1. 即応性</h4>

<p>
将来，暗号上の発見に直面したときに 機敏に対応できるよう、同じ資源に，`完全性~metadata$の集合が複数個†結付けられてもよい。
◎
Multiple sets of integrity metadata may be associated with a single resource in order to provide agility in the face of future cryptographic discoveries. For example, the resource described in the previous section may be described by either of the following hash expressions:
</p>

<div class="example">

<p>
作者は、同じ資源に対し，例えば `SHA-384$hS, `SHA-512$hS ~hashの二つを指定してよい：
◎
sha384-dOTZf16X8p34q2/kYyEFm0jh89uTjikhnzjeLeF0FHsEaYKb1A1cv+Lyv4Hk8vHd
◎
sha512-Q2bFTOhEALkN8hOms2FKTDLy7eugP2zFZ1T8LCvX42Fp3WoNr3bjZSAHeOsHrbV1Fu9/A0EzCinRE7Af1ofPrw==
◎
Authors may choose to specify both, for example:
</p>

<pre class="lang-html">
&lt;script src="hello_world.js"
   integrity="sha384-`…( ~digest )…$V
              sha512-`…( ~digest )…$V"
   crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>
</div>


<p class="trans-note">【†
集合が複数個（ `multiple sets of^en 〜 ）
— すなわち、各~hash関数ごとにも，複数の~hash値を与えれる（
<a href="#_multi-hash">後述の例</a>
）。
】</p>

<p>
この事例では、~UAは，応答を検証するときに~list内の最も強い~hash関数を選んで，
その~metadataを利用することになる（後述の
“%~metadata を`構文解析-$する” ／
“%集合 から`最も強い~metadataを取得-$する”
に則って）。
◎
In this case, the user agent will choose the strongest hash function in the list, and use that metadata to validate the response (as described below in the “parse metadata” and “get the strongest metadata from set” algorithms).
</p>

<p>
~secureでないと決定された~hash関数に対しては、~UAは，それを非推奨にした上で、最終的には，~secureでないな~hash関数を利用している完全性~検証の~supportを除去するベキである。
~UAは、応答の妥当性を検査する際に，非推奨にされた関数に基づく~digestを利用してもヨイ。
◎
When a hash function is determined to be insecure, user agents SHOULD deprecate and eventually remove support for integrity validation using the insecure hash function. User agents MAY check the validity of responses using a digest based on a deprecated function.
</p>


<p>
作者が，古い~UAに縛られることなく より強い~hash関数に切替えれるよう、~UAは，自身が~supportしない~hash関数を利用している検証に対しては，その完全性~値は供されなかったかの様に動作することになる（後述の，
<a href="#does-response-match-metadatalist">%応答 は %~metadata~list に合致するか？</a>
を見よ）。
作者には、強い~hash関数を利用することに加え，より強い~hash関数が可用になり次第 それへ移行することが奨励される。
◎
To allow authors to switch to stronger hash functions without being held back by older user agents, validation using unsupported hash functions acts like no integrity value was provided (see the “Does response match metadataList” algorithm below). Authors are encouraged to use strong hash functions, and to begin migrating to stronger hash functions as they become available.
</p>

			</section>
			<section id="priority">
<h4 title="Priority">3.2.2. 優先度</h4>

<p>
~UAは、［
2 個の~hash関数 %A, %B に対し，［
どちらか優先される方, あるいは
優先度が等しい場合は空~文字列
］を返す仕組み
— 以下では
`getPrioritizedHashFunction@( %A, %B )
と記される関数 —
を供するモノトスル。
それは，~UAが最も衝突耐性があると見なす~hash関数を返す。
例えば、
`getPrioritizedHashFunction$(`sha256^l, `sha512^l)
は， `sha512^l を返し、
`getPrioritizedHashFunction$(`sha256^l, `sha256^l)
は，空~文字列を返すことになる。
◎
User agents must provide a mechanism for determining the relative priority of two hash functions and return the empty string if the priority is equal. That is, if a user agent implemented a function like getPrioritizedHashFunction(a, b) it would return the hash function the user agent considers the most collision-resistant. For example, getPrioritizedHashFunction('sha256', 'sha512') would return 'sha512' and getPrioritizedHashFunction('sha256', 'sha256') would return the empty string.
</p>


<p class="note">注記：
`getPrioritizedHashFunction$ は、内部的な実装の詳細であり，実装者が~web~appに供する~APIでない。
それはもっぱら、この文書にて~algoの記述を単純~化するために利用される。
◎
The getPrioritizedHashFunction is an internal implementation detail. It is not an API that implementors provide to web applications. It is used in this document only to simplify the algorithm description.
</p>

<p class="trans-note">【
3 個~以上の~hash関数の優先度が循環する様な結論を導くような `getPrioritizedHashFunction$ が 明示的に禁止されていないが、そのような比較~関数は許容されないかどうかは、この仕様の他所を見ても判らない（この仕様の~algoは、そうであっても問題なく働く／働いてしまう）。
】</p>

			</section>
		</section>
		<section id="response-verification-algorithms">
<h3 title="Response verification algorithms">3.3. 応答を検証yする~algo</h3>

			<section id="apply-algorithm-to-response">
<h4 title="Apply algorithm to response">3.3.1. %応答 に %~algo を適用する</h4>


<div class="p">
<ol>
	<li>
%表現~data ~LET %応答 の`表現~data$
</li>
	<li>
~IF［
~UAは，`内容~符号法$たち（ `Content-Encoding$h ）を適用した上で内容を消費するものと意図する
］
⇒
%表現~data ~SET %表現~data に`内容~符号法$たちを適用した結果
</li>
	<li>
~RET ［
%表現~data に %~algo を`適用-$した結果
］を~base64に符号化した結果
</li>
</ol>

◎
Let result be the result of applying algorithm to the representation data without any content-codings applied, except when the user agent intends to consume the content with content-encodings applied. In the latter case, let result be the result of applying algorithm to the representation data.
◎
Let encodedResult be result of base64-encoding result.
◎
Return encodedResult.
</div>

			</section>
			<section id="is-response-eligible-for-integrity-validation">
<h4 title="Is response eligible for integrity validation">3.3.2. %応答 は完全性~検証に適格か？</h4>


<p>
［
攻撃者が、完全性~検査を介して値を総当たりすることにより，非同一-生成元~dataを読取る能
］を軽減するため、応答は，［
それが同一-生成元である
］か, または［
`CORS$r を介して読込む生成元として，明示的に~accessが是認されている
］場合に限り，そのような検査に適格とされる。
◎
In order to mitigate an attacker’s ability to read data cross-origin by brute-forcing values via integrity checks, responses are only eligible for such checks if they are same-origin or are the result of explicit access granted to the loading origin via Cross Origin Resource Sharing [CORS].
</p>


<p class="note">注記：
`RFC6454$r の
<a href="~RFC6454#section-4">§ 4</a>
に注記されているように、~UAには，`file^sc ~scheme~URLに対し大域一意~識別子を利用するものもある。
そのような~UAにおいては、
`file^sc ~scheme~URL越しに~accessされる資源は、完全性~検査に適格とされないことになる。
◎
As noted in RFC6454, section 4, some user agents use globally unique identifiers for each file URI. This means that resources accessed over a file scheme URL are unlikely to be eligible for integrity checks.
</p>

<p class="note">注記：
`~secureな文脈$下にあること（例：文書は~HTTPS越しに送達された）が、完全性~検証の利用に必要とされるわけではない
— 資源の完全性は、~app~levelのみの~security~toolであり，~UAの~security状態を変更するものではないので。
しかしながら作者は、~secureな文脈でない何か（例： ~HTTP越しに送達された文書）で利用された完全性【~metadata】は，`~security保証を全く供さない^emことを自覚しておくべきである。
この理由から、作者は，~secureな文脈~下に限って完全性~metadataを送達するべきである。
更なる論点は、
<a href="#non-secure-contexts-remain-non-secure">~secureでない文脈は~secureでないであり続ける</a>
を見よ。
◎
Being in a Secure Context (e.g., a document delivered over HTTPS) is not necessary for the use of integrity validation. Because resource integrity is only an application level security tool, and it does not change the security state of the user agent, a Secure Context is unnecessary. However, if integrity is used in something other than a Secure Context (e.g., a document delivered over HTTP), authors should be aware that the integrity provides no security guarantees at all. For this reason, authors should only deliver integrity metadata in a Secure Context. See Non-secure contexts remain non-secure for more discussion.
</p>

<p>
これらの制約の詳細は、次の~algoで与えられる：
◎
The following algorithm details these restrictions:
</p>

<ol>
	<li>
%応答 ~LET %資源 を`~fetch$した結果の応答
◎
Let response be the response that results from fetching the resource.
</li>
	<li>
~IF［
%応答 の`種別$rs ~IN
{ `basic^l, `cors^l, `default^l }
］
⇒
~RET ~T
◎
If the response type is basic, cors or default, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>


<div class="note">

<p>注記：
応答の`種別$rsは， `FETCH$r にて定義され、うち，上に挙げたものは次を表す：
◎
The response types are defined by the Fetch specification [FETCH] and refer to the following:
</p>

<ul>
	<li>
`basic^l は、応答が
【それを要請した資源と】
同一-生成元であることを表す。
◎
basic is a same-origin response, and thus the requestor has full access to read the body.
</li>
	<li>
`cors^l は、~CORSが可能化された非同一-生成元への要請に対する妥当な応答であることを表す。
◎
cors is a valid response to a cross-origin, CORS-enabled request, and thus again the requestor has full access to read the body.
</li>
	<li>
`default^l は、 Service Worker により，要請に対する応答として生成された妥当な応答であることを表す。
◎
default is a valid response that is generated by a Service Worker as a response to the request, so its body, too, is fully readable by the requestor.
</li>
</ul>

<p>
これらのいずれもに対しても、要請者は，応答の`本体$rsを全部的に読取れることになる。
◎
↑</p>

</div>

			</section>
			<section id="parse-metadata">
<h4 title="Parse metadata.">3.3.3. %~metadata を構文解析する</h4>

<p>
この~algoは、所与の文字列に対し，
`~metadataなし^i または［
~UAにより解される~hash関数からなる，妥当な~hash式の集合
］を返す：
◎
This algorithm accepts a string, and returns either no metadata, or a set of valid hash expressions whose hash functions are understood by the user agent.
</p>

<p class="trans-note">【
空~集合を返す場合もある（含まれている~metadataすべてが妥当でない場合に生じる）。
`~metadataなし^i との違いは、［
<a href="#does-response-match-metadatalist">%応答 は %~metadata~list に合致するか？</a>
］の挙動に現れる。
】</p>

<ol>
	<li>
%結果 ~LET 空~集合
◎
Let result be the empty set.
◎
Let empty be equal to true.
</li>
	<li>
%~token~list ~LET `~ASCII空白で分割する$( %~metadata )
◎
↓</li>
	<li>
~IF［
%~token~list は空~listである
］
⇒
~RET `~metadataなし^i
◎
↓↓</li>
	<li>
<p>
%~token~list 内の~EACH ( %~token ) に対し：
◎
For each token returned by splitting metadata on spaces:
</p>
		<ol>
			<li>
~IF［
%~token は妥当な~metadataでない
］
⇒
~CONTINUE
◎
Set empty to false.
◎
If token is not a valid metadata, skip the remaining steps, and proceed to the next token.
</li>
			<li>
%解析済み~token ~SET `完全性~metadata$の文法に基づいて %~token を構文解析した結果
◎
Parse token per the grammar in integrity metadata.
</li>
			<li>
%~algo ~LET %解析済み~token の `alg$P 成分
◎
Let algorithm be the alg component of token.
</li>
			<li>
~IF［
%~algo は ~UAが認識する~hash関数である
］
⇒
%結果 に %解析済み~token を追加する
◎
If algorithm is a hash function recognized by the user agent, add the parsed token to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return no metadata if empty is true, otherwise return result.
</li>
</ol>

			</section>
			<section id="get-the-strongest-metadata-from-set">
<h4 title="Get the strongest metadata from set.">3.3.4. %集合 から最も強い~metadataを取得する</h4>

<ol>
	<li>
%結果 ~LET 空~集合
◎
↓</li>
	<li>
%最強~algo ~LET ~NULL
◎
Let result be the empty set and strongest be the empty string.
</li>
	<li>
<p>
%集合 内の~EACH ( %~item ) に対し：
</p>
		<ol>
			<li>
%新~algo ~LET %~item の `alg$P 成分
</li>
			<li>
%~algo ~SET ［
%最強~algo ~EQ ~NULL ならば %新~algo ／
~ELSE_ `getPrioritizedHashFunction$( %最強~algo, %新~algo ) の結果
］
</li>
			<li>
<p>
%~algo に応じて：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dd>
%~item を %結果 に追加する
</dd>

	<dt>%新~algo</dt>
	<dd>
<ol ><li>%結果 ~SET 空~集合
</li><li>%~item を %結果 に追加する
</li><li>%最強~algo ~SET %新~algo
</li></ol>
	</dd>

	<dt>%最強~algo</dt>
	<dd>
何もしない
</dd>
</dl>
			</li>
		</ol>

◎
For each item in set:
◎
If result is the empty set, add item to result and set strongest to item, skip to the next item.
◎
Let currentAlgorithm be the alg component of strongest.
◎
Let newAlgorithm be the alg component of item.
◎
If the result of getPrioritizedHashFunction(currentAlgorithm, newAlgorithm) is the empty string, add item to result. If the result is newAlgorithm, set strongest to item, set result to the empty set, and add item to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>



			</section>
			<section id="does-response-match-metadatalist">
<h4 title="Does response match metadataList?">3.3.5. %応答 は %~metadata~list に合致するか？</h4>


<ol>
	<li>
%解析済み~metadata ~LET
%~metadata~list を`構文解析-$した結果
◎
Let parsedMetadata be the result of parsing metadataList.
</li>
	<li>
~IF［
%解析済み~metadata ~EQ `~metadataなし^i
］
⇒
~RET ~T
◎
If parsedMetadata is no metadata, return true.
</li>
	<li>
~IF［
%応答 は`完全性~検証に適格$でない
］
⇒
~RET ~F
◎
If response is not eligible for integrity validation, return false.
</li>
	<li>
~IF［
%解析済み~metadata は空~集合である
］
⇒
~RET ~T
◎
If parsedMetadata is the empty set, return true.
</li>
	<li>
%~metadata ~LET
%解析済み~metadata から`最も強い~metadataを取得-$した結果
◎
Let metadata be the result of getting the strongest metadata from parsedMetadata.
</li>
	<li>
<p>
%~metadata 内の~EACH ( %~item ) に対し：
◎
For each item in metadata:
</p>
		<ol>
			<li>
%~algo ~LET %~item の `alg$P 成分
◎
Let algorithm be the alg component of item.
</li>
			<li>
`期待される値^V ~LET %~item の `val$P 成分
◎
Let expectedValue be the val component of item.
</li>
			<li>
%実~値 ~LET %応答 に %~algo を`適用-$した結果
◎
Let actualValue be the result of applying algorithm to response.
</li>
			<li>
~IF［
%実~値 ~EQ `期待される値^V
］
⇒
~RET ~T
◎
If actualValue is a case-sensitive match for expectedValue, return true.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

<p id="_multi-hash">
この~algoは、~UAが，複数の 妥当かつ強い~hash関数を受容できるようにする。
◎
This algorithm allows the user agent to accept multiple, valid strong hash functions.＼
</p>

<div class="example">
<p>
例えば，開発者は、 `script$e 要素を次のようにも記せる：
◎
For example, a developer might write a script element such as:
</p>

<pre class="lang-html">
&lt;script src="https://example.com/example-framework.js"
        integrity="sha384-`…( ~digest )…$V
                   sha384-`…( ~digest )…$V"
        crossorigin="anonymous"&gt;&lt;/script&gt;
</pre>
</div>

<p>
~UAに，二つの異なる内容~payload
— 最初の, および二番目の `SHA-384$hS ~hash値に合致するもの —
を受容させられるようになる。
◎
which would allow the user agent to accept two different content payloads, one of which matches the first SHA384 hash value and the other matches the second SHA384 hash value.
</p>

<p class="note">注記：
~UAは、利用者に，この~algoの結果を改変することを許容してよい
— ［
利用者~選好,
~bookmarklet,
第三者主体による~UAに対する追加,
その他の同類の仕組み
］を介して。
例えば、
<a href="https://www.eff.org/https-everywhere">HTTPS Everywhere</a>
の様な拡張により生成される~redirectは、資源の［
~HTTPS, ~HTTP
］~versionが相違する場合でも，正しく読込んで実行する。
◎
User agents may allow users to modify the result of this algorithm via user preferences, bookmarklets, third-party additions to the user agent, and other such mechanisms. For example, redirects generated by an extension like HTTPS Everywhere could load and execute correctly, even if the HTTPS version of a resource differs from the HTTP version.
</p>

<p class="note">注記：
この~algoは、応答が`完全性~検証に適格$でない場合には ~F を返す
— 下位資源の完全性には，~CORSが要求され、~CORSを伴わずにそれを利用しようとする試みるのは，論理的に~errorなので。
加えて，~UAは、開発者~consoleに向けて，この失敗を説明する警告~messageを報告するベキである。
◎
This algorithm returns false if the response is not eligible for integrity validation since Subresource Integrity requires CORS, and it is a logical error to attempt to use it without CORS. Additionally, user agents SHOULD report a warning message to the developer console to explain this failure.
</p>


			</section>
		</section>
		<section id="verification-of-html-document-subresources">
<h3 title="Verification of HTML document subresources">3.4. ~HTML文書の下位資源に対する検証y</h3>

<p>
種々の~HTML要素が，［［
文書の中へ埋込まれるか, 文書の文脈~下で実行される
］ことになるような資源
］を要請する。
その種の要素に対し，完全性~metadataを~supportする一環として、
`link$e ／ `script$e
要素には，新たな内容~属性 `integrity$a が追加される。
◎
A variety of HTML elements result in requests for resources that are to be embedded into the document, or executed in its context. To support integrity metadata for some of these elements, a new integrity attribute is added to the list of content attributes for the link and script elements.
</p>


<p>
各~要素の `integrity$a 内容~属性を`反映する$，対応する `integrity$m ~IDL属性が［
`HTMLLinkElement^I ／ `HTMLScriptElement^I
］~interfaceに追加される。
◎
A corresponding integrity IDL attribute which reflects the value each element’s integrity content attribute is added to the HTMLLinkElement and HTMLScriptElement interfaces.
</p>

<p class="note">注記：
この仕様の将来の改訂版は、アリなすべての下位資源
— すなわち，次に挙げる要素 —
に対しても，完全性の~supportを含める見込みが高い
⇒
`a^e, `audio^e, `embed^e, `iframe^e, `img^e, `link^e, `object^e, `script^e,
`source^e, `track^e, `video^e
◎
A future revision of this specification is likely to include integrity support for all possible subresources, i.e., a, audio, embed, iframe, img, link, object, script, source, track, and video elements.
</p>


			<section id="the-integrity-attribute">
<h3 title="The integrity attribute">3.5. `integrity^a 属性</h3>

<p>
`integrity^a 属性は、要素に対する`完全性~metadata$を表現する。
この属性の値は、空~文字列か, または
少なくとも 1 個以上の，次の ABNF （ Augmented Backus-Naur Form, `ABNF$r ） 文法に則って妥当な~metadataを含んでなければナラナイ
◎
The integrity attribute represents integrity metadata for an element. The value of the attribute MUST be either the empty string, or at least one valid metadata as described by the following ABNF grammar:
</p>

<!-- 
この文書が利用する ABNF（ Augmented Backus-Naur Form ）記法は，
RFC5234 `ABNF$r にて指定される。
 -->

<pre class="bnf">
`integrity-metadata@P
    = *`WSP^P `hash-with-options$P *( 1*`WSP^P `hash-with-options$P ) *`WSP^P
    / *`WSP^P
`hash-with-options@P  = `hash-expression$P *("?" `option-expression$P)
`option-expression@P  = *`VCHAR^P
`hash-expression@P    = `hash-algo$P "-" `base64-value$P
</pre>


<div class="p">

<p>
`integrity$m ~IDL属性は、 `integrity$a 内容~属性を`反映する$モノトスル。
</p>

<p>
上の ABNF において：
</p>

<ul>
	<li>
`hash-algo$P, `base64-value$P
は、~CSP Level 2 の
<a href="~CSP2#source-list-syntax">§ ~source~list構文</a>
の同名の生成規則で与えられる。
</li>
	<li>
`WSP^P は、 HTML 仕様に定義される`~ASCII空白$を表す。
<!-- ＊
原文は White_Space characters とも記されているが，おそらく誤り。
-->
</li>
	<li>
`VCHAR^P
（印字可能~文字）は、
`ABNF$r <a href="~RFCx/rfc5234#appendix-B.1">Appendix B.1</a> にて定義される。
</li>
</ul>

◎
hash-algo          = &lt;hash-algo production from [Content Security Policy Level 2, section 4.2]&gt;
◎
base64-value       = &lt;base64-value production from [Content Security Policy Level 2, section 4.2]&gt;
◎
The integrity IDL attribute must reflect the integrity content attribute.
</div>


<p>
`option-expression$P は、各 `hash-expression$P ごとに結付けられ，直前の `hash-expression$P のみに適用される。
◎
option-expressions are associated on a per hash-expression basis and are applied only to the hash-expression that immediately precedes it.
</p>


<p>
~UAは、将来の~optionと全部的に前方-互換であり続けるようにするため，自身が認識しない `option-expression$P を無視するモノトスル。
◎
In order for user agents to remain fully forwards compatible with future options, the user agent MUST ignore all unrecognized option-expressions.
</p>

<p class="note">注記：
構文~内では `option-expression$P が予約されているが、定義された~optionはまだないことに注意。
この仕様の将来の~versionでは，~optionに対しより特定な構文を定義することになる見込みが高いので、アリな限り広く定義されている。
◎
Note that while the option-expression has been reserved in the syntax, no options have been defined. It is likely that a future version of the spec will define a more specific syntax for options, so it is defined here as broadly as possible.
</p>


			</section>
			<section id="element-interface-extensions">
<h3 title="Element interface extensions">3.6. 要素~interfaceに対する拡張</h3>

<pre class="idl">
partial interface `HTMLLinkElement$I {
                    attribute DOMString integrity;
};

partial interface `HTMLScriptElement$I {
                    attribute DOMString integrity;
};
</pre>

<p>
これらの~interfaceの `integrity^m 属性は、いずれも，当の要素の `integrity$a 属性を`反映する$。
◎
3.6.1 HTMLLinkElement

partial interface HTMLLinkElement {
    attribute DOMString integrity;
};

3.6.1.1 Attributes

integrity of type DOMString
    integrity

3.6.2 HTMLScriptElement

partial interface HTMLScriptElement {
    attribute DOMString integrity;
};

3.6.2.1 Attributes

integrity of type DOMString
    integrity
</p>


				</section>
			</section>
			<section id="handling-integrity-violations">
<h3 title="Handling integrity violations">3.7. 完全性~違反の取扱い</h3>

<p>
~UAは、完全性~検査に失敗した応答を［
具現化する／実行する
］のを拒否して，代わりに
`FETCH$r にて定義される~network~errorを返すことになる。
◎
The user agent will refuse to render or execute responses that fail an integrity check, instead returning a network error as defined in Fetch [FETCH].
</p>

<p class="note">注記：
完全性~検査の失敗-時には、 `error^et ~eventが発火される。
開発者は、正準的~fallback資源（例： ~CDNから~serveされていない, 二次的な，信用されてはいるが より低速な~sourceからの資源など）を供したいと望むなら、［
この `error^et ~eventをとらえて，失敗した当の資源を異なるものに置換する
］ような適切な~handlerを供せる。
◎
On a failed integrity check, an error event is fired. Developers wishing to provide a canonical fallback resource (e.g., a resource not served from a CDN, perhaps from a secondary, trusted, but slower source) can catch this error event and provide an appropriate handler to replace the failed resource with a different one.
</p>



			<section id="elements">
<h3 title="Elements">3.8. 要素</h3>

				<section id="the-link-element-for-stylesheets">
<h4 title="The link element for stylesheets">3.8.1. ~stylesheetを指す `link^e 要素</h4>

<div class="p">
<p>
~UAは、 `link$e 要素 %要素 が［
~keyword `stylesheet^v を値に含む `rel^a 属性
］を有している下で， %要素 が指している`資源を得しようと試みる$ときは、［
%要請 を用いて`~fetch$する段の前
］に，次の段を行う：
</p>

<ol>
	<li>
%要請 の`完全性~metadata$ ~SET %要素 の `integrity$a 属性~値
</li>
</ol>

<p class="trans-note">【
この段は、現在の~HTML仕様（ WHATWG ）には，すでに統合されている。
】</p>
◎
Whenever a user agent attempts to obtain a resource pointed to by a link element that has a rel attribute with the keyword of stylesheet, modify step 4 to read:
◎
Do a potentially CORS-enabled fetch of the resulting absolute URL, with the mode being the current state of the element’s crossorigin content attribute, the origin being the origin of the link element’s Document, the default origin behavior set to taint, and the integrity metadata of the request set to the value of the element’s integrity attribute.
</div>


				</section>
				<section id="the-script-element">
<h4 title="The script element">3.8.2. `script^e 要素</h4>

<p>
HTML5 の
<a href="http://www.w3.org/TR/html5/scripting-1.html#prepare-a-script">~scriptを準備する~algo</a>
の段 14.1 を次の段に置換する：
◎
Replace step 14.1 of HTML5’s “prepare a script” algorithm with:
</p>

<ol>
	<li>
%src ~LET %要素 の `src^a 属性~値；<br>
%要請 の`完全性~metadata$ ~LET %要素 の `integrity$a 属性~値
◎
Let src be the value of the element’s src attribute and the request’s associated integrity metadata be the value of the element’s integrity attribute.
</li>
</ol>

<p class="trans-note">【
この段は、現在の~HTML仕様（ WHATWG ）の
<a href="~HEscripting#prepare-a-script">~scriptを準備する~algo</a>
には，すでに統合されている。
`script^e 要素の
<a href="~HEscripting#attr-script-integrity">`integrity^a 属性</a>,
<a href="~WAPI#fetching-scripts">~scriptの~fetch法</a>
も見よ。
】</p>


				</section>
			</section>
		</section>
	</section>
	<section id="proxies">
<h2 title="Proxies">4. ~proxy</h2>

<div class="p">
<p>
応答を改変するような~proxyその他の中継~serverを最適化するときは、当の応答に結付けられた~digestが新たな内容にも同期cし続けることを確保しなければナラナイ。
選択肢としては、次が挙げられる：
</p>

<ul ><li>資源に結付けられている`完全性~metadata$が更新されることを確保する。
</li><li>単純に，~page作者が完全性~検証yを要請した際には，当の資源の正準的~versionのみを送達する。
</li></ul>
◎
Optimizing proxies and other intermediate servers which modify the responses MUST ensure that the digest associated with those responses stays in sync with the new content. One option is to ensure that the integrity metadata associated with resources is updated. Another would be simply to deliver only the canonical version of resources for which a page author has requested integrity verification.
</div>


<p>
中継~serverに伝わり易くするため、資源を~serveしている~serverは，自身が送信する資源に，値 `no-transform$dir を伴う `Cache-Control$h ~headerを伴わせるベキである。
◎
To help inform intermediate servers, those serving the resources SHOULD send along with the resource a Cache-Control header with a value of no-transform.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">5. ~security上の考慮点</h2>

~INFORMATIVE

		<section id="non-secure-contexts-remain-non-secure">
<h3 title="Non-secure contexts remain non-secure">5.1 ~secureでない文脈は~secureでないであり続ける</h3>

<p>
［［
~HTTP~pageなどの`~secureな文脈$でない文脈
］により送達される`完全性~metadata$
］が保護する生成元は，［
外部~資源を~hostしている~serverの弱体化に抗する
］ことのみである。
~network攻撃者は、~hashの検証-対象である応答を，その経路上で改ざんできるのと同じく，~~元の~digestも改ざんできる（あるいは，それを除去するなど，文書に対し何でもできる）。
したがって，作者は、完全性~metadataを`~secureな文脈$下でのみ送達するベキである。
<a href="http://www.w3.org/2001/tag/doc/web-https">~webの~secure化法</a>
も見よ。
◎
Integrity metadata delivered by a context that is not a Secure Context, such as an HTTP page, only protects an origin against a compromise of the server where an external resources is hosted. Network attackers can alter the digest in-flight (or remove it entirely, or do absolutely anything else to the document), just as they could alter the response the hash is meant to validate. Thus, it is recommended that authors deliver integrity metadata only to a Secure Context. See also securing the web.
</p>


		</section>
		<section id="hash-collision-attacks">
<h3 title="Hash collision attacks">5.2 ~hash衝突~攻撃</h3>

<p>
~digestの強さは、それを生成する~hash関数に基づく。
~UAには、［
弱いことが既知である~hashing関数に対する~supportは拒否すること
］, および［
~supportする~algoを，衝突耐性があることが既知であるものに制限すること
］が推奨される。
推奨されない~hashing関数の例としては、 `MD5^hS や `SHA-1^hS が挙げられる。
これを書いている時点では、`SHA-384$hS は 良好な~~基準である。
◎
Digests are only as strong as the hash function used to generate them. It is recommended that user agents refuse to support known-weak hashing functions and limit supported algorithms to those known to be collision resistant. Examples of hashing functions that are not recommended include MD5 and SHA-1. At the time of writing, SHA-384 is a good baseline.
</p>

<p>
更には、~UAには，［
定期的に，自身が~supportしている~hash関数を評価し直すこと
］, および［
~secureでないと~~判明した関数に対しては，~supportを非推奨にすること
］が推奨される。
~hash関数は，時を経て［
期待されるより ずっと弱い, あるいは 一部の事例では壊れている
］ものと~~判明することがあるので、~UAは，開発にあたって そのことを自覚し続けることが重要である。
◎
Moreover, it is recommended that user agents re-evaluate their supported hash functions on a regular basis and deprecate support for those functions shown to be insecure. Over time, hash functions may be shown to be much weaker than expected and, in some cases, broken, so it is important that user agents stay aware of these developments.
</p>


		</section>
		<section id="cross-origin-data-leakage">
<h3 title="Cross-origin data leakage">5.3 非同一-生成元~data漏洩e</h3>

<p>
この仕様は、［
完全性の保護-対象である非同一-生成元~要請
］に`~CORS設定群~属性$が在ることを要求する。
この要件が無ければ、攻撃者は
<a href="http://www.w3.org/Security/wiki/Same_Origin_Policy">同一-生成元~施策</a>
に違反することもでき、非同一-生成元~資源が，ある種の内容を持つかどうか決定できてしまう：
◎
This specification requires the CORS settings attribute to be present on integrity-protected cross-origin requests. If that requirement were omitted, attackers could violate the same-origin policy and determine whether a cross-origin resource has certain content.
</p>

<ul>
	<li>
攻撃者は、既知な~digestで資源の読込nを試みながら，その失敗を注視する。
読込nに失敗したなら、応答はその~hashに合致しないものと推定でき、それにより その内容についての洞察を得られる。
これは例えば、利用者が特定0の~serviceに~log-inしたかどうかを露呈するかもしれない。
◎
Attackers would attempt to load the resource with a known digest, and watch for load failures. If the load fails, the attacker could surmise that the response didn’t match the hash and thereby gain some insight into its contents. This might reveal, for example, whether or not a user is logged into a particular service.
</li>
	<li>
<p>
更には，攻撃者は、静的な資源~内の特定の値を総当たりできる。
◎
Moreover, attackers could brute-force specific values in an otherwise static resource.＼
</p>

<div class="example">

<p>
次の様な~JSON応答を考える：
◎
Consider a JSON response that looks like this:
</p>

<pre class="lang-json">
{'status': 'authenticated', 'username': 'admin'}
</pre>

<p>
攻撃者は、様々な共通的な~usernameから，応答に対する~hashを予め算出しておいて、
それらの~hashを順々に指定しながら繰返し文書の読込nを試みれる。
読込nに成功したなら、~usernameを正しく推測できたことが確認されたことになる。
◎
An attacker could precompute hashes for the response with a variety of common usernames, and specify those hashes while repeatedly attempting to load the document. A successful load would confirm that the attacker has correctly guessed the username.
</p>
</div>

	</li>
</ul>


		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕様のかなりの部分は、
Gervase Markham 氏による
<a href="http://www.gerv.net/security/link-fingerprints/">Link Fingerprints</a>
の概念, および WHATWG による
<a href="https://wiki.whatwg.org/wiki/Link_Hashes">Link Hashes</a>
から着想を得ている。
◎
Much of the content here is inspired heavily by Gervase Markham’s Link Fingerprints concept, as well as WHATWG’s Link Hashes.
</p>

<p>
この仕様の初期~versionに貴重な貢献された Google 社の Mike West 氏に特別な謝意を。
加えて，貴重な~feedbackを寄せられた次の方々にも：
◎
A special thanks to Mike West of Google, Inc. for his invaluable contributions to the initial version of this spec.
</p>

<div lang="en-x-a0">
Additionally, Brad Hill, Anne van Kesteren, Jonathan Kingston, Mark Nottingham, Dan Veditz, Eduardo Vela, Tanvi Vyas, and Michal Zalewski provided invaluable feedback.
</div>

	</section>
</main></div>
