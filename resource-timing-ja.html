<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing Level 2 — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style type="text/css">
.event-type,
.handler {
	color: purple;
}

.status {
	color: green;
}


#_time-table {
	background: #eef1fc;
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: solid gray 1px;
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 1em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2019-01-10
trans_update:2019-01-17
source_checked: 170318
page_state_key:TIMING
original_url:https://w3c.github.io/resource-timing/
spec_status:ED
ref_id_prefix:bib-
copyright:2019,permissive
trans_1st_pub:2013-01-23


●●class_map
h:header
e:element
a:attr
st:status
et:event-type
P:production
v:value
css:css

●●tag_map
I:code
m:code
c:code
h:code
e:code
a:code
et:code
st:code
P:code
css:code
v:code
i:i

●●original_id_map

dom-performanceresourcetiming-requestend:dfn-requestend

●●link_map



	●IDL
Exposed:~WEBIDL#Exposed
Default:~WEBIDL#Default

DOMString:~WEBIDL#idl-DOMString
object:~WEBIDL#idl-object
	unsigned long long:~WEBIDL#idl-unsigned-long-long
	unsigned long:~WEBIDL#idl-unsigned-long


I.PerformanceResourceTiming:#dom-performanceresourcetiming
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~TR/hr-time-2/#domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:~TIMELINE#the-performanceentry-interface
I.PerformanceObserver:~TIMELINE#the-performanceobserver-interface

I.EventHandler:~WAPI#eventhandler
	I.Document

m.toJSON:#dom-performanceresourcetiming-tojson
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.workerStart:#dom-performanceresourcetiming-workerstart
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.connectEnd:#dom-performanceresourcetiming-connectend
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.requestEnd:#dom-performanceresourcetiming-requestend
m.responseStart:#dom-performanceresourcetiming-responsestart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.transferSize:#dom-performanceresourcetiming-transfersize
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize

m.clearResourceTimings:#dom-performance-clearresourcetimings
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull

m.name:#dfn-name
m.entryType:#dfn-entrytype
m.startTime:#dfn-starttime
m.duration:#dfn-duration


	https://www.w3.org/TR/beacon/
m.sendBeacon:~BEACON#sec-sendBeacon-method
m.fetch:~FETCH#fetch-method

l.css:#dfn-css
l.navigation:#dfn-navigation
l.xmlhttprequest:#dfn-xmlhttprequest
l.fetch:#dfn-fetch
l.beacon:#dfn-beacon
l.other:#dfn-other

	●e
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.link:~HEmetadata#the-link-element
e.script:~HEscripting#the-script-element
e.object:~HEembed#the-object-element
e.svg:~SVG11/struct.html#SVGElement

et.resourcetimingbufferfull:#dfn-resourcetimingbufferfull

h.Timing-Allow-Origin:#dfn-timing-allow-origin
	h.Origin:~IETF/rfc6454#section-4

css.url():~CSSSYN#consume-a-url-token

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax

応答~code:~RFC7231#section-6
st.1xx:~RFC7231#section-6.2
st.3XX:~RFC7231#section-6.4
	#rfc.section.6.4
st.204:~RFC7231#section-6.3.5
	HTTP 204 (No Content):#status.204

処理~model:#processing-model

i.~obj作成:#dfn-step-create-object
i.~fetch開始:#dfn-step-fetch-start
i.収集~開始:#dfn-step-collection-start
i.接続-開始:#dfn-step-connect-start
i.要請~開始:#dfn-step-request-start
i.応答~開始:#dfn-step-response-start
i.応答~終了0:#dfn-step-response-end
i.最終~記録-:#dfn-step-final-record
	-:#dfn-step-final-queue

	●
~redirect等:#_redirect-or-equivalents
局所~cache等:#_cache-or-local
満杯:#_full

資源:#dfn-resource
非同一-生成元:#dfn-cross-origin
現-文書:#dfn-current-document
現-時刻:#dfn-current-time

計時~許可検査:#dfn-timing-allow-check

資源~計時~buffer~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~buffer現size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~event処理待ち~flag:#dfn-resource-timing-buffer-full-event-pending-flag
資源~計時~副buffer:#dfn-resource-timing-secondary-buffer
資源~計時~副buffer現size:#dfn-resource-timing-secondary-buffer-current-size

処理能~entry~bufferに~entryを追加する:#dfn-add-a-performanceresourcetiming-entry
資源~計時~entryを追加でき:#dfn-can-add-resource-timing-entry
~buffer満杯~eventを発火する:#dfn-fire-a-buffer-full-event
副buffer内の~entryを移動する:#dfn-copy-secondary-buffer

時刻起点:~HRTIME#dfn-time-origin


処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
処理能時列線:~TIMELINE#performance-timeline
	#sec-performance-timeline
	Performance:~TR/navigation-timing-2/#performance
処理能~entryを~queueする:~TIMELINE#dfn-queue-a-performanceentry
処理能~entry種別を登録する:~TIMELINE#dfn-register-a-performance-entry-type

要請:~FETCH#concept-request
rq.行先:~FETCH#concept-request-destination
rq.~client:~FETCH#concept-request-client

~HTTP~network~fetch:~FETCH#http-network-fetch
~HTTP~network-or-cache~fetch:~FETCH#http-network-or-cache-fetch
~fetch:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~navi要請:~FETCH#navigation-request

~HTTP~cache:~RFC7234#section-1
HTTP/2:~IETF/rfc7540
	~IETF/draft-ietf-httpbis-http2-16
	ALPN〜:https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids

~ES大域~環境:~WEBIDL#es-environment
既定の~toJSON演算:~WEBIDL#default-tojson-operation


閲覧文脈:~BROWSERS#browsing-context
	~HTML50/browsers.html#browsing-context
結付けられている文書:~WINDOW#concept-document-window
	~WINDOW#dom-document-2
大域~obj:~WAPI#concept-settings-object-global
関連する~app~cache:~HTMLLS/offline.html#relevant-application-cache
	~HTML50/...

解決-済み~URL:~HTMLurl#resulting-url-string
	~HTMLurl#parse-a-url
	＊#resolve-a-url
	~URL1#

v.stylesheet:~HTMLlinks#link-type-stylesheet

	data: URI:~IETF/rfc2397
生成元:~ORIGIN#concept-origin
	~IETF/rfc6454#section-4
同一-生成元:~ORIGIN#same-origin
	~IETF/rfc6454#section-5

内容~符号法たち:~RFC7231#section-3.1.2.1
	http://httpwg.github.io/specs/rfc7231.html#content.codings

転送~符号法:~RFC7230#section-4
持続的~接続:~RFC7230#section-6.3
非同期に~close:~RFC7230#section-6.5
~message本体:~RFC7230#section-3.3
~payload本体:~RFC7230#section-3.3
~chunked符号法:~RFC7230#section-4.1

要素:~DOM4#concept-element
局所~名:~DOM4#concept-element-local-name
	m.localName:~DOM4#concept-element-local-name
~eventを発火する:~DOM4#concept-event-fire

~taskを~queueする:~WAPI#queue-a-task

走らす:~SW#run-service-worker
	＊~SW#service-worker-concept
作動中の~worker:~SW#dfn-active-worker
合致する作動中の~worker:~SW#dfn-containing-service-worker-registration
~service~worker登録:~SW#dfn-service-worker-registration
名前~fetch_evの~eventを発火する:~SW#on-fetch-request-algorithm

~TR/html5/infrastructure.html#http-response-codes
	＊:~TR/html5/infrastructure.html#or-equivalent
	:~RFC7230#section-7

	-:#dom-PerformanceNavigationTiming-startTime
	-:https://www.w3.org/TR/navigation-timing-2/#dom-PerformanceNavigationTiming-startTime
	-:conforming IDL fragments:https://www.w3.org/TR/2016/REC-WebIDL-1-20161215/#dfn-conforming-set-of-idl-fragments

	-:#dfn-dom
	-:#dfn-getting
	-:#dfn-setting
	-:#dfn-javascript
	-:#dom

●●words_table1

SW:https://www.w3.org/TR/service-workers-1/
BEACON:beacon-ja.html
NAV-TIMING:navigation-timing-ja.html

fetch_ev: <code class="event-type">fetch</code>


●●words_table

	●fetch／HTTP
HTTP:
web:::ウェブ
site:::サイト
page:::ページ
	~app~cache:application cache
navi:navigation::ナビ
navigate:::ナビゲート
download:::ダウンロード
payload:::ペイロード
事前読込み:preload::事前読み込み:事前ロード
読込み:load::読み込み:ロード
読込む:load する::読み込む:ロードする
host:::ホスト
link:::リンク
service:::サービス
URL:
open:
	~openし直:reopen
close:
fetch:
fetching:::fetch 処理
client:::クライアント
server:::サーバ
scheme:::スキーム
資源:resource::~:リソース
下位資源:subresources::下位リソース
redirect:::リダイレクト
transport:::トランスポート
domain:::ドメイン
検索:lookup::~
proxy:::プロキシ
tunnel:::トンネル
handshake:::ハンドシェイク
chunked::チャンク化
端点間:end-to-end::~:エンドツーエンド
符号法:coding::~:コーディング
network:::ネットワーク
network-or-cache:::ネットワーク-or-キャッシュ
error:::エラー
protocol:::プロトコル
header:::ヘッダ
field:::フィールド
message:::メッセージ
本体:body::~:ボディ
stylesheet:::スタイルシート
status:::ステータス

要請:request::~:リクエスト
応答:response::~:レスポンス
連鎖:chain::~
収集-:collect::~
収集:collection::~
受信-:receive::~
受信:receiving::~
受信者:recipient::~
送信-:send::~
	送信し直:resend
送信者:sender::~
送信:sending::~
持続的:persistent::~
接続:connection::~:コネクション
接続-:connect::~:コネクト
確立-:establish:~
確立ng:establishing:確立
確立:establishment:~
事由:reason::~
生成-:generate::~
生成元:origin::~:オリジン
同一-:same-::~
非同一-:cross-::~:クロス
検索取得:retrieval::~
検索取得-:retrieve::~
折衝-:negotiate::~:ネゴシエート
折衝:negotiation::~:ネゴシエーション
低層の:lower-layer::~
層:layer::~
起動-:initiate::~
起動元:initiator::~
転送:transfer::~
事前条件:precondition::~
出自に:originate:~
再検証-:revalidate::~
再検証:revalidation::~
結合-:combine::~
	予行:preflight::~
行先:destination::~

	●計時
処理能時列線:Performance Timeline::~:パフォーマンスタイムライン
処理能:performance::~:パフォーマンス
時列線:timeline::~:タイムライン
	時系列順:
	milliseconds:::ミリ秒~数
clock:::クロック
skew:::スキュー
buffer:::バッファ
副buffer:secondary buffer:副 buffer:副バッファ
entry:::エントリ
時刻:time::~
時間:time::~
計時:timing::~:タイミング
時機:timing::~:タイミング
時刻印:timestamp::~:タイムスタンプ
時刻起点:time origin::~
時区間:interval::~
所要時間:time interval::~
経過時間:time elapsed::~
	経過:since
	属性:timing attribute:~
	情報:timing information:~
	測定:timing measurement:~
開始:start:~
終了0:end:終了
完遂-:finish:~
遅延:latency::~

計測:measurement:~
計測-:measure:~
測定:measurement:~
測定-:measure:~

満杯:full::~:フル
格納-:store:~
格納:store:~
検査:check:~
許可検査:allow check:~
記録-:record::~
単調増加:monotonic::~
単調増加-:monotonic に increase::単調に増加-

	即時:immediate
	費やさ:takes／spent

	●syntax
解決-:resolve:~
	解決-済み:resolved
byte:::バイト
特有の:-specific:~

接頭辞:prefix:~
octet:::オクテット
percent:::パーセント
token:::トークン
overhead:::オーバーヘッド
frame:::フレーム
stream:::ストリーム
comma:::カンマ
命名規約:naming convention:~
規約:convention:~
合致:match:~
	合間:between:~
大文字:uppercase:~
文字:character:~
空:empty:~
区切りの:-separated:~
空白:whitespace:~
改行文字:newline:~
数字:digit:~
文字列:string:~
符号化-:encode::~:エンコード
符号化法:encoding::~:エンコーディング
	~~復号:remove
構文:syntax:~
	正準形:canonical
構文解析器:parser::~:パーサ
直列化-:serialize::~:シリアル化

	●保安
secure:::セキュア
security:::セキュリティ
privacy:::プライバシー
policy:::ポリシー
transport:::トランスポート
	施策:
悪意的な:malicious な:悪意のある
	悪化:worse:~
懸念:concern:~
	問題:problem:~
	統計的指紋収集:statistical fingerprinting
第三者:third-party:~
訪問-:visit:~
施行-:enforce:~

	●DOM ／ IDL
method:::メソッド
演算:operation:~
toJSON:
call:
worker:
作動中の:active な::~:アクティブな
interface:::インタフェース
event:::イベント
handler:::ハンドラ
obj:object::オブジェクト
例外:exception:~
要素:element:~

浮上:bubble:~
発火-:fire:~
queue:::キュー
文書:document:~
根元:root:~
単純:simple:~
取消:cancel:~
親:parent:~
継承:inherited:~

閲覧文脈:browsing context:~
文脈:context:~
要素:element:~
内容:content:~
登録-:register:~
	登録-済み:registered
未登録の:non-registered:~
登録:registration:~

大域:global::~:グローバル
環境:environment:~
初期:initial:~
関連する:relevant な:~

	●処理一般
algo:algorithm::アルゴリズム
logic:::ロジック
task:::タスク
flag:::フラグ
process:::プロセス
手続き:steps:~
段:step:~
処理:processing:~
処理-:process:~
処理過程:process:処理
完了-:complete:~
完了:completion:~
中止-:abort:~
処理待ち:pending:~
走らす:run する:~
合格-:pass:~
失敗-:fail:~
失敗:failure:~
成功-:succeed:~
	成功した:successful
成功裡:successful:~
返され:return され:~
返さ:return し:~
返す:return する:~
	返り:return:~
破棄-:discard:~
終了-:terminate:~
動作:action:~
計算-:calculate:~
調整:adjustment:~

	●仕様
UA:user agent:UA
system:::システム
version:::バージョン
proprietary:::プロプライエタリ
header:::ヘッダ
vendor:::ベンダ
risk:::リスク
	~risk下:at risk
model:::モデル
情報:information:~
仕組み:mechanism:~
任意選択:optional:~
	容易:easily
	手法:
既定:default:~::デフォルト
既定の:default:~::デフォルト
明示的:explicit:~
包括的:comprehensive:~
可用:available:~
各種用語:terminology:~
内部:internal:~
精確:precise:~
実際:actual:~
実際の:actual な:~
概して:typical に:~
特色機能:feature:~
作業草案:Working Draft:~
重要:important:~
事例:case:~
様相:picture:~
必要性:need:~
	必要
暫定的:provisional:~
方式:manner:~
適理な:reasonable な:理に適う
	足りる:sufficiently
	しておく:make sure
	べき:should
	したがって:therefore
	により:according to
	こともある:possible
	方法:-
	今日:today
	図式:graph
	内訳

	●仕様（動詞
support:::サポート
encapsulation:::カプセル化
test:::テスト
release:::リリース
指定-:specify:~
仕様:spec:~
利用者:user:~
制約:restriction:~
拘束:constraints:~
拘束-:constrain:~
制限:limit:~
上限:limit:~
定義-:define:~
定義:definition:~
	手助け:facilitate:~
拡張-:extend:~
拡張:extension:~
指示-:indicate:~
推奨-:recommend:~
供-:provide:~
供せ:provide でき:~
	供する側:provider:~
	手段:instrumentation
試験的:experimental:~
試験-:experiment:~
規範的:normative:~
	規範的でない:non-normative
導入-:introduce:~
	概要／序論:Introduction:~
要件:requirements:~
可能化-:enable:~
適合性:conformance:~
適用-:apply:~
app:application::アプリ
意図-:intend:~
結付けら:associate さ:結び付けら
考査:review:~
表面化-:surface:~
依存関係:dependency:~
精緻化:refining:~
論点:discussion:~
取組む:address する:取り組む
見做して:assume して:~
意味-:mean:~
制御-:control:~
明確化-:clarify:~
記述的:descriptive:~
遂行-:perform:~
開発者:developer:~
追加的な:additional な:追加の
	も:additional
実装-:implement:~
実装:implementation:~
再利用:reuse:~
利用:use:~
機能-:function:~
決定-:determine:~
記述-:describe:~
許容-:allow:~
試行-:try:~
再試行:retry:~
試みる:attempt する:~
関係-:relate:~
落とさ:drop さ:~
被った:incur した:~
関与-:participate:~
期待-:expect:~
反映-:reflect:~
除外:exclusion:~
除外-:exclude:~
環境設定-:configure:~
	仕立て上げ:be modified to

	●未分類（動詞
追加-:add:~
除去-:remove:~
初期化-:initialize:~
被呼出時:被 invoke 時:~
取得子:getter:~
作成-:create:~
作成:creation:~
設定-:set:~
変化:change:~
変更-:change:~
埋込d:embedded::埋め込み
	呼び出:invoke／call
値:value:~
消費-:consume:~
公開-:expose:~
共有-:share:~
完全:complete:~
既存の:existing:~
報告-:report:~
知覚-:perceive:~
表現-:represent:~
認証:authentication:~
challenge:::チャレンジ
	challenge応答:challenge-response
識別-:identify:~
超過:excess:~

	含める:include する:~
	含めら:include さ:~
	含まれ:include さ:~
	対象にする:included
	前に生じる:preceed
	からなる:compose
	〜内の~entryを移動する:copy


	●未分類
HTML:
SVG:
ALPN:
ID:
ES:ECMAScript
JS:JavaScript
size:::サイズ
script:::スクリプト
	 0:zero
source:::ソース
access:::アクセス
data:::データ
名前:name:~
名:name:~
parameter:::パラメタ
cache:::キャッシュ
hit:::ヒット
miss:::ミス
benchmark:::ベンチマーク
markup:::マークアップ
list:::リスト
cost:::コスト
下位:sub-:~
pattern:::パタン
renderer:
kernel:::カーネル
browser:::ブラウザ
stack:::スタック
非同期:asynchronous::~

品質:quality:~
体験:experience:~
動的:dynamic:~
局所:local::~:ローカル
属性:attribute:~
code:::コード
値:value:~

差分:difference:~
等価:equivalent:~
関数:function:~
妥当:valid:~
指令:directive::~
内側:inside:~
種別:type:~
型:type:~
識別子:identifier:~
registry:::レジストリ
不透明:opaque:~
逐次的:sequential:~
順序:order:~

	-:underline
	可能
	各段階
	場合
	後続
	移動できなかった~entryは:does not add more room in the buffer than it adds resources to it

	●指示語
新たな:new:~
現size:current size:現 size:現サイズ
	現在:current
現-:current:~
現在の:current:~
	現時点では:currently
特定0の:particular:ある特定の

	開始時点:at the beginning
	起点
	時点
	最大で:maximum:~
	最大数
	最小
	個数
	最後の:last
	最初の:first
	最初の:oldest
	個目:second
	一方
	一部
	以下
	当
	該当
	同じ:same
	対応:correspond
	対象
	対象:subject
	対象外
	直前／直後:immediately
	結果:result
	複数
	複数個
	見込::1
	部分
	最終:final
	別の:another
	以前は:Formally
	末尾:the end
	すべての:all


●●ref_normative

[BEACON]
    Beacon. Ilya Grigorik; Alois Reitbauer; Arvind Jain; Jatinder Mann. W3C. 13 April 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/beacon/
[CSS-SYNTAX-3]
    CSS Syntax Module Level 3. Tab Atkins Jr.; Simon Sapin. W3C. 20 February 2014. W3C Candidate Recommendation. URL: https://www.w3.org/TR/css-syntax-3/
[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.github.io/ecma262/
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 1 March 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 30 November 2018. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[PERFORMANCE-TIMELINE-2]
    Performance Timeline Level 2. Ilya Grigorik. W3C. 10 January 2019. W3C Working Draft. URL: https://www.w3.org/TR/performance-timeline-2/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234
[RFC5246]
    The Transport Layer Security (TLS) Protocol Version 1.2. T. Dierks; E. Rescorla. IETF. August 2008. Proposed Standard. URL: https://tools.ietf.org/html/rfc5246
[RFC6454]
    The Web Origin Concept. A. Barth. IETF. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230
[RFC7231]
    Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231
[RFC7234]
    Hypertext Transfer Protocol (HTTP/1.1): Caching. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7234
[RFC7301]
    Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension. S. Friedl; A. Popov; A. Langley; E. Stephan. IETF. July 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7301
[service-workers-1]
    Service Workers 1. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. 2 November 2017. W3C Working Draft. URL: https://www.w3.org/TR/service-workers-1/
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/
[XHR]
    XMLHttpRequest Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://xhr.spec.whatwg.org/

●●ref_informative

[service-workers-nightly]
    Service Workers Nightly. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. LS. URL: https://w3c.github.io/ServiceWorker/

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Resource Timing Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/resource-timing-2/

最新の編集者草案
	https://w3c.github.io/resource-timing/

編集
	<a href="toddreif@microsoft.com">Todd Reifsteck</a> (Microsoft Corp.)
	<a href="igrigorik@gmail.com">Ilya Grigorik</a> (Google)
	<a href="yoav@yoav.ws">Yoav Weiss</a> (Google) 
	<a href="arvind@google.com">Arvind Jain</a> (Google Inc.) (Until December 2014)
	<a href="jmann@microsoft.com">Jatinder Mann</a> (Microsoft Corp.) (Until February 2014)
	Zhiheng Wang (Google Inc.) (Until July 2012)
	Anderson Quach (Microsoft Corp.) (Until March 2011)

Participate
	<a href="https://github.com/w3c/resource-timing/">GitHub w3c/resource-timing </a>
	<a href="https://github.com/w3c/resource-timing/issues">File a bug</a>
	<a href="https://github.com/w3c/resource-timing/commits/gh-pages/index.html">Commit history</a>
	<a href="https://github.com/w3c/resource-timing/pulls/">Pull requests</a>

Can I use this API?
	<a href="https://caniuse.com/#feat=resource-timing">caniuse.com</a>

Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

</script>



</head>

<body>

<header>


	<hgroup>
<h1>リソースの計時 — Resource Timing Level 2</h1>
	</hgroup>

</header>


<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>
<p>
この仕様は、~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
-->
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
この文書は
<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
により発行されました。
◎
This document was published by the Web Performance Working Group as a Working Draft. This document is intended to become a W3C Recommendation. If you wish to make comments regarding this document, please send them to public-web-perf@w3.org (subscribe, archives) with [ResourceTiming] at the start of your email's subject. All comments are welcome.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る遅延は Web ~appにとり重要な品質~benchmarkである。
~JSに基づく仕組みは、~appにおける利用者~側の遅延を測定するための包括的な~~手段を供せるが、端点間の遅延については，多くの事例で，完全な様相を供せない。
この仕様は、 `PerformanceResourceTiming$I ~interfaceを導入する。
それは、~JSにより，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、この仕様を拡張して，~naviに関わる追加的な計時~情報を供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>


<div class="example">
<p>
例えば，次の~JSは、単純な方法により，資源~fetchに要した時間を計測しようと試みる：
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は計測できるが、その内訳の各段階に費やされた時間は計測できない。
更に、~markupにより記述された資源に費やされた時間を，この~scriptで計測することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に取組むため、この文書は
`PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、~client側~appにおける完全な遅延~計測を可能にする，~JSによる仕組みを供する。
この~interfaceにより、前の例は，利用者が知覚する資源の読込み時間を計測-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、~markupにより定義されたものまで含め，~page内のそれぞれの資源~fetchに要した時間の長さを計算する。
この例は、~pageが
<samp >https://www.w3.org</samp>
下に~hostされていると見做している。
その気になれば
`PerformanceResourceTiming$I
~interfaceを利用して、資源~fetchingの各段階ごとに要した時間も計測できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<p>
この仕様を通して、以下の用語が用いられる：
</p>

<dl class="def-list">
	<dt>`資源@（ `resource^en ）</dt>
	<dd>
<p>
要素その他 利用者により起動される~fetchを指す。
例えば資源は、次に挙げるものを出自にし得る：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XHR$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v の `link$e
］などの，~HTML要素 `HTML$r
</li><li>`svg$e などの~SVG要素 `SVG11$r
</li></ul>
◎
The term resource is used to refer to elements and any other user-initiated fetches throughout this specification. For example, a resource could originate from XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</dd>

	<dt>`非同一-生成元@（ `cross origin^en ）</dt>
	<dd>
`同一-生成元$でないことを意味する。
◎
The term cross-origin is used to mean non same origin.
</dd>

	<dt>`現-文書@（ `current document^en ）</dt>
	<dd>
`Window^I ~objに`結付けられている文書$を指す。
◎
The term current document refers to the document associated with the Window object's newest Document object.
</dd>

	<dt>`現-時刻@（ `current time^en ）</dt>
	<dd id="_measured-since">
時刻~値は，
<a href="~NAV-TIMING#dom-performancenavigationtiming-starttime">文書の~naviの開始</a>
を起点としてミリ秒~単位で計測されるものとする
`HR-TIME-2$r
。
例えば，文書の~naviの開始は、時刻 0 で生じる。
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
</dd>
	<dd>
`現-時刻$は、文書の~naviの開始から その時点までに経過した，ミリ秒~数による時刻を指す。
◎
The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time.
</dd>
	<dd class="note">注記：
この，時刻の定義は、 `HR-TIME-2$r 仕様に基づくものであり、
1970 年 1 月 1 日 0 時 0 分 0 秒 (UTC) を起点としていた，
`NAVIGATION-TIMING-2$r 仕様による定義
【実際には、旧 Level 1 仕様による定義】
とは異なる。
◎
Note
◎
This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING-2], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</dd>
</dl>


		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>
<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
簡潔に記すため、次の非公式な用語も導入する：
</p>

<dl class="def-list">
	<dt>`~redirect等@</dt>
	<dd>
~HTTP~redirect応答または（他の~protocolにおける）
<a href="~TR/html5/infrastructure.html#http-response-codes">それに等価なもの</a>
を指す総称。
この定義は、この仕様の以前の~versionによる参照先（過去の~HTML仕様）に基づく
— 現在の原文における<a href="~HTMLLS/#or-equivalent">この用語の参照先</a>は、存在しない（廃された）。
単に，~HTTP~redirect応答にされるべきように思われる
— 同族の `NAVIGATION-TIMING-2$r 仕様では、そう更新されているので。
</dd>

	<dt>`局所~cache等@</dt>
	<dd>
［
`関連する~app~cache$, または局所~資源
］を指す総称。
何をもって局所~資源とされるかは、この仕様には述べられていない。
`file://^P ~URLの資源や`~HTTP~cache$などが含まれそうだが（しかしながら、一部の箇所だけ明示的に “~HTTP~cacheも含む” などと注釈されているため，不明瞭になっている）。
</dd>
</dl>

		</section>
	</section>
	<section id="sec-resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>


		<section id="introduction-0">
<h3 title="Introduction">4.1. 序論</h3>

~INFORMATIVE

<div class="p">
<p>
`PerformanceResourceTiming$I
~interfaceは、~download可能な資源の計時~測定を手助けする。
例えば、次のものに利用できる：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XHR$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$v の `link$e
］などの，~HTML要素 `HTML$r
</li><li>`svg$e などの~SVG要素 `SVG11$r
</li></ul>

◎
The PerformanceResourceTiming interface facilitates timing measurement of downloadable resources. For example, this interface is available for XMLHttpRequest objects [XHR], HTML elements [HTML] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</div>


		</section>
		<section id="resources-included-in-the-performanceresourcetiming-interface">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源</h3>

<p>
~NULL でない`~client$rqからの`要請$により`~fetch$されたすべての資源は、
`局所~cache等$から検索取得された資源も含め
— `処理~model$の一部として除外されない限り —
`PerformanceResourceTiming$I ~objとして，`~client$rqの`大域~obj$の`処理能時列線$に含めるモノトスル。
ただし，~fetchにより起動されたが（~network~errorなどに因り）後で中止された資源は、`処理能時列線$に含めなくてもヨイ
— 含める場合、各種~属性の値は`処理~model$による手続き（後述）の中で初期化するモノトスル。
◎
All resource Requests fetched by a non-null client MUST be included as PerformanceResourceTiming objects in the client's global object's Performance Timeline, unless excluded from the timeline as part of the processing model. Resources that are retrieved from relevant application caches or local resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MAY be included as PerformanceResourceTiming objects in the Performance Timeline and MUST contain initialized attribute values for processed substeps of the processing model.
</p>

<p>
この節の残りの部分は規範的ではない。
◎
The rest of this section is non-normative.
</p>


<p>
例：
◎
Examples:
</p>

<ul>
	<li>
複数の~HTML `img$e 要素の `src^a 属性に，正準形が同じになる~URL（ `the same canonical URL^en 
【すなわち，同じ資源を指す~URL】
）が利用されている場合、［
最初に資源`~fetch$を起動させた `img^e 要素
］の方が `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められるベキである。
~UAは、 2 個目以降の `img^e 要素の~URLに対しては、再~要請することなく，最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能時列線$には、最初に起動された， `img^e 要素に対する資源`~fetch$による結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element should be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
~HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、元々の資源`~fetch$のみならず，新たな~URLへの`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
~HTML `iframe$e 要素の~markupに `src^a 属性が指定されていない場合、~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合，その新たな~URLの資源へ`~fetch$されることになる。
この場合、新たな~URLによる`~fetch$のみが， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準形が同じになる~URL用に，複数の `XMLHttpRequest$I が生成された場合、いずれの資源`~fetch$も， `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められることになる
— 後続する資源~fetch要請には、先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の~HTML `iframe$e 要素~内に入れ子にされた文書により要請される下位~資源は、親~文書の`処理能時列線$ではなく，入れ子にされた文書の`処理能時列線$に含められる。
`iframe^e に対し`処理能時列線$に含められるのは、その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~IETF/rfc2397">data: URI</a> `RFC2397$r
を持つ場合、その資源は，`処理能時列線$には含められない。
data: URI は埋込d~dataであり、`~fetch$を要さないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>
	<li>
資源`~fetch$が~network~error（ DNS, TCP, TLS ~errorなど）に因り中止された場合、その~fetchは，失敗した時点までの属性~値で初期化された `PerformanceResourceTiming$I ~objとして`処理能時列線$に含められてよい
— 例えば TCP ~handshake~errorは、 要請~用の DNS 時刻印を報告するべきである, 等々。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch may be included as a PerformanceResourceTiming object in the Performance Timeline with initialized attribute values up to the point of failure - e.g. a TCP handshake error should report DNS timestamps for the request, and so on.
</li>
	<li>
資源`~fetch$が，事前条件（例： 混在内容（ `mixed content^en ）, CORS 制約, CSP ~policy, など）に失敗したことにより中止された場合、その資源については，`処理能時列線$には含められるべきでない。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource should not not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>


		</section>
		<section id="sec-performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>


<p>
`PerformanceResourceTiming$I ~interfaceは、`処理能時列線$に関与し，
`PerformanceEntry$I ~interfaceの次の属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>


<dl class="idl-def">
	<dt>`name@m</dt>
    <dd>
取得子は、要請された資源の`解決-済み~URL$ を返すモノトスル。
この属性は、`~fetch$先が異なる~URLに~redirectされても，変化しないモノトスル。
◎
This attribute MUST return the resolved URL of the requested resource. This attribute must not change even if the fetch redirected to a different URL.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、 `resource^l を返すモノトスル。
◎
The entryType attribute MUST return the DOMString "resource".
</dd>

	<dt>`startTime@m</dt>
	<dd>
<p>
取得子は、［
~UAが資源`~fetching$を~queueする直前の時刻
］を表す，［
`DOMHighResTimeStamp$I 型 `HR-TIME-2$r の値
］を返すモノトスル。
資源~fetchの間に`~redirect等$が生じたときは、次に与える値を返すモノトスル：
</p>

<ul ><li>どの`~redirect等$に対しても、［
`現-文書$と`同一-生成元$であるか, または`計時~許可検査$に合格する
］ならば、 `redirectStart$m と同じ値。
</li><li>他の場合、 `fetchStart$m と同じ値。
</li></ul>


◎
The startTime attribute MUST return a DOMHighResTimeStamp [HR-TIME-2] with the time immediately before the user agent starts to queue the resource for fetching. If there are HTTP redirects or equivalent when fetching the resource, and if all the redirects or equivalent are from the same origin as the current document or the timing allow check algorithm passes, this attribute MUST return the same value as redirectStart. Otherwise, this attribute MUST return the same value as fetchStart.
</dd>

	<dt>`duration@m</dt>
	<dd>
取得子は、
`responseEnd$m の， `startTime$m からの差分を表す
`DOMHighResTimeStamp$I
を返すモノトスル
<!-- ＊,respectively -->
◎
The duration attribute MUST return a DOMHighResTimeStamp equal to the difference between responseEnd and startTime, respectively.
</dd>
</dl>


<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute `DOMString$ `initiatorType$m;
  readonly attribute `DOMString$ `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$I `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$I `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseEnd$m;
  readonly attribute unsigned long long `transferSize$m;
  readonly attribute unsigned long long `encodedBodySize$m;
  readonly attribute unsigned long long `decodedBodySize$m;
  [`Default$] `object$ `toJSON$m();
};
</pre>


<dl class="idl-def">
	<dt>`toJSON()@m</dt>
	<dd>
~call時には、 `WebIDL$r による`既定の~toJSON演算$を走らす。
◎
When toJSON is called, run [WEBIDL]'s default toJSON operation.
</dd>

	<dt>`initiatorType@m</dt>
	<dd>
<p>
取得子は、何が資源の~fetch要請を生じさせたかに応じて，次を返すモノトスル：
◎
On getting, the initiatorType attribute MUST return one of the following DOMString values:
</p>

		<ul>
			<li>
要請は`要素$を処理した結果による場合
⇒
当の要素の`局所~名$
◎
The same value as the localName of that element [DOM], if the request is a result of processing the element;
</li>
			<li>
要請は
`url()$css による指令（
`@import url()^css や `background: url()^css
など）
`CSS-SYNTAX-3$r
を処理した結果による場合
⇒
`css@l
◎
"css", if the request is a result of processing a CSS url() directive [CSS-SYNTAX-3], such as @import url() or background: url();
</li>
			<li>
要請は
`~navi要請$である場合
⇒
`navigation@l
◎
"navigation", if the request is a navigation request;
</li>
			<li>
要請は `XMLHttpRequest$I ~obj `XHR$r を処理した結果による場合
⇒
`xmlhttprequest@l
◎
"xmlhttprequest", if the request is a result of processing an XMLHttpRequest object [XHR];
</li>
			<li>
要請は
`fetch()$m ~method
`FETCH$r
を処理した結果による場合
⇒
`fetch@l
◎
"fetch", if the request is the result of processing the Fetch method [FETCH];
</li>
			<li>
要請は
`sendBeacon()$m ~method
`BEACON$r
を処理した結果による場合
⇒
`beacon@l
◎
"beacon", if the request is the result of processing the sendBeacon method [BEACON];
</li>
			<li>
上に挙げたどれにも該当しない場合
⇒
`other@l
◎
"other", if none of the above conditions match.
</li>
		</ul>
	</dd>

	<dt>`nextHopProtocol@m</dt>
	<dd>
<p>
取得子は、［
当の資源が`局所~cache等$から検索取得されているならば 空~文字列 ／
~ELSE_ 
~ALPN~protocol~ID
— `ALPN Protocol ID^en `RFC7301$r —
として識別される，資源~fetchに利用された~network~protocol
］を返すモノトスル。
~proxyが環境設定されている下では、次を返すモノトスル：
</p>
		<ul>
			<li>
~tunnel接続が確立された場合
⇒
その~tunnelされた~protocolの~ALPN~protocol~ID
</li>
			<li>
他の場合
⇒
~proxyへの最初の hop の~ALPN~protocol~ID
</li>
		</ul>

<p>
~ALPN~protocol~IDを精確に表現するため、次の拘束も適用される：
</p>
		<ul>
			<li>
~ALPN~protocol内の~octetのうち， `%^l を除く妥当な~token文字は~percent符号化しないモノトスル。
</li>
			<li>
~percent符号化法には，大文字の 16 進~数字を用いるモノトスル。
</li>
		</ul>
◎
On getting, the attribute nextHopProtocol returns the network protocol used to fetch the resource, as identified by the ALPN Protocol ID [RFC7301]; resources retrieved from relevant application caches or local resources, return an empty string. When a proxy is configured, if a tunnel connection is established then this attribute MUST return the ALPN Protocol ID of the tunneled protocol, otherwise it MUST return the ALPN Protocol ID of the first hop to the proxy. In order to have precisely one way to represent any ALPN protocol ID, the following additional constraints apply: octets in the ALPN protocol MUST NOT be percent-encoded if they are valid token characters except "%", and when using percent-encoding, uppercase hex digits MUST be used.
</dd>
	<dd>
登録-済み~ALPN~protocol~IDは、以前は IANA により文書~化されていた。
~UAは、試験的な未登録の~protocolを利用している事例では，~ALPN用に折衝されている値があれば それを利用するモノトスル
— ~ALPNは~protocol折衝~用に利用されていない場合、別の記述的な文字列を利用してもヨイ
◎
Formally registered ALPN protocol IDs are documented by IANA. In case the user agent is using an experimental, non-registered protocol, the user agent MUST use the ALPN negotiated value if any. If ALPN was not used for protocol negotiations, the user agent MAY use another descriptive string.
Note
</dd>
	<dd class="note">注記：
~ALPN~ID `h3^l は、
`HTTP/3 Internet Draft^en
内の
`HTTP/3 protocol^en
の最終~version用に定義されている。
◎
The "h3" ALPN ID is defined for the final version of the HTTP/3 protocol in the HTTP/3 Internet Draft.
</dd>
	<dd>
この属性は、実際にどう折衝されたかに関わらず，~fetch用に利用~中の~network~protocolを識別するためとして意図されていることに注意。
すなわち、~network~protocolを折衝するために~ALPNが利用されていなくても、この属性は，依然として，~ALPN~protocol~IDを利用して利用~中の~protocolを指示する。
◎
Note that the nextHopProtocol attribute is intended to identify the network protocol in use for the fetch regardless of how it was actually negotiated; that is, even if ALPN is not used to negotiate the network protocol, this attribute still uses the ALPN Protocol ID's to indicate the protocol in use.
</dd>


	<dt>`workerStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the workerStart attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
現在の［
`閲覧文脈$ ／ ~worker文脈
］には`作動中の~worker$ %worker は在る
`service-workers-1$r
］：
◎
If the current browsing or worker context's have an active worker [service-workers-1]:
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
~RET ~UAが［
 %worker に向けて，`名前~fetch_evの~eventを発火する$
］直前の時刻
◎
the time immediately before the user agent fires an event named `fetch` at the active worker if the worker is available.
</li>
					<li>
~RET ~UAが［
%worker を`走らす$
］直前の時刻
◎
the time immediately before the user agent runs the worker required to service the request.
</li>
				</ol>
			</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~workerの`時刻起点$の定義により、~naviにおける事前読込み（ `preload^en ）要請
【用の `PerformanceResourceTiming$I ~obj】
の一部の属性は，負の `DOMHighResTimeStamp$I 値をとることもある。
【時刻起点より前に~fetchが起動され得るので（<a href="https://github.com/w3c/resource-timing/issues/139">詳細</a>）。】
◎
Note that according to the definition of time origin in workers, it is possible that some attributes of navigation preload requests will have negative DOMHighResTimeStamp values.
</dd>

	<dt>`redirectStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the redirectStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源`~fetching$において`~redirect等$が生じている
］~AND［
それらの`~redirect等$すべてが，`計時~許可検査$に合格した
］
⇒
~RET ［
~redirectを起動させた`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource that initiates the redirect, if there are HTTP redirects or equivalent when fetching the resource and all the redirects or equivalent pass the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>


	<dt>`redirectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the redirectEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
資源`~fetching$において`~redirect等$が生じている
］~AND［
それらの`~redirect等$すべてが，`計時~許可検査$に合格した
］
⇒
~RET ［
最後の~redirectに対する応答の最後の~byteを受信した
］直後の時刻
◎
The time immediately after receiving the last byte of the response of the last redirect, if there are HTTP redirects or equivalent when fetching the resource and all the redirects or equivalent pass the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>


	<dt>`fetchStart@m</dt>
	<dd>

<p>
取得子は、次を走らすモノトスル：
◎
On getting, the fetchStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
`~redirect等$が生じている
］
⇒
~RET ~UAが［
~redirectされなかった最後の資源`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the final resource in the redirection, if there are HTTP redirects or equivalent.
</li>
			<li>
~RET ~UAが［
資源`~fetch$を開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the domainLookupStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm.
</li>
			<li>
~IF［
資源を~fetchする際に~domain検索は要求されていない（例：
`持続的~接続$ `RFC7230$r が利用されている／
資源は`局所~cache等$から検索取得された）
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if no domain lookup was required to fetch the resources (e.g. if a persistent connection [RFC7230] was used or in case the resource was retrieved from relevant application caches or local resources).
</li>
			<li>
~IF［
~UAの~cache内に~domain情報が在る
］
⇒
~RET ~UAが［
~domain情報~cacheから~domain~dataの検索取得を開始した
］直前の時刻
◎
The time immediately after the user agent starts the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~RET ~UAが［
資源~用の~domain名~検索を開始した
］直前の時刻
◎
The time immediately before the user agent starts the domain name lookup for the resource, otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the domainLookupEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm.
</li>
			<li>
~IF［
資源を~fetchする際に~domain検索は要求されていない（例：
`持続的~接続$ `RFC7230$r が利用されている／
資源は`局所~cache等$から検索取得された）
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if no domain lookup was required to fetch the resources (e.g. if a persistent connection [RFC7230] was used or in case the resource was retrieved from relevant application caches or local resources).
</li>
			<li>
~IF［
~UAの~cache内に~domain情報が在る
］
⇒
~RET ~UAが［
~domain情報~cacheからの~domain~dataの検索取得を終えた
］直後の時刻
◎
The time immediately after the user agent ends the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~RET ~UAが［
資源~用の~domain名~検索を完遂した
］直後の時刻
◎
The time immediately after the user agent finishes the domain name lookup for the resource, otherwise.
</li>
		</ol>
	</dd>

	<dt>`connectStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the connectStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p>
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立ngを開始した
］直前の時刻
◎
The time immediately before the user agent start establishing the connection to the server to retrieve the resource, otherwise.
</p>

<p>
~transport接続が失敗して，~UAが接続を~openし直した場合、
`connectStart$m は，新たな接続に対応する値を返すベキである。
◎
If the transport connection fails and the user agent reopens a connection, connectStart SHOULD return the corresponding value of the new connection.
</p>
			</li>
		</ol>
	</dd>

	<dt>`connectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the connectEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p>
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立ngを完遂した
］直後の時刻
◎
The time immediately after the user agent finish establishing the connection to the server to retrieve the resource, otherwise.
</p>

<p>
返される値には、SSL ~handshakeや SOCKS 認証などの他の所要時間も含む、~transport接続の確立に要した時間も含めるモノトスル。
◎
The returned time MUST include the time interval to establish the transport connection, as well as other time intervals such as SSL handshake and SOCKS authentication.
</p>

<p>
~transport接続が失敗して，~UAが接続を~openし直した場合、
`connectEnd$m は，新たな接続に対応する値を返すベキである。
◎
If the transport connection fails and the user agent reopens a connection, connectEnd SHOULD return the corresponding value of the new connection.
</p>
			</li>
		</ol>
	</dd>

	<dt>`secureConnectionStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the secureConnectionStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
~secure~transportは利用されていない
］~OR［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］
⇒
~RET 0
◎
Zero, if a secure transport is not used or if any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm.
</li>
			<li>
~IF［
`持続的~接続$ `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
~RET ~UAが［
現在の接続を~secureにする~handshake処理を開始した
］直前の時刻
◎
The time immediately before the user agent starts the handshake process to secure the current connection, otherwise.
</li>
		</ol>
	</dd>

	<dt>`requestStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the requestStart attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
要請~連鎖（~redirectを含む）を成す すべての資源`~fetch$は，`計時~許可検査$に合格した
］
⇒
~RET
~UAが［［
`局所~cache等$, または ~server
］に向けて，その資源~要請を開始した
］直前の時刻
◎
The time immediately before the user agent starts requesting the resource from the server, or from relevant application caches or from local resources, if all requests in the resource fetch's request-chain (including redirects) pass the timing allow check algorithm. 


the last non-redirected fetch of the resource passes the timing allow check algorithm.
</p>

<p>
要請の送信-後に~transport接続が失敗して，~UAが接続を~openし直して要請を送信し直した場合、その新たな要請に対応する値を返すモノトスル。
◎
If the transport connection fails after a request is sent and the user agent reopens a connection and resend the request, requestStart MUST return the corresponding values of the new request.
</p>
			</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dd class="note">
<p>注記：
この~interfaceは、要請の送信~完了を表現する
“`requestEnd^m” の類の属性は含まない。
◎
Note
◎
This interface does not include an attribute to represent the completion of sending the request, e.g. requestEnd.
</p>

		<ul>
			<li>
~UAからの要請の送信~完了は、［
その種の属性が最も役立つ，~network~transportにおける 対応する完了~時刻
］を常に指示するものではない。
◎
Completion of sending the request from the user agent does not always indicate the corresponding completion time in the network transport, which brings most of the benefit of having such an attribute.
</li>
			<li>
一部の~UAは、~HTTP層の~encapsulationに因り，実際の完了~時刻を決定する~costが高くつく。
◎
Some user agents have high cost to determine the actual completion time of sending the request due to the HTTP layer encapsulation.
</li>
		</ul>
	</dd>



	<dt>`responseStart@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the responseStart attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す すべての資源`~fetch$は，`計時~許可検査$に合格した
］
⇒
~RET ~UAの~HTTP構文解析器が［
`局所~cache等$, または~server
］から［
応答の最初の~byte（例：
HTTP/2 用には ~frame~headerの~byte列 ／
HTTP/1.x 用には 応答の~status行
）
］を受信した直後の時刻
◎
The time immediately after the user agent's HTTP parser receives the first byte of the response (e.g. frame header bytes for HTTP/2, or response status line for HTTP/1.x) from relevant application caches, or from local resources or from the server if all requests in the resource fetch's request-chain (including redirects) pass the timing allow check algorithm.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>

	</dd>
	<dd class="note">注記：
何が “最初の~byteを受信した” かの定義には、
~kernel,
~browserの~network~stack,
~HTTP構文解析器, 
~renderer,
等々，いくつか適理なものが在る。
上では~HTTP構文解析器と定めているので、それが~dataを受信する前に［
~clientの~kernel~buffer, その他の手続き
］の内側にて~dataを~queueする時間も含まれ得る。
◎
Note
◎
There are many reasonable definitions of "receipt of first byte": as seen by the kernel, by the browsers network stack / HTTP parser, by the renderer, and so on. The above definition is with respect to the HTTP parser, and thus may include queuing time inside of client's kernel buffers and other steps that may preceed receipt of data by the HTTP parser.
</dd>
	<dd class="note">注記：
~fetchが複数の要請からなる場合（例：
予行（ `preflight^en ）,
認証~challenge応答,
~redirect,
等々）、報告される `responseStart^m 値は，最後の要請のそれになる。
また、要請に対する応答が複数~在る場合
— すなわち， `1xx$st ( Informational ) 応答が在る場合 —
報告される `responseStart^m 値は，最後の要請に対する最初の応答のそれになる。
◎
Note
◎
For fetches composed of multiple requests (e.g. preflights, authentication challenge-response, redirects, and so on), the reported responseStart value is that of the last request. In the case where more than one response is available for a request, due to an Informational 1xx response, the reported responseStart value is that of the first response to the last request.
</dd>

	<dt>`responseEnd@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the responseEnd attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
~UAは~network~errorにより~fetchを中止した
］
⇒
~RET 中止した時刻
◎
↓</li>
			<li>
<p>
~RET 次のうち，早い方の時刻
</p>

<ul><li>~UAが［［
`局所~cache等$, または~server
］から資源の最後の~byteを受信した
］直後の時刻
</li><li>~transport接続が~closeされる直前の時刻
</li></ul>

◎
The time immediately after the user agent receives the last byte of the response or immediately before the transport connection is closed, whichever comes first. The resource here can be received either from relevant application caches, local resources, or from the server.
◎
The time immediately before the user agent aborts the fetch due to a network error.
</li>
		</ol>
	</dd>

	<dt>`transferSize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the transferSize attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
要請~連鎖（~redirectを含む）を成す すべての資源`~fetch$は，`計時~許可検査$に合格した
］
⇒
~RET ［
`~HTTP~network~fetch$から受信された，応答の［
一連の~header, および`~payload本体$ `RFC7230$r
］に消費された~size
］
◎
the size, in octets received from a HTTP-network fetch, consumed by the response header fields and the response payload body [RFC7230] if all requests in the resource fetch's request-chain (including redirects) pass the timing allow check algorithm.
</p>

<p>
~navigateするときに`~redirect等$があって，すべての`~redirect等$が同じ`生成元$ `RFC6454$r から来ている場合、それらの~redirectにより被った~HTTP~overheadも含まれるベキである。
◎
If there are HTTP redirects or equivalent when navigating and if all the redirects or equivalent are from the same origin [RFC6454], this attribute should include the HTTP overhead of incurred redirects.
</p>

<p>
この属性は、~HTTPによる~overhead（
HTTP/1.1 における，`~chunked符号法$や~headerの前後の空白（改行文字も含む） ／
`HTTP/2$ における，同じ~stream上の 他の［
~serverから~clientへの~frame
］による~overhead）を含めるベキである一方、低層の~protocolにおける~overhead（
TLS `RFC5246$r や TCP
によるものなど）は，含めるベキでない。
◎
This attribute should include HTTP overhead (such as HTTP/1.1 chunked encoding and whitespace around header fields, including newlines, and HTTP/2 frame overhead, along with other server-to-client frames on the same stream), but should not include lower-layer protocol overhead (such as TLS [RFC5246]or TCP).
</p>

<p class="note">注記：
`transferSize$m 値が `encodedBodySize$m より低くなることもある：
~cache済みの応答が成功裡に再検証されたとき、
`transferSize$m は，再検証する際に被った~HTTP応答~headerたちの~sizeを報告し、
`encodedBodySize$m は，以前に検索取得された~payload本体の~sizeを報告する。
◎
Note
◎
It is possible for transferSize value to be lower than encodedBodySize: when a cached response is successfully revalidated the transferSize reports the size of the response HTTP headers incurred during the revalidation, and encodedBodySize reports the size of the previously retrieved payload body.
</li>
			<li>
~RET 0
— 資源が`局所~cache等$から検索取得された場合も含め
◎
zero otherwise, including for resources retrieved from relevant application caches or from local resources.
</li>
		</ol>

	</dd>


	<dt>`encodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the encodedBodySize attribute MUST return as follows:
</p>
		<ol>
			<li>
~IF［
要請~連鎖（~redirectを含む）を成す すべての資源`~fetch$は，`計時~許可検査$に合格した
］
⇒
~RET
`~HTTP~network-or-cache~fetch$から受信された
`~payload本体$ `RFC7230$r の~octet数による~size
— 適用されている`内容~符号法たち$ `RFC7231$r があれば それを~~復号する前の
◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the payload body [RFC7230], prior to removing any applied content-codings [RFC7231], if all requests in the resource fetch's request-chain (including redirects) pass the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET
~payload本体の~octet数による~size
— 適用されている`内容~符号法たち$があれば それを~~復号する前の
◎
The size, in octets, of the payload body prior to removing any applied content-codings if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>

	</dd>
	<dd class="note">注記：
`encodedBodySize^m は、`応答~code$に依存して 0 にもなることもある
— 例えば~HTTP `204$st (No Content), `3XX$st, 等々。
◎
Note
◎
The encodedBodySize may be zero depending on the response code - e.g. HTTP 204 (No Content), 3XX, etc.
</dd>

	<dt>`decodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らすモノトスル：
◎
On getting, the decodedBodySize attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
要請~連鎖（~redirectを含む）を成す すべての資源`~fetch$は，`計時~許可検査$に合格した
］
⇒
~RET
`~HTTP~network-or-cache~fetch$から受信された`~message本体$ † `RFC7230$r の~octet数による~size
— 適用されている`内容~符号法たち$ `RFC7231$r を~~復号した後の
</p>

<p class="trans-note">【†
厳密には，`~payload本体$であろう（それ以前に`転送~符号法$も~~復号される必要がある筈なので）
】</p>

◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the message body [RFC7230], after removing any applied content-codings [RFC7231], if all requests in the resource fetch's request-chain (including redirects) pass the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得された
］
⇒
~RET
~payloadの~size
— 適用されている`内容~符号法たち$があればそれを~~復号した後の
◎
The size, in octets, of the payload after removing any applied content-codings, if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET 0
◎
zero, otherwise.
</li>
		</ol>
	</dd>
</dl>

<p>
`PerformanceResourceTiming$I を実装する~UAは、【利用される前に】次を走らすモノトスル
⇒
`処理能~entry種別を登録する$( `resource^l )
◎
A user agent implementing PerformanceResourceTiming MUST run the register a performance entry type algorithm with "resource" as input.
</p>

		</section>
		<section id="sec-extensions-performance-interface">
<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>


<p>
~UAは、 `PerformanceResourceTiming$I ~objとして`処理能時列線$ `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限できる。
この節では、 `Performance$I ~interfaceを拡張して，格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent may choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小~個数は 250 である
— ~UAはこれを変更してもよいが。
この制限は、
`setResourceTimingBufferSize()$m を呼び出すことにより，変更-を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 250, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>


<p>
各 `~ES大域~環境$は、次のものを持つ：
◎
Each ECMAScript global environment has:
</p>

<dl class="def-list">
	<dt>
`資源~計時~buffer~size上限@
◎
A resource timing buffer size limit＼
</dt>
	<dd>
初期~時は 250 以上【が推奨される】。
◎
which should initially be 250 or greater.
<dd>

	<dt>
`資源~計時~buffer現size@
◎
A resource timing buffer current size＼
</dt>
	<dd>
0 以上の整数。
初期~時は 0 。
◎
which is initially 0.
</dd>

	<dt>
`資源~計時~buffer満杯~event処理待ち~flag@
◎
A resource timing buffer full event pending flag＼
</dt>
	<dd>
~flag値。
初期~時は ~OFF 。
◎
which is initially false.
</dd>

	<dt>
`資源~計時~副buffer現size@
◎
A resource timing secondary buffer current size which is initially 0.
</dt>
	<dd class="trans-note">【
`資源~計時~副buffer$を成す~entryの個数を表すが、この訳では，この用語は利用しない。
代わりに，~algoの記述にて等価に表現する（`副buffer内の~entryを移動する$における，真偽値 %移動した ）。
そうした方が簡潔かつ簡明に記述できるので。
】</dd>

	<dt>
`資源~計時~副buffer@
◎
A resource timing secondary buffer＼
</dt>
	<dd>
0 個以上の `PerformanceResourceTiming$I ~objからなる~list。
初期~時は空。
◎
to store PerformanceResourceTiming objects that is initially empty.
</dd>
</dl>

<pre class="idl">
partial interface `Performance$I {
  void `clearResourceTimings()$m;
  void `setResourceTimingBufferSize$m(unsigned long %maxSize);

  attribute `EventHandler$I `onresourcetimingbufferfull$m;
};
</pre>

<p>
`Performance$I ~interfaceは
`HR-TIME-2$r にて定義される。
◎
The Performance interface is defined in [HR-TIME-2].
</p>

<dl class="idl-def">

	<dt>`clearResourceTimings()@m</dt>
	<dd>
<p>
被呼出時には、次を走らすモノトスル：
◎
The method clearResourceTimings runs the following steps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$から 次を満たす~entryをすべて除去する
⇒
`PerformanceResourceTiming$I ~objである
◎
Remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~SET 0
◎
Set resource timing buffer current size to 0.
</li>
		</ol>
	</dd>

	<dt>`setResourceTimingBufferSize(maxSize)@m</dt>
	<dd>
被呼出時には、次を走らすモノトスル
⇒
`資源~計時~buffer~size上限$ ~SET %maxSize
◎
The setResourceTimingBufferSize method runs the following steps:
• Set resource timing buffer size limit to the maxSize parameter.＼
</dd>
	<dd class="note">注記：
［
%maxSize ~LT `資源~計時~buffer現size$
］であっても，`処理能~entry~buffer$から `PerformanceResourceTiming$I ~objは除去されない。
◎
If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</dd>

	<dt>`onresourcetimingbufferfull@m</dt>
	<dd>
`resourcetimingbufferfull@et
~event用の~event~handler。
【`~buffer満杯~eventを発火する$を見よ。】
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event described below.
</dd>
</dl>

<p>
`資源~計時~entryを追加でき@
るとは、次が満たされることをいう
⇒
`資源~計時~buffer現size$ ~LT `資源~計時~buffer~size上限$
◎
To check if can add resource timing entry, run the following steps:
• If resource timing buffer current size is smaller than resource timing buffer size limit, return true.
• Return false.
</p>

<p class="algo-head">
`処理能~entry~bufferに~entryを追加する@
ときは、所与の
( `処理能~entry~buffer$ %~buffer, `PerformanceResourceTiming$I ~obj %~entry )
に対し，次を走らす：
◎
To add a PerformanceResourceTiming entry (new entry) in the performance entry buffer, run the following steps:
• Let new entry be the input PerformanceEntry to be added.
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~entryを追加でき$る
］~AND［
`資源~計時~buffer満杯~event処理待ち~flag$ ~EQ ~OFF
］：
◎
If can add resource timing entry returns true and resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
%~buffer に %~entry を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
Increase resource timing buffer current size by 1.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`資源~計時~buffer満杯~event処理待ち~flag$ ~EQ ~OFF
］：
◎
If resource timing buffer full event pending flag is false, run the following substeps:
</p>
		<ol>
			<li>
`資源~計時~buffer満杯~event処理待ち~flag$ ~SET ~ON
◎
Set resource timing buffer full event pending flag to true.
</li>
			<li>
次を走らす`~taskを~queueする$
⇒
`~buffer満杯~eventを発火する$
◎
Queue a task to run fire a buffer full event.
</li>
		</ol>
	</li>
	<li>
`資源~計時~副buffer$に %~entry を付加する
◎
Add new entry to the resource timing secondary buffer.
◎
Increase resource timing secondary buffer current size by 1.
</li>
</ol>

<p class="algo-head">
`副buffer内の~entryを移動する@
ときは、次を走らす：
◎
To copy secondary buffer, run the following steps:
</p>

<ol>
	<li>
%移動した ~LET ~F
</li>
	<li>
<p>
~WHILE［
`資源~計時~副buffer$は空でない
］~AND［
`資源~計時~entryを追加でき$る
］：
◎
While resource timing secondary buffer is not empty and can add resource timing entry returns true, run the following substeps:
</p>
		<ol>
			<li>
%~entry ~LET `資源~計時~副buffer$内の最初の（最も古い） `PerformanceResourceTiming$I ~obj
◎
Let entry be the oldest PerformanceResourceTiming in resource timing secondary buffer.
</li>
			<li>
`処理能~entry~buffer$の末尾に %~entry を追加する
◎
Add entry to the end of performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
Increment resource timing buffer current size by 1.
</li>
			<li>
`資源~計時~副buffer$から %~entry を除去する
◎
Remove entry from resource timing secondary buffer.
</li>
			<li>
%移動した ~SET ~T
◎
Decrement resource timing secondary buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
~RET %移動した
</li>
</ol>

<p class="algo-head">
`~buffer満杯~eventを発火する@
ときは、次を走らす：
◎
To fire a buffer full event, run the following steps:
</p>

<ol>
	<li>
<p>
~WHILE［
`資源~計時~副buffer$は空でない
］：
◎
While resource timing secondary buffer is not empty, run the following substeps:
</p>
		<ol>
			<li>
~IF［
`資源~計時~entryを追加でき$ない
］
⇒
`Performance$I ~objに向けて，名前 `resourcetimingbufferfull$et の`~eventを発火する$
◎
Let number of excess entries before be resource timing secondary buffer current size.
◎
If can add resource timing entry returns false, then fire an event named resourcetimingbufferfull at the Performance object.
</li>
			<li>
%移動した ~LET `副buffer内の~entryを移動する$
◎
Run copy secondary buffer.
</li>
			<li>
~IF［
%移動した ~EQ ~F
］
⇒＃
`資源~計時~副buffer$からすべての~entryを除去する†；
~BREAK
◎
Let number of excess entries after be resource timing secondary buffer current size.
◎
If number of excess entries before is lower than or equals number of excess entries after, then remove all entries from resource timing secondary buffer, set resource timing secondary buffer current size to 0, and abort these steps.
</li>
		</ol>
	</li>
	<li>
`資源~計時~buffer満杯~event処理待ち~flag$ ~SET ~F
◎
Set resource timing buffer full event pending flag to false.
</li>
</ol>

<p class="note">注記：†
移動できなかった~entryは、~bufferから落とされる。
開発者は、 `resourcetimingbufferfull$et ~event用の~event~handler内で［
`clearResourceTimings()$m を~callするか,
（ `setResourceTimingBufferSize()$m を~callして）~bufferが足りるよう拡張するか
］しておくべきである。
◎
This means that if the resourcetimingbufferfull event handler does not add more room in the buffer than it adds resources to it, excess entries will be dropped from the buffer. Developers should make sure that resourcetimingbufferfull event handlers call clearResourceTimings or extend the buffer sufficiently (by calling setResourceTimingBufferSize).
</p>

		</section>
		<section id="sec-cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一-生成元~資源</h3>

<div class="p">
<p>
`非同一-生成元$資源は、
`PerformanceResourceTiming$I ~objとして
`処理能時列線$に含められるモノトスル。
`非同一-生成元$資源に対する~fetchが`計時~許可検査$に失敗した場合、その
`PerformanceResourceTiming$I
~objの属性のうち，次のものは、 0 になるモノトスル：
</p>

<ul>
<li>`redirectStart$m
<li>`redirectEnd$m
<li>`domainLookupStart$m
<li>`domainLookupEnd$m
<li>`connectStart$m
<li>`connectEnd$m
<li>`requestStart$m
<li>`responseStart$m
<li>`secureConnectionStart$m
<li>`transferSize$m
<li>`encodedBodySize$m
<li>`decodedBodySize$m
</ul>

◎
Cross-origin resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a cross-origin resource, these attributes of its PerformanceResourceTiming object MUST be set to zero: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, secureConnectionStart, transferSize, encodedBodySize and decodedBodySize.
</div>

<p>
~server側~appは、この節で前に指定された，［
さもなければ`非同一-生成元$の制約から値が 0 にされる属性
］の，~UAにおける公開を許容するために、当の文書~生成元を値とする
`Timing-Allow-Origin$h ~HTTP応答~header返してもよい。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to the cross-origin restrictions previously specified in this section.
</p>

			<section id="sec-timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一-生成元の制約に因り 0 にされていた属性
］の値を見ることが許容される生成元（たち）
］を指示する~policyを通信できる。
この~headerの値は、次の ABNF `RFC5234$r と
<a href="~RFC7230#section-7">その~list拡張</a>
`RFC7230$r を用いて表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that are allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234] (using List Extension, [RFC7230]):
</p>

<pre class="ABNF">
Timing-Allow-Origin = 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、複数個の `Timing-Allow-Origin$h ~headerを生成してもヨイ。
受信者は、複数個の `Timing-Allow-Origin$h ~headerに対しては、それらの~headerの値を順に~commaで区切って連結して， 1 つの~headerに結合してもヨイ。
◎
The sender may generate multiple Timing-Allow-Origin header fields. The recipient may combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<p>
`計時~許可検査@
は、所与の %資源 の計時~情報を`現-文書$ %文書 と共有し得るかどうかを検査する
— %V を %資源 に伴われる `Timing-Allow-Origin$h ~headerの値とするとき、次のいずれかが満たされるならば “合格した” とされる
【他の場合、この仕様においては “失敗した” と記される】
：
◎
The timing allow check algorithm, which checks whether a resource's timing information can be shared with the current document, is as follows:
</p>

<ul>
	<li>
%資源, %文書 は`同一-生成元$である
◎
If the resource is same origin, return pass.
</li>
	<li>
%文書 の`生成元$【を直列化した結果】の値 ~EQ %V を成すある `origin-or-null$P 成分
◎
If the Timing-Allow-Origin header value list contains a case-sensitive match for the value of the origin of the current document,＼
</li>
	<li>
%V 内に `wildcard$P （ `*^l ）が在る
◎
or a wildcard ("*"), return pass.
◎
Return fail.
</li>
</ul>


			</section>
			<section id="sec-iana-considerations">
<h4 title="IANA Considerations">4.5.2. IANA 考慮点</h4>

<p>
この節では、 `Timing-Allow-Origin$h を
<a href="~IETF/rfc3864#section-4.2.2">暫定的な~message~header</a>
として登録する。
◎
This section registers Timing-Allow-Origin as a Provisional Message Header.
</p>

<ul>
	<li>
~header~field名：
`Timing-Allow-Origin^h
◎
Header field name:
Timing-Allow-Origin
</li>
	<li>
適用-可能な~protocol：
http
◎
Applicable protocol:
http
</li>
	<li>
位置付け：
暫定的
◎
Status:
provisional
</li>
	<li>
Author/Change controller：
<a href="https://www.w3.org/">W3C</a>
◎
Author/Change controller:
W3C
</li>
	<li>
仕様~文書：
<a href="#sec-timing-allow-origin">`Timing-Allow-Origin^h 応答~header</a>
◎
Specification document:
4.5.1 Timing-Allow-Origin Response Header
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="sec-process">
<h2 title="Process">5. 処理過程</h2>

		<section id="processing-model">
<h3 title="Processing Model">5.1. 処理~model</h3>

<p>
`PerformanceResourceTiming$I ~interfaceに定義される各種 計時~属性を次の図式に示す。
括弧内の属性は、資源が`非同一-生成元$から`~fetch$されている下では，可用でない。
~UAは、規範的でない時区間を許容するために，各 計時の合間に内部~処理を行ってもよい。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis may not be available when fetching resources from different origins. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure><figcaption>
各種 計時~属性を示す図式（時間は下に向かって進行する）。
括弧内の属性は、資源が`計時~許可検査$に失敗した場合は，可用でなくされ得ることを指示する。
【この訳では、原文の図式（ SVG ）を HTML + CSS による等価な図式に差し替えている。】
◎
Figure 1 This figure illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes in parenthesis indicate that they may not be available if the resource does not pass the timing allow check algorithm.
</figcaption>

<div id="_time-table">

	<div>
<div style="top:-0.5em">← `startTime$m ／  ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← `fetchStart$m</div>
~app~cache
	</div>
	<div>
<div style="top:-0.5em">← ( `domainLookupStart$m )</div>
DNS
<div style="bottom:-0.5em">← ( `domainLookupEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← ( `connectStart$m )</div>
<div style="top:0.5em">← ( `secureConnectionStart$m )</div>
TCP
<div style="bottom:-0.5em">← ( `connectEnd$m )</div>
	</div>
	<div style="margin-bottom:0">
<div style="top:-0.5em">← ( `requestStart$m )</div>
要請
	</div>
	<div style="margin-top:0">
<div style="top:-0.5em">← ( `responseStart$m )</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>
</div>
<!-- 
timestamp-diagram.svg
-->
</figure>

<p>
~NULL でない`~client$rqからの`要請$ %要請 により`~fetch$された
~EACH ( 資源 ) に対し，以下を遂行する：
◎
For each resource whose Request has a non-null client, perform the following steps:
</p>

<ol>
	<li>
<p>
~IF［
資源は
`no-cors^i ~policyの下で~fetchされる
非同一-生成元~stylesheetである
］
⇒
~CONTINUE
◎
↑</p>

<p class="issue">
この非同一-生成元の除外は、
Fetch registry を介して定義されるべきである：
CSS については、 Fetch の用語, および［
no-CORS CSS 下位資源に対し
何らかの “不透明な要請~flag” のような類の~flagを ~ON にすること
］を通して定義される必要がある。
しかる後、 Resource Timing において，資源~fetch~eventを表面化させるために
Fetch registry と~interfaceするべきである。
◎
Above cross-origin exclusion should be defined via Fetch registry: CSS needs to be defined in terms of Fetch and set some kind of "opaque request flag" for no-CORS CSS subresources. In turn, Resource Timing should interface with Fetch registry to surface resource fetch events.
</p>

<p class="note">注記：
上の資源~除外は、~risk下にある
— 現時点では、
<a href="https://wpt.fyi/results/resource-timing/no-entries-for-cross-origin-css-fetched.sub.html?label=experimental">関係する~test</a>
に合格した実装は一つしかないので。
◎
The above resource exclusion is at risk as currently only one implementation passes the related test.
</p>

	</li>
	<li>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 は［
<a href="~HEembed#process-the-iframe-attributes">`iframe^e の属性を処理する</a> ／
<a href="~HTMLLS/obsolete.html#process-the-frame-attributes">`frame^e の属性を処理する</a>
］ことにより誘発されたものでない
］
⇒
~RET
◎
If the resource's Request's destination equals to "document", and the Request was not triggered by process the iframe attributes or process the frame attributes, abort the remaining steps.
</li>
	<li>
<p>
`~obj作成@i：
</p>
		<ol>
			<li>
%object ~SET 新たな `PerformanceResourceTiming$I ~obj
◎
↓</li>
			<li>
%object の `entryType$m ~SET `resource^l
◎
Create a new PerformanceResourceTiming object and set entryType to the DOMString resource.
</li>
			<li>
資源の検索取得を~queueする直前に
⇒＃
%object の `startTime$m ~SET `現-時刻$；
%object の `nextHopProtocol$m ~SET 空~文字列
◎
Immediately before the user agent starts to queue the resource for retrieval, record the current time in startTime, and set nextHopProtocol to the empty DOMString.
</li>
			<li>
%object の `initiatorType$m ~SET 資源の起動元
◎
Record the initiator of the resource in initiatorType.
</li>
			<li>
%object の `name$m ~SET 要請した資源の`解決-済み~URL$
◎
↓</li>
			<li>
<p>
~IF［
現在の［
`閲覧文脈$ ／ ~worker文脈
］に`合致する作動中の~worker$ %worker は在る
`service-workers-1$r
］：
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
%worker に向けて`名前~fetch_evの~eventを発火する$直前に
⇒
%object の `workerStart$m ~SET `現-時刻$
</li>
					<li>
~ELSE
⇒
%worker を`走らす$直前に
⇒
%object の `workerStart$m ~SET `現-時刻$
</li>
				</ol>
<!-- ＊
~link先が変？ run a worker ？
 -->
◎
Record the resolved URL of the requested resource in name. If there is an active worker ([service-workers-1]) matching the current browsing or worker context's, immediately before the user agent runs the worker record the time as workerStart, or if the worker is already available, immediately before the event named `fetch` is fired at the active worker record the time as workerStart. Otherwise, if there is no matching service worker registration, set workerStart value to zero.
</li>
			<li>
~ELSE（合致する`~service~worker登録$は無い）
⇒
%object の `workerStart$m ~SET 0
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
`~fetch開始@i
— `~fetching$を開始する直前に：
</p>
		<ol>
			<li>
%fetchStart ~LET `現-時刻$
</li>
			<li>
%object の `fetchStart$m ~SET %fetchStart
</li>
			<li>
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］ ~SET %fetchStart
</li>
		</ol>

◎
Immediately before a user agent starts the fetching process, record the current time as fetchStart. Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
	<li>
<p>
`収集~開始@i：
</p>
		<ol>
			<li>
~IF［
別の既存の~data, あるいは すでに完了した［
`現-文書$から起動された`~fetch$
］による~dataを再利用する
］
⇒
~RET
◎
If the user agent is to reuse the data from another existing or completed fetch initiated from the current document, abort the remaining steps.
</li>
			<li>
<p>
~IF［
要請~連鎖（~redirectを含む）を成す ある資源`~fetch$は，`計時~許可検査$に失敗した
］：
</p>
				<ol>
					<li>
%object の［
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m
］ ~SET 0
</li>
					<li>
~GOTO `応答~終了0$i
</li>
				</ol>

◎
If any request in the resource fetch's request-chain (including redirects) fails the timing allow check algorithm, the user agent MUST set redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart and secureConnectionStart to zero and go to step 16.
</li>
			<li>
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］ ~SET %fetchStart
◎
Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
			<li>
~IF［
資源は`局所~cache等$（ `~HTTP~cache$ `RFC7234$r も含む）から~fetchされている
］
⇒
~GOTO `要請~開始$i
◎
If the resource is fetched from the relevant application cache or local resources, including the HTTP cache [RFC7234], go to step 14.
</li>
			<li>
~IF［
~domain検索は要求されていない
］
⇒
~GOTO `接続-開始$i
◎
↓</li>
			<li>
~domain名~検索を開始する直前に
⇒
%object の `domainLookupStart$m ~SET `現-時刻$
◎
If no domain lookup is required, go to step 14. Otherwise, immediately before a user agent starts the domain name lookup, record the time as domainLookupStart.
</li>
			<li>
<p>
~domain名~検索を終えた直後に（~UAは、その前に複数の再試行を要し得る）：
</p>
				<ol>
					<li>
~IF［
検索に成功した
］~OR［
資源は `計時~許可検査$に合格した
］
⇒
%object の `domainLookupEnd$m ~SET `現-時刻$
</li>
					<li>
~IF［
検索に失敗した
］
⇒
~GOTO `最終~記録-$i
</li>
				</ol>
◎
Record the time as domainLookupEnd immediately after the domain name lookup is successfully done. A user agent may need multiple retries before that. If the domain name lookup fails and resource passes the timing allow check record the time as domainLookupEnd and go to step 17.
</li>
		</ol>
	</li>
	<li>
<p>
`接続-開始@i：
</p>
		<ol>
			<li>
~IF［
資源`~fetch$に持続的~transport接続が利用されている
］
⇒
%object の［
`connectStart$m, `connectEnd$m
］ ~SET %object の `domainLookupEnd$m と同じ値
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
~serverへの接続を起動する直前に
⇒
%object の `connectStart$m ~SET `現-時刻$
</li>
					<li>
<p>
接続の成否が確定した時点で：
</p>
						<ol>
							<li>
~IF［
~serverまたは~proxyへ接続を確立できなかった
］
⇒＃
%object の `connectEnd$m ~SET `現-時刻$；
~GOTO `最終~記録-$i
</li>
							<li>
%object の `connectEnd$m ~SET `現-時刻$（~UAは、接続を確立するために複数回の再試行を要し得るが，成功した接続の時刻印のみを反映するべきである）
</li>
							<li>
%object の `nextHopProtocol$m ~SET 接続に利用されている~ALPN~ID
</li>
						</ol>
					</li>
				</ol>
◎
If a persistent transport connection is used to fetch the resource, let connectStart and connectEnd be the same value of domainLookupEnd. Otherwise, record the time as connectStart immediately before initiating a successful connection to the server and record the time as connectEnd immediately after the successful connection to the server or proxy is established. A user agent may need multiple retries to establish a successful connection and should reflect the timestamps for the successful connection only. Once connection is established set the value of nextHopProtocol to the ALPN ID used by the connection. If a connection can not be established, record the time up to the connection failure as connectEnd and go to step 17.
</li>
			<li>
~IF［
~secure~transportが利用されている
］
⇒
接続を~secureにする~handshake処理-の直前に
⇒
%object の `secureConnectionStart$m ~SET `現-時刻$
◎
The user agent MUST set the secureConnectionStart attribute as follows:
◎
When a secure transport is used, the user agent MUST record the time as secureConnectionStart immediately before the handshake process to secure the connection.
</li>
			<li>
~ELSE
⇒
%object の `secureConnectionStart$m ~SET 0
◎
When a secure transport is not used, the user agent MUST set the value of secureConnectionStart to 0.
</li>
		</ol>
	</li>
	<li>
<p>
`要請~開始@i
⇒
資源~用に要請の送信†を開始する直前に
（†要請を送信するために複数回の再試行を要した場合は、最後に試行したときの）
⇒
%object の `requestStart$m ~SET `現-時刻$
◎
Immediately before a user agent starts sending the request for the resource, record the current time as requestStart. If a user agent needed multiple retries to send the request, record the current time of the last attempt.
</p>

<p class="note">注記：
~network~protocolは、［
接続の確立, ~secureな接続の確立, 要請の送信
］を逐次的な方式で遂行しないこともある。
したがって開発者は、これらの値が常に特定0の順序になると期待するべきでない。
【そうであっても、この~algo自体は，記された順に進行するものと解釈するべきであろう — さもなければ ~GOTO などの~logicがきちんと定義されなくなるので。】
◎
Network protocols may not perform the connection establishment, secure connection establishment and request sending in a sequential manner. Therefore, developers should not expect these values to always be in a particular order.
</p>
	</li>
	<li>
`応答~開始@i
⇒
応答の最初の~byteを受信した直後に
⇒
%object の `responseStart$m ~SET `現-時刻$
◎
Record the time as responseStart immediately after the user agent receives the first byte of the response.
</li>
	<li>
<p>
`応答~終了0@i：
</p>
		<ol>
			<li>
<p>
~IF［
要請の送信-, または応答~全体の受信-に失敗したため，接続を~openし直す必要がある
］
⇒
~GOTO `接続-開始$i
◎
Record the time as responseEnd immediately after receiving the last byte of the response.↓
◎
Return to step 12 if the user agent fails to send the request or receive the entire response, and needs to reopen the connection.
</p>

<p class="example">
例えば，`持続的~接続$ `RFC7230$r が可能化されているときは、まず最初に，要請を送信するための~open接続の再利用を（その接続は`非同期に~close$され得るが）試行してよい。
そのような場合、［
`connectStart$m,
`connectEnd$m,
`requestStart$m
］は，~openし直した接続において収集された計時~情報を表現するべきである。
◎
When persistent connection [RFC7230] is enabled, a user agent may first try to re-use an open connect to send the request while the connection can be asynchronously closed. In such case, connectStart, connectEnd and requestStart should represent timing information collected over the re-open connection.
</p>
			</li>
			<li>
応答の最後の~byteを受信した直後に
⇒
%object の `responseEnd$m ~SET `現-時刻$
◎
↑</li>
			<li>
%object の［
`transferSize$m,
`encodedBodySize$m, 
`decodedBodySize$m
］ ~SET それぞれの属性の定義に従う値
— これらは、`計時~許可検査$の対象になる。
◎
Set the value of transferSize, encodedBodySize, decodedBodySize to corresponding values, subject to timing allow check algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
`最終~記録-@i：
</p>
		<ol>
			<li>
~IF［
%object の `responseEnd$m はまだ設定されていない
］
⇒
%object の `responseEnd$m ~SET `現-時刻$
</li>
			<li>
%object の `duration$m ~SET
( %object の `responseEnd$m ) − ( %object の `startTime$m )
</li>
		</ol>
◎
If responseEnd is not set, set it to the current time. Record the difference between responseEnd and startTime in duration.
</li>
	<li>
<p>
~IF［
資源が~fetchされた結果が`~redirect等$になった
］：
◎
If the fetched resource results in an HTTP redirect or equivalent, then
</p>

		<ol style="list-style-type:lower-alpha;">
			<li>
%新たな資源 ~SET ~redirect先の資源
◎
↓</li>
			<li>
~IF［
現在の資源, %新たな資源 の両者とも［［
`現-文書$と`同一-生成元$から来ていない
］~AND［
`計時~許可検査$に失敗した
］］］
⇒
%object の［
`redirectStart$m, `redirectEnd$m
］~SET 0
◎
If the current resource and the redirected resource are not from the same origin as the current document, and the timing allow check algorithm fails for either resource, set redirectStart and redirectEnd to 0. Then, return to step 5 with the new resource.
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
~IF［
%object の `redirectStart$m の値はまだ設定されていない
］
⇒
%object の `redirectStart$m ~SET %fetchStart
◎
If the value of redirectStart is not set, let it be the value of fetchStart.
</li>
					<li>
%object の `redirectEnd$m ~SET %object の `responseEnd$m の値
◎
Let redirectEnd be the value of responseEnd.
</li>
					<li>
［［
`startTime$m,
`redirectStart$m,
`redirectEnd$m,
`initiatorType$m
］を除く，
%object のすべての属性
］ ~SET 0 
◎
Set all the attributes in the PerformanceResourceTiming object to 0 except startTime, redirectStart, redirectEnd, and initiatorType.
</li>
				</ol>
			</li>
			<li>
資源 ~SET %新たな資源
◎
↓</li>
			<li>
~GOTO `~fetch開始$i
◎
Return to step 5 with the new resource.
</li>
		</ol>
	</li>
	<li id="dfn-step-final-queue">
`処理能~entryを~queueする$( %object )
◎
Queue the PerformanceResourceTiming object.
</li>
	<li>
`処理能~entry~bufferに~entryを追加する$( %要請 の`~client$rqの`大域~obj$の`処理能~entry~buffer$, %object )
◎
Add the PerformanceResourceTiming object to the Request's client's global object's performance entry buffer.
</li>
</ol>

<p class="issue">
~entryが いつ`処理能~entry~buffer$に追加されるかを明確化する。
<!--  20, 21 ＊？ -->
この仕様は、［
最後の 2 つの段を，資源の `load^et ~eventが生じる前後のどちらに走らすべきか
］は，指定しない。
関係する論点は
<a href="https://github.com/w3c/resource-timing/issues/82">issue 82</a>
を見よ。
◎
Issue 82: Clarify when entry is added to performance entry buffer
◎
This specification does not specify whether steps 20 and 21 should run before or after the load event of the resource—see issue 82 for related discussion.
◎
Issue 82: Clarify when entry is added to performance entry buffer
</p>

		</section>
		<section id="sec-monotonic-clock">
<h3 title="Monotonic Clock">5.2. 単調増加~clock</h3>
<p>
計時~属性の値は、資源`~fetch$の間，計時~属性が~system~clock調整により~skewされないように、単調増加するモノトスル。
時系列順に記録された２つの計時~属性の差分は決して負にならないモノトスル。
文書の下位~資源も含めた，すべての資源において、~UAは根元の文書~naviの開始時点の~system~clockを記録し，後続の計時~属性は、~naviの開始からの経過時間を測定する単調増加~clockの下で定義されるモノトスル。
◎
The value of the timing attributes MUST monotonically increase to ensure timing attributes are not skewed by adjustments to the system clock while fetching the resource. The difference between any two chronologically recorded timing attributes MUST never be negative. For all resources, including subdocument resources, the user agent MUST record the system clock at the beginning of the root document navigation and define subsequent timing attributes in terms of a monotonic clock measuring time elapsed from the beginning of the navigation.
</p>

		</section>
	</section>
	<section id="sec-privacy-security">
<h2 title="Privacy and Security">6. ~privacyと~security</h2>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I
~interfaceは、資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、既定では`同一-生成元$~policyが施行される。
その結果，一部の属性は、
<a href="#sec-cross-origin-resources">非同一-生成元~資源</a>
節にて述べたように， 0 に設定される。
資源を供する側は、 `Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定することにより，資源~用のすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in 4.5 Cross-origin Resources. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

<p>
統計的指紋収集（ `statistical fingerprinting^en ）は、悪意的な~web~siteが、第三者~web~site内の資源に対する~cacheの~hit／~missの時機を測定することにより、利用者が第三者~web~siteを訪問したかどうかを決定し得る点で、~privacyに関わる問題になる。
`PerformanceResourceTiming$I
~interfaceは，文書~内の資源の計時~情報を供するが、
<a href="#sec-cross-origin-resources">非同一-生成元の制約</a>
があるため、この~privacyの懸念を，［
今日すでにある，資源に対する `load^et ~eventから時機を測定して~cacheの~hit／~missを決定する手法
］より，悪化させるものにはならない。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the cross-origin restrictions prevent making this privacy concern any worse than it is today using the load event on resources to measure timing to determine cache hits and misses.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に協力された次の方々に謝意を：
</p>

<p lang="en-x-a0">
Thanks to
  Anne Van Kesteren,
  Annie Sullivan,
  Arvind Jain,
  Boris Zbarsky,
  Darin Fisher,
  Jason Weber,
  Jonas Sicking,
  James Simonsen,
  Karen Anderson,
  Kyle Scholz,
  Nic Jansma,
  Philippe Le Hegaret,
  Sigbjørn Vik,
  Steve Souders,
  Todd Reifsteck,
  Tony Gentilcore and
  William Chan
for their contributions to this work.
</p>

	</section>

</main></div>
