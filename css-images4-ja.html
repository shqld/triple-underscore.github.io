<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Images Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>

#_dgm-efunc2 {
	position: relative;
	overflow: hidden;
	width: 24em;
	padding: 1.5em;
}

._ex-efunc-src {
	position: absolute;
	top: 0;
	left: 0;
	width: 12em;
	height: 3em;
	color: white;
	background: lime;
}
#_ex-efunc-dst {
	position: relative;
	color: black;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	const source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't': // typedef
	text = `&lt;${key}&gt;`;
	break;
case 'vt': // css values
	text = `&lt;${key}&gt;`;
	break;
case 'f': // funcdef
	text = `${key}()`;
	break;
case 'ft': // funcdef
	text = `&lt;<code class="func">${key}()</code>&gt;`;
	klass='f';
	break;
case 'P': // token
	text = `&lt;${key}&gt;`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Images Module Level 4
spec_date:2019-04-15
trans_update:2019-04-20
source_checked:180705
page_state_key:CSS
original_url:https://drafts.csswg.org/css-images-4/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:paint,css
conformance:css
copyright:2019,permissive
trans_1st_pub:2017-04-24


●●class_map
p:property
f:func
t:type
u:unit
vt:type
ft:type
v:value
P:production
css:css
e:element
a:attr
et:event-type

●●tag_map
p:code
t:var
vt:var
ft:var
css:code
f:code
d:code
c:code
e:code
a:code
u:code
f:code
v:code
I:code
m:code
et:code
P:var
V:var
i:i

●●original_id_map


●●link_map



I.CSS:~CSSOM1#namespacedef-css
SameObject:~WEBIDL#SameObject
m.elementSources:#dom-css-elementsources

a.dir:~HTMLdom#the-dir-attribute
e.canvas:~HEcanvas#the-canvas-element
e.p:~HEgrouping#the-p-element
e.img:~HEimages#the-img-element
e.video:~HEmedia#the-video-element
e.iframe:~HEembed#the-iframe-element
e.picture:~HEimages#the-picture-element
	e.ul
	e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.defs:~SVG11/struct.html#DefsElement
e.linearGradient:~SVG11/pservers.html#LinearGradientElement
e.radialGradient:~SVG11/pservers.html#RadialGradientElement
e.pattern:~SVG11/pservers.html#PatternElement
e.use:~SVG11/struct.html#UseElement

	et.click
p.object-fit:#propdef-object-fit

p.image-resolution:#propdef-image-resolution
p.background-image:~CSSBG#propdef-background-image
p.background-position:~CSSBG#propdef-background-position
p.background-color:~CSSBG#propdef-background-color
p.background-size:~CSSBG#propdef-background-size
p.cursor:~CSSUI#propdef-cursor
p.direction:~CSSWM#propdef-direction
	~CSS2VISUREN#propdef-direction
p.list-style-image:~CSSWG/css-lists-3/#propdef-list-style-image

v.snap:#valdef-image-resolution-snap
v.from-image:#valdef-image-resolution-from-image
v.transparent:~CSSCOLOR#valdef-color-transparent

v.contain:#valdef-object-fit-contain
v.cover:#valdef-object-fit-cover
v.fill:#valdef-object-fit-fill
v.none:#valdef-object-fit-none
v.scale-down:#valdef-object-fit-scale-down

v.circle:~CSSIMAGE#valdef-ending-shape-circle
v.ellipse:~CSSIMAGE#valdef-ending-shape-ellipse

t.angular-color-hint:#typedef-angular-color-hint
t.angular-color-stop-list:#typedef-angular-color-stop-list
t.angular-color-stop:#typedef-angular-color-stop
t.angular-color-stop:#typedef-angular-color-stop

t.color-stop-angle:#typedef-color-stop-angle
t.color-stop-length:#typedef-color-stop-length
t.color-stop-list:#typedef-color-stop-list
t.color-stop:#typedef-color-stop
t.gradient:#typedef-gradient
t.image-set-option:#typedef-image-set-option
t.image-src:#typedef-image-src
t.image-tags:#typedef-image-tags
t.image:#typedef-image
t.linear-color-hint:#typedef-linear-color-hint
t.linear-color-stop:#typedef-linear-color-stop

t.color:~CSSCOLOR#typedef-color
	~CSSWG/css-color-3/#valuea-def-color
t.id-selector:~SELECTORS4#typedef-id-selector

t.angle-percentage:~CSSVAL#typedef-angle-percentage
t.angle:~CSSVAL#angle-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.position:~CSSVAL#typedef-position
t.string:~CSSVAL#string-value
t.url:~CSSVAL#url-value
t.angle:~CSSVAL#angle-value
t.custom-ident:~CSSVAL#identifier-value
t.length:~CSSVAL#length-value
t.position:~CSSVAL#typedef-position
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.url:~CSSVAL#url-value
t.percentage:~CSSVAL#percentage-value

t.cf-image:#typedef-cf-image
t.ending-shape:~CSSIMAGE#valdef-radial-gradient-ending-shape

f.linear-gradient:~CSSIMAGE#funcdef-linear-gradient
f.radial-gradient:~CSSIMAGE#funcdef-radial-gradient
f.repeating-linear-gradient:~CSSIMAGE#funcdef-repeating-linear-gradient

f.cross-fade:#funcdef-cross-fade
f.image-set:#funcdef-image-set
f.url:~CSSVAL#funcdef-url
f.conic-gradient:#funcdef-conic-gradient
f.element:#funcdef-element
f.image:#funcdef-image

	f.repeating-conic-gradient:#funcdef-repeating-conic-gradient
	f.repeating-linear-gradient:#funcdef-repeating-linear-gradient
	f.repeating-radial-gradient:#funcdef-repeating-radial-gradient
	tv.angle:#valdef-conic-gradient-angle
	tv.position:#valdef-conic-gradient-position
	tv.resolution:#valdef-image-resolution-resolution

u.px:~CSSVAL#px


	●用語

勾配~box:#gradient-box
勾配~中心:#conic-gradient-gradient-center
勾配~線:#gradient-line
画像~解像度:#image-resolution
内在的~解像度:#intrinsic-resolution
無効な画像:#invalid-image
描画され:#element-not-rendered
塗り~source:#paint-source

内在的~寸法を決定する:#intrinsic-dimensions-of-a-cross-fade
外観を決定する:#appearance-of-a-cross-fade


~fallback色を伴う~URL:#image-notation
装飾限界~box:#decorated-bounding-box

始点:#starting-point
終点:#ending-point

	§勾配~notation:#gradients
	§~image~notation:#image-notation
	§Solid-color Images:#color-images
	＊rendering of another element in the document:#element-notation
	＊repeating gradients:#repeating-gradients

塗り~source:#paint-source

円錐型~勾配:#conic-gradients
色~補間~hint:#color-interpolation-hint
色停:#color-stop
色停~list:#color-stop-list

	＊two location syntax:#color-stop-syntax
	＊color interpolation hints:#color-stop-syntax

	●用語（L3
終形:~CSSIMAGE#ending-shape
中心:~CSSIMAGE#radial-gradient-gradient-center
線型~勾配:~CSSIMAGE#linear-gradients
放射型~勾配:~CSSIMAGE#radial-gradients
繰返し勾配:~CSSIMAGE#repeating-gradients
	繰返し勾配:#repeating-gradients
~url参照:~CSSIMAGE#url-notation
実obj~size:~CSSIMAGE#concrete-object-size
既定の~obj~size:~CSSIMAGE#default-object-size
内在的~寸法:~CSSIMAGE#intrinsic-dimensions
~obj~size折衝:~CSSIMAGE#object-size-negotiation

	●用語（外部
~tuple:~INFRA#tuple
~item:~INFRA#list-item
~list:~INFRA#list
付加する:~INFRA#list-append
空:~INFRA#list-is-empty


~border画像~区画:~CSSBG#border-image-area

積層~文脈:~CSS2VISUREN#stacking-context
	積層~文脈:~CSS2VISUREN#x43

媒体~素片~識別子:~TR/media-frags/#naming-space
媒体~素片:~TR/media-frags/

透明な黒:~CSSCOLOR#transparent-black

利用元~単位:~SVGcoords#TermUserUnits
	利用元~単位:~SVG11/coords.html#Units
塗り~server:~SVGpainting#TermPaintServerElement
	塗り~server:~SVG11/pservers.html
~secure~animate化~mode:~SVGconform#secure-animated-mode
	~secure~animate化~mode:~TR/svg-integration/#secure-animated-mode
~secure静的~mode:~SVGconform#secure-static-mode
	~secure静的~mode:~TR/svg-integration/#secure-static-mode

	all elements:~CSSWG/css-pseudo/#generated-content

	:~TR/2012/WD-css4-images-20120911/
	:images/sprites.svg
	<color-hint> <color-hint>:
	<color-stop> <color-stop>:

主要~box:~CSSDISP#principal-box
置換d要素:~CSSDISP#replaced-element

生成内容:~CSS22/generate.html#content

~ID選択子:~SELECTORS4#id-selector

線型~easing関数:~CSSEASING#linear-easing-function
~easing関数:~CSSEASING#easing-function



●●words_table1


●●words_table


	●幾何
2D:
1D:
寸法:dimension:~
軸:axis:~
	軸に~~平行な:axis-aligned
縦幅:height:~
横幅:width:~
原点:origin:~
四分円:quadrant:~
左端:left:~
右端:right:~
始端:start:~
回転-:rotate::回転
回転:rotation::~

区画:area::~
辺:edge::~

開始-:start:~
外側:outside:~
側:side:~
矩形:rectangle:~

裏返され:flip され:~
裏返して:flip して:~

座標系:coordinate system:~
左上隅:top left corner:~
変形-:transform:~
方位:orientation:~
方位-:orient:~
角度:angle:~
横:horizontal::~
縦:vertical::~
線:line::~
距離:distance:~
ズラし:shift し:ずらし
拡縮-:scale::~
	拡縮し直す:rescale
時計回り:clockwise::~
	反~時計回り

	●値／スカラー／比較
無限:infinite:~
	広さ無限:infinite
補間-:interpolate:~
補間:interpolation:~

単位:unit:~
利用元:user:~
	利用元~単位:user coordinate
値:value:~
丸めた:round した:~
長さ:length:~
総和:sum:~
	総和:summed together
加算-:add:~
減算-:subtract:~
計算-:calculate:~
変換-:convert:~
	変換
pair:::ペア
加重d:weighted:加重
重み:weight:~
平均:average:~
同等性:equality:~
分配-:distribute:~
平坦:flat:~
	平坦~化:flatten
空間:space:~
結合-:combine:~
入力:input:~

	切り上げ:floor
	等分にあてがわれる:divided equally between〜

	●画像／色／勾配
画像:image::~:イメージ
raster:::ラスター
	~raster化:rasterization
vector:::ベクター
解像度:resolution::~
画素:pixel::~
機器:device::~:デバイス
素片:fragment::~:フラグメント
断片:fragment::~:フラグメント
dot:::ドット
	ドット数:dots
勾配:gradient:::グラデーション
円錐型:conic::~
品質:quality:~
	高~品質:high-quality
中心:center::~
cross-fade:

	●色
色:color::~:カラー
	色~付け:colored
色停:color-stop::~:カラーストップ
単色:solid-color::~:ソリッドカラー
所在:location::~
channel:::チャネル
alpha:
透明度:transparency::~
透明:transparent::~
半透明:partially-transparent::~
黒:black:~
白い:white:~
滑らか:smooth::~
放射型:radial::~
線型:linear::~
終形:ending shape::~
混色-:blend:~
繰返し:repetition:繰り返し
繰返す:repeat する:繰り返す
繰返され:repeat され:繰り返され
繰返して:repeat して:繰り返して
繰返しな:repeat しな:繰り返しな

	●CSS layout
置換-:replace:~
置換d:replaced:置換
行内:inline::~:インライン
obj:object::オブジェクト
layout:::レイアウト
box:::ボックス
size:::サイズ
sizing:::サイズ法
slice:::スライス

	overlay
border:::ボーダー
方向:direction::~
方向性:directionality::~
	逆~方向の:opposite direction
	向きのある:directional
背景:background::~
位置:position::~
内在的:intrinsic::~
縦横比:aspect ratio::~:アスペクト比
文脈:context::~
可視:visible::~
視覚的:visual::~

包含-:contain:~
包含塊:containing block:~

実obj:concrete object::実オブジェクト
canvas:::キャンバス

生成内容:generated content::~

頁:page::ページ
頁割:pagination::ページ割り付け

装飾-:decorate::~
装飾限界:decorated bounding::~
装飾的:decorative::~
限界:bound:~

折衝:negotiation::~:ネゴシエーション

描く:draw する:~
描いた:draw した:~
描かれ:draw され:~
切抜く:clip out する:切り抜く
切抜かれ:clip out され:切り抜かれ
切取る:clip する:切り取る
切取られ:clip され:切り取られ
埋尽く:fill し尽く:埋め尽く
接合-:flush:~
	接合-:joined flush
整形:formatting:~
積層:stacking:~
分断:break:~
	分断され:broken
表示:display:~
整列-:align:~
浮動-:float:~
収める:fit させる:~

主要:principal:主

	●遷移
開始:starting:~
終止-:end:~
終止:ending:~
進捗:progress:~
進行-:progress:~
遷移-:transition:~
遷移:transition:~
所要時間:duration:~
経過時間:elapsed time:~
easing:
補間:interpolation:~
	増減:grow and then shrink
変数:variable:~
一足飛び:abrupt:~
	進行度合い how far along in

	●CSS
CSS:
animation:::アニメーション
animate:::アニメート
	~animate化:animated
prop:property::プロパティ
keyword:::キーワード
記法:notation:~
名前:name:~
適用対象:applies to:~
百分率:percentage:~

初期:initial:~
	~LET:initialized
継承-:inherit:~
指定d:specified:指定
算出d:computed:算出
使用:used:~
正準的:canonical:~
離散的:discrete:~

要素:element:~
宣言:declaration:~
	宣言-:declare:~
型:type:~
成分:component:~
属性:attribute:~
自動的:automatic:~
媒体:media::~:メディア
fallback:::フォールバック
直列化:serialization:~
	直列化-:serialize:~

子孫:descendant:~
先祖:ancestor:~
子:child:~
	子たち:children:~
選択子:selector:~::セレクタ
擬似要素:pseudo-element:~

描画-:render:~::レンダー
描画:rendering:~::レンダリング
screen:::スクリーン
紙:paper:~
言語:language:~
静的:static:~
塗り:paint:~
塗ng:painting:塗り
server:::サーバ
左横書き:LTR:~
右横書き:RTL:~
双向性:bidi:~
影:shadow::~
行0:line:行
柱:column::カラム
規則:rule:~

	●仕様
WG:
model:::モデル
algo:algorithm::アルゴリズム
UA:user agent:UA
module:::モジュール
version:::バージョン
Level:
level:::レベル
host:::ホスト
仕様:spec:~
特別:special:~
特殊:special:~
特色機能:feature:~
将来:future:~
将来の:future:~
作者:author:~
	節:section:~

適合性:conformance:~
	段:step:~
正しく:correct に:~
目的:purpose:~
通例的:usual:~
error:::エラー
明示的:explicit:~
機能性:functionality:~
能:ability:~
事例:case:~
既定:default:~
既定の:default:~
適切:appropriate:~
共通的な:common な:よくある
有意:significant:~

仕方:way:~
互換性:compatibility:~
	compat 
前方互換:forwards-compatible:~
利点:advantage:~
理由:reason:~
自立的:standalone:~
旧来:legacy:~
旧来の:legacy な:~
通常通り:as normal に:~
通常の:normal な:~
通常は:normal には:~
容易:easy:~
algo:algorithm:~
疑似的な:pseudo-:~
可用:available:~
効率的:efficient:~
無為:nonsensical:~
直に:direct に:~
	直に:directly-
直接的:direct:~
間接的:indirect:~
実際:actual:~
関連する:relevant な:~
課題:issue:~
選択肢:option:~
困難:difficult:~
要因:factor:~
適正:proper:~
状況:situation:~
解決策:solution:~
判定基準:criteria:~
汎用:generic:~
賢い:smart な:~
不完全:incomplete:~
強調:highlight:~
詳細:details:~
詳細な:detailed:~
効果:effect:~
実質的:effective:~
観念:notion:概念
複階的:complex:~
一般:general:~

	必要:need
	より詳しく述べるなら、:In specific terms,
	十分:enough
	依然として／も:still
	補助:helpful
	易くする:help
	誤ったものに:be wrong
	簡単:simple
	例:example
	~~問題なく:fine
	〜に基づいて:based
	〜に注意。:note
	おそらく:probably
	欲され:desire
	かなり:substantially
	していく:over time
	必ずしも:necessarily:~
	要約:abstract
	可能性:possibility:~
	しかしながら，:however
	節:section
	またはそれに準じるもの:some degree of
	表す:denote
	最低限:at minimum
	最大化:maximize
	どうにかして:somehow
	に対する:compared to
	に応じる:-sensitive
	応じ:care
	編集者:I
	歓迎:welcome
	多くの用途に:put to many uses
	-:we
	-:my
	必要とされ:necessary
	~~仕事:task

	●仕様（動詞
support:::サポート
実装:implementation:~
	実装-:implement:~
変更点:changes:~
拡張-:extend:~
拡張:extension:~
設計-:design:~
期待-:expect:~
解釈-:interpret:~
導入-:introduce:~
	~~考えて:try:~
要求-:require:~
	要-:require:~
挙動:behavior:ふるまい
注釈:annotation:~
保守-:maintain:~
指定-:specify:~
決定-:determine:~
依存-:depend:~
	dependent
独立:independent:~
依存関係:dependency:~
定義-:define:~
定義:definition:~
適用-:apply:~
供-:provide:~
供せる:provide できる:~
供さな:provide しな:~
影響-:affect:~
考慮点:considerations:~
働く:work する:~
働かな:work しな:~
先送り:defer:~
取組む:address する:取り組む
更新-:update:~
見なさ:consider さ:~
記述-:describe:~
述べる:describe する:~
記述:description:~
関係-:relate:~
尊守-:honor:~
見做す:assume する:~
防げる:prevent できる:~
競合-:conflict:~
意味-:mean:~
示唆:suggestion:~
依拠-:rely:~
	依拠-可能:reliable
修正-:fix:~
避ける:avoid する:~
避けた:avoid した:~
選好-:prefer:~
制約:restriction:~
利用:use:~
	利用-法
	利用して:using
再利用:reuse:~
	再利用-:re-use
利用者:user:~
取扱わな:handle しな:取り扱わな
取扱う:handle する:取り扱う
最適化-:optimize:~
代理-:proxy:~
見做して:assume して:~
見積もり:estimation:~
働く:work する:~
受容-:accept:~
改善:improvement:~
言明-:state:~
依拠-:rely:~
許容-:allow:~
考査:review:~
指示-:indicate:~
拘束-:constrain::~
拘束:constraint::~
正確:exact:~
裁定-:decide:~
	裁定-:decision
省略-:omit:~
動作-:act:~

	注記:Note:~
	-:predictable:~
	見受けられる:appears to be
	行える:can be done
	要する:requiring
	選ばれ:chosen
	見よ:see
	求まれ:want
	次に従って:as follows
	則って:according


	●未分類（動詞
誘発-:trigger:~
解決-:resolve:~
解決:resolution:~
生産-:produce:~
再生産-:reproduce:~
表現-:represent:~
	表現:representation:~
算出-:compute:~
付加-:append:~
調整-:adjust:~
	~~計算
構築-:construct:~
	あたられ:consult
作成-:create:~
無視-:ignore:~
	~~指示
挿入-:insert:~
合致-:match:~::マッチ
照合-:match:~::マッチ
印刷:print:~::プリント
印刷機:printer:~::プリンタ
処理-:process:~
処理:processing:~
参照:reference:~
参照-:refer:~
参照先の:referenced:~
参照元の:referencing:~
設定-:set:~
変化-:change:~
埋込んで:embed して:埋め込んで
読込む:load する:読み込む
読込み:load :読み込み
読込め:load でき:読み込め
復号-:decode:~::デコード
失敗-:fail:~
読める:read できる:~
	readable
符号化-:encode:~::エンコード
解せな:understand できな:~
記録-:record:~
組合わせ:combination:組み合せ
組合せる:combine する:組み合せる
組合せた:combine した:組み合せた
組合せて:combine して:組み合せて
組合され:combine され:組み合され

見出せな:find できな:~
見出して:find して:~
見出した:find した:~
見出す:find する:~
見出され:find され:~
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
	扱われ:treat され:~
追加-:add:~
追加:addition:~
追加的な:additional な:追加の
	追加された:additional

生成-:generate:~
	生成し直-:regenerate
	生成し直す場合でも、結果の:In the latter case 〜 regeneration process
複製:copy:~
反映:reflection:~
反映-:reflect:~
検出:detection:~
検出-:detect:~
検索-:look-up:~
結付けら:associate さ:結び付けら
ヤリトリ-:interact:やりとり:~
選択-:select:~
関与-:participate:~
直列化-:serialize::~:シリアル化
直列化:serialization::~:シリアル化
操作:manipulation:~
入子の:nested:入れ子の
確立-:establish:~

	先行の:preceding:~
	後続の:following:~

	変わ:vary
	等し:equal
	対応-:correspond
	探す:look for
	起こる:happen:~
	示す:show:~
	得:obtain:~
	含:include
	含めて:including:~
	指-:point
	不在:absent
	保ち続け keep track
	食い過ぎる:eats too much 
	周囲の:surrounding
	塞ぐ:slapping
	走らせ:run し:~

	●未分類
XML:
SVG:
GCPM:
ID:
HTML:
JS:Javascript
URL:
url:
interface:::インタフェース
secure:::セキュア
mode:::モード
privacy:::プライバシー
security:::セキュリティ
download:::ダウンロード
bullet:::ビュレット
tellub:::トッレュビ
pattern:::パタン
slideshow:::スライドショー
slide:::スライド
script:::スクリプト
live:
preview:::プレビュー
view:::ビュー
handler:::ハンドラ
navigate:::ナビゲート
entry:::エントリ
key:::
fancy:
map:
graph:::グラフ
妥当:valid:~
無効:invalid:~
構文:syntax:~
構文空間:syntax-space:~
文法:grammar:~
文字列:string:~
文字:character:~
命名:naming:~
文書:document:~
	文書~外:Out-Of-Document
引数:argument:~
内容:content:~
全部的:full:~
数値的:explicit:~
上書き:override:~
	上書き法:overriding
形式:format:~::フォーマット
関数:function:~
等価:equivalent:~
	一致する:identical
情報:information:~
単純:simple:~
	単純~化-:simplify／:simplifying
構造:structure:~
text:::テキスト
data:::データ
list:::リスト
item:::アイテム
tuple:::タプル
metadata:::メタデータ
資源:resource::~:リソース
source:::ソース
hint:::ヒント
bitmap:::ビットマップ
code:::コード
file:::ファイル
computer-monitor:computer monitor::コンピュータモニタ
inch:::インチ
美麗:attractive:~
見かけ:look:~
外観:appearance:~
	現れる:appear
一部分:portion:~
絶対:absolute:~
相対:relative:~
整数:integer:~
構文解析:parsing:~::パース処理
背後:behind:~
識別子:identifier:~
循環:cycle:~
循環関係:circular relationship:~
矢印:arrow:~
中間的:intermediate:~
index:
空:empty:~
再帰的:recursive:~
順序:order:~

	~~背後に回るlies beneath
	淡く染めるtinting
	画素が目立つ:pixellated
	重ねて:overlay
	一致:identical
	結果:result
	小さい:small
	通:through
	一斉に:in tandem
	X
	background-image
	against
	HTML5
	-:entirely
	Mozilla:Moz
	後続-:follow
	consist
	B
	A
	来:come

	●指示語
単独の:single:~
外部:external:~
既存の:existing:~
自前の:own:~
新たな:new:~
特定0の:particular:ある特定の
	最初の:first:~
	最初:first:~
	も:as well
	だけ:just
	様な:like
	何〜かに:across
	すなわち、:that is
	もっぱら:solely
	まったく:at all／never 〜 at all
	先頭:beginning
	先頭の:leading
	先ず:first
	何か:something
	この:this
	いくつかの:several
	そのような:such
	等々:etc
	別の:another
	多くの／数多くの:many
	すべての:all
	他の／他方:other
	前:before
	下:below
	似る:similar
	-:somewhat silly
	似た:somewhat similar
	両者:both
	1 個の:one
	その:that
	最も小さい:smallest
	同じ:same
	他所:elsewhere
	各:each
	自身:itself
	これらの:these
	それらを:them
	それらの:their
	それら:they
	 2 個の:two
	何か:something
	次の／前の:next/previous
	複数:multiple
	代わりに:instead
	主な:main
	今や:now
	-:now
	そのまま:as-is
	またがる:across
	単に:just
	数種の:handful
	あるもの／:anything
	傍:alongside
	先行の:preceding:~
	後続の:following:~
	他方:On the other hand
	残りの:remaining
	最終:final

	●

送達-:deliver:~
受信-:receive:~
送信-:send:~
mobile:::モバイル
接続:connection:~
読込む:load する:読み込む
vector:::ベクター
display:::ディスプレイ
bitmap:::ビットマップ
filesize:::ファイルサイズ
入子に:nest:入れ子に

帯域幅:bandwidth:~
次元:dimension::~
icon:::アイコン
混在して:mix されて:~
速度:speed:~
	~~選択:choice
低速:slow:~
変更:change:~
変更-:change:~
	理想的:ideal:~
	存続する:lifetime
	高
	低


●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 March 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-LISTS-3]
    Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 20 March 2014. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 22 December 2017. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 31 January 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[CSS3-TRANSFORMS]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MEDIA-FRAGS]
    Raphaël Troncy; et al. Media Fragments URI 1.0 (basic). 25 September 2012. REC. URL: https://www.w3.org/TR/media-frags/ 
[PNG]
    Tom Lane. Portable Network Graphics (PNG) Specification (Second Edition). 10 November 2003. REC. URL: https://www.w3.org/TR/PNG/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 
[SVG-INTEGRATION]
    Cameron McCormack; Doug Schepers; Dirk Schulze. SVG Integration. 17 April 2014. WD. URL: https://www.w3.org/TR/svg-integration/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 

●●ref_informative

[SMIL10]
    Philipp Hoschka. Synchronized Multimedia Integration Language (SMIL) 1.0 Specification. 15 June 1998. REC. URL: https://www.w3.org/TR/1998/REC-smil-19980615/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Images Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css4-images/

編集者草案
	https://drafts.csswg.org/css-images-4/

以前のバージョン
	https://www.w3.org/TR/2012/WD-css4-images-20120911/

最新の課題
	<a href="https://www.w3.org/Style/CSS/Tracker/products/27">Tracker</a>
	<span><a href="https://github.com/w3c/csswg-drafts/labels/css-images-4">GitHub Issues</a></span>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a class="p-name fn u-url url" href="http://lea.verou.me/about">Lea Verou</a> (Invited Expert)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/master/css-images-4/Overview.bs

</script>

</head>

<body>


<!--%resource pool -->
<div id="_persisted_parts" hidden>

<img
	id="_dgm-img_scale"
	height="160"
	alt="（ SVG 画像）"
	src="css-images/img_scale.svg"
	style="border: thin solid black;"
>

<pre class="lang-html" id="_dgm-efunc1">
&lt;style&gt;
#src {
    color: white;
    background: lime;
    width: 12em;
    height: 3em;
    position: relative;
}
#dst {
    color: black;
    background: element(#src);
    width: 20em;
    padding: 1.5em;
}
&lt;/style&gt;
&lt;p id='src'&gt;普通の要素です。&lt;/p&gt;
&lt;p id='dst'&gt;前の要素を背景に利用しています。&lt;/p&gt;
</pre>

<!-- 
I’m an ordinary element!
I’m using the previous element as my background!
 -->

<!-- element-function.png -->
<div id="_dgm-efunc2">
<div class="_ex-efunc-src" style="">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:24em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:24em;">普通の要素です。</div>
<div id="_ex-efunc-dst">前の要素を背景に利用しています。</div>
</div>

<img
	id="_dgm-sprites"
	alt="黒い部分が次第に増える 9 個の円（ SVG 画像）"
	title="[9 circles, with 0 to 8 eighths filled in]"
	src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiCgl4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCgl4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCXdpZHRoPSIzNjAiCgloZWlnaHQ9IjQwIgo+Cgo8ZGVmcz4KCTxwYXRoIGlkPSJIIiBkPSJNIDAgLTUgQSA1LDUgMCAwIDEgMCw1IHoiLz4KCTxnIGlkPSJISCI+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgZmlsbD0iYmxhY2siIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgZmlsbD0iI0NDQyIgdHJhbnNmb3JtPSJyb3RhdGUoMTgwKSIgLz4KCTwvZz4KPC9kZWZzPgoKPGcgdHJhbnNmb3JtPSJzY2FsZSg0KXRyYW5zbGF0ZSg1LDUpIiBzdHJva2U9Im5vbmUiPgoKCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDApIiBmaWxsPSIjQ0NDIiAvPgoJPC9nPgoJPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgZmlsbD0iI0NDQyIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCQk8dXNlIHhsaW5rOmhyZWY9IiNIIiB0cmFuc2Zvcm09InJvdGF0ZSg5MCkiIGZpbGw9IiNDQ0MiIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1KSIgZmlsbD0iI0NDQyIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCQk8dXNlIHhsaW5rOmhyZWY9IiNIIiB0cmFuc2Zvcm09InJvdGF0ZSg0NSkiIGZpbGw9ImJsYWNrIiAvPgoJPC9nPgoJPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1KSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTgwKSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+CjwvZz4KCjwvc3ZnPg=="
>

</div>

<header>
	<hgroup>
<h1>CSS Images Module Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この~moduleは、 `image$t 型と`置換d要素$に関係する~CSS~level 4 の特色機能を包含する。
それは、~CSS~level 2 `CSS21$r と この仕様の~level 3 `css3-images$r の機能性を含み，それを拡張する。
~level 3 からの主な拡張は、
`image$t 型に対する `image$f 記法, `element$f 記法などの追加，および
円錐型~勾配である。
◎
This module contains the features of CSS level 4 relating to the &lt;image&gt; type and replaced elements. It includes and extends the functionality of CSS level 2 [CSS21] and in the previous level of this specification [css3-images]. The main extensions compared to "CSS Images Module Level 3" [css3-images] are several additions to the &lt;image&gt; type, such as the image() notation, the element() notation, and conic gradients.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
 -->
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>


<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは~2D画像を表現するための追加的な仕方を導入する
例えば，
`~fallback色を伴う~URL$ ／
`円錐型~勾配$として ／
<a href="#element-notation">文書~内の別の要素の描画</a>として。
◎
This module introduces additional ways of representing 2D images, for example as a URL with color fallback, as conic gradients, or as the rendering of another element in the document.
</p>

	</section>
	<section id="image-values">
<h2 title="2D Image Values: the &lt;image&gt; type">2. ~2D画像~値： `image^t 型</h2>

<p>
`image$t 値~型は、~2D画像を表し，［
`~url参照$ ／
`~fallback色を伴う~URL$ ／
<a href="#gradients">勾配~記法</a>
］をとり得る。
その構文は、次で与えられる：
◎
The &lt;image&gt; value type denotes a 2D image. It can be a url reference, image notation, or gradient notation. Its syntax is:
</p>


<pre class="prod">
`image@t = `url$t | `image$ft | `image-set$ft | `cross-fade$ft | `gradient$t
</pre>


<p>
`image$t は、［
`background-image$p, `list-style-image$p, `cursor$p
］~prop
`CSS21$r
なども含め，数多くの~CSS~propにて利用できる（それらの値~内の `url$t 成分を置換する）。
◎
An &lt;image&gt; can be used in many CSS properties, including the background-image, list-style-image, cursor properties [CSS21] (where it replaces the &lt;url&gt; component in the property’s value).
</p>


<p>
一部の事例では、妥当な画像~形式でない資源を指している `url$t など，画像は無効になる。
`無効な画像@
は、内在的~寸法を伴わない，単色の `transparent$v 画像として描画される。
しかしながら， `image$f 記法などの一部の文脈~下では、`無効な画像$には特別な挙動がある。
◎
In some cases, an image is invalid, such as a &lt;url&gt; pointing to a resource that is not a valid image format. An invalid image is rendered as a solid-color transparent image with no intrinsic dimensions. However, invalid images have special behavior in some contexts, such as the image() notation.
</p>


		<section id="image-file-formats">
<h3 title="Image File Formats">2.1. 画像~file形式</h3>

<p>
~propにおいて `image$t 値から参照~される妥当な画像に対しては、~UAは，最低限，次の~file形式を~supportするモノトスル：
◎
At minimum, the UA must support the following image file formats when referenced from an &lt;image&gt; value, for all the properties in which using &lt;image&gt; is valid:
</p>

<ul>
	<li>
`PNG$r により指定される， PNG
◎
PNG, as specified in [PNG]
</li>
	<li>
`SVG11$r により指定される，`~secure静的~mode$を利用している~SVG（ `SVG-INTEGRATION$r を見よ）
◎
SVG, as specified in [SVG11], using the secure static mode (See [SVG-INTEGRATION])
</li>
	<li>
~UAが~animate化 `image$t を~supportする場合、
`SVG11$r により指定される，`~secure~animate化~mode$を利用している~SVG（
`SVG-INTEGRATION$r を見よ）
◎
If the UA supports animated &lt;image&gt;s, SVG, as specified in [SVG11], using the secure animated mode (See [SVG-INTEGRATION])
</li>
</ul>

<p>
~UAは、他の~file形式を~supportしてもヨイ。
◎
The UA may support other file formats as well.
</p>



		</section>
		<section id="url-notation">
<h3 title="Image References: the url() notation">2.2. 画像~参照： `url^f 記法</h3>

<p class="note">注記：
`css3-images$r と<a href="~CSSIMAGE#url-notation">同じ</a>。
◎
Note: No change from [css3-images].
</p>

		</section>
		<section id="image-set-notation">
<h3 title="Resolution Negotiation: the image-set() notation">2.3. 解像度の折衝： `image-set^f 記法</h3>

<p>
利用者の機器に最も適切な解像度の画像を送達することは、困難な~~仕事にもなり得る。
理想的には、画像~解像度は、利用者~間で様々な，機器それぞれの解像度と同じになるべきである。
しかしながら、どの画像を送信するか裁定する要因になるものは、他にもあり得る
— 例えば，低速な~mobile接続の下では、利用者は，解像度は適正でも，巨大になる画像を読込むのを待つより，低~解像度の画像を受信する方を選好するかもしれない。
`image-set$f 関数により、作者は，これらの課題のほとんどを無視して、単に，画像に複数の解像度を供することで，与えられた状況で最も適切なものを~UAに裁定してもらうことが可能になる。
◎
Delivering the most appropriate image resolution for a user’s device can be a difficult task. Ideally, images should be in the same resolution as the device they’re being viewed in, which can vary between users. However, other factors can factor into the decision of which image to send; for example, if the user is on a slow mobile connection, they may prefer to receive lower-res images rather than waiting for a large proper-res image to load. The image-set() function allows an author to ignore most of these issues, simply providing multiple resolutions of an image and letting the UA decide which is most appropriate in a given situation.
</p>

<p class="issue">
この解決策は、解像度が~filesizeを代理するものと見做しているので、［
複数の解像度からなる一連の~vector画像や,
一連の画像に~vectorと~rasterが混在しているとき（例えば~icon）
］を，適切に取扱わない。
例えば、高~解像度 向けには~vector画像,
低~解像度 向けには画素に最適化された~bitmap,
低~帯域幅 向けには同じ~vector画像（高~解像度であってもずっと小さいので）など。
◎
This solution assumes that resolution is a proxy for filesize, and therefore doesn’t appropriately handle multi-resolution sets of vector images, or mixing vector images with raster ones (e.g. for icons). For example, use a vector for high-res, pixel-optimized bitmap for low-res, and same vector again for low-bandwidth (because it’s much smaller, even though it’s higher resolution).
</p>

<p>
`image-set^f の構文は：
◎
The syntax for image-set() is:
</p>



<pre class="prod">
`image-set@f
    = image-set( `image-set-option$t# )
`image-set-option@t
    = [ `image$t | `string$t ] `resolution$t
</pre>

<p class="issue">
~HTMLの `picture$e 要素の機能性に合致させるため、
`w^u ／ `h^u 次元, および `format^f 関数
を追加すべき。
◎
We should add "w" and "h" dimensions as a possibility, and a "format()" function, to match the functionality of HTML’s picture.
</p>

<p>
`image-set$f 関数は、直接的にも（他の `image$t 型の引数として）間接的にも，入子にできない。
◎
The image-set() function can not be nested inside of itself, either directly or indirectly (as an argument to another &lt;image&gt; type).
</p>

<p class="issue">
この制約は必要か？
◎
Is this restriction needed?
</p>

<p>
`image-set$f の中の各 `string$t は、 `url$t を表現する。
◎
Each &lt;string&gt; inside image-set() represents a &lt;url&gt;.
</p>

<p>
`image-set$f 関数~内の各 `image-set-option$t の `resolution$t は，互いに異ならなければナラナイ
— さもなければ，関数は無効になる。
◎
Every &lt;image-set-option&gt; in a given image-set() must have a different &lt;resolution&gt;, or else the function is invalid.
</p>

<p>
~UAは、どの `image-set-option$t を読込むかについて、自身に関連する判定基準（~displayの解像度, 接続~速度, 等々）を何であれ見出して，それに基づいて選ぶモノトスル。
しかる後、 `image-set$f は，その~~選択に結び付けられている画像を表現し、その`内在的~解像度$は，その~~選択に結び付けられている解像度になる。
~UAは、頁が存続する間，与えられた `image-set$f に対し利用する `image-set-option$t を，<strong>変更してもヨイ</strong>
— 選択肢を選ぶために利用された判定基準が，~UAの見積もりにおいて変更に価する程に十分~変化したならば。
◎
UAs must make a UA-specific choice of which &lt;image-set-option&gt; to load, based on whatever criteria they find relevant (such as the resolution of the display, connection speed, etc). The image-set() then represents the image associated with the URL of that choice. The image’s intrinsic resolution is the resolution associated with that choice. UAs may change which &lt;image-set-option&gt; they wish to use for a given image-set() over the lifetime of the page, if the criteria used to determine which option to choose change significantly enough to make it worthwhile in the UA’s estimation.
</p>

<div class="example">
<p>
次の例に、 `image-set$f を用いて 3 種の画像を供する方法を示す。
“通常”, “高~解像度”, （高~品質な印刷~用の） “極高~解像度” （印刷機は <em>極めて</em> 高い解像度を持ち得るので）：
◎
This example shows how to use image-set() to provide an image in three versions: a "normal" version, a "high-res" version, and an extra-high resolution version for use in high-quality printing (as printers can have extremely high resolution):
</p>

<pre class="lang-css">
background-image: image-set(
    "foo.png" 1x, "foo-2x.png" 2x, "foo-print.png" 600dpi
);
</pre>
</div>

		</section>
		<section id="image-notation">
<h3 title="Image Fallbacks and Annotations: the image() notation">2.4. 画像~fallbackと注釈： `image^f 記法</h3>

<p>
`image$f 関数により、作者は次が可能になる：
◎
The image() function allows an author to:
</p>


<ul>
   <li>
`媒体~素片$を利用して、画像の一部分を切抜く。
◎
use media fragments to clip out a portion of an image
</li>
	<li>
単色を画像として利用する。
◎
use a solid color as an image
</li>
	<li>
指定された URL にある画像が［
~downloadできない, または復号できない
］ときの，単色~画像への~fallbackを指定する。
◎
fallback to a solid-color image, when the image at the specified url can’t be downloaded or decoded
</li>
	<li>
画像の~metadataに指定されている画像の方位に，自動的に従うようにする。
◎
automatically respect the image orientation specified in the image’s metadata
</li>
</ul>

<p>
`image$f 記法は，次で定義される：
◎
The image() notation is defined as:
</p>

<pre class="prod">
`image@f = image( `image-tags$t? [ `image-src$t? , `color$t? ]! )
`image-tags@t = [ ltr | rtl ]
`image-src@t = [ `url$t | `string$t ]
</pre>


<p>
`image$f 内で利用される `string$t は、 `url$t を表現する。
CSS における通例的な~URLと同様、
`image$f 値に指定された相対~URLは，算出d値を得るときに（ “値と単位” 仕様 `css-values-3$r に従って）絶対~URLに解決される。
◎
A &lt;string&gt; used in image() represents a &lt;url&gt;. As usual for URLs in CSS, relative URLs are resolved to an absolute URL (as described in Values &amp; Units [css-values-3]) when a specified image() value is computed.
</p>

<p>
EXIF などの画像の~metadataにて，方位が指定されている場合、~UAは，その~metadataの指定に従って，画像を回転させたり裏返して 正しく方位させるモノトスル。
◎
If the image has an orientation specified in its metadata, such as EXIF, the UA must rotate or flip the image to correctly orient it as the metadata specifies.
</p>

			</section>
			<section id="image-fallbacks">
<h4 title="Image Fallbacks">2.4.1. 画像の~fallback</h4>

<p>
`image$f に~URLと `color$t の両者が指定された下で，~URLが`無効な画像$を表現するときには、 `image$f 関数は，URL が元々指定されていなかったかのように
<a href="#color-images">単色の画像</a>
を描画する。
◎
If both a URL and a &lt;color&gt; are specified in image(), then whenever the URL represents an invalid image, the image() function renders as if the URL were not specified at all; it generates a solid-color image as specified in §2.4.3 Solid-color Images.
</p>

<div class="example">

<p>
~fallback色を利用すれば、画像の読込みに失敗したときでも，少なくとも~textは読めるようになる。
例えば次の旧来~codeは、画像が透明度を持たない矩形であれば，~~問題なく働く。
◎
The fallback color can be used to ensure that text is still readable even when the image fails to load. For example, the following legacy code works fine if the image is rectangular and has no transparency:
</p>

<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: url("dark.png") black; }
</pre>

<p>
画像が読込めなくても、背景~色により，依然として白い~textは読める。
しかしながら，画像に透明度がある場合、背後の黒が可視になり，おそらく欲されない結果になる。
`image$f 関数は、これに取組む：
◎
When the image doesn’t load, the background color is still there to ensure that the white text is readable. However, if the image has some transparency, the black will be visible behind it, which is probably not desired. The image() function addresses this:
</p>


<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: image("dark.png", black); }
</pre>


<p>
今度は、画像を読込めたときには黒はまったく現れなくなる一方、何らかの理由で画像の読込みに失敗した場合には，黒がそれに代わり，白い背景に白い~textが設定されるのを防げる。
◎
Now, the black won’t show at all if the image loads, but if for whatever reason the image fails, it’ll pop in and prevent the white text from being set against a white background.
</p>

</div>

			<section id="image-fragments">
<h4 title="Image Fragments">2.4.2. 画像~断片</h4>

<p>
`image$f に指定された~URLが，（例えば，`媒体~素片~識別子$の利用により）資源の一部分を表現するとき、その一部分は，その文脈から切抜かれた上で，自立的な画像として利用されるようになる。
◎
When a URL specified in image() represents a portion of a resource (e.g. by the use of media fragment identifiers) that portion is clipped out of its context and used as a standalone image.
</p>

<div class="example">
<p>
例えば，次の画像と~CSSが与えられたとする：
◎
For example, given the following image and CSS:
</p>

<figure>
`sprites^dgm
</figure>

<pre class="lang-css">
background-image: image('sprites.svg#xywh=80,0,40,40')
</pre>

<p>
要素の背景は、この画像の， ( 80px, 0px ) の所から，右下へ高さ幅ともに 40px の部分（画像の中では黒の四分円）で埋尽くされることになる。
◎
...the background of the element will be the portion of the image that starts at (40px,0px) and is 20px wide and tall, which is just the circle with a quarter filled in.
</p>

</div>

<p>
作者が，~CSSの前方互換な構文解析~規則の利点を活かして，画像~slice用の~fallbackを供せるようにするため、 `image$f 記法を~supportする実装は，［
`image$f を通して指定された画像
］に対する
`xywh=<var>#,#,#,#</var>^c
形による`媒体~素片~識別子$ `MEDIA-FRAGS$r を~supportする<em>モノトスル</em>。
◎
So that authors can take advantage of CSS’s forwards-compatible parsing rules to provide a fallback for image slices, implementations that support the image() notation must support the xywh=#,#,#,# form of media fragment identifiers for images specified via image(). [MEDIA-FRAGS]
</p>

<div class="example">

<p>
画像~断片は `url$f 記法でも利用し得ることに注意。
しかしながら、`媒体~素片$ 記法を解せない旧来の~UA は，素片を無視して，単純に画像~全体を表示することになる。
◎
Note that image fragments can also be used with the url() notation. However, a legacy UA that doesn’t understand the media fragments notation will ignore the fragment and simply display the entirety of the image.
</p>

<p>
`image$f 記法は~UA による`媒体~素片$の~supportを要するので、作者は，画像~素片~URLを利用する際に，~fallbackを供する CSS の前方互換な構文解析~規則の利点を活かせる：
◎
Since the image() notation requires UAs to support media fragments, authors can take advantage of CSS’s forward-compatible parsing rules to provide a fallback when using an image fragment URL:
</p>

<pre class="lang-css">
background-image: url('swirl.png'); /* 旧~UA */
background-image: image('sprites.png#xywh=10,30,60,20'); /* 新~UA */
</pre>

</div>


<p>
~URLに利用されている素片~識別子の構文が，実装が解せない, あるいはその画像~型において妥当でない場合、その~URLは，`無効な画像$を表現しているものと扱うモノトスル。
◎
If a URL uses a fragment identifier syntax that the implementation does not understand, or does not consider valid for that type of image, the URL must be treated as representing an invalid image.
</p>

<p class="note">注記：
旧来との互換性の理由から、この~errorの取扱いは，
~URL【そのもの】の定義ではなく， `image$f 【の中の~URL】に限られる。
◎
Note: This error-handling is limited to image(), and not in the definition of URL, for legacy compat reasons.
</p>



			</section>
			<section id="color-images">
<h4 title="Solid-color Images">2.4.3. 単色の画像</h4>

<p>
`image$f 関数の引数に（~URLなしで） `color$t のみが指定された場合、内在的~寸法を伴わない，指定された色による単色~画像を表現する。
◎
If the image() function is specified with only a &lt;color&gt; argument (no URL), it represents a solid-color image of the specified color with no intrinsic dimensions.
</p>

<div class="example">

<p>
例えば，これを、他の画像の上層に半透明な色を重ねて
背景~画像を “淡く染める” 簡単な方法として利用できる：
◎
For example, one can use this as a simple way to "tint" a background image, by overlaying a partially-transparent color over the top of the other image:
</p>

<pre class="lang-css">
background-image: image(rgba(0,0,255,.5)), url("bg-image.png");
</pre>


<p>
`background-color$p は、これに対しては働かない。
それが生成する単色は、常に，すべての背景~画像の<em>~~背後に回る</em>ので。
◎
background-color does not work for this, as the solid color it generates always lies beneath all the background images.
</p>

</div>


			</section>
			<section id="bidi-images">
<h4 title="Bidi-sensitive Images">2.4.4. 双向性に応じる画像</h4>

<p>
作者は、 `image$f 内の `image-src$t の前に、画像~用の方向性（ `image-tags$t ）を指定してもヨイ
— これは、~HTML要素に `dir$a 属性を追加するのに似る。
要素~上で／内で逆~方向の `direction$p を伴う画像が利用された場合、その画像は，行内~方向に裏返されるモノトスル（行内~方向が X 軸であれば，例えば `scaleX(-1)^v で変形されたかのように）。
◎
Before listing any &lt;image-src&gt;s, the author may specify a directionality for the image, similar to adding a dir attribute to an element in HTML. If a directional image is used on or in an element with opposite direction, the image must be flipped in the inline direction (as if it was transformed by, e.g., scaleX(-1), if the inline direction is the X axis).
</p>

<p class="note">注記：
この宣言が不在の場合の既定では、画像の方向性はまったくないので，周囲の要素の方向性にも応じない。
◎
Note: Absent this declaration, images default to no directionality at all, and thus don’t care about the directionality of the surrounding element.
</p>

<div class="example">

<p>
~listが，~bulletとして内容の中を指す矢印を利用していて、左横書きの~textを包含する~list~itemと, 右横書きのそれとが混在している場合、~bulletは，左端にも右端にも生じる。
その結果、一方の側では~textの中を指すよう設計された画像は、他方の側では~textの外を指すことになる。
これは、次の様な~codeで修正できる：
◎
A list may use an arrow for a bullet that points into the content. If the list can contain both LTR and RTL text, though, the bullet may be on the left or the right, and an image designed to point into the text on one side will point out of the text on the other side. This can be fixed with code like:
</p>

<pre class="lang-html">
&lt;ul style="list-style-image: image(ltr 'arrow.png');"&gt;
  &lt;li dir='ltr'&gt;左に~bulletがあります。&lt;/li&gt;
  &lt;li dir='rtl'&gt;~bulletは右にあります。&lt;/li&gt;
&lt;/ul&gt;
</pre>
<!-- 
My bullet is on the left!
MY BULLET IS ON THE RIGHT!
 -->

<p>
これは次の様に描画されるべきである：
◎
This should render something like:
</p>

<pre class="lang-html">
☞ 左に~bulletがあります。
  。すまりあに右は~tellub ☜
</pre>
<!-- 
☞ My bullet is on the left!
  !THGIR EHT NO SI TELLUB YM ⇐
-->

<p class="trans-note">【
便宜上，日本語で記しているが、実際には，右横書きの言語でなければ、このように左方へ流れる表示にはならない。
】</p>

<p>
左横書き~list~itemにおいては，画像はそのまま利用され、右横書き~list~itemにおいても内容を指すように，画像は行内~方向に裏返されることになる。
◎
In LTR list items, the image will be used as-is. In the RTL list items, however, it will be flipped in the inline direction, so it still points into the content.
</p></div>



			</section>
		</section>
		<section id="cross-fade-function">
<h3 title="Combining images: the cross-fade() notation">2.5. 画像を組合せる： `cross-fade^f 記法</h3>

<p>
~CSSにより 2 個の画像~間の遷移を与えるためには、［
開始-, 終止-
］画像を組合せた中間的な画像を明示的に指す仕方を要する。
`cross-fade$f 関数が、これを達成する。
それは、組合される 2 個の画像, および
組合わせの遷移の進行度合いを指示する。
◎
When transitioning between images, CSS requires a way to explicitly refer to the intermediate image that is a combination of the start and end images. This is accomplished with the cross-fade() function, which indicates the two images to be combined and how far along in the transition the combination is.
</p>

<p class="note">注記：
作者は、 `cross-fade$f 関数を，多くの単純な画像~操作にも利用できる
—
画像を単色で淡く染めたり，`放射型~勾配$と組合せて，頁~内の特定0の区画を強調するなど。
◎
Note: Authors can also use the cross-fade() function for many simple image manipulations, such as tinting an image with a solid color or highlighting a particular area of the page by combining an image with a radial gradient.
</p>

<p>
`cross-fade^f の構文は、次で定義される：
◎
The syntax for cross-fade() is defined as:
</p>

<pre class="prod">
`cross-fade@f = cross-fade( `cf-image$t# )
`cf-image$t = `percentage$t? &amp;&amp; [ `image$t | `color$t ]
</pre>

<p>
この関数は、 2 枚~以上の画像を組合せて生成される画像を表現する。
◎
The function represents an image generated by combining two or more images.
</p>

<p>
各~画像の `percentage$t は、その画像が他の画像と混色されたときの，含有率を表現する。
`percentage$t 値は、 `0%^v 〜 `100%^v の範囲に入らなければナラナイ
— 他の値は無効とする。
◎
The &lt;percentage&gt; represents how much of each image is retained when it is blended with the other images. The &lt;percentage&gt; must be between 0% and 100% inclusive; any other value is invalid.
</p>

<p>
百分率が省略された画像がある場合、 `100%^v から［
他の画像に指定されたすべての百分率の総和
］を減算してから `0%^v 以上に切り上げた結果が，算出d値の時点で［
省略された百分率を伴うすべての画像
］に等分にあてがわれる。
【<a href="#cross-fade-painting">実際の~algo</a>／下の注記と食い違う？】
◎
If any percentages are omitted, all the specified percentages are summed together and subtracted from 100%, the result is floored at 0%, then divided equally between all images with omitted percentages at computed-value time.
</p>

<div class="note">

<p>注記：
これは，算出d値には反映されないが、すべての引数の百分率の総和が `100%^v を超えるときは
— ［
~sizing／塗ng
］の詳細にて —
実質的に，総和が正確に `100%^v になるよう各 引数は拡縮し直される。
◎
While this is not reflected in the computed value, when all the arguments’ percentages sum to greater than 100%, the sizing/painting details effectively rescale them so that they sum to exactly 100%.
</p>

<p>
他方，総和が `100%^v 以下のときは
— ［
~sizing／塗ng
］の詳細にて —
実質的に，［
百分率が［
総和が `100%^v に等しくなるために必要とされる残りの値
］に設定され，`透明な黒$にされた `cf-image$t【！ `transparent$v 引数】
］が追加されたかの様に動作する。
◎
On the other hand, when the sum is less than 100%, the sizing/painting details effectively act like there’s an additional transparent argument, with its percentage set to the remaining value necessary to make the sum equal 100%.
</p>

</div>

<p>
`color$t が供された場合、それは “自動的”な寸法を伴う単色~画像を表現する
（それは、結果の画像の~sizingにはまったく関与しない
— 詳細は~sizing詳細~下を見よ）。
◎
If a &lt;color&gt; is provided, it represents a solid-color image with “automatic” dimensions (it doesn’t participate in the sizing of the result image at all; see details in the sizing details below).
</p>

			<section id="cross-fade-sizing">
<h4 title="cross-fade() Sizing">2.5.1. `cross-fade^f の~sizing</h4>

<p>
`cross-fade$f が表現する画像の寸法は、関数の各 `image$t 引数の寸法の加重d平均になる
— `color$t 引数には効果は無い。
それは、以下に従って計算される。
◎
The dimensions of the image represented by a cross-fade() are a weighted average of dimensions of the &lt;image&gt; arguments to the function; the &lt;color&gt; arguments have no effect. They are calculated as follows:
</p>

<p class="trans-note">【
以下に現れる百分率は、どこから得られるのか不明。
`cf-image$t を成す `percentage^t ではないはず（混色-用の重みであり，~sizeとは関係ないので）。
】</p>

<div class="algorithm">
<p>
`cross-fade$f の
`内在的~寸法を決定する@
ときは：
◎
To determine the intrinsic dimensions of a cross-fade():
</p>

<ol>
	<li>
%画像~list ~LET 新たな`~list$
◎
Let images be an empty list.
</li>
	<li>
<p>
`cross-fade$f 関数の
~EACH( `image$t 値を伴う引数 %引数 )
に対し：
◎
For each argument of the cross-fade() function with an &lt;image&gt; value:
</p>
		<ol>
			<li>
%~item ~LET
( `横幅^i, `縦幅^i, `百分率^i )
からなる`~tuple$
◎
Let item be a tuple consisting of a width, a height, and a percentage.
</li>
			<li>
%~item の ( `横幅^i, `縦幅^i ) ~SET ［
%引数 の `image$t に対し， `cross-fade$f が現れる文脈に適切に`~obj~size折衝$ ~algoを走らせた結果
］の`実obj~size$の ( 横幅, 縦幅 )
◎
Run the object size negotation algorithm for the &lt;image&gt;, as appropriate for the context in which the cross-fade() appears, and set item’s width and height to the width and height of the resulting concrete object size.
</li>
			<li>
%~item の`百分率^i ~SET %引数 の百分率
◎
Set item’s percentage to the argument’s percentage.
</li>
			<li>
%画像~list に %~item を`付加する$
【この段は、この訳による補完】
</li>
		</ol>
	</li>
	<li>
~IF［
%画像~list は`空$である
］
⇒
~RET ε （内在的~寸法は無い）
【 `既定の~obj~size$を返すべきでは？】
◎
If images is empty, return no intrinsic dimensions.
</li>
	<li>
%百分率の総和 ~LET %画像~list 内のすべての`~item$の`百分率^iの総和
◎
Let percentage sum be the sum of all the percentages of the items in images.
</li>
	<li>
%画像~list 内の
~EACH( %~item )
に対し
⇒
%~item の百分率 ~SET %~item の`百分率^i ~DIV %百分率の総和
◎
For each item in images, divide item’s percentage by percentage sum, and set item’s percentage to the result.
</li>
	<li>
~Assert：
%画像~list 内の`百分率^iの総和 ~EQ `100%^v 
◎
Assert: The percentages in images now sum to 100%.
</li>
	<li>
( %最終~横幅, %最終~縦幅 ) ~LET ( `0px^v, `0px^v )
◎
Let final width and final height be 0px.
</li>
	<li>
%画像~list 内の
~EACH( %~item )
に対し
⇒＃
%最終~横幅 ~INCBY %~item の`横幅^i ~MUL %~item の`百分率^i；
%最終~縦幅 ~INCBY %~item の`縦幅^i ~MUL %~item の`百分率^i
◎
For each item in images, multiply item’s width by item’s percentage and add the result to final width, and multiply item’s height by item’s percentage and add the result to final height.
</li>
	<li>
~RET 内在的~寸法( %最終~横幅, %最終~縦幅 )
◎
Return an intrinsic width of final width and an intrinsic height of final height.
</li>
</ol>
</div>

			</section>
			<section id="cross-fade-painting">
<h4 title="cross-fade() Painting">2.5.2. `cross-fade^f の塗ng</h4>

<p>
`cross-fade$f が表現する画像は、関数に与えられた引数たちの加重d平均であり，以下に従って計算される：
◎
The image represented by a cross-fade() is a weighted average of the input arguments to the function, calculated as follows:
</p>

<div class="algorithm">

<p>
`cross-fade^f の
`外観を決定する@
ときは：
◎
To determine the appearance of a cross-fade():
</p>

<ol>
	<li>
%画像~list ~LET 新たな`~list$
◎
Let images be an empty list.
</li>
	<li>
%~size ~LET  `内在的~寸法を決定する$を利用して `cross-fade$f 関数の`実obj~size$を見出した結果
◎
Let size be a tuple of width and height, initialized to the result of finding the concrete object size of the cross-fade() function (using the intrinsic dimensions of a cross-fade()).
</li>
	<li>
<p>
`cross-fade$f 関数の
~EACH( %引数 )
に対し：
◎
For each argument of the cross-fade() function:
</p>
		<ol>
			<li>
%~item ~LET
( `画像^i, `百分率^i )
からなる`~tuple$
◎
Let item be a tuple consisting of an image and a percentage.
</li>
			<li>
~IF［
%引数 は `image$t 値を伴う
］
⇒
%~item の`画像^i ~SET その `image^t 画像を %~size に拡縮し直した結果 
◎
If argument has an &lt;image&gt;, rescale it to size’s width and height and set item’s image to the result.＼
</li>
			<li>
~ELSE （ %引数 は `color$t 値を伴う）
⇒
%~item の`画像^i ~SET
寸法 %~size の，その `color^t の単色~画像
◎
Otherwise, argument has a &lt;color&gt;; set item’s image to a solid-color image of the &lt;color&gt;, with size’s dimensions.
</li>
			<li>
%~item の`百分率^i ~SET %引数 の百分率
【無い場合は？】
◎
Set item’s percentage to the argument’s percentage.
</li>
		</ol>
	</li>
	<li>
%百分率の総和 ~LET %画像~list を成すすべての`~item$の`百分率^iの総和
◎
Let percentage sum be the sum of all the percentages of the items in images.
</li>
	<li>
~IF［
%百分率の総和 ~LT 100%
］
⇒
%画像~list に次のようにされた`~tuple$を付加する
⇒＃
`画像^i ~SET 寸法 %~size の`透明な黒$にされた単色~画像,
`百分率^i ~SET 100% ~MINUS %百分率の総和
◎
If percentage sum is less than 100%, append a tuple to images consisting of a solid-color transparent-black image with size’s dimensions, and a percentage equal to 100% minus percentage sum.
</li>
	<li>
~ELIF［
%百分率の総和 ~GT 100%
］
⇒
%画像~list 内の
~EACH( %~item )
に対し
⇒
%~item の`百分率^i ~SET %~item の百分率 ~DIV %百分率の総和
◎
Otherwise, if percentage sum is greater than 100%, then for each item in images, divide item’s percentage by percentage sum, and set item’s percentage to the result.
</li>
	<li>
<p>
~RET 次のようにされた画像：
</p>
		<ul>
			<li>
寸法 %~size
</li>
			<li>
各 画素は［
%画像~list 内の各 %~item の`画像^iの，対応する画素
］たちに対し，
%~item の百分率を重みに用いて線型~加重d平均をとった結果
（色~channel, ~alpha~channelとも平均をとる）
</li>
		</ul>
<p>
この段の目的においては、各~画素の色は乗算済み sRGB 内で計算するモノトスル。
◎
Let final image be an image with size’s dimensions, and every pixel being the weighted linear average of the corresponding pixels of each item’s image in images, weighted according to the item’s percentage. (Average both the color channels and the alpha channel of the pixels.) For the purpose of this calculation, each pixel’s color must be in pre-multiplied sRGB.
</p>

<details class="note" open="">
	<summary>
上の演算の詳細
◎
Details on the above operation
</summary>
<div>
【未訳】
◎
This is applying an N-way Porter-Duff dissolve operation to the source images. Wikipedia defines dissolve as a stochastic operation, with the result pixels independently randomly chosen from the source images’ corresponding pixels according to their source images’ weights, but as pixels shrink to infinitely small, this converges to doing color-averaging in pre-multiplied color space.

In particular, this means that `cross-fade(white 50%, transparent 50%)` will produce a partially-transparent solid white image. (Rather than a partially-transparent gray, which is what you’d get if you averaged the opaque white and transparent black pixels in non-premultiplied space.)

As converting to pre-multiplied does entail some loss of precision, and graphics libraries may or may not support this operation natively, as per usual any method can be used so long as it achieves the specified effect.

For example, one can instead rebalance the percentages according to the alphas of each pixel, then do the color-channel averages in non-premultiplied space. E.g., to render cross-fade(rgb(255 0 0 / 1) 40%, rgb(0 255 0 / .5) 20%, rgb(0 0 255 / 0) 40%), rebalancing the percentages according to the 1 / .5 / 0 alphas would produce 40% / 10% / 0% (which renormalizes to 80% / 20% / 0%), at which point you can average the raw color channel values and end up with an rgb(204 51 0 / .5) image. (Note that the alpha channel is still averaged using the original percentages, not the rebalanced ones.)
◎
Return final image.
</div>
</details>

	</li>
</ol>

</div>

			</section>
			<section id="cross-fade-complex">
<h4 title="Simplifying Complex cross-fade()">2.5.3. 複階的な `cross-fade^f の単純~化</h4>


<p class="issue">
~WGによる解決にしたがって、画像~用に “同等性” の観念を定義し，
“同じ” 画像たちは算出d値の時点で百分率の総和をとって結合する。
◎
Per WG resolution, define a notion of "equality" for images, and combine "same" images at computed-value time, summing their percentages.
</p>

<p class="issue">
~WGによる解決にしたがって、直に入子にされた `cross-fade$f は，算出d値の時点で単に百分率を分配して平坦~化するように単純~化する
— `cross-fade(A 10%, cross-fade(B 30%, C 70%) 90%)^v は
`cross-fade(A 10%, B 27%, C 63%)^v になるように。
◎
Per WG resolution, simplify directly-nested cross-fade() at computed-value time by just distributing the percentage and flattening; cross-fade(A 10%, cross-fade(B 30%, C 70%) 90%) becomes cross-fade(A 10%, B 27%, C 63%).
</p>

			</section>
		</section>
		<section id="element-notation">
<h3 title="Using Elements as Images: the element() notation">2.6. 要素を画像として利用する： `element^f 記法</h3>

<p>
`element$f 関数により、作者は，文書~内の要素を画像として利用することが可能になる。
参照先の要素の外観が変化するに伴い、画像も変化するようになる。
これを利用すれば，例えば、~slideshowにおける次／前の~slideの~live~previewを作成したり，~fancyな勾配を生成するために `canvas$e 要素を参照~したり，背景を~animate化することさえ可能になる。
◎
The element() function allows an author to use an element in the document as an image. As the referenced element changes appearance, the image changes as well. This can be used, for example, to create live previews of the next/previous slide in a slideshow, or to reference a canvas element for a fancy generated gradient or even an animated background.
</p>


<p class="note">注記：
`element$f 関数が再生産するのは、参照先の要素の<em>外観</em>に限られ，実際の内容やその構造を再生産することはない。
作者は、装飾的な目的に限り，これを利用するべきである。
`element$f を，頁にまたがる有意な内容を伴う要素を再生産するために利用してはナラナイ
— 代わりに、単に文書の中に要素の複数の複製を挿入すること。
◎
Note: The element() function only reproduces the appearance of the referenced element, not the actual content and its structure. Authors should only use this for decorative purposes, and must not use element() to reproduce an element with significant content across the page. Instead, just insert multiple copies of the element into the document.
</p>


<p>
`element$f の構文は、次で与えられる：
◎
The syntax for element() is:
</p>

<pre class="prod">
`element@f = element( `id-selector$t )
</pre>


<p>
ここで `id-selector$t は`~ID選択子$である。
`SELECT$r
◎
where &lt;id-selector&gt; is an ID selector [SELECT].
</p>


<p class="issue">
外部~文書~内の要素（~SVGの`塗り~server$など）を参照できるようにする必要はあるか？
あるいは、この用途には `url^f を利用するだけで十分か？
◎
Do we need to be able to refer to elements in external documents (such as SVG paint servers)? Or is it enough to just use url() for this?
</p>


<p class="issue">
この名前は、 GCPM の似た関数と競合する。
これはどうにかして解決される必要がある。
◎
This name conflicts with a somewhat similar function in GCPM. This needs to be resolved somehow.
</p>


<p class="issue">
要素の “反映” を行う能が求まれる
— 要素~上の背景~画像として, または擬似要素~内で。
循環の検出を誘発するのを避けるため、これは特別に取扱われる必要がある。
◎
Want the ability to do "reflections" of an element, either as a background-image on the element or in a pseudo-element. This needs to be specially-handled to avoid triggering the cycle-detection.
</p>


<p class="issue">
`overflow^p が `paged^v にされている~view内の単独の頁にはどう取組むか？
◎
When we have overflow:paged, how can we address a single page in the view?
</p>


<p>
`element$f 関数は、その引数に与えた~IDに合致する要素を参照~する。
~IDは、先ず `elementSources$m ~map内で検索される。
見出されなかった場合，文書に対し照合され、合致した要素が複数あれば，関数は それらのうち最初の要素を参照~する。
◎
The element() function references the element matched by its argument. The ID is first looked up in the elementSources map, as described in that section. If it’s not found, it’s then matched against the document. If multiple elements are matched, the function references the first such element.
</p>


<p>
`element$f 関数により表現される画像は、要素が文書~内で可視かどうかに基づいて変わり得る：
◎
The image represented by the element() function can vary based on whether the element is visible in the document:
</p>

<dl>
	<dt>
要素は`描画され$ていて，`置換d要素$の子孫ではない, かつ`積層~文脈$を生成する場合：
◎
an element that is rendered, is not a descendant of a replaced element, and generates a stacking context 
</dt>
	<dd>
<p>
関数は、内在的~sizeが参照先の要素の
`装飾限界~box@
に等しい画像を表現する：
◎
The function represents an image with its intrinsic size equal to the decorated bounding box of the referenced element:
</p>
		<ul>
			<li>
~CSS描画~modelを利用して描画される要素に対しては、`装飾限界~box$は，`主要~box$のすべての断片の`~border画像~区画$を包含する, かつ軸に~~平行な，最も小さい矩形になる。
◎
for an element rendered using a CSS rendering model, the decorated bounding box is the smallest axis-aligned rectangle that contains the border image areas of all the fragments of the principal box
</li>
			<li>
~SVG描画~modelを利用して描画される要素に対する`装飾限界~box$は，
<a href="https://www.w3.org/TR/SVGTiny12/intro.html#TermDecoratedBoundingBox">SVGにより定義されるそれ</a>になる。
【大雑把に言えば，外形線の太さも含め，図形~全体を囲う最小の矩形】
◎
for an element rendered using the SVG rendering model, the decorated bounding box is defined by SVG
</li>
		</ul>

<p class="note">注記：
画像は，その限界の外側にあるものは既定で切取るので、~box影の様な`装飾限界~box$の外側へ拡張する装飾は，切取られることになる。
◎
Note: Because images clip anything outside their bounds by default, this means that decorations that extend outside the decorated bounding box, like box shadows, may be clipped.
</p>

	</dd>
	<dd>
画像は、広さ無限の `transparent$v ~canvas上に参照先の要素とその子孫を描画して構築され
（文書~内にあるときの~sizeと同じになる）、`装飾限界~box$の各~辺は画像の各~辺に接合されるように，位置される。
◎
The image is constructed by rendering the referenced element and its descendants (at the same size that they would be in the document) over an infinite transparent canvas, positioned so that the edges of the decorated bounding box are flush with the edges of the image.
</dd>
	<dd class="issue">
実装を効率的にするためには、要素には積層~文脈またはそれに準じるものが要求されるよう見受けられる。
全部的な積層~文脈は必要か？あるいは疑似的な積層~文脈で済むか？
それは通常の積層~文脈になる必要はあるか？あるいは `element^f に描画するときに積層~文脈として描画するだけで済むか？
◎
Requiring some degree of stacking context on the element appears to be required for an efficient implementation. Do we need a full stacking context, or just a pseudo-stacking context? Should it need to be a stacking context normally, or can we just render it as a stacking context when rendering it to element()?
</dd>
	<dd>
参照先の要素またはその先祖に変形-が適用されている場合、要素を画像として描画するときには，変形-は無視されるモノトスル。
`CSS3-TRANSFORMS$r
◎
If the referenced element has a transform applied to it or an ancestor, the transform must be ignored when rendering the element as an image. [CSS3-TRANSFORMS]
</dd>
	<dd>
参照先の要素が何~頁かに分断されている場合、要素は，頁の内容~区画が頁割~方向に接合されていたかのように表示される
— 頁の各~辺は初期~包含塊の対応する始端~辺に整列された上で。
<span class="note">
何~行0か／何~柱か
に分断されている要素は、単に`装飾限界~box$と伴に描画される
</span>
◎
If the referenced element is broken across pages, the element is displayed as if the page content areas were joined flush in the pagination direction, with pages' edges corresponding to the initial containing block’s start edge aligned. Elements broken across lines or columns are just rendered with their decorated bounding box.
</dd>
	<dd>
実装は、参照先の要素~用に生成した既存の~bitmap~dataを再利用してもヨイ。
あるいは，要素の表示-を生成し直して、当の~sizeにおける画像の品質を最大化してもヨイ（例えば、参照先の要素は~SVG素片であると検出された場合）。
生成し直す場合でも、結果の画像における~layoutは参照先の要素から変化させないモノトスル。
すなわち，画像の見かけは、~raster化の品質の違いを除き，参照先の要素と一致させるモノトスル。
◎
Implementations may either re-use existing bitmap data generated for the referenced element or regenerate the display of the element to maximize quality at the image’s size (for example, if the implementation detects that the referenced element is an SVG fragment); in the latter case, the layout of the referenced element in the image must not be changed by the regeneration process. That is, the image must look identical to the referenced element, modulo rasterization quality.
</dd>
	<dd class="example">
<p>
`p$e 要素を文書~内の他所で背景として再利用する例：
◎
As a somewhat silly example, a p element can be reused as a background elsewhere in the document:
</p>

`efunc1^dgm

<figure>
`efunc2^dgm
</figure>

	</dd>

	<dt>
要素は`描画され$ないが、`塗り~source$を供する場合：
◎
an element that is not rendered, but which provides a paint source
</dt>
	<dd>
関数は、`塗り~source$の［
内在的~size, 外観
］を伴う画像を表現する
— ~sizeと外観は、~host言語により定義される。
◎
The function represents an image with the intrinsic size and appearance of the paint source. The host language defines the size and appearance of paint sources.
</dd>
	<dd class="example">
<p>
例えば， `element$f 関数は、~HTML文書~内の ~SVG `pattern$e 要素を参照~できる：
◎
For example, the element() function can reference an SVG &lt;pattern&gt; element in an HTML document:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;svg&gt;
  &lt;defs&gt;
    &lt;pattern id='pattern1'&gt;
      &lt;path d='...'&gt;
    &lt;/pattern&gt;
  &lt;/defs&gt;
&lt;/svg&gt;
&lt;p style="background: element(#pattern1)"&gt;
<span class="comment">
ここでは~patternを背景に用いてます。
~patternが変化したり~animateされた場合、背景も更新されることになります。
◎
I’m using the pattern as a background! If the pattern is changed or animated, my background will be updated too!
</span>
&lt;/p&gt;
</pre>

<p>
~HTMLは［
`canvas$e, `img$e, `video$e
］など、塗り~sourceを供する，数種の要素を定義する。
頁~内には表示されてないが，中に何か描かれている `canvas$e を，~CSSから参照~できることを意味する：
◎
HTML also defines that a handful of elements, such as canvas, img, and video, provide a paint source. This means that CSS can, for example, reference a canvas that’s being drawn into, but not displayed in the page:
</p>


<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  var %canvas = document.querySelector('#animated-bullet');
  %canvas.width = 20; canvas.height = 20;
  drawAnimation(%canvas);
&lt;/script&gt;
&lt;canvas id='animated-bullet' style='display:none'&gt;&lt;/canvas&gt;
&lt;ul style="list-style-image: element(#animated-bullet);"&gt;
  &lt;li&gt;<span class="comment">
ここでは `canvas$e を~bulletに用いてます。
◎
I’m using the canvas as a bullet!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
ここでも。
◎
So am I!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
`canvas$e が~JSで変更される度に，すべての~bullet画像も更新されます。
◎
As the canvas is changed over time with Javascript, we’ll all update our bullet image with it!
</span>&lt;/li&gt;
&lt;/ul&gt;
</pre>

	</dd>

	<dt>
その他の場合：
◎
anything else
</dt>
	<dd>
関数は`無効な画像$を表現する。
◎
The function represents an invalid image.
</dd>
	<dd class="example">
<p>
例えば，次に挙げる `element$f の利用は、どれも透明な背景になる：
◎
For example, all of the following element() uses will result in a transparent background:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;p id='one' style="display:none; position: relative;"&gt;one&lt;/p&gt;
&lt;iframe src="http://example.com"&gt;
  &lt;p id='two' style="position: relative;"&gt;<span class="comment">
~fallback内容
◎
I’m fallback content!
</span>&lt;/p&gt;
&lt;/iframe&gt;
&lt;ul&gt;
  &lt;li style="background: element(#one);"&gt;
<span class="comment">
要素 `p id='one'^e は、 `display^p が `none^v にされていて`描画され$ないので，塗り~sourceを供さない。
◎
A display:none element isn’t rendered, and a P element doesn’t provide a paint source.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#two);"&gt;
<span class="comment">
`element^f には `iframe$e の様な`置換d要素$の子孫は利用できない。
◎
The descendants of a replaced element like an IFRAME can’t be used in element() either.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#three);"&gt;
<span class="comment">
`id^a "`three^v" の要素はないので、この背景も透明になる。
◎
There’s no element with an id of "three", so this also gets rendered as a transparent image.
</span>
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
	</dd>
</dl>

<p>
結付けられている~boxがない要素は、
`描画され@
ないとされる。
これは例えば、要素またはその ある先祖にて `display^p が `none^v にされている場合などに起こり得る。
~host言語は、要素が描画されないと見なされ得る追加的な仕方を定義してもヨイ
— 例えば，~SVGにおいては、 `defs$e 要素のどの子孫も描画されないものと見なされる。
◎
An element is not rendered if it does not have an associated box. This can happen, for example, if the element or an ancestor is display:none. Host languages may define additional ways in which an element can be considered not rendered; for example, in SVG, any descendant of a &lt;defs&gt; element is considered to be not rendered.
</p>

<div class="example">

<p>
`element$f 関数には、多くの用途がある。
例えば、~slideshowにおける次／前の~slideの~previewを示すために利用できる：
◎
The element() function can be put to many uses. For example, it can be used to show a preview of the previous or next slide in a slideshow:
</p>


<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
function navigateSlides() {
  var %currentSlide = ...;
  document.querySelector('#prev-slide').id = '';
  document.querySelector('#next-slide').id = '';
  %currentSlide.previousElementSibling.id = 'prev-slide';
  %currentSlide.nextElementSibling.id = 'next-slide';
}
&lt;/script&gt;
&lt;style&gt;
.slide {
  /* <span class="comment">
`element^f 可能になるためには、積層~文脈にする必要がある。
◎
Need to be a stacking context to be element()-able.
</span> */
  position: relative;
}
#prev-preview, #next-preview {
  position: fixed;
  ...
}
#prev-preview { background: element(#prev-slide); }
#next-preview { background: element(#next-slide); }
&lt;/style&gt;
&lt;a id='prev-preview'&gt;前の~slide&lt;/a&gt;
&lt;a id='next-preview'&gt;次の~slide&lt;/a&gt;
&lt;section class='slide'&gt;...&lt;/section&gt;
&lt;section class='slide current-slide'&gt;...&lt;/section&gt;
...
</pre>
<!-- 
Previous Slide
Next Slide
 -->

<p>
この例の `navigateSlides()^c 関数は、次の／前の~slideの `id^a を更新する
— それは、~slideの傍に浮動している小さい~box内に表示される。
`element$f 関数による~slideとはヤリトリできないので（それは単なる画像である）、~preview~box上で `click^et ~handlerを利用して頁を~navigateし易くすることもできる。
◎
In this example, the navigateSlides function updates the ids of the next and previous slides, which are then displayed in small floating boxes alongside the slides. Since you can’t interact with the slides through the element() function (it’s just an image), you could even use click handlers on the preview boxes to help navigate through the page.
</p>

</div>

			<section id="paint-sources">
<h4 title="Paint Sources">2.6.1. 塗り~source</h4>

<p>
~host言語は、何らかの要素を
`塗り~source@
を供するものとを定義してもヨイ。
塗り~sourceは、内在的~外観を持ち，［
~layoutする／描画-
］する必要なく`実obj~size$を得れるので、`描画され$ていなくとも画像として利用できる。
◎
Host languages may define that some elements provide a paint source. Paint sources have an intrinsic appearance and can obtain a concrete object size without having to do layout or rendering, and so may be used as images even when they’re not rendered.
</p>


<p>
~HTMLにおいては、［
`img$e ／ `video$e ／ `canvas$e
］要素が塗り~sourceを供する。
◎
In HTML, the img, video, and canvas elements provide paint sources.
</p>

<p>
~SVGにおいては、`塗り~server$を供する要素が，塗り~sourceを供する。
<span class="note">注記：
SVG1.1 においては，［
`linearGradient$e, `radialGradient$e, `pattern$e 
］要素が塗り~sourceを供する。
</span>
それらは，その仕様にて述べるように描かれる
— 次に定義される座標系の下で：
◎
In SVG, any element that provides a paint server provides a paint source. Note: In SVG1.1, the &lt;linearGradient&gt;, &lt;radialGradient&gt;, and &lt;pattern&gt; elements provide paint sources. They are drawn as described in the spec, with the coordinate systems defined as follows:
</p>

<dl>
	<dt>`objectBoundingBox^v</dt>
	<dd>
原点は，描かれている`実obj~size$により定義される矩形の左上隅。
寸法は，`実obj~size$と同じ。
`利用元~単位$は，`実obj~size$の横幅, 縦幅。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. A single user coordinate is the width and height of the concrete object size.
</dd>

	<dt>`userSpaceOnUse^v</dt>
	<dd>
原点は，描かれている`実obj~size$により定義される矩形の左上隅。
寸法は，`実obj~size$と同じ。
`利用元~単位$は， `px$u 単位に等価。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. User coordinates are sized equivalently to the CSS px unit.
</dd>
</dl>


<p class="note">注記：
この~moduleの将来の~versionでは、［
外部~文書~内の／
もっぱら~scriptにより作成された文書~内にまったく挿入されない
］塗り~sourceを参照する仕方を定義することが期待されている。
◎
Note: It is expected that a future version of this module will define ways to refer to paint sources in external documents, or ones that are created solely by script and never inserted into a document at all.
</p>



			</section>
			<section id="elementsources">
<h4 title="Using Out-Of-Document Sources: the ElementSources interface">2.6.2. 文書~外~sourceの利用-法： `ElementSources^I ~interface</h4>

<p>
`element$f 関数は、通常は文書の中の要素を選択するが、`塗り~source$を供する要素は，必ずしも文書~内にある必要はない。
例えば、~scriptにより 作成され, 保守され, 描かれ，文書に直に挿入されてはいない~HTML `canvas$e 要素など。
◎
The element() function normally selects elements within a document, but elements that provide a paint source don’t necessarily need to be in-document. For example, an HTML canvas element can be created, maintained, and drawn into entirely in script, with no need for it to be inserted into the document directly.
</p>


<p>
`~ID選択子$は，文書の外側にある要素は選択できないので、要素を参照する仕方が必要になる。
`elementSources$m ~map~objがこれを供する。
◎
All that’s needed is a way to refer to the element, as an ID selector cannot select elements outside of the document. The elementSources Map object provides this.
</p>


<pre class="idl">
partial namespace `CSS$I {
  [`SameObject$] readonly attribute Map `elementSources@m;
};
</pre>

<p class="issue" lang="en">
IDL namespaces don’t support attributes yet. &lt;https://github.com/w3c/csswg-drafts/issues/428&gt;
</p>

<p>
`elementSources$m ~map内の~entryのうち，次を満たすものが、 `element$f 関数にて可用になる
⇒
［
文字列を~keyとする
］~AND［
`塗り~source$を供している~objを値にとる
］
◎
Any entries in the elementSources map with a string key and a value that is an object providing a paint source are made available to the element() function.
</p>

<p>
`element$f に与えた `id-selector$t に対しては、先ず `elementSources$m ~map内で，~ID（先頭の文字 `#^c は含めない）が検索される：
◎
Whenever element() uses an &lt;id-selector&gt;, the ID’s value (without the leading # character) is first looked up in the elementSources map:
</p>

<ul>
	<li>
~IDを~keyとする~entryが見出された場合、 `element$f 関数は，~entryの値で与えられる~objが`塗り~source$を供して［
いるならば その塗り~source ／
いないならば`無効な画像$
］を表現する。
◎
If it’s found, and the object associated with it provides a paint source, the element() function represents that paint source.
◎
If it’s found, but the object associated with it doesn’t provide a paint source, the element() function represent an invalid image.
</li>
	<li>
見出されなかった場合、通常通り，文書~内を探す。
◎
If the ID isn’t found in the map at all, it’s then looked for in the document as normal.
</li>
</ul>


<p class="issue">
この`~ID選択子$の再利用は、 Mozilla の挙動に合致する。
編集者は、文法の先頭を `custom-ident$t で塞ぐのは避けたいと~~考えている
— それは構文空間を食い過ぎるので。
別の可能性として、値を言語により定義される~keywordから開始させ，
`custom-ident$t を後続させる案も考えられる
— `element(external fancy)^v  か何かの様に。
何か命名の示唆があれば歓迎する。
◎
This reuse of the ID selector matches Moz behavior. I’m trying to avoid slapping a &lt;custom-ident&gt; right in the beginning of the grammar, as that eats too much syntax-space. Another possibility, though, is to start the value with a language-defined keyword followed by a &lt;custom-ident&gt;, like element(external fancy) or something. Naming suggestions welcome.
</p>

<div class="example">

<p>
外部~canvasを用いて~fancyな背景を~animateする例：
◎
For example, fancy animating backgrounds can be done with an external canvas:
</p>

<pre class="lang-html">
&lt;script&gt;
var %bg = document.createElement('canvas');
%bg.height = 200;
%bg.width = 1000;
drawFancyBackground(%bg);
CSS.elementSources.set('fancy', %bg);
&lt;/script&gt;
&lt;style&gt;
h1 {
  background-image: element(#fancy);
}
&lt;/style&gt;
</pre>


<p>
“~fancy” ~canvasの中に何かが描かれ，~animateされるに伴い，すべての `h1^e 要素の背景も自動的かつ一斉に更新されることになる。
◎
As the "fancy" canvas is drawn into and animated, the backgrounds of all the H1 elements will automatically update in tandem.
</p>

<p>
`elementSources$m ~mapは，文書に対し`~ID選択子$を照合する前にあたられるので、文書~内に `#fancy^v に合致する要素があっても，背景は依然として `elementSources$m 値から来ることに注意。
◎
Note that the elementSources map is consulted before the document to match the ID selector, so even if there’s an element in the document that would match #fancy, the backgrounds will still predictably come from the elementSources value instead.
</p>

</div>

			</section>
			<section id="element-cycles">
<h4 title="Cycle Detection">2.6.3. 循環の検出</h4>


<p>
`element$f 関数は、無為な循環関係を生産し得る
— 自身を自前の背景に利用する要素など。
が，これらの関係性は、依存関係~graphを保ち続け, 共通的な循環~検出~algoを用いれば，容易かつ依拠-可能に検出して解決できる。
◎
The element() function can produce nonsensical circular relationships, such as an element using itself as its own background. These relationships can be easily and reliably detected and resolved, however, by keeping track of a dependency graph and using common cycle-detection algorithms.
</p>

<p>
依存関係~graphは、次に挙げる辺からなる：
◎
The dependency graph consists of edges such that:
</p>

<ul>
	<li>
どの要素も、その子たちに依存する。
◎
every element depends on its children
</li>
	<li>
要素 A 上のある~propが `element$f 関数を利用していて，要素 B を指しているならば、 A は B に依存する
◎
for any element A with a property using the element() function pointing to an element B, A depends on B
</li>
	<li>
~host言語が，要素が他の要素の描画を参照する仕方を定義しているならば、参照元の要素は参照先の要素に依存する。
例えば，~SVGにおいては、 `use$e 要素は参照先の要素に依存する。
◎
if a host language defines a way for elements to refer to the rendering of other elements, the referencing element depends on the referenced element. For example, in SVG, a &lt;use&gt; element depends on the element it referenced.
</li>
</ul>

<p>
この~graphが循環を包含する場合、その循環に関与しているどの `element$f 関数も，`無効な画像$になる。
◎
If the graph contains a cycle, any element() functions participating in the cycle are invalid images.
</p>


			</section>
		</section>
	</section>
	<section id="gradients">
<h2 title="Gradients">3. 勾配</h2>

<a id="conic-gradients"></a>
<a id="color-stop-syntax"></a>

【この節の内容は未訳。】

	</section>
	<section id="stripes">
<h2 title="1D Image Values: the stripes() notation">4. ~1D画像~値： `stripes^f 記法</h2>


<p class="issue">
<a href="https://github.com/w3c/csswg-drafts/issues/2532">WG resolution</a>
により、［
~border／外形線
］用に，~1D画像を作成する `stripes^f 関数を定義することになった。
◎
Per WG resolution, define the stripes() function which creates a 1D image for use in borders/outlines.
</p>

	</section>
	<section id="sizing">
<h2 title="Sizing Images and Objects in CSS">5. ~CSSにおける画像／~objの~sizing</h2>

		<section id="the-object-fit">
<h3 title="Sizing Objects: the object-fit property">5.1. ~objの~sizing： `object-fit^p ~prop</h3>

◎名 `object-fit@p
◎値 `fill$v | `none$v | [`contain$v | `cover$v] || `scale-down$v
◎初 `fill$v
◎適 `置換d要素$
◎継 されない
◎百 受容しない
◎算 指定された~keyword（たち）
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`object-fit$p ~propは、置換d要素の内容が，その使用［
横幅, 縦幅
］により確立される~boxに，どう収めるべきかを指定する。
◎
The object-fit property specifies how the contents of a replaced element should be fitted to the box established by its used height and width.
</p>

<p class="trans-note">【
以下、
<a href="~CSSIMAGE#the-object-fit">~level 3 の内容</a>
と同じ部分
—  “L3” と記されている箇所 —
の和訳は省略する。
】</p>

<dl class="valdef">
	<dt>`fill@v</dt>
	<dd>
L3
◎
The replaced content is sized to fill the element’s content box: the object’s concrete object size is the element’s used width and height.
</dd>

	<dt>`none@v</dt>
	<dd>
L3
◎
The replaced content is not resized to fit inside the element’s content box: determine the object’s concrete object size using the default sizing algorithm with no specified size, and a default object size equal to the replaced element’s used width and height.
</dd>


	<dt>`contain@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while fitting within the element’s content box: its concrete object size is resolved as a contain constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、内容は［
`none$v, `contain$v
］のうち，`実obj~size$が小さくなる方が指定されたかのように~sizeされる。
◎
If the scale-down flag is used, size the content as if none or contain were specified, whichever would result in a smaller concrete object size.
</dd>
	<dd class="note">注記：
`none$v, `contain$v
の両者とも内容の内在的~縦横比を保たせるので、大きさの比較は可能になる。
◎
Note: Both none and contain respect the content’s intrinsic aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`cover@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while filling the element’s entire content box: its concrete object size is resolved as a cover constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、内容は［
`none$v, `cover$v
］のうち，`実obj~size$が小さくなる方が指定されたかのように~sizeされる。
◎
If the scale-down flag is used, size the content as if none or cover were specified, whichever would result in a smaller concrete object size.
</dd>
	<dd class="note">注記：
`none$v, `cover$v 
の両者とも内容の内在的~縦横比を保たせるので、大きさの比較は可能になる。
◎
Note: Both none and cover respect the content’s intrinsic aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`scale-down@v</dt>
	<dd>
`contain scale-down^v と等価。
◎
Equivalent to contain scale-down. 
</dd>
</dl>

<p>
L3
◎
If the content does not completely fill the replaced element’s content box, the unfilled space shows the replaced element’s background. Since replaced elements always clip their contents to the content box, the content will never overflow. See the object-position property for positioning the object with respect to the content box.
</p>

<figure>`img_scale^dgm<figcaption>
<p>
L3
◎
An example showing how four of the values of object-fit cause the replaced element (blue figure) to be scaled to fit its height/width box (shown with a green background), using the initial value for object-position.＼
</p>

<p>
この事例では、図に示されていない値 `scale-down$v, および `scale-down contain^v による見かけは， `contain$v と一致し、
`scale-down cover^v による見かけは， `none$v と一致する。
◎
In this case, scale-down and scale-down contain would look identical to contain, and scale-down cover would look identical to none. 
</p>
</figcaption></figure>

<p class="note">注記：
L3
◎
Note: The object-fit property has similar semantics to the fit attribute in [SMIL10] and the &lt;meetOrSlice&gt; parameter on the preserveAspectRatio attribute in [SVG11].
</p>

<p class="note">注記：
L3
◎
Note: Per the object size negotiation algorithm, the concrete object size (or, in this case, the size of the content) does not directly scale the object itself - it is merely passed to the object as information about the size of the visible canvas. How to then draw into that size is up to the image format. In particular, raster images always scale to the given size, while SVG uses the given size as the size of the "SVG Viewport" (a term defined by SVG) and then uses the values of several attributes on the root &lt;svg&gt; element to determine how to draw itself.
</p>

		</section>
	</section>
	<section id="image-processing">
<h2 title="Image Processing">6. 画像~処理</h2>

		<section id="the-image-resolution">
<h3 title="Overriding Image Resolutions: the image-resolution property">6.1. 画像~解像度の上書き法： `image-resolution^p ~prop</h3>

<p>
`画像~解像度@
は、単位~長さあたりの画像~画素~数として定義される。
例えば、~inchあたりの画素~数。
画像~形式には、画像の解像度についての情報を記録するものもある。
この情報は、整形~処理-にあたって画像の実際の~sizeを決定する補助になり得るが、誤ったものにもなり得るので，その場合には，無視されるべきである。
~CSSの既定では、
~CSS `px$u 単位が 1 画像~画素に等しい解像度と見做すが、
`image-resolution$p ~propにより，他の解像度も利用できるようになる。
◎
The image resolution is defined as the number of image pixels per unit length, e.g., pixels per inch. Some image formats can record information about the resolution of images. This information can be helpful when determining the actual size of the image in the formatting process. However, the information can also be wrong, in which case it should be ignored. By default, CSS assumes a resolution of one image pixel per CSS px unit; however, the image-resolution property allows using some other resolution.
</p>

◎名 `image-resolution@p
◎値 [ `from-image$v || `resolution$t ] &amp;&amp; `snap$v?
◎初 `1dppx^v
◎適 すべての要素
◎継 される
◎百 受容しない
◎算 
指定された~keyword（たち） ／ 指定された `resolution$t ／ これらが成す組
— ただし， `resolution$t は `snap$v 用に調整され得る（下記を見よ）。
◎
specified keyword(s) and/or &lt;resolution&gt; (possibly adjusted for snap, see below)
◎順 文法に従う
◎ア 離散的
◎表終


<p class="issue">
`image-set$f 記法は、画像の内在的~解像度を改め得る
—
それは、この~propを設定しなくても，自動的に尊守されるのが理想的だが【？】。
これをどう~~解決すべきか？
初期~値を、
“~CSSが他を~~指示しない限り `1dppx^v とする”
を意味する `auto^v に変えるか？
`image-resolution^p は、解像度が~CSSにおける他の何かで設定された画像には効果がないようにするか？
あるいは、 `image-set$f を，それが常に何らかの方法で `1dppx^v 画像を生産するように，どうにか `wordsmith^en するか？
◎
The image-set() notation can alter the intrinsic resolution of an image, which ideally would be automatically honored without having to set this property. How should we best address this? Change the initial value to auto, meaning "1dppx, unless CSS says otherwise"? Say that image-resolution has no effect on images whose resolution was set by something else in CSS? Or somehow wordsmithing image-set() in some way such that it always produces 1dppx images somehow?
</p>

<p>
`image-resolution$p ~propは、［［
要素~内／要素~上
］で利用されるすべての~raster画像
］の`内在的~解像度$を，指定する。
それは、内容~画像（例えば，`置換d要素$や`生成内容$）にも, 装飾的な画像（ `background-image$p など）にも影響する。
画像の
`内在的~解像度@
は、画像の`内在的~寸法$を決定するために利用される。
各種 値の意味は：
◎
The image-resolution property specifies the intrinsic resolution of all raster images used in or on the element. It affects both content images (e.g. replaced elements and generated content) and decorative images (such as background-image). The intrinsic resolution of an image is used to determine the image’s intrinsic dimensions. Values have the following meanings:
</p>


<dl class="valdef">
	<dt id="valdef-image-resolution-resolution">`resolution$t</dt>
	<dd>
内在的~解像度を数値的に指定する。
この場合の 1 “~dot” は， 1 画像~画素に対応する。
◎
Specifies the intrinsic resolution explicitly. A "dot" in this case corresponds to a single image pixel.
</dd>
	<dd class="trans-note">【
すなわち、［
`css-values-3$r による
<a href="~CSSVAL#resolution">`resolution^t</a>
の定義
］に記されている “~dot” は 1 画像~画素と解釈される。
】</dd>

	<dt>`from-image@v</dt>
	<dd>
画像の内在的~解像度は、画像~形式から指定される。
画像が自前の解像度を指定していない場合、
`resolution$t が明示的に指定されていれば，それが利用され、他の場合は既定の `1dppx^v になる。
◎
The image’s intrinsic resolution is taken as that specified by the image format. If the image does not specify its own resolution, the explicitly specified resolution is used (if given), else it defaults to 1dppx.
</dd>

	<dt>`snap@v</dt>
	<dd>
この~keywordが伴われている `resolution$t は、 1 画像~画素が機器~画素の整数~倍に対応するような，最も近い値に丸めた結果に算出される。
解像度が画像からとられる【 `from-image$v が供されている】場合、内在的~解像度の使用~値は，画像~自身による解像度を同様に調整した結果になる。
◎
If the "snap" keyword is provided, the computed &lt;resolution&gt; (if any) is the specified resolution rounded to the nearest value that would map one image pixel to an integer number of device pixels. If the resolution is taken from the image, then the used intrinsic resolution is the image’s native resolution similarly adjusted.
</dd>
</dl>

<p>
SVG などの~vector形式には、内在的~解像度はない。
この~propは、~vector画像には効果がない。
◎
As vector formats such as SVG do not have an intrinsic resolution, this property has no effect on vector images.
</p>

<div class="example">

<p>
印刷機の解像度は、~computer-monitorより，かなり高いのが常なので、~screen上ではきれいな画像でも，印刷~時には画素が目立つ。
`image-resolution$p ~propを利用すれば、文書~内に高~解像度の画像を埋込んで 適切な~sizeを保守しつつ，~screen上でも紙~上でも美麗に表示できるようになる：
◎
Printers tend to have substantially higher resolution than computer monitors; due to this, an image that looks fine on the screen may look pixellated when printed out. The image-resolution property can be used to embed a high-resolution image into the document and maintain an appropriate size, ensuring attractive display both on screen and on paper:
</p>

<pre class="lang-css">
img.high-res {
  image-resolution: 300dpi;
}
</pre>


<p>
この規則の下では、 300dpi で 5 ~inch幅になるようにされた画像は，実際に 5 ~inch幅で表示されることになる。
この規則が無い下では、~CSSの既定による 1 ~inchあたり 96 画像~画素の表示になるので、画像は［
300 × 5 ÷ 96 ＝ 約 15.6
］~inch幅で表示されることになる。
◎
With this set, an image meant to be 5 inches wide at 300dpi will actually display as 5in wide; without this set, the image would display as approximately 15.6in wide since the image is 15000 image pixels across, and by default CSS displays 96 image pixels per inch.
</p>

</div>

<div class="example">

<p>
画像~形式には、自身の~data内に解像度を符号化するものもある。
次の規則は、~UAが，解像度を画像~自身から見出すように指定する
— 見出されない場合、~CSS `px$u 単位あたり 1 画像~画素に~fallbackする。
◎
Some image formats can encode the image resolution into the image data. This rule specifies that the UA should use the image resolution found in the image itself, falling back to 1 image pixel per CSS px unit.
</p>

<pre class="lang-css">
img { image-resolution: from-image }
</pre>


<p>
次の規則は、~UAが，解像度を画像~自身から見出すように指定しつつ、見出せないときは，解像度を既定の `1dppx^v でなく `300dpi^v に設定する。
◎
These rules both specify that the UA should use the image resolution found in the image itself, but if the image has no resolution, the resolution is set to 300dpi instead of the default 1dppx.
</p>


<pre class="lang-css">
img { image-resolution: from-image 300dpi }
img { image-resolution: 300dpi from-image }
</pre>

</div>

<div class="example">

<p>
次の規則は、画像~解像度を 300dpi に設定する（画像~自身の解像度は，無視される）。
◎
Using this rule, the image resolution is set to 300dpi. (The resolution in the image, if any, is ignored.)
</p>

<pre class="lang-css">
img { image-resolution: 300dpi }
</pre>


<p>
一方で，次の規則では、~screen解像度が 96dpi の下であれば，画像を解像度 288dpi で描画することになる（ 3 画像~画素が 1 機器~画素に対応する）：
◎
This rule, on the other hand, if used when the screen’s resolution is 96dpi, would instead render the image at 288dpi (so that 3 image pixels map to 1 device pixel):
</p>


<pre class="lang-css">
img { image-resolution: 300dpi snap; }
</pre>


<p>
`snap$v ~keywordは、解像度が画像から取得されるときにも利用できる：
◎
The snap keyword can also be used when the resolution is taken from the image:
</p>


<pre class="lang-css">
img { image-resolution: snap from-image; }
</pre>


<p>
画像~自身に備わる解像度が
300dpi のときには 288dpi で描画する（ 3 画像~画素が 1 機器~画素に対応する）一方で、
72dpi のときには 96dpi で描画することになる（ 1 画像~画素が 1 機器~画素に対応する）。
◎
An image declaring itself as 300dpi will, in the situation above, display at 288dpi (3 image pixels per device pixel) whereas an image declaring 72dpi will render at 96dpi (1 image pixel per device pixel).
</p>
</div>



		</section>
	</section>
	<section id="interpolation">
<h2 title="Interpolation">7. 補間</h2>

<p>
この節では、~CSSによる遷移や~animation（ CSS Transitions ／ CSS Animations ）における利用のために，［
この仕様にて定義される，新たな値~型
］の補間-法を述べる。
◎
This section describes how to interpolate between new value types defined in this specification, for use with modules such as CSS Transitions and CSS Animations.
</p>

<p>
以下の~algoにおいて，単に［
2 つの値が “補間される”, あるいは “遷移する”
］と記される所では、それ以上の詳細を言明することなく，
<a href="~TRANSITION#animatable-types" >CSS Transitions 仕様に従って補間される</a>
べきであることを意味する。
他の場合、 ~algoは，その補間の詳細な記述において，変数 %t を参照する。
これは、 0% から 100% へ進行する数値であり，遷移の［
所要時間, 経過時間, 利用されている`~easing関数$
］に基づく遷移の進捗を表現する値に設定される。
例えば、`線型~easing関数$と所要時間 1 秒の下では， 0.3 秒後の %t は 30% になる。
◎
If an algorithm below simply states that two values should be "interpolated" or "transitioned" without further details, then the value should be interpolated as described by the Transitions spec. Otherwise, the algorithm may reference a variable t in its detailed description of the interpolation. This is a number which starts at 0% and goes to 100%, and is set to a value that represents the progress through the transition, based on the duration of the transition, the elapsed time, and the timing function in use. For example, with a linear timing function and a 1s duration, after .3s t is equal to 30%.
</p>

		<section id="interpolating-images">
<h3 title="Interpolating &lt;image&gt;">7.1. `image^t の補間-法</h3>

<p>
すべての画像は補間できる
— 一部の特殊な型の画像（勾配など）は、特別な補間~規則を備えるが。
一般~語で述べるなら、画像は、 %開始-画像 の~sizeに拡縮した所から始まり， %終止-画像 の~sizeへ遷移する間に 2 つを~cross-fadeすることにより、補間される。
◎
All images can be interpolated, though some special types of images (like some gradients) have their own special interpolation rules. In general terms, images are interpolated by scaling them to the size of the start image and cross-fading the two while they transition to the size of the end image.
</p>

<p>
より詳しく述べるなら、補間における各~時点にて，画像は
<samp class="css">cross-fade( ( 100% ~MINUS %t ) %開始-画像, %終止-画像 )</samp>
に等しくされる。
◎
In specific terms, at each point in the interpolation the image is equal to cross-fade( (100% - t) start image, end image).
</p>

<p class="issue">
画像~無しから, あるいは画像~無しへ遷移するような，特殊な事例の補間-法
—
<samp class="css">`background-image^p: `url(foo)^v;</samp>
から
<samp class="css">`background-image^p: `none^v;</samp>
へ のような。
◎
Special-case interpolating to/from no image, like "background-image: url(foo);" to "background-image: none;".
</p>

		</section>
		<section id="interpolating-image-combinations">
<h3 title="Interpolating cross-fade()">7.2. `cross-fade^f の補間-法</h3>

<p>
`cross-fade$f を成す 3 成分は独立に補間される。
これは、入子の `cross-fade$f 記法にもなり得ることに注意。
◎
The three components of cross-fade() are interpolated independently. Note this may result in nested cross-fade() notations.
</p>

		</section>
		<section id="interpolating-gradients">
<h3 title="Interpolating &lt;gradient&gt;">7.3. `gradient^t の補間-法</h3>


<p class="issue">
この節は考査と改善を要する。
特に、 `linear-gradient^f の取扱いは，不完全と考えられる
—
勾配~線の［
開始~位置 〜 終止~位置の “長さ” （ 0% から 100% までの距離）
］が，同じ~animationを通じて増減しないように、数値的に特に補間すべきと見られる。
◎
This section needs review and improvement. In particular, I believe the handling of linear-gradient() is incomplete - I think we want to specifically interpolate the "length" of the gradient line (the distance between 0% and 100%) between the starting and ending positions explicitly, so it doesn’t grow and then shrink over a single animation.
</p>

<p>
勾配 画像は、~CSSによる遷移や~animationにおいて，勾配の一方から他方へ向かう~animationが滑らかになるように，直に補間し得る。
ただし、勾配の補間が許容されるためには，少数の制約がある：
◎
Gradient images can be interpolated directly in CSS transitions and animations, smoothly animating from one gradient to another. There are only a few restrictions on what gradients are allowed to be interpolated:
</p>

<ol>
	<li>
［
開始, 終止
］勾配を与える関数の型は，同じでなければナラナイ。
（例えば、 `linear-gradient$f からは、
`linear-gradient$f へは遷移できるが，
`radial-gradient$f ／ `repeating-linear-gradient$f へは遷移できない）
◎
Both the starting and ending gradient must be expressed with the same function. (For example, you can transition from a linear-gradient() to a linear-gradient(), but not from a linear-gradient() to a radial-gradient() or a repeating-linear-gradient().)
</li>
	<li>
［
開始, 終止
］勾配の `color-stop$t は同数でなければナラナイ。
この目的においては、すべての`繰返し勾配$には 無限~個の`色停$があり，互いに同数あると見なされる。
◎
Both the starting and ending gradient must have the same number of &lt;color-stop&gt;s. For this purpose, all repeating gradients are considered to have infinite color stops, and thus all repeating gradients match in this respect.
</li>
	<li>
両~勾配とも， `length$t, `percentage$t による`色停$を組合せて利用していない。
◎
Neither gradient uses a combination of &lt;length&gt; and &lt;percentage&gt; color stops.
</li>
</ol>

<p>
2 つの勾配が，上述の 3 つの拘束すべてを満たすならば、以下に述べるように補間されるモノトスル。
3 つ目の拘束だけ満たさない場合、 50% の所で一足飛びに遷移されるモノトスル（将来の仕様により他が指定されない限り）。
他の場合、汎用 `image$t に対するときと同じく， `cross-fade$f を用いて補間されるモノトスル。
◎
If the two gradients satisfy all of those constraints, they must be interpolated as described below. If they fail the third one only, they must be abruptly transitioned at 50% (unless otherwise specified by a future specification). If they fail either of the first two constraints, they must be interpolated using cross-fade() as for generic images.
</p>

<p class="note">注記：
50% の所で一足飛びに遷移させるのは，内容が~cross-fadeに依拠しないようにして、将来に，この事例~用に より賢い補間~規則を追加できるようにするためである。
◎
Note: The abrupt transition at 50% is so that content will not rely on cross-fading, and smarter interpolation rules can be added for this case in the future.
</p>

<ol>
	<li>
<p>
［
開始, 終止
］勾配の各~成分を，数値的な形に変換する：
◎
Convert both the start and end gradients to their explicit forms:
</p>
		<dl>
			<dt>
`線型~勾配$に対しては：
◎
For linear gradients:
</dt>
			<dd>
<p>【成分は方向のみ】</p>
				<ul>
					<li>
`angle$t として指定されている場合、すでに数値的な形である。
◎
If the direction is specified as an &lt;angle&gt;, it is already in its explicit form.
</li>
					<li>
<p>
他の場合【すなわち，~keyword】、まず，等価な描画を生産するような［
0 度 以上, 360 度 未満
］の範囲の `angle$t に変換する。
◎
Otherwise, change its direction to an &lt;angle&gt; in [0deg,360deg) that would produce an equivalent rendering.
</p>

<p>
加えて、［
開始, 終止
］勾配の いずれの方向も~keywordで指定されていて, かつ［
上で数値化された 2 つの角度の差の絶対値
］が 180 度より大きい場合は、小さい方の角度に 360 度を加算する。
<span class="note">
これにより、例えば［
`to left^v （ 270 度）から `to top^v （ 0 度）への遷移
］は、期待されるように，勾配を（反~時計回りに 3/4 回転ではなく，）時計回りに 1/4 回転させる。
</span>
◎
If both the start and end gradients had their direction specified with keywords, and the absolute difference between the angles their directions mapped to is greater than 180deg, add 360deg to the direction of the gradient with the smaller angle. This ensures that a transition from, for example, "to left" (270deg) to "to top" (0deg) rotates the gradient a quarter-turn clockwise, as expected, rather than rotating three-quarters of a turn counter-clockwise.
</p>
					</li>
				</ul>
			</dd>

			<dt>
`放射型~勾配$に対しては：
◎
For radial gradients:
</dt>
			<dd>
				<ul>
					<li>
【終形の】~sizeが［
2 つの `length$t または 2 つの `percentage$t
］で指定されている場合、すでに数値的であり，変換は必要ない。
<!-- ＊
“2 つの”, ”~size” — 補間の趣旨からは［
開始~勾配の終形の縦（横）~sizeと, 
終止~勾配の終形の縦（横）~size
］と解釈すべきように思えるが、そうすると次項の記述にそぐわなくなる。
 -->
◎
If the size is specified as two &lt;length&gt;s or &lt;percentage&gt;s, it is already in its explicit form.
</li>
					<li>
<p>
他の場合、2 つの~sizeは，［
等価な`終形$を生産するような `length$t の~pair
］に~~変換されるモノトスル。
</p>

<p>
加えて、 `ending-shape$t が `circle$v に指定されている場合は，それを `ellipse$v に変更する。
</p>
◎
Otherwise, the size must be changed to a pair of &lt;length&gt;s that would produce an equivalent ending-shape. If the &lt;ending-shape&gt; was specified as circle, change it to ellipse.
</li>
				</ul>

<p class="trans-note">【
勾配の`中心$（ `position$t ）も~keywordにより指定され得るが、言及されていない
— それらも同様に数値化すると見られる。
】</p>

			</dd>
		</dl>
	</li>
	<li>
<p>
勾配の各 成分と色停を，独立に補間する：
</p>

<p>
`線型~勾配$に対しては、成分は角度のみになる。
`放射型~勾配$に対しては、成分は［
中心の［
横, 縦
］位置
］, および［
【終形の】 ［
横, 縦
］方向の長さ
］からなる。
</p>
◎
Interpolate each component and color-stop of the gradients independently. For linear gradients, the only component is the angle. For radial gradients, the components are the horizontal and vertical position of the center and the horizontal and vertical axis lengths.
</li>
	<li>
<p>
`色停$を補間する：
</p>

<p>
まず、［
開始, 終止
］勾配の，各 色停を互いに対応付ける：
</p>

		<ul>
			<li>
各~色停に，指定された順により ~indexを付与する。
</li>
			<li>
`繰返し勾配$に対しては、後続の／先行の
他のすべての色停には，色停~listを繰返しながら，適切にズラした~indexを付与する。
</li>
			<li>
各~勾配の同じ~indexの色停が互いに対応する。
</li>
		</ul>
<p>
しかる後、各 対応する色停~pairに対し，その［
位置, 色
］を独立に補間する。
</p>
◎
To interpolate a color-stop, first match each color-stop in the start gradient to the corresponding color-stop at the same index in the end gradient. For repeating gradients, the first specified color-stop in the start and end gradients are considered to be at the same index, and all other color-stops following and preceding are indexed appropriately, repeating and shifting each gradient’s list of color-stops as needed. Then, for each pair of color-stops, interpolate the position and color independently.
</li>
</ol>

		</section>
	</section>
	<section id="serialization">
<h2 title="Serialization">8. 直列化</h2>

【次も適用されることを除き， <a href="~CSSIMAGE#serialization">~level 3 と同じ</a>（なので、和訳は省略する）。】

<p>
`cross-fade$f に対しては、常に `percentage$t も直列化する。
◎
For cross-fade(), always serialize the &lt;percentage&gt;.
</p>

	</section>
	<section id="privsec">
<h2 title="Privacy and Security Considerations">~privacy／~security上の考慮点</h2>

<p class="note">注記：
`css3-images$r と<a href="~CSSIMAGE#privsec">同じ</a>。
◎
Note: No change from [css3-images].
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p id="changes-20120911">
<a href="~TR/2012/WD-css4-images-20120911/">2012 年 9 月 11 日付 作業草案</a>
からの変更点は：
◎
Changes Since the 11 September 2012 Working Draft
</p>

<ul>
	<li>
<a href="#color-stop-syntax">色~補間~hint</a>
を追加した。
◎
Added color interpolation hints
</li>
	<li>
勾配の色停に
<a href="#color-stop-syntax">2 個の所在による構文</a>
を追加した。
◎
Added the two location syntax for gradient color stops
</li>
	<li>
`円錐型~勾配$に開始-角度を追加した。
◎
Added start angles to conic gradients
</li>
	<li>
色停の位置（たち）は、今や色より前にも来れる
◎
The position(s) of a color stop can now come before the color
</li>
	<li>
`css3-images$r に一致する~textは、 `css3-images$r への参照に置換した。
◎
Text that is identical to [css3-images] has been replaced with a reference to [css3-images].
</li>
</ul>

<p id="changes-3">
~Level 3 からの変更点は：
◎
Changes Since Level 3
</p>

<ul>
	<li>
（~level 3 から先送りされた）
`image$f 記法を追加した。
◎
Added the image() notation (deferred from Level 3)
</li>
	<li>
（~level 3 から先送りされた）
`image-resolution$p ~propを追加した。
◎
Added the image-resolution property (deferred from Level 3)
</li>
	<li>
（~level 3 から先送りされた）
`element$f 記法を追加した。
◎
Added the element() notation (deferred from Level 3)
</li>
	<li>
`円錐型~勾配$を追加した。
◎
Added conic gradients
</li>
</ul>

	</section>

</main></div><!-- MAIN -->

