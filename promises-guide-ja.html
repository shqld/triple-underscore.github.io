<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Writing Promise-Using Specifications （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />

<style>
.comment {
	font-family: serif0, serif;
	color: green;
	white-space: normal;
}

q {
	display: block;
	margin: 0.6em 0.6em 0.6em 2em;
	text-decoration: underline;
}

var {
	font-family: serif0, serif;
}

b {
	color: black;
}

i {
	text-decoration: underline;
}

.event-type {
	color: purple;
}

.js-value {
	color: #041;
}

.literal {
	color: gray;
}

/* 例／注記 */
.note, .example {
	padding: .5em;
	/* padding: .5rem; /* proposed unit in css3-values */
	border-width: .5em;
	/* border-left-width: .5rem; /* proposed unit in css3-values */
	border-style: none none none solid;
}

/* Example box */
.example {
	border-color: #E0CB52;
	background: #FCFAEE;
}

/* Examples */
.example > pre {
	background: #FCFADC;
}

.note {
	border-color: #52E052;
	background: #E9FBE9;
}


.lang-javascript {
	background: #FCFADC;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data)
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'c':
	const i = key.indexOf('(');
	if(i > 0) {
		text = key.slice(0, i)
		+ key.slice(i).replace(/\w+/g, '<var>$&</var>')
	}
	break;
case 'et':
case 'b':
case 'i':
case 'V':
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>
<!-- 
if(href){
	switch(indicator){
	case '^':
		break;
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
			text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
//	if(!href && indicator !== '^') console.log(match); // check error

return text;

 -->
<script type="text/plain" id="_source_data">


●●options

spec_date:2018-11-09
trans_update:2018-11-23
source_checked:161106
original_url:https://www.w3.org/2001/tag/doc/promises-guide
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
trans_1st_pub:2015-01-12


●●class_map
jv:js-value
jA:abstract
et:event-type

●●tag_map
jv:code
i:i
c:code
et:code
V:var
jA:span

●●original_id_map


initial-value:


●●link_map


射:#_arrow-func
初期~値:#initial-value
新たな~promise:#a-new-promise
解決する:#resolve-promise
解決して:#resolve-promise
解決-:#resolve-promise
~promiseとして解決する:#resolved-as-a-promise
~promiseとして解決され:#resolved-as-a-promise
解決される~promise:#a-promise-resolved-with

却下する:#reject-promise
却下される~promise:#a-promise-rejected-with
変形する:#transforming-by
変形した:#transforming-by

充足-時:#upon-fulfillment
却下-時:#upon-rejection
決着-:#_settle
決着:#_settle
~promise-call:#promise-calling
すべての~promiseを待機する:#waiting-for-all
すべてを待機する~promiseを取得する:#waiting-for-all-promise

充足~値:#fulfillment-value
事由~値:#reason-value

	●§
	#example-resource-open
	#example-delay
	#promise-call-in-js
	#always-return-promises
	#should-promise-call
	#shorthand-manipulating
	#example-batch-request


	●INFRA
~list:~INFRA#list
~size:~INFRA#list-size

	●HTML
並列的:~HTMLINFRA#in-parallel
~taskを~queueする:~WAPI#queue-a-task
関連する設定群~obj:~WAPI#relevant-settings-object-for-a-global-object
	~WAPI#relevant-settings-object
担当の~event~loop:~WAPI#responsible-event-loop
~eventを発火する:~DOM4#concept-event-fire

	●ES6
c.Promise.all():~TC39#sec-promise.all
c.Promise.prototype.then:~TC39#sec-promise.prototype.then
c.Promise.reject:~TC39#sec-promise.reject
c.Promise.resolve:~TC39#sec-promise.resolve
~realm:~TC39#sec-code-realms
~Promise0:~TC39#sec-well-known-intrinsic-objects
jA.PerformPromiseThen:~TC39#sec-performpromisethen


	組込みの ECMAScript ~error型:~TC39#sec-error-objects
	ECMAScript の次の~version:~TC39#sec-promise-objects
	`reject^c 関数:~TC39#sec-promise-reject-functions
	`resolve^c 関数:~TC39#sec-promise-resolve-functions
	`Promise^c 構築子:~TC39#sec-promise-constructor

	●WebIDL
~PromiseT:~WEBIDL#es-promise
~callback関数:~WEBIDL#dfn-callback-function
~callback~interface:~WEBIDL#dfn-callback-interface
~promise型:~WEBIDL#es-promise
c.USVString:~WEBIDL#idl-USVString
c.DOMException:~WEBIDL#idl-DOMException

多重定義:~WEBIDL#idl-overloading
多重定義~解決~algo:~WEBIDL#dfn-overload-resolution-algorithm
演算:~WEBIDL#dfn-operation
共用体~型:~WEBIDL#idl-union
	投出
	例外

	“演算” 節:~WEBIDL#es-operations
	WebIDL 仕様により:~WEBIDL#es-operations
	Web IDL:http://www.w3.org/TR/WebIDL/

	それらを呼出して:~WEBIDL#es-invoking-callback-functions
	~promiseが決着したときの手続きを遂行する:~WEBIDL#dfn-perform-steps-once-promise-is-settled
	WebIDL により:~WEBIDL#es-exceptions


c.Request:~FETCH#dom-request
c.Response:~FETCH#response
c.fetch():~FETCH#dom-global-fetch
c.IDBRequest:~INDEXEDDB#request-api
c.send():~XHR#dom-xmlhttprequest-send


Streams API:https://github.com/whatwg/streams


●●words_table1

MANIFEST:http://w3c.github.io/manifest/
PromiseT: <code>Promise&lt;<var>T</var>&gt;</code> 
射:=&gt;
Promise0:%Promise%


●●words_table


	●一般処理
task::::タスク
ready:
background::::バックグラウンド
thread::::スレッド
error::::エラー
	error-handling
event::::イベント
loop::::ループ
flow::::フロー
小task:microtask::小 task:小タスク
mode::::モード
parameter::::パラメタ
realm:
method::::メソッド
listen:
cancel::キャンセル
access::::アクセス
accessor::::アクセサ
catch:
thenable:
promise:
promise-call:
	promise-called:
	promise-calling:
	promise-property:
call:
callback:
calling:
wrapper:
阻む:block する::~::ブロックする
阻まれ:block され::~::ブロックされ
阻まな:block しな::~::ブロックしな
	阻まれることなく:non-blocking
下位手続き:nested steps:~
手続き:steps:~
段:step:~
並列的:parallel::~
非同期性:asynchronicity::~
非同期的:asynchronous::~
同期的:synchronous::~
非同期:async::~
one-and-done::一回で終える
一度限り:one-time:~
一度限りの:one-time:~
等価:equivalent:~
例外:exception::~
引数:argument:~
arg:
事由:reason::~
増分的:incremental:~
即時:immediate:~
即時の:immediate な:~
非同時性:asynchrony:~
時機:time:~
却下-:reject::~
	却下される:rejected
却下:rejection::~
	却下-時:upon rejection
充足-:fulfill::~
充足d:fulfilled::充足
	充足される:fulfilled
充足:fulfillment::~
	充足-時:upon fulfillment
待機-:wait::~
解決-:resolve::~
解決:resolution::~
集成-:aggregate::~
決着-:settle::~
決着:settling::~
変形-:transform::~
反応-:react::~::リアクト
反応:reaction::~::リアクション
通達-:signal::~
通知-:notify::~
通知:notification::~
遅延:delay::~
発火-:fire::~
失敗-:fail::~
失敗:failure::~
成功-:succeed::~
成功:success::~
成功裡:successful::~
投出:throw::~
完了:completion::~
完了-:complete::~
走る:run する:~
走らせ:run させ:~
	running
返値:return value:返り値
返し:return し:~
返す:return する:~
返され:return され:~
返さな:return しな:~
返せる:return できる:~

処分済み:disposed:~
完遂d:finished:完遂
保存-:save:~
入力の:incoming:入力された
入力:input:~
処理-:process:~
動作:action:~
消費-:consume:~
伝播-:propagate:~
中止-:abort:~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出:invocation:呼び出し
検出:detection:~
検出-:detect:~
実行-:execute:~
実行:execution:~
遂行-:perform:~
	遂行-法:performing
渡す:pass する:~
渡され:pass され:~
渡した:pass した:~
渡せる:pass できる:~
繰返:繰り返
抜出る:exit する:抜け出る
誘発-:trigger:~

	省略時は／省略可能:optional
	何度も行われる:iterative
	行われ:done
	~~開始させる:kick off
	往復:moves back and forth
	戻る:back する
	戻る:moves backward

	●データ型／操作
型:type::~
集合:set::~
queue::::キュー
	queue up
配列:array::~
obj:object:::オブジェクト
primitive::::プリミティブ
list::::リスト
共用体:union::~
property::::プロパティ
data::::データ
entry::::エントリ
class::::クラス
instance::::インスタンス
内部slot:internal slot::内部 slot:内部スロット
空:empty::~
関数:function::~
初期化-:initialize::~
初期:initial::~
新たな:new::~
型:type::~
値:value::~
作成-:create::~
	作成法:creating::~
操作-:manipulate::~
	操作-法:manipulating
取得子:getter::~
取得-:get::~
設定-:set::~
	設定し直す:reset
読取る:read する::読み取る
読取り:reading::読み取り
書出す:write する::書き出す
転換-:turn:~
更新-:update::~
検証-:validate::~
検証:validation::~
変換-:convert:~
変換:conversion:~
変異:mutation::~
改変-:modify::~
	改変-不能な:un-modifiable
生産-:produce::~
組上げる:compose する:組み上げる
遷移:transition::~
挿入-:insert::~
検索取得-:retrieve::取得
構築子:constructor::~::コンストラクタ
有構造:structured::~
clone::::クローン
演算:operation::~



	●仕様
UA:user agent:UA
API:
version::::バージョン
metadata::::メタデータ
model::::モデル
pattern::::パタン
platform::::プラットフォーム
web:::::ウェブ
vagaries:
logic::::ロジック
main::::メイン
idea:::アイデア
popular::::ポピュラー
test::::テスト
community::::コミュニティ
algo:algorithm:::アルゴリズム
app:application:::アプリ
原則:advice:~
paradigm::::パラダイム
注釈文:prose::~
句:phrase::~::フレーズ
	~vagaries of clearly manifesting
局面:scenario:~
否定的:negative:~
旧世界:old world:~
懸念:concern:~
役立つ:helpful になる:~
情報的な:informational:情報を与える
原型的:prototypical:~
変種:variant:~
微妙:subtle:~
一助:help:~
一般:general:~
	一般~化:generalization
一般な:general:一般的な
アリ:possible:可能
	可能性:possibilities
	不可能:impossible:~
正しく:correct に:~
不正:incorrect:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
付録:appendix:~
	例:example:~
	例えば:for example:~
例外的:exceptional:~
便宜:convenience:~
側面:aspect:~
候補:candidate:~
共通的な:common な:よくある
	よくある:commonly-encountered
審判:judgement call:~
	判定:judgement:~
用法:usage:~
効果:effect:~
単純:simple:~
	単純に:simply:~
単純化-:simplify:~
可用:available:~
回答:answer:~
多義的:ambiguous:~
	あいまい:ambiguous:~
実際:actual:~
容易く:easy に:~
帰結:consequence:~
影響0:impact:影響
役割:role:~
従来の:conventional:~
情報:information:~
手動:manual:~
手引き:guidance:~
技法:technique:~
拙い:poor:~
指標:indicator:~
方式:manner:~
方法:how:~
旧式:legacy:~
旧来の:legacy な:~
明示的:explicit:~
有用:useful:~
末端利用者:end-user:~
本質的:essential:~
標準の:standard な:~
正確:exact:~
正確a:accurate:正確
状況:situation:~
状況下:circumstance:~
直に:direct に:~
相似:analogy:~
相似的:analogous:~
真:true:~
稀:rare:~
簡便:convenient:~
簡潔:concise:~
末端利用者:end user:~
背景:background:~
自動的:automatic:~
複雑な:complicated:~
詳細:details:~
論点:discussion:~
議論:debate:~
通例的:usual:~
	通例的には:usually:~
通常の:normal:~
適切:appropriate:~
高価な:expensive:~
現実:real-world:~
正解:right solution:~
質問:question:~
	問い:question
	何かを問うもの:phrased as a question
念頭:mind:~
不確かな:sure でない:~
強い:strong な:~
重要:important:~

	到来:advent
	場当たり的:ad-hoc
	理由付ける:reason about
	:versus
	使い過ぎ:over-using
	しない方が良い:bad
	まずい:bad
	良い:good
	場合によっては:possibly
	易く:ease
	易い
	対照的に:in contrast
	relation to 〜 ~nail down :相対的な時点に確定する
	使い勝手の良い:nice
	繊細
	互いに競いながら~test:battle-test
	書式上のもの:form of documentation
	一例:draw
	傍系として:alongside
	とりわけ:especially
	とても:very
	ひょっとして:perhaps
	おそらく:probably
	しかしながら:however
	したがって:thus
	べき:should
	~~十分である:just fine
	もちろん:of course
	ちょうど同じく:just like 〜as well.
	注記される:call out
	好例:Good cases
	理由:why
	終わりに、:To close,
	〜の原則が守られる:take care〜advice
	表す:stands in for
	向けのもの:audience
	すなわち:namely
	何でもよい:not relevant
	類する:similar
	このこと:subject
	依然として:still
	同様に、:similarly
	更には:furthermore
	更なる／更に:further
	ちょっとした:aslight
	~~定式化:encode

	●仕様（動詞
書く:write する:~
書けば:write すれば:~
書込み:writing:書き込み
書かれ:write され:~
書手:writer:書き手
利用:use:~
利用者:user::~
approach::::アプローチ
守られ:care され:~
	に基づく:-based
明言-:state:~
略記:shorthand::~
説明0:illustrate:説明
明白化-:clear に manifest:~
加味-:account:~
勧める:advise する:~
請う:ask する:~
請われ:ask され:~
欲する:want する:~
欲して:want して:~
自問-:ask:~
請求:demand:~
不許可に:permission を deny:~
	壊れて:broken:~
指図-:instruct:~
関係0-:matter:関係
仮定-:pretend:~
作者:author:~
予期-:expect:~
期待-:expect:~
仲介-:mediate:~
作業:work:~
働く:work する:~
働ける:work できる:~
望む:wish する:~
注記-:note:~
孕まれ:involve され:~
定義-:define:~
定義:definition:~
実装者:implementer:~
導入:introduction:~
導出-:derive:~
強いる:force する:~
必要-:need:~
	必要とされる:necessary:~
意味-:mean:~
抽象化-:abstract-away:~
拡張-:extend:~
指定-:specify:~
指示-:indicate:~
	指示するもの
挙動:behavior:ふるまい
供-:provide:~
供せ:provide でき:~
給-:supply:~
移行-:move:~
補助的:supporting:~
要約-:summarize:~
見なす:consider する:~
見なさ:consider さ:~
見出され:find され:~
見出せ:find でき:~
見出し:heading:~
解-:understand:~
設計:design:~
許容-:allow:~
試みる:attempt する:~
試みて:attempt して:~
説明-:explain:~
述べる:describe する:~
適合-:conform:~
適合性:conformance:~
適用-:apply:~
	適用-可能:applicable
選択:choice:~
開発:development:~
開発者:developer:~
関係:relation:~
取組む:address する:取り組む
診る:consult する:~
診な:consult しな:~
取扱い:handling:取り扱い
	取扱う:handle する:取り扱う
取扱え:handle でき:取り扱え
取扱っ:handle し:取り扱っ
	取扱わ:handle し:取り扱わ
	取扱われ:handle され:取り扱われ
	扱-:treat／deal with
受容-:accept:~
統一化-:unify:~
統一的:uniform:~
統合-:integrate:~
翻訳-:translate:~
表出でき:express でき:表せ

	:stand
	必ず-:ensure
	考える:think する
	解ってもらうappeal
	できるようになる:allowing
	:meant
	注目:notice
	関心を持つ／関心がある:interested in
	見よ:see
	あるとする:take
	これからは:going forward
	念頭に置く:keeping it in mind
	互いに合致しない:mismatched
	に関して:with respect to
	言-~say
	散らばる:scatter
	関して:regard
	遂に〜完成:culminate
	について扱う:dealing with
	:differing
	読み飛ばし:skip し
	加えて，:additionally

	●未分類（動詞

buffer::::バッファ
buffering::::バッファ処理
cache::::キャッシュ
fetch:
多重定義:overload::~
叩いた:hit した:~

load::::ロード
loaded::load 済み::ロード済み
未load:unloaded:未 load::未ロード
再load:reload:~::リロード
	~re-load:再~load
	読込み:load:読み込み
	読込む:load する:読み込む
	読込まれ:load され:読み込まれ
	読込済み:loaded:読み込み済み
	未読込み:unloaded:未読み込み
	再~load:reload:再読み込み
	~reacting
	~resolving::::
配列順序:sequencing:~
使用者:consumer:~
申込める:subscribe できる:~
申込んで:subscribe して:~
算出-:compute:~
計算:computation:~
	~~時間のかかる計算:long-running computation
保つ:keep する:~
公開-:expose:~
包含-:contain:~
参照:reference:~
参照-:refer:~
	繰返し~recurring::::
反映-:reflect:~
含まれ:include され:~
含む:include する:~
含め:include し:~
送受信-:send or receive:~
通信-:communicate:~
受信-:receive:~
格納済みの:previously-stored:~
	通過:pass
宣言-:declare:~
所属-:belong:~
	対応-:correspond:~
	生じ:occur し:~
	生じる:occur する:~
省略-:omit:~
組込みの:built-in:組み込みの
結付けら:associate さ:結び付けら
表現-:represent:~
要請:request:~
応答:response::~::レスポンス
観測-:observe:~
	観測-可能:observable
追加-:add:~
	追加-:additional:~
除いて:except して:~
	結果:result:~
	結果の:resulting

	知る:know する
	示す:show する
	示され:show され
	開:opening up
	与-:give
	成す:consist
	得-:get
	起こる:happen する
	置く:put
	返信:replies
	失われる:lost
	押した:press した
	〜になる:become／becoming

	●未分類
JS:JavaScript
WebIDL:
index:
size::::サイズ
global:
DOM:
	ECMAScript:
URL:
block::::ブロック
animation::::アニメーション
bookmark::::ブックマーク
button::::ボタン
channel::::チャネル
code::::コード
encapsulate::::カプセル化
escape::::エスケープ
font::::フォント
framework::::フレームワーク
handler::::ハンドラ
interface::::インタフェース
応接する:interface する:~
library::::ライブラリ
machine::::マシン
memory:::記憶域::メモリ

ms:milliseconds::ミリ秒
network::::ネットワーク

script::::スクリプト
status::::ステータス
storage::::ストレージ
stream::::ストリーム
streaming::::ストリーミング

zero::::ゼロ

設定群:settings::~
関連する:relevant な:~
担当の:responsible::~
状態:state::~
内在的:intrinsic::~
内的:internal::~
nothing::何も無し

内側:inside:~
内容:content:~
名前:name:~
妥当:valid:~
	invalid
形:form:~
文字列:string:~
文書:document:~
	文書~化:documented
環境:environment:~
	~appeal to environmental asynchrony
環境上の:environmental:環境における
	:environmental:~
画像:image:~
要素:element:~
言語:language:~
資源:resource::~:リソース
部位:portion:~
重複:duplicate:~
量:amount:~
頁:page:~:::ページ
連絡先情報:contact:~
	用意ができた~ready
巨大:large:~
	一部分:part:~
blog-post:blog post:ブログ投稿
不在:absence:~
位置:position:~
回数:count:~
合計:total:~

	末尾側:toward the end
	少しでも:remotely
	開始:starting
	沿う:along
	行:line
	通:through
	standalone
	large
	利用者~~入力を促すときUser interface prompts
	quite
	こと:occasion
	:potentially
	OK:
	against
	二倍:twice
	一対一対応one-to-one correspondence
	それが生じた時点とされる:that eventuality comes to pass
	~block
	場所:place
	:sure
	越しに:over

	充足d回数:fullfilledCount

	●指示語
広範:wide:~
今後の:later:~
特有の:specific な:~
特定の:specific:~
現在の:current:~
次回の:next:~
初回の:initial:~
単独の:single:~
最初の:first:~
第一:first:~
最大:maximum:~
	最早:no-longer:~
最終的:eventual:~
最終的な:eventual:~
最終的:eventual:~
	eventually:~
余分な:extra:~
後続して:successive に:~
全部的:full:~
	数種の:several:~
	全体:entire:~
	以前:previous:~
	少数の:a few:~
	常に:always:~
	今や:now
	主に:primary に
	両者:both:~
	ほとんどの:most
	そのような:such
	何か:something
	何故なら:because
	他の:other
	別々:separate
	別の:another
	前:before
	後:after
	後者:latter
	前者:former
	自身:itself
	~~全体を通して:throughout
	節:section
	複数の:multiple
	一連の:series
	ここ:here
	この:this
	これらの:these
	それらを:them
	すでに:already
	すべての:all
	その:that
	それら:they
	それらの:their
	それらの:those
	ほぼ:mostly
	ほぼ:almost
	各:each
	合間:between
	同じ:same
	自前の:own
	ある種の:certain class
	もの:thing
	複数回:more than once
	一まとめに:together
	:old
	:once
	一つの:one
	上:above
	下:below
	次の:the following
	特に、:In particular
	単に:just
	様な／同様に:like
	多い:often
	少なくとも:least
	決して:never
	種々の:variety
	多くの:many
	違って:Unlike
	ありふれている:abound throughout
	多種多様な:large variety of differing
	時点:at the time
	多種のmany sorts
	代わりに:instead


●●ref_normative

[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 

●●spec_metadata
編集
	<a href="https://domenic.me/">Domenic Denicola</a> (Google) <a href="mailto:d@domenic.me">d@domenic.me</a>

Participate:
	<a href="https://github.com/w3ctag/promises-guide">GitHub w3ctag/promises-guide</a> (<a href="https://github.com/w3ctag/promises-guide/issues/new">file an issue</a>; <a href="https://github.com/w3ctag/promises-guide/issues?state=open">open issues</a>)

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより公開された
<a href="http://www.w3.org/2001/tag/doc/promises-guide">Writing Promise-Using Specifications</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>

<body>

<header>
	<hgroup>
<h1 id="title">Promise を利用する仕様を書くとき — Writing Promise-Using Specifications</h1>
<h2 id="subtitle" title="A Collection of Interesting Ideas">様々なアイデア集</h2>
	</hgroup>

<details><summary>&copy;</summary>
<small class="copyright" lang="en-x-a0">
<a href="http://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>
<!-- 
<img alt=CC0 src=https://i.creativecommons.org/p/zero/1.0/80x15.png>
-->
To the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
In addition, as of 9 November 2018, the editors have made this specification available under the
<a href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0" rel="license">Open Web Foundation Agreement Version 1.0</a>,
which is available at http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.
Parts of this work may be from another specification document.
If so, those parts are instead covered by the license of that specification document.
</small></details>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この文書は、~promiseを［
作成する／受容する／操作する
］ような仕様を書くための手引きを与える。
また、~promiseを利用する仕様を記すときに 注釈文にて利用できる，一連の略記法についても述べる。
◎
This document gives guidance on how to write specifications that create, accept, or manipulate promises. It also includes a series of prose shorthands you can use in your specification to work with promises.
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
<em>~promise</em>
（ “約束” ）とは、［
単独の非同期的な演算
］の最終的な結果を表現する，~objである。
それは，非同期的な関数からも返し得るので、使用者は，演算が成功した／失敗したときに~callされるような~callbackを~queueすることのみならず、返された~promise~objを操作して，様々な~~分岐の可能性を開けるようになる。
◎
A promise is an object that represents the eventual result of a single asynchronous operation. They can be returned from asynchronous functions, thus allowing consumers to not only queue up callbacks to be called when the operation succeeds or fails, but also to manipulate the returned promise object, opening up a variety of possibilities.
</p>

<p>
~promiseは、
Dojo, jQuery, YUI, Ember, Angular, WinJS, Q, その他諸々の，~popularな~frameworkの一部分も含め，多くの~JS~library間で互いに競いながら~testされてきた。
これは、遂には
<a href="https://promisesaplus.com/">Promises/A+ ~community仕様</a>
【<a href="Promises_Aplus-ja.html" >和訳</a>】
として完成され、ほとんどの~libraryはそれに適合している。
今や、標準の `Promise^c ~classが
<a href="~TC39#sec-promise-objects">ECMAScript 言語~仕様に含まれている</a>
`ECMASCRIPT$r
— 各種~web~platform~APIは、自身による非同期的な演算~用の~promiseを返せるようになっている。
◎
Promises have been battle-tested in many JavaScript libraries, including as part of popular frameworks like Dojo, jQuery, YUI, Ember, Angular, WinJS, Q, and others. This culminated in the Promises/A+ community specification which most libraries conformed to. Now, a standard Promise class is included in the ECMAScript Language Specification [ECMASCRIPT], allowing web platform APIs to return promises for their asynchronous operations.
</p>

<p>
~promiseは今や、すべての “~one-and-done” 非同期的な演算~用の，~web~platformにおける~paradigmである。
以前まで、仕様は，そのような演算~用に，互いに合致しない 種々の仕組みを利用していた。
これからは、この型のすべての非同期的な演算は，代わりに~promiseを返すように指定されるべきである
— ~platformに，非同期性のための統一化された~primitiveを与えるために。
◎
Promises are now the web platform’s paradigm for all "one and done" asynchronous operations. Previously, specifications used a variety of mismatched mechanisms for such operations. Going forward, all asynchronous operations of this type should be specified to instead return promises, giving our platform a unified primitive for asynchronicity.
</p>

<p class="note">
この文書は主に，仕様の書手たちに向けたのものであるが、~promiseを利用する
~library／~app
を書く~JS開発者にとっても有用になる。
特に仕様の書手~向けの節は、開発者が読み飛ばし易くするため，その旨が注記される。
◎
Although the primary audience of this document is specification writers, it is also useful for JavaScript developers who want to write libraries or applications using promises. We will call out sections that are spec-writer specific so developers can skip them more easily.
</p>


	</section>
	<section id="when-to-use">
<h2 title="When to Use Promises">2. ~promiseをいつ利用するか</h2>



		<section id="one-and-done">
<h3 title="One-and-Done Operations">2.1. ~one-and-done演算</h3>

<p>
~promiseは、主に，［［［
単独の非同期的な演算
］を~~開始させる~method
］から，返されるもの
］として利用される。
~promiseを返す関数は、通常の同期的な関数とは対照的に，非同期的な関数†として考えるべきである
— ここには とても強い相似があることを念頭に置いておけば、そのような関数を書いたり, それを理由付けるのも 容易くなる。
◎
The primary use case for promises is returning them from a method that kicks off a single asynchronous operation. One should think of promise-returning functions as asynchronous functions, in contrast to normal synchronous functions; there is a very strong analogy here, and keeping it in mind makes such functions easier to write and reason about.
</p>

<p>
例えば：
通常の同期的な関数は、値を返すか, または 例外を投出する。
相似的に、非同期的な関数†は，［
ある値により充足されるか, または
ある事由により却下される
］ような，~promiseを返すことになる。
同期的な関数が “~nothing”（すなわち， `undefined^jv ）を返し得るのとちょうど同じく、非同期的な関数から返される~promiseも，~nothing（ `undefined^jv ）で充足し得る
— この事例においては、~promiseの充足は，単純に非同期的な演算の完了を通達する。
【† より詳しく述べるなら、非同期的な演算を “包装する” 関数 — “その実行を<em>約束する</em> ~promise~objとして即時に（同期的に）返すような関数” の略記。】
◎
For example, normal synchronous functions can either return a value or throw an exception. Asynchronous functions will, analogously, return a promise, which can either be fulfilled with a value, or rejected with a reason. Just like a synchronous function that returns "nothing" (i.e. undefined), promises returned by asynchronous functions can be fulfilled with nothing (undefined); in this case the promise fulfillment simply signals completion of the asynchronous operation.
</p>

<p>
そのような非同期的な演算の例は、各種~web仕様にありふれている
— ~promiseの仕組みにより：
◎
Examples of such asynchronous operations abound throughout web specifications:
</p>

<ul>

	<li>
非同期的な I/O 演算：
~storage~APIにより~dataを 読取る／書出す ~methodは、~promiseを返せるようになる。
◎
Asynchronous I/O operations: methods to read or write from a storage API could return a promise.
</li>
	<li>
非同期的な~network演算：
~network越しに~dataを送受信する~methodは、~promiseを返せるようになる。
◎
Asynchronous network operations: methods to send or receive data over the network could return a promise.
</li>
	<li>
~~時間のかかる計算：
何かを算出するために ある程度時間を~~要する~methodは、結果<!---->のための~promiseを返した上で，別の~thread上で働けるようになる。
◎
Long-running computations: methods that take a while to compute something could do the work on another thread, returning a promise for the result.
</li>
	<li>
利用者に~~入力を促すとき：
利用者に回答を請う~methodは、~promiseを返せるようになる。
◎
User interface prompts: methods that ask the user for an answer could return a promise.
</li>
</ul>

<p>
以前までは、~web仕様は，非同期的な演算~用に，多種多様な~patternを利用していた。
これらは，
<a href="#legacy">後述の付録</a>
にて文書~化されているので、何が今や旧式と見なされているかについての~ideaを得られる。
今や、~platform~primitiveとして，~promiseがある
— そのような~approachは最早~必要とされない。
◎
Previously, web specifications used a large variety of differing patterns for asynchronous operations. We’ve documented these in an appendix below, so you can get an idea of what is now considered legacy. Now that we have promises as a platform primitive, such approaches are no longer necessary.
</p>

		</section>
		<section id="one-time-events">
<h3 title="One-Time &quot;Events&quot;">2.2. 一度限りの “~event”</h3>

<p>
~promiseは、すでに
充足された／却下された
後でも，
【まだ処理が終わっていないかのように，その結果が通達されるよう】
申込めるので、ある種の “~event” においては，とても有用になり得る。
一度だけ起こるものであって，作者が すでに生じた後にも その~statusを観測したいと欲することが多いとき、［
充足されたのは，それが生じた時点とされる
］ような~promiseを供することは、とても簡便な~APIを与える。
◎
Because promises can be subscribed to even after they’ve already been fulfilled or rejected, they can be very useful for a certain class of "event." When something only happens once, and authors often want to observe the status of it after it’s already occurred, providing a promise that becomes fulfilled when that eventuality comes to pass gives a very convenient API.
</p>

<p>
そのような “~event” の原型的な例として、~loadedかどうかを指示するものが挙げられる：
画像, ~font, あるいは文書などの資源でさえ、［［
資源が全部的に~loadされたときに限り，充足される（あるいは，資源の~load時に~errorが~~生じたときは却下される）
］ような~promise
］を返すような， `loaded^c ~propertyを供し得る。
作者は常に、
`resource.loaded.then(onLoaded, onFailure)^c
と記すことで，［
資源の用意ができ次第，実行されることになる
］ような動作が~queueされる。
これは、［
資源がすでに~loadされていたときでも，
%onLoaded を実行する小taskを~queueする
］ように，働く。
対照的に，~event~modelでは、［
~eventが発火された時点で，作者がまだ申込んでいない場合
］には、その情報は失われる。
◎
The prototypical example of such an "event" is a loaded indicator: a resource such as an image, font, or even document, could provide a loaded property that is a promise that becomes fulfilled only when the resource has fully loaded (or becomes rejected if there’s an error loading the resource). Then, authors can always queue up actions to be executed once the resource is ready by doing resource.loaded.then(onLoaded, onFailure). This will work even if the resource was loaded already, queueing a microtask to execute onLoaded. This is in contrast to an event model, where if the author is not subscribed at the time the event fires, that information is lost.
</p>



		</section>
		<section id="state-transitions">
<h3 title="More General State Transitions">2.3. より一般な，状態~遷移</h3>

<p>
ある種の事例においては、~promiseは、［
状態~遷移を通達するための一般な仕組み
］として，有用になり得る。
この用法には微妙な所があるが、正しく行われたなら、使用者にとって，とても使い勝手の良い~APIを供せる。
◎
In certain cases, promises can be useful as a general mechanism for signaling state transitions. This usage is subtle, but can provide a very nice API for consumers when done correctly.
</p>

<p>
この~patternは、一度限りの “~event” 利用~事例の一般~化と考えられる。
例えば、いくつかの `&lt;img&gt;^c 要素があるとする。
それらは、 `src^c ~propertyを設定し直すことにより，再~loadさせられる
— すなわち，それらの状態は、 `~loaded^i から `未load^i へ戻るようにも遷移し得る。
したがって、 `~loaded^i になることは，一度限りではない：
代わりに、画像は，実際には［
`~loaded^i,  `未load^i の状態を往復する
］ような状態~machineを成す。
そのような局面においては、それぞれの画像に［
~promiseを返す `loaded^c ~property
］を与えることが，依然として有用になる
— それは、次回の［
`~loaded^i 状態へ移行する状態~遷移
］を通達する（あるいは、画像がすでに `~loaded^i 状態にあるならば，充足される~promiseを返す）。
この~propertyは、画像が `~loaded^i 状態から `未load^i 状態へ戻るまでは、検索取得される度に，同じ~promiseを返すべきである。
`未load^i 状態へ戻ったなら、<em>次回の</em>  `~loaded^i への遷移を表現するような，新たな~promiseが作成される。
◎
One can think of this pattern as a generalization of the one-time "events" use case. For example, take &lt;img&gt; elements. By resetting their src property, they can be re-loaded; that is, they can transition back from a loaded state to an unloaded state. Thus becoming loaded is not a one-time occasion: instead, the image actually consists of a state machine that moves back and forth between loaded and unloaded states. In such a scenario, it is still useful to give images a promise-returning loaded property, which will signal the next state transition to a loaded state (or be already fulfilled if the image is already in a loaded state). This property should return the same promise every time it is retrieved, until the image moves backward from the loaded state into the unloaded state. Once that occurs, a new promise is created, representing the next transition to loaded.
</p>

<p>
`~loaded^i へ遷移し得る資源のみならず、~platformにおいて これが有用になり得る，多くの場面がある
— 例えば：
`完遂d^i へ遷移し得る~animation ／
`処分済み^i へ遷移し得る高価な資源 ／
`未load^i になり得る~cache
など。
◎
There are many places in the platform where this can be useful, not only for resources which can transition to loaded, but e.g. for animations that can transition to finished, or expensive resources that can transition to disposed, or caches that can become unloaded.
</p>

<p>
この~patternのちょっとした変種は、ある~classが［
状態を遷移させるような~method
］を包含していて，その策定者が［
その状態~遷移が完了したときに，それを指示させたい
］と欲しているときに生じる。
その事例においては、［
その~methodが~promiseを返すようにする
］ことができる
— その~classの~obj上の~propertyに指示させる代わりに。
`Streams API$ は、その `wait()^c ／ `close()^c ~methodに対し，この変種を利用する。
一般に、~methodは動作~用に, ~propertyは情報的な状態~遷移~用に，利用されるべきである。
◎
A slight variant of this pattern occurs when your class contains a method that causes a state transition, and you want to indicate when that state transition completes. In that case you can return a promise from the method, instead of keeping it as a property on your object. The streams API uses this variant for its wait() and close() methods. In general, methods should be used for actions, and properties for informational state transitions.
</p>

<p>
終わりに、この~patternの使い過ぎに注意。
あらゆる状態~遷移に，対応する~promise~propertyが必要になるわけではない。
有用になるかどうかの指標には、次が挙げられる：
◎
To close, we must caution against over-using this pattern. Not every state transition needs a corresponding promise-property. Indicators that it might be useful include:
</p>

<ul>
	<li>
作者は、ほぼ常に，その状態~遷移の<em>次の</em>~instanceに関心があり、遷移が生じる度に繰返し通知が必要になるのは，稀なとき。
例えば、作者は，画像~要素が再loadされる度に それを知りたいと望むことは稀にしかない
— 通例的には、単純に，画像の初回の~load, 場合によっては
その `src^c を設定し直した後に生じる次回の~loadに限られる。
◎
Authors are almost always interested in the next instance of that state transition, and rarely need recurring notification every time it occurs. For example, rarely do authors care to know every time an image element is reloaded; usually they simply care about the initial load of the image, or possibly the next one that occurs after resetting its src.
</li>
	<li>
作者は、すでに生じた遷移に反応することに関心があることが多いとき。
例えば作者は、画像が［
~loadされたとき, あるいは すでに~load済みならアリな限り早く
］に，何らかの~codeを走らせたいと欲することが多い。
◎
Authors are often interested in reacting to transitions that have already occurred. For example, authors often want to run some code once an image is loaded; if the image is already loaded, they want to run the code as soon as possible.
</li>
</ul>



		</section>
	</section>
	<section id="when-not-to-use">
<h2 title="When Not to Use Promises">3. ~promiseを利用すべきでないとき</h2>

<p>
~promiseは、多種の非同期的な演算に対し，広範に適用-可能であるが、非同期性のためであっても，依然として適切でない状況はある。
◎
Although promises are widely applicable to asynchronous operations of many sorts, there are still situations where they are not appropriate, even for asynchronicity.
</p>



		<section id="recurring-events">
<h3 title="Recurring Events">3.1. 繰返される~event</h3>

<p>
複数回~生じ得るような どの~eventも、~promiseの “~one-and-done” ~modelに対する良い候補にはならない。
~promiseに対し、代わりに一連の~eventを表現するような，単独の非同期的な演算はない。
ここでは、従来の `EventTarget^c の用法で~~十分である。
◎
Any event that can occur more than once is not a good candidate for the "one and done" model of promises. There is no single asynchronous operation for the promise to represent, but instead a series of events. Conventional EventTarget usage is just fine here.
</p>



		</section>
		<section id="streaming-data">
<h3 title="Streaming Data">3.2. ~streaming~data</h3>

<p>
~dataが巨大にもなることもあって, 増分的に生産し得るものである場合、~promiseはおそらく，正解ではない。
代わりに、開発~下にある `Streams API$ を利用したいと欲するであろう
— それは、作者が，~data~streamを［
その内容~全体を~memory内に~bufferすることなく処理して，増分的に組上げる
］ことを~~可能にする。
◎
If the amount of data involved is potentially large, and could be produced incrementally, promises are probably not the right solution. Instead, you’ll want to use the under-development streams API, which allows authors to process and compose data streams incrementally, without buffering the entire contents of the stream into memory.
</p>

<p>
注記：
すべての~dataが~memory内に~bufferされても懸念にならないような事例に対しては、便宜のため，Streams API の傍系として~promise~APIを供せる場合もあるが、あくまで補助的な役割になるであろう。
◎
Note that in some cases, you could provide a promise API alongside a streaming API, as a convenience for those cases when buffering all the data into memory is not a concern. But this would be a supporting, not primary, role.
</p>



		</section>
	</section>
	<section id="api-design-guidance">
<h2 title="API Design Guidance">4. ~API設計の手引き</h2>

<p>
仕様の~APIにおいて~promiseを利用したり受容することには、少数の微妙な側面がある。
ここでは、よくある質問や状況に取組む。
◎
There are a few subtle aspects of using or accepting promises in your API. Here we attempt to address commonly-encountered questions and situations.
</p>



		<section id="errors">
<h3 title="Errors">4.1. ~error</h3>

			<section id="always-return-promises">
<h4 title="Promise-Returning Functions Should Always Return Promises">4.1.1. ~promiseを返す関数は，常に~promiseを返すべきである</h4>

<p>
~promiseを返す関数は、すべての状況下で，常に~promiseを返すべきである
— 結果が同期的に可用であっても, あるいは
入力が妥当でないことを同期的に検出し得るとしても、この情報は，統一的な~channelを通して通信される必要がある。
開発者が次のように書けば：
◎
Promise-returning functions should always return a promise, under all circumstances. Even if the result is available synchronously, or the inputs can be detected as invalid synchronously, this information needs to be communicated through a uniform channel so that a developer can be sure that by doing
</p>

<pre class="lang-javascript">
promiseFunction()
  .then(%onSuccess)
  .catch(%onFailure);
</pre>

<p>
すべての成功／~errorを取扱えるようにするため。
◎
they are handling all successes and all errors.
</p>

<p>
特に，~promiseを返す関数は、決して，~errorを同期的に投出するべきでない
— そうすると、その使用者に~error取扱い~logicの重複を強いることになるので：
<code>catch (%e) { ... }</code>
~block内に一つ,
<code>.catch(%e 射 { ... })</code>
~block内にもう一つ。
引数を検証する際に~errorになるときでも、すべての~errorは、却下される~promiseを返すことにより，通達されるべきである。
◎
In particular, promise-returning functions should never synchronously throw errors, since that would force duplicate error-handling logic on the consumer: once in a catch (e) { ... } block, and once in a .catch(e =&gt; { ... }) block. Even argument validation errors are not OK. Instead, all errors should be signaled by returning rejected promises.
</p>

<p class="trans-note">【
記法
<code>%args `射@ %code</code>
は、 %args を入力に %code を実行する無名~関数（
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions">arrow function</a>
）。
】</p>

<p>
~WebIDLに基づく仕様については、この~~原則は
<a href="~WEBIDL#es-operations">~WebIDL仕様により</a>
自動的に守られる：
~WebIDLの［
`演算$や, `多重定義~解決~algo$自身
］により投出される，どの例外も、自動的に 却下に変換される。
手動により検証する方法の例は、後述の
<a href="#example-validated-delay">`validatedDelay^c 例</a>
を見よ。
◎
For WebIDL-based specs, this is taken care of automatically by the WebIDL specification: any exceptions thrown by WebIDL operations, or by the WebIDL overload resolution algorithm itself, are automatically converted into rejections. For an example of how to do manual validation, see the validatedDelay example below.
</p>



			</section>
			<section id="reasons-should-be-errors">
<h4 title="Rejection Reasons Should Be Errors">4.1.2. 却下~事由は `Error^c にするべきである</h4>

<p>
~promiseの却下~事由は、常に
ECMAScript `Error^c 型の~instanceにされるべきである
— 同期的に投出される例外が、常に `Error^c の~instanceにされるべきであることと，ちょうど同様に。
◎
Promise rejection reasons should always be instances of the ECMAScript Error type, just like synchronously-thrown exceptions should always be instances of Error as well.
</p>

<p>
特に，~DOMや他の~web~platform仕様においては、このことは、
`DOMError^c を決して利用せず，代わりに［
<a href="~WEBIDL#es-exceptions">~WebIDLにより</a>
拡張された `Error^c である， `DOMException$c
］が利用されるべきであることを意味する。
もちろん、
<a href="~TC39#sec-error-objects">組込みの ECMAScript ~error型</a>
も利用できる。
◎
In particular, for DOM or other web platform specs, this means you should never use DOMError, but instead use DOMException, which per WebIDL extends Error. You can of course also use one of the built-in ECMAScript error types.
</p>



			</section>
			<section id="rejections-should-be-exceptional">
<h4 title="Rejections Should Be Used for Exceptional Situations">4.1.3. 却下は、例外的な状況に対し利用されるべきである</h4>

<p>
正確に何を以って “例外的” と見なすかは，議論になるのが常だが、
~API仕様において~promiseを`却下する$ことにする前に，常に自問するべきである：
この関数が同期的であったとするとき、この状況下で，例外の投出-を期待するだろうか？
あるいは，（ `null^jv, `false^jv, `undefined^jv のような）失敗~値を期待するだろうか？
~APIの使用者にとっては，いずれの挙動がより有用になるか？について、考えるべきである。
不確かなときは、~APIが同期的であると仮定した下で，開発者たちが例外の投出を期待するかどうか、考えるべきである。
◎
What exactly you consider "exceptional" is up for debate, as always. But, you should always ask, before rejecting a promise: if this function was synchronous, would I expect a thrown exception under this circumstance? Or perhaps a failure value (like null, false, or undefined)? You should think about which behavior is more useful for consumers of your API. If you’re not sure, pretend your API is synchronous and then think if your developers would expect a thrown exception.
</p>

<p>
却下が~~適切になる事例には、次がある：
◎
Good cases for rejections include:
</p>

<ul>

	<li>
~storageへの書込みや~networkからの読取りなどの I/O 演算に失敗したとき。
◎
A failed I/O operation, like writing to storage or reading from the network.
</li>
	<li>
要請された~taskを完了させることが不可能なとき：
例えば、演算が
`accessUsersContacts()^c
【“利用者の連絡先情報に~accessする”】
であって，利用者が不許可にしたなら、何かで却下される~promiseを返すべきである。
◎
When it will be impossible to complete the requested task: for example if the operation is accessUsersContacts() and the user denies permission, then it should return a rejected promise.
</li>
	<li>
非同期的な演算を試みている間に，内的に何かが壊れているような状況：
例えば、開発者から妥当でない~dataが渡された, あるいは
環境がこの演算に対し妥当でない状態にあるなど。
◎
Any situation where something is internally broken while attempting an asynchronous operation: for example if the developer passes in invalid data, or the environment is in an invalid state for this operation.
</li>
</ul>

<p>
却下が~~不適切になる事例には、次がある：
◎
Bad uses of rejections include:
</p>

<ul>

	<li>
非同期的に請われた値を，見出せなかったとき：
例えば，
【“非同期的な map” asyncMap があるとして，】
<!-- 
maplike
-->
`asyncMap.get(key)^c は、 %key に対する~entryがないときは，
`undefined^jv に対する~promiseを返すべきである。
同様に、 `asyncMap.has(key)^c は， `false^jv に対する~promiseを返すべきである。
%key の不在は，例外的でないであろうから、却下される~promiseを返すのは，拙い選択になるであろう。
◎
When a value is asked for asynchronously and is not found: for example asyncMap.get("key") should return a promise for undefined when there is no entry for "key", and similarly asyncMap.has("key") should return a promise for false. The absence of "key" would be unexceptional, and so a rejected promise would be a poor choice.
</li>
	<li>
演算は何かを問うものであり, その回答が否定的になるとき：
例えば演算が
`hasPermissionToAccessUsersContacts()^c
【“利用者の連絡先情報への~accessは許可されているか？”】
であって，利用者が不許可にしたときは、`却下する$のでなく，
`false^jv で充足される~promiseを返すべきである。
◎
When the operation is phrased as a question, and the answer is negative: for example if the operation is hasPermissionToAccessUsersContacts() and the user has denied permission, then it should return a promise fulfilled with false; it should not reject.
</li>
</ul>

<p>
審判が必要とされるような事例には、次がある：
◎
Cases where a judgement call will be necessary include:
</p>

<ul>

	<li>
問いなのか請求なのかについて、より あいまいな~API：
例えば `requestUsersContacts()^c 
【“連絡先情報の~~入力を要請する”】
は、利用者が不許可にしたとき，
`null^jv で充足される~promiseを返すことも，あるいは［
利用者が不許可にしたことを明言する~error
］で却下される~promiseを返すことも考え得る。
◎
APIs that are more ambiguous about being a question versus a demand: for example requestUsersContacts() could return a promise fulfilled with null if the user denies permission, or it could return a promise rejected with an error stating that the user denied permission.
</li>
</ul>



			</section>
		</section>
		<section id="async-algorithms">
<h3 title="Asynchronous Algorithms">4.2. 非同期的な~algo</h3>

<p class="note">
この節は、主に仕様の書手~向けである。
ここでは、注釈文において，非同期的な~algo~flowを明白化するときの~vagariesについて扱う。
これについての背景は、
<a href="https://annevankesteren.nl/2014/08/asynchronicity">非同期性についての Anne 氏の~blog-post</a>
†を見よ。
【† 要約：非同期に実行される~algoの中で，不用意に大域的な~propertyを汚すと、並列的に実行されている~JS~codeの信頼性を確保できなくなる。】
◎
This section is primarily for spec writers, dealing with the vagaries of clearly manifesting asynchronous algorithm flow in prose. For more background on this subject, see Anne’s blog post on asynchronicity.
</p>



			<section id="simply-resolve-or-reject">
<h4 title="Simply Resolve or Reject the Promise">4.2.1. ~promiseを単純に解決する／却下するとき</h4>

<p>
~callbackの旧世界と違って、
成功, ~error
それぞれの事例に対し，別々の~callback型を（例えば~WebIDLにおいて）作成する必要はない。
代わりに，単に~promiseを
`解決する$／`却下する$
だけでよい。
◎
Unlike in the old world of callbacks, there’s no need to create separate callback types (e.g. in WebIDL) for your success and error cases. Instead, just resolve or reject your promise.
</p>



			</section>
			<section id="explicit-async-steps">
<h4 title="Note Parallel Steps Explicitly">4.2.2. 並列的な手続きを明示的に注記する</h4>

<p>
仕様の~algo内のどの手続きが，作者の~JS~codeと並列的に走るか
— すなわち，~script実行を阻まないことになるか —
について注記することは、重要である。
これは、~algoの実装者に［
どの演算が，例えば~background~threadや非同期的な I/O ~callを利用する必要があるか
］について指図する。
また、作者たちにとっては，［
~algoの演算に関して <em>彼らの</em>演算に期待されている配列順序
］を知る一助になる。
そのためには、 `HTML$r の “`並列的$に” という句を利用する。
◎
It is important to note which steps in your algorithms will be run in parallel with the author’s JavaScript code, i.e. without blocking script execution. This instructs implementers as to which operations will need to use e.g. a background thread or asychronous I/O calls. And it helps authors to know the expected sequencing of their operations with respect to those of your algorithm. To do this, use the phrase in parallel from [HTML].
</p>

<p>
例として、次の手続きは、 %ms ~ms後に`解決される~promise$を与える：
◎
As an example, the following steps will give a promise that is resolved after ms milliseconds:
</p>

<ol>

	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きを`並列的$に走らせる：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~ms待機する
◎
Wait ms milliseconds.
</li>
			<li>
`undefined^jv で %p を`解決する$。
◎
Resolve p with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %p 【 上の下位手続きが終わるのを待たずに】
◎
Return p.
</li>
</ol>

<p>
“並列的に走らせる”
の見出しを省略したなら、~algoは，実装者に［
~main~threadを %ms ~ms間~阻む
］よう指図することになり、とてもまずい！
— 上のように書かれたなら、~algo自身は阻まれることなく，待機することを正しく述べることになる。
◎
If we had omitted the "Run the following steps in parallel" heading, then the algorithm would have instructed implementers to block the main thread for ms milliseconds, which is very bad! Whereas as written, this algorithm correctly describes a non-blocking wait.
</p>



			</section>
			<section id="queue-tasks">
<h4 title="Queue Tasks to Invoke Developer Code">4.2.3. 開発者~codeを呼出す~taskは~queueする</h4>

<p>
~promiseは、非同期~演算について開発者に通知することに関して，多くの詳細を抽象化する。
例えば、
<q>%x を引数に，~callback %cb を~callする`~taskを~queueする$</q>
と記す代わりに、
<q>%x で %p を`解決する$</q>
と記すことができる
— そうすれば、［
それが通常の~promiseの仕組みを利用することになる
］と解されるようになる（すなわち，開発者は、~promiseの `then^c ~methodに~callbackを渡すことにより、その<!-- 決着＊ --> 充足／却下 を待機できる
— それは，次回の小taskにおいて それらの~callbackを~callすることになる）。
なので、~promiseに基づく非同期的な~algoの内側では、ほとんどの事例において，明示的に~taskを~queueするように記す必要はなくなる。
◎
Promises abstract away many of the details regarding notifying the developer about async operations. For example, you can say "resolve p with x" instead of e.g. "queue a task to call the callback cb with x," and it’s understood that this will use the normal promise mechanisms. (Namely, the developer can wait for fulfillment or rejection by passing callbacks to the promise’s then method, which will call those callbacks in the next microtask.) So in most cases, you will not need to explicitly queue tasks inside your promise-based asynchronous algorithms.
</p>

<p>
しかしながら、［
~promiseが仲介し得るものを超える仕方で，開発者~codeと応接する必要がある所
］では、依然として，~taskを~queueするように記す必要がある。
例えば、［
開発者による~event~handlerの中へ~callし得る
］ような~eventを，発火させたいと欲することもあろう。
あるいは、有構造~clone演算を遂行する必要があるかもしれない
— それは、
<a href="https://lists.w3.org/Archives/Public/public-webcrypto/2014Mar/0141.html">取得子を誘発し得る</a>
【要約： Object.defineProperty で設定された get を誘発し得る — すなわち，これも開発者~codeを~callし得る】
。
これらが，~algoの非同期的な部位の内側で行われなければならない場合、［
特定の~task~queueを介して, および それに入れられる~taskにより，行われる
］ことを指定する必要がある。
これは、［
そのような~APIの開発者から観測-可能な演算が起こる，正確な時機
］を，［
その~queueされる他の~task
］, および［
~promiseにより利用される小task~queue
］の両者から相対的な時点に確定させる。
◎
However, in cases where you need to interface with developer code in more ways than can be mediated via the promise, you’ll still need to queue a task. For example, you may want to fire an event, which can call into developer event handlers. Or you may need to perform a structured clone operation, which can trigger getters. If these things must be done inside the asynchronous portion of your algorithm, you need to specify that they are done via a queued task, and with a specific task queue. This nails down the exact time such developer-observable operations happen both in relation to other queued tasks, and to the microtask queue used by promises.
</p>

<p>
例として、次の手続きは，
%ms ~ms後に`解決される~promise$を返すことになるが、所与の
( ~obj %~obj )
上にも名前 `timerfinished^et の~eventを発火する：
◎
As an example, the following steps will return a promise resolved after ms milliseconds, but also fire an event named timerfinished on an object object:
</p>

<ol>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きを`並列的$に走らせる：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~ms間~待機する
◎
Wait ms milliseconds.
</li>
			<li>
`undefined^jv で %p を`解決する$
◎
Resolve p with undefined.
</li>
			<li>
次を走らす`~taskを~queueする$
⇒
%~obj に向けて，名前 `timerfinished^et の`~eventを発火する$
◎
Queue a task to fire a simple event named timerfinished at the object.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>



			</section>
		</section>
		<section id="accepting-promises">
<h3 title="Accepting Promises">4.3. ~promiseの受容-法</h3>



			<section id="resolve-arguments">
<h4 title="Promise Arguments Should Be Resolved">4.3.1. ~promise引数は解決されるべきである</h4>

<div class="p">
<p>
一般に、引数が~promiseであると期待される所では、~thenable
【 `then^c ~methodを備える~obj】
も非~promise値も許容されるべきである
— 引数を利用する前に，
<em>`~promiseとして解決する$</em>
ことにより。
<em>決して</em>，次をするべきでない：
</p>

<ul>
	<li>
入力の値に対する 型~検出
</li>
	<li>
~promiseと他の値との間の`多重定義$
</li>
	<li>
~promiseを`共用体~型$ 内に置くこと
</li>
</ul>

◎
In general, when an argument is expected to be a promise, you should also allow thenables and non-promise values by resolving the argument to a promise before using it. You should never do a type-detection on the incoming value, or overload between promises and other values, or put promises in a union type.
</div>

<p>
~WebIDLを利用する仕様においては、これは，~WebIDLの`~promise型$により自動的に守られる。
~JSにおいて それが意味する所を見るため、~promiseに %ms ~msの遅延を追加する，次の関数を考える：
◎
In WebIDL-using specs, this is automatically taken care of by the WebIDL promise type. To see what it means in JavaScript, consider the following function, which adds a delay of ms milliseconds to a promise:
</p>

<div class="example">
<pre class="lang-javascript">
function addDelay(%promise, %ms) {
    return Promise.resolve(%promise).then(%v `射$
        new Promise(%resolve 射
            setTimeout(() 射 %resolve(%v), %ms);
        )
    );
}

var %p1 = addDelay(doAsyncOperation(), 500);
var %p2 = addDelay("value", 1000);
</pre>
</div>

<p>
この例においては、
%p1 は，［［
`doAsyncOperation()^c から返される %promise
］が充足されてから 500 ~ms後に，その演算の値で充足される
］ことになる（または、 %p1 は %promise が却下され次第，却下されることになる）。
また，入力の引数は`~promiseとして解決され$るので、この関数は，文字列 `value^l を渡したときにも働ける：
%p2 は、1000 ~ms後に， `value^l で充足されることになる。
このような仕方で、本質的に，それを［
値に対し即時に充足される~promise
］として扱っている。
◎
In this example, p1 will be fulfilled 500 ms after the promise returned by doAsyncOperation() fulfills, with that operation’s value. (Or p1 will reject as soon as that promise rejects.) And, since we resolve the incoming argument to a promise, the function can also work when you pass it the string "value": p2 will be fulfilled with "value" after 1000 ms. In this way, we essentially treat it as an immediately-fulfilled promise for that value.
</p>



			</section>
			<section id="should-promise-call">
<h4 title="Developer-Supplied Promise-Returning Functions Should Be &quot;Promise-Called&quot;">4.3.2. ~promiseを返す関数として開発者から給された関数は “~promise-callされる” べきである</h4>

<p>
仕様の策定者は、［［
~promiseを返す関数を期待しているもの【引数など】
］に対し，開発者から給された %関数
］に対しては、［
%関数 が~thenableや非~promise値
を返す, あるいは 例外を投出する
］ことも許容するべきである。
また、これらすべての事例に対し，［
%関数 がそれに相似的な~promise
【すなわち， %関数 の返値で解決されるか, %関数 が投出した例外で却下される~promise】
を返した
］かのように扱うべきである。
この処理は、
“ %関数 を `~promise-call$する”
と呼ばれる演算に~encapsulateできる。
これにより、同期的な形のときでも、成功／失敗に対し，非同期的な形のときと同じように反応させられる。
◎
If the developer supplies you with a function that you expect to return a promise, you should also allow it to return a thenable or non-promise value, or even throw an exception, and treat all these cases as if they had returned an analogous promise. We can encapsulate this process in an operation called promise-calling the supplied function. This allows us to have the same reaction to synchronous forms of success and failure that we would to asynchronous forms.
</p>

<p>
これを利用する方法と，何故そうすべきかについての更なる論点は、後述の
<a href="#example-resource-open">`resource.open^c 例</a>
を見よ。
◎
See the resource.open example below for further discussion of how and why this should be used.
</p>



			</section>
		</section>
	</section>
	<section id="shorthand-phrases">
<h2 title="Shorthand Phrases">5. 略記~用の句</h2>

<p class="note">
この節は、主に仕様の書手~向けである。
ここでは、共通的な各種~promise演算の遂行-法を，注釈文にてどう述べるかについて扱う。
◎
This section is primarily for spec writers, dealing with ways of performing common promise operations in prose.
</p>

<p class="note">
この節は、最終的には，~WebIDLの当該箇所に移行されるべきである。
<a href="https://github.com/w3ctag/promises-guide/issues/27">#27</a>
を見よ。
◎
This section should eventually move to WebIDL, where it belongs. See #27.
</p>

<p>
仕様を書くときは、共通的な~promise演算を簡潔に参照できると簡便である。
以下では、それを行えるようにするための，一連の略記を定義する。
◎
When writing such specifications, it’s convenient to be able to refer to common promise operations concisely. We define here a set of shorthands that allow you to do so.
</p>

<p class="trans-note">【
以下に現れる語
“充足~値”／“事由~値”
の
“充足”／“事由”
は、値の役割を明らかにするための呼称であり、値の範囲に何らかの要件を課すものではない（一部は、訳者による補完である）。
】</p>



		<section id="shorthand-creating">
<h3 title="Creating Promises">5.1. ~promiseの作成-法</h3>

<div class="p">
<p>
`新たな~promise@
とは、［
初期化されているが, まだ解決されていない，新たな~promise~obj
］を，更に操作するためのものとして与えるものである。
それは、次を~callすることに等価である
⇒
<code>new Promise((%resolve, %reject) `射$ { … })</code>
</p>

<p>
ここで：
</p>

<ul>
	<li>
`Promise()^c には、
<a href="~TC39#sec-promise-constructor">`Promise^c 構築子</a>
の`初期~値$を利用する。
</li>
	<li>
`…^c は、今後の利用
— <a href="#shorthand-manipulating">~promiseの操作-法</a>
節による略記の定義~内で利用される —
のために
%resolve ／ %reject
の値を保存する~codeを表す。
【具体的には <a href="#example-add-delay">6.3 節の~JS~code例</a>に】
</li>
</ul>

◎
"A new promise" gives a new, initialized-but-unresolved promise object to manipulate further. It is equivalent to calling new Promise((resolve, reject) =&gt; { ... }), using the initial value of the Promise constructor. Here ... stands in for code that saves the value of resolve and reject for later use by the shorthands under §5.2 Manipulating Promises.
</div>

<div class="p">
<p>
( 充足~値 %x )
が与えられている下における，句
<q>
<dfn id="a-promise-resolved-with">%x で解決される（新たな）~promise</dfn>
</q>
とは、
`Promise.resolve(x)^c による結果の~promiseを~~表す略記である
— ここで：
</p>

<ul>
	<li>
`Promise.resolve^c には、 `Promise.resolve$c の`初期~値$を利用する。
</li>
</ul>

<p>
そのような結果を得ることを、
<q>
%x を
`~promiseとして解決する@
</q>
とも記す。
</p>
◎
"A promise resolved with x" or "x resolved as a promise" is shorthand for the result of Promise.resolve(x), using the initial value of Promise.resolve.
</div>

<div class="p">
<p>
( 事由~値 %r )
が与えられている下における，句
<q>
<dfn id="a-promise-rejected-with">%r で却下される（新たな）~promise</dfn>
</q>
とは、
`Promise.reject(r)^c の結果を~~表す略記である
— ここで：
</p>

<ul>
	<li>
`Promise.reject^c には、 `Promise.reject$c の`初期~値$を利用する。
</li>
</ul>

◎
"A promise rejected with r" is shorthand for the result of Promise.reject(r), using the initial value of Promise.reject.
</div>


<p class="trans-note">【
内部ではすでに過去であっても，
“解決される” ／ “却下される”
と記しているのは、外部に対しては
%resolve ／ %reject
を通して非同期に（未来に）通達されることになるためである。
冗長に書くならば、
“解決されるのは確定しているが，まだ そのときに行う処理は呼出されていない”
等々の様になるであろう。
】</p>

<!-- from ES6
The resolve function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.

The reject function returns a new promise rejected with the passed argument.
-->

		</section>
		<section id="shorthand-manipulating">
<h3 title="Manipulating Promises">5.2. ~promiseの操作-法</h3>

<p>
( ~promise %p, 充足~値 %x )
が与えられている下における，句
<q>%x で %p を
<dfn id="resolve-promise">解決する</dfn></q>
とは、［［
%p の作成-時に格納済みの，
<a href="~TC39#sec-promise-resolve-functions">%resolve 関数</a>
］に，引数 %x を渡して~callする
］ことを表す略記である。
◎
"Resolve p with x" is shorthand for calling a previously-stored resolve function from creating p, with argument x.
</p>

<!-- 
A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.
 -->

<p>
( ~promise %p, 事由~値 %r )
が与えられている下における，句
<q>%r で %p を
`却下する@
</q>
とは、［［
%p の作成-時に格納済みの，
<a href="~TC39#sec-promise-reject-functions">%reject 関数</a>
］に，引数 %r を渡して~callする
］ことを表す略記である。
◎
"Reject p with r" is shorthand for calling a previously-stored reject function from creating p, with argument r.
</p>

<p class="trans-note">【
同じ
“解決-”, “却下-”
が、新たな~promiseを作成するときと，操作するときの両者に用いられてることに注意。
“%x で`解決される~promise$” は、
“`新たな~promise$ %p を作成してから， %x で %p を`解決-$した結果の %p”
と同じものになるように見受けられる（が、確かめたわけではない）。
】</p>

<p>
これらの略記が，`並列的$に走らせている~algoの中で利用されている場合、
%p に`関連する設定群~obj$の`担当の~event~loop$上に，格納済みの関数を~callする`~taskを~queueする$。
◎
If the algorithm using these shorthands is running in parallel, the shorthands queue a task on p’s relevant settings object’s responsible event loop to call the stored function.
</p>



		</section>
		<section id="shorthand-reacting">
<h3 title="Reacting to Promises">5.3. ~promiseに対する反応-法</h3>

<div class="p">
<p>
( ~promise %p, 充足~値 %v )
が与えられている下における，句
<q>
%v による %p の
`充足-時@
には…（ %下位手続き ）
</q>
とは、［
<code>%p.then(%onFulfilled)</code>
が
【 %onFulfilled が~callされる前に】
~callされている
］ことを表す略記である†
— ここで：
</p>

<ul>
	<li>
<code>%p.then</code> には、 `Promise.prototype.then$c の`初期~値$を利用する。
</li>
	<li>
後続して与えられる %下位手続き が %onFulfilled 関数を成す。
</li>
<!-- from ES6
When the then method is called with arguments onFulfilled and onRejected the following steps are taken:
-->
	<li>
充足~値 %v が，［
%下位手続き が %onFulfilled の引数として~accessする値
］を与える††。
</li>
</ul>

◎
"Upon fulfillment of p with value v" is shorthand for calling p.then(onFulfilled), with the successive nested steps comprising the onFulfilled function, and using the initial value of Promise.prototype.then. The steps then have access to onFulfilled’s argument as v.
</div>

<div class="p">

<p>
( ~promise %p, 事由~値 %r )
が与えられている下における，句
<q>
%r による %p の
`却下-時@
には…（ %下位手続き ）
</q>
とは、［
<code>%p.then(`undefined^jv, %onRejected)</code>
が
【 %onRejected が~callされる前に】
~callされている
］ことを表す略記である†
— ここで：
</p>


<ul>
	<li>
<code>%p.then</code> には、 `Promise.prototype.then$c の`初期~値$を利用する。
</li>
	<li>
後続して与えられる %下位手続き が %onRejected 関数を成す。
</li>
	<li>
事由~値 %r が，［
%下位手続き が %onRejected の引数として~accessする値
］を与える††。
</li>
</ul>

◎
"Upon rejection of p with reason r" is shorthand for calling p.then(undefined, onRejected), with the successive nested steps comprising the onRejected function, and using the initial value of Promise.prototype.then. The steps then have access to onRejected’s argument as r.
</div>

<div class="trans-note">【
<ul>
	<li>
<a href="#example-add-delay">これらの句の用例</a>
</li>
	<li>†
これらの句
<q>〜時には…</q>
は、
“〜されたとき”
に加えて，
“すでに〜されていたとき”
も含む
— ~algoの中で，これらの句に遭遇した時点で、当の~promiseは すでに［
充足-／却下-
］されている場合もあり得るので。
</li>
	<li>††
%下位手続き の中で，引数が利用されない場合、充足~値／事由~値が省略されて，単に
<q>%p の充足-時には…</q>
等と記されることもある。
</li>
	<li>
~promiseが
`決着-@
（ settle ）した（あるいは， “する”, “される”, 等々）という語も用いられる（他の仕様にも現れる）。
これは、~promiseが充足されたか却下された（が，まだ［
充足-時／却下-時
］の処理は行われていない）ことを表す総称を意味する。
</li>
</ul>

】</div>

<div class="p">
<p>
(
~promise %p,
充足~handler %fulfillmentHandler （省略可）,
却下~handler %rejectionHandler （省略可）
)
が与えられている下における，句
<q>
（それらの~handlerで） %p を
`変形する@
</q>
とは、［
<code>%p.then(%fulfillmentHandler, %rejectionHandler)</code>
を~callする
］ことを表す略記である
— ここで：
</p>

<ul>
	<li>
<code>%p.then</code> には、 `Promise.prototype.then$c の`初期~値$を利用する。
</li>
	<li class="trans-note">【
充足~handler／却下~handlerが省略されている場合、
`undefined^jv として扱うものと見られる。
（両者とも省略されることはまず無いであろうが。）
】</li>
</ul>
◎
"Transforming p with a fulfillment and/or rejection handler" is shorthand for calling p.then(fulfillmentHandler, rejectionHandler), using the initial value of Promise.prototype.then.
</div>

<div class="example">
<p>
後者の句の例を挙げる：
◎
Some examples of the latter phrase would be
</p>

<ol>
	<li>
［
`undefined^jv を返す 充足~handler
］で %p を`変形した$結果を返す。
◎
Return the result of transforming p with a fulfillment handler that returns undefined.
</li>
</ol>

<p>
あるいは
◎
or
</p>

<ol>
	<li>
［
第一~引数の二倍を返す 充足~handler
］で %p を`変形した$結果を返す。
◎
Return the result of transforming p with a fulfillment handler that returns twice its first argument.
</li>
</ol>

<p>
これらは順に、次に対応する：
◎
These correspond to
</p>

<pre class="lang-javascript">
return %p.then(() `射$ undefined);
</pre>

<p>
,
◎
and
</p>
<pre class="lang-javascript">
return %p.then(%x 射 2 * %x);
</pre>

<p>
（もちろん，もっと複雑な変形-もアリになる
— 下の
<a href="#example-resource-open">`resource.open^c 例</a>
に示されるように。）
◎
respectively. (More complicated transforms are of course possible as well, as shown in the resource.open example below.)
</p>
</div>



		</section>
		<section id="aggregating-promises">
<h3 title="Aggregating Promises">5.4. 複数の~promiseの集成-法</h3>

<div class="algorithm">
<p>
`すべての~promiseを待機する@
ときは、所与の
( %~promise~list, %成功~手続き, %失敗~手続き )
に対し，次の手続きを遂行する：
◎
To wait for all of a list of promises promises, with success steps successSteps that take a list of JavaScript values and failure steps failureSteps that take a rejection reason JavaScript value, perform the following steps:
</p>

<ol>
	<li>
~Assert
⇒＃
%~promise~list は~promiseの`~list$である,
%成功~手続き は ( ~JS値の`~list$ ) を引数にとる手続きである,
%失敗~手続き は ( 却下~事由を表す~JS値 ) を引数にとる手続きである
◎
↑</li>
	<li>
%充足d回数 ~LET 0
◎
Let fullfilledCount be 0.
</li>
	<li>
%却下-済み ~LET ~F
◎
Let rejected be false.
</li>
	<li>
<p>
%却下~handler ~LET 所与の引数 ( %~arg ) に対し，次の手続きを遂行する組込みの関数：
◎
Let rejectionHandler be a built-in function that takes an argument arg and performs the following steps:
</p>
		<ol>
			<li>
~IF［
%却下-済み ~EQ ~T
］
⇒
~RET
◎
If rejected is true, abort these steps.
</li>
			<li>
%却下-済み ~SET ~T
◎
Set rejected to true.
</li>
			<li>
次を遂行する
⇒
%失敗~手続き( %~arg )
◎
Perform failureSteps given arg.
</li>
		</ol>
	</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
%合計 ~LET %~promise~list の`~size$
◎
Let total be promises’s size.
</li>
	<li>
%結果 ~LET %合計 個の ~NULL 値からなる新たな`~list$
◎
Let result be a list containing total null values.
</li>
	<li>
<p>
%~promise~list を成す
~EACH( %~promise )
に対し：
◎
For each promise of promises:
</p>
		<ol>
			<li>
%~promise~index ~LET %~index
◎
Let promiseIndex be index.
</li>
			<li>
<p>
%充足~handler ~LET 所与の引数 ( %~arg ) に対し，次の手続きを遂行する，組込みの関数：
◎
Let fulfillmentHandler be a built-in function that takes an argument arg performs the following steps:
</p>
				<ol>
					<li>
%結果[ %~promise~index ] ~SET %~arg
◎
Set result[promiseIndex] to arg.
</li>
					<li>
%充足d回数 ~INCBY 1
◎
Set fullfilledCount to fullfilledCount + 1.
</li>
					<li>
~IF［
%充足d回数 ~EQ %合計
］
⇒
次を遂行する
⇒
%成功~手続き( %結果 )
◎
If fullfilledCount equals total, then perform successSteps given result.
</li>
				</ol>
			</li>
			<li>
次を遂行する
⇒
`PerformPromiseThen$jA( %~promise, %充足~handler, %却下~handler )
◎
Perform PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler).
</li>
			<li>
%~index ~INCBY 1
◎
Set index to index + 1.
</li>
		</ol>
	</li>
</ol>

<p>
この句は、~JS~code用の `Promise.all()$c 関数と同じ仕方で，［
複数の~promiseの結果を集成して，それらに対し一まとめに反応させたいと望むとき
］に有用になる。
◎
This phrase is useful when you wish to aggregate the result of multiple promises, and react to them all together, in the same way that Promise.all() functions for JavaScript code.
</p>
</div>

<div class="algorithm">
<p>
`すべてを待機する~promiseを取得する@
ときは、所与の
( %~promise~list, %成功~手続き, %失敗~手続き（省略時は ε ） )
に対し，次の手続きを遂行する：
◎
To get a promise for waiting for all of a list of promises promises, with success steps successSteps that take a list of JavaScript values and optional failure steps failureSteps that take a rejection reason JavaScript value, perform the following steps:
</p>

<ol>
	<li>
~Assert
⇒＃
%~promise~list は~promiseの`~list$である,
%成功~手続き は ( ~JS値の`~list$ ) を引数にとる手続きである,
省略可能な %失敗~手続き は ( 却下~事由を表す~JS値 ) を引数にとる手続きである
◎
↑</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
~IF［
%失敗~手続き ~EQ ε
］
⇒
%失敗~手続き ~SET 所与の引数 ( %~arg ) に対し，次を遂行する手続き
⇒
~THROW %~arg
◎
If failureSteps were not given, let them be steps taking an argument arg that throw arg.
</li>
	<li>
<p>
%成功~手続き~wrapper ~LET 所与の
( %結果~list )
に対し，次を遂行する手続き：
◎
Let successStepsWrapper be the following steps, given results:
</p>
		<ol>
			<li>
%手続きの結果 ~LET 次を遂行した結果
⇒
%成功~手続き( %結果~list )
【手続きが値を返さない場合の結果は、暗黙的に `undefined^jv ？】
◎
Let stepsResult be the result of performing successSteps given results.＼
</li>
			<li>
~IF［
前~段にて例外が投出された
］
⇒
その例外で %~promise を`却下する$
◎
If these steps threw an exception, reject promise with that exception.
</li>
			<li>
~ELSE
⇒
%手続きの結果 で %~promise を`解決する$
◎
Resolve promise with stepsResult.
</li>
		</ol>
	</li>
	<li>
<p>
%失敗~手続き~wrapper ~LET 所与の
( %事由 )
に対し，次を遂行する手続き：
◎
Let failureStepsWrapper be the following steps, given reason:
</p>
		<ol>
			<li>
%手続きの結果 ~LET 次を遂行した結果
⇒
%失敗~手続き( %事由 )
◎
Let stepsResult be the result of performing failureSteps given reason.＼
</li>
			<li>
~IF［
前~段にて例外が投出された
］
⇒
その例外で %~promise を`却下する$
◎
If these steps threw an exception, reject promise with that exception.
</li>
			<li>
~ELSE
⇒
%手続きの結果 で %~promise を`解決する$
◎
Resolve promise with stepsResult.
</li>
		</ol>
	</li>
	<li>
`すべての~promiseを待機する$( %~promise~list, %成功~手続き~wrapper, %失敗~手続き~wrapper )
◎
Wait for all of promises, given successStepsWrapper and failureStepsWrapper.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p>
この句は、複数の~promiseの結果を集成して，それらから別の~promiseを生産したいと望むときに有用になる。
◎
This phrase is useful when you wish to aggregate the results of multiple promises, and then produce another promise from them.
</p>

<p>
この句の用法~例は
<a href="#example-batch-request">`batchRequest( urls )^c 節</a>
に見出せる。
◎
An example usage of this phrase is found in §6.7 batchRequest(urls).
</p>
</div>

		</section>
		<section id="shorthand-promise-calling">
<h3 title="Promise-Calling">5.5. ~promise-call法</h3>

<p>
関数 %f が与えられた下で，
<q>
<code>%f( `...args^V )</code> を
<dfn id="promise-calling">~promise-call</dfn>
</q>
したときの結果は、次で与えられる：
◎
The result of promise-calling f(...args) is:
</p>

<ul>

	<li>
%f を~callして充足~値 %v が返されたならば
⇒
%v で`解決される~promise$
◎
If the call returns a value v, the result of resolving v as a promise.
</li>
	<li>
%f を~callして例外 %e が投出されたならば
⇒
%e で`却下される~promise$
◎
If the call throws an exception e, a promise rejected with e.
</li>
</ul>

<div class="note" id="promise-call-in-js">
<p>
~JSでは、~promise-callは，次のように表出できよう：
◎
In JavaScript, you might express promise-calling this way:
</p>

<pre class="lang-javascript">
function promiseCall(%f, `...args^V ) {
    try {
        return Promise.resolve(%f(`...args^V));
    } catch (%e) {
        return Promise.reject(%e);
    }
}
</pre>
</div>



		</section>
		<section id="shorthand-note-onrealms">
<h3 title="A Note on Realms">5.6. ~realmについての注記</h3>

<p>
すべての事例において、
<q>
<code>Promise.resolve</code> の
`初期~値@
</q>
の様な句を利用するときは、［［［
指定されている関数（この場合は `resolve^c ）
］に結付けられている`~realm$†
］の中での初期~値
］を意味する。
例えば、
`window.f()^c が
“`1^jv で`解決される~promise$”
を返すものと指定されている場合：
◎
In all cases, when we use phrases like "the initial value of Promise.resolve," we mean the initial value within the realm associated to the function being specified. So for example, if window.f() is specified to return "a promise resolved with 1," then:
</p>

<p class="trans-note">【†
“~~領域” — 大雑把に言えば、［
当の~codeが参照している, または作成した，~obj／関数
］が “属する” ECMAScript 大域環境
】</p>

<pre class="lang-javascript">
assert(windowA.f().constructor === windowA.Promise);
assert(windowB.f().constructor === windowB.Promise);

/* <span class="comment">
関数が呼出されている~objの~realmは、効果を持たない
— 関数の~realmだけが，関係0する：
◎
The realm of the object the function is being invoked on has no effect;
the function’s realm is all that matters.
</span>*/
assert(windowA.f.call(windowB).constructor === windowA.Promise);

/* <span class="comment">
次のものは、~promise構築子に対する変異も伝播することを意味する：
◎
This means mutations to the Promise constructor also propagate.
</span>*/

windowA.Promise.prototype.foo = "bar";
assert(windowA.f().foo === "bar");
assert(windowB.f().foo === undefined);

/* <span class="comment">
`Promise.resolve^c の~algoは、~globalを診る代わりに，内在的な, 改変-不能な `~Promise0$ を利用するので、
名前 `Promise^l の~global~propertyを改変しても，返値には影響0しない
◎
But since the algorithm for Promise.resolve uses the un-modifiable %Promise% intrinsic, instead of consulting the global, modifying the global property named
"Promise" does not impact the return value.
</span>*/
const %oldPromise = windowA.Promise;
windowA.Promise = () `射$ throw new Error(
    "<span
	title="I break developer code, but not platform code!"
	>開発者~codeは壊しますが，~platform~codeは壊しません。</span>"
);
assert(windowA.f().constructor !== windowA.Promise);
assert(windowA.f().constructor === %oldPromise);
</pre>

<p>
更なる情報については、
<a href="https://lists.w3.org/Archives/Public/www-tag/2014Jan/0108.html">この www-tag ~thread</a>
を見よ — とりわけ返信を。
◎
For more information, see this www-tag thread, especially the replies.
</p>



		</section>
	</section>
	<section id="examples">
<h2 title="Examples">6. 例</h2>

<p class="note">
この節は、ほぼ仕様の書手~向けであるが、仕様の注釈文を~JSに翻訳した例も与える。
◎
This section is mostly for spec writers, although it does give examples of the spec prose translated into JavaScript.
</p>



		<section id="example-delay">
<h3>6.1. `delay( ms )^c</h3>

<p>
`delay^c は、 %ms ~ms内に充足されることになる，~promiseを返す関数である。
~promiseの解決は，一~行の注釈文で記せる：
◎
delay is a function that returns a promise that will be fulfilled in ms milliseconds. It illustrates how simply you can resolve a promise, with one line of prose.
</p>

<ol>

	<li>
%ms ~LET ToNumber(%ms)
◎
Let ms be ToNumber(ms).
</li>
	<li>
%ms ~LET ［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ { %ms, `+0^jv } の最大
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きを`並列的$に走らせる：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~ms間 待機する
◎
Wait ms milliseconds.
</li>
			<li>
`undefined^jv で %p を`解決する$
◎
Resolve p with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p>
~JSによる等価な関数は，次の様になるであろう：
◎
The equivalent function in JavaScript would be
</p>

<pre class="lang-javascript">
function delay(%ms) {
    %ms = Number(%ms);
    %ms = Number.isNaN(%ms) ? +0 : Math.max(%ms, +0);
    return new Promise(%resolve `射$ setTimeout(%resolve, %ms));
}
</pre>

<p>
あるいは、指定された手続きに，より一対一に対応するように記すなら：
◎
or, in a more one-to-one correspondence with the specified steps,
</p>

<pre class="lang-javascript">
function delay(%ms) {
    // <span class="comment" title="Steps 1, 2"
	>段 1, 2</span>
    %ms = Number(%ms);
    %ms = Number.isNaN(%ms) ? +0 : Math.max(%ms, +0);

    // <span class="comment" title="Step 3"
	>段 3</span>
    let %resolve;
    const %p = new Promise(%r 射 { %resolve = %r; });

    // <span class="comment" title="Step 4"
	>段 4</span>
    setTimeout(() 射 %resolve(undefined), %ms);

    // <span class="comment" title="Step 5"
	>段 5</span>
    return %p;
}
</pre>



		</section>
		<section id="example-validated-delay">
<h3>6.2. `validateddelay( ms )^c</h3>

<p>
`validatedDelay^c 関数は、その引数を検証することになる点を除いて，
<a href="#example-delay">`delay^c 関数</a>
とほぼ同様である。
これは、どの非同期的な演算であれ、その開始~前に即時の失敗を通達させるために，却下される~promiseを利用する方法を示す：
◎
The validatedDelay function is much like the delay function, except it will validate its arguments. This shows how to use rejected promises to signal immediate failure before even starting any asynchronous operations.
</p>

<ol>

	<li>
%ms ~LET ToNumber(%ms)
◎
Let ms be ToNumber(ms).
</li>
	<li>
~IF［
%ms ~EQ `NaN^jv
］
⇒
~RET
`TypeError^jv で`却下される~promise$
◎
If ms is NaN, return a promise rejected with a TypeError.
</li>
	<li>
~IF［
%ms ~LT ~zero
］
⇒
~RET `RangeError^jv で`却下される~promise$
◎
If ms is less than zero, return a promise rejected with a RangeError.
</li>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きを`並列的$に走らせる：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~ms間 待機する
◎
Wait ms milliseconds.
</li>
			<li>
`undefined^jv で %p を`解決する$
◎
Resolve p with undefined.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p>
~JSによる等価な関数は，次の様になるであろう：
◎
The equivalent function in JavaScript would be
</p>

<pre class="lang-javascript">
function delay(%ms) {
    %ms = Number(%ms);

    if (Number.isNaN(%ms)) {
        return Promise.reject(new TypeError("Not a number."));
    }
    if (%ms &lt; 0) {
        return Promise.reject(new RangeError("ms must be at least zero."));
    }

    return new Promise(%resolve `射$ setTimeout(%resolve, %ms));
}
</pre>



		</section>
		<section id="example-add-delay">
<h3>6.3. `addDelay( promise, ms )^c</h3>

<p>
`addDelay^c は、引数 %promise が`決着-$してから，返される~promiseが`決着-$するまでの合間に
余分な %ms ~msの遅延を追加する関数である。
引数 %promise を`~promiseとして解決する$ことで、非~promise値や~thenableも %promise に渡せるようにしている所に注目。
◎
addDelay is a function that adds an extra ms milliseconds of delay between promise settling and the returned promise settling. Notice how it resolves the incoming argument to a promise, so that you could pass it a non-promise value or a thenable.
</p>

<ol>
	<li>
%ms ~LET ToNumber(%ms)
◎
Let ms be ToNumber(ms).
</li>
	<li>
%ms ~LET［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ { %ms, `+0^jv } の最大
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
%resolvedToPromise ~LET %promise で`解決される~promise$
◎
Let resolvedToPromise be the result of resolving promise to a promise.
</li>
	<li>
<p>
充足~値 %v による
%resolvedToPromise の`充足-時$には、次の手続きを`並列的$に遂行する：
◎
Upon fulfillment of resolvedToPromise with value v, perform the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~ms間 待機する
◎
Wait ms milliseconds.
</li>
			<li>
%v で %p を`解決する$
◎
Resolve p with v.
</li>
		</ol>
	</li>
	<li>
<p>
事由~値 %r による %resolvedToPromise の`却下-時$には、次の手続きを`並列的$に遂行する：
◎
Upon rejection of resolvedToPromise with reason r, perform the following steps in parallel:
</p>

		<ol>
			<li>
%ms ~ms間 待機する
◎
Wait ms milliseconds.
</li>
			<li>
%r で %p を`却下する$
◎
Reject p with r.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>


<p>
~JSによる等価な関数は，次の様になるであろう：
◎
The equivalent function in JavaScript would be
</p>

<pre class="lang-javascript">
function addDelay(%promise, %ms) {
    %ms = Number(%ms);
    %ms = Number.isNaN(%ms) ? +0 : Math.max(%ms, +0);

    let %resolve, %reject;
    const %p = new Promise((%r, %rr) `射$ { %resolve = %r; %reject = %rr; });

    const resolvedToPromise = Promise.resolve(%promise);
    resolvedToPromise.then(
        %v 射 setTimeout(() 射 %resolve(%v), %ms),
        %r 射 setTimeout(() 射 %reject(%r), %ms)
    );

    return %p;
}
</pre>



		</section>
		<section id="example-resource-open">
<h3>6.4. `resource.open ( resourcePath, openingOperation )^c</h3>

<p>
`resource.open^c
は、［
その働きのほとんどは，渡された関数 %openingOperation の実行-が占める
］が、しかる~~後，［
この演算の結果を反映するように `resource^c の~propertyたちを更新する
］ような，~methodである。
これは、［
Streams 仕様にて用いられている一部の技法
］の，単純化された~versionである。
この~methodは、別の関数を `~promise-call$ する方法, その理由について説明0するために~~導入したものである。
◎
resource.open is a method that executes the passed function openingOperation to do most of its work, but then updates the resource’s properties to reflect the result of this operation. It is a simplified version of some of the techniques used in the streams specification. The method is meant to illustrate how and why you might promise-call another function.
</p>

<ol>

	<li>
%resourcePath ~LET ToString(%resourcePath)
◎
Let resourcePath be ToString(resourcePath).
</li>
	<li>
%openingPromise ~LET
%openingOperation(%resourcePath)
を`~promise-call$した結果
◎
Let openingPromise be the result of promise-calling openingOperation(resourcePath).
</li>
	<li>
<p>
~RET 次の~handlerで %openingPromise を`変形した$結果：
◎
Return the result of transforming openingPromise with:
</p>
		<ul>
			<li>
［
`this.status^c ~SET `opened^l
］にするような，充足~handler。
◎
A fulfillment handler that sets this.status to "opened".
</li>
			<li>
引数 %r を伴って~callされたときに［
`this.status^c ~SET `errored^l；
`this.error^c ~SET %r
］にするような，却下~handler。
◎
A rejection handler that, when called with argument r, set this.status to "errored" and this.error to r.
</li>
		</ul>
	</li>
</ol>

<p>
<a href="#promise-call-in-js">上に定義された `promiseCall^c 関数</a>
を利用すれば、~JSによる等価な関数は，次の様になるであろう：
◎
The equivalent function in JavaScript would be
</p>

<pre class="lang-javascript">
resource.open = function (%resourcePath, %openingOperation) {
    %resourcePath = String(%resourcePath);

    return promiseCall(%openingOperation, %resourcePath).then(
        %v `射$ {
            this.status = "opened";
        },
        %r 射 {
            this.status = "errored";
            this.error = %r;
        }
    );
};
</pre>

<p>
◎
using the promiseCall function defined above.
</p>

<div class="note">
<p>注記：
単に %openingOperation を~callしていないことに注意
— すなわち，直に
<code>%openingOperation(%resourcePath)</code>
を行うことにするなら、~codeは次の様になるが：
◎
Note how if we had instead just called openingOperation, i.e. done openingOperation(resourcePath) directly, then code like
</p>

<pre class="lang-javascript">
resource.open(%synchronouslyOpenTheResource).then(%doSomethingElse);
</pre>

<p>
それは~promiseを返さないので、返値~上で `then^c を~callするときに失敗することになる。
それを加味したとしても，
%synchronouslyOpenTheResource が~errorを投出したときはどうするか？
結果が `errored^l ~statusになるように欲するが、`~promise-call$しなければ、その~errorにより，単純に `resource.open^c から抜出ることになってしまう。
ここでは、`~promise-call$が とても役立つことが見れる。
◎
would fail. It would not return a promise, so calling then on the return value would fail. Even if we accounted for that, what if synchronouslyOpenTheResource threw an error? We would want that to result in an "errored" status, but without promise-calling, that would not be the case: the error would simply cause resource.open to exit. So you can see that promise-calling is quite helpful here.
</p>
</div>



		</section>
		<section id="example-environment-ready">
<h3>6.5. %environment`.ready^c</h3>

<p>
ある “環境” を表現する
`Environment^c ~obj %environment の
`ready^c ~methodは、環境の何らかの部分
— 例えば，~DOM文書 —
が “~ready（準備済み）” になったときに，それを通達する~propertyであるとする。
ここでは、その環境における非同時性について~~定式化する方法を説明0する：
◎
environment.ready is a property that signals when some part of some environment becomes "ready," e.g. a DOM document. It illustrates how to encode environmental asynchronicity.
</p>

<ul>
	<li>
どの `Environment^c ~objも，［
新たな~promiseに初期化される， [[ready]] 内部slot
］を有するようにする。
%environment の `ready^c 取得子が~callされたときは、この `Environment^c ~objの [[ready]] 内部slotの値が返されるとする。
◎
Let every Environment object have a [[ready]] internal slot, initialized with a new promise. When the getter for environment.ready is called, return the value of this Environment object’s [[ready]] internal slot.
</li>
	<li>
<p>
次の各~段が `Environment^c ~objを~readyにするような，ある~algoの末尾側に挿入されることになるであろう：
◎
The following steps might be inserted toward the end of some algorithm for readying Environment objects:
</p>
		<ul>
			<li>
当の環境が成功裡に~readyになったときは
⇒
`undefined^jv で［
`Environment^c ~obj の [[ready]] ~promise
］を`解決する$
◎
If the environment becomes ready successfully, resolve this Environment object’s [[ready]] promise with undefined.
</li>
			<li>
当の環境が~readyになるのに失敗したときは
⇒
［
~load失敗を説明する `Error^jv ~instance
］で［
`Environment^c ~obj の [[ready]] ~promise
］を`却下する$
◎
If the environment fails to become ready, reject this Environment object’s [[ready]] promise with an Error instance explaining the load failure.
</li>
		</ul>
	</li>
</ul>


		</section>
		<section id="example-add-bookmark">
<h3>6.6. `addBookmark()^c</h3>

<p>
`addBookmark^c は、［
現在の~web頁を~bookmarkとして追加する
］ことを利用者に要請する，関数である。
これは、
<a href="https://github.com/domenic/promises-unwrapping/issues/85">何度も行われる設計~作業</a>
から取り出されたものであり、
環境上の非同時性を，現実にありそうな局面として解ってもらうと伴に、即時の却下についても説明0するものである。
◎
addBookmark is a function that requests that the user add the current web page as a bookmark. It’s drawn from some iterative design work and illustrates a more real-world scenario of appealing to environmental asynchrony, as well as immediate rejections.
</p>

<ol>
	<li>
~IF［
この~methodは、明示的な利用者~動作の結果として，呼出された
］のではない
⇒
~RET ［
名前 `SecurityError^l の新たな `DOMException$c
］で`却下される~promise$
◎
If this method was not invoked as a result of explicit user action, return a promise rejected with a new DOMException whose name is "SecurityError".
</li>
	<li>
<p>
~IF［
文書の［
mode of operation†
］ ~EQ standalone††
］
⇒
~RET ［
名前 `NotSupported^l の新たな `DOMException$c
］で`却下される~promise$
◎
If the document’s mode of operation is standalone, return a promise rejected with a new DOMException whose name is "NotSupported".
</p>

【† <a href="~MANIFEST#dfn-display-mode">display mode</a>, ††<a href="~MANIFEST#dfn-display-modes-values">standalone</a> ？】
</li>
	<li>
%promise ~LET 新たな~promise
◎
Let promise be a new promise.
</li>
	<li>
%info ~LET ［
~web~appの~metadata
］を得た結果
◎
Let info be the result of getting a web application’s metadata.
</li>
	<li>
<p>
次の手続きを`並列的$に走らせる：
◎
Run the following steps in parallel:
</p>

		<ol>
			<li>
<p>
%info を用いて, ~UAに特有の方式で，［
末端利用者が~bookmarkを追加したいと欲するかどうか，選択する
］ことを許容する
◎
Using info, and in a manner that is user-agent specific, allow the end user to make a choice as to whether they want to add the bookmark.
</p>
				<ol>
					<li>
~IF［
末端利用者は
~bookmarkの追加-要請を中止した（利用者が~escapeキーを叩いた, “~cancel” ~buttonを押したなど）
］
⇒
［
名前 `AbortError^l の新たな `DOMException$c
］で %promise を`却下する$
◎
If the end-user aborts the request to add the bookmark (e.g., they hit escape, or press a "cancel" button), reject promise with a new DOMException whose name is "AbortError".
</li>
					<li>
~ELSE
⇒
`undefined^jv で %promise を`解決する$
◎
Otherwise, resolve promise with undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>



		</section>
		<section id="example-batch-request">
<h3>6.7. `batchRequest( urls )^c</h3>

<p>
`SERVICE-WORKERS$r では、何箇所かで
“`すべてを待機する~promiseを取得する$”
が利用されている。
`batchRequest^c †は、その種のある利用を単純化した~versionを説明0する。
それは、何個かの~URLからなる`~list$を入力にとり，各~URLを~fetchして作成された `Response$c ~objからなる配列に対する~promiseを返す。
いずれかの~fetchが失敗した場合には、その失敗で`却下される~promise$を返す。
◎
Several places in [SERVICE-WORKERS] use get a promise to wait for all. batchRequest illustrates a simplified version of one of their uses. It takes as input a list of URLs, and returns a promise for an array of Response objects created by fetching the corresponding URL. If any of the fetches fail, it will return a promise rejected with that failure.
</p>

<p class="trans-note">【†
`batchRequest^c は、現在の仕様には無い。
おそらく、別名の~method（ `addAll^c ？）に置き換えられている。
】</p>

<ol>
	<li>
%応答~promiseたち ~LET 新たな空`~list$
◎
Let responsePromises be a new empty list
</li>
	<li>
<p>
%urls を成す
~EACH( 値 %url )
に対し：
◎
For each value url of urls,
</p>
		<ol>
			<li>
%url ~LET %url を `USVString$c に変換した結果
◎
Let url be the result of converting url to a USVString.
</li>
			<li>
%req ~LET 新たな `Request$c を，その構築子に %url を渡して作成した結果
◎
Let req be the result of creating a new Request passing url to the constructor.
</li>
			<li>
%p ~LET %req を引数に `fetch()$c を~callした結果
◎
Let p be the result of calling fetch() with req.
</li>
			<li>
%応答~promiseたち に %p を追加する
◎
Add p to responsePromises.
</li>
		</ol>
	</li>
	<li>
~RET `すべてを待機する~promiseを取得する$( %応答~promiseたち, 次を行う成功~手続き )
⇒
手続きは、所与の ( %~list ) に対し， %~list を~JS `Array^c に変換した結果を返す
◎
Return the result of getting a promise to wait for all of responsePromises, given success steps that take results and returns the result of converting that list into a JavaScript Array.
</li>
</ol>



		</section>
	</section>
	<section id="webidl">
<h2 title="WebIDL and Promises">7. ~WebIDLと~promise</h2>

<p class="note">
この節は，主に仕様の書手~向けであり、~promiseを，~web仕様にてよく利用される~interface定義~言語と統合する方法について扱う。
◎
This section is primarily for spec writers, dealing with how promises integrate with an interface definition language often used in web specs.
</p>

<p>
`WEBIDL$r は`~PromiseT$ 型を供する
— それは、~WebIDLを通してそれらの~APIを公開するような仕様を書くときに，利用できる。
参照し易くするため、~PromiseT 型が及ぼす影響0を，ここに要約する。
◎
[WEBIDL] provides a Promise&lt;T&gt; type which can be used when writing specifications that expose their API through WebIDL. We summarize the impact of Promise&lt;T&gt; here for easy reference.
</p>



		<section id="webidl-promise-return-values">
<h3 title="Promise&lt;T&gt; Return Values">7.1. ~PromiseT 型の返値</h3>

<p>
すべての~WebIDL返値と同様、返値として~PromiseT 型を宣言することは、~algoの値を返す実際の段には，影響0しない。
それは単純に書式上のものであり、［
~promiseでない何か, または
~WebIDL %T 型でない充足~値による~promise
］を返すように仕様を書くことは、不正になる。
◎
Like all WebIDL return values, declaring a return value of type Promise&lt;T&gt; has no impact on the algorithm’s actual return steps. It is simply a form of documentation, and if you return something that is not a promise or is a promise with a fulfillment value that is not of WebIDL-type T, then you have written incorrect documentation into your spec.
</p>

<p>
しかしながら、［
~methodや~accessorを，~promiseを返すように宣言する
］ことには、一つの重要な影響0がある：
それは、［
さもなければ
— 例えば，型~変換に失敗した結果として —
投出されるような例外が、必ず~catchされ，却下される~promiseに転換される
］ようにする（ ~WebIDLの
<a href="~WEBIDL#es-operations">“演算” 節</a>
の
“`If O has a return type that is a promise type …^en”
【“〜の返値~型が~promise型であるならば…”】
の所, および その文書~~全体に散らばる，それに類する句を見よ）。
これにより、少なくとも例外については、［
<a href="#always-return-promises">~promiseを返す関数は，常に~promiseを返すべきである</a>
］原則は，自動的に守られることになる。
◎
However, declaring that your method or accessor returns a promise does have one important impact: it ensures that any exceptions that it would otherwise throw, e.g. as a result of failed type conversions, are caught and turned into rejected promises. (See the "Operations" section, "If O has a return type that is a promise type …", and similar phrases scattered throughout the document.) This automatically takes care of the advice in §4.1.1 Promise-Returning Functions Should Always Return Promises, at least for exceptions.
</p>



		</section>
		<section id="webidl-promise-parameters">
<h3 title="Promise&lt;T&gt; Parameters">7.2. ~PromiseT 型の~parameter</h3>

<p>
~WebIDL~methodの~parameterが ~PromiseT 型として宣言されているとき、その~parameterとして渡された どの引数も自動的に`~promiseとして解決され$、
<a href="#resolve-arguments">~promise引数は解決されるべきである</a>
原則は守られることになる。
◎
When a parameter of a WebIDL method is declared as Promise&lt;T&gt;, it will automatically resolve any arguments passed in that position. This will take care of the "Promise Arguments Should Be Resolved" advice above.
</p>

<p>
~WebIDL ~PromiseT 型の引数が得られたなら、~WebIDLによる
“<a href="~WEBIDL#dfn-perform-steps-once-promise-is-settled">~promiseが決着したときの手続きを遂行する</a>”
~algoを利用できる。
これは、上の
`充足-時$には…／`却下-時$には…
の略記~句とよく似るが、 “充足-時には” の手続きを走らす前に，［
~promiseの充足~値を~WebIDL型 %T に変換する
］段も追加されている。
加えて、仕様の~algoが［
前者／後者の手続きを走らせて導出される，~promise
］を返すようにもする。
型~変換に失敗した場合、~algoは［
それを失敗させた~error
］で却下される~promiseを返すようにする。
◎
If you have a WebIDL Promise&lt;T&gt; argument, you can use the WebIDL perform some steps once a promise is settled algorithm. This is much like our upon fulfillment … and upon rejection … shorthand phrases above, but it will add an additional step of converting the promise’s fulfillment value to the WebIDL type T before running any upon-fulfillment steps. Additionally it causes your algorithm to return a promise derived from running those steps. If the type conversion fails, your algorithm will return a promise rejected with the error causing that failure.
</p>

<p>
ここでの %T は、 <em>充足~値の</em> ~WebIDL型を指すことに注意。
更には、~WebIDLの
“~promiseが`決着-$したときの手続きを遂行する”
~algoを利用する場合にのみ，影響0するものであり、他の仕方で~promiseを利用する場合（別の関数を通して それを渡すなど）は，そうならない。
型が何でもよければ、 `Promise&lt;any&gt;^c 型を~parameterに利用することを勧める。
◎
Note that the T here refers to a WebIDL type for the fulfillment value. Furthermore, it only has impact if you use the WebIDL "perform some steps …" algorithm, and not if you use the promise in other ways (such as passing it along to another function). If that is not relevant, we advise using Promise&lt;any&gt; for parameters.
</p>

<div class="note">
<p>
解決の挙動の帰結として、~PromiseT 型の~parameterは，他のいかなる~parameterとも`多重定義$し得ない。
例えば、次のように宣言することはできない：
◎
As a consequence of the resolution behavior, Promise&lt;T&gt; parameters cannot be overloaded with any other parameters. For example, you cannot do:
</p>

<pre class="idl">
// <span class="comment" title="INVALID WEBIDL">妥当でない~WebIDL</span>
void f(Promise&lt;DOMString&gt; %x);
void f(DOMString %y);
</pre></div>


		</section>
		<section id="webidl-developer-functions-returning-promises">
<h3 title="Developer Functions Returning Promises">7.3. ~promiseを返す開発者~関数</h3>

<p>
~WebIDLにおいては、`~callback関数$として宣言することにより（または、稀な事例では`~callback~interface$を介して）、~JS関数を~~引数にとれるようになる。
それは後に、~WebIDL値の~listを~~引数に
<a href="~WEBIDL#es-invoking-callback-functions">呼出される</a>。
◎
In WebIDL, you consume JavaScript functions by declaring them as WebIDL callback functions (or, in rare cases, via callback interfaces) and later invoking them with a list of WebIDL values.
</p>

<p>
~WebIDLの仕組みを利用して~JS関数を~callすることにした場合、呼出~algoにおいては、自動的に返値を［
~promiseとして解決する, あるいは
例外が投出されたなら却下される~promiseに変換する
］ことになり、［
<a href="#should-promise-call">~promiseを返す関数として開発者から給された関数は “~promise-callされる” べきである</a>
］原則は，自動的に守られることになる。
◎
If you use WebIDL’s mechanisms for calling JavaScript functions, the invocation algorithm will automatically resolve return values and convert thrown exceptions into rejected promises. This automatically takes care of the advice in §4.3.2 Developer-Supplied Promise-Returning Functions Should Be "Promise-Called".
</p>



		</section>
		<section id="webidl-examples">
<h3 title="Examples">7.4. 例</h3>

<div class="example">
<p>
~promiseを返す~method：
◎
Promise-returning methods:
</p>

<pre class="idl">
interface ProtectedResource {
  Promise&lt;void&gt; requestAccess();
  // ...
};

interface Quoter {
  Promise&lt;DOMString&gt; getInterestingQuote();
};
</pre>
</div>

<div class="example">
<p>
~promiseを返す~property：
◎
Promise-returning properties
</p>

<pre class="idl">
interface StateMachine {
  readonly attribute Promise&lt;void&gt; loaded;

  Promise&lt;void&gt; load();
};
</pre>
</div>

<div class="example">
<p>
~promiseを受容する~method：
◎
Promise-accepting methods
</p>

<pre class="idl">
interface Waiter {
  void waitUntil(Promise&lt;any&gt; %promise);
};
</pre>
</div>

<div class="example">
<p>
~promiseを返す開発者~関数
◎
Promise-returning developer functions
</p>

<pre class="idl">
callback Promise&lt;DOMString&gt; ResourceLoader();

interface ResourceConsumer {
  void loadAndConsumeResource(ResourceLoader %loader);
};
</pre>
</div>

		</section>
	</section>
	<section id="legacy">

<h2 title="Appendix: Legacy APIs for Asynchronicity">付録： 旧来の非同期 API </h2>

<p>
多くの~web~platform API は、~promiseの到来より前に書かれているため、自前の場当たり的な仕方で，非同期的 演算の［
完了／失敗
］を通達している。
これらには次のものが含まれる：
◎
Many web platform APIs were written before the advent of promises, and thus came up with their own ad-hoc ways of signaling asynchronous operation completion or failure. These include:
</p>


<ul>
	<li>
IndexedDB のいくつかの~methodは、［
`onsuccess^c, `onerror^c
］~event~handlerを伴う `IDBRequest$c ~objを返す。
◎
IndexedDB returning IDBRequest objects, with their onsuccess and onerror events
</li>
	<li>
File System API の
<a href="http://www.w3.org/TR/file-system-api/#methods">`methods^c</a>
【？】は、~parameterに種々の
`successCallback^c ／ `errorCallback^c
をとる。
◎
The File API’s methods taking various successCallback and errorCallback parameters
</li>
	<li>
Notifications API の
<a href="~NOTIFICATIONS#dom-notification-requestpermission">`requestPermission()^c</a>
~methodは、自身の~callbackを
`granted^l ／ `denied^l
で~callする。
◎
The Notifications API’s requestPermission method, which calls its callback with "granted" or "denied"
</li>
	<li>
Fullscreen API の
<a href="~FULLSCREEN#dom-element-requestfullscreen">`requestFullscreen()^c</a>
~methodは、文書~obj上に
`fullscreenchange^et ／ `fullscreenerror^et
~eventを誘発し、成功／失敗を検出するためには、それを~listenしなければならない。
◎
The Fullscreen API’s requestFullscreen method, which triggers onfullscreenchange or onfullscreenerror events on the nearby document object that must be listened to in order to detect success or failure
</li>
	<li>
XMLHttpRequest の `send()$c ~methodは、複数回にわたり `readystatechange^et を誘発し，~objの各種~propertyを~status~情報で更新する
— ~~最終的な状態~遷移の成功／失敗を正確aに検出するためには、その情報を診なければならない。
◎
XMLHttpRequest’s send method, which triggers onreadystatechange multiple times and updates properties of the object with status information which must be consulted in order to accurately detect success or failure of the ultimate state transition
</li>
</ul>

<p>
【仕様の策定者は、】
これらに類似するような何かが少しでも見出されるなら、それは~~止めて，代わりに~promiseを利用するように。
◎
If you find yourself doing something even remotely similar to these, stop, and instead use promises.
</p>


	</section>

</main></div>
